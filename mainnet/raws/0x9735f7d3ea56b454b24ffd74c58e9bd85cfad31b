{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.13;\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0-rc.0) (token/ERC20/IERC20.sol)\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n/// @notice An error used to indicate that an argument passed to a function is illegal or\r\n///         inappropriate.\r\n///\r\n/// @param message The error message.\r\nerror IllegalArgument(string message);\r\n\r\n/// @notice An error used to indicate that a function has encountered an unrecoverable state.\r\n///\r\n/// @param message The error message.\r\nerror IllegalState(string message);\r\n\r\n/// @notice An error used to indicate that an operation is unsupported.\r\n///\r\n/// @param message The error message.\r\nerror UnsupportedOperation(string message);\r\n\r\n/// @notice An error used to indicate that a message sender tried to execute a privileged function.\r\n///\r\n/// @param message The error message.\r\nerror Unauthorized(string message);\r\n/// @title  Multicall\r\n/// @author Uniswap Labs\r\n///\r\n/// @notice Enables calling multiple methods in a single call to the contract\r\nabstract contract Multicall {\r\n    error MulticallFailed(bytes data, bytes result);\r\n\r\n    function multicall(\r\n        bytes[] calldata data\r\n    ) external payable returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n\r\n            if (!success) {\r\n                revert MulticallFailed(data[i], result);\r\n            }\r\n\r\n            results[i] = result;\r\n        }\r\n    }\r\n}\r\n/// @title  Mutex\r\n/// @author Alchemix Finance\r\n///\r\n/// @notice Provides a mutual exclusion lock for implementing contracts.\r\nabstract contract Mutex {\r\n    enum State {\r\n        RESERVED,\r\n        UNLOCKED,\r\n        LOCKED\r\n    }\r\n\r\n    /// @notice The lock state.\r\n    State private _lockState = State.UNLOCKED;\r\n\r\n    /// @dev A modifier which acquires the mutex.\r\n    modifier lock() {\r\n        _claimLock();\r\n\r\n        _;\r\n\r\n        _freeLock();\r\n    }\r\n\r\n    /// @dev Gets if the mutex is locked.\r\n    ///\r\n    /// @return if the mutex is locked.\r\n    function _isLocked() internal view returns (bool) {\r\n        return _lockState == State.LOCKED;\r\n    }\r\n\r\n    /// @dev Claims the lock. If the lock is already claimed, then this will revert.\r\n    function _claimLock() internal {\r\n        // Check that the lock has not been claimed yet.\r\n        if (_lockState != State.UNLOCKED) {\r\n            revert IllegalState(\"Lock already claimed\");\r\n        }\r\n\r\n        // Claim the lock.\r\n        _lockState = State.LOCKED;\r\n    }\r\n\r\n    /// @dev Frees the lock.\r\n    function _freeLock() internal {\r\n        _lockState = State.UNLOCKED;\r\n    }\r\n}\r\n\r\n/// @title  IERC20TokenReceiver\r\n/// @author Alchemix Finance\r\ninterface IERC20TokenReceiver {\r\n    /// @notice Informs implementors of this interface that an ERC20 token has been transferred.\r\n    ///\r\n    /// @param token The token that was transferred.\r\n    /// @param value The amount of the token that was transferred.\r\n    function onERC20Received(address token, uint256 value) external;\r\n}\r\ninterface IConvexBooster {\r\n    function deposit(uint256 pid, uint256 amount, bool stake) external returns (bool);\r\n    function withdraw(uint256 pid, uint256 amount) external returns (bool);\r\n}\r\ninterface IConvexRewards {\r\n    function rewardToken() external view returns (IERC20);\r\n    function earned(address account) external view returns (uint256);\r\n    function extraRewards(uint256 index) external view returns (address);\r\n    function balanceOf(address account) external returns(uint256);\r\n    function withdraw(uint256 amount, bool claim) external returns (bool);\r\n    function withdrawAndUnwrap(uint256 amount, bool claim) external returns (bool);\r\n    function getReward() external returns (bool);\r\n    function getReward(address recipient, bool claim) external returns (bool);\r\n    function stake(uint256 amount) external returns (bool);\r\n    function stakeFor(address account, uint256 amount) external returns (bool);\r\n}\r\ninterface IConvexToken is IERC20 {\r\n    function maxSupply() external view returns (uint256);\r\n    function totalCliffs() external view returns (uint256);\r\n    function reductionPerCliff() external view returns (uint256);\r\n}\r\n\r\n/// @dev TODO\r\nuint256 constant NUM_META_COINS = 2;\r\n\r\ninterface IStableMetaPool is IERC20 {\r\n    function get_balances() external view returns (uint256[NUM_META_COINS] memory);\r\n\r\n    function coins(uint256 index) external view returns (IERC20);\r\n\r\n    function A() external view returns (uint256);\r\n\r\n    function get_virtual_price() external view returns (uint256);\r\n\r\n    function calc_token_amount(\r\n        uint256[NUM_META_COINS] calldata amounts,\r\n        bool deposit\r\n    ) external view returns (uint256 amount);\r\n\r\n    function add_liquidity(\r\n        uint256[NUM_META_COINS] calldata amounts,\r\n        uint256 minimumMintAmount\r\n    ) external returns (uint256 minted);\r\n\r\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256 dy);\r\n\r\n    function get_dy_underlying(int128 i, int128 j, uint256 dx, uint256[NUM_META_COINS] calldata balances) external view returns (uint256 dy);\r\n\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 minimumDy) external returns (uint256);\r\n\r\n    function remove_liquidity(uint256 amount, uint256[NUM_META_COINS] calldata minimumAmounts) external;\r\n\r\n    function remove_liquidity_imbalance(\r\n        uint256[NUM_META_COINS] calldata amounts,\r\n        uint256 maximumBurnAmount\r\n    ) external returns (uint256);\r\n\r\n    function calc_withdraw_one_coin(uint256 tokenAmount, int128 i) external view returns (uint256);\r\n\r\n    function remove_liquidity_one_coin(\r\n        uint256 tokenAmount,\r\n        int128 i,\r\n        uint256 minimumAmount\r\n    ) external returns (uint256);\r\n\r\n    function get_price_cumulative_last() external view returns (uint256[NUM_META_COINS] calldata);\r\n\r\n    function block_timestamp_last() external view returns (uint256);\r\n\r\n    function get_twap_balances(\r\n        uint256[NUM_META_COINS] calldata firstBalances,\r\n        uint256[NUM_META_COINS] calldata lastBalances,\r\n        uint256 timeElapsed\r\n    ) external view returns (uint256[NUM_META_COINS] calldata);\r\n\r\n    function get_dy(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256[NUM_META_COINS] calldata balances\r\n    ) external view returns (uint256);\r\n}\r\n\r\nuint256 constant NUM_STABLE_COINS = 3;\r\n\r\ninterface IStableSwap3Pool {\r\n    function coins(uint256 index) external view returns (IERC20);\r\n\r\n    function A() external view returns (uint256);\r\n\r\n    function get_virtual_price() external view returns (uint256);\r\n\r\n    function calc_token_amount(\r\n        uint256[NUM_STABLE_COINS] calldata amounts,\r\n        bool deposit\r\n    ) external view returns (uint256 amount);\r\n\r\n    function add_liquidity(uint256[NUM_STABLE_COINS] calldata amounts, uint256 minimumMintAmount) external;\r\n\r\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256 dy);\r\n\r\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256 dy);\r\n\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 minimumDy) external returns (uint256);\r\n\r\n    function remove_liquidity(uint256 amount, uint256[NUM_STABLE_COINS] calldata minimumAmounts) external;\r\n\r\n    function remove_liquidity_imbalance(\r\n        uint256[NUM_STABLE_COINS] calldata amounts,\r\n        uint256 maximumBurnAmount\r\n    ) external;\r\n\r\n    function calc_withdraw_one_coin(uint256 tokenAmount, int128 i) external view returns (uint256);\r\n\r\n    function remove_liquidity_one_coin(\r\n        uint256 tokenAmount,\r\n        int128 i,\r\n        uint256 minimumAmount\r\n    ) external;\r\n}\r\n\r\n/// @title  IERC20Metadata\r\n/// @author Alchemix Finance\r\ninterface IERC20Metadata {\r\n    /// @notice Gets the name of the token.\r\n    ///\r\n    /// @return The name.\r\n    function name() external view returns (string memory);\r\n\r\n    /// @notice Gets the symbol of the token.\r\n    ///\r\n    /// @return The symbol.\r\n    function symbol() external view returns (string memory);\r\n\r\n    /// @notice Gets the number of decimals that the token has.\r\n    ///\r\n    /// @return The number of decimals.\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n/// @title  SafeERC20\r\n/// @author Alchemix Finance\r\nlibrary SafeERC20 {\r\n    /// @notice An error used to indicate that a call to an ERC20 contract failed.\r\n    ///\r\n    /// @param target  The target address.\r\n    /// @param success If the call to the token was a success.\r\n    /// @param data    The resulting data from the call. This is error data when the call was not a\r\n    ///                success. Otherwise, this is malformed data when the call was a success.\r\n    error ERC20CallFailed(address target, bool success, bytes data);\r\n\r\n    /// @dev A safe function to get the decimals of an ERC20 token.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the query fails or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token The target token.\r\n    ///\r\n    /// @return The amount of decimals of the token.\r\n    function expectDecimals(address token) internal view returns (uint8) {\r\n        (bool success, bytes memory data) = token.staticcall(\r\n            abi.encodeWithSelector(IERC20Metadata.decimals.selector)\r\n        );\r\n\r\n        if (!success || data.length < 32) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n\r\n        return abi.decode(data, (uint8));\r\n    }\r\n\r\n    /// @dev Transfers tokens to another address.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer failed or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token     The token to transfer.\r\n    /// @param recipient The address of the recipient.\r\n    /// @param amount    The amount of tokens to transfer.\r\n    function safeTransfer(address token, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(IERC20.transfer.selector, recipient, amount)\r\n        );\r\n\r\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n    }\r\n\r\n    /// @dev Approves tokens for the smart contract.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the approval fails or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token   The token to approve.\r\n    /// @param spender The contract to spend the tokens.\r\n    /// @param value   The amount of tokens to approve.\r\n    function safeApprove(address token, address spender, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(IERC20.approve.selector, spender, value)\r\n        );\r\n\r\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n    }\r\n\r\n    /// @dev Transfer tokens from one address to another address.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer fails or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token     The token to transfer.\r\n    /// @param owner     The address of the owner.\r\n    /// @param recipient The address of the recipient.\r\n    /// @param amount    The amount of tokens to transfer.\r\n    function safeTransferFrom(address token, address owner, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(IERC20.transferFrom.selector, owner, recipient, amount)\r\n        );\r\n\r\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice A struct used to define initialization parameters. This is not included\r\n///         in the contract to prevent naming collisions.\r\nstruct InitializationParams {\r\n    address admin;\r\n    address operator;\r\n    address rewardReceiver;\r\n    address transmuterBuffer;\r\n    IERC20 curveToken;\r\n    IStableSwap3Pool threePool;\r\n    IStableMetaPool metaPool;\r\n    uint256 threePoolSlippage;\r\n    uint256 metaPoolSlippage;\r\n    IConvexToken convexToken;\r\n    IConvexBooster convexBooster;\r\n    IConvexRewards convexRewards;\r\n    uint256 convexPoolId;\r\n}\r\n\r\n/// @dev The amount of precision that slippage parameters have.\r\nuint256 constant SLIPPAGE_PRECISION = 1e4;\r\n\r\n/// @dev The amount of precision that curve pools use for price calculations.\r\nuint256 constant CURVE_PRECISION = 1e18;\r\n\r\n/// @notice Enumerations for 3pool assets.\r\n///\r\n/// @dev Do not change the order of these fields.\r\nenum ThreePoolAsset {\r\n    DAI, USDC, USDT\r\n}\r\n\r\n/// @notice Enumerations for meta pool assets.\r\n///\r\n/// @dev Do not change the order of these fields.\r\nenum MetaPoolAsset {\r\n    ALUSD, THREE_POOL\r\n}\r\n\r\n/// @title  ThreePoolAssetManager\r\n/// @author Alchemix Finance\r\ncontract ThreePoolAssetManager is Multicall, Mutex, IERC20TokenReceiver {\r\n    /// @notice Emitted when the admin is updated.\r\n    ///\r\n    /// @param admin The admin.\r\n    event AdminUpdated(address admin);\r\n\r\n    /// @notice Emitted when the pending admin is updated.\r\n    ///\r\n    /// @param pendingAdmin The pending admin.\r\n    event PendingAdminUpdated(address pendingAdmin);\r\n\r\n    /// @notice Emitted when the operator is updated.\r\n    ///\r\n    /// @param operator The operator.\r\n    event OperatorUpdated(address operator);\r\n\r\n    /// @notice Emitted when the reward receiver is updated.\r\n    ///\r\n    /// @param rewardReceiver The reward receiver.\r\n    event RewardReceiverUpdated(address rewardReceiver);\r\n\r\n    /// @notice Emitted when the transmuter buffer is updated.\r\n    ///\r\n    /// @param transmuterBuffer The transmuter buffer.\r\n    event TransmuterBufferUpdated(address transmuterBuffer);\r\n\r\n    /// @notice Emitted when the 3pool slippage is updated.\r\n    ///\r\n    /// @param threePoolSlippage The 3pool slippage.\r\n    event ThreePoolSlippageUpdated(uint256 threePoolSlippage);\r\n\r\n    /// @notice Emitted when the meta pool slippage is updated.\r\n    ///\r\n    /// @param metaPoolSlippage The meta pool slippage.\r\n    event MetaPoolSlippageUpdated(uint256 metaPoolSlippage);\r\n\r\n    /// @notice Emitted when 3pool tokens are minted.\r\n    ///\r\n    /// @param amounts               The amounts of each 3pool asset used to mint liquidity.\r\n    /// @param mintedThreePoolTokens The amount of 3pool tokens minted.\r\n    event MintThreePoolTokens(uint256[NUM_STABLE_COINS] amounts, uint256 mintedThreePoolTokens);\r\n\r\n    /// @notice Emitted when 3pool tokens are minted.\r\n    ///\r\n    /// @param asset                 The 3pool asset used to mint 3pool tokens.\r\n    /// @param amount                The amount of the asset used to mint 3pool tokens.\r\n    /// @param mintedThreePoolTokens The amount of 3pool tokens minted.\r\n    event MintThreePoolTokens(ThreePoolAsset asset, uint256 amount, uint256 mintedThreePoolTokens);\r\n\r\n    /// @notice Emitted when 3pool tokens are burned.\r\n    ///\r\n    /// @param asset     The 3pool asset that was received.\r\n    /// @param amount    The amount of 3pool tokens that were burned.\r\n    /// @param withdrawn The amount of the 3pool asset that was withdrawn.\r\n    event BurnThreePoolTokens(ThreePoolAsset asset, uint256 amount, uint256 withdrawn);\r\n\r\n    /// @notice Emitted when meta pool tokens are minted.\r\n    ///\r\n    /// @param amounts               The amounts of each meta pool asset used to mint liquidity.\r\n    /// @param mintedThreePoolTokens The amount of meta pool tokens minted.\r\n    event MintMetaPoolTokens(uint256[NUM_META_COINS] amounts, uint256 mintedThreePoolTokens);\r\n\r\n    /// @notice Emitted when meta tokens are minted.\r\n    ///\r\n    /// @param asset  The asset used to mint meta pool tokens.\r\n    /// @param amount The amount of the asset used to mint meta pool tokens.\r\n    /// @param minted The amount of meta pool tokens minted.\r\n    event MintMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 minted);\r\n\r\n    /// @notice Emitted when meta pool tokens are burned.\r\n    ///\r\n    /// @param asset     The meta pool asset that was received.\r\n    /// @param amount    The amount of meta pool tokens that were burned.\r\n    /// @param withdrawn The amount of the asset that was withdrawn.\r\n    event BurnMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 withdrawn);\r\n\r\n    /// @notice Emitted when meta pool tokens are deposited into convex.\r\n    ///\r\n    /// @param amount  The amount of meta pool tokens that were deposited.\r\n    /// @param success If the operation was successful.\r\n    event DepositMetaPoolTokens(uint256 amount, bool success);\r\n\r\n    /// @notice Emitted when meta pool tokens are withdrawn from convex.\r\n    ///\r\n    /// @param amount  The amount of meta pool tokens that were withdrawn.\r\n    /// @param success If the operation was successful.\r\n    event WithdrawMetaPoolTokens(uint256 amount, bool success);\r\n\r\n    /// @notice Emitted when convex rewards are claimed.\r\n    ///\r\n    /// @param success      If the operation was successful.\r\n    /// @param amountCurve  The amount of curve tokens sent to the reward recipient.\r\n    /// @param amountConvex The amount of convex tokens sent to the reward recipient.\r\n    event ClaimRewards(bool success, uint256 amountCurve, uint256 amountConvex);\r\n\r\n    /// @notice Emitted when 3pool assets are sent to the transmuter buffer.\r\n    ///\r\n    /// @param asset  The 3pool asset that was reclaimed.\r\n    /// @param amount The amount of the asset that was reclaimed.\r\n    event ReclaimThreePoolAsset(ThreePoolAsset asset, uint256 amount);\r\n\r\n    /// @notice The admin.\r\n    address public admin;\r\n\r\n    /// @notice The current pending admin.\r\n    address public pendingAdmin;\r\n\r\n    /// @notice The operator.\r\n    address public operator;\r\n\r\n    // @notice The reward receiver.\r\n    address public rewardReceiver;\r\n\r\n    /// @notice The transmuter buffer.\r\n    address public transmuterBuffer;\r\n\r\n    /// @notice The curve token.\r\n    IERC20 public immutable curveToken;\r\n\r\n    /// @notice The 3pool contract.\r\n    IStableSwap3Pool public immutable threePool;\r\n\r\n    /// @notice The meta pool contract.\r\n    IStableMetaPool public immutable metaPool;\r\n\r\n    /// @notice The amount of slippage that will be tolerated when depositing and withdrawing assets\r\n    ///         from the stable swap pool. In units of basis points.\r\n    uint256 public threePoolSlippage;\r\n\r\n    /// @notice The amount of slippage that will be tolerated when depositing and withdrawing assets\r\n    ///         from the meta pool. In units of basis points.\r\n    uint256 public metaPoolSlippage;\r\n\r\n    /// @notice The convex token.\r\n    IConvexToken public immutable convexToken;\r\n\r\n    /// @notice The convex booster contract.\r\n    IConvexBooster public immutable convexBooster;\r\n\r\n    /// @notice The convex rewards contract.\r\n    IConvexRewards public immutable convexRewards;\r\n\r\n    /// @notice The convex pool identifier.\r\n    uint256 public immutable convexPoolId;\r\n\r\n    /// @dev A cache of the tokens that the stable swap pool supports.\r\n    IERC20[NUM_STABLE_COINS] private _threePoolAssetCache;\r\n\r\n    /// @dev A cache of the tokens that the meta pool supports.\r\n    IERC20[NUM_META_COINS] private _metaPoolAssetCache;\r\n\r\n    /// @dev A modifier which reverts if the message sender is not the admin.\r\n    modifier onlyAdmin() {\r\n        if (msg.sender != admin) {\r\n            revert Unauthorized(\"Not admin\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev A modifier which reverts if the message sender is not the operator.\r\n    modifier onlyOperator() {\r\n        if (msg.sender != operator) {\r\n            revert Unauthorized(\"Not operator\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(InitializationParams memory params) {\r\n        admin             = params.admin;\r\n        operator          = params.operator;\r\n        rewardReceiver    = params.rewardReceiver;\r\n        transmuterBuffer  = params.transmuterBuffer;\r\n        curveToken        = params.curveToken;\r\n        threePool         = params.threePool;\r\n        metaPool          = params.metaPool;\r\n        threePoolSlippage = params.threePoolSlippage;\r\n        metaPoolSlippage  = params.metaPoolSlippage;\r\n        convexToken       = params.convexToken;\r\n        convexBooster     = params.convexBooster;\r\n        convexRewards     = params.convexRewards;\r\n        convexPoolId      = params.convexPoolId;\r\n\r\n        for (uint256 i = 0; i < NUM_STABLE_COINS; i++) {\r\n            _threePoolAssetCache[i] = params.threePool.coins(i);\r\n        }\r\n\r\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\r\n            _metaPoolAssetCache[i] = params.metaPool.coins(i);\r\n        }\r\n\r\n        emit AdminUpdated(admin);\r\n        emit OperatorUpdated(operator);\r\n        emit RewardReceiverUpdated(rewardReceiver);\r\n        emit TransmuterBufferUpdated(transmuterBuffer);\r\n        emit ThreePoolSlippageUpdated(threePoolSlippage);\r\n        emit MetaPoolSlippageUpdated(metaPoolSlippage);\r\n    }\r\n\r\n    /// @notice Gets the amount of meta pool tokens that this contract has in reserves.\r\n    ///\r\n    /// @return The reserves.\r\n    function metaPoolReserves() external view returns (uint256) {\r\n        return metaPool.balanceOf(address(this));\r\n    }\r\n\r\n    /// @notice Gets the amount of a 3pool asset that this contract has in reserves.\r\n    ///\r\n    /// @param asset The 3pool asset.\r\n    ///\r\n    /// @return The reserves.\r\n    function threePoolAssetReserves(ThreePoolAsset asset) external view returns (uint256) {\r\n        IERC20 token = getTokenForThreePoolAsset(asset);\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    /// @notice Gets the amount of a meta pool asset that this contract has in reserves.\r\n    ///\r\n    /// @param asset The meta pool asset.\r\n    ///\r\n    /// @return The reserves.\r\n    function metaPoolAssetReserves(MetaPoolAsset asset) external view returns (uint256) {\r\n        IERC20 token = getTokenForMetaPoolAsset(asset);\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    /// @notice Gets the amount of a 3pool asset that one alUSD is worth.\r\n    ///\r\n    /// @param asset The 3pool asset.\r\n    ///\r\n    /// @return The amount of the underying.\r\n    function exchangeRate(ThreePoolAsset asset) public view returns (uint256) {\r\n        IERC20 alUSD = getTokenForMetaPoolAsset(MetaPoolAsset.ALUSD);\r\n\r\n        uint256[NUM_META_COINS] memory metaBalances = metaPool.get_balances();\r\n        uint256 amountThreePool = metaPool.get_dy(\r\n            int128(uint128(uint256(MetaPoolAsset.ALUSD))),\r\n            int128(uint128(uint256(MetaPoolAsset.THREE_POOL))),\r\n            10**SafeERC20.expectDecimals(address(alUSD)),\r\n            metaBalances\r\n        );\r\n\r\n        return threePool.calc_withdraw_one_coin(amountThreePool, int128(uint128(uint256(asset))));\r\n    }\r\n\r\n    /// @dev Struct used to declare local variables for the calculate rebalance function.\r\n    struct CalculateRebalanceLocalVars {\r\n        uint256 minimum;\r\n        uint256 maximum;\r\n        uint256 minimumDistance;\r\n        uint256 minimizedBalance;\r\n        uint256 startingBalance;\r\n    }\r\n\r\n    /// @notice Calculates how much alUSD or 3pool needs to be added or removed from the metapool\r\n    ///         to reach a target exchange rate for a specified 3pool asset.\r\n    ///\r\n    /// @param rebalanceAsset      The meta pool asset to use to rebalance the pool.\r\n    /// @param targetExchangeAsset The 3pool asset to balance the price relative to.\r\n    /// @param targetExchangeRate  The target exchange rate.\r\n    ///\r\n    /// @return delta The amount of alUSD or 3pool that needs to be added or removed from the pool.\r\n    /// @return add   If the alUSD or 3pool needs to be removed or added.\r\n    function calculateRebalance(\r\n        MetaPoolAsset rebalanceAsset,\r\n        ThreePoolAsset targetExchangeAsset,\r\n        uint256 targetExchangeRate\r\n    ) public view returns (uint256 delta, bool add) {\r\n        uint256 decimals;\r\n        {\r\n            IERC20 alUSD = getTokenForMetaPoolAsset(MetaPoolAsset.ALUSD);\r\n            decimals     = SafeERC20.expectDecimals(address(alUSD));\r\n        }\r\n\r\n        uint256[NUM_META_COINS] memory startingBalances = metaPool.get_balances();\r\n        uint256[NUM_META_COINS] memory currentBalances  = [startingBalances[0], startingBalances[1]];\r\n\r\n        CalculateRebalanceLocalVars memory v;\r\n        v.minimum          = 0;\r\n        v.maximum          = type(uint96).max;\r\n        v.minimumDistance  = type(uint256).max;\r\n        v.minimizedBalance = type(uint256).max;\r\n        v.startingBalance  = startingBalances[uint256(rebalanceAsset)];\r\n\r\n        uint256 previousBalance;\r\n\r\n        for (uint256 i = 0; i < 256; i++) {\r\n            uint256 examineBalance;\r\n            if ((examineBalance = (v.maximum + v.minimum) / 2) == previousBalance) break;\r\n\r\n            currentBalances[uint256(rebalanceAsset)] = examineBalance;\r\n\r\n            uint256 amountThreePool = metaPool.get_dy(\r\n                int128(uint128(uint256(MetaPoolAsset.ALUSD))),\r\n                int128(uint128(uint256(MetaPoolAsset.THREE_POOL))),\r\n                10**decimals,\r\n                currentBalances\r\n            );\r\n\r\n            uint256 exchangeRate = threePool.calc_withdraw_one_coin(\r\n                amountThreePool,\r\n                int128(uint128(uint256(targetExchangeAsset)))\r\n            );\r\n\r\n            uint256 distance = abs(exchangeRate, targetExchangeRate);\r\n\r\n            if (distance < v.minimumDistance) {\r\n                v.minimumDistance  = distance;\r\n                v.minimizedBalance = examineBalance;\r\n            } else if(distance == v.minimumDistance) {\r\n                uint256 examineDelta = abs(examineBalance, v.startingBalance);\r\n                uint256 currentDelta = abs(v.minimizedBalance, v.startingBalance);\r\n                v.minimizedBalance = currentDelta > examineDelta ? examineBalance : v.minimizedBalance;\r\n            }\r\n\r\n            if (exchangeRate > targetExchangeRate) {\r\n                if (rebalanceAsset == MetaPoolAsset.ALUSD) {\r\n                    v.minimum = examineBalance;\r\n                } else {\r\n                    v.maximum = examineBalance;\r\n                }\r\n            } else {\r\n                if (rebalanceAsset == MetaPoolAsset.ALUSD) {\r\n                    v.maximum = examineBalance;\r\n                } else {\r\n                    v.minimum = examineBalance;\r\n                }\r\n            }\r\n\r\n            previousBalance = examineBalance;\r\n        }\r\n\r\n        return v.minimizedBalance > v.startingBalance\r\n            ? (v.minimizedBalance - v.startingBalance, true)\r\n            : (v.startingBalance - v.minimizedBalance, false);\r\n    }\r\n\r\n    /// @notice Gets the amount of curve tokens and convex tokens that can be claimed.\r\n    ///\r\n    /// @return amountCurve  The amount of curve tokens available.\r\n    /// @return amountConvex The amount of convex tokens available.\r\n    function claimableRewards() public view returns (uint256 amountCurve, uint256 amountConvex) {\r\n        amountCurve  = convexRewards.earned(address(this));\r\n        amountConvex = _getEarnedConvex(amountCurve);\r\n    }\r\n\r\n    /// @notice Gets the ERC20 token associated with a 3pool asset.\r\n    ///\r\n    /// @param asset The asset to get the token for.\r\n    ///\r\n    /// @return The token.\r\n    function getTokenForThreePoolAsset(ThreePoolAsset asset) public view returns (IERC20) {\r\n        uint256 index = uint256(asset);\r\n        if (index >= NUM_STABLE_COINS) {\r\n            revert IllegalArgument(\"Asset index out of bounds\");\r\n        }\r\n        return _threePoolAssetCache[index];\r\n    }\r\n\r\n    /// @notice Gets the ERC20 token associated with a meta pool asset.\r\n    ///\r\n    /// @param asset The asset to get the token for.\r\n    ///\r\n    /// @return The token.\r\n    function getTokenForMetaPoolAsset(MetaPoolAsset asset) public view returns (IERC20) {\r\n        uint256 index = uint256(asset);\r\n        if (index >= NUM_META_COINS) {\r\n            revert IllegalArgument(\"Asset index out of bounds\");\r\n        }\r\n        return _metaPoolAssetCache[index];\r\n    }\r\n\r\n    /// @notice Begins the 2-step process of setting the administrator.\r\n    ///\r\n    /// The caller must be the admin. Setting the pending timelock to the zero address will stop\r\n    /// the process of setting a new timelock.\r\n    ///\r\n    /// @param value The value to set the pending timelock to.\r\n    function setPendingAdmin(address value) external onlyAdmin {\r\n        pendingAdmin = value;\r\n        emit PendingAdminUpdated(value);\r\n    }\r\n\r\n    /// @notice Completes the 2-step process of setting the administrator.\r\n    ///\r\n    /// The pending admin must be set and the caller must be the pending admin. After this function\r\n    /// is successfully executed, the admin will be set to the pending admin and the pending admin\r\n    /// will be reset.\r\n    function acceptAdmin() external {\r\n        if (pendingAdmin == address(0)) {\r\n            revert IllegalState(\"Pending admin unset\");\r\n        }\r\n\r\n        if (pendingAdmin != msg.sender) {\r\n            revert Unauthorized(\"Not pending admin\");\r\n        }\r\n\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n\r\n        emit AdminUpdated(admin);\r\n        emit PendingAdminUpdated(address(0));\r\n    }\r\n\r\n    /// @notice Sets the operator.\r\n    ///\r\n    /// The caller must be the admin.\r\n    ///\r\n    /// @param value The value to set the admin to.\r\n    function setOperator(address value) external onlyAdmin {\r\n        operator = value;\r\n        emit OperatorUpdated(value);\r\n    }\r\n\r\n    /// @notice Sets the reward receiver.\r\n    ///\r\n    /// @param value The value to set the reward receiver to.\r\n    function setRewardReceiver(address value) external onlyAdmin {\r\n        rewardReceiver = value;\r\n        emit RewardReceiverUpdated(value);\r\n    }\r\n\r\n    /// @notice Sets the transmuter buffer.\r\n    ///\r\n    /// @param value The value to set the transmuter buffer to.\r\n    function setTransmuterBuffer(address value) external onlyAdmin {\r\n        transmuterBuffer = value;\r\n        emit TransmuterBufferUpdated(value);\r\n    }\r\n\r\n    /// @notice Sets the slippage that will be tolerated when depositing and withdrawing 3pool\r\n    ///         assets. The slippage has a resolution of 6 decimals.\r\n    ///\r\n    /// The operator is allowed to set the slippage because it is a volatile parameter that may need\r\n    /// fine adjustment in a short time window.\r\n    ///\r\n    /// @param value The value to set the slippage to.\r\n    function setThreePoolSlippage(uint256 value) external onlyOperator {\r\n        if (value > SLIPPAGE_PRECISION) {\r\n            revert IllegalArgument(\"Slippage not in range\");\r\n        }\r\n        threePoolSlippage = value;\r\n        emit ThreePoolSlippageUpdated(value);\r\n    }\r\n\r\n    /// @notice Sets the slippage that will be tolerated when depositing and withdrawing meta pool\r\n    ///         assets. The slippage has a resolution of 6 decimals.\r\n    ///\r\n    /// The operator is allowed to set the slippage because it is a volatile parameter that may need\r\n    /// fine adjustment in a short time window.\r\n    ///\r\n    /// @param value The value to set the slippage to.\r\n    function setMetaPoolSlippage(uint256 value) external onlyOperator {\r\n        if (value > SLIPPAGE_PRECISION) {\r\n            revert IllegalArgument(\"Slippage not in range\");\r\n        }\r\n        metaPoolSlippage = value;\r\n        emit MetaPoolSlippageUpdated(value);\r\n    }\r\n\r\n    /// @notice Mints 3pool tokens with a combination of assets.\r\n    ///\r\n    /// @param amounts The amounts of the assets to deposit.\r\n    ///\r\n    /// @return minted The number of 3pool tokens minted.\r\n    function mintThreePoolTokens(\r\n        uint256[NUM_STABLE_COINS] calldata amounts\r\n    ) external lock onlyOperator returns (uint256 minted) {\r\n        return _mintThreePoolTokens(amounts);\r\n    }\r\n\r\n    /// @notice Mints 3pool tokens with an asset.\r\n    ///\r\n    /// @param asset  The asset to deposit into the 3pool.\r\n    /// @param amount The amount of the asset to deposit.\r\n    ///\r\n    /// @return minted The number of 3pool tokens minted.\r\n    function mintThreePoolTokens(\r\n        ThreePoolAsset asset,\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (uint256 minted) {\r\n        return _mintThreePoolTokens(asset, amount);\r\n    }\r\n\r\n    /// @notice Burns 3pool tokens to withdraw an asset.\r\n    ///\r\n    /// @param asset  The asset to withdraw.\r\n    /// @param amount The amount of 3pool tokens to burn.\r\n    ///\r\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\r\n    function burnThreePoolTokens(\r\n        ThreePoolAsset asset,\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (uint256 withdrawn) {\r\n        return _burnThreePoolTokens(asset, amount);\r\n    }\r\n\r\n    /// @notice Mints meta pool tokens with a combination of assets.\r\n    ///\r\n    /// @param amounts The amounts of the assets to deposit.\r\n    ///\r\n    /// @return minted The number of meta pool tokens minted.\r\n    function mintMetaPoolTokens(\r\n        uint256[NUM_META_COINS] calldata amounts\r\n    ) external lock onlyOperator returns (uint256 minted) {\r\n        return _mintMetaPoolTokens(amounts);\r\n    }\r\n\r\n    /// @notice Mints meta pool tokens with an asset.\r\n    ///\r\n    /// @param asset  The asset to deposit into the meta pool.\r\n    /// @param amount The amount of the asset to deposit.\r\n    ///\r\n    /// @return minted The number of meta pool tokens minted.\r\n    function mintMetaPoolTokens(\r\n        MetaPoolAsset asset,\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (uint256 minted) {\r\n        return _mintMetaPoolTokens(asset, amount);\r\n    }\r\n\r\n    /// @notice Burns meta pool tokens to withdraw an asset.\r\n    ///\r\n    /// @param asset  The asset to withdraw.\r\n    /// @param amount The amount of meta pool tokens to burn.\r\n    ///\r\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\r\n    function burnMetaPoolTokens(\r\n        MetaPoolAsset asset,\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (uint256 withdrawn) {\r\n        return _burnMetaPoolTokens(asset, amount);\r\n    }\r\n\r\n    /// @notice Deposits and stakes meta pool tokens into convex.\r\n    ///\r\n    /// @param amount The amount of meta pool tokens to deposit.\r\n    ///\r\n    /// @return success If the tokens were successfully deposited.\r\n    function depositMetaPoolTokens(\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (bool success) {\r\n        return _depositMetaPoolTokens(amount);\r\n    }\r\n\r\n    /// @notice Withdraws and unwraps meta pool tokens from convex.\r\n    ///\r\n    /// @param amount The amount of meta pool tokens to withdraw.\r\n    ///\r\n    /// @return success If the tokens were successfully withdrawn.\r\n    function withdrawMetaPoolTokens(\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (bool success) {\r\n        return _withdrawMetaPoolTokens(amount);\r\n    }\r\n\r\n    /// @notice Claims convex, curve, and auxiliary rewards.\r\n    ///\r\n    /// @return success If the claim was successful.\r\n    function claimRewards() external lock onlyOperator returns (bool success) {\r\n        success = convexRewards.getReward();\r\n\r\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\r\n        uint256 convexBalance = convexToken.balanceOf(address(this));\r\n\r\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\r\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\r\n\r\n        emit ClaimRewards(success, curveBalance, convexBalance);\r\n    }\r\n\r\n    /// @notice Flushes three pool assets into convex by minting 3pool tokens from the assets,\r\n    ///         minting meta pool tokens using the 3pool tokens, and then depositing the meta pool\r\n    ///         tokens into convex.\r\n    ///\r\n    /// This function is provided for ease of use.\r\n    ///\r\n    /// @param amounts The amounts of the 3pool assets to flush.\r\n    ///\r\n    /// @return The amount of meta pool tokens deposited into convex.\r\n    function flush(\r\n        uint256[NUM_STABLE_COINS] calldata amounts\r\n    ) external lock onlyOperator returns (uint256) {\r\n        uint256 mintedThreePoolTokens = _mintThreePoolTokens(amounts);\r\n\r\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(\r\n            MetaPoolAsset.THREE_POOL,\r\n            mintedThreePoolTokens\r\n        );\r\n\r\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\r\n            revert IllegalState(\"Deposit into convex failed\");\r\n        }\r\n\r\n        return mintedMetaPoolTokens;\r\n    }\r\n\r\n    /// @notice Flushes a three pool asset into convex by minting 3pool tokens using the asset,\r\n    ///         minting meta pool tokens using the 3pool tokens, and then depositing the meta pool\r\n    ///         tokens into convex.\r\n    ///\r\n    /// This function is provided for ease of use.\r\n    ///\r\n    /// @param asset  The 3pool asset to flush.\r\n    /// @param amount The amount of the 3pool asset to flush.\r\n    ///\r\n    /// @return The amount of meta pool tokens deposited into convex.\r\n    function flush(\r\n        ThreePoolAsset asset,\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (uint256) {\r\n        uint256 mintedThreePoolTokens = _mintThreePoolTokens(asset, amount);\r\n\r\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(\r\n            MetaPoolAsset.THREE_POOL,\r\n            mintedThreePoolTokens\r\n        );\r\n\r\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\r\n            revert IllegalState(\"Deposit into convex failed\");\r\n        }\r\n\r\n        return mintedMetaPoolTokens;\r\n    }\r\n\r\n    /// @notice Recalls a three pool asset into reserves by withdrawing meta pool tokens from\r\n    ///         convex, burning the meta pool tokens for 3pool tokens, and then burning the 3pool\r\n    ///         tokens for an asset.\r\n    ///\r\n    /// This function is provided for ease of use.\r\n    ///\r\n    /// @param asset  The 3pool asset to recall.\r\n    /// @param amount The amount of the meta pool tokens to withdraw from convex and burn.\r\n    ///\r\n    /// @return The amount of the 3pool asset recalled.\r\n    function recall(\r\n        ThreePoolAsset asset,\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (uint256) {\r\n        if (!_withdrawMetaPoolTokens(amount)) {\r\n            revert IllegalState(\"Withdraw from convex failed\");\r\n        }\r\n        uint256 withdrawnThreePoolTokens = _burnMetaPoolTokens(MetaPoolAsset.THREE_POOL, amount);\r\n        return _burnThreePoolTokens(asset, withdrawnThreePoolTokens);\r\n    }\r\n\r\n    /// @notice Reclaims a three pool asset to the transmuter buffer.\r\n    ///\r\n    /// @param asset  The 3pool asset to reclaim.\r\n    /// @param amount The amount to reclaim.\r\n    function reclaimThreePoolAsset(ThreePoolAsset asset, uint256 amount) public lock onlyAdmin {\r\n        IERC20 token = getTokenForThreePoolAsset(asset);\r\n        SafeERC20.safeTransfer(address(token), transmuterBuffer, amount);\r\n\r\n        IERC20TokenReceiver(transmuterBuffer).onERC20Received(address(token), amount);\r\n\r\n        emit ReclaimThreePoolAsset(asset, amount);\r\n    }\r\n\r\n    /// @notice Sweeps a token out of the contract to the admin.\r\n    ///\r\n    /// @param token  The token to sweep.\r\n    /// @param amount The amount of the token to sweep.\r\n    function sweep(address token, uint256 amount) external lock onlyAdmin {\r\n        SafeERC20.safeTransfer(address(token), msg.sender, amount);\r\n    }\r\n\r\n    /// @inheritdoc IERC20TokenReceiver\r\n    ///\r\n    /// @dev This function is required in order to receive tokens from the conduit.\r\n    function onERC20Received(address token, uint256 value) external { /* noop */ }\r\n\r\n    /// @dev Gets the amount of convex that will be minted for an amount of curve tokens.\r\n    ///\r\n    /// @param amountCurve The amount of curve tokens.\r\n    ///\r\n    /// @return The amount of convex tokens.\r\n    function _getEarnedConvex(uint256 amountCurve) internal view returns (uint256) {\r\n        uint256 supply      = convexToken.totalSupply();\r\n        uint256 cliff       = supply / convexToken.reductionPerCliff();\r\n        uint256 totalCliffs = convexToken.totalCliffs();\r\n\r\n        if (cliff >= totalCliffs) return 0;\r\n\r\n        uint256 reduction = totalCliffs - cliff;\r\n        uint256 earned    = amountCurve * reduction / totalCliffs;\r\n\r\n        uint256 available = convexToken.maxSupply() - supply;\r\n        return earned > available ? available : earned;\r\n    }\r\n\r\n    /// @dev Mints 3pool tokens with a combination of assets.\r\n    ///\r\n    /// @param amounts The amounts of the assets to deposit.\r\n    ///\r\n    /// @return minted The number of 3pool tokens minted.\r\n    function _mintThreePoolTokens(\r\n        uint256[NUM_STABLE_COINS] calldata amounts\r\n    ) internal returns (uint256 minted) {\r\n        IERC20[NUM_STABLE_COINS] memory tokens = _threePoolAssetCache;\r\n\r\n        IERC20 threePoolToken = getTokenForMetaPoolAsset(MetaPoolAsset.THREE_POOL);\r\n\r\n        uint256 threePoolDecimals = SafeERC20.expectDecimals(address(threePoolToken));\r\n        uint256 normalizedTotal   = 0;\r\n\r\n        for (uint256 i = 0; i < NUM_STABLE_COINS; i++) {\r\n            if (amounts[i] == 0) continue;\r\n\r\n            uint256 tokenDecimals   = SafeERC20.expectDecimals(address(tokens[i]));\r\n            uint256 missingDecimals = threePoolDecimals - tokenDecimals;\r\n\r\n            normalizedTotal += amounts[i] * 10**missingDecimals;\r\n\r\n            // For assets like USDT, the approval must be first set to zero before updating it.\r\n            SafeERC20.safeApprove(address(tokens[i]), address(threePool), 0);\r\n            SafeERC20.safeApprove(address(tokens[i]), address(threePool), amounts[i]);\r\n        }\r\n\r\n        // Calculate what the normalized value of the tokens is.\r\n        uint256 expectedOutput = normalizedTotal * CURVE_PRECISION / threePool.get_virtual_price();\r\n\r\n        // Calculate the minimum amount of 3pool lp tokens that we are expecting out when\r\n        // adding liquidity for all of the assets. This value is based off the optimistic\r\n        // assumption that one of each token is approximately equal to one 3pool lp token.\r\n        uint256 minimumMintAmount = expectedOutput * threePoolSlippage / SLIPPAGE_PRECISION;\r\n\r\n        // Record the amount of 3pool lp tokens that we start with before adding liquidity\r\n        // so that we can determine how many we minted.\r\n        uint256 startingBalance = threePoolToken.balanceOf(address(this));\r\n\r\n        // Add the liquidity to the pool.\r\n        threePool.add_liquidity(amounts, minimumMintAmount);\r\n\r\n        // Calculate how many 3pool lp tokens were minted.\r\n        minted = threePoolToken.balanceOf(address(this)) - startingBalance;\r\n\r\n        emit MintThreePoolTokens(amounts, minted);\r\n    }\r\n\r\n    /// @dev Mints 3pool tokens with an asset.\r\n    ///\r\n    /// @param asset  The asset to deposit into the 3pool.\r\n    /// @param amount The amount of the asset to deposit.\r\n    ///\r\n    /// @return minted The number of 3pool tokens minted.\r\n    function _mintThreePoolTokens(\r\n        ThreePoolAsset asset,\r\n        uint256 amount\r\n    ) internal returns (uint256 minted) {\r\n        IERC20 token          = getTokenForThreePoolAsset(asset);\r\n        IERC20 threePoolToken = getTokenForMetaPoolAsset(MetaPoolAsset.THREE_POOL);\r\n\r\n        uint256 threePoolDecimals = SafeERC20.expectDecimals(address(threePoolToken));\r\n        uint256 missingDecimals   = threePoolDecimals - SafeERC20.expectDecimals(address(token));\r\n\r\n        uint256[NUM_STABLE_COINS] memory amounts;\r\n        amounts[uint256(asset)] = amount;\r\n\r\n        // Calculate the minimum amount of 3pool lp tokens that we are expecting out when\r\n        // adding single sided liquidity. This value is based off the optimistic assumption that\r\n        // one of each token is approximately equal to one 3pool lp token.\r\n        uint256 normalizedAmount  = amount * 10**missingDecimals;\r\n        uint256 expectedOutput    = normalizedAmount * CURVE_PRECISION / threePool.get_virtual_price();\r\n        uint256 minimumMintAmount = expectedOutput * threePoolSlippage / SLIPPAGE_PRECISION;\r\n\r\n        // Record the amount of 3pool lp tokens that we start with before adding liquidity\r\n        // so that we can determine how many we minted.\r\n        uint256 startingBalance = threePoolToken.balanceOf(address(this));\r\n\r\n        // For assets like USDT, the approval must be first set to zero before updating it.\r\n        SafeERC20.safeApprove(address(token), address(threePool), 0);\r\n        SafeERC20.safeApprove(address(token), address(threePool), amount);\r\n\r\n        // Add the liquidity to the pool.\r\n        threePool.add_liquidity(amounts, minimumMintAmount);\r\n\r\n        // Calculate how many 3pool lp tokens were minted.\r\n        minted = threePoolToken.balanceOf(address(this)) - startingBalance;\r\n\r\n        emit MintThreePoolTokens(asset, amount, minted);\r\n    }\r\n\r\n    /// @dev Burns 3pool tokens to withdraw an asset.\r\n    ///\r\n    /// @param asset  The asset to withdraw.\r\n    /// @param amount The amount of 3pool tokens to burn.\r\n    ///\r\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\r\n    function _burnThreePoolTokens(\r\n        ThreePoolAsset asset,\r\n        uint256 amount\r\n    ) internal returns (uint256 withdrawn) {\r\n        IERC20 token          = getTokenForThreePoolAsset(asset);\r\n        IERC20 threePoolToken = getTokenForMetaPoolAsset(MetaPoolAsset.THREE_POOL);\r\n\r\n        uint256 index = uint256(asset);\r\n\r\n        uint256 threePoolDecimals = SafeERC20.expectDecimals(address(threePoolToken));\r\n        uint256 missingDecimals   = threePoolDecimals - SafeERC20.expectDecimals(address(token));\r\n\r\n        // Calculate the minimum amount of underlying tokens that we are expecting out when\r\n        // removing single sided liquidity. This value is based off the optimistic assumption that\r\n        // one of each token is approximately equal to one 3pool lp token.\r\n        uint256 normalizedAmount = amount * threePoolSlippage / SLIPPAGE_PRECISION;\r\n        uint256 expectedOutput   = normalizedAmount * threePool.get_virtual_price() / CURVE_PRECISION;\r\n        uint256 minimumAmountOut = expectedOutput / 10**missingDecimals;\r\n\r\n        // Record the amount of underlying tokens that we start with before removing liquidity\r\n        // so that we can determine how many we withdrew from the pool.\r\n        uint256 startingBalance = token.balanceOf(address(this));\r\n\r\n        SafeERC20.safeApprove(address(threePoolToken), address(threePool), 0);\r\n        SafeERC20.safeApprove(address(threePoolToken), address(threePool), amount);\r\n\r\n        // Remove the liquidity from the pool.\r\n        threePool.remove_liquidity_one_coin(amount, int128(uint128(index)), minimumAmountOut);\r\n\r\n        // Calculate how many underlying tokens that were withdrawn.\r\n        withdrawn = token.balanceOf(address(this)) - startingBalance;\r\n\r\n        emit BurnThreePoolTokens(asset, amount, withdrawn);\r\n    }\r\n\r\n    /// @dev Mints meta pool tokens with a combination of assets.\r\n    ///\r\n    /// @param amounts The amounts of the assets to deposit.\r\n    ///\r\n    /// @return minted The number of meta pool tokens minted.\r\n    function _mintMetaPoolTokens(\r\n        uint256[NUM_META_COINS] calldata amounts\r\n    ) internal returns (uint256 minted) {\r\n        IERC20[NUM_META_COINS] memory tokens = _metaPoolAssetCache;\r\n\r\n        uint256 total = 0;\r\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\r\n            if (amounts[i] == 0) continue;\r\n\r\n            total += amounts[i];\r\n\r\n            // For assets like USDT, the approval must be first set to zero before updating it.\r\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), 0);\r\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), amounts[i]);\r\n        }\r\n\r\n        // Calculate the minimum amount of 3pool lp tokens that we are expecting out when\r\n        // adding liquidity for all of the assets. This value is based off the optimistic\r\n        // assumption that one of each token is approximately equal to one 3pool lp token.\r\n        uint256 expectedOutput    = total * CURVE_PRECISION / metaPool.get_virtual_price();\r\n        uint256 minimumMintAmount = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\r\n\r\n        // Add the liquidity to the pool.\r\n        minted = metaPool.add_liquidity(amounts, minimumMintAmount);\r\n\r\n        emit MintMetaPoolTokens(amounts, minted);\r\n    }\r\n\r\n    /// @dev Mints meta pool tokens with an asset.\r\n    ///\r\n    /// @param asset  The asset to deposit into the meta pool.\r\n    /// @param amount The amount of the asset to deposit.\r\n    ///\r\n    /// @return minted The number of meta pool tokens minted.\r\n    function _mintMetaPoolTokens(\r\n        MetaPoolAsset asset,\r\n        uint256 amount\r\n    ) internal returns (uint256 minted) {\r\n        IERC20 token = getTokenForMetaPoolAsset(asset);\r\n\r\n        uint256[NUM_META_COINS] memory amounts;\r\n        amounts[uint256(asset)] = amount;\r\n\r\n        // Calculate the minimum amount of 3pool lp tokens that we are expecting out when\r\n        // adding single sided liquidity. This value is based off the optimistic assumption that\r\n        uint256 minimumMintAmount = amount * metaPoolSlippage / SLIPPAGE_PRECISION;\r\n\r\n        // For assets like USDT, the approval must be first set to zero before updating it.\r\n        SafeERC20.safeApprove(address(token), address(metaPool), 0);\r\n        SafeERC20.safeApprove(address(token), address(metaPool), amount);\r\n\r\n        // Add the liquidity to the pool.\r\n        minted = metaPool.add_liquidity(amounts, minimumMintAmount);\r\n\r\n        emit MintMetaPoolTokens(asset, amount, minted);\r\n    }\r\n\r\n    /// @dev Burns meta pool tokens to withdraw an asset.\r\n    ///\r\n    /// @param asset  The asset to withdraw.\r\n    /// @param amount The amount of meta pool tokens to burn.\r\n    ///\r\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\r\n    function _burnMetaPoolTokens(\r\n        MetaPoolAsset asset,\r\n        uint256 amount\r\n    ) internal returns (uint256 withdrawn) {\r\n        uint256 index = uint256(asset);\r\n\r\n        // Calculate the minimum amount of the meta pool asset that we are expecting out when\r\n        // removing single sided liquidity. This value is based off the optimistic assumption that\r\n        // one of each token is approximately equal to one meta pool lp token.\r\n        uint256 expectedOutput   = amount * metaPool.get_virtual_price() / CURVE_PRECISION;\r\n        uint256 minimumAmountOut = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\r\n\r\n        // Remove the liquidity from the pool.\r\n        withdrawn = metaPool.remove_liquidity_one_coin(\r\n            amount,\r\n            int128(uint128(index)),\r\n            minimumAmountOut\r\n        );\r\n\r\n        emit BurnMetaPoolTokens(asset, amount, withdrawn);\r\n    }\r\n\r\n    /// @dev Deposits and stakes meta pool tokens into convex.\r\n    ///\r\n    /// @param amount The amount of meta pool tokens to deposit.\r\n    ///\r\n    /// @return success If the tokens were successfully deposited.\r\n    function _depositMetaPoolTokens(uint256 amount) internal returns (bool success) {\r\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), 0);\r\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), amount);\r\n\r\n        success = convexBooster.deposit(convexPoolId, amount, true /* always stake into rewards */);\r\n\r\n        emit DepositMetaPoolTokens(amount, success);\r\n    }\r\n\r\n    /// @dev Withdraws and unwraps meta pool tokens from convex.\r\n    ///\r\n    /// @param amount The amount of meta pool tokens to withdraw.\r\n    ///\r\n    /// @return success If the tokens were successfully withdrawn.\r\n    function _withdrawMetaPoolTokens(uint256 amount) internal returns (bool success) {\r\n        success = convexRewards.withdrawAndUnwrap(amount, false /* never claim */);\r\n        emit WithdrawMetaPoolTokens(amount, success);\r\n    }\r\n\r\n    /// @dev Claims convex, curve, and auxiliary rewards.\r\n    ///\r\n    /// @return success If the claim was successful.\r\n    function _claimRewards() internal returns (bool success) {\r\n        success = convexRewards.getReward();\r\n\r\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\r\n        uint256 convexBalance = convexToken.balanceOf(address(this));\r\n\r\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\r\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\r\n\r\n        emit ClaimRewards(success, curveBalance, convexBalance);\r\n    }\r\n\r\n    /// @dev Gets the minimum of two integers.\r\n    ///\r\n    /// @param x The first integer.\r\n    /// @param y The second integer.\r\n    ///\r\n    /// @return The minimum value.\r\n    function min(uint256 x , uint256 y) private pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    /// @dev Gets the absolute value of the difference of two integers.\r\n    ///\r\n    /// @param x The first integer.\r\n    /// @param y The second integer.\r\n    ///\r\n    /// @return The absolute value.\r\n    function abs(uint256 x , uint256 y) private pure returns (uint256) {\r\n        return x > y ? x - y : y - x;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"transmuterBuffer\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"curveToken\",\"type\":\"address\"},{\"internalType\":\"contract IStableSwap3Pool\",\"name\":\"threePool\",\"type\":\"address\"},{\"internalType\":\"contract IStableMetaPool\",\"name\":\"metaPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"threePoolSlippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"metaPoolSlippage\",\"type\":\"uint256\"},{\"internalType\":\"contract IConvexToken\",\"name\":\"convexToken\",\"type\":\"address\"},{\"internalType\":\"contract IConvexBooster\",\"name\":\"convexBooster\",\"type\":\"address\"},{\"internalType\":\"contract IConvexRewards\",\"name\":\"convexRewards\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"convexPoolId\",\"type\":\"uint256\"}],\"internalType\":\"struct InitializationParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC20CallFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalArgument\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"name\":\"MulticallFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum MetaPoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"name\":\"BurnMetaPoolTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum ThreePoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"name\":\"BurnThreePoolTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountCurve\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountConvex\",\"type\":\"uint256\"}],\"name\":\"ClaimRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"DepositMetaPoolTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"metaPoolSlippage\",\"type\":\"uint256\"}],\"name\":\"MetaPoolSlippageUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedThreePoolTokens\",\"type\":\"uint256\"}],\"name\":\"MintMetaPoolTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum MetaPoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"}],\"name\":\"MintMetaPoolTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[3]\",\"name\":\"amounts\",\"type\":\"uint256[3]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedThreePoolTokens\",\"type\":\"uint256\"}],\"name\":\"MintThreePoolTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum ThreePoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedThreePoolTokens\",\"type\":\"uint256\"}],\"name\":\"MintThreePoolTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"PendingAdminUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum ThreePoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReclaimThreePoolAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardReceiver\",\"type\":\"address\"}],\"name\":\"RewardReceiverUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threePoolSlippage\",\"type\":\"uint256\"}],\"name\":\"ThreePoolSlippageUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"transmuterBuffer\",\"type\":\"address\"}],\"name\":\"TransmuterBufferUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"WithdrawMetaPoolTokens\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MetaPoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnMetaPoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ThreePoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnThreePoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MetaPoolAsset\",\"name\":\"rebalanceAsset\",\"type\":\"uint8\"},{\"internalType\":\"enum ThreePoolAsset\",\"name\":\"targetExchangeAsset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"targetExchangeRate\",\"type\":\"uint256\"}],\"name\":\"calculateRebalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"delta\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountCurve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountConvex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexBooster\",\"outputs\":[{\"internalType\":\"contract IConvexBooster\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexPoolId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexRewards\",\"outputs\":[{\"internalType\":\"contract IConvexRewards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexToken\",\"outputs\":[{\"internalType\":\"contract IConvexToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositMetaPoolTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ThreePoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"}],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"amounts\",\"type\":\"uint256[3]\"}],\"name\":\"flush\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ThreePoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"flush\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MetaPoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"}],\"name\":\"getTokenForMetaPoolAsset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ThreePoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"}],\"name\":\"getTokenForThreePoolAsset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metaPool\",\"outputs\":[{\"internalType\":\"contract IStableMetaPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MetaPoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"}],\"name\":\"metaPoolAssetReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metaPoolReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metaPoolSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MetaPoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintMetaPoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"}],\"name\":\"mintMetaPoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ThreePoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintThreePoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"amounts\",\"type\":\"uint256[3]\"}],\"name\":\"mintThreePoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"onERC20Received\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ThreePoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recall\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ThreePoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reclaimThreePoolAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMetaPoolSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setRewardReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setThreePoolSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setTransmuterBuffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"threePool\",\"outputs\":[{\"internalType\":\"contract IStableSwap3Pool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ThreePoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"}],\"name\":\"threePoolAssetReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"threePoolSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transmuterBuffer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawMetaPoolTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ThreePoolAssetManager", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008392f6669292fa56123f71949b52d883ae57e2250000000000000000000000009e2b6378ee8ad2a4a95fe481d63caba8fb0ebbf90000000000000000000000009e2b6378ee8ad2a4a95fe481d63caba8fb0ebbf90000000000000000000000001eed2dbeb9fc23ab483f447f38f289ca15f79bac000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd52000000000000000000000000bebc44782c7db0a1a60cb6fe97d0b483032ff1c700000000000000000000000043b4fdfd4ff969587185cdb6f0bd875c5fc83f8c00000000000000000000000000000000000000000000000000000000000026ed00000000000000000000000000000000000000000000000000000000000026ed0000000000000000000000004e3fbd56cd56c3e72c1403e103b45db9da5b9d2b000000000000000000000000f403c135812408bfbe8713b5a23a04b3d48aae3100000000000000000000000002e2151d4f351881017abdf2dd2b51150841d5b30000000000000000000000000000000000000000000000000000000000000024", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1c4db18572b044e9784659c06ca51c1f24e41f841dcebb131a4703e7180e72b5"}]}