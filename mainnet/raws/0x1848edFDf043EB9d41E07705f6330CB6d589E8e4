{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FlyzLOOKSCapacitor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport './interfaces/IFlyzTreasury.sol';\\n\\nimport './types/Ownable.sol';\\nimport './interfaces/IERC20.sol';\\n\\nimport './libraries/SafeMath.sol';\\nimport './libraries/SafeERC20.sol';\\n\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\n\\ninterface ILooksStaking {\\n    function userInfo(address user) external view returns (uint256, uint256, uint256);\\n    function deposit(uint256 amount, bool claimRewardToken) external;\\n    function withdraw(uint256 shares, bool claimRewardToken) external;\\n    function withdrawAll(bool claimRewardToken) external;\\n    function harvest() external;\\n}\\n\\ninterface IFlyzWrappedLOOKS is IERC20 {\\n    function mintTo(address to, uint256 amount) external;\\n    function burn(uint256 amount) external;\\n}\\n\\ncontract FlyzLOOKSCapacitor is Ownable {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    bool public autoStake;\\n    bool public autoHarvest;\\n\\n    address public immutable flyz;\\n    address public immutable flyzLP;\\n    address public immutable weth;\\n    address public immutable looks;\\n    address public immutable looksLP;\\n    address public immutable looksStaking;\\n    address public immutable wrappedLooks;\\n    address public immutable treasury;\\n    address public immutable swapRouter;\\n\\n    mapping(address => bool) private _depositors;\\n\\n    event DepositorAdded(address indexed depositor);\\n    event DepositorRemoved(address indexed depositor);\\n\\n    modifier onlyOnwerOrDepositor() {\\n        require(msg.sender == owner() || _depositors[msg.sender], \\\"Capacitor: Not owner or depositor\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _flyz,\\n        address _looks,\\n        address _looksStaking,\\n        address _wrappedLooks,\\n        address _treasury,\\n        address _router\\n    ) {\\n        flyz = _flyz;\\n        looks = _looks;\\n        wrappedLooks = _wrappedLooks;\\n        looksStaking = _looksStaking;\\n        treasury = _treasury;\\n        autoStake = true;\\n\\n        IUniswapV2Router02 _swapRouter = IUniswapV2Router02(_router);\\n        IUniswapV2Factory _factory = IUniswapV2Factory(_swapRouter.factory());\\n        address _weth = _swapRouter.WETH();\\n        address _flyzLP = _factory.getPair(_flyz, _weth);\\n        address _looksLP = _factory.getPair(_looks, _weth);\\n\\n        swapRouter = _router;\\n        weth = _weth;\\n        flyzLP = _flyzLP;\\n        looksLP = _looksLP;\\n\\n        IERC20(_looks).approve(_looksStaking,  uint256(-1));\\n        IERC20(_looks).approve(_router,  uint256(-1));\\n        IERC20(_flyz).approve(_router,  uint256(-1));\\n        IERC20(_weth).approve(_router,  uint256(-1));\\n        IERC20(_flyz).approve(_treasury,  uint256(-1));\\n        IERC20(_flyzLP).approve(_treasury,  uint256(-1));\\n        IERC20(_looks).approve(_treasury,  uint256(-1));\\n        IERC20(_wrappedLooks).approve(_treasury,  uint256(-1));\\n    }\\n\\n    /**\\n     * @notice returns the pending rewards in LOOKS staking contract\\n     */\\n    function getStakingInfos() public view returns (uint256 shares, uint256 userRewardPerTokenPaid, uint256 rewards) {\\n        (shares, userRewardPerTokenPaid, rewards) = ILooksStaking(looksStaking).userInfo(address(this));\\n    }\\n\\n    /**\\n     * @notice Stake LOOKS tokens (and collect reward tokens if requested)\\n     * @param amount amount of LOOKS to stake\\n     * @param claimRewardToken whether to claim reward tokens\\n     */\\n    function _stake(uint256 amount, bool claimRewardToken) internal {\\n        require(amount <= IERC20(looks).balanceOf(address(this)), \\\"Capacitor: over balance\\\");\\n        ILooksStaking(looksStaking).deposit(amount, claimRewardToken);\\n    }\\n\\n    /**\\n     * @notice Stake LOOKS tokens (and collect reward tokens if requested)\\n     * @param amount amount of LOOKS to stake\\n     * @param claimRewardToken whether to claim reward tokens\\n     */\\n    function stake(uint256 amount, bool claimRewardToken) external onlyOnwerOrDepositor {\\n        _stake(amount, claimRewardToken);\\n    }\\n\\n    /**\\n     * @notice Stake all LOOKS tokens (and collect reward tokens if requested)\\n     * @param claimRewardToken whether to claim reward tokens\\n     */\\n    function stakeAll(bool claimRewardToken) external onlyOnwerOrDepositor {\\n        _stake(IERC20(looks).balanceOf(address(this)), claimRewardToken);\\n    }\\n\\n    /**\\n     * @notice Unstake LOOKS tokens (and collect reward tokens if requested)\\n     * @param shares shares to withdraw\\n     * @param claimRewardToken whether to claim reward tokens\\n     */\\n    function unstake(uint256 shares, bool claimRewardToken) external onlyOnwerOrDepositor {\\n        require(shares > 0, \\\"Capacitor: Invalid shares\\\");\\n        ILooksStaking(looksStaking).withdraw(shares, claimRewardToken);\\n    }\\n\\n    /**\\n     * @notice Unstake all LOOKS tokens (and collect reward tokens if requested)\\n     * @param claimRewardToken whether to claim reward tokens\\n     */\\n    function unstakeAll(bool claimRewardToken) external onlyOnwerOrDepositor {\\n        ILooksStaking(looksStaking).withdrawAll(claimRewardToken);\\n    }\\n\\n    /**\\n     * @notice Harvest current pending rewards\\n     */\\n    function _harvest() internal {\\n        (, , uint256 rewards) = getStakingInfos();\\n        if (rewards > 0) {\\n            ILooksStaking(looksStaking).harvest();\\n        }\\n    }\\n\\n    /**\\n     * @notice Harvest current pending rewards\\n     */\\n    function harvest() external onlyOnwerOrDepositor {\\n        _harvest();\\n    }\\n\\n    /**\\n     * @notice Deposit LOOKS and send a receipt token to the treasury\\n     */\\n    function deposit(uint256 amount) external onlyOnwerOrDepositor {\\n        IERC20(looks).safeTransferFrom(msg.sender, address(this), amount);\\n        IFlyzWrappedLOOKS(wrappedLooks).mintTo(treasury, amount);\\n\\n        if (autoStake) {\\n            _stake(amount, autoHarvest);\\n        }\\n        else if (autoHarvest) {\\n            _harvest();\\n        }\\n    }\\n\\n    /**\\n     * @notice send a receipt token to the treasury (LOOKS are transfered first by the caller to the contract)\\n     * used by BondDepository to save gas\\n     */\\n    function depositReceipt(uint256 amount) external onlyOnwerOrDepositor {\\n        require(amount <= IERC20(looks).balanceOf(address(this)), \\\"Capacitor: over balance\\\");\\n        IFlyzWrappedLOOKS(wrappedLooks).mintTo(treasury, amount);\\n\\n        if (autoStake) {\\n            _stake(amount, autoHarvest);\\n        }\\n        else if (autoHarvest) {\\n            _harvest();\\n        }\\n    }\\n\\n    /**\\n     * @dev Swap helper function\\n     */\\n    function _swap(address pair, address token, uint256 amount, address to) internal returns (uint256) {\\n        address token0 = IUniswapV2Pair(pair).token0();\\n        address token1 = IUniswapV2Pair(pair).token1();\\n        address otherToken = token0 == token ? token1 : token0;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = token0 == token ? token0 : token1;\\n        path[1] = otherToken;\\n\\n        uint256 balance = IERC20(otherToken).balanceOf(address(this));\\n        IUniswapV2Router02(swapRouter).swapExactTokensForTokens(amount, 0, path, to, block.timestamp);\\n        uint256 newBalance = IERC20(otherToken).balanceOf(address(this));\\n\\n        return newBalance - balance;\\n    }\\n\\n    /**\\n     * @notice Swap LOOKS to WETH, swap WETH to FLYZ, add liquidity to FLYZ/WETH LP and send LP to treasury with 100% profit\\n     */\\n    function swapAndSendFlyzLPToTreasury(uint256 looksAmount) external onlyOnwerOrDepositor {\\n        // swap looks to weth\\n        if (looksAmount > 0) {\\n            require(looksAmount <= IERC20(looks).balanceOf(address(this)), \\\"Capacitor: over LOOKS balance\\\");\\n            _swap(looksLP, looks, looksAmount, address(this));\\n        }\\n\\n        // buy back flyz\\n        uint256 wethAmount = IERC20(weth).balanceOf(address(this)).div(2);\\n        require(wethAmount > 0, \\\"Capacitor: WETH balance is 0\\\");\\n        uint256 flyzReceived = _swap(flyzLP, weth, wethAmount, address(this));\\n\\n        // add liquidity to flyz LP\\n        IUniswapV2Router02(swapRouter).addLiquidity(flyz, weth, flyzReceived, wethAmount, 0, 0, address(this), block.timestamp);\\n\\n        // add to the treasury with 100% profit\\n        uint256 lpAmount = IERC20(flyzLP).balanceOf(address(this));\\n        uint256 profit = IFlyzTreasury(treasury).valueOfToken(flyzLP, lpAmount);\\n        IFlyzTreasury(treasury).deposit(lpAmount, flyzLP, profit);\\n    }\\n\\n    /**\\n     * @notice Withdraw LOOKS from treasury to this contract and replace with WRAPPED LOOKS\\n     */\\n    function receiveLooksFromTreasury(uint256 amount) external onlyOnwerOrDepositor {\\n        require(amount <= IERC20(looks).balanceOf(treasury), \\\"Capacitor: over balance\\\");\\n\\n        // mint wrapped looks receipt\\n        IFlyzWrappedLOOKS(wrappedLooks).mintTo(address(this), amount);   \\n        // deposit wrapped looks receipt to treasury\\n        IFlyzTreasury(treasury).deposit(amount, wrappedLooks, 0);\\n        // withdraw looks from treasury\\n        IFlyzTreasury(treasury).withdraw(amount, looks);\\n    }\\n\\n    /**\\n     * @notice Withdraw WRAPPED LOOKS from the treasury to this contract and replace with LOOKS\\n     * WRAPPED LOOKS are burned\\n     */\\n    function sendLooksToTreasury(uint256 amount) external onlyOnwerOrDepositor {\\n        require(amount <= IERC20(looks).balanceOf(address(this)), \\\"Capacitor: over balance\\\");\\n     \\n        // deposit looks to treasury\\n        IFlyzTreasury(treasury).deposit(amount, looks, 0);\\n        // withdraw wrapped looks from treasury\\n        IFlyzTreasury(treasury).withdraw(amount, wrappedLooks);\\n        // burn wrapped looks receipt\\n        IFlyzWrappedLOOKS(wrappedLooks).burn(amount);\\n    }\\n\\n    /**\\n     * @notice Auto stake LOOKS on deposits\\n     */\\n    function setAutoStake(bool enable) external onlyOwner {\\n        autoStake = enable;\\n    }\\n\\n    /**\\n     * @notice Auto harvest rewards on deposits\\n     */\\n    function setAutoHarvest(bool enable) external onlyOwner {\\n        autoHarvest = enable;\\n    }\\n\\n    /**\\n     * @notice Returns `true` if `account` is a member of deposit group\\n     */\\n    function isDepositor(address account) public view returns(bool) {\\n        return _depositors[account];\\n    }\\n\\n    /**\\n     * @notice Add `depositor` to the list of addresses allowed to call `deposit()`  \\n     */\\n    function addDepositor(address depositor) external onlyOwner {\\n        require(depositor != address(0), \\\"Capacitor: invalid address(0)\\\");\\n        require(!_depositors[depositor], \\\"Capacitor: already depositor\\\");\\n        _depositors[depositor] = true;\\n        emit DepositorAdded(depositor);\\n    }\\n\\n    /**\\n     * @notice Remove `depositor` from the list of addresses allowed to call `deposit()`  \\n     */\\n    function removeDepositor(address depositor) external onlyOwner {\\n        require(_depositors[depositor], \\\"Capacitor: not depositor\\\");\\n        _depositors[depositor] = false;\\n        emit DepositorRemoved(depositor);\\n    }\\n\\n    /**\\n     * @notice Recover tokens sent to this contract by mistake\\n     */\\n    function recoverLostToken(address _token, uint256 amount) external onlyOwner returns (bool) {\\n        require(amount <= IERC20(_token).balanceOf(address(this)), \\\"Capacitor: over token balance\\\");\\n        IERC20(_token).safeTransfer(\\n            msg.sender,\\n            amount\\n        );\\n        return true;\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IFlyzTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\ninterface IFlyzTreasury {\\n    function excessReserves() external view returns (uint256);\\n\\n    function deposit(\\n        uint256 _amount,\\n        address _token,\\n        uint256 _profit\\n    ) external returns (uint256 sent_);\\n\\n    function valueOfToken(address _token, uint256 _amount)\\n        external\\n        view\\n        returns (uint256 value_);\\n\\n    function mintRewards(address _recipient, uint256 _amount) external;\\n\\n    function manage(address _token, uint256 _amount) external;\\n\\n    function withdraw(uint256 _amount, address _token) external;\\n}\\n\"\r\n    },\r\n    \"contracts/types/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n\\n    function renounceManagement() external;\\n\\n    function pushManagement(address newOwner_) external;\\n\\n    function pullManagement() external;\\n}\\n\\ncontract Ownable is IOwnable {\\n    address internal _owner;\\n    address internal _newOwner;\\n\\n    event OwnershipPushed(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n    event OwnershipPulled(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        _owner = msg.sender;\\n        emit OwnershipPushed(address(0), _owner);\\n    }\\n\\n    function owner() public view override returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, 'Ownable: caller is not the owner');\\n        _;\\n    }\\n\\n    function renounceManagement() public virtual override onlyOwner {\\n        emit OwnershipPushed(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function pushManagement(address newOwner_)\\n        public\\n        virtual\\n        override\\n        onlyOwner\\n    {\\n        require(\\n            newOwner_ != address(0),\\n            'Ownable: new owner is the zero address'\\n        );\\n        emit OwnershipPushed(_owner, newOwner_);\\n        _newOwner = newOwner_;\\n    }\\n\\n    function pullManagement() public virtual override {\\n        require(msg.sender == _newOwner, 'Ownable: must be new owner to pull');\\n        emit OwnershipPulled(_owner, _newOwner);\\n        _owner = _newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\\ninterface IERC20Mintable {\\n    function mint(uint256 amount_) external;\\n\\n    function mint(address account_, uint256 ammount_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, 'SafeMath: addition overflow');\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, 'SafeMath: subtraction overflow');\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, 'SafeMath: division by zero');\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    function sqrrt(uint256 a) internal pure returns (uint256 c) {\\n        if (a > 3) {\\n            c = a;\\n            uint256 b = add(div(a, 2), 1);\\n            while (b < c) {\\n                c = b;\\n                b = div(add(div(a, b), b), 2);\\n            }\\n        } else if (a != 0) {\\n            c = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport '../interfaces/IERC20.sol';\\n\\nimport './SafeMath.sol';\\nimport './Counters.sol';\\nimport './Address.sol';\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            'SafeERC20: approve from non-zero to non-zero allowance'\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(\\n            value\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\\n            value,\\n            'SafeERC20: decreased allowance below zero'\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata = address(token).functionCall(\\n            data,\\n            'SafeERC20: low-level call failed'\\n        );\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(\\n                abi.decode(returndata, (bool)),\\n                'SafeERC20: ERC20 operation did not succeed'\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport './SafeMath.sol';\\n\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance >= amount,\\n            'Address: insufficient balance'\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}('');\\n        require(\\n            success,\\n            'Address: unable to send value, recipient may have reverted'\\n        );\\n    }\\n\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return functionCall(target, data, 'Address: low-level call failed');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'Address: low-level call with value failed'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            'Address: insufficient balance for call'\\n        );\\n        require(isContract(target), 'Address: call to non-contract');\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\n            data\\n        );\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 weiValue,\\n        string memory errorMessage\\n    ) private returns (bytes memory) {\\n        require(isContract(target), 'Address: call to non-contract');\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\\n            data\\n        );\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n    function functionStaticCall(address target, bytes memory data)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return\\n            functionStaticCall(\\n                target,\\n                data,\\n                'Address: low-level static call failed'\\n            );\\n    }\\n\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), 'Address: static call to non-contract');\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function functionDelegateCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionDelegateCall(\\n                target,\\n                data,\\n                'Address: low-level delegate call failed'\\n            );\\n    }\\n\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), 'Address: delegate call to non-contract');\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            if (returndata.length > 0) {\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n    function addressToString(address _address)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes32 _bytes = bytes32(uint256(_address));\\n        bytes memory HEX = '0123456789abcdef';\\n        bytes memory _addr = new bytes(42);\\n\\n        _addr[0] = '0';\\n        _addr[1] = 'x';\\n\\n        for (uint256 i = 0; i < 20; i++) {\\n            _addr[2 + i * 2] = HEX[uint8(_bytes[i + 12] >> 4)];\\n            _addr[3 + i * 2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\\n        }\\n\\n        return string(_addr);\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_flyz\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_looks\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_looksStaking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wrappedLooks\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"DepositorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"DepositorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipPulled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipPushed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"addDepositor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoHarvest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositReceipt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flyz\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flyzLP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakingInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userRewardPerTokenPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isDepositor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"looks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"looksLP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"looksStaking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pullManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"pushManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"receiveLooksFromTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverLostToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"removeDepositor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendLooksToTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setAutoHarvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setAutoStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimRewardToken\",\"type\":\"bool\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"claimRewardToken\",\"type\":\"bool\"}],\"name\":\"stakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"looksAmount\",\"type\":\"uint256\"}],\"name\":\"swapAndSendFlyzLPToTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimRewardToken\",\"type\":\"bool\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"claimRewardToken\",\"type\":\"bool\"}],\"name\":\"unstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedLooks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FlyzLOOKSCapacitor", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000005a1912749d2b7c3cdb832b81601c8c3f437a0de8000000000000000000000000f4d2888d29d722226fafa5d9b24f9164c092421e000000000000000000000000bcd7254a1d759efa08ec7c3291b2e85c5dcc12ce0000000000000000000000000f9ac57736216bad72c8bd56312ad55cfde040ea000000000000000000000000e742799d9c8b1401c35f2137791d9cb5e7dec5d60000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}