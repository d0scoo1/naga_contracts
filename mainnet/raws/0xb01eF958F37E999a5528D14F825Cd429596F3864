{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: contracts\\interfaces\\IAVN.sol\n\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.11;\r\n\r\ninterface IAVN {\r\n  event LogAuthorisationUpdated(address indexed contractAddress, bool status);\r\n  event LogQuorumUpdated(uint256[2] quorum);\r\n  event LogValidatorFunctionsAreEnabled(bool status);\r\n  event LogLiftingIsEnabled(bool status);\r\n  event LogLoweringIsEnabled(bool status);\r\n  event LogLowerCallUpdated(bytes2 callId, uint256 numBytes);\r\n\r\n  event LogValidatorRegistered(bytes32 indexed t1PublicKeyLHS, bytes32 t1PublicKeyRHS, bytes32 indexed t2PublicKey,\r\n      uint256 indexed t2TransactionId);\r\n  event LogValidatorDeregistered(bytes32 indexed t1PublicKeyLHS, bytes32 t1PublicKeyRHS, bytes32 indexed t2PublicKey,\r\n      uint256 indexed t2TransactionId);\r\n  event LogRootPublished(bytes32 indexed rootHash, uint256 indexed t2TransactionId);\r\n\r\n  event LogLifted(address indexed token, address indexed t1Address, bytes32 indexed t2PublicKey, uint256 amount);\r\n  event LogLowered(address indexed token, address indexed t1Address, bytes32 indexed t2PublicKey, uint256 amount);\r\n\r\n  // Owner only\r\n  function transferValidators() external;\r\n  function setAuthorisationStatus(address contractAddress, bool status) external;\r\n  function setQuorum(uint256[2] memory quorum) external;\r\n  function disableValidatorFunctions() external;\r\n  function enableValidatorFunctions() external;\r\n  function disableLifting() external;\r\n  function enableLifting() external;\r\n  function disableLowering() external;\r\n  function enableLowering() external;\r\n  function updateLowerCall(bytes2 callId, uint256 numBytes) external;\r\n  function recoverERC777TokensFromLegacyTreasury(address erc777Address) external;\r\n  function recoverERC20TokensFromLegacyTreasury(address erc20Address) external;\r\n  function liftLegacyStakes(bytes calldata t2PublicKey, uint256 amount) external;\r\n\r\n  // Validator only\r\n  function registerValidator(bytes memory t1PublicKey, bytes32 t2PublicKey, uint256 t2TransactionId,\r\n      bytes calldata confirmations) external;\r\n  function deregisterValidator(bytes memory t1PublicKey, bytes32 t2PublicKey, uint256 t2TransactionId,\r\n      bytes calldata confirmations) external;\r\n  function publishRoot(bytes32 rootHash, uint256 t2TransactionId, bytes calldata confirmations) external;\r\n\r\n  // Authorised contract only\r\n  function storeT2TransactionId(uint256 t2TransactionId) external;\r\n  function storeRootHash(bytes32 rootHash) external;\r\n  function storeLiftProofHash(bytes32 proofHash) external;\r\n  function storeLoweredLeafHash(bytes32 leafHash) external;\r\n  function unlockETH(address payable recipient, uint256 amount) external;\r\n  function unlockERC777Tokens(address erc777Address, address recipient, uint256 amount) external;\r\n  function unlockERC20Tokens(address erc20Address, address recipient, uint256 amount) external;\r\n\r\n  // Public\r\n  function getAuthorisedContracts() external view returns (address[] memory);\r\n  function getIsPublishedRootHash(bytes32 rootHash) external view returns (bool);\r\n  function lift(address erc20Address, bytes calldata t2PublicKey, uint256 amount) external;\r\n  function proxyLift(address erc20Address, bytes calldata t2PublicKey, uint256 amount, address approver, uint256 proofNonce,\r\n      bytes calldata proof) external;\r\n  function liftETH(bytes calldata t2PublicKey) external payable;\r\n  function lower(bytes memory leaf, bytes32[] calldata merklePath) external;\r\n  function confirmAvnTransaction(bytes32 leafHash, bytes32[] memory merklePath) external view returns (bool);\r\n}\n\n// File: contracts\\interfaces\\IERC20.sol\n\n\r\npragma solidity 0.8.11;\r\n\r\n// As described in https://eips.ethereum.org/EIPS/eip-20\r\ninterface IERC20 {\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  function name() external view returns (string memory); // optional method - see eip spec\r\n  function symbol() external view returns (string memory); // optional method - see eip spec\r\n  function decimals() external view returns (uint8); // optional method - see eip spec\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address owner) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n}\n\n// File: contracts\\interfaces\\IERC777.sol\n\n\r\npragma solidity 0.8.11;\r\n\r\n// As defined in https://eips.ethereum.org/EIPS/eip-777\r\ninterface IERC777 {\r\n  event Sent(address indexed operator, address indexed from, address indexed to, uint256 amount, bytes data,\r\n      bytes operatorData);\r\n  event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n  event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n  event AuthorizedOperator(address indexed operator,address indexed holder);\r\n  event RevokedOperator(address indexed operator, address indexed holder);\r\n\r\n  function name() external view returns (string memory);\r\n  function symbol() external view returns (string memory);\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address holder) external view returns (uint256);\r\n  function granularity() external view returns (uint256);\r\n  function defaultOperators() external view returns (address[] memory);\r\n  function isOperatorFor(address operator, address holder) external view returns (bool);\r\n  function authorizeOperator(address operator) external;\r\n  function revokeOperator(address operator) external;\r\n  function send(address to, uint256 amount, bytes calldata data) external;\r\n  function operatorSend(address from, address to, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\r\n  function burn(uint256 amount, bytes calldata data) external;\r\n  function operatorBurn( address from, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\r\n}\n\n// File: contracts\\interfaces\\IERC777Recipient.sol\n\n\r\npragma solidity 0.8.11;\r\n\r\n// As defined in the 'ERC777TokensRecipient And The tokensReceived Hook' section of https://eips.ethereum.org/EIPS/eip-777\r\ninterface IERC777Recipient {\r\n  function tokensReceived(address operator, address from, address to, uint256 amount, bytes calldata data,\r\n      bytes calldata operatorData) external;\r\n}\n\n// File: contracts\\interfaces\\IAvnFTTreasury.sol\n\n\r\npragma solidity 0.8.11;\r\n\r\ninterface IAvnFTTreasury {\r\n  event LogFTTreasuryPermissionUpdated(address indexed treasurer, bool status);\r\n\r\n  function setTreasurerPermission(address treasurer, bool status) external;\r\n  function getTreasurers() external view returns(address[] memory);\r\n  function unlockERC777Tokens(address token, uint256 amount, bytes calldata data) external;\r\n  function unlockERC20Tokens(address token, uint256 amount) external;\r\n}\n\n// File: contracts\\thirdParty\\interfaces\\IERC1820Registry.sol\n\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC1820Registry.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the global ERC1820 Registry, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\r\n * implementers for interfaces in this registry, as well as query support.\r\n *\r\n * Implementers may be shared by multiple accounts, and can also implement more\r\n * than a single interface for each account. Contracts can implement interfaces\r\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\r\n * contract.\r\n *\r\n * {IERC165} interfaces can also be queried via the registry.\r\n *\r\n * For an in-depth explanation and source code analysis, see the EIP text.\r\n */\r\ninterface IERC1820Registry {\r\n    /**\r\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\r\n     * account is able to set interface implementers for it.\r\n     *\r\n     * By default, each account is its own manager. Passing a value of `0x0` in\r\n     * `newManager` will reset the manager to this initial state.\r\n     *\r\n     * Emits a {ManagerChanged} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     */\r\n    function setManager(address account, address newManager) external;\r\n\r\n    /**\r\n     * @dev Returns the manager for `account`.\r\n     *\r\n     * See {setManager}.\r\n     */\r\n    function getManager(address account) external view returns (address);\r\n\r\n    /**\r\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\r\n     * `interfaceHash`.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     * The zero address can also be used in `implementer` to remove an old one.\r\n     *\r\n     * See {interfaceHash} to learn how these are created.\r\n     *\r\n     * Emits an {InterfaceImplementerSet} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\r\n     * end in 28 zeroes).\r\n     * - `implementer` must implement {IERC1820Implementer} and return true when\r\n     * queried for support, unless `implementer` is the caller. See\r\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\r\n     */\r\n    function setInterfaceImplementer(\r\n        address account,\r\n        bytes32 _interfaceHash,\r\n        address implementer\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\r\n     * implementer is registered, returns the zero address.\r\n     *\r\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\r\n     * zeroes), `account` will be queried for support of it.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     */\r\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\r\n     * corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\r\n     */\r\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\r\n\r\n    /**\r\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n     * @param account Address of the contract for which to update the cache.\r\n     * @param interfaceId ERC165 interface for which to update the cache.\r\n     */\r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n\r\n    /**\r\n     * @notice Checks whether a contract implements an ERC165 interface or not.\r\n     * If the result is not cached a direct lookup on the contract address is performed.\r\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n     * {updateERC165Cache} with the contract address.\r\n     * @param account Address of the contract to check.\r\n     * @param interfaceId ERC165 interface to check.\r\n     * @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\r\n     * @param account Address of the contract to check.\r\n     * @param interfaceId ERC165 interface to check.\r\n     * @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\r\n\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n}\n\n// File: contracts\\Owned.sol\n\n\r\npragma solidity 0.8.11;\r\n\r\ncontract Owned {\r\n\r\n  address public owner = msg.sender;\r\n\r\n  event LogOwnershipTransferred(address indexed owner, address indexed newOwner);\r\n\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner, \"Only owner\");\r\n    _;\r\n  }\r\n\r\n  function setOwner(address _owner)\r\n    external\r\n    onlyOwner\r\n  {\r\n    require(_owner != address(0), \"Owner cannot be zero address\");\r\n    emit LogOwnershipTransferred(owner, _owner);\r\n    owner = _owner;\r\n  }\r\n}\n\n// File: ..\\contracts\\AVN.sol\n\n\r\npragma solidity 0.8.11;\r\r\r\r\r\r\r\r\n\r\ncontract LegacyValidatorsManager {\r\n  uint256 public numActiveValidators;\r\n  uint256 public validatorIdNum;\r\n  mapping (uint256 => address) public t1Address;\r\n  mapping (uint256 => bytes32) public t2PublicKey;\r\n}\r\n\r\ncontract AVN is IAVN, IERC777Recipient, Owned {\r\n  // Universal address as defined in Registry Contract Address section of https://eips.ethereum.org/EIPS/eip-1820\r\n  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n  // keccak256(\"ERC777Token\")\r\n  bytes32 constant internal ERC777_TOKEN_HASH = 0xac7fbab5f54a3ca8194167523c6753bfeb96a445279294b6125b68cce2177054;\r\n  // keccak256(\"ERC777TokensRecipient\")\r\n  bytes32 constant internal ERC777_TOKENS_RECIPIENT_HASH = 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\r\n  uint256 constant internal SIGNATURE_LENGTH = 65;\r\n  uint256 constant internal LIFT_LIMIT = type(uint128).max;\r\n  address constant internal PSEUDO_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n  IAvnFTTreasury immutable internal LEGACY_AVN_TREASURY;\r\n  LegacyValidatorsManager immutable internal LEGACY_AVN_VALIDATORS_MANAGER;\r\n\r\n  mapping (uint256 => bool) public isRegisteredValidator;\r\n  mapping (uint256 => bool) public isActiveValidator;\r\n  mapping (address => uint256) public t1AddressToId;\r\n  mapping (bytes32 => uint256) public t2PublicKeyToId;\r\n  mapping (uint256 => address) public idToT1Address;\r\n  mapping (uint256 => bytes32) public idToT2PublicKey;\r\n  mapping (bytes2 => uint256) public numBytesToLowerData;\r\n  mapping (address => bool) public isAuthorisedContract;\r\n  mapping (bytes32 => bool) public isPublishedRootHash;\r\n  mapping (uint256 => bool) public isUsedT2TransactionId;\r\n  mapping (bytes32 => bool) public hasLowered;\r\n  mapping (bytes32 => bool) public hasLifted;\r\n\r\n  address[] public authorisedContracts;\r\n  uint256[2] public quorum;\r\n\r\n  uint256 public numActiveValidators;\r\n  uint256 public nextValidatorId;\r\n  uint256 public unliftedLegacyStakes;\r\n  bool public validatorFunctionsAreEnabled;\r\n  bool public liftingIsEnabled;\r\n  bool public loweringIsEnabled;\r\n  bool public validatorsTransferred;\r\n\r\n  address immutable public avtAddress;\r\n\r\n  constructor(address avt, LegacyValidatorsManager avnValidatorsManager, IAvnFTTreasury avnFTTreasury)\r\n  {\r\n    ERC1820_REGISTRY.setInterfaceImplementer(address(this), ERC777_TOKENS_RECIPIENT_HASH, address(this));\r\n    avtAddress = avt;\r\n    LEGACY_AVN_VALIDATORS_MANAGER = avnValidatorsManager;\r\n    LEGACY_AVN_TREASURY = avnFTTreasury;\r\n    numBytesToLowerData[0x2d00] = 133; // callID (2 bytes) + proof (2 prefix + 32 relayer + 32 signer + 1 prefix + 64 signature)\r\n    numBytesToLowerData[0x2700] = 133; // callID (2 bytes) + proof (2 prefix + 32 relayer + 32 signer + 1 prefix + 64 signature)\r\n    numBytesToLowerData[0x2702] = 2;   // callID (2 bytes)\r\n    validatorFunctionsAreEnabled = true;\r\n    liftingIsEnabled = true;\r\n    loweringIsEnabled = true;\r\n    nextValidatorId = 1;\r\n    quorum[0] = 2;\r\n    quorum[1] = 3;\r\n    unliftedLegacyStakes = 2500000000000000000000000; // 2,500,000 AVT in full atto AVT\r\n  }\r\n\r\n  modifier onlyAuthorisedContract() {\r\n    require(isAuthorisedContract[msg.sender], \"Access denied\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyWhenLiftingIsEnabled() {\r\n    require(liftingIsEnabled, \"Lifting currently disabled\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyWhenValidatorFunctionsAreEnabled() {\r\n    require(validatorFunctionsAreEnabled, \"Function currently disabled\");\r\n    _;\r\n  }\r\n\r\n  function transferValidators()\r\n    onlyOwner\r\n    external\r\n  {\r\n    require(validatorsTransferred == false, \"Validators already transferred\");\r\n    numActiveValidators = LEGACY_AVN_VALIDATORS_MANAGER.numActiveValidators();\r\n    nextValidatorId = LEGACY_AVN_VALIDATORS_MANAGER.validatorIdNum();\r\n\r\n    for (uint256 id = 1; id < nextValidatorId; id++) {\r\n      idToT1Address[id] = LEGACY_AVN_VALIDATORS_MANAGER.t1Address(id);\r\n      idToT2PublicKey[id] = LEGACY_AVN_VALIDATORS_MANAGER.t2PublicKey(id);\r\n      t1AddressToId[idToT1Address[id]] = id;\r\n      t2PublicKeyToId[idToT2PublicKey[id]] = id;\r\n      isRegisteredValidator[id] = true;\r\n      isActiveValidator[id] = true;\r\n    }\r\n\r\n    validatorsTransferred = true;\r\n  }\r\n\r\n  function setAuthorisationStatus(address contractAddress, bool status)\r\n    onlyOwner\r\n    external\r\n  {\r\n    uint256 size;\r\n\r\n    assembly {\r\n      size := extcodesize(contractAddress)\r\n    }\r\n\r\n    require(size > 0, \"Only contracts\");\r\n\r\n    if (status == isAuthorisedContract[contractAddress]) {\r\n      return;\r\n    } else if (status) {\r\n      isAuthorisedContract[contractAddress] = true;\r\n      authorisedContracts.push(contractAddress);\r\n    } else {\r\n      isAuthorisedContract[contractAddress] = false;\r\n      uint256 endContractAddress = authorisedContracts.length - 1;\r\n      for (uint256 i; i < endContractAddress; i++) {\r\n        if (authorisedContracts[i] == contractAddress) {\r\n          authorisedContracts[i] = authorisedContracts[endContractAddress];\r\n          break;\r\n        }\r\n      }\r\n      authorisedContracts.pop();\r\n    }\r\n    emit LogAuthorisationUpdated(contractAddress, status);\r\n  }\r\n\r\n  function setQuorum(uint256[2] memory _quorum)\r\n    onlyOwner\r\n    public\r\n  {\r\n    require(_quorum[1] != 0, \"Invalid: div by zero\");\r\n    require(_quorum[0] <= _quorum[1], \"Invalid: above 100%\");\r\n    quorum = _quorum;\r\n    emit LogQuorumUpdated(quorum);\r\n  }\r\n\r\n  function disableValidatorFunctions()\r\n    onlyOwner\r\n    external\r\n  {\r\n    validatorFunctionsAreEnabled = false;\r\n    emit LogValidatorFunctionsAreEnabled(false);\r\n  }\r\n\r\n  function enableValidatorFunctions()\r\n    onlyOwner\r\n    external\r\n  {\r\n    validatorFunctionsAreEnabled = true;\r\n    emit LogValidatorFunctionsAreEnabled(true);\r\n  }\r\n\r\n  function disableLifting()\r\n    onlyOwner\r\n    external\r\n  {\r\n    liftingIsEnabled = false;\r\n    emit LogLiftingIsEnabled(false);\r\n  }\r\n\r\n  function enableLifting()\r\n    onlyOwner\r\n    external\r\n  {\r\n    liftingIsEnabled = true;\r\n    emit LogLiftingIsEnabled(true);\r\n  }\r\n\r\n  function disableLowering()\r\n    onlyOwner\r\n    external\r\n  {\r\n    loweringIsEnabled = false;\r\n    emit LogLoweringIsEnabled(false);\r\n  }\r\n\r\n  function enableLowering()\r\n    onlyOwner\r\n    external\r\n  {\r\n    loweringIsEnabled = true;\r\n    emit LogLoweringIsEnabled(true);\r\n  }\r\n\r\n  function updateLowerCall(bytes2 callId, uint256 numBytes)\r\n    onlyOwner\r\n    external\r\n  {\r\n    numBytesToLowerData[callId] = numBytes;\r\n    emit LogLowerCallUpdated(callId, numBytes);\r\n  }\r\n\r\n  function recoverERC777TokensFromLegacyTreasury(address erc777Address)\r\n    onlyOwner\r\n    external\r\n  {\r\n    uint256 lockedBalance = IERC777(erc777Address).balanceOf(address(LEGACY_AVN_TREASURY));\r\n    LEGACY_AVN_TREASURY.unlockERC777Tokens(erc777Address, lockedBalance, \"\");\r\n  }\r\n\r\n  function recoverERC20TokensFromLegacyTreasury(address erc20Address)\r\n    onlyOwner\r\n    external\r\n  {\r\n    uint256 lockedBalance = IERC20(erc20Address).balanceOf(address(LEGACY_AVN_TREASURY));\r\n    LEGACY_AVN_TREASURY.unlockERC20Tokens(erc20Address, lockedBalance);\r\n  }\r\n\r\n  function liftLegacyStakes(bytes calldata t2PublicKey, uint256 amount)\r\n    onlyOwner\r\n    external\r\n  {\r\n    require(amount <= unliftedLegacyStakes, \"Not enough stake remaining\");\r\n    bytes32 checkedT2PublicKey = checkT2PublicKey(t2PublicKey);\r\n    unliftedLegacyStakes = unliftedLegacyStakes - amount;\r\n    emit LogLifted(avtAddress, address(this), checkedT2PublicKey, amount);\r\n  }\r\n\r\n  function registerValidator(bytes memory t1PublicKey, bytes32 t2PublicKey, uint256 t2TransactionId,\r\n      bytes calldata confirmations)\r\n    onlyWhenValidatorFunctionsAreEnabled\r\n    external\r\n  {\r\n    require(t1PublicKey.length == 64, \"T1 public key must be 64 bytes\");\r\n    address t1Address = address(uint160(uint256(keccak256(t1PublicKey))));\r\n    uint256 id = t1AddressToId[t1Address];\r\n    require(isRegisteredValidator[id] == false, \"Validator is already registered\");\r\n\r\n    // The order of the elements is the reverse of the deregisterValidatorHash\r\n    bytes32 registerValidatorHash = keccak256(abi.encodePacked(t1PublicKey, t2PublicKey));\r\n    verifyConfirmations(toConfirmationHash(registerValidatorHash, t2TransactionId), confirmations);\r\n    doStoreT2TransactionId(t2TransactionId);\r\n\r\n    if (id == 0) {\r\n      require(t2PublicKeyToId[t2PublicKey] == 0, \"T2 public key already in use\");\r\n      id = nextValidatorId;\r\n      idToT1Address[id] = t1Address;\r\n      t1AddressToId[t1Address] = id;\r\n      idToT2PublicKey[id] = t2PublicKey;\r\n      t2PublicKeyToId[t2PublicKey] = id;\r\n      nextValidatorId++;\r\n    } else {\r\n      require(idToT2PublicKey[id] == t2PublicKey, \"Cannot change T2 public key\");\r\n    }\r\n\r\n    isRegisteredValidator[id] = true;\r\n\r\n    bytes32 t1PublicKeyLHS;\r\n    bytes32 t1PublicKeyRHS;\r\n    assembly {\r\n      t1PublicKeyLHS := mload(add(t1PublicKey, 0x20))\r\n      t1PublicKeyRHS := mload(add(t1PublicKey, 0x40))\r\n    }\r\n\r\n    emit LogValidatorRegistered(t1PublicKeyLHS, t1PublicKeyRHS, t2PublicKey, t2TransactionId);\r\n  }\r\n\r\n  function deregisterValidator(bytes memory t1PublicKey, bytes32 t2PublicKey, uint256 t2TransactionId,\r\n      bytes calldata confirmations)\r\n    onlyWhenValidatorFunctionsAreEnabled\r\n    external\r\n  {\r\n    uint256 id = t2PublicKeyToId[t2PublicKey];\r\n    require(isRegisteredValidator[id], \"Validator is not registered\");\r\n\r\n    // The order of the elements is the reverse of the registerValidatorHash\r\n    bytes32 deregisterValidatorHash = keccak256(abi.encodePacked(t2PublicKey, t1PublicKey));\r\n    verifyConfirmations(toConfirmationHash(deregisterValidatorHash, t2TransactionId), confirmations);\r\n    doStoreT2TransactionId(t2TransactionId);\r\n\r\n    isRegisteredValidator[id] = false;\r\n    isActiveValidator[id] = false;\r\n    numActiveValidators--;\r\n\r\n    bytes32 t1PublicKeyLHS;\r\n    bytes32 t1PublicKeyRHS;\r\n    assembly {\r\n      t1PublicKeyLHS := mload(add(t1PublicKey, 0x20))\r\n      t1PublicKeyRHS := mload(add(t1PublicKey, 0x40))\r\n    }\r\n\r\n    emit LogValidatorDeregistered(t1PublicKeyLHS, t1PublicKeyRHS, t2PublicKey, t2TransactionId);\r\n  }\r\n\r\n  function publishRoot(bytes32 rootHash, uint256 t2TransactionId, bytes calldata confirmations)\r\n    onlyWhenValidatorFunctionsAreEnabled\r\n    external\r\n  {\r\n    verifyConfirmations(toConfirmationHash(rootHash, t2TransactionId), confirmations);\r\n    doStoreT2TransactionId(t2TransactionId);\r\n    doStoreRootHash(rootHash);\r\n    emit LogRootPublished(rootHash, t2TransactionId);\r\n  }\r\n\r\n  function storeT2TransactionId(uint256 t2TransactionId)\r\n    onlyAuthorisedContract\r\n    external\r\n  {\r\n    doStoreT2TransactionId(t2TransactionId);\r\n  }\r\n\r\n  function storeRootHash(bytes32 rootHash)\r\n    onlyAuthorisedContract\r\n    external\r\n  {\r\n    doStoreRootHash(rootHash);\r\n  }\r\n\r\n  function storeLiftProofHash(bytes32 proofHash)\r\n    onlyAuthorisedContract\r\n    external\r\n  {\r\n    doStoreLiftProofHash(proofHash);\r\n  }\r\n\r\n  function storeLoweredLeafHash(bytes32 leafHash)\r\n    onlyAuthorisedContract\r\n    external\r\n  {\r\n    doStoreLoweredLeafHash(leafHash);\r\n  }\r\n\r\n  function unlockETH(address payable recipient, uint256 amount)\r\n    onlyAuthorisedContract\r\n    external\r\n  {\r\n    (bool success, ) = recipient.call{value: amount}(\"\");\r\n    require(success, \"ETH transfer failed\");\r\n  }\r\n\r\n  function unlockERC777Tokens(address erc777Address, address recipient, uint256 amount)\r\n    onlyAuthorisedContract\r\n    external\r\n  {\r\n    IERC777(erc777Address).send(recipient, amount, \"\");\r\n  }\r\n\r\n  function unlockERC20Tokens(address erc20Address, address recipient, uint256 amount)\r\n    onlyAuthorisedContract\r\n    external\r\n  {\r\n    assert(IERC20(erc20Address).transfer(recipient, amount));\r\n  }\r\n\r\n  function getAuthorisedContracts()\r\n    external\r\n    view\r\n    returns (address[] memory)\r\n  {\r\n    return authorisedContracts;\r\n  }\r\n\r\n  function getIsPublishedRootHash(bytes32 rootHash)\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return isPublishedRootHash[rootHash];\r\n  }\r\n\r\n  function lift(address erc20Address, bytes calldata t2PublicKey, uint256 amount)\r\n    onlyWhenLiftingIsEnabled\r\n    external\r\n  {\r\n    doLift(erc20Address, msg.sender, t2PublicKey, amount);\r\n  }\r\n\r\n  function proxyLift(address erc20Address, bytes calldata t2PublicKey, uint256 amount, address approver, uint256 proofNonce,\r\n      bytes calldata proof)\r\n    onlyWhenLiftingIsEnabled\r\n    external\r\n  {\r\n    if (msg.sender != approver) {\r\n      doStoreLiftProofHash(keccak256(proof));\r\n      bytes32 msgHash = keccak256(abi.encodePacked(erc20Address, t2PublicKey, amount, proofNonce));\r\n      address signer = recoverSigner(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", msgHash)), proof);\r\n      require(signer == approver, \"Lift proof invalid\");\r\n    }\r\n    doLift(erc20Address, approver, t2PublicKey, amount);\r\n  }\r\n\r\n  function liftETH(bytes calldata t2PublicKey)\r\n    payable\r\n    onlyWhenLiftingIsEnabled\r\n    external\r\n  {\r\n    bytes32 checkedT2PublicKey = checkT2PublicKey(t2PublicKey);\r\n    require(msg.value > 0, \"Cannot lift zero ETH\");\r\n    emit LogLifted(PSEUDO_ETH_ADDRESS, msg.sender, checkedT2PublicKey, msg.value);\r\n  }\r\n\r\n  // ERC-777 automatic lifting\r\n  function tokensReceived(address /* operator */, address from, address to, uint256 amount, bytes calldata data,\r\n      bytes calldata /* operatorData */)\r\n    onlyWhenLiftingIsEnabled\r\n    external\r\n  {\r\n    if (from == address(LEGACY_AVN_TREASURY)) return; // recovering funds from the legacy treasury so we don't lift here\r\n    require(to == address(this), \"Tokens must be sent to this contract\");\r\n    require(amount > 0, \"Cannot lift zero ERC777 tokens\");\r\n    bytes32 checkedT2PublicKey = checkT2PublicKey(data);\r\n    require(ERC1820_REGISTRY.getInterfaceImplementer(msg.sender, ERC777_TOKEN_HASH) == msg.sender, \"Token must be registered\");\r\n    IERC777 erc777Contract = IERC777(msg.sender);\r\n    require(erc777Contract.balanceOf(address(this)) <= LIFT_LIMIT, \"Exceeds ERC777 lift limit\");\r\n    emit LogLifted(msg.sender, from, checkedT2PublicKey, amount);\r\n  }\r\n\r\n  function lower(bytes memory leaf, bytes32[] calldata merklePath)\r\n    external\r\n  {\r\n    require(loweringIsEnabled, \"Lowering currently disabled\");\r\n    bytes32 leafHash = keccak256(leaf);\r\n    require(confirmAvnTransaction(leafHash, merklePath), \"Leaf or path invalid\");\r\n    doStoreLoweredLeafHash(leafHash);\r\n\r\n    uint256 ptr;\r\n    ptr += getCompactIntegerByteSize(leaf[ptr]); // add number of bytes encoding the leaf length\r\n    require(uint8(leaf[ptr]) & 128 != 0, \"Unsigned transaction\"); // bitwise version check to ensure leaf is signed transaction\r\n    ptr += 99; // version (1 byte) + multiAddress type (1 byte) + sender (32 bytes) + curve type (1 byte) + signature (64 bytes)\r\n    ptr += leaf[ptr] == 0x00 ? 1 : 2; // add number of era bytes (immortal is 1, otherwise 2)\r\n    ptr += getCompactIntegerByteSize(leaf[ptr]); // add number of bytes encoding the nonce\r\n    ptr += getCompactIntegerByteSize(leaf[ptr]); // add number of bytes encoding the tip\r\n    ptr += 32; // account for the first 32 EVM bytes holding the leaf's length\r\n\r\n    bytes2 callId;\r\n\r\n    assembly {\r\n      callId := mload(add(leaf, ptr))\r\n    }\r\n\r\n    require(numBytesToLowerData[callId] != 0, \"Not a lower leaf\");\r\n    ptr += numBytesToLowerData[callId];\r\n    bytes32 t2PublicKey;\r\n    address token;\r\n    uint128 amount;\r\n    address t1Address;\r\n\r\n    assembly {\r\n      t2PublicKey := mload(add(leaf, ptr)) // load next 32 bytes into 32 byte type starting at ptr\r\n      token := mload(add(add(leaf, 20), ptr)) // load leftmost 20 of next 32 bytes into 20 byte type starting at ptr + 20\r\n      amount := mload(add(add(leaf, 36), ptr)) // load leftmost 16 of next 32 bytes into 16 byte type starting at ptr + 20 + 16\r\n      t1Address := mload(add(add(leaf, 56), ptr)) // load leftmost 20 of next 32 bytes type starting at ptr + 20 + 16 + 20\r\n    }\r\n\r\n    // amount was encoded in little endian so we need to reverse to big endian:\r\n    amount = ((amount & 0xFF00FF00FF00FF00FF00FF00FF00FF00) >> 8) | ((amount & 0x00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\r\n    amount = ((amount & 0xFFFF0000FFFF0000FFFF0000FFFF0000) >> 16) | ((amount & 0x0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\r\n    amount = ((amount & 0xFFFFFFFF00000000FFFFFFFF00000000) >> 32) | ((amount & 0x00000000FFFFFFFF00000000FFFFFFFF) << 32);\r\n    amount = (amount >> 64) | (amount << 64);\r\n\r\n    if (token == PSEUDO_ETH_ADDRESS) {\r\n      (bool success, ) = payable(t1Address).call{value: amount}(\"\");\r\n      require(success, \"ETH transfer failed\");\r\n    } else if (ERC1820_REGISTRY.getInterfaceImplementer(token, ERC777_TOKEN_HASH) == token) {\r\n      IERC777(token).send(t1Address, amount, \"\");\r\n    } else {\r\n      assert(IERC20(token).transfer(t1Address, amount));\r\n    }\r\n\r\n    emit LogLowered(token, t1Address, t2PublicKey, amount);\r\n  }\r\n\r\n  function confirmAvnTransaction(bytes32 leafHash, bytes32[] memory merklePath)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    bytes32 rootHash = leafHash;\r\n\r\n    for (uint256 i; i < merklePath.length; i++) {\r\n      bytes32 node = merklePath[i];\r\n      if (rootHash < node)\r\n        rootHash = keccak256(abi.encode(rootHash, node));\r\n      else\r\n        rootHash = keccak256(abi.encode(node, rootHash));\r\n    }\r\n\r\n    return isPublishedRootHash[rootHash];\r\n  }\r\n\r\n  // reference: https://docs.substrate.io/v3/advanced/scale-codec/#compactgeneral-integers\r\n  function getCompactIntegerByteSize(bytes1 checkByte)\r\n    private\r\n    pure\r\n    returns (uint256 byteLength)\r\n  {\r\n    uint8 mode = uint8(checkByte) & 3; // the 2 least significant bits encode the byte mode so we do a bitwise AND on them\r\n\r\n    if (mode == 0) { // single-byte mode\r\n      byteLength = 1;\r\n    } else if (mode == 1) { // two-byte mode\r\n      byteLength = 2;\r\n    } else if (mode == 2) { // four-byte mode\r\n      byteLength = 4;\r\n    } else {\r\n      byteLength = uint8(checkByte >> 2) + 5; // upper 6 bits + 4 are the number of bytes following + 1 for the checkbyte itself\r\n    }\r\n  }\r\n\r\n  function toConfirmationHash(bytes32 data, uint256 t2TransactionId)\r\n    private\r\n    view\r\n    returns (bytes32)\r\n  {\r\n    return keccak256(abi.encode(data, t2TransactionId, idToT2PublicKey[t1AddressToId[msg.sender]]));\r\n  }\r\n\r\n  function verifyConfirmations(bytes32 msgHash, bytes memory confirmations)\r\n    private\r\n  {\r\n    bytes32 ethSignedPrefixMsgHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", msgHash));\r\n    uint256 numConfirmations = confirmations.length / SIGNATURE_LENGTH;\r\n    uint256 requiredConfirmations = numActiveValidators * quorum[0] / quorum[1] + 1;\r\n    uint256 validConfirmations;\r\n    uint256 id;\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n    bool[] memory confirmed = new bool[](nextValidatorId);\r\n\r\n    for (uint256 i; i < numConfirmations; i++) {\r\n      assembly {\r\n        let offset := mul(i, SIGNATURE_LENGTH)\r\n        r := mload(add(confirmations, add(0x20, offset)))\r\n        s := mload(add(confirmations, add(0x40, offset)))\r\n        v := byte(0, mload(add(confirmations, add(0x60, offset))))\r\n      }\r\n      if (v < 27) v += 27;\r\n      if (v != 27 && v != 28 || uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n        continue;\r\n      } else {\r\n        id = t1AddressToId[ecrecover(ethSignedPrefixMsgHash, v, r, s)];\r\n\r\n        if (isActiveValidator[id] == false) {\r\n          if (isRegisteredValidator[id]) {\r\n            // Here we activate any previously registered but as yet unactivated validators\r\n            isActiveValidator[id] = true;\r\n            numActiveValidators++;\r\n            validConfirmations++;\r\n            confirmed[id] = true;\r\n          }\r\n        } else if (confirmed[id] == false) {\r\n          validConfirmations++;\r\n          confirmed[id] = true;\r\n        }\r\n      }\r\n      if (validConfirmations == requiredConfirmations) break;\r\n    }\r\n\r\n    require(validConfirmations == requiredConfirmations, \"Invalid confirmations\");\r\n  }\r\n\r\n  function doStoreT2TransactionId(uint256 t2TransactionId)\r\n    private\r\n  {\r\n    require(isUsedT2TransactionId[t2TransactionId] == false, \"T2 transaction must be unique\");\r\n    isUsedT2TransactionId[t2TransactionId] = true;\r\n  }\r\n\r\n  function doStoreRootHash(bytes32 rootHash)\r\n    private\r\n  {\r\n    require(isPublishedRootHash[rootHash] == false, \"Root already exists\");\r\n    isPublishedRootHash[rootHash] = true;\r\n  }\r\n\r\n  function doStoreLiftProofHash(bytes32 proofHash)\r\n    private\r\n  {\r\n    require(hasLifted[proofHash] == false, \"Lift proof already used\");\r\n    hasLifted[proofHash] = true;\r\n  }\r\n\r\n  function doStoreLoweredLeafHash(bytes32 leafHash)\r\n    private\r\n  {\r\n    require(hasLowered[leafHash] == false, \"Already lowered\");\r\n    hasLowered[leafHash] = true;\r\n  }\r\n\r\n  function doLift(address erc20Address, address approver, bytes memory t2PublicKey, uint256 amount)\r\n    private\r\n  {\r\n    require(ERC1820_REGISTRY.getInterfaceImplementer(erc20Address, ERC777_TOKEN_HASH) == address(0), \"ERC20 lift only\");\r\n    require(amount > 0, \"Cannot lift zero ERC20 tokens\");\r\n    bytes32 checkedT2PublicKey = checkT2PublicKey(t2PublicKey);\r\n    IERC20 erc20Contract = IERC20(erc20Address);\r\n    uint256 currentBalance = erc20Contract.balanceOf(address(this));\r\n    assert(erc20Contract.transferFrom(approver, address(this), amount));\r\n    uint256 newBalance = erc20Contract.balanceOf(address(this));\r\n    require(newBalance <= LIFT_LIMIT, \"Exceeds ERC20 lift limit\");\r\n    emit LogLifted(erc20Address, approver, checkedT2PublicKey, newBalance - currentBalance);\r\n  }\r\n\r\n  function checkT2PublicKey(bytes memory t2PublicKey)\r\n    private\r\n    pure\r\n    returns (bytes32 checkedT2PublicKey)\r\n  {\r\n    require(t2PublicKey.length == 32, \"Bad T2 public key\");\r\n    checkedT2PublicKey = bytes32(t2PublicKey);\r\n  }\r\n\r\n  function recoverSigner(bytes32 hash, bytes memory signature)\r\n    private\r\n    pure\r\n    returns (address)\r\n  {\r\n    if (signature.length != 65) return address(0);\r\n\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    assembly {\r\n      r := mload(add(signature, 0x20))\r\n      s := mload(add(signature, 0x40))\r\n      v := byte(0, mload(add(signature, 0x60)))\r\n    }\r\n\r\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) return address(0);\r\n    if (v < 27) v += 27;\r\n    if (v != 27 && v != 28) return address(0);\r\n\r\n    return ecrecover(hash, v, r, s);\r\n  }\r\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"avt\",\"type\":\"address\"},{\"internalType\":\"contract LegacyValidatorsManager\",\"name\":\"avnValidatorsManager\",\"type\":\"address\"},{\"internalType\":\"contract IAvnFTTreasury\",\"name\":\"avnFTTreasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"LogAuthorisationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"t1Address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"t2PublicKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogLifted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"LogLiftingIsEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes2\",\"name\":\"callId\",\"type\":\"bytes2\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numBytes\",\"type\":\"uint256\"}],\"name\":\"LogLowerCallUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"t1Address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"t2PublicKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogLowered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"LogLoweringIsEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"LogOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"quorum\",\"type\":\"uint256[2]\"}],\"name\":\"LogQuorumUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"t2TransactionId\",\"type\":\"uint256\"}],\"name\":\"LogRootPublished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"t1PublicKeyLHS\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"t1PublicKeyRHS\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"t2PublicKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"t2TransactionId\",\"type\":\"uint256\"}],\"name\":\"LogValidatorDeregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"LogValidatorFunctionsAreEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"t1PublicKeyLHS\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"t1PublicKeyRHS\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"t2PublicKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"t2TransactionId\",\"type\":\"uint256\"}],\"name\":\"LogValidatorRegistered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"authorisedContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avtAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"leafHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"merklePath\",\"type\":\"bytes32[]\"}],\"name\":\"confirmAvnTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"t1PublicKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"t2PublicKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"t2TransactionId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"confirmations\",\"type\":\"bytes\"}],\"name\":\"deregisterValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableLifting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableLowering\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableValidatorFunctions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableLifting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableLowering\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableValidatorFunctions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuthorisedContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"rootHash\",\"type\":\"bytes32\"}],\"name\":\"getIsPublishedRootHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hasLifted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hasLowered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToT1Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToT2PublicKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isActiveValidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAuthorisedContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isPublishedRootHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isRegisteredValidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isUsedT2TransactionId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"t2PublicKey\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"lift\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"t2PublicKey\",\"type\":\"bytes\"}],\"name\":\"liftETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"t2PublicKey\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"liftLegacyStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liftingIsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"leaf\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"merklePath\",\"type\":\"bytes32[]\"}],\"name\":\"lower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loweringIsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextValidatorId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numActiveValidators\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes2\",\"name\":\"\",\"type\":\"bytes2\"}],\"name\":\"numBytesToLowerData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"t2PublicKey\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proofNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"proxyLift\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"t2TransactionId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"confirmations\",\"type\":\"bytes\"}],\"name\":\"publishRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"quorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"}],\"name\":\"recoverERC20TokensFromLegacyTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc777Address\",\"type\":\"address\"}],\"name\":\"recoverERC777TokensFromLegacyTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"t1PublicKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"t2PublicKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"t2TransactionId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"confirmations\",\"type\":\"bytes\"}],\"name\":\"registerValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setAuthorisationStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"_quorum\",\"type\":\"uint256[2]\"}],\"name\":\"setQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"proofHash\",\"type\":\"bytes32\"}],\"name\":\"storeLiftProofHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"leafHash\",\"type\":\"bytes32\"}],\"name\":\"storeLoweredLeafHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"rootHash\",\"type\":\"bytes32\"}],\"name\":\"storeRootHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t2TransactionId\",\"type\":\"uint256\"}],\"name\":\"storeT2TransactionId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"t1AddressToId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"t2PublicKeyToId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferValidators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unliftedLegacyStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unlockERC20Tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc777Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unlockERC777Tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unlockETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes2\",\"name\":\"callId\",\"type\":\"bytes2\"},{\"internalType\":\"uint256\",\"name\":\"numBytes\",\"type\":\"uint256\"}],\"name\":\"updateLowerCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorFunctionsAreEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorsTransferred\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AVN", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "0000000000000000000000000d88ed6e74bbfd96b831231638b66c05571e824f00000000000000000000000046ead2891ecf9c7444cb9197d4faacc7f54c593c00000000000000000000000073fe91d082b3604b8261de321086333e78ab1112", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}