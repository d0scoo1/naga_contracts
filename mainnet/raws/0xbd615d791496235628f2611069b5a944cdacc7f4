{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"cache/solpp-generated-contracts/UpgradeGatekeeper.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Events.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Upgradeable.sol\\\";\\nimport \\\"./UpgradeableMaster.sol\\\";\\n\\n/// @title Upgrade Gatekeeper Contract\\n/// @author Matter Labs\\ncontract UpgradeGatekeeper is UpgradeEvents, Ownable {\\n    using SafeMath for uint256;\\n\\n    /// @notice Array of addresses of upgradeable contracts managed by the gatekeeper\\n    Upgradeable[] public managedContracts;\\n\\n    /// @notice Upgrade mode statuses\\n    enum UpgradeStatus {Idle, NoticePeriod, Preparation}\\n\\n    UpgradeStatus public upgradeStatus;\\n\\n    /// @notice Notice period finish timestamp (as seconds since unix epoch)\\n    /// @dev Will be equal to zero in case of not active upgrade mode\\n    uint256 public noticePeriodFinishTimestamp;\\n\\n    /// @notice Addresses of the next versions of the contracts to be upgraded (if element of this array is equal to zero address it means that appropriate upgradeable contract wouldn't be upgraded this time)\\n    /// @dev Will be empty in case of not active upgrade mode\\n    address[] public nextTargets;\\n\\n    /// @notice Version id of contracts\\n    uint256 public versionId;\\n\\n    /// @notice Contract which defines notice period duration and allows finish upgrade during preparation of it\\n    UpgradeableMaster public mainContract;\\n\\n    /// @notice Contract constructor\\n    /// @param _mainContract Contract which defines notice period duration and allows finish upgrade during preparation of it\\n    /// @dev Calls Ownable contract constructor\\n    constructor(UpgradeableMaster _mainContract) Ownable(msg.sender) {\\n        mainContract = _mainContract;\\n        versionId = 0;\\n    }\\n\\n    /// @notice Adds a new upgradeable contract to the list of contracts managed by the gatekeeper\\n    /// @param addr Address of upgradeable contract to add\\n    function addUpgradeable(address addr) external {\\n        requireMaster(msg.sender);\\n        require(upgradeStatus == UpgradeStatus.Idle, \\\"apc11\\\"); /// apc11 - upgradeable contract can't be added during upgrade\\n\\n        managedContracts.push(Upgradeable(addr));\\n        emit NewUpgradable(versionId, addr);\\n    }\\n\\n    /// @notice Starts upgrade (activates notice period)\\n    /// @param newTargets New managed contracts targets (if element of this array is equal to zero address it means that appropriate upgradeable contract wouldn't be upgraded this time)\\n    function startUpgrade(address[] calldata newTargets) external {\\n        requireMaster(msg.sender);\\n        require(upgradeStatus == UpgradeStatus.Idle, \\\"spu11\\\"); // spu11 - unable to activate active upgrade mode\\n        require(newTargets.length == managedContracts.length, \\\"spu12\\\"); // spu12 - number of new targets must be equal to the number of managed contracts\\n\\n        uint256 noticePeriod = mainContract.getNoticePeriod();\\n        mainContract.upgradeNoticePeriodStarted();\\n        upgradeStatus = UpgradeStatus.NoticePeriod;\\n        noticePeriodFinishTimestamp = block.timestamp.add(noticePeriod);\\n        nextTargets = newTargets;\\n        emit NoticePeriodStart(versionId, newTargets, noticePeriod);\\n    }\\n\\n    /// @notice Cancels upgrade\\n    function cancelUpgrade() external {\\n        requireMaster(msg.sender);\\n        require(upgradeStatus != UpgradeStatus.Idle, \\\"cpu11\\\"); // cpu11 - unable to cancel not active upgrade mode\\n\\n        mainContract.upgradeCanceled();\\n        upgradeStatus = UpgradeStatus.Idle;\\n        noticePeriodFinishTimestamp = 0;\\n        delete nextTargets;\\n        emit UpgradeCancel(versionId);\\n    }\\n\\n    /// @notice Activates preparation status\\n    /// @return Bool flag indicating that preparation status has been successfully activated\\n    function startPreparation() external returns (bool) {\\n        requireMaster(msg.sender);\\n        require(upgradeStatus == UpgradeStatus.NoticePeriod, \\\"ugp11\\\"); // ugp11 - unable to activate preparation status in case of not active notice period status\\n\\n        if (block.timestamp >= noticePeriodFinishTimestamp) {\\n            upgradeStatus = UpgradeStatus.Preparation;\\n            mainContract.upgradePreparationStarted();\\n            emit PreparationStart(versionId);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /// @notice Finishes upgrade\\n    /// @param targetsUpgradeParameters New targets upgrade parameters per each upgradeable contract\\n    function finishUpgrade(bytes[] calldata targetsUpgradeParameters) external {\\n        requireMaster(msg.sender);\\n        require(upgradeStatus == UpgradeStatus.Preparation, \\\"fpu11\\\"); // fpu11 - unable to finish upgrade without preparation status active\\n        require(targetsUpgradeParameters.length == managedContracts.length, \\\"fpu12\\\"); // fpu12 - number of new targets upgrade parameters must be equal to the number of managed contracts\\n        require(mainContract.isReadyForUpgrade(), \\\"fpu13\\\"); // fpu13 - main contract is not ready for upgrade\\n        mainContract.upgradeFinishes();\\n\\n        for (uint64 i = 0; i < managedContracts.length; i++) {\\n            address newTarget = nextTargets[i];\\n            if (newTarget != address(0)) {\\n                managedContracts[i].upgradeTarget(newTarget, targetsUpgradeParameters[i]);\\n            }\\n        }\\n        versionId++;\\n        emit UpgradeComplete(versionId, nextTargets);\\n\\n        upgradeStatus = UpgradeStatus.Idle;\\n        noticePeriodFinishTimestamp = 0;\\n        delete nextTargets;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"14\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"v\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"15\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"x\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"y\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Events.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./Upgradeable.sol\\\";\\nimport \\\"./Operations.sol\\\";\\n\\n/// @title zkSync events\\n/// @author Matter Labs\\n/// @author Stars Labs\\ninterface Events {\\n    /// @notice Event emitted when a block is committed\\n    event BlockCommit(uint32 indexed blockNumber);\\n    event BlockVerification(uint32 indexed blockNumber);\\n\\n    /// @notice Event emitted when user funds are withdrawn from the zkSync contract\\n    event Withdrawal(uint16 indexed tokenId, uint128 amount);\\n\\n    event OnchainWithdrawal(\\n        address indexed owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n\\n    /// @notice Event emitted when user send a transaction to deposit her funds\\n    event OnchainDeposit(\\n        address indexed sender,\\n        uint16 indexed tokenId,\\n        uint128 amount,\\n        address indexed owner\\n    );\\n\\n    event OnchainCreatePair(\\n        uint16 indexed tokenAId,\\n        uint16 indexed tokenBId,\\n        uint16 indexed pairId,\\n        address pair\\n    );\\n\\n    /// @notice Event emitted when blocks are reverted\\n    event BlocksRevert(uint32 totalBlocksVerified, uint32 totalBlocksCommitted);\\n\\n    /// @notice Exodus mode entered event\\n    event ExodusMode();\\n\\n    /// @notice New priority request event. Emitted when a request is placed into mapping\\n    event NewPriorityRequest(\\n        address sender,\\n        uint64 serialId,\\n        Operations.OpType opType,\\n        bytes pubData,\\n        uint256 expirationBlock\\n    );\\n\\n    /// @notice Deposit committed event.\\n    event DepositCommit(\\n        uint32 indexed zkSyncBlockId,\\n        uint32 indexed accountId,\\n        address owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n\\n    /// @notice Full exit committed event.\\n    event FullExitCommit(\\n        uint32 indexed zkSyncBlockId,\\n        uint32 indexed accountId,\\n        address owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n\\n    event CreatePairCommit(\\n        uint32 indexed zkSyncBlockId,\\n        uint32 indexed accountId,\\n        uint16 tokenAId,\\n        uint16 tokenBId,\\n        uint16 indexed tokenPairId,\\n        address pair\\n    );\\n\\n    /// @notice Notice period changed\\n    event NoticePeriodChange(uint256 newNoticePeriod);\\n}\\n\\n/// @title Upgrade events\\n/// @author Matter Labs\\ninterface UpgradeEvents {\\n    /// @notice Event emitted when new upgradeable contract is added to upgrade gatekeeper's list of managed contracts\\n    event NewUpgradable(uint256 indexed versionId, address indexed upgradeable);\\n\\n    /// @notice Upgrade mode enter event\\n    event NoticePeriodStart(\\n        uint256 indexed versionId,\\n        address[] newTargets,\\n        uint256 noticePeriod // notice period (in seconds)\\n    );\\n\\n    /// @notice Upgrade mode cancel event\\n    event UpgradeCancel(uint256 indexed versionId);\\n\\n    /// @notice Upgrade mode preparation status event\\n    event PreparationStart(uint256 indexed versionId);\\n\\n    /// @notice Upgrade mode complete event\\n    event UpgradeComplete(uint256 indexed versionId, address[] newTargets);\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Ownable Contract\\n/// @author Matter Labs\\n// NO CHANGE\\ncontract Ownable {\\n    /// @dev Storage position of the masters address (keccak256('eip1967.proxy.admin') - 1)\\n    bytes32 private constant masterPosition = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /// @notice Contract constructor\\n    /// @dev Sets msg sender address as masters address\\n    /// @param masterAddress Master address\\n    constructor(address masterAddress) {\\n        setMaster(masterAddress);\\n    }\\n\\n    /// @notice Check if specified address is master\\n    /// @param _address Address to check\\n    function requireMaster(address _address) internal view {\\n        require(_address == getMaster(), \\\"1c\\\"); // oro11 - only by master\\n    }\\n\\n    /// @notice Returns contract masters address\\n    /// @return master Master's address\\n    function getMaster() public view returns (address master) {\\n        bytes32 position = masterPosition;\\n        assembly {\\n            master := sload(position)\\n        }\\n    }\\n\\n    /// @dev Sets new masters address\\n    /// @param _newMaster New master's address\\n    function setMaster(address _newMaster) internal {\\n        bytes32 position = masterPosition;\\n        assembly {\\n            sstore(position, _newMaster)\\n        }\\n    }\\n\\n    /// @notice Transfer mastership of the contract to new master\\n    /// @param _newMaster New masters address\\n    function transferMastership(address _newMaster) external {\\n        requireMaster(msg.sender);\\n        require(_newMaster != address(0), \\\"1d\\\"); // otp11 - new masters address can't be zero address\\n        setMaster(_newMaster);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Upgradeable.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Interface of the upgradeable contract\\n/// @author Matter Labs\\ninterface Upgradeable {\\n    /// @notice Upgrades target of upgradeable contract\\n    /// @param newTarget New target\\n    /// @param newTargetInitializationParameters New target initialization parameters\\n    function upgradeTarget(address newTarget, bytes calldata newTargetInitializationParameters) external;\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/UpgradeableMaster.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Interface of the upgradeable master contract (defines notice period duration and allows finish upgrade during preparation of it)\\n/// @author Matter Labs\\ninterface UpgradeableMaster {\\n    /// @notice Notice period before activation preparation status of upgrade mode\\n    function getNoticePeriod() external returns (uint256);\\n\\n    /// @notice Notifies contract that notice period started\\n    function upgradeNoticePeriodStarted() external;\\n\\n    /// @notice Notifies contract that upgrade preparation status is activated\\n    function upgradePreparationStarted() external;\\n\\n    /// @notice Notifies contract that upgrade canceled\\n    function upgradeCanceled() external;\\n\\n    /// @notice Notifies contract that upgrade finishes\\n    function upgradeFinishes() external;\\n\\n    /// @notice Checks that contract is ready for upgrade\\n    /// @return bool flag indicating that contract is ready for upgrade\\n    function isReadyForUpgrade() external returns (bool);\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Operations.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\n\\nimport \\\"./Bytes.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\n/// @title zkSync operations tools\\n/// @author Matter Labs\\n/// @author Stars Labs\\nlibrary Operations {\\n    /// @notice zkSync circuit operation type\\n    enum OpType {\\n        Noop,    //0\\n        Deposit,\\n        TransferToNew,\\n        Withdraw,\\n        Transfer,\\n        FullExit, //5\\n        ChangePubKey,\\n        MiningMaintenance,\\n        ClaimBonus,\\n        CreatePair,\\n        AddLiquidity,//10\\n        RemoveLiquidity,\\n        Swap\\n    }\\n\\n    // Byte lengths\\n    uint8 constant OP_TYPE_BYTES = 1;\\n    uint8 constant TOKEN_BYTES = 2;\\n    uint8 constant PUBKEY_BYTES = 32;\\n    uint8 constant NONCE_BYTES = 4;\\n    uint8 constant PUBKEY_HASH_BYTES = 20;\\n    uint8 constant ADDRESS_BYTES = 20;\\n    /// @dev Packed fee bytes lengths\\n    uint8 constant FEE_BYTES = 2;\\n    /// @dev zkSync account id bytes lengths\\n    uint8 constant ACCOUNT_ID_BYTES = 4;\\n    uint8 constant AMOUNT_BYTES = 16;\\n    /// @dev Signature (for example full exit signature) bytes length\\n    uint8 constant SIGNATURE_BYTES = 64;\\n\\n    // Deposit pubdata\\n    struct Deposit {\\n        // uint8 opType\\n        uint32 accountId;\\n        uint16 tokenId;\\n        uint128 amount;\\n        address owner;\\n        uint32 pairAccountId;\\n    }\\n\\n    // NEW ADD ACCOUNT_ID_BYTES\\n    uint256 public constant PACKED_DEPOSIT_PUBDATA_BYTES =\\n        OP_TYPE_BYTES + ACCOUNT_ID_BYTES + TOKEN_BYTES + AMOUNT_BYTES + ADDRESS_BYTES + ACCOUNT_ID_BYTES;\\n\\n    /// Deserialize deposit pubdata\\n    function readDepositPubdata(bytes memory _data) internal pure returns (Deposit memory parsed) {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint256 offset = OP_TYPE_BYTES;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset); // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\\n        (offset, parsed.pairAccountId) = Bytes.readUInt32(_data, offset); // pairAccountId\\n        require(offset == PACKED_DEPOSIT_PUBDATA_BYTES, \\\"N\\\"); // reading invalid deposit pubdata size\\n    }\\n\\n    /// Serialize deposit pubdata\\n    // NEW ADD pairAccountId\\n    function writeDepositPubdataForPriorityQueue(Deposit memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            uint8(OpType.Deposit),\\n            bytes4(0), // accountId (ignored) (update when ACCOUNT_ID_BYTES is changed)\\n            op.tokenId, // tokenId\\n            op.amount, // amount\\n            op.owner, // owner\\n            bytes4(0) // pairAccountId\\n        );\\n    }\\n\\n    /// @notice Write deposit pubdata for priority queue check.\\n    function checkDepositInPriorityQueue(Deposit memory op, bytes20 hashedPubdata) internal pure returns (bool) {\\n        return Utils.hashBytesToBytes20(writeDepositPubdataForPriorityQueue(op)) == hashedPubdata;\\n    }\\n\\n    // FullExit pubdata\\n    struct FullExit {\\n        // uint8 opType\\n        uint32 accountId;\\n        address owner;\\n        uint16 tokenId;\\n        uint128 amount;\\n        uint32 pairAccountId;\\n    }\\n\\n    // NEW ADD ACCOUNT_ID_BYTES\\n    uint256 public constant PACKED_FULL_EXIT_PUBDATA_BYTES =\\n        OP_TYPE_BYTES + ACCOUNT_ID_BYTES + ADDRESS_BYTES + TOKEN_BYTES + AMOUNT_BYTES + ACCOUNT_ID_BYTES;\\n\\n    function readFullExitPubdata(bytes memory _data) internal pure returns (FullExit memory parsed) {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint256 offset = OP_TYPE_BYTES;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset); // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\\n        // NEW ADD pairAccountId\\n        (offset, parsed.pairAccountId) = Bytes.readUInt32(_data, offset); // pairAccountId\\n        require(offset == PACKED_FULL_EXIT_PUBDATA_BYTES, \\\"O\\\"); // reading invalid full exit pubdata size\\n    }\\n\\n    function writeFullExitPubdataForPriorityQueue(FullExit memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            uint8(OpType.FullExit),\\n            op.accountId, // accountId\\n            op.owner, // owner\\n            op.tokenId, // tokenId\\n            uint128(0), // amount -- ignored\\n            // NEW ADD pairAccountId\\n            uint32(0) // pairAccountId -- ignored\\n        );\\n    }\\n\\n    function checkFullExitInPriorityQueue(FullExit memory op, bytes20 hashedPubdata) internal pure returns (bool) {\\n        return Utils.hashBytesToBytes20(writeFullExitPubdataForPriorityQueue(op)) == hashedPubdata;\\n    }\\n\\n    // Withdraw pubdata\\n    struct Withdraw {\\n        //uint8 opType; -- present in pubdata, ignored at serialization\\n        // NEW ADD\\n        uint32 accountId;\\n        uint16 tokenId;\\n        uint128 amount;\\n        //uint16 fee; -- present in pubdata, ignored at serialization\\n        address owner;\\n        // NEW ADD\\n        uint32 pairAccountId;\\n    }\\n\\n    function readWithdrawPubdata(bytes memory _data) internal pure returns (Withdraw memory parsed) {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        // CHANGE uint256 offset = OP_TYPE_BYTES + ACCOUNT_ID_BYTES;\\n        uint256 offset = OP_TYPE_BYTES; // opType\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset); // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\\n        offset += FEE_BYTES; // fee (ignored)\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\\n        // NEW ADD\\n        (offset, parsed.pairAccountId) = Bytes.readUInt32(_data, offset); // pairAccountId\\n    }\\n\\n    // ForcedExit pubdata\\n    struct ForcedExit {\\n        //uint8 opType; -- present in pubdata, ignored at serialization\\n        //uint32 initiatorAccountId; -- present in pubdata, ignored at serialization\\n        //uint32 targetAccountId; -- present in pubdata, ignored at serialization\\n        uint16 tokenId;\\n        uint128 amount;\\n        //uint16 fee; -- present in pubdata, ignored at serialization\\n        address target;\\n    }\\n\\n    function readForcedExitPubdata(bytes memory _data) internal pure returns (ForcedExit memory parsed) {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint256 offset = OP_TYPE_BYTES + ACCOUNT_ID_BYTES * 2; // opType + initiatorAccountId + targetAccountId (ignored)\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset); // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\\n        offset += FEE_BYTES; // fee (ignored)\\n        (offset, parsed.target) = Bytes.readAddress(_data, offset); // target\\n    }\\n\\n    // ChangePubKey\\n    enum ChangePubkeyType {ECRECOVER, CREATE2, OldECRECOVER}\\n\\n    struct ChangePubKey {\\n        // uint8 opType; -- present in pubdata, ignored at serialization\\n        uint32 accountId;\\n        bytes20 pubKeyHash;\\n        address owner;\\n        uint32 nonce;\\n        //uint16 tokenId; -- present in pubdata, ignored at serialization\\n        //uint16 fee; -- present in pubdata, ignored at serialization\\n    }\\n\\n    function readChangePubKeyPubdata(bytes memory _data) internal pure returns (ChangePubKey memory parsed) {\\n        uint256 offset = OP_TYPE_BYTES;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.pubKeyHash) = Bytes.readBytes20(_data, offset); // pubKeyHash\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\\n        (offset, parsed.nonce) = Bytes.readUInt32(_data, offset); // nonce\\n    }\\n\\n    // CreatePair pubdata\\n    // NEW ADD\\n    struct CreatePair {\\n        // uint8 opType; -- present in pubdata, ignored at serialization\\n        uint32 accountId;\\n        uint16 tokenA;\\n        uint16 tokenB;\\n        uint16 tokenPair;\\n        address pair;\\n    }\\n    // NEW ADD\\n    uint256 public constant PACKED_CREATE_PAIR_PUBDATA_BYTES =\\n        OP_TYPE_BYTES + ACCOUNT_ID_BYTES + TOKEN_BYTES + TOKEN_BYTES + TOKEN_BYTES + ADDRESS_BYTES;\\n\\n    // NEW ADD\\n    function readCreatePairPubdata(bytes memory _data) internal pure returns (CreatePair memory parsed)\\n    {\\n        uint256 offset = OP_TYPE_BYTES; // opType\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.tokenA) = Bytes.readUInt16(_data, offset); // tokenAId\\n        (offset, parsed.tokenB) = Bytes.readUInt16(_data, offset); // tokenBId\\n        (offset, parsed.tokenPair) = Bytes.readUInt16(_data, offset); // pairId\\n        (offset, parsed.pair) = Bytes.readAddress(_data, offset); // pairId\\n        require(offset == PACKED_CREATE_PAIR_PUBDATA_BYTES, \\\"rcp10\\\"); // reading invalid create pair pubdata size\\n    }\\n\\n    // NEW ADD\\n    function writeCreatePairPubdata(CreatePair memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            OpType.CreatePair,\\n            bytes4(0),      // accountId (ignored) (update when ACCOUNT_ID_BYTES is changed)\\n            op.tokenA,      // tokenAId\\n            op.tokenB,      // tokenBId\\n            op.tokenPair,   // pairId\\n            op.pair         // pair account\\n        );\\n    }\\n\\n    function checkCreatePairInPriorityQueue(CreatePair memory op, bytes20 hashedPubdata) internal pure returns (bool) {\\n        return Utils.hashBytesToBytes20(writeCreatePairPubdata(op)) == hashedPubdata;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Bytes.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n// Functions named bytesToX, except bytesToBytes20, where X is some type of size N < 32 (size of one word)\\n// implements the following algorithm:\\n// f(bytes memory input, uint offset) -> X out\\n// where byte representation of out is N bytes from input at the given offset\\n// 1) We compute memory location of the word W such that last N bytes of W is input[offset..offset+N]\\n// W_address = input + 32 (skip stored length of bytes) + offset - (32 - N) == input + offset + N\\n// 2) We load W from memory into out, last N bytes of W are placed into out\\n\\nlibrary Bytes {\\n    function toBytesFromUInt16(uint16 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 2);\\n    }\\n\\n    function toBytesFromUInt24(uint24 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 3);\\n    }\\n\\n    function toBytesFromUInt32(uint32 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 4);\\n    }\\n\\n    function toBytesFromUInt128(uint128 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 16);\\n    }\\n\\n    // Copies 'len' lower bytes from 'self' into a new 'bytes memory'.\\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length 'len'.\\n    function toBytesFromUIntTruncated(uint256 self, uint8 byteLength) private pure returns (bytes memory bts) {\\n        require(byteLength <= 32, \\\"Q\\\");\\n        bts = new bytes(byteLength);\\n        // Even though the bytes will allocate a full word, we don't want\\n        // any potential garbage bytes in there.\\n        uint256 data = self << ((32 - byteLength) * 8);\\n        assembly {\\n            mstore(\\n            add(bts, 32), // BYTES_HEADER_SIZE\\n            data\\n            )\\n        }\\n    }\\n\\n    // Copies 'self' into a new 'bytes memory'.\\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length '20'.\\n    function toBytesFromAddress(address self) internal pure returns (bytes memory bts) {\\n        bts = toBytesFromUIntTruncated(uint256(self), 20);\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 20)\\n    function bytesToAddress(bytes memory self, uint256 _start) internal pure returns (address addr) {\\n        uint256 offset = _start + 20;\\n        require(self.length >= offset, \\\"R\\\");\\n        assembly {\\n            addr := mload(add(self, offset))\\n        }\\n    }\\n\\n    // Reasoning about why this function works is similar to that of other similar functions, except NOTE below.\\n    // NOTE: that bytes1..32 is stored in the beginning of the word unlike other primitive types\\n    // NOTE: theoretically possible overflow of (_start + 20)\\n    function bytesToBytes20(bytes memory self, uint256 _start) internal pure returns (bytes20 r) {\\n        require(self.length >= (_start + 20), \\\"S\\\");\\n        assembly {\\n            r := mload(add(add(self, 0x20), _start))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x2)\\n    function bytesToUInt16(bytes memory _bytes, uint256 _start) internal pure returns (uint16 r) {\\n        uint256 offset = _start + 0x2;\\n        require(_bytes.length >= offset, \\\"T\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x3)\\n    function bytesToUInt24(bytes memory _bytes, uint256 _start) internal pure returns (uint24 r) {\\n        uint256 offset = _start + 0x3;\\n        require(_bytes.length >= offset, \\\"U\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x4)\\n    function bytesToUInt32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 r) {\\n        uint256 offset = _start + 0x4;\\n        require(_bytes.length >= offset, \\\"V\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x10)\\n    function bytesToUInt128(bytes memory _bytes, uint256 _start) internal pure returns (uint128 r) {\\n        uint256 offset = _start + 0x10;\\n        require(_bytes.length >= offset, \\\"W\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x14)\\n    function bytesToUInt160(bytes memory _bytes, uint256 _start) internal pure returns (uint160 r) {\\n        uint256 offset = _start + 0x14;\\n        require(_bytes.length >= offset, \\\"X\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x20)\\n    function bytesToBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32 r) {\\n        uint256 offset = _start + 0x20;\\n        require(_bytes.length >= offset, \\\"Y\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // Original source code: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol#L228\\n    // Get slice from bytes arrays\\n    // Returns the newly created 'bytes memory'\\n    // NOTE: theoretically possible overflow of (_start + _length)\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_bytes.length >= (_start + _length), \\\"Z\\\"); // bytes length is less then start byte + length bytes\\n\\n        bytes memory tempBytes = new bytes(_length);\\n\\n        if (_length != 0) {\\n            assembly {\\n                let slice_curr := add(tempBytes, 0x20)\\n                let slice_end := add(slice_curr, _length)\\n\\n                for {\\n                    let array_current := add(_bytes, add(_start, 0x20))\\n                } lt(slice_curr, slice_end) {\\n                    slice_curr := add(slice_curr, 0x20)\\n                    array_current := add(array_current, 0x20)\\n                } {\\n                    mstore(slice_curr, mload(array_current))\\n                }\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    /// Reads byte stream\\n    /// @return new_offset - offset + amount of bytes read\\n    /// @return data - actually read data\\n    // NOTE: theoretically possible overflow of (_offset + _length)\\n    function read(\\n        bytes memory _data,\\n        uint256 _offset,\\n        uint256 _length\\n    ) internal pure returns (uint256 new_offset, bytes memory data) {\\n        data = slice(_data, _offset, _length);\\n        new_offset = _offset + _length;\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 1)\\n    function readBool(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, bool r) {\\n        new_offset = _offset + 1;\\n        r = uint8(_data[_offset]) != 0;\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 1)\\n    function readUint8(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint8 r) {\\n        new_offset = _offset + 1;\\n        r = uint8(_data[_offset]);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 2)\\n    function readUInt16(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint16 r) {\\n        new_offset = _offset + 2;\\n        r = bytesToUInt16(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 3)\\n    function readUInt24(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint24 r) {\\n        new_offset = _offset + 3;\\n        r = bytesToUInt24(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 4)\\n    function readUInt32(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint32 r) {\\n        new_offset = _offset + 4;\\n        r = bytesToUInt32(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 16)\\n    function readUInt128(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint128 r) {\\n        new_offset = _offset + 16;\\n        r = bytesToUInt128(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readUInt160(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint160 r) {\\n        new_offset = _offset + 20;\\n        r = bytesToUInt160(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readAddress(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, address r) {\\n        new_offset = _offset + 20;\\n        r = bytesToAddress(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readBytes20(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, bytes20 r) {\\n        new_offset = _offset + 20;\\n        r = bytesToBytes20(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 32)\\n    function readBytes32(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, bytes32 r) {\\n        new_offset = _offset + 32;\\n        r = bytesToBytes32(_data, _offset);\\n    }\\n\\n    /// Trim bytes into single word\\n    function trim(bytes memory _data, uint256 _new_length) internal pure returns (uint256 r) {\\n        require(_new_length <= 0x20, \\\"10\\\"); // new_length is longer than word\\n        require(_data.length >= _new_length, \\\"11\\\"); // data is to short\\n\\n        uint256 a;\\n        assembly {\\n            a := mload(add(_data, 0x20)) // load bytes into uint256\\n        }\\n\\n        return a >> ((0x20 - _new_length) * 8);\\n    }\\n\\n    // Helper function for hex conversion.\\n    function halfByteToHex(bytes1 _byte) internal pure returns (bytes1 _hexByte) {\\n        require(uint8(_byte) < 0x10, \\\"hbh11\\\"); // half byte's value is out of 0..15 range.\\n\\n        // \\\"FEDCBA9876543210\\\" ASCII-encoded, shifted and automatically truncated.\\n        return bytes1(uint8(0x66656463626139383736353433323130 >> (uint8(_byte) * 8)));\\n    }\\n\\n    // Convert bytes to ASCII hex representation\\n    function bytesToHexASCIIBytes(bytes memory _input) internal pure returns (bytes memory _output) {\\n        bytes memory outStringBytes = new bytes(_input.length * 2);\\n\\n        // code in `assembly` construction is equivalent of the next code:\\n        // for (uint i = 0; i < _input.length; ++i) {\\n        //     outStringBytes[i*2] = halfByteToHex(_input[i] >> 4);\\n        //     outStringBytes[i*2+1] = halfByteToHex(_input[i] & 0x0f);\\n        // }\\n        assembly {\\n            let input_curr := add(_input, 0x20)\\n            let input_end := add(input_curr, mload(_input))\\n\\n            for {\\n                let out_curr := add(outStringBytes, 0x20)\\n            } lt(input_curr, input_end) {\\n                input_curr := add(input_curr, 0x01)\\n                out_curr := add(out_curr, 0x02)\\n            } {\\n                let curr_input_byte := shr(0xf8, mload(input_curr))\\n            // here outStringByte from each half of input byte calculates by the next:\\n            //\\n            // \\\"FEDCBA9876543210\\\" ASCII-encoded, shifted and automatically truncated.\\n            // outStringByte = byte (uint8 (0x66656463626139383736353433323130 >> (uint8 (_byteHalf) * 8)))\\n                mstore(\\n                out_curr,\\n                shl(0xf8, shr(mul(shr(0x04, curr_input_byte), 0x08), 0x66656463626139383736353433323130))\\n                )\\n                mstore(\\n                add(out_curr, 0x01),\\n                shl(0xf8, shr(mul(and(0x0f, curr_input_byte), 0x08), 0x66656463626139383736353433323130))\\n                )\\n            }\\n        }\\n        return outStringBytes;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Utils.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Bytes.sol\\\";\\n\\nlibrary Utils {\\n    /// @notice Returns lesser of two values\\n    function minU32(uint32 a, uint32 b) internal pure returns (uint32) {\\n        return a < b ? a : b;\\n    }\\n\\n    /// @notice Returns lesser of two values\\n    function minU64(uint64 a, uint64 b) internal pure returns (uint64) {\\n        return a < b ? a : b;\\n    }\\n\\n    /// @notice Sends tokens\\n    /// @dev NOTE: this function handles tokens that have transfer function not strictly compatible with ERC20 standard\\n    /// @dev NOTE: call `transfer` to this token may return (bool) or nothing\\n    /// @param _token Token address\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @return bool flag indicating that transfer is successful\\n    function sendERC20(\\n        IERC20 _token,\\n        address _to,\\n        uint256 _amount\\n    ) internal returns (bool) {\\n        (bool callSuccess, bytes memory callReturnValueEncoded) =\\n        address(_token).call(abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", _to, _amount));\\n        // `transfer` method may return (bool) or nothing.\\n        bool returnedSuccess = callReturnValueEncoded.length == 0 || abi.decode(callReturnValueEncoded, (bool));\\n        return callSuccess && returnedSuccess;\\n    }\\n\\n    /// @notice Transfers token from one address to another\\n    /// @dev NOTE: this function handles tokens that have transfer function not strictly compatible with ERC20 standard\\n    /// @dev NOTE: call `transferFrom` to this token may return (bool) or nothing\\n    /// @param _token Token address\\n    /// @param _from Address of sender\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @return bool flag indicating that transfer is successful\\n    function transferFromERC20(\\n        IERC20 _token,\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) internal returns (bool) {\\n        (bool callSuccess, bytes memory callReturnValueEncoded) =\\n        address(_token).call(abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\", _from, _to, _amount));\\n        // `transferFrom` method may return (bool) or nothing.\\n        bool returnedSuccess = callReturnValueEncoded.length == 0 || abi.decode(callReturnValueEncoded, (bool));\\n        return callSuccess && returnedSuccess;\\n    }\\n\\n    /// @notice Recovers signer's address from ethereum signature for given message\\n    /// @param _signature 65 bytes concatenated. R (32) + S (32) + V (1)\\n    /// @param _messageHash signed message hash.\\n    /// @return address of the signer\\n    function recoverAddressFromEthSignature(bytes memory _signature, bytes32 _messageHash)\\n    internal\\n    pure\\n    returns (address)\\n    {\\n        require(_signature.length == 65, \\\"P\\\"); // incorrect signature length\\n\\n        bytes32 signR;\\n        bytes32 signS;\\n        uint8 signV;\\n        assembly {\\n            signR := mload(add(_signature, 32))\\n            signS := mload(add(_signature, 64))\\n            signV := byte(0, mload(add(_signature, 96)))\\n        }\\n\\n        return ecrecover(_messageHash, signV, signR, signS);\\n    }\\n\\n    /// @notice Returns new_hash = hash(old_hash + bytes)\\n    function concatHash(bytes32 _hash, bytes memory _bytes) internal pure returns (bytes32) {\\n        bytes32 result;\\n        assembly {\\n            let bytesLen := add(mload(_bytes), 32)\\n            mstore(_bytes, _hash)\\n            result := keccak256(_bytes, bytesLen)\\n            mstore(_bytes, sub(bytesLen, 32))\\n        }\\n        return result;\\n    }\\n\\n    function hashBytesToBytes20(bytes memory _bytes) internal pure returns (bytes20) {\\n        return bytes20(uint160(uint256(keccak256(_bytes))));\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n\\n    function symbol() external pure returns (string memory);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract UpgradeableMaster\",\"name\":\"_mainContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"versionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upgradeable\",\"type\":\"address\"}],\"name\":\"NewUpgradable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"versionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"newTargets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"noticePeriod\",\"type\":\"uint256\"}],\"name\":\"NoticePeriodStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"versionId\",\"type\":\"uint256\"}],\"name\":\"PreparationStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"versionId\",\"type\":\"uint256\"}],\"name\":\"UpgradeCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"versionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"newTargets\",\"type\":\"address[]\"}],\"name\":\"UpgradeComplete\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addUpgradeable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"targetsUpgradeParameters\",\"type\":\"bytes[]\"}],\"name\":\"finishUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"master\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainContract\",\"outputs\":[{\"internalType\":\"contract UpgradeableMaster\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"managedContracts\",\"outputs\":[{\"internalType\":\"contract Upgradeable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextTargets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noticePeriodFinishTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startPreparation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"newTargets\",\"type\":\"address[]\"}],\"name\":\"startUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMaster\",\"type\":\"address\"}],\"name\":\"transferMastership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeStatus\",\"outputs\":[{\"internalType\":\"enum UpgradeGatekeeper.UpgradeStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"versionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UpgradeGatekeeper", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001e3cfbc5adfd98a5af70ff551b11140e87452172", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}