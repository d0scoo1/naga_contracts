{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CycloneWrapper.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2021-04-23\\r\\n*/\\r\\n\\r\\n// File: contracts/token/IERC20Basic.sol\\r\\n\\r\\npragma solidity <0.6 >=0.4.21;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC20Basic\\r\\n * @dev Simpler version of ERC20 interface\\r\\n * @dev see https://github.com/ethereum/EIPs/issues/179\\r\\n */\\r\\ncontract IERC20Basic {\\r\\n  function totalSupply() public view returns (uint256);\\r\\n  function balanceOf(address who) public view returns (uint256);\\r\\n  function transfer(address to, uint256 value) public returns (bool);\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n}\\r\\n\\r\\n// File: contracts/token/IERC20.sol\\r\\n\\r\\npragma solidity <0.6 >=0.4.21;\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC20 interface\\r\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\r\\n */\\r\\ncontract IERC20 is IERC20Basic {\\r\\n  function name() external view returns (string memory);\\r\\n  function symbol() external view returns (string memory);\\r\\n  function allowance(address owner, address spender) public view returns (uint256);\\r\\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\\r\\n  function approve(address spender, uint256 value) public returns (bool);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n// File: contracts/IMessierV2dot2.sol\\r\\n\\r\\npragma solidity <0.6 >=0.4.24;\\r\\n\\r\\n\\r\\ninterface IMessierV2dot2 {\\r\\n\\r\\n  function coinDenomination() external view returns (uint256);\\r\\n  function tokenDenomination() external view returns (uint256);\\r\\n  function M87Denomination() external view returns (uint256);\\r\\n  function token() external view returns (IERC20);\\r\\n  function M87Token() external view returns (IERC20);\\r\\n  function deposit(bytes32 _commitment) external payable returns (bytes32, uint32, uint256, uint256, uint256);\\r\\n  function withdraw(bytes calldata _proof, bytes32 _root, bytes32 _nullifierHash, address payable _recipient, address payable _relayer, uint256 _fee, uint256 _refund) external payable;\\r\\n  function anonymityFee() external view returns (uint256);\\r\\n}\\r\\n\\r\\n// File: contracts/math/SafeMath.sol\\r\\n\\r\\npragma solidity <0.6 >=0.4.21;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that throw on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n  /**\\r\\n  * @dev Multiplies two numbers, throws on overflow.\\r\\n  */\\r\\n\\r\\n  /*@CTK SafeMath_mul\\r\\n    @tag spec\\r\\n    @post __reverted == __has_assertion_failure\\r\\n    @post __has_assertion_failure == __has_overflow\\r\\n    @post __reverted == false -> c == a * b\\r\\n    @post msg == msg__post\\r\\n   */\\r\\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    c = a * b;\\r\\n    assert(c / a == b);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Integer division of two numbers, truncating the quotient.\\r\\n  */\\r\\n  /*@CTK SafeMath_div\\r\\n    @tag spec\\r\\n    @pre b != 0\\r\\n    @post __reverted == __has_assertion_failure\\r\\n    @post __has_overflow == true -> __has_assertion_failure == true\\r\\n    @post __reverted == false -> __return == a / b\\r\\n    @post msg == msg__post\\r\\n   */\\r\\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\\r\\n    // uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n    return a / b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\r\\n  */\\r\\n  /*@CTK SafeMath_sub\\r\\n    @tag spec\\r\\n    @post __reverted == __has_assertion_failure\\r\\n    @post __has_overflow == true -> __has_assertion_failure == true\\r\\n    @post __reverted == false -> __return == a - b\\r\\n    @post msg == msg__post\\r\\n   */\\r\\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    assert(b <= a);\\r\\n    return a - b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Adds two numbers, throws on overflow.\\r\\n  */\\r\\n  /*@CTK SafeMath_add\\r\\n    @tag spec\\r\\n    @post __reverted == __has_assertion_failure\\r\\n    @post __has_assertion_failure == __has_overflow\\r\\n    @post __reverted == false -> c == a + b\\r\\n    @post msg == msg__post\\r\\n   */\\r\\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n    c = a + b;\\r\\n    assert(c >= a);\\r\\n    return c;\\r\\n  }\\r\\n}\\r\\n\\r\\n// File: contracts/utils/Address.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type,\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\r\\n     * execution of a contract's constructor, its address will be reported as\\r\\n     * not containing a contract.\\r\\n     *\\r\\n     * > It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies in extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size > 0;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/token/SafeERC20.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves.\\r\\n\\r\\n        // A Solidity high level call has three parts:\\r\\n        //  1. The target address is checked to verify it contains contract code\\r\\n        //  2. The call itself is made, and success asserted\\r\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\r\\n\\r\\n        if (returndata.length > 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/uniswapv2/IRouter.sol\\r\\n\\r\\npragma solidity >=0.5.0 <0.8.0;\\r\\n\\r\\ninterface IRouter {\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function swapETHForExactTokens(\\r\\n        uint amountOut,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint[] memory amounts);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\\r\\n}\\r\\n\\r\\n// File: contracts/uniswapv2/MessierWrapper.sol\\r\\n\\r\\npragma solidity <0.6 >=0.4.24;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\ncontract MessierWrapper {\\r\\n  using SafeMath for uint256;\\r\\n  using SafeERC20 for IERC20;\\r\\n  IRouter public router;\\r\\n  address public wrappedCoin;\\r\\n  address public messierAddr;\\r\\n  mapping(address => bool) public whitelisted;\\r\\n\\r\\n  event Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp, uint256 M87Denomination, uint256 anonymityFee);\\r\\n\\r\\n  constructor(IRouter _router, address _wrappedCoin, address _messierAddr) public {\\r\\n    router = _router;\\r\\n    wrappedCoin = _wrappedCoin;\\r\\n    messierAddr = _messierAddr;\\r\\n    IMessierV2dot2 _messier = IMessierV2dot2(messierAddr);\\r\\n    IERC20 token = _messier.token();\\r\\n    if (address(token) != address(0)) {\\r\\n        token.safeApprove(messierAddr, uint256(-1));\\r\\n    }\\r\\n    _messier.M87Token().safeApprove(messierAddr, uint256(-1));\\r\\n  }\\r\\n\\r\\n  function () external payable {}\\r\\n\\r\\n  function purchaseCost(IMessierV2dot2 _messier) external view returns (uint256) {\\r\\n    uint256 M87Amount = _messier.M87Denomination().add(_messier.anonymityFee());\\r\\n    if (M87Amount == 0) {\\r\\n        return 0;\\r\\n    }\\r\\n    address[] memory paths = new address[](2);\\r\\n    paths[0] = wrappedCoin;\\r\\n    paths[1] = address(_messier.M87Token());\\r\\n    uint256[] memory amounts = router.getAmountsIn(M87Amount, paths);\\r\\n    return amounts[0];\\r\\n  }\\r\\n\\r\\n  function deposit(IMessierV2dot2 _messier, bytes32 _commitment, bool _buyM87) external payable {\\r\\n    require(address(_messier) == messierAddr, \\\"not whitelisted\\\");\\r\\n    uint256 coinAmount = _messier.coinDenomination();\\r\\n    require(msg.value >= coinAmount, \\\"MessierWrapper: insufficient coin!\\\");\\r\\n    uint256 tokenAmount = _messier.tokenDenomination();\\r\\n    uint256 M87Amount = _messier.M87Denomination().add(_messier.anonymityFee());\\r\\n    uint256 remainingCoin = msg.value.sub(coinAmount);\\r\\n    if (tokenAmount > 0) {\\r\\n      _messier.token().safeTransferFrom(msg.sender, address(this), tokenAmount);\\r\\n    }\\r\\n    if (M87Amount > 0) {\\r\\n      if (_buyM87) {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = wrappedCoin;\\r\\n        path[1] = address(_messier.M87Token());\\r\\n        uint256[] memory amounts = router.swapETHForExactTokens.value(remainingCoin)(M87Amount, path, address(this), block.timestamp.mul(2));\\r\\n        require(remainingCoin >= amounts[0], \\\"MessierWrapper: unexpected status\\\");\\r\\n        remainingCoin -= amounts[0];\\r\\n      } else {\\r\\n        _messier.M87Token().safeTransferFrom(msg.sender, address(this), M87Amount);\\r\\n      }\\r\\n    }\\r\\n    bytes32 commitment;\\r\\n    uint32 insertedIndex;\\r\\n    uint256 blocktime;\\r\\n    uint256 M87Deno;\\r\\n    uint256 fee;\\r\\n    (commitment, insertedIndex, blocktime, M87Deno, fee) = _messier.deposit.value(coinAmount)(_commitment);\\r\\n    emit Deposit( commitment, insertedIndex, blocktime, M87Deno, fee );\\r\\n    if (remainingCoin > 0) {\\r\\n      (bool success,) = msg.sender.call.value(remainingCoin)(\\\"\\\");\\r\\n      require(success, 'MessierWrapper: refund');\\r\\n    }\\r\\n  }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wrappedCoin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_messierAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"leafIndex\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"M87Denomination\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"anonymityFee\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IMessierV2dot2\",\"name\":\"_messier\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_commitment\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_buyM87\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"messierAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IMessierV2dot2\",\"name\":\"_messier\",\"type\":\"address\"}],\"name\":\"purchaseCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wrappedCoin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MessierWrapper", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000190956a704fbb70f0acce8338870771d17654952", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}