{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: WTFPL\r\npragma solidity >=0.8.0;\r\n\r\n//  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557    \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\r\n// \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\r\n// \u2588\u2588\u2551  \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\r\n// \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\r\n// \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2554\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\r\n//  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u255d\u255a\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\r\n\r\n/// @notice Arithmetic library with operations for fixed-point numbers.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\r\nlibrary FixedPointMathLib {\r\n    /*///////////////////////////////////////////////////////////////\r\n                            COMMON BASE UNITS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal constant YAD = 1e8;\r\n    uint256 internal constant WAD = 1e18;\r\n    uint256 internal constant RAY = 1e27;\r\n    uint256 internal constant RAD = 1e45;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                         FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function fmul(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 baseUnit\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Store x * y in z for now.\r\n            z := mul(x, y)\r\n\r\n            // Equivalent to require(x == 0 || (x * y) / x == y)\r\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // If baseUnit is zero this will return zero instead of reverting.\r\n            z := div(z, baseUnit)\r\n        }\r\n    }\r\n\r\n    function fdiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 baseUnit\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Store x * baseUnit in z for now.\r\n            z := mul(x, baseUnit)\r\n\r\n            // Equivalent to require(y != 0 && (x == 0 || (x * baseUnit) / x == baseUnit))\r\n            if iszero(and(iszero(iszero(y)), or(iszero(x), eq(div(z, x), baseUnit)))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // We ensure y is not zero above, so there is never division by zero here.\r\n            z := div(z, y)\r\n        }\r\n    }\r\n\r\n    function fpow(\r\n        uint256 x,\r\n        uint256 n,\r\n        uint256 baseUnit\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            switch x\r\n            case 0 {\r\n                switch n\r\n                case 0 {\r\n                    // 0 ** 0 = 1\r\n                    z := baseUnit\r\n                }\r\n                default {\r\n                    // 0 ** n = 0\r\n                    z := 0\r\n                }\r\n            }\r\n            default {\r\n                switch mod(n, 2)\r\n                case 0 {\r\n                    // If n is even, store baseUnit in z for now.\r\n                    z := baseUnit\r\n                }\r\n                default {\r\n                    // If n is odd, store x in z for now.\r\n                    z := x\r\n                }\r\n\r\n                // Shifting right by 1 is like dividing by 2.\r\n                let half := shr(1, baseUnit)\r\n\r\n                for {\r\n                    // Shift n right by 1 before looping to halve it.\r\n                    n := shr(1, n)\r\n                } n {\r\n                    // Shift n right by 1 each iteration to halve it.\r\n                    n := shr(1, n)\r\n                } {\r\n                    // Revert immediately if x ** 2 would overflow.\r\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\r\n                    if shr(128, x) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Store x squared.\r\n                    let xx := mul(x, x)\r\n\r\n                    // Round to the nearest number.\r\n                    let xxRound := add(xx, half)\r\n\r\n                    // Revert if xx + half overflowed.\r\n                    if lt(xxRound, xx) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Set x to scaled xxRound.\r\n                    x := div(xxRound, baseUnit)\r\n\r\n                    // If n is even:\r\n                    if mod(n, 2) {\r\n                        // Compute z * x.\r\n                        let zx := mul(z, x)\r\n\r\n                        // If z * x overflowed:\r\n                        if iszero(eq(div(zx, x), z)) {\r\n                            // Revert if x is non-zero.\r\n                            if iszero(iszero(x)) {\r\n                                revert(0, 0)\r\n                            }\r\n                        }\r\n\r\n                        // Round to the nearest number.\r\n                        let zxRound := add(zx, half)\r\n\r\n                        // Revert if zx + half overflowed.\r\n                        if lt(zxRound, zx) {\r\n                            revert(0, 0)\r\n                        }\r\n\r\n                        // Return properly scaled zxRound.\r\n                        z := div(zxRound, baseUnit)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                        GENERAL NUMBER UTILITIES\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Start off with z at 1.\r\n            z := 1\r\n\r\n            // Used below to help find a nearby power of 2.\r\n            let y := x\r\n\r\n            // Find the lowest power of 2 that is at least sqrt(x).\r\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\r\n                y := shr(128, y) // Like dividing by 2 ** 128.\r\n                z := shl(64, z)\r\n            }\r\n            if iszero(lt(y, 0x10000000000000000)) {\r\n                y := shr(64, y) // Like dividing by 2 ** 64.\r\n                z := shl(32, z)\r\n            }\r\n            if iszero(lt(y, 0x100000000)) {\r\n                y := shr(32, y) // Like dividing by 2 ** 32.\r\n                z := shl(16, z)\r\n            }\r\n            if iszero(lt(y, 0x10000)) {\r\n                y := shr(16, y) // Like dividing by 2 ** 16.\r\n                z := shl(8, z)\r\n            }\r\n            if iszero(lt(y, 0x100)) {\r\n                y := shr(8, y) // Like dividing by 2 ** 8.\r\n                z := shl(4, z)\r\n            }\r\n            if iszero(lt(y, 0x10)) {\r\n                y := shr(4, y) // Like dividing by 2 ** 4.\r\n                z := shl(2, z)\r\n            }\r\n            if iszero(lt(y, 0x8)) {\r\n                // Equivalent to 2 ** z.\r\n                z := shl(1, z)\r\n            }\r\n\r\n            // Shifting right by 1 is like dividing by 2.\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n\r\n            // Compute a rounded down version of z.\r\n            let zRoundDown := div(x, z)\r\n\r\n            // If zRoundDown is smaller, use it.\r\n            if lt(zRoundDown, z) {\r\n                z := zRoundDown\r\n            }\r\n        }\r\n    }\r\n}// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\nabstract contract GemswapERC20 {\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /* -------------------------------------------------------------------------- */\r\n    /*                                 ERC20 LOGIC                                */\r\n    /* -------------------------------------------------------------------------- */\r\n\r\n    string public constant name = 'Concave LP';\r\n    string public constant symbol = 'CNV-LP';\r\n    uint8 public constant decimals = 18;\r\n\r\n    uint256 public totalSupply;\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /* -------------------------------------------------------------------------- */\r\n    /*                              EIP-2612 STORAGE                              */\r\n    /* -------------------------------------------------------------------------- */\r\n\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /* -------------------------------------------------------------------------- */\r\n    /*                                 ERC20 LOGIC                                */\r\n    /* -------------------------------------------------------------------------- */\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked { balanceOf[to] += amount; }\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked { totalSupply -= amount; }\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked { balanceOf[to] += amount; }\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n        balanceOf[from] -= amount;\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked { balanceOf[to] += amount; }\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /* -------------------------------------------------------------------------- */\r\n    /*                               EIP-2612 LOGIC                               */\r\n    /* -------------------------------------------------------------------------- */\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline, uint8 v, bytes32 r, bytes32 s\r\n    ) external {\r\n        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');\r\n        unchecked {\r\n            bytes32 digest = keccak256(\r\n                abi.encodePacked(\r\n                    '\\x19\\x01',\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n                )\r\n            );\r\n\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');\r\n        }\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes('1')),\r\n                block.chainid,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n}\r\ncontract GemswapPair is GemswapERC20 {\r\n\r\n    /* -------------------------------------------------------------------------- */\r\n    /*                                   EVENTS                                   */\r\n    /* -------------------------------------------------------------------------- */\r\n\r\n    event Mint(address indexed sender, uint256 baseAmount, uint256 quoteAmount);\r\n    event Burn(address indexed sender, uint256 baseAmount, uint256 quoteAmount, address indexed to);\r\n\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 baseAmountIn,\r\n        uint256 quoteAmountIn,\r\n        uint256 baseAmountOut,\r\n        uint256 quoteAmountOut,\r\n        address indexed to\r\n    );\r\n\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    /* -------------------------------------------------------------------------- */\r\n    /*                                  CONSTANTS                                 */\r\n    /* -------------------------------------------------------------------------- */\r\n\r\n    // To avoid division by zero, there is a minimum number of liquidity tokens that always\r\n    // exist (but are owned by account zero). That number is BIPS_DIVISOR, ten thousand.\r\n    uint256 internal constant PRECISION = 112;\r\n    uint256 internal constant BIPS_DIVISOR = 10_000;\r\n\r\n    /* -------------------------------------------------------------------------- */\r\n    /*                                MUTABLE STATE                               */\r\n    /* -------------------------------------------------------------------------- */\r\n\r\n    address public token0;\r\n    address public token1;\r\n\r\n    uint256 public swapFee;\r\n    uint256 public price0CumulativeLast;\r\n    uint256 public price1CumulativeLast;\r\n\r\n    uint112 private reserve0;\r\n    uint112 private reserve1;\r\n    uint32  private blockTimestampLast;\r\n\r\n    function getReserves() public view returns (uint112 _baseReserves, uint112 _quoteReserves, uint32 _lastUpdate) {\r\n        (_baseReserves, _quoteReserves, _lastUpdate) = (reserve0, reserve1, blockTimestampLast);\r\n    }\r\n\r\n    /* -------------------------------------------------------------------------- */\r\n    /*                                  MODIFIERS                                 */\r\n    /* -------------------------------------------------------------------------- */\r\n\r\n    uint256 private reentrancyStatus;\r\n\r\n    modifier nonReentrant() {\r\n        require(reentrancyStatus == 1, \"REENTRANCY\");\r\n        reentrancyStatus = 2;\r\n        _;\r\n        reentrancyStatus = 1;\r\n    }\r\n\r\n    /* -------------------------------------------------------------------------- */\r\n    /*                               INITIALIZATION                               */\r\n    /* -------------------------------------------------------------------------- */\r\n\r\n    error INITIALIZED();\r\n\r\n    // called once by the factory at time of deployment\r\n    function initialize(\r\n        address _base,\r\n        address _quote,\r\n        uint256 _swapFee\r\n    ) external {\r\n        if (swapFee > 0) revert INITIALIZED();\r\n        (token0, token1, swapFee) = (_base, _quote, _swapFee);\r\n        reentrancyStatus = 1; // init reentrance lock\r\n    }\r\n\r\n    error BALANCE_OVERFLOW();\r\n\r\n    /// @notice update reserves and, on the first call per block, price accumulators\r\n    function _update(\r\n        uint256 baseBalance,\r\n        uint256 quoteBalance,\r\n        uint112 _baseReserves,\r\n        uint112 _quoteReserves\r\n    ) private {\r\n        unchecked {\r\n            // revert if either balance is greater than 2**112\r\n            if (baseBalance > type(uint112).max || quoteBalance > type(uint112).max) revert BALANCE_OVERFLOW();\r\n            // store current time in memory (mod 2**32 to prevent DoS in 20 years)\r\n            uint32 timestampAdjusted = uint32(block.timestamp % 2**32);\r\n            // store elapsed time since last update\r\n            uint256 timeElapsed = timestampAdjusted - blockTimestampLast;\r\n\r\n            // if oracle info hasn\"t been updated this block, and there's liquidity, update TWAP variables\r\n            if (timeElapsed > 0 && _baseReserves != 0 && _quoteReserves != 0) {\r\n                price0CumulativeLast += ((uint256(_quoteReserves) << PRECISION) / _baseReserves) * timeElapsed;\r\n                price1CumulativeLast += ((uint256(_baseReserves) << PRECISION) / _quoteReserves) * timeElapsed;\r\n            }\r\n\r\n            // sync reserves (make them match balances)\r\n            (reserve0, reserve1, blockTimestampLast) = (uint112(baseBalance), uint112(quoteBalance), timestampAdjusted);\r\n            // emit event since mutable storage was updated\r\n            emit Sync(reserve0, reserve1);\r\n        }\r\n    }\r\n\r\n    error INSUFFICIENT_LIQUIDITY_MINTED();\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function mint(address to) external nonReentrant returns (uint256 liquidity) {\r\n        // store any variables used more than once in memory to avoid SLOAD\"s\r\n        (uint112 _baseReserves, uint112 _quoteReserves,) = getReserves();\r\n        uint256 baseBalance = GemswapERC20(token0).balanceOf(address(this));\r\n        uint256 quoteBalance = GemswapERC20(token1).balanceOf(address(this));\r\n\r\n        uint256 baseAmount = baseBalance - _baseReserves;\r\n        uint256 quoteAmount = quoteBalance - _quoteReserves;\r\n\r\n\r\n        uint256 _totalSupply = totalSupply;\r\n        // if lp token total supply is equal to BIPS_DIVISOR (1,000 wei),\r\n        // amountOut (liquidity) is equal to the root of k minus BIPS_DIVISOR\r\n        if (_totalSupply == 0) {\r\n            liquidity = FixedPointMathLib.sqrt(baseAmount * quoteAmount) - BIPS_DIVISOR;\r\n            _mint(address(0), BIPS_DIVISOR);\r\n        } else {\r\n            liquidity = min(uDiv(baseAmount * _totalSupply, _baseReserves), uDiv(quoteAmount * _totalSupply, _quoteReserves));\r\n        }\r\n        // revert if Lp tokens out is equal to zero\r\n        if (liquidity == 0) revert INSUFFICIENT_LIQUIDITY_MINTED();\r\n        // mint liquidity providers LP tokens\r\n        _mint(to, liquidity);\r\n        // update mutable storage (reserves + cumulative oracle prices)\r\n        _update(baseBalance, quoteBalance, _baseReserves, _quoteReserves);\r\n        // emit event since mutable storage was updated\r\n        emit Mint(msg.sender, baseAmount, quoteAmount);\r\n    }\r\n\r\n    error INSUFFICIENT_LIQUIDITY_BURNED();\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function burn(address to) external nonReentrant returns (uint256 baseAmount, uint256 quoteAmount) {\r\n        // store any variables used more than once in memory to avoid SLOAD\"s\r\n        (uint112 _baseReserves, uint112 _quoteReserves,) = getReserves();\r\n        address _base = token0;\r\n        address _quote = token1;\r\n        uint256 baseBalance = GemswapERC20(_base).balanceOf(address(this));\r\n        uint256 quoteBalance = GemswapERC20(_quote).balanceOf(address(this));\r\n        uint256 liquidity = balanceOf[address(this)];\r\n        uint256 _totalSupply = totalSupply;\r\n        // division was originally unchecked, using balances ensures pro-rata distribution\r\n        baseAmount = uDiv(liquidity * baseBalance, _totalSupply);\r\n        quoteAmount = uDiv(liquidity * quoteBalance, _totalSupply);\r\n        // revert if amountOuts are both equal to zero\r\n        if (baseAmount == 0 && quoteAmount == 0) revert INSUFFICIENT_LIQUIDITY_BURNED();\r\n        // burn LP tokens from this contract\"s balance\r\n        _burn(address(this), liquidity);\r\n        // return liquidity providers underlying tokens\r\n        TransferHelper.safeTransfer(_base, to, baseAmount);\r\n        TransferHelper.safeTransfer(_quote, to, quoteAmount);\r\n        // update mutable storage (reserves + cumulative oracle prices)\r\n        _update(\r\n            GemswapERC20(_base).balanceOf(address(this)),\r\n            GemswapERC20(_quote).balanceOf(address(this)),\r\n            _baseReserves,\r\n            _quoteReserves\r\n        );\r\n        // emit event since mutable storage was updated\r\n        emit Burn(msg.sender, baseAmount, quoteAmount, to);\r\n    }\r\n\r\n    error INSUFFICIENT_OUTPUT_AMOUNT();\r\n    error INSUFFICIENT_LIQUIDITY();\r\n    error INSUFFICIENT_INPUT_AMOUNT();\r\n    error INSUFFICIENT_INVARIANT();\r\n    error INAVLID_TO();\r\n\r\n    /// @notice Optimistically swap tokens, will revert if K is not satisfied\r\n    /// @param baseAmountOut - amount of token0 tokens user wants to receive\r\n    /// @param quoteAmountOut - amount of token1 tokens user wants to receive\r\n    /// @param to - recipient of 'output' tokens\r\n    /// @param data - arbitrary data used during flashswaps\r\n    function swap(\r\n        uint256 baseAmountOut,\r\n        uint256 quoteAmountOut,\r\n        address to,\r\n        bytes calldata data\r\n    ) external nonReentrant {\r\n        // revert if both amounts out are zero\r\n        if (baseAmountOut == 0 && quoteAmountOut == 0) revert INSUFFICIENT_OUTPUT_AMOUNT();\r\n        // store reserves in memory to avoid SLOAD\"s\r\n        (uint112 _baseReserves, uint112 _quoteReserves,) = getReserves();\r\n        // revert if both amounts out\r\n        if (baseAmountOut > _baseReserves || quoteAmountOut >=_quoteReserves) revert INSUFFICIENT_LIQUIDITY();\r\n        // store any other variables used more than once in memory to avoid SLOAD\"s & stack too deep errors\r\n        uint256 baseAmountIn;\r\n        uint256 quoteAmountIn;\r\n        uint256 baseBalance;\r\n        uint256 quoteBalance;\r\n\r\n        {\r\n        address _base = token0;\r\n        address _quote = token1;\r\n        // make sure not to send tokens to token contracts\r\n        if (to == _base || to == _quote) revert INAVLID_TO();\r\n        // optimistically transfer \"to\" token0 tokens\r\n        // optimistically transfer \"to\" token1 tokens\r\n        if (baseAmountOut > 0) TransferHelper.safeTransfer(_base, to, baseAmountOut);\r\n        if (quoteAmountOut > 0) TransferHelper.safeTransfer(_quote, to, quoteAmountOut);\r\n        // if data length is greater than 0, initiate flashswap\r\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, baseAmountOut, quoteAmountOut, data);\r\n        // store token0 token balance of contract in memory\r\n        // store token1 token balance of contract in memory\r\n        baseBalance = GemswapERC20(_base).balanceOf(address(this));\r\n        quoteBalance = GemswapERC20(_quote).balanceOf(address(this));\r\n        }\r\n\r\n        // Math was originally unchecked here\r\n        unchecked {\r\n            // calculate baseAmountIn by comparing contracts balance to last known reserve\r\n            // calculate quoteAmountIn by comparing contracts balance to last known reserve\r\n            if (baseBalance > _baseReserves - baseAmountOut) baseAmountIn = baseBalance - (_baseReserves - baseAmountOut);\r\n            if (quoteBalance > _quoteReserves - quoteAmountOut) quoteAmountIn = quoteBalance - (_quoteReserves - quoteAmountOut);\r\n        }\r\n        // revert if user hasn't sent any tokens to the contract\r\n        if (baseAmountIn == 0 && quoteAmountIn == 0) revert INSUFFICIENT_INPUT_AMOUNT();\r\n\r\n        {\r\n        // store swap fee in memory to save SLOAD\r\n        uint256 _swapFee = swapFee;\r\n        // calculate x, y adjusted to account for swap fees\r\n        // revert if adjusted k (invariant) is less than old k\r\n        uint256 baseBalanceAdjusted = baseBalance * BIPS_DIVISOR - baseAmountIn * _swapFee;\r\n        uint256 quoteBalanceAdjusted = quoteBalance * BIPS_DIVISOR - quoteAmountIn * _swapFee;\r\n        if (baseBalanceAdjusted * quoteBalanceAdjusted < uint256(_baseReserves) * _quoteReserves * 1e8) revert INSUFFICIENT_INVARIANT();\r\n        }\r\n\r\n        // update mutable storage (reserves + cumulative oracle prices first tx per block)\r\n        _update(baseBalance, quoteBalance, _baseReserves, _quoteReserves);\r\n        // emit event since mutable storage was updated\r\n        emit Swap(msg.sender, baseAmountIn, quoteAmountIn, baseAmountOut, quoteAmountOut, to);\r\n    }\r\n\r\n    // force balances to match reserves\r\n    function skim(address to) external nonReentrant {\r\n        // store any variables used more than once in memory to avoid SLOAD\"s\r\n        address _base = token0;\r\n        address _quote = token1;\r\n        // transfer unaccounted reserves -> \"to\"\r\n        TransferHelper.safeTransfer(_base, to, GemswapERC20(_base).balanceOf(address(this)) - reserve0);\r\n        TransferHelper.safeTransfer(_quote, to, GemswapERC20(_quote).balanceOf(address(this)) - reserve1);\r\n    }\r\n\r\n    // force reserves to match balances\r\n    function sync() external nonReentrant {\r\n        _update(\r\n            GemswapERC20(token0).balanceOf(address(this)),\r\n            GemswapERC20(token1).balanceOf(address(this)),\r\n            reserve0,\r\n            reserve1\r\n        );\r\n    }\r\n\r\n    /* -------------------------------------------------------------------------- */\r\n    /*                              INTERNAL HELPERS                              */\r\n    /* -------------------------------------------------------------------------- */\r\n\r\n    // unchecked division\r\n    function uDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {assembly {z := div(x, y)}}\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {z = x < y ? x : y;}\r\n}\r\n\r\n// naming left for old contract support\r\ninterface IUniswapV2Callee {\r\n    function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external;\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"BALANCE_OVERFLOW\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INAVLID_TO\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INITIALIZED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_INPUT_AMOUNT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_INVARIANT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_LIQUIDITY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_LIQUIDITY_BURNED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_LIQUIDITY_MINTED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_OUTPUT_AMOUNT\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteAmount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseAmountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteAmountOut\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserve0\",\"type\":\"uint112\"},{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserve1\",\"type\":\"uint112\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"_baseReserves\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"_quoteReserves\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"_lastUpdate\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_quote\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_swapFee\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price0CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price1CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GemswapPair", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://846ba4ecf424657ae09a8fee413865c6ee0c523eee6a77c1ddcaeefbc45e4746"}]}