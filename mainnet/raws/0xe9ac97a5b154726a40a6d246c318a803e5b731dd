{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.11;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract ERC20\r\n{\r\n  function balanceOf(address account) public view virtual returns (uint256) {\r\n    account;\r\n    return 0;\r\n  }\r\n  function transfer(address recipient, uint256 amount) public virtual returns (bool) {\r\n    recipient;\r\n    amount;\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract TokenTimelock is Ownable {\r\n  ERC20 public token = ERC20(0xE2d393a1b629D0b034F8e9976ED354f43718b31C);\r\n  uint public ENTRY_PRICE = 0.5 ether;\r\n  uint public INITIAL_UNLOCK_AMOUNT = 10 ether;\r\n  uint public AMOUNT_PER_UNLOCK = 5 ether;\r\n  uint public UNLOCK_COUNT = 4;\r\n\r\n  mapping(uint8 => uint256) public unlock_time;\r\n  mapping(address => bool) public is_beneficiary;\r\n  mapping(address => mapping(uint => bool)) public beneficiary_has_claimed;\r\n\r\n  mapping(uint => address) public initial_token_unlock_addresses;\r\n  uint public initial_token_unlock_addresses_count;\r\n\r\n  mapping(address => bool) public whitelist;\r\n\r\n  // Public functions\r\n  \r\n  function claim(uint8 unlock_number) public {\r\n    require(unlock_number < UNLOCK_COUNT, \"Must be below unlock count.\");\r\n    require(block.timestamp >= unlock_time[unlock_number], \"Must have reached unlock time.\");\r\n    require(is_beneficiary[msg.sender], \"Beneficiary must be beneficiary.\");\r\n    require(beneficiary_has_claimed[msg.sender][unlock_number] == false, \"Beneficiary should not have claimed.\");\r\n    require(whitelist[msg.sender],\"Sender must be whitelisted\");\r\n\r\n    beneficiary_has_claimed[msg.sender][unlock_number] = true;\r\n\r\n    token.transfer(msg.sender, AMOUNT_PER_UNLOCK);\r\n  }\r\n\r\n  function buy() public payable\r\n  {\r\n    require(whitelist[msg.sender], \"You must be whitelisted.\");\r\n    require(!is_beneficiary[msg.sender], \"You already are a beneficiary.\");\r\n    require(msg.value == ENTRY_PRICE, \"Must pay the entry price.\");\r\n    \r\n    initial_token_unlock_addresses[initial_token_unlock_addresses_count] = msg.sender;\r\n    initial_token_unlock_addresses_count += 1;\r\n\r\n    is_beneficiary[msg.sender] = true;\r\n  }\r\n\r\n  // Admin functions\r\n\r\n  function releaseInitialUnlockAmount() public onlyOwner\r\n  {\r\n    for(uint i; i < initial_token_unlock_addresses_count; i++)\r\n    {\r\n      if(is_beneficiary[initial_token_unlock_addresses[i]])\r\n      {\r\n        token.transfer(initial_token_unlock_addresses[i], INITIAL_UNLOCK_AMOUNT);\r\n      }\r\n    }\r\n    INITIAL_UNLOCK_AMOUNT = 0;\r\n  }\r\n\r\n  function setEntryPrice(uint entry_price) public onlyOwner\r\n  {\r\n    ENTRY_PRICE = entry_price;\r\n  }\r\n\r\n  function setInitialUnlockAmount(uint initial_unlock_amount) public onlyOwner\r\n  {\r\n    INITIAL_UNLOCK_AMOUNT = initial_unlock_amount;\r\n  }\r\n\r\n  function setAmountPerUnlock(uint amount_per_unlock) public onlyOwner\r\n  {\r\n    AMOUNT_PER_UNLOCK = amount_per_unlock;\r\n  }\r\n\r\n  function setUnlockCount(uint unlock_count) public onlyOwner\r\n  {\r\n    UNLOCK_COUNT = unlock_count;\r\n  }\r\n\r\n  function setUnlockTimes(uint[] memory unlock_times) public onlyOwner\r\n  {\r\n    setUnlockCount(unlock_times.length);\r\n    for(uint8 i; i<unlock_times.length; i++)\r\n    {\r\n      unlock_time[i] = unlock_times[i];\r\n    }\r\n  }\r\n\r\n  function editWhitelist(address[] memory addresses, bool value) public onlyOwner\r\n  {\r\n    for(uint i; i < addresses.length; i++){\r\n      whitelist[addresses[i]] = value;\r\n    }\r\n  }\r\n\r\n  function revokeBeneficiary(address beneficiary) public onlyOwner\r\n  {\r\n    whitelist[beneficiary] = false;\r\n    is_beneficiary[beneficiary] = false;\r\n  }\r\n\r\n  function withdrawETH() public onlyOwner\r\n  {\r\n    (bool sent, bytes memory data) = address(owner()).call{value: address(this).balance}(\"\");\r\n    require(sent, \"Failed to send Ether\");\r\n    data;\r\n  }\r\n\r\n  function withdrawTokens() public onlyOwner\r\n  {\r\n    token.transfer(address(owner()), token.balanceOf(address(this)));\r\n  }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AMOUNT_PER_UNLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ENTRY_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INITIAL_UNLOCK_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNLOCK_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"beneficiary_has_claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"unlock_number\",\"type\":\"uint8\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"editWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"initial_token_unlock_addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initial_token_unlock_addresses_count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"is_beneficiary\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseInitialUnlockAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"revokeBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_per_unlock\",\"type\":\"uint256\"}],\"name\":\"setAmountPerUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"entry_price\",\"type\":\"uint256\"}],\"name\":\"setEntryPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initial_unlock_amount\",\"type\":\"uint256\"}],\"name\":\"setInitialUnlockAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unlock_count\",\"type\":\"uint256\"}],\"name\":\"setUnlockCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"unlock_times\",\"type\":\"uint256[]\"}],\"name\":\"setUnlockTimes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"unlock_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenTimelock", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f8a91f0ac66a35b3d60d05c24788fd20622bd05e8c460cc3d72a5967c3673bb7"}]}