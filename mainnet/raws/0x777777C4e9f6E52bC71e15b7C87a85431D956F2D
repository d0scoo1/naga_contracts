{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\n/*\r\nBusiness Source License 1.1\r\n\r\nLicense text copyright \u00a9 2017 MariaDB Corporation Ab, All Rights Reserved.\r\n\"Business Source License\" is a trademark of MariaDB Corporation Ab.\r\n\r\nTerms\r\n\r\nThe Licensor hereby grants you the right to copy, modify, create derivative\r\nworks, redistribute, and make non-production use of the Licensed Work. The\r\nLicensor may make an Additional Use Grant, above, permitting limited\r\nproduction use.\r\n\r\nEffective on the Change Date, or the fourth anniversary of the first publicly\r\navailable distribution of a specific version of the Licensed Work under this\r\nLicense, whichever comes first, the Licensor hereby grants you rights under\r\nthe terms of the Change License, and the rights granted in the paragraph\r\nabove terminate.\r\n\r\nIf your use of the Licensed Work does not comply with the requirements\r\ncurrently in effect as described in this License, you must purchase a\r\ncommercial license from the Licensor, its affiliated entities, or authorized\r\nresellers, or you must refrain from using the Licensed Work.\r\n\r\nAll copies of the original and modified Licensed Work, and derivative works\r\nof the Licensed Work, are subject to this License. This License applies\r\nseparately for each version of the Licensed Work and the Change Date may vary\r\nfor each version of the Licensed Work released by Licensor.\r\n\r\nYou must conspicuously display this License on each original or modified copy\r\nof the Licensed Work. If you receive the Licensed Work in original or\r\nmodified form from a third party, the terms and conditions set forth in this\r\nLicense apply to your use of that work.\r\n\r\nAny use of the Licensed Work in violation of this License will automatically\r\nterminate your rights under this License for the current and all other\r\nversions of the Licensed Work.\r\n\r\nThis License does not grant you any right in any trademark or logo of\r\nLicensor or its affiliates (provided that you may use a trademark or logo of\r\nLicensor as expressly required by this License).\r\n\r\nTO THE EXTENT PERMITTED BY APPLICABLE LAW, THE LICENSED WORK IS PROVIDED ON\r\nAN \u201cAS IS\u201d BASIS. LICENSOR HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS,\r\nEXPRESS OR IMPLIED, INCLUDING (WITHOUT LIMITATION) WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND\r\nTITLE.\r\n\r\nMariaDB hereby grants you permission to use this License\u2019s text to license\r\nyour works, and to refer to it using the trademark \u201cBusiness Source License\u201d,\r\nas long as you comply with the Covenants of Licensor below.\r\n\r\nCovenants of Licensor\r\n\r\nIn consideration of the right to use this License\u2019s text and the \u201cBusiness\r\nSource License\u201d name and trademark, Licensor covenants to MariaDB, and to all\r\nother recipients of the licensed work to be provided by Licensor:\r\n\r\n1. To specify as the Change License the GPL Version 2.0 or any later version,\r\n   or a license that is compatible with GPL Version 2.0 or a later version,\r\n   where \u201ccompatible\u201d means that software provided under the Change License can\r\n   be included in a program with software provided under GPL Version 2.0 or a\r\n   later version. Licensor may specify additional Change Licenses without\r\n   limitation.\r\n\r\n2. To either: (a) specify an additional grant of rights to use that does not\r\n   impose any additional restriction on the right granted in this License, as\r\n   the Additional Use Grant; or (b) insert the text \u201cNone\u201d.\r\n\r\n3. To specify a Change Date.\r\n\r\n4. Not to modify this License in any other way.\r\n*/\r\n\r\npragma solidity ^0.8.12;\r\ninterface ICerbyTokenMinterBurner {\r\n    function balanceOf(\r\n        address _account\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n    function totalSupply()\r\n        external\r\n        view\r\n        returns (uint256);\r\n    function mintHumanAddress(\r\n        address _to,\r\n        uint256 _desiredAmountToMint\r\n    )\r\n        external;\r\n    function burnHumanAddress(\r\n        address _from,\r\n        uint256 _desiredAmountToBurn\r\n    )\r\n        external;\r\n    function transferCustom(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    )\r\n        external;\r\n    function getUtilsContractAtPos(\r\n        uint256 pos\r\n    )\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\npragma solidity ^0.8.10;\r\nstruct TransactionInfo {\r\n    bool isBuy;\r\n    bool isSell;\r\n}\r\ninterface ICerbyBotDetection {\r\n    function checkTransactionInfo(\r\n        address _tokenAddr,\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _recipientBalance,\r\n        uint256 _transferAmount\r\n    )\r\n        external\r\n        returns (TransactionInfo memory output);\r\n    function isBotAddress(\r\n        address _addr\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n    function executeCronJobs()\r\n        external;\r\n    function detectBotTransaction(\r\n        address _tokenAddr,\r\n        address _addr\r\n    )\r\n        external\r\n        returns (bool);\r\n    function registerTransaction(\r\n        address _tokenAddr,\r\n        address _addr\r\n    )\r\n        external;\r\n}\r\npragma solidity ^0.8.12;\r\nstruct AccessSettings {\r\n    bool isMinter;\r\n    bool isBurner;\r\n    bool isTransferer;\r\n    bool isModerator;\r\n    bool isTaxer;\r\n    address addr;\r\n}\r\ninterface ICerbyToken {\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n    function transferFrom(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n    function transfer(\r\n        address _recipient,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    )\r\n        external\r\n        returns (bool success);\r\n    function balanceOf(\r\n        address _account\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n    function totalSupply()\r\n        external\r\n        view\r\n        returns (uint256);\r\n    function mintHumanAddress(\r\n        address _to,\r\n        uint256 _desiredAmountToMint\r\n    )\r\n        external;\r\n    function burnHumanAddress(\r\n        address _from,\r\n        uint256 _desiredAmountToBurn\r\n    )\r\n        external;\r\n    function mintByBridge(\r\n        address _to,\r\n        uint256 _realAmountToMint\r\n    )\r\n        external;\r\n    function burnByBridge(\r\n        address _from,\r\n        uint256 _realAmountBurn\r\n    )\r\n        external;\r\n    function getUtilsContractAtPos(\r\n        uint256 _pos\r\n    )\r\n        external\r\n        view\r\n        returns (address);\r\n    function updateUtilsContracts(\r\n        AccessSettings[] calldata accessSettings\r\n    )\r\n        external;\r\n    function transferCustom(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    )\r\n        external;\r\n}\r\npragma solidity ^0.8.12;\r\nabstract contract CerbyCronJobsExecution {\r\n    uint256 constant CERBY_BOT_DETECTION_CONTRACT_ID = 3;\r\n    ICerbyToken constant CERBY_TOKEN_INSTANCE = ICerbyToken(\r\n        0xdef1fac7Bf08f173D286BbBDcBeeADe695129840\r\n    );\r\n    error CerbyCronJobsExecution_TransactionsAreTemporarilyDisabled();\r\n    modifier detectBotTransactionThenRegisterTransactionAndExecuteCronJobsAfter(\r\n        address _tokenIn,\r\n        address _from,\r\n        address _tokenOut,\r\n        address _to\r\n    ) {\r\n        ICerbyBotDetection iCerbyBotDetection = ICerbyBotDetection(\r\n            getUtilsContractAtPos(\r\n                CERBY_BOT_DETECTION_CONTRACT_ID\r\n            )\r\n        );\r\n        if (iCerbyBotDetection.detectBotTransaction(_tokenIn, _from)) {\r\n            revert CerbyCronJobsExecution_TransactionsAreTemporarilyDisabled();\r\n        }\r\n        iCerbyBotDetection.registerTransaction(\r\n            _tokenOut,\r\n            _to\r\n        );\r\n        _;\r\n        iCerbyBotDetection.executeCronJobs();\r\n    }\r\n    modifier checkForBotsAndExecuteCronJobsAfter(\r\n        address _from\r\n    ) {\r\n        ICerbyBotDetection iCerbyBotDetection = ICerbyBotDetection(\r\n            getUtilsContractAtPos(\r\n                CERBY_BOT_DETECTION_CONTRACT_ID\r\n            )\r\n        );\r\n        if (iCerbyBotDetection.isBotAddress(_from)) {\r\n            revert CerbyCronJobsExecution_TransactionsAreTemporarilyDisabled();\r\n        }\r\n        _;\r\n        iCerbyBotDetection.executeCronJobs();\r\n    }\r\n    function getUtilsContractAtPos(\r\n        uint256 _pos\r\n    )\r\n        public\r\n        view\r\n        virtual\r\n        returns (address)\r\n    {\r\n        return CERBY_TOKEN_INSTANCE.getUtilsContractAtPos(_pos);\r\n    }\r\n}\r\npragma solidity ^0.8.0;\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\npragma solidity ^0.8.0;\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\npragma solidity ^0.8.0;\r\ninterface IERC1155Receiver is IERC165 {\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\npragma solidity ^0.8.0;\r\ninterface IERC1155 is IERC165 {\r\n    event TransferSingle(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 id,\r\n        uint256 value\r\n    );\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed account,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n    function balanceOf(address account, uint256 id)\r\n        external\r\n        view\r\n        returns (uint256);\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n    function isApprovedForAll(address account, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\npragma solidity ^0.8.12;\r\nabstract contract ERC1155 {\r\n    mapping(uint256 => mapping(address => uint256)) erc1155Balances;\r\n    mapping(address => mapping(address => bool)) erc1155OperatorApprovals;\r\n    mapping(uint256 => uint256) erc1155TotalSupply;\r\n    address constant BURN_ADDRESS = address(0);\r\n    event TransferSingle(\r\n        address indexed _operator,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _id,\r\n        uint256 _value\r\n    );\r\n    event TransferBatch(\r\n        address indexed _operator,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256[] _ids,\r\n        uint256[] _values\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed _account,\r\n        address indexed _operator,\r\n        bool _approved\r\n    );\r\n    error ERC1155_CallerIsNotOwnerNorApproved();\r\n    error ERC1155_IdsLengthMismatch();\r\n    error ERC1155_InsufficientBalanceForTransfer();\r\n    error ERC1155_BurnAmountExceedsBalance();\r\n    error ERC1155_ERC1155ReceiverRejectsTokens();\r\n    error ERC1155_TransferToNonERC1155ReceiverImplementer();\r\n    modifier addressIsApproved(address _addr) {\r\n        if (_addr == msg.sender && isApprovedForAll(_addr, msg.sender)) {\r\n            revert ERC1155_CallerIsNotOwnerNorApproved();\r\n        }\r\n        _;\r\n    }\r\n    modifier idsLengthMismatch(\r\n        uint256 _idsLength,\r\n        uint256 _accountsLength\r\n    ) {\r\n        if (_idsLength != _accountsLength) {\r\n            revert ERC1155_IdsLengthMismatch();\r\n        }\r\n        _;\r\n    }\r\n    function balanceOf(\r\n        address _account,\r\n        uint256 _id\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return erc1155Balances[_id][_account];\r\n    }\r\n    function isApprovedForAll(\r\n        address _account,\r\n        address _operator\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return erc1155OperatorApprovals[_account][_operator];\r\n    }\r\n    function balanceOfBatch(\r\n        address[] calldata _accounts,\r\n        uint256[] calldata _ids\r\n    )\r\n        external\r\n        view\r\n        idsLengthMismatch(_ids.length, _accounts.length)\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory batchBalances = new uint256[](_accounts.length);\r\n        for (uint256 i = 0; i < _ids.length; ++i) {\r\n            batchBalances[i] = balanceOf(_accounts[i], _ids[i]);\r\n        }\r\n        return batchBalances;\r\n    }\r\n    function totalSupply(uint256 _id)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return erc1155TotalSupply[_id];\r\n    }\r\n    function exists(uint256 _id)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return erc1155TotalSupply[_id] > 0;\r\n    }\r\n    function _safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _id,\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        address operator = msg.sender;\r\n        uint256 fromBalance = erc1155Balances[_id][_from];\r\n        if (fromBalance < _amount) {\r\n            revert ERC1155_InsufficientBalanceForTransfer();\r\n        }\r\n        unchecked {\r\n            erc1155Balances[_id][_from] = fromBalance - _amount;\r\n            erc1155Balances[_id][_to] += _amount;\r\n        }\r\n        emit TransferSingle(\r\n            operator,\r\n            _from,\r\n            _to,\r\n            _id,\r\n            _amount\r\n        );\r\n        _doSafeTransferAcceptanceCheck(operator, _from, _to, _id, _amount, \"\");\r\n    }\r\n    function _mint(\r\n        address _to,\r\n        uint256 _id,\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        if (_amount == 0) {\r\n            return;\r\n        }\r\n        address operator = msg.sender;\r\n        erc1155TotalSupply[_id] += _amount;\r\n        unchecked {\r\n            erc1155Balances[_id][_to] += _amount;\r\n        }\r\n        emit TransferSingle(operator, BURN_ADDRESS, _to, _id, _amount);\r\n        _doSafeTransferAcceptanceCheck(\r\n            operator,\r\n            BURN_ADDRESS,\r\n            _to,\r\n            _id,\r\n            _amount,\r\n            \"\"\r\n        );\r\n    }\r\n    function _burn(\r\n        address _from,\r\n        uint256 _id,\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        address operator = msg.sender;\r\n        uint256 fromBalance = erc1155Balances[_id][_from];\r\n        if (fromBalance < _amount) {\r\n            revert ERC1155_BurnAmountExceedsBalance();\r\n        }\r\n        unchecked {\r\n            erc1155Balances[_id][_from] = fromBalance - _amount;\r\n            erc1155TotalSupply[_id] -= _amount;\r\n        }\r\n        emit TransferSingle(operator, _from, BURN_ADDRESS, _id, _amount);\r\n    }\r\n    function _setApprovalForAll(\r\n        address _owner,\r\n        address _operator,\r\n        bool _approved\r\n    )\r\n        internal\r\n    {\r\n        erc1155OperatorApprovals[_owner][_operator] = _approved;\r\n        emit ApprovalForAll(_owner, _operator, _approved);\r\n    }\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _id,\r\n        uint256 _amount,\r\n        bytes memory _data\r\n    )\r\n        private\r\n    {\r\n        if (isContract(_to)) {\r\n            try\r\n                IERC1155Receiver(_to).onERC1155Received(\r\n                    _operator,\r\n                    _from,\r\n                    _id,\r\n                    _amount,\r\n                    _data\r\n                )\r\n            returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    revert ERC1155_ERC1155ReceiverRejectsTokens();\r\n                }\r\n            } catch {\r\n                revert ERC1155_TransferToNonERC1155ReceiverImplementer();\r\n            }\r\n        }\r\n    }\r\n    function isContract(address _account)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\npragma solidity ^0.8.12;\r\nabstract contract CerbySwapV1_ERC1155 is ERC1155, CerbyCronJobsExecution {\r\n    string contractName = \"CerbySwapV1\";\r\n    string contractSymbol = \"CS1\";\r\n    string urlPrefix = \"https://data.cerby.fi/CerbySwap/v1/\";\r\n    function name()\r\n        external\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return contractName;\r\n    }\r\n    function symbol()\r\n        external\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return contractSymbol;\r\n    }\r\n    function decimals()\r\n        external\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 18;\r\n    }\r\n    function totalSupply()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 i;\r\n        uint256 totalSupplyAmount;\r\n        while (erc1155TotalSupply[++i] > 0) {\r\n            totalSupplyAmount += erc1155TotalSupply[i];\r\n        }\r\n        return totalSupplyAmount;\r\n    }\r\n    function uri(\r\n        uint256 _id\r\n    )\r\n        external\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return string(\r\n            abi.encodePacked(\r\n                urlPrefix,\r\n                _uint2str(_id), \".json\"\r\n            )\r\n        );\r\n    }\r\n    function setApprovalForAll(\r\n        address _operator,\r\n        bool _approved\r\n    )\r\n        external\r\n        checkForBotsAndExecuteCronJobsAfter(msg.sender)\r\n    {\r\n        _setApprovalForAll(\r\n            msg.sender,\r\n            _operator,\r\n            _approved\r\n        );\r\n    }\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _id,\r\n        uint256 _amount,\r\n        bytes calldata\r\n    )\r\n        external\r\n        checkForBotsAndExecuteCronJobsAfter(_from)\r\n        addressIsApproved(_from)\r\n    {\r\n        _safeTransferFrom(\r\n            _from,\r\n            _to,\r\n            _id,\r\n            _amount\r\n        );\r\n    }\r\n    function _uint2str(\r\n        uint256 _i\r\n    )\r\n        private\r\n        pure\r\n        returns (string memory str)\r\n    {\r\n        if (_i == 0) return \"0\";\r\n        uint256 j = _i;\r\n        uint256 length;\r\n        while (j != 0) {\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint256 k = length;\r\n        j = _i;\r\n        while (j != 0) {\r\n            bstr[--k] = bytes1(uint8(48 + j % 10));\r\n            j /= 10;\r\n        }\r\n        str = string(bstr);\r\n    }\r\n}\r\npragma solidity ^0.8.12;\r\nabstract contract CerbySwapV1_Math {\r\n    function sqrt(\r\n        uint256 _y\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256 z)\r\n    {\r\n        if (_y > 3) {\r\n            z = _y;\r\n            uint256 x = _y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (_y / x + x) / 2;\r\n            }\r\n        } else if (_y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\npragma solidity ^0.8.12;\r\ninterface ICerbySwapV1_Vault {\r\n    function initialize(\r\n        address _token\r\n    )\r\n        external;\r\n    function balanceOf(\r\n        address _account\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    )\r\n        external\r\n        returns (bool success);\r\n    function withdrawEth(\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        external;\r\n    function withdrawTokens(\r\n        address _token,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        external;\r\n}\r\npragma solidity ^0.8.12;\r\ninterface IBasicERC20 {\r\n    function balanceOf(\r\n        address _account\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    )\r\n        external\r\n        returns (bool success);\r\n}\r\npragma solidity ^0.8.12;\r\nabstract contract CerbySwapV1_EventsAndErrors {\r\n    event PoolCreated(\r\n        address _token,\r\n        address _vaultAddress,\r\n        uint256 _poolId\r\n    );\r\n    event LiquidityAdded(\r\n        address _token,\r\n        uint256 _amountTokensIn,\r\n        uint256 _amountCerUsdToMint,\r\n        uint256 _lpAmount\r\n    );\r\n    event LiquidityRemoved(\r\n        address _token,\r\n        uint256 _amountTokensOut,\r\n        uint256 _amountCerUsdToBurn,\r\n        uint256 _amountLpTokensBalanceToBurn\r\n    );\r\n    event Swap(\r\n        address _token,\r\n        address _sender,\r\n        uint256 _amountTokensIn,\r\n        uint256 _amountCerUsdIn,\r\n        uint256 _amountTokensOut,\r\n        uint256 _amountCerUsdOut,\r\n        uint256 _currentFee,\r\n        address _transferTo\r\n    );\r\n    event Sync(\r\n        address _token,\r\n        uint256 _newBalanceToken,\r\n        uint256 _newBalanceCerUsd,\r\n        uint256 _newCreditCerUsd\r\n    );\r\n    error CerbySwapV1_TokenAlreadyExists();\r\n    error CerbySwapV1_TokenDoesNotExist();\r\n    error CerbySwapV1_TransactionIsExpired();\r\n    error CerbySwapV1_AmountOfTokensMustBeLargerThanOne();\r\n    error CerbySwapV1_AmountOfCerUsdMustBeLargerThanOne();\r\n    error CerbySwapV1_OutputCerUsdAmountIsLowerThanMinimumSpecified();\r\n    error CerbySwapV1_OutputTokensAmountIsLowerThanMinimumSpecified();\r\n    error CerbySwapV1_InputCerUsdAmountIsLargerThanMaximumSpecified();\r\n    error CerbySwapV1_InputTokensAmountIsLargerThanMaximumSpecified();\r\n    error CerbySwapV1_SwappingTokenToSameTokenIsForbidden();\r\n    error CerbySwapV1_InvariantKValueMustBeSameOrIncreasedOnAnySwaps();\r\n    error CerbySwapV1_SafeTransferNativeFailed();\r\n    error CerbySwapV1_SafeTransferFromFailed();\r\n    error CerbySwapV1_AmountOfCerUsdOrTokensInMustBeLargerThanOne();\r\n    error CerbySwapV1_FeeIsWrong();\r\n    error CerbySwapV1_TvlMultiplierIsWrong();\r\n    error CerbySwapV1_MintFeeMultiplierMustNotBeLargerThan50Percent();\r\n    error CerbySwapV1_CreditCerUsdMustNotBeBelowZero();\r\n    error CerbySwapV1_CreditCerUsdIsAlreadyMaximum();\r\n}\r\npragma solidity ^0.8.12;\r\nabstract contract CerbySwapV1_Declarations is CerbySwapV1_EventsAndErrors {\r\n    Pool[] pools;\r\n    mapping(address => TokenCache) cachedTokenValues;\r\n    uint256 constant ETH_MAINNET_CHAIN_ID = 1;\r\n    uint256 constant BSC_MAINNET_CHAIN_ID = 56;\r\n    uint256 constant POLYGON_MAINNET_CHAIN_ID = 137;\r\n    uint256 constant AVALANCHE_MAINNET_CHAIN_ID = 43114;\r\n    uint256 constant FANTOM_MAINNET_CHAIN_ID = 250;\r\n    address constant CER_USD_TOKEN = 0x333333f9E4ba7303f1ac0BF8fE1F47d582629194;\r\n    address constant VAULT_IMPLEMENTATION = 0xc0DE7771A6F7029d62E8071e331B36136534D70D;\r\n    address NATIVE_TOKEN;\r\n    uint256 constant MINT_FEE_DENORM = 10000;\r\n    uint256 constant MAX_CER_USD_CREDIT = type(uint128).max;\r\n    uint256 constant FEE_DENORM = 10000;\r\n    uint256 constant FEE_DENORM_SQUARED = FEE_DENORM * FEE_DENORM;\r\n    uint256 constant TRADE_VOLUME_DENORM = 1e18;\r\n    uint256 constant TVL_MULTIPLIER_DENORM = 1e10;\r\n    uint256 constant NUMBER_OF_TRADE_PERIODS = 6;\r\n    uint256 constant NUMBER_OF_TRADE_PERIODS_MINUS_ONE = NUMBER_OF_TRADE_PERIODS - 1;\r\n    uint256 constant ONE_PERIOD_IN_SECONDS = 288 minutes;\r\n    uint256 constant MINIMUM_LIQUIDITY = 1000;\r\n    address constant DEAD_ADDRESS = address(0xdead);\r\n    Settings settings;\r\n    struct TokenCache {\r\n        address vaultAddress;\r\n        uint96 poolId;\r\n    }\r\n    struct Settings {\r\n        address mintFeeBeneficiary;\r\n        uint32 mintFeeMultiplier;\r\n        uint8 feeMinimum;\r\n        uint8 feeMaximum;\r\n        uint64 tvlMultiplierMinimum;\r\n        uint64 tvlMultiplierMaximum;\r\n    }\r\n    struct Pool {\r\n        uint40[NUMBER_OF_TRADE_PERIODS] tradeVolumePerPeriodInCerUsd;\r\n        uint8 lastCachedFee;\r\n        uint8 lastCachedTradePeriod;\r\n        uint128 lastSqrtKValue;\r\n        uint128 creditCerUsd;\r\n    }\r\n    struct PoolBalances {\r\n        uint256 balanceToken;\r\n        uint256 balanceCerUsd;\r\n    }\r\n}\r\npragma solidity ^0.8.12;\r\ncontract CerbySwapV1_MinimalProxy is CerbySwapV1_Declarations {\r\n    function cloneVault(\r\n        address _token\r\n    )\r\n        internal\r\n        returns (address)\r\n    {\r\n        bytes32 salt = _getSaltByToken(_token);\r\n        bytes20 vaultImplementationBytes = bytes20(\r\n            VAULT_IMPLEMENTATION\r\n        );\r\n        address resultVaultAddress;\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(\r\n                clone,\r\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\r\n            )\r\n            mstore(add(clone, 0x14), vaultImplementationBytes)\r\n            mstore(\r\n                add(clone, 0x28),\r\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\r\n            )\r\n            resultVaultAddress := create2(\r\n                0,\r\n                clone,\r\n                0x37,\r\n                salt\r\n            )\r\n        }\r\n        return resultVaultAddress;\r\n    }\r\n    function _getCachedVaultCloneAddressByToken(\r\n        address _token\r\n    )\r\n        internal\r\n        returns(address)\r\n    {\r\n        address vault = cachedTokenValues[_token].vaultAddress;\r\n        if (vault == address(0)) {\r\n            vault = _generateVaultAddressByToken(\r\n                _token\r\n            );\r\n            cachedTokenValues[_token].vaultAddress = vault;\r\n        }\r\n        return vault;\r\n    }\r\n    function _generateVaultAddressByToken(\r\n        address _token\r\n    )\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        bytes32 salt = _getSaltByToken(_token);\r\n        address factory = address(this);\r\n        address vaultCloneAddress;\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(\r\n                ptr,\r\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\r\n            )\r\n            mstore(add(ptr, 0x14), shl(0x60, VAULT_IMPLEMENTATION))\r\n            mstore(\r\n                add(ptr, 0x28),\r\n                0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000\r\n            )\r\n            mstore(add(ptr, 0x38), shl(0x60, factory))\r\n            mstore(add(ptr, 0x4c), salt)\r\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\r\n            vaultCloneAddress := keccak256(add(ptr, 0x37), 0x55)\r\n        }\r\n        return vaultCloneAddress;\r\n    }\r\n    function _getSaltByToken(\r\n        address _token\r\n    )\r\n        internal\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                _token,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n}\r\npragma solidity ^0.8.12;\r\nabstract contract CerbySwapV1_SafeFunctions is\r\n    CerbySwapV1_EventsAndErrors,\r\n    CerbySwapV1_MinimalProxy\r\n{\r\n    function _getPoolBalances(\r\n        address _token\r\n    )\r\n        internal\r\n        view\r\n        returns (PoolBalances memory)\r\n    {\r\n        address vault = cachedTokenValues[_token].vaultAddress == address(0)\r\n            ? _generateVaultAddressByToken(_token)\r\n            : cachedTokenValues[_token].vaultAddress;\r\n        return PoolBalances(\r\n            _getTokenBalance(_token, vault),\r\n            _getTokenBalance(CER_USD_TOKEN, vault)\r\n        );\r\n    }\r\n    function _getTokenBalance(\r\n        address _token,\r\n        address _vault\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _token == NATIVE_TOKEN\r\n            ? _vault.balance\r\n            : IBasicERC20(_token).balanceOf(_vault);\r\n    }\r\n    function _safeTransferFromHelper(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amountTokens\r\n    )\r\n        internal\r\n    {\r\n        if (_from == msg.sender) {\r\n            if (_token != NATIVE_TOKEN) {\r\n                _safeCoreTransferFrom(\r\n                    _token,\r\n                    _from,\r\n                    _to,\r\n                    _amountTokens\r\n                );\r\n                return;\r\n            }\r\n            uint256 nativeBalance = address(this).balance;\r\n            if (nativeBalance > _amountTokens) {\r\n                _safeCoreTransferNative(\r\n                    msg.sender,\r\n                    nativeBalance - _amountTokens\r\n                );\r\n            }\r\n            _safeCoreTransferNative(\r\n                _to,\r\n                _amountTokens\r\n            );\r\n            return;\r\n        }\r\n        if (_token != NATIVE_TOKEN) {\r\n            ICerbySwapV1_Vault(_from).withdrawTokens(\r\n                _token,\r\n                _to,\r\n                _amountTokens\r\n            );\r\n            return;\r\n        }\r\n        ICerbySwapV1_Vault(_from).withdrawEth(\r\n            _to,\r\n            _amountTokens\r\n        );\r\n    }\r\n    function _safeCoreTransferFrom(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        internal\r\n    {\r\n        (bool success, bytes memory data) = _token.call(\r\n            abi.encodeWithSelector(\r\n                0x23b872dd,\r\n                _from,\r\n                _to,\r\n                _value\r\n            )\r\n        );\r\n        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) {\r\n            revert CerbySwapV1_SafeTransferFromFailed();\r\n        }\r\n    }\r\n    function _safeCoreTransferNative(\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        internal\r\n    {\r\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\r\n        if (!success) {\r\n            revert CerbySwapV1_SafeTransferNativeFailed();\r\n        }\r\n    }\r\n}\r\npragma solidity ^0.8.12;\r\nabstract contract CerbySwapV1_Modifiers is CerbySwapV1_Declarations {\r\n    modifier tokenMustExistInPool(\r\n        address _token\r\n    ) {\r\n        if (cachedTokenValues[_token].poolId == 0 || _token == CER_USD_TOKEN) {\r\n            revert CerbySwapV1_TokenDoesNotExist();\r\n        }\r\n        _;\r\n    }\r\n    modifier transactionIsNotExpired(\r\n        uint256 _expireTimestamp\r\n    ) {\r\n        if (block.timestamp > _expireTimestamp) {\r\n            revert CerbySwapV1_TransactionIsExpired();\r\n        }\r\n        _;\r\n    }\r\n}\r\npragma solidity ^0.8.12;\r\nabstract contract CerbySwapV1_GetFunctions is\r\n    CerbySwapV1_Modifiers,\r\n    CerbySwapV1_SafeFunctions\r\n{\r\n    function getTokenToPoolId(\r\n        address _token\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return cachedTokenValues[_token].poolId;\r\n    }\r\n    function getSettings()\r\n        external\r\n        view\r\n        returns (Settings memory)\r\n    {\r\n        return settings;\r\n    }\r\n    function getPoolsByTokens(\r\n        address[] calldata _tokens\r\n    )\r\n        external\r\n        view\r\n        returns (Pool[] memory)\r\n    {\r\n        Pool[] memory outputPools = new Pool[](_tokens.length);\r\n        for (uint256 i; i < _tokens.length; i++) {\r\n            address token = _tokens[i];\r\n            outputPools[i] = pools[cachedTokenValues[token].poolId];\r\n        }\r\n        return outputPools;\r\n    }\r\n    function getPoolsBalancesByTokens(\r\n        address[] calldata _tokens\r\n    )\r\n        external\r\n        view\r\n        returns (PoolBalances[] memory)\r\n    {\r\n        PoolBalances[] memory outputPools = new PoolBalances[](_tokens.length);\r\n        for (uint256 i; i < _tokens.length; i++) {\r\n            address token = _tokens[i];\r\n            outputPools[i] = _getPoolBalances(token);\r\n        }\r\n        return outputPools;\r\n    }\r\n    function getCurrentFeeBasedOnTrades(\r\n        address _token\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 fee)\r\n    {\r\n        Pool storage pool = pools[cachedTokenValues[_token].poolId];\r\n        PoolBalances memory poolBalances = _getPoolBalances(\r\n            _token\r\n        );\r\n        return _getCurrentFeeBasedOnTrades(\r\n            pool,\r\n            poolBalances\r\n        );\r\n    }\r\n    function getOutputExactTokensForTokens(\r\n        address _tokenIn,\r\n        address _tokenOut,\r\n        uint256 _amountTokensIn\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (_tokenOut == CER_USD_TOKEN) {\r\n            return _getOutputExactTokensForCerUsd(\r\n                _getPoolBalances(_tokenIn),\r\n                _tokenIn,\r\n                _amountTokensIn\r\n            );\r\n        }\r\n        if (_tokenIn == CER_USD_TOKEN) {\r\n            return _getOutputExactCerUsdForTokens(\r\n                _getPoolBalances(_tokenOut),\r\n                _amountTokensIn\r\n            );\r\n        }\r\n        uint256 amountCerUsdOut = _getOutputExactTokensForCerUsd(\r\n            _getPoolBalances(_tokenIn),\r\n            _tokenIn,\r\n            _amountTokensIn\r\n        );\r\n        return _getOutputExactCerUsdForTokens(\r\n            _getPoolBalances(_tokenOut),\r\n            amountCerUsdOut\r\n        );\r\n    }\r\n    function getInputTokensForExactTokens(\r\n        address _tokenIn,\r\n        address _tokenOut,\r\n        uint256 _amountTokensOut\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (_tokenOut == CER_USD_TOKEN) {\r\n            return _getInputTokensForExactCerUsd(\r\n                _getPoolBalances(_tokenIn),\r\n                _tokenIn,\r\n                _amountTokensOut\r\n            );\r\n        }\r\n        if (_tokenIn == CER_USD_TOKEN) {\r\n            return _getInputCerUsdForExactTokens(\r\n                _getPoolBalances(_tokenOut),\r\n                _amountTokensOut\r\n            );\r\n        }\r\n        uint256 amountCerUsdOut = _getInputCerUsdForExactTokens(\r\n            _getPoolBalances(_tokenOut),\r\n            _amountTokensOut\r\n        );\r\n        return _getInputTokensForExactCerUsd(\r\n            _getPoolBalances(_tokenIn),\r\n            _tokenIn,\r\n            amountCerUsdOut\r\n        );\r\n    }\r\n    function _getCurrentPeriod()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return block.timestamp\r\n            / ONE_PERIOD_IN_SECONDS\r\n            % NUMBER_OF_TRADE_PERIODS;\r\n    }\r\n    function _getCurrentFeeBasedOnTrades(\r\n        Pool storage _pool,\r\n        PoolBalances memory _poolBalances\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 currentPeriod = _getCurrentPeriod();\r\n        uint256 volume;\r\n        for (uint256 i; i < NUMBER_OF_TRADE_PERIODS; i++) {\r\n            if (i == currentPeriod) continue;\r\n            volume += _pool.tradeVolumePerPeriodInCerUsd[i];\r\n        }\r\n        volume = (volume - NUMBER_OF_TRADE_PERIODS_MINUS_ONE) * TRADE_VOLUME_DENORM;\r\n        uint256 tvlMin = _poolBalances.balanceCerUsd\r\n            * uint256(settings.tvlMultiplierMinimum)\r\n            / TVL_MULTIPLIER_DENORM;\r\n        uint256 tvlMax = _poolBalances.balanceCerUsd\r\n            * uint256(settings.tvlMultiplierMaximum)\r\n            / TVL_MULTIPLIER_DENORM;\r\n        if (volume <= tvlMin) {\r\n            return uint256(settings.feeMaximum);\r\n        }\r\n        if (volume >= tvlMax) {\r\n            return uint256(settings.feeMinimum);\r\n        }\r\n        return uint256(settings.feeMaximum)\r\n            - (uint256(settings.feeMaximum) - uint256(settings.feeMinimum))\r\n            * (volume - tvlMin)\r\n            / (tvlMax - tvlMin);\r\n    }\r\n    function _getOutputExactTokensForCerUsd(\r\n        PoolBalances memory poolBalances,\r\n        address _token,\r\n        uint256 _amountTokensIn\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Pool storage pool = pools[cachedTokenValues[_token].poolId];\r\n        return _getOutput(\r\n            _amountTokensIn,\r\n            uint256(poolBalances.balanceToken),\r\n            uint256(poolBalances.balanceCerUsd),\r\n            _getCurrentFeeBasedOnTrades(\r\n                pool,\r\n                poolBalances\r\n            )\r\n        );\r\n    }\r\n    function _getOutputExactCerUsdForTokens(\r\n        PoolBalances memory poolBalances,\r\n        uint256 _amountCerUsdIn\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return _getOutput(\r\n            _amountCerUsdIn,\r\n            uint256(poolBalances.balanceCerUsd),\r\n            uint256(poolBalances.balanceToken),\r\n            0\r\n        );\r\n    }\r\n    function _getOutput(\r\n        uint256 _amountIn,\r\n        uint256 _reservesIn,\r\n        uint256 _reservesOut,\r\n        uint256 _fee\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 amountInWithFee = _amountIn\r\n            * (FEE_DENORM - _fee);\r\n        return amountInWithFee\r\n            * _reservesOut\r\n            / (_reservesIn * FEE_DENORM + amountInWithFee);\r\n    }\r\n    function _getInputTokensForExactCerUsd(\r\n        PoolBalances memory poolBalances,\r\n        address _token,\r\n        uint256 _amountCerUsdOut\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Pool storage pool = pools[cachedTokenValues[_token].poolId];\r\n        return _getInput(\r\n            _amountCerUsdOut,\r\n            uint256(poolBalances.balanceToken),\r\n            uint256(poolBalances.balanceCerUsd),\r\n            _getCurrentFeeBasedOnTrades(\r\n                pool,\r\n                poolBalances\r\n            )\r\n        );\r\n    }\r\n    function _getInputCerUsdForExactTokens(\r\n        PoolBalances memory poolBalances,\r\n        uint256 _amountTokensOut\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return _getInput(\r\n            _amountTokensOut,\r\n            uint256(poolBalances.balanceCerUsd),\r\n            uint256(poolBalances.balanceToken),\r\n            0\r\n        );\r\n    }\r\n    function _getInput(\r\n        uint256 _amountOut,\r\n        uint256 _reservesIn,\r\n        uint256 _reservesOut,\r\n        uint256 _fee\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return _reservesIn\r\n            * _amountOut\r\n            * FEE_DENORM\r\n            / (FEE_DENORM - _fee)\r\n            / (_reservesOut - _amountOut)\r\n            + 1;\r\n    }\r\n}\r\npragma solidity ^0.8.12;\r\nabstract contract CerbySwapV1_LiquidityFunctions is\r\n    CerbySwapV1_Modifiers,\r\n    CerbySwapV1_Math,\r\n    CerbySwapV1_ERC1155,\r\n    CerbySwapV1_GetFunctions\r\n{\r\n    function increaseCerUsdCreditInPool(\r\n        address _token,\r\n        uint256 _amountCerUsdCredit\r\n    )\r\n        external\r\n    {\r\n        Pool storage pool = pools[cachedTokenValues[_token].poolId];\r\n        if (pool.creditCerUsd == MAX_CER_USD_CREDIT) {\r\n            revert CerbySwapV1_CreditCerUsdIsAlreadyMaximum();\r\n        }\r\n        pool.creditCerUsd += uint128(\r\n            _amountCerUsdCredit\r\n        );\r\n        ICerbyTokenMinterBurner(CER_USD_TOKEN).burnHumanAddress(\r\n            msg.sender,\r\n            _amountCerUsdCredit\r\n        );\r\n        PoolBalances memory poolBalances = _getPoolBalances(\r\n            _token\r\n        );\r\n        emit Sync(\r\n            _token,\r\n            poolBalances.balanceToken,\r\n            poolBalances.balanceCerUsd,\r\n            pool.creditCerUsd\r\n        );\r\n    }\r\n    function createPool(\r\n        address _token,\r\n        uint256 _amountTokensIn,\r\n        uint256 _amountCerUsdToMint,\r\n        address _transferTo\r\n    )\r\n        external\r\n        payable\r\n        detectBotTransactionThenRegisterTransactionAndExecuteCronJobsAfter(_token, msg.sender, _token, _transferTo)\r\n    {\r\n        _createPool(\r\n            _token,\r\n            _amountTokensIn,\r\n            _amountCerUsdToMint,\r\n            0,\r\n            _transferTo\r\n        );\r\n    }\r\n    function _createPool(\r\n        address _token,\r\n        uint256 _amountTokensIn,\r\n        uint256 _amountCerUsdToMint,\r\n        uint256 _creditCerUsd,\r\n        address _transferTo\r\n    )\r\n        internal\r\n    {\r\n        if (cachedTokenValues[_token].poolId > 0) {\r\n            revert CerbySwapV1_TokenAlreadyExists();\r\n        }\r\n        address vaultAddress = cloneVault(\r\n            _token\r\n        );\r\n        ICerbySwapV1_Vault(vaultAddress).initialize(\r\n            _token\r\n        );\r\n        _safeTransferFromHelper(\r\n            _token,\r\n            msg.sender,\r\n            vaultAddress,\r\n            _amountTokensIn\r\n        );\r\n        ICerbyTokenMinterBurner(CER_USD_TOKEN).mintHumanAddress(\r\n            vaultAddress,\r\n            _amountCerUsdToMint\r\n        );\r\n        _amountTokensIn = _getTokenBalance(\r\n            _token,\r\n            vaultAddress\r\n        );\r\n        if (_amountTokensIn <= 1) {\r\n            revert CerbySwapV1_AmountOfTokensMustBeLargerThanOne();\r\n        }\r\n        uint40[NUMBER_OF_TRADE_PERIODS] memory tradeVolumePerPeriodInCerUsd;\r\n        for (uint256 i; i < NUMBER_OF_TRADE_PERIODS; i++) {\r\n            tradeVolumePerPeriodInCerUsd[i] = 1;\r\n        }\r\n        uint256 newSqrtKValue = sqrt(\r\n            _amountTokensIn * _amountCerUsdToMint\r\n        );\r\n        Pool memory pool = Pool({\r\n            tradeVolumePerPeriodInCerUsd: tradeVolumePerPeriodInCerUsd,\r\n            lastCachedFee: uint8(settings.feeMaximum),\r\n            lastCachedTradePeriod: uint8(_getCurrentPeriod()),\r\n            lastSqrtKValue: uint128(newSqrtKValue),\r\n            creditCerUsd: uint128(_creditCerUsd)\r\n        });\r\n        uint256 poolId = pools.length;\r\n        pools.push(pool);\r\n        cachedTokenValues[_token].poolId = uint96(poolId);\r\n        _mint(\r\n            DEAD_ADDRESS,\r\n            poolId,\r\n            MINIMUM_LIQUIDITY\r\n        );\r\n        uint256 lpAmount = newSqrtKValue\r\n            - MINIMUM_LIQUIDITY;\r\n        _mint(\r\n            _transferTo,\r\n            poolId,\r\n            lpAmount\r\n        );\r\n        emit PoolCreated(\r\n            _token,\r\n            vaultAddress,\r\n            poolId\r\n        );\r\n        emit LiquidityAdded(\r\n            _token,\r\n            _amountTokensIn,\r\n            _amountCerUsdToMint,\r\n            lpAmount\r\n        );\r\n        emit Sync(\r\n            _token,\r\n            _amountTokensIn,\r\n            _amountCerUsdToMint,\r\n            _creditCerUsd\r\n        );\r\n    }\r\n    function addTokenLiquidity(\r\n        address _token,\r\n        uint256 _amountTokensIn,\r\n        uint256 _expireTimestamp,\r\n        address _transferTo\r\n    )\r\n        external\r\n        payable\r\n        detectBotTransactionThenRegisterTransactionAndExecuteCronJobsAfter(_token, msg.sender, _token, _transferTo)\r\n        tokenMustExistInPool(_token)\r\n        transactionIsNotExpired(_expireTimestamp)\r\n        returns (uint256)\r\n    {\r\n        return _addTokenLiquidity(\r\n            _token,\r\n            _amountTokensIn,\r\n            _transferTo\r\n        );\r\n    }\r\n    function _addTokenLiquidity(\r\n        address _token,\r\n        uint256 _amountTokensIn,\r\n        address _transferTo\r\n    )\r\n        private\r\n        returns (uint256)\r\n    {\r\n        uint256 poolId = cachedTokenValues[_token].poolId;\r\n        Pool storage pool = pools[poolId];\r\n        address vaultInAddress = _getCachedVaultCloneAddressByToken(\r\n            _token\r\n        );\r\n        PoolBalances memory poolBalancesBefore = _getPoolBalances(\r\n            _token\r\n        );\r\n        _safeTransferFromHelper(\r\n            _token,\r\n            msg.sender,\r\n            vaultInAddress,\r\n            _amountTokensIn\r\n        );\r\n        uint256 tokenBalanceAfter = _getTokenBalance(\r\n            _token,\r\n            vaultInAddress\r\n        );\r\n        _amountTokensIn = tokenBalanceAfter\r\n            - poolBalancesBefore.balanceToken;\r\n        if (_amountTokensIn <= 1) {\r\n            revert CerbySwapV1_AmountOfTokensMustBeLargerThanOne();\r\n        }\r\n        uint256 amountLpTokensToMintAsFee = _getMintFeeLiquidityAmount(\r\n            uint256(pool.lastSqrtKValue),\r\n            sqrt(poolBalancesBefore.balanceToken * poolBalancesBefore.balanceCerUsd),\r\n            erc1155TotalSupply[poolId]\r\n        );\r\n        _mint(\r\n            settings.mintFeeBeneficiary,\r\n            poolId,\r\n            amountLpTokensToMintAsFee\r\n        );\r\n        uint256 amountCerUsdToMint = _amountTokensIn\r\n            * poolBalancesBefore.balanceCerUsd\r\n            / poolBalancesBefore.balanceToken;\r\n        if (amountCerUsdToMint <= 1) {\r\n            revert CerbySwapV1_AmountOfCerUsdMustBeLargerThanOne();\r\n        }\r\n        pool.lastSqrtKValue = uint128(\r\n            sqrt(\r\n                tokenBalanceAfter\r\n                * (poolBalancesBefore.balanceCerUsd + amountCerUsdToMint)\r\n            )\r\n        );\r\n        ICerbyTokenMinterBurner(CER_USD_TOKEN).mintHumanAddress(\r\n            vaultInAddress,\r\n            amountCerUsdToMint\r\n        );\r\n        uint256 lpAmount = _amountTokensIn\r\n            * erc1155TotalSupply[poolId]\r\n            / poolBalancesBefore.balanceToken;\r\n        _mint(\r\n            _transferTo,\r\n            poolId,\r\n            lpAmount\r\n        );\r\n        emit LiquidityAdded(\r\n            _token,\r\n            _amountTokensIn,\r\n            amountCerUsdToMint,\r\n            lpAmount\r\n        );\r\n        emit Sync(\r\n            _token,\r\n            tokenBalanceAfter,\r\n            poolBalancesBefore.balanceCerUsd + amountCerUsdToMint,\r\n            pool.creditCerUsd\r\n        );\r\n        return lpAmount;\r\n    }\r\n    function removeTokenLiquidity(\r\n        address _token,\r\n        uint256 _amountLpTokensBalanceToBurn,\r\n        uint256 _expireTimestamp,\r\n        address _transferTo\r\n    )\r\n        external\r\n        detectBotTransactionThenRegisterTransactionAndExecuteCronJobsAfter(_token, msg.sender, _token, _transferTo)\r\n        tokenMustExistInPool(_token)\r\n        transactionIsNotExpired(_expireTimestamp)\r\n        returns (uint256)\r\n    {\r\n        return _removeTokenLiquidity(\r\n            _token,\r\n            _amountLpTokensBalanceToBurn,\r\n            _transferTo\r\n        );\r\n    }\r\n    function _removeTokenLiquidity(\r\n        address _token,\r\n        uint256 _amountLpTokensBalanceToBurn,\r\n        address _transferTo\r\n    )\r\n        private\r\n        returns (uint256)\r\n    {\r\n        uint256 poolId = cachedTokenValues[_token].poolId;\r\n        Pool storage pool = pools[poolId];\r\n        PoolBalances memory poolBalancesBefore = _getPoolBalances(\r\n            _token\r\n        );\r\n        uint256 amountLpTokensToMintAsFee = _getMintFeeLiquidityAmount(\r\n            uint256(pool.lastSqrtKValue),\r\n            sqrt(poolBalancesBefore.balanceToken * poolBalancesBefore.balanceCerUsd),\r\n            erc1155TotalSupply[poolId]\r\n        );\r\n        _mint(\r\n            settings.mintFeeBeneficiary,\r\n            poolId,\r\n            amountLpTokensToMintAsFee\r\n        );\r\n        uint256 amountTokensOut = poolBalancesBefore.balanceToken\r\n            * _amountLpTokensBalanceToBurn\r\n            / erc1155TotalSupply[poolId];\r\n        uint256 amountCerUsdToBurn = poolBalancesBefore.balanceCerUsd\r\n            * _amountLpTokensBalanceToBurn\r\n            / erc1155TotalSupply[poolId];\r\n        PoolBalances memory poolBalancesAfter = PoolBalances(\r\n            poolBalancesBefore.balanceToken - amountTokensOut,\r\n            poolBalancesBefore.balanceCerUsd - amountCerUsdToBurn\r\n        );\r\n        pool.lastSqrtKValue = uint128(\r\n            sqrt(poolBalancesAfter.balanceToken * poolBalancesAfter.balanceCerUsd)\r\n        );\r\n        _burn(\r\n            msg.sender,\r\n            poolId,\r\n            _amountLpTokensBalanceToBurn\r\n        );\r\n        address vaultOutAddress = _getCachedVaultCloneAddressByToken(\r\n            _token\r\n        );\r\n        ICerbyTokenMinterBurner(CER_USD_TOKEN).burnHumanAddress(\r\n            vaultOutAddress,\r\n            amountCerUsdToBurn\r\n        );\r\n        _safeTransferFromHelper(\r\n            _token,\r\n            vaultOutAddress,\r\n            _transferTo,\r\n            amountTokensOut\r\n        );\r\n        emit LiquidityRemoved(\r\n            _token,\r\n            amountTokensOut,\r\n            amountCerUsdToBurn,\r\n            _amountLpTokensBalanceToBurn\r\n        );\r\n        emit Sync(\r\n            _token,\r\n            poolBalancesAfter.balanceToken,\r\n            poolBalancesAfter.balanceCerUsd,\r\n            pool.creditCerUsd\r\n        );\r\n        return amountTokensOut;\r\n    }\r\n    function _getMintFeeLiquidityAmount(\r\n        uint256 _oldSqrtKValue,\r\n        uint256 _newSqrtKValue,\r\n        uint256 _totalLPSupply\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 mintFeePercentage = uint256(\r\n            settings.mintFeeMultiplier\r\n        );\r\n        if (\r\n            mintFeePercentage == 0 ||\r\n            _newSqrtKValue <= _oldSqrtKValue\r\n        ) {\r\n            return 0;\r\n        }\r\n        return _totalLPSupply\r\n            * mintFeePercentage\r\n            * (_newSqrtKValue - _oldSqrtKValue)\r\n            / (\r\n                _newSqrtKValue\r\n                * (MINT_FEE_DENORM - mintFeePercentage)\r\n                    + _oldSqrtKValue * mintFeePercentage\r\n            );\r\n    }\r\n}\r\npragma solidity ^0.8.12;\r\nabstract contract CerbySwapV1_SwapFunctions is CerbySwapV1_LiquidityFunctions {\r\n    function swapExactTokensForTokens(\r\n        address _tokenIn,\r\n        address _tokenOut,\r\n        uint256 _amountTokensIn,\r\n        uint256 _minAmountTokensOut,\r\n        uint256 _expireTimestamp,\r\n        address _transferTo\r\n    )\r\n        external\r\n        payable\r\n        detectBotTransactionThenRegisterTransactionAndExecuteCronJobsAfter(_tokenIn, msg.sender, _tokenOut, _transferTo)\r\n        transactionIsNotExpired(_expireTimestamp)\r\n        returns (uint256[] memory)\r\n    {\r\n        return _swapExactTokensForTokens(\r\n            _tokenIn,\r\n            _tokenOut,\r\n            _amountTokensIn,\r\n            _minAmountTokensOut,\r\n            _transferTo\r\n        );\r\n    }\r\n    function _swapExactTokensForTokens(\r\n        address _tokenIn,\r\n        address _tokenOut,\r\n        uint256 _amountTokensIn,\r\n        uint256 _minAmountTokensOut,\r\n        address _transferTo\r\n    )\r\n        private\r\n        returns (uint256[] memory)\r\n    {\r\n        if (_tokenIn == _tokenOut) {\r\n            revert CerbySwapV1_SwappingTokenToSameTokenIsForbidden();\r\n        }\r\n        address vaultAddressIn = _getCachedVaultCloneAddressByToken(\r\n            _tokenIn\r\n        );\r\n        uint256[] memory amounts = new uint256[](2);\r\n        amounts[0] = _amountTokensIn;\r\n        PoolBalances memory poolInBalancesBefore;\r\n        if (_tokenOut == CER_USD_TOKEN) {\r\n            poolInBalancesBefore = _getPoolBalances(\r\n                _tokenIn\r\n            );\r\n            amounts[1] = _getOutputExactTokensForCerUsd(\r\n                poolInBalancesBefore,\r\n                _tokenIn,\r\n                _amountTokensIn\r\n            );\r\n            if (amounts[1] < _minAmountTokensOut) {\r\n                revert CerbySwapV1_OutputCerUsdAmountIsLowerThanMinimumSpecified();\r\n            }\r\n            _safeTransferFromHelper(\r\n                _tokenIn,\r\n                msg.sender,\r\n                vaultAddressIn,\r\n                _amountTokensIn\r\n            );\r\n            _swap(\r\n                _tokenIn,\r\n                poolInBalancesBefore,\r\n                0,\r\n                amounts[1],\r\n                _transferTo\r\n            );\r\n            return amounts;\r\n        }\r\n        address vaultAddressOut = _getCachedVaultCloneAddressByToken(\r\n            _tokenOut\r\n        );\r\n        PoolBalances memory poolOutBalancesBefore;\r\n        if (_tokenIn == CER_USD_TOKEN) {\r\n            poolOutBalancesBefore = _getPoolBalances(\r\n                _tokenOut\r\n            );\r\n            amounts[1] = _getOutputExactCerUsdForTokens(\r\n                poolOutBalancesBefore,\r\n                _amountTokensIn\r\n            );\r\n            if (amounts[1] < _minAmountTokensOut) {\r\n                revert CerbySwapV1_OutputTokensAmountIsLowerThanMinimumSpecified();\r\n            }\r\n            _safeTransferFromHelper(\r\n                _tokenIn,\r\n                msg.sender,\r\n                vaultAddressOut,\r\n                _amountTokensIn\r\n            );\r\n            _swap(\r\n                _tokenOut,\r\n                poolOutBalancesBefore,\r\n                amounts[1],\r\n                0,\r\n                _transferTo\r\n            );\r\n            return amounts;\r\n        }\r\n        poolInBalancesBefore = _getPoolBalances(\r\n            _tokenIn\r\n        );\r\n        uint256 amountCerUsdOut = _getOutputExactTokensForCerUsd(\r\n            poolInBalancesBefore,\r\n            _tokenIn,\r\n            _amountTokensIn\r\n        );\r\n        poolOutBalancesBefore = _getPoolBalances(\r\n            _tokenOut\r\n        );\r\n        amounts[1] = _getOutputExactCerUsdForTokens(\r\n            poolOutBalancesBefore,\r\n            amountCerUsdOut\r\n        );\r\n        if (amounts[1] < _minAmountTokensOut) {\r\n            revert CerbySwapV1_OutputTokensAmountIsLowerThanMinimumSpecified();\r\n        }\r\n        _safeTransferFromHelper(\r\n            _tokenIn,\r\n            msg.sender,\r\n            vaultAddressIn,\r\n            _amountTokensIn\r\n        );\r\n        _swap(\r\n            _tokenIn,\r\n            poolInBalancesBefore,\r\n            0,\r\n            amountCerUsdOut,\r\n            vaultAddressOut\r\n        );\r\n        _swap(\r\n            _tokenOut,\r\n            poolOutBalancesBefore,\r\n            amounts[1],\r\n            0,\r\n            _transferTo\r\n        );\r\n        return amounts;\r\n    }\r\n    function swapTokensForExactTokens(\r\n        address _tokenIn,\r\n        address _tokenOut,\r\n        uint256 _amountTokensOut,\r\n        uint256 _maxAmountTokensIn,\r\n        uint256 _expireTimestamp,\r\n        address _transferTo\r\n    )\r\n        external\r\n        payable\r\n        detectBotTransactionThenRegisterTransactionAndExecuteCronJobsAfter(_tokenIn, msg.sender, _tokenOut, _transferTo)\r\n        transactionIsNotExpired(_expireTimestamp)\r\n        returns (uint256[] memory)\r\n    {\r\n        return _swapTokensForExactTokens(\r\n            _tokenIn,\r\n            _tokenOut,\r\n            _amountTokensOut,\r\n            _maxAmountTokensIn,\r\n            _transferTo\r\n        );\r\n    }\r\n    function _swapTokensForExactTokens(\r\n        address _tokenIn,\r\n        address _tokenOut,\r\n        uint256 _amountTokensOut,\r\n        uint256 _maxAmountTokensIn,\r\n        address _transferTo\r\n    )\r\n        private\r\n        returns (uint256[] memory)\r\n    {\r\n        if (_tokenIn == _tokenOut) {\r\n            revert CerbySwapV1_SwappingTokenToSameTokenIsForbidden();\r\n        }\r\n        address vaultAddressIn = _getCachedVaultCloneAddressByToken(\r\n            _tokenIn\r\n        );\r\n        uint256[] memory amounts = new uint256[](2);\r\n        amounts[1] = _amountTokensOut;\r\n        PoolBalances memory poolInBalancesBefore;\r\n        if (_tokenOut == CER_USD_TOKEN) {\r\n            poolInBalancesBefore = _getPoolBalances(\r\n                _tokenIn\r\n            );\r\n            amounts[0] = _getInputTokensForExactCerUsd(\r\n                poolInBalancesBefore,\r\n                _tokenIn,\r\n                _amountTokensOut\r\n            );\r\n            if (amounts[0] > _maxAmountTokensIn) {\r\n                revert CerbySwapV1_InputTokensAmountIsLargerThanMaximumSpecified();\r\n            }\r\n            _safeTransferFromHelper(\r\n                _tokenIn,\r\n                msg.sender,\r\n                vaultAddressIn,\r\n                amounts[0]\r\n            );\r\n            _swap(\r\n                _tokenIn,\r\n                poolInBalancesBefore,\r\n                0,\r\n                _amountTokensOut,\r\n                _transferTo\r\n            );\r\n            return amounts;\r\n        }\r\n        address vaultAddressOut = _getCachedVaultCloneAddressByToken(\r\n            _tokenOut\r\n        );\r\n        PoolBalances memory poolOutBalancesBefore;\r\n        if (_tokenIn == CER_USD_TOKEN) {\r\n            poolOutBalancesBefore = _getPoolBalances(\r\n                _tokenOut\r\n            );\r\n            amounts[0] = _getInputCerUsdForExactTokens(\r\n                poolOutBalancesBefore,\r\n                _amountTokensOut\r\n            );\r\n            if (amounts[0] > _maxAmountTokensIn) {\r\n                revert CerbySwapV1_InputCerUsdAmountIsLargerThanMaximumSpecified();\r\n            }\r\n            _safeTransferFromHelper(\r\n                _tokenIn,\r\n                msg.sender,\r\n                vaultAddressOut,\r\n                amounts[0]\r\n            );\r\n            _swap(\r\n                _tokenOut,\r\n                poolOutBalancesBefore,\r\n                _amountTokensOut,\r\n                0,\r\n                _transferTo\r\n            );\r\n            return amounts;\r\n        }\r\n        poolOutBalancesBefore = _getPoolBalances(\r\n            _tokenOut\r\n        );\r\n        uint256 amountCerUsdOut = _getInputCerUsdForExactTokens(\r\n            poolOutBalancesBefore,\r\n            _amountTokensOut\r\n        );\r\n        if (amountCerUsdOut <= 1) {\r\n            revert CerbySwapV1_AmountOfCerUsdMustBeLargerThanOne();\r\n        }\r\n        poolInBalancesBefore = _getPoolBalances(\r\n            _tokenIn\r\n        );\r\n        amounts[0] = _getInputTokensForExactCerUsd(\r\n            poolInBalancesBefore,\r\n            _tokenIn,\r\n            amountCerUsdOut\r\n        );\r\n        if (amounts[0] > _maxAmountTokensIn) {\r\n            revert CerbySwapV1_InputTokensAmountIsLargerThanMaximumSpecified();\r\n        }\r\n        _safeTransferFromHelper(\r\n            _tokenIn,\r\n            msg.sender,\r\n            vaultAddressIn,\r\n            amounts[0]\r\n        );\r\n        _swap(\r\n            _tokenIn,\r\n            poolInBalancesBefore,\r\n            0,\r\n            amountCerUsdOut,\r\n            vaultAddressOut\r\n        );\r\n        _swap(\r\n            _tokenOut,\r\n            poolOutBalancesBefore,\r\n            _amountTokensOut,\r\n            0,\r\n            _transferTo\r\n        );\r\n        return amounts;\r\n    }\r\n    function _swap(\r\n        address _token,\r\n        PoolBalances memory _poolBalancesBefore,\r\n        uint256 _amountTokensOut,\r\n        uint256 _amountCerUsdOut,\r\n        address _transferTo\r\n    )\r\n        private\r\n    {\r\n        PoolBalances memory poolBalancesAfter = _getPoolBalances(\r\n            _token\r\n        );\r\n        uint256 amountCerUsdIn = poolBalancesAfter.balanceCerUsd\r\n            - _poolBalancesBefore.balanceCerUsd;\r\n        uint256 amountTokensIn = poolBalancesAfter.balanceToken\r\n            - _poolBalancesBefore.balanceToken;\r\n        if (amountTokensIn + amountCerUsdIn <= 1) {\r\n            revert CerbySwapV1_AmountOfCerUsdOrTokensInMustBeLargerThanOne();\r\n        }\r\n        Pool storage pool = pools[cachedTokenValues[_token].poolId];\r\n        if (\r\n            pool.creditCerUsd < MAX_CER_USD_CREDIT &&\r\n            uint256(pool.creditCerUsd) + amountCerUsdIn < _amountCerUsdOut\r\n        ) {\r\n            revert CerbySwapV1_CreditCerUsdMustNotBeBelowZero();\r\n        }\r\n        uint256 currentPeriod = _getCurrentPeriod();\r\n        uint256 fee;\r\n        {\r\n            if (amountCerUsdIn <= 1 && amountTokensIn > 1) {\r\n                uint256 lastPeriodI = uint256(\r\n                    pool.lastCachedTradePeriod\r\n                );\r\n                if (lastPeriodI != currentPeriod) {\r\n                    uint256 endPeriod = currentPeriod < lastPeriodI\r\n                        ? currentPeriod + NUMBER_OF_TRADE_PERIODS\r\n                        : currentPeriod;\r\n                    while(++lastPeriodI <= endPeriod) {\r\n                        pool.tradeVolumePerPeriodInCerUsd[lastPeriodI % NUMBER_OF_TRADE_PERIODS] = 1;\r\n                    }\r\n                    pool.lastCachedFee = uint8(\r\n                        _getCurrentFeeBasedOnTrades(\r\n                            pool,\r\n                            _poolBalancesBefore\r\n                        )\r\n                    );\r\n                    pool.lastCachedTradePeriod = uint8(\r\n                        currentPeriod\r\n                    );\r\n                }\r\n                fee = uint256(pool.lastCachedFee);\r\n            }\r\n            uint256 beforeKValueDenormed = _poolBalancesBefore.balanceToken\r\n                * _poolBalancesBefore.balanceCerUsd\r\n                * FEE_DENORM_SQUARED;\r\n            uint256 afterKValueDenormed = (\r\n                    poolBalancesAfter.balanceCerUsd\r\n                    * FEE_DENORM\r\n                        - amountCerUsdIn\r\n                        * fee\r\n                )\r\n                * (\r\n                    poolBalancesAfter.balanceToken\r\n                    * FEE_DENORM\r\n                        - amountTokensIn\r\n                        * fee\r\n                );\r\n            if (afterKValueDenormed < beforeKValueDenormed) {\r\n                revert CerbySwapV1_InvariantKValueMustBeSameOrIncreasedOnAnySwaps();\r\n            }\r\n            if (pool.creditCerUsd < MAX_CER_USD_CREDIT) {\r\n                pool.creditCerUsd = uint128(\r\n                    uint256(pool.creditCerUsd)\r\n                        + amountCerUsdIn\r\n                        - _amountCerUsdOut\r\n                );\r\n            }\r\n            if (_amountCerUsdOut > TRADE_VOLUME_DENORM) {\r\n                uint256 updatedTradeVolume = _amountCerUsdOut\r\n                    / TRADE_VOLUME_DENORM\r\n                    + uint256(pool.tradeVolumePerPeriodInCerUsd[currentPeriod]);\r\n                pool.tradeVolumePerPeriodInCerUsd[currentPeriod] = updatedTradeVolume < type(uint40).max\r\n                    ? uint40(updatedTradeVolume)\r\n                    : type(uint40).max;\r\n            }\r\n        }\r\n        address vault = _getCachedVaultCloneAddressByToken(\r\n            _token\r\n        );\r\n        _safeTransferFromHelper(\r\n            CER_USD_TOKEN,\r\n            vault,\r\n            _transferTo,\r\n            _amountCerUsdOut\r\n        );\r\n        _safeTransferFromHelper(\r\n            _token,\r\n            vault,\r\n            _transferTo,\r\n            _amountTokensOut\r\n        );\r\n        emit Swap(\r\n            _token,\r\n            msg.sender,\r\n            amountTokensIn,\r\n            amountCerUsdIn,\r\n            _amountTokensOut,\r\n            _amountCerUsdOut,\r\n            fee,\r\n            _transferTo\r\n        );\r\n        emit Sync(\r\n            _token,\r\n            poolBalancesAfter.balanceToken,\r\n            poolBalancesAfter.balanceCerUsd,\r\n            pool.creditCerUsd\r\n        );\r\n    }\r\n}\r\npragma solidity ^0.8.0;\r\nabstract contract Ownable {\r\n    address private contractOwner;\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    error Ownable_CallerIsNotOwner();\r\n    error Ownable_NewOwnerIsNotTheZeroAddress();\r\n    constructor() {}\r\n    function owner() public view virtual returns (address) {\r\n        return contractOwner;\r\n    }\r\n    modifier onlyOwner() {\r\n        if (contractOwner != msg.sender) {\r\n            revert Ownable_CallerIsNotOwner();\r\n        }\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n    function transferOwnership(address _newOwner) public virtual onlyOwner {\r\n        if (_newOwner == address(0)) {\r\n            revert Ownable_NewOwnerIsNotTheZeroAddress();\r\n        }\r\n        _transferOwnership(_newOwner);\r\n    }\r\n    function _transferOwnership(address _newOwner) internal virtual {\r\n        address oldOwner = contractOwner;\r\n        contractOwner = _newOwner;\r\n        emit OwnershipTransferred(oldOwner, _newOwner);\r\n    }\r\n}\r\npragma solidity ^0.8.12;\r\nabstract contract CerbySwapV1_AdminFunctions is\r\n    CerbySwapV1_SwapFunctions,\r\n    Ownable\r\n{\r\n    function adminSetUrlPrefix(\r\n        string calldata _newUrlPrefix\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        urlPrefix = _newUrlPrefix;\r\n    }\r\n    function adminUpdateNameAndSymbol(\r\n        string memory _newContractName,\r\n        string memory _newContractSymbol\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        contractName = _newContractName;\r\n        contractSymbol = _newContractSymbol;\r\n    }\r\n    function adminUpdateSettings(\r\n        Settings calldata _settings\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        if (\r\n            _settings.feeMinimum == 0 ||\r\n            _settings.feeMinimum > _settings.feeMaximum\r\n        ) {\r\n            revert CerbySwapV1_FeeIsWrong();\r\n        }\r\n        if (_settings.tvlMultiplierMinimum > _settings.tvlMultiplierMaximum) {\r\n            revert CerbySwapV1_TvlMultiplierIsWrong();\r\n        }\r\n        if (_settings.mintFeeMultiplier >= MINT_FEE_DENORM / 2) {\r\n            revert CerbySwapV1_MintFeeMultiplierMustNotBeLargerThan50Percent();\r\n        }\r\n        settings = _settings;\r\n    }\r\n    function adminCreatePool(\r\n        address _token,\r\n        uint256 _amountTokensIn,\r\n        uint256 _amountCerUsdToMint,\r\n        address _transferTo\r\n    )\r\n        external\r\n        payable\r\n        onlyOwner\r\n    {\r\n        _createPool(\r\n            _token,\r\n            _amountTokensIn,\r\n            _amountCerUsdToMint,\r\n            MAX_CER_USD_CREDIT,\r\n            _transferTo\r\n        );\r\n    }\r\n    function adminChangeCerUsdCreditInPool(\r\n        address _token,\r\n        uint256 _amountCerUsdCredit\r\n    )\r\n        external\r\n        onlyOwner\r\n        tokenMustExistInPool(_token)\r\n    {\r\n        PoolBalances memory poolBalances = _getPoolBalances(\r\n            _token\r\n        );\r\n        Pool storage pool = pools[cachedTokenValues[_token].poolId];\r\n        pool.creditCerUsd = uint128(\r\n            _amountCerUsdCredit\r\n        );\r\n        emit Sync(\r\n            _token,\r\n            poolBalances.balanceToken,\r\n            poolBalances.balanceCerUsd,\r\n            _amountCerUsdCredit\r\n        );\r\n    }\r\n}\r\npragma solidity ^0.8.12;\r\ncontract CerbySwapV1 is CerbySwapV1_AdminFunctions {\r\n    constructor() {\r\n        _transferOwnership(\r\n            msg.sender\r\n        );\r\n        if (block.chainid == ETH_MAINNET_CHAIN_ID) {\r\n            NATIVE_TOKEN = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n        } else if (block.chainid == BSC_MAINNET_CHAIN_ID) {\r\n            NATIVE_TOKEN = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n        } else if (block.chainid == POLYGON_MAINNET_CHAIN_ID) {\r\n            NATIVE_TOKEN = 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270;\r\n        } else if (block.chainid == AVALANCHE_MAINNET_CHAIN_ID) {\r\n            NATIVE_TOKEN = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\r\n        } else if (block.chainid == FANTOM_MAINNET_CHAIN_ID) {\r\n            NATIVE_TOKEN = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;\r\n        }\r\n        uint40[NUMBER_OF_TRADE_PERIODS] memory tradeVolumePerPeriodInCerUsd;\r\n        pools.push(\r\n            Pool({\r\n                tradeVolumePerPeriodInCerUsd: tradeVolumePerPeriodInCerUsd,\r\n                lastCachedTradePeriod: 0,\r\n                lastCachedFee: 0,\r\n                lastSqrtKValue: 0,\r\n                creditCerUsd: 0\r\n            })\r\n        );\r\n    }\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CerbyCronJobsExecution_TransactionsAreTemporarilyDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_AmountOfCerUsdMustBeLargerThanOne\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_AmountOfCerUsdOrTokensInMustBeLargerThanOne\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_AmountOfTokensMustBeLargerThanOne\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_CreditCerUsdIsAlreadyMaximum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_CreditCerUsdMustNotBeBelowZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_FeeIsWrong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_InputCerUsdAmountIsLargerThanMaximumSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_InputTokensAmountIsLargerThanMaximumSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_InvariantKValueMustBeSameOrIncreasedOnAnySwaps\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_MintFeeMultiplierMustNotBeLargerThan50Percent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_OutputCerUsdAmountIsLowerThanMinimumSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_OutputTokensAmountIsLowerThanMinimumSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_SafeTransferFromFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_SafeTransferNativeFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_SwappingTokenToSameTokenIsForbidden\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_TokenAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_TokenDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_TransactionIsExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CerbySwapV1_TvlMultiplierIsWrong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_BurnAmountExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_CallerIsNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_ERC1155ReceiverRejectsTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_IdsLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_InsufficientBalanceForTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_TransferToNonERC1155ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Ownable_CallerIsNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Ownable_NewOwnerIsNotTheZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountTokensIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountCerUsdToMint\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lpAmount\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountTokensOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountCerUsdToBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountLpTokensBalanceToBurn\",\"type\":\"uint256\"}],\"name\":\"LiquidityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountTokensIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountCerUsdIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountTokensOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountCerUsdOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_currentFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_transferTo\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newBalanceToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newBalanceCerUsd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newCreditCerUsd\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokensIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expireTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_transferTo\",\"type\":\"address\"}],\"name\":\"addTokenLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountCerUsdCredit\",\"type\":\"uint256\"}],\"name\":\"adminChangeCerUsdCreditInPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokensIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountCerUsdToMint\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_transferTo\",\"type\":\"address\"}],\"name\":\"adminCreatePool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newUrlPrefix\",\"type\":\"string\"}],\"name\":\"adminSetUrlPrefix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newContractName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_newContractSymbol\",\"type\":\"string\"}],\"name\":\"adminUpdateNameAndSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"mintFeeBeneficiary\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"mintFeeMultiplier\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"feeMinimum\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"feeMaximum\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"tvlMultiplierMinimum\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"tvlMultiplierMaximum\",\"type\":\"uint64\"}],\"internalType\":\"struct CerbySwapV1_Declarations.Settings\",\"name\":\"_settings\",\"type\":\"tuple\"}],\"name\":\"adminUpdateSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokensIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountCerUsdToMint\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_transferTo\",\"type\":\"address\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getCurrentFeeBasedOnTrades\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokensOut\",\"type\":\"uint256\"}],\"name\":\"getInputTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokensIn\",\"type\":\"uint256\"}],\"name\":\"getOutputExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"getPoolsBalancesByTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"balanceToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceCerUsd\",\"type\":\"uint256\"}],\"internalType\":\"struct CerbySwapV1_Declarations.PoolBalances[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"getPoolsByTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"uint40[6]\",\"name\":\"tradeVolumePerPeriodInCerUsd\",\"type\":\"uint40[6]\"},{\"internalType\":\"uint8\",\"name\":\"lastCachedFee\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"lastCachedTradePeriod\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"lastSqrtKValue\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"creditCerUsd\",\"type\":\"uint128\"}],\"internalType\":\"struct CerbySwapV1_Declarations.Pool[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSettings\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"mintFeeBeneficiary\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"mintFeeMultiplier\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"feeMinimum\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"feeMaximum\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"tvlMultiplierMinimum\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"tvlMultiplierMaximum\",\"type\":\"uint64\"}],\"internalType\":\"struct CerbySwapV1_Declarations.Settings\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getTokenToPoolId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pos\",\"type\":\"uint256\"}],\"name\":\"getUtilsContractAtPos\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountCerUsdCredit\",\"type\":\"uint256\"}],\"name\":\"increaseCerUsdCreditInPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountLpTokensBalanceToBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expireTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_transferTo\",\"type\":\"address\"}],\"name\":\"removeTokenLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokensIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountTokensOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expireTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_transferTo\",\"type\":\"address\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokensOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmountTokensIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expireTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_transferTo\",\"type\":\"address\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CerbySwapV1", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fa30f05a8dbadd60c9d56cf2f1ec7b21de437decdfbfad3c5c9c6703cb2ac24c"}]}