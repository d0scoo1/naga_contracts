{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@0xdievardump/signed-allowances/contracts/SignedAllowance.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\\n\\n/// @title SignedAllowance\\n/// @author Simon Fremaux (@dievardump)\\ncontract SignedAllowance {\\n    using ECDSA for bytes32;\\n\\n    // list of already used allowances\\n    mapping(bytes32 => bool) public usedAllowances;\\n\\n    // address used to sign the allowances\\n    address private _allowancesSigner;\\n\\n    /// @notice Helper to know allowancesSigner address\\n    /// @return the allowance signer address\\n    function allowancesSigner() public view virtual returns (address) {\\n        return _allowancesSigner;\\n    }\\n\\n    /// @notice Helper that creates the message that signer needs to sign to allow a mint\\n    ///         this is usually also used when creating the allowances, to ensure \\\"message\\\"\\n    ///         is the same\\n    /// @param account the account to allow\\n    /// @param nonce the nonce\\n    /// @return the message to sign\\n    function createMessage(address account, uint256 nonce)\\n        public\\n        view\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(account, nonce, address(this)));\\n    }\\n\\n    /// @notice Helper that creates a list of messages that signer needs to sign to allow mintings\\n    /// @param accounts the accounts to allow\\n    /// @param nonces the corresponding nonces\\n    /// @return messages the messages to sign\\n    function createMessages(address[] memory accounts, uint256[] memory nonces)\\n        external\\n        view\\n        returns (bytes32[] memory messages)\\n    {\\n        require(accounts.length == nonces.length, '!LENGTH_MISMATCH!');\\n        messages = new bytes32[](accounts.length);\\n        for (uint256 i; i < accounts.length; i++) {\\n            messages[i] = createMessage(accounts[i], nonces[i]);\\n        }\\n    }\\n\\n    /// @notice This function verifies that the current request is valid\\n    /// @dev It ensures that _allowancesSigner signed a message containing (account, nonce, address(this))\\n    ///      and that this message was not already used\\n    /// @param account the account the allowance is associated to\\n    /// @param nonce the nonce associated to this allowance\\n    /// @param signature the signature by the allowance signer wallet\\n    /// @return the message to mark as used\\n    function validateSignature(\\n        address account,\\n        uint256 nonce,\\n        bytes memory signature\\n    ) public view returns (bytes32) {\\n        return\\n            _validateSignature(account, nonce, signature, allowancesSigner());\\n    }\\n\\n    /// @dev It ensures that signer signed a message containing (account, nonce, address(this))\\n    ///      and that this message was not already used\\n    /// @param account the account the allowance is associated to\\n    /// @param nonce the nonce associated to this allowance\\n    /// @param signature the signature by the allowance signer wallet\\n    /// @param signer the signer\\n    /// @return the message to mark as used\\n    function _validateSignature(\\n        address account,\\n        uint256 nonce,\\n        bytes memory signature,\\n        address signer\\n    ) internal view returns (bytes32) {\\n        bytes32 message = createMessage(account, nonce)\\n            .toEthSignedMessageHash();\\n\\n        // verifies that the sha3(account, nonce, address(this)) has been signed by signer\\n        require(message.recover(signature) == signer, '!INVALID_SIGNATURE!');\\n\\n        // verifies that the allowances was not already used\\n        require(usedAllowances[message] == false, '!ALREADY_USED!');\\n\\n        return message;\\n    }\\n\\n    /// @notice internal function that verifies an allowance and marks it as used\\n    ///         this function throws if signature is wrong or this nonce for this user has already been used\\n    /// @param account the account the allowance is associated to\\n    /// @param nonce the nonce\\n    /// @param signature the signature by the allowance wallet\\n    function _useAllowance(\\n        address account,\\n        uint256 nonce,\\n        bytes memory signature\\n    ) internal {\\n        bytes32 message = validateSignature(account, nonce, signature);\\n        usedAllowances[message] = true;\\n    }\\n\\n    /// @notice Allows to change the allowance signer. This can be used to revoke any signed allowance not already used\\n    /// @param newSigner the new signer address\\n    function _setAllowancesSigner(address newSigner) internal {\\n        _allowancesSigner = newSigner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/EtherealStates/EtherealStates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\nimport {EtherealStatesMeta} from './EtherealStatesMeta.sol';\\n\\n/// @title EtherealStates - https://etherealstates.art\\n/// @author Artist: GenuineHumanArt (https://twitter.com/GenuineHumanArt)\\n/// @author Developer: dievardump (https://twitter.com/dievardump, dievardump@gmail.com)\\ncontract EtherealStates is EtherealStatesMeta {\\n    constructor(\\n        string memory contractURI_,\\n        address mintPasses,\\n        address newSigner,\\n        address dnaGenerator_,\\n        address metadataManager_,\\n        VRFConfig memory vrfConfig_\\n    )\\n        EtherealStatesMeta(\\n            contractURI_,\\n            mintPasses,\\n            newSigner,\\n            dnaGenerator_,\\n            metadataManager_,\\n            vrfConfig_\\n        )\\n    {}\\n}\\n\"\r\n    },\r\n    \"contracts/EtherealStates/EtherealStatesCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {IERC721A, ERC721A, ERC721ABurnable} from 'erc721a/contracts/extensions/ERC721ABurnable.sol';\\n\\n/// @title EtherealStatesCore\\n/// @author Artist: GenuineHumanArt (https://twitter.com/GenuineHumanArt)\\n/// @author Developer: dievardump (https://twitter.com/dievardump, dievardump@gmail.com)\\n/// @notice EtherealStates Core Logic\\ncontract EtherealStatesCore is\\n    ERC721A('Ethereal States', 'ESTS'),\\n    ERC721ABurnable,\\n    Ownable\\n{\\n    error WithdrawError();\\n\\n    /////////////////////////////////////////////////////////\\n    // Royalties                                           //\\n    /////////////////////////////////////////////////////////\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        override(ERC721A, IERC721A)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == this.royaltyInfo.selector ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @notice Royalties - ERC2981\\n    /// @param tokenId the tokenId\\n    /// @param amount the amount it's sold for\\n    /// @return the recipient and amount to send to it\\n    function royaltyInfo(uint256 tokenId, uint256 amount)\\n        external\\n        view\\n        returns (address, uint256)\\n    {\\n        return (owner(), (amount * 5) / 100);\\n    }\\n\\n    /////////////////////////////////////////////////////////\\n    // Gated Owner                                         //\\n    /////////////////////////////////////////////////////////\\n\\n    /// @notice allows owner to withdraw funds from the contract\\n    function withdraw(address token) external onlyOwner {\\n        if (address(0) != token) {\\n            IERC20(token).transfer(\\n                msg.sender,\\n                IERC20(token).balanceOf(address(this))\\n            );\\n        } else {\\n            uint256 balance = address(this).balance;\\n            if (balance > 0) {\\n                //solhint-disable-next-line avoid-low-level-calls\\n                (bool success, ) = msg.sender.call{value: balance}('');\\n                if (!success) revert WithdrawError();\\n            }\\n        }\\n    }\\n}\\n\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/EtherealStates/EtherealStatesDNA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\n/// @title EtherealStatesDNA\\n/// @author Artist: GenuineHumanArt (https://twitter.com/GenuineHumanArt)\\n/// @author Developer: dievardump (https://twitter.com/dievardump, dievardump@gmail.com)\\n/// @notice Generates DNA for EtherealStates NFTs\\n///         A big thank you to cxkoda (https://twitter.com/cxkoda) who helped me with the bit manipulation\\n///         & assembly and saved quite some gas.\\ncontract EtherealStatesDNA {\\n    error WrongDistributionForLayer(uint256 layer, uint256 acc);\\n\\n    function checkLayersValidity() public pure {\\n        unchecked {\\n            bytes memory layer;\\n            uint256 acc;\\n            uint256 i;\\n            for (uint256 j; j < 20; j++) {\\n                layer = getLayer(j);\\n                acc = 0;\\n                assembly {\\n                    for {\\n                        let current := add(layer, 0x20)\\n                        let length := mload(layer)\\n                    } lt(i, length) {\\n                        current := add(current, 2)\\n                        i := add(i, 2)\\n                    } {\\n                        acc := add(acc, sar(240, mload(current)))\\n                    }\\n                    i := 0\\n                }\\n\\n                if (acc != 10000) {\\n                    revert WrongDistributionForLayer(j, acc);\\n                }\\n            }\\n        }\\n    }\\n\\n    function generate(uint256 seed, bool includeHolderTraits)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        uint256 dna;\\n        uint256 random;\\n\\n        unchecked {\\n            for (uint256 i; i < 20; i++) {\\n                // keccak the seed, very simple prng\\n                // we do it on each call, because even if Holders layer is not shown we want to be sure\\n                // the layers after stay the same with or without it\\n                seed = uint256(keccak256(abi.encode(seed)));\\n\\n                // next random number\\n                random = seed % 10000;\\n\\n                // push 8 null bits on the right side\\n                dna <<= 8;\\n\\n                // done here and not in consumer, because getLayer(i) and pickOne are costly operations.\\n                // this way we save the gas when the trait is not included\\n                if (i != 12 || includeHolderTraits) {\\n                    // set the last 8 bits to the index of the asset in the layer\\n                    dna |= _pickOne(getLayer(i), random);\\n                }\\n            }\\n\\n            // add 96 null bits right\\n            dna <<= 96;\\n        }\\n        return bytes32(dna);\\n    }\\n\\n    function _pickOne(bytes memory layer, uint256 chance)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        unchecked {\\n            uint256 i;\\n            assembly {\\n                for {\\n                    let current := add(layer, 0x20)\\n                    let acc\\n                } 1 {\\n                    // add 2 bytes to current position\\n                    current := add(current, 2)\\n                    i := add(i, 2)\\n                } {\\n                    // add the value of the 2 first bytes of current in acc\\n                    acc := add(acc, sar(240, mload(current)))\\n                    // if chance < acc\\n                    if lt(chance, acc) {\\n                        break\\n                    }\\n                }\\n                i := sar(1, i)\\n            }\\n            return i;\\n        }\\n    }\\n\\n    // this is pretty dirty but this saves quite some gas\\n    // 1) putting the layers in storage would be very expensive when deploying & when reading storage\\n    // 2) using arrays of uint for that many assets (512), is too big for a contract\\n    // After tests, this seems to be a good working compromise\\n    function getLayer(uint256 which) public pure returns (bytes memory layer) {\\n        if (which == 0)\\n            layer = hex'01900190017c017c019001900006015e01900040017c00be0190000a0190015e017c017c0190015e001000680190017c0190017c00140020017c0087017c017c00df015e';\\n        else if (which == 1)\\n            layer = hex'012e0132007c00a0005e000a012c01e701e7000c000800b4006401e700a201e701e701e701e701bb01e701e7000e01e701b7000c01b701bb007c0130000e01e701e700a6';\\n        else if (which == 2)\\n            layer = hex'01b8019001b801b801a4011801cc01cc01cc0168001401cc01cc01b801cc01b801cc01b801b801b801b801cc01a401cc';\\n        else if (which == 3)\\n            layer = hex'004b003602080208020802080208004b00780208009102080110020802080208020801ae020801ae0208004f020802080208';\\n        else if (which == 4)\\n            layer = hex'007d004002080208020802080208004b020800a502080129020802080208020801c2020801c202080036020802080208';\\n        else if (which == 5)\\n            layer = hex'02260226021202120226021200d2012c022600aa02260096004002120212010400780212005602260212021202260226';\\n        else if (which == 6)\\n            layer = hex'01c201c200320064017201c201c20172001901c2017201720096017200960172003201c201c2017201c20064001901c2017201720064017201c201c2009601c2';\\n        else if (which == 7)\\n            layer = hex'00a01d4c005500780055009f00c700c7000700a000c700c7009f000500780055005500780005001e00c70078';\\n        else if (which == 8)\\n            layer = hex'01a901f401b301b301f401b301b301f401f4010e01f401f401b301f401b301f401a901f4005a01f40096001e01f401f4';\\n        else if (which == 9)\\n            layer = hex'020801b301b30208020801b300640208003c020800a001b301e501e501b30208015e020801b300c802080208015e0208';\\n        else if (which == 10)\\n            layer = hex'01e001fe019a019a01fe01e001fe01e0019a003201e001fe00960069004b01fe01fe01fe01fe01e001e001fe01fe019a';\\n        else if (which == 11)\\n            layer = hex'01f401f401f401f4012c01f40194019401e0001401e001f401f401e0000a019401e001e0019401f401f4019400fa01f4';\\n        else if (which == 12)\\n            layer = hex'0000032f032f032f032f032f032f01e00154032f01e00226032f032f032f';\\n        else if (which == 13)\\n            layer = hex'00780205020502050205008c01e002050205020501e0020500a000c001e001e00036020501e001e0020500fa02050205';\\n        else if (which == 14)\\n            layer = hex'020800be01e0020801e001fe01fe01e000fa003c01e0020800640208008c020801e00208020801e002080208020800a0';\\n        else if (which == 15)\\n            layer = hex'0194007801e0019401ea01ea01e00194000a019401ea01ea01ea01ea012c01e000fa01ea01ea01e001e001ea01ea0194';\\n        else if (which == 16)\\n            layer = hex'003201c2014301c201c2000a0143000f01c20143014301c200a000a00007005001c2003c00a001c2014301c201c201c201c201c201c201c2014301c201c200a0';\\n        else if (which == 17)\\n            layer = hex'00a00143005001a401a400f001a4006401a401a401a401a40143014301a4000a01a400f001a401a401a401a401a401a4014a01a400f000a0003c01430143002d';\\n        else if (which == 18)\\n            layer = hex'0143005001a401a401a4014301a40082002d01a4000a01a401a400f001a401a401a400a001a4004601a400a001a401430143014301a4017c00f001a4014a00f0';\\n        else if (which == 19)\\n            layer = hex'000a000a000a000a000a000a000a000a268e000a000a000a000a000a';\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/EtherealStates/EtherealStatesMeta.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\nimport {IERC721A, ERC721A} from 'erc721a/contracts/extensions/ERC721ABurnable.sol';\\n\\nimport {OwnableOperators} from '../utils/OwnableOperators.sol';\\n\\nimport {EtherealStatesMinter} from './EtherealStatesMinter.sol';\\nimport {EtherealStatesVRF} from './EtherealStatesVRF.sol';\\nimport {EtherealStatesDNA} from './EtherealStatesDNA.sol';\\n\\n/// @title EtherealStatesMeta\\n/// @author Artist: GenuineHumanArt (https://twitter.com/GenuineHumanArt)\\n/// @author Developer: dievardump (https://twitter.com/dievardump, dievardump@gmail.com)\\n/// @notice EtherealStates Meta logic\\ncontract EtherealStatesMeta is\\n    EtherealStatesMinter,\\n    EtherealStatesVRF,\\n    OwnableOperators\\n{\\n    error NotRevealed();\\n    error NonexistentToken();\\n    error WrongContext();\\n    error TooLate();\\n\\n    /// @notice emitted whenever the DNA changes.\\n    event TokenDNAChanged(\\n        address operator,\\n        uint256 indexed tokenId,\\n        bytes32 oldDNA,\\n        bytes32 newDNA\\n    );\\n\\n    /// @notice emitted whenever the random seed is set\\n    event RandomSeedSet(uint256 randomSeed);\\n\\n    /// @notice ChainLink Random Seed\\n    uint256 public randomSeed;\\n\\n    /// @notice DNA Generator contract\\n    address public dnaGenerator;\\n\\n    /// @notice Metadata manager\\n    address public metadataManager;\\n\\n    /// @notice this allows to save the DNA in the contract instead of having to generate\\n    ///         it every time we call tokenDNA()\\n    mapping(uint256 => bytes32) public revealedDNA;\\n\\n    string public contractURI;\\n\\n    /////////////////////////////////////////////////////////\\n    // Modifiers                                           //\\n    /////////////////////////////////////////////////////////\\n\\n    // stops minting after reveal\\n    modifier onlyBeforeReveal() {\\n        if (requestId != 0) {\\n            revert TooLate();\\n        }\\n        _;\\n    }\\n\\n    // allows some stuff only after reveal\\n    modifier onlyAfterReveal() {\\n        if (randomSeed == 0) {\\n            revert TooEarly();\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        string memory contractURI_,\\n        address mintPasses,\\n        address newSigner,\\n        address dnaGenerator_,\\n        address metadataManager_,\\n        VRFConfig memory vrfConfig_\\n    )\\n        EtherealStatesMinter(mintPasses, newSigner)\\n        EtherealStatesVRF(vrfConfig_)\\n    {\\n        contractURI = contractURI_;\\n        dnaGenerator = dnaGenerator_;\\n        metadataManager = metadataManager_;\\n    }\\n\\n    /////////////////////////////////////////////////////////\\n    // Getters                                             //\\n    /////////////////////////////////////////////////////////\\n\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        override(IERC721A, ERC721A)\\n        returns (string memory)\\n    {\\n        if (!_exists(tokenId)) {\\n            revert NonexistentToken();\\n        }\\n\\n        return EtherealStatesMinter(metadataManager).tokenURI(tokenId);\\n    }\\n\\n    function totalMinted() public view returns (uint256) {\\n        return _totalMinted();\\n    }\\n\\n    /// @notice Get the DNA for a givent tokenId\\n    /// @param tokenId the token id to get the DNA for\\n    /// @return dna the DNA\\n    function tokenDNA(uint256 tokenId)\\n        public\\n        view\\n        onlyAfterReveal\\n        returns (bytes32 dna)\\n    {\\n        if (!_exists(tokenId)) {\\n            revert NonexistentToken();\\n        }\\n\\n        dna = revealedDNA[tokenId];\\n\\n        if (dna == 0x0) {\\n            dna = _tokenDNA(tokenId);\\n        }\\n    }\\n\\n    function tokensDNA(uint256 startId, uint256 howMany)\\n        public\\n        view\\n        returns (bytes32[] memory dnas)\\n    {\\n        bytes32 dna;\\n        dnas = new bytes32[](howMany);\\n        for (uint256 i; i < howMany; i++) {\\n            dna = revealedDNA[startId + i];\\n            if (dna == 0x0) {\\n                dna = _tokenDNA(startId + i);\\n            }\\n            dnas[i] = dna;\\n        }\\n    }\\n\\n    /////////////////////////////////////////////////////////\\n    // Setters                                             //\\n    /////////////////////////////////////////////////////////\\n\\n    /// @notice Allows to save the DNA of a tokenId so it doesn't need to be recomputed\\n    ///         after that\\n    /// @param tokenId the token id to reveal\\n    /// @return dna the DNA\\n    function revealDNA(uint256 tokenId)\\n        external\\n        onlyAfterReveal\\n        returns (bytes32 dna)\\n    {\\n        if (!_exists(tokenId)) {\\n            revert NonexistentToken();\\n        }\\n\\n        dna = revealedDNA[tokenId];\\n\\n        // only reveal if not already revealed\\n        if (dna == 0x0) {\\n            dna = _tokenDNA(tokenId);\\n            revealedDNA[tokenId] = dna;\\n            emit TokenDNAChanged(msg.sender, tokenId, 0x0, dna);\\n        }\\n    }\\n\\n    /////////////////////////////////////////////////////////\\n    // Gated Operator                                      //\\n    /////////////////////////////////////////////////////////\\n\\n    /// @notice Allows an Operator to update a token DNA\\n    /// @param tokenId the token id to update the DNA of\\n    /// @param newDNA the new DNA\\n    function updateTokenDNA(uint256 tokenId, bytes32 newDNA)\\n        external\\n        onlyOperator\\n    {\\n        if (!_exists(tokenId)) {\\n            revert NonexistentToken();\\n        }\\n\\n        // the caller must be approved by the owner\\n        if (!isApprovedForAll(ownerOf(tokenId), msg.sender)) {\\n            revert ApprovalCallerNotOwnerNorApproved();\\n        }\\n\\n        bytes32 dna = revealedDNA[tokenId];\\n        if (dna == 0x0) {\\n            revert NotRevealed();\\n        }\\n\\n        revealedDNA[tokenId] = newDNA;\\n        emit TokenDNAChanged(msg.sender, tokenId, dna, newDNA);\\n    }\\n\\n    /////////////////////////////////////////////////////////\\n    // Gated Owner                                         //\\n    /////////////////////////////////////////////////////////\\n\\n    /// @notice Allows owner to update metadataManager\\n    /// @param newManager the new address of the metadata manager\\n    function setMetadataManager(address newManager) external onlyOwner {\\n        metadataManager = newManager;\\n    }\\n\\n    /// @notice Allows owner to update dna generator\\n    /// @param newGenerator the new address of the dna generator\\n    function setDNAGenerator(address newGenerator) external onlyOwner {\\n        dnaGenerator = newGenerator;\\n    }\\n\\n    /// @notice Allows to start the reveal process once everything is minted or time's up\\n    /// @dev this can only be used beforeReveal, so once the seed is set, this can't be called again\\n    ///      if the call, for any reason, fails,\\n    function startReveal() external onlyOwner {\\n        // only call if requestId is 0\\n        if (requestId != 0) {\\n            revert WrongContext();\\n        }\\n        currentTier = 0;\\n        _requestRandomWords();\\n    }\\n\\n    /// @notice Allows to reset the requestId, if, for some reason, the ChainLink call does not work\\n    /// @dev this can only be used beforeReveal, so once the seed is set, this can't be called again\\n    function resetRequestId() external onlyOwner {\\n        if (requestId == 0 || randomSeed != 0) {\\n            revert WrongContext();\\n        }\\n        requestId = 0;\\n    }\\n\\n    /// @notice Allows owner to update the VRFConfig if something is not right\\n    /// @dev this can only be used beforeReveal, so once the seed is set, this can't be called again\\n    function setVRFConfig(VRFConfig memory vrfConfig_)\\n        external\\n        onlyOwner\\n        onlyBeforeReveal\\n    {\\n        vrfConfig = vrfConfig_;\\n    }\\n\\n    /////////////////////////////////////////////////////////\\n    // Internals                                           //\\n    /////////////////////////////////////////////////////////\\n\\n    // called when ChainLink answers with the random number\\n    function fulfillRandomWords(\\n        uint256, /* requestId */\\n        uint256[] memory words\\n    ) internal override {\\n        randomSeed = words[0];\\n        emit RandomSeedSet(randomSeed);\\n    }\\n\\n    function _tokenDNA(uint256 tokenId) internal view returns (bytes32) {\\n        return\\n            EtherealStatesDNA(dnaGenerator).generate(\\n                uint256(keccak256(abi.encode(randomSeed, tokenId))),\\n                hasHoldersTrait(tokenId)\\n            );\\n    }\\n\\n    function _mintStates(\\n        address to,\\n        uint256 quantity,\\n        uint256 free,\\n        bool addHoldersTrait\\n    ) internal override onlyBeforeReveal {\\n        super._mintStates(to, quantity, free, addHoldersTrait);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/EtherealStates/EtherealStatesMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\nimport {SignedAllowance} from '@0xdievardump/signed-allowances/contracts/SignedAllowance.sol';\\n\\nimport {PrimeList} from '../libraries/PrimeList.sol';\\n\\nimport {EtherealStatesCore} from './EtherealStatesCore.sol';\\n\\n/// @title EtherealStatesMinter\\n/// @author Artist: GenuineHumanArt (https://twitter.com/GenuineHumanArt)\\n/// @author Developer: dievardump (https://twitter.com/dievardump, dievardump@gmail.com)\\n/// @notice EtherealStates Minter logic\\ncontract EtherealStatesMinter is EtherealStatesCore, SignedAllowance {\\n    error LengthMismatch();\\n    error TooManyRequested();\\n    error UnknownItem();\\n\\n    error WrongMintProcess();\\n    error TooEarly();\\n\\n    error WrongValue();\\n\\n    error OneMintCallPerBlockForContracts();\\n\\n    /// @notice Emitted so we can know which tokens have the HoldersTrait and quickly generate after reveal\\n    /// @param startTokenId the starting id\\n    /// @param quantity the amount of ids\\n    event TokensWithHoldersTrait(uint256 startTokenId, uint256 quantity);\\n\\n    uint256 public constant START_TOKEN_INDEX = 1;\\n\\n    uint256 public constant MAX_SUPPLY = 7000;\\n\\n    uint256 public constant MAX_PUBLIC = 6;\\n\\n    uint256 public constant MAX_PER_LIST = 2;\\n\\n    uint256 public constant MINT_BUNDLE = 5;\\n\\n    uint256 public constant MINT_PRICE = 0.08 ether;\\n\\n    address public immutable MINT_PASSES_HOLDER;\\n\\n    uint256 public currentTier;\\n\\n    uint256 public teamAllocation = 40;\\n\\n    uint256 private _extraDataMint;\\n\\n    /// @notice quantity minted for an address in the allow list + public mint\\n    mapping(address => uint256) public mintsCounter;\\n\\n    /// @notice last tx.origin mint block when using contracts\\n    mapping(address => uint256) private _contractLastBlockMinted;\\n\\n    /////////////////////////////////////////////////////////\\n    // Modifiers                                           //\\n    /////////////////////////////////////////////////////////\\n\\n    modifier onlyMinimumTier(uint256 tier) {\\n        if (currentTier < tier) {\\n            revert TooEarly();\\n        }\\n        _;\\n    }\\n\\n    // this modifier helps to protect against people using contracts to mint\\n    // a big amount of NFTs in one call\\n    // for people minting through contracts (custom or even Gnosis-Safe)\\n    // we impose a limit on tx.origin of one call per block\\n    // ensuring a loop can not be used, but still allowing contract minting.\\n    // This allows Gnosis & other contracts wallets users to still be able to mint\\n    // This is not the perfect solution, but it's a \\\"not perfect but I'll take it\\\" compromise\\n    modifier protectOrigin() {\\n        if (tx.origin != msg.sender) {\\n            if (block.number == _contractLastBlockMinted[tx.origin]) {\\n                revert OneMintCallPerBlockForContracts();\\n            }\\n            _contractLastBlockMinted[tx.origin] = block.number;\\n        }\\n        _;\\n    }\\n\\n    constructor(address mintPasses, address newSigner) {\\n        MINT_PASSES_HOLDER = mintPasses;\\n\\n        _setAllowancesSigner(newSigner);\\n    }\\n\\n    /////////////////////////////////////////////////////////\\n    // Getters                                             //\\n    /////////////////////////////////////////////////////////\\n\\n    function hasHoldersTrait(uint256 tokenId) public view returns (bool) {\\n        return _ownershipOf(tokenId).extraData == 1;\\n    }\\n\\n    /////////////////////////////////////////////////////////\\n    // Minting                                             //\\n    /////////////////////////////////////////////////////////\\n\\n    function mintPublic(uint256 quantity)\\n        external\\n        payable\\n        onlyMinimumTier(3)\\n        protectOrigin\\n    {\\n        uint256 alreadyMinted = mintsCounter[msg.sender];\\n        if (alreadyMinted + quantity > MAX_PUBLIC) {\\n            revert TooManyRequested();\\n        }\\n        mintsCounter[msg.sender] = alreadyMinted + quantity;\\n\\n        _mintStates(msg.sender, quantity, 0, false);\\n    }\\n\\n    function mintWithAllowlist(\\n        uint256 quantity,\\n        uint256 nonce,\\n        bytes memory signature\\n    ) external payable onlyMinimumTier(2) {\\n        // first validate signature\\n        validateSignature(msg.sender, nonce, signature);\\n\\n        // then make sure the account doesn't try to mint more than MAX_PER_LIST\\n        uint256 alreadyMinted = mintsCounter[msg.sender];\\n        if (alreadyMinted + quantity > MAX_PER_LIST) {\\n            revert TooManyRequested();\\n        }\\n\\n        // update minted\\n        mintsCounter[msg.sender] = alreadyMinted + quantity;\\n\\n        _mintStates(msg.sender, quantity, 0, false);\\n    }\\n\\n    function mintWithPasses(\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bool addHoldersTrait\\n    ) external payable onlyMinimumTier(1) {\\n        // calculate how many to mint and how many are free\\n        uint256 free;\\n        uint256 quantity;\\n        uint256 length = ids.length;\\n        for (uint256 i; i < length; i++) {\\n            if (ids[i] == 1) {\\n                free += amounts[i];\\n            }\\n            quantity += amounts[i];\\n        }\\n\\n        // we are not using safeMint so we can do that here.\\n        _mintStates(msg.sender, quantity, free, addHoldersTrait);\\n\\n        // burn all the passes; will revert if someone tries to do weird stuff with\\n        // ids & amounts\\n        IERC1155Burnable(MINT_PASSES_HOLDER).burnBatch(\\n            msg.sender,\\n            ids,\\n            amounts\\n        );\\n    }\\n\\n    /////////////////////////////////////////////////////////\\n    // Gated                                               //\\n    /////////////////////////////////////////////////////////\\n\\n    /// @notice Allows owner to set current tier for the mint\\n    /// @notice (0 = no mint, 1 = holders, 2 = holders & allowlist, 3 = hholders & allowlist & public)\\n    /// @param newTier the new value for the current tier\\n    function setTier(uint256 newTier) external onlyOwner {\\n        currentTier = newTier;\\n    }\\n\\n    /// @notice Allows owner to set the current signer for the allowlist\\n    /// @param newSigner the address of the new signer\\n    function setAllowancesSigner(address newSigner) external onlyOwner {\\n        _setAllowancesSigner(newSigner);\\n    }\\n\\n    function teamMint(\\n        address[] calldata accounts,\\n        uint256[] calldata quantities\\n    ) external onlyOwner {\\n        uint256 length = accounts.length;\\n\\n        if (accounts.length != quantities.length) {\\n            revert LengthMismatch();\\n        }\\n\\n        uint256 _teamAllocation = teamAllocation;\\n\\n        for (uint256 i; i < length; i++) {\\n            // will revert if too many requested\\n            _teamAllocation -= quantities[i];\\n\\n            _mintStates(accounts[i], quantities[i], quantities[i], false);\\n        }\\n\\n        teamAllocation = _teamAllocation;\\n    }\\n\\n    /// @dev for tests; might forget to remove, so it's lock on testnets ids\\n    function testMints(\\n        address to,\\n        uint256 quantity,\\n        bool addHoldersTrait\\n    ) external onlyOwner {\\n        require(block.chainid == 4 || block.chainid == 31337, 'OnlyTests()');\\n        _mintStates(to, quantity, quantity, addHoldersTrait);\\n    }\\n\\n    /////////////////////////////////////////////////////////\\n    // Internals                                           //\\n    /////////////////////////////////////////////////////////\\n\\n    // start at START_TOKEN_INDEX\\n    function _startTokenId() internal pure override returns (uint256) {\\n        return START_TOKEN_INDEX;\\n    }\\n\\n    function _mintStates(\\n        address to,\\n        uint256 quantity,\\n        uint256 free,\\n        bool addHoldersTrait\\n    ) internal virtual {\\n        // check that there is enough supply\\n        if (_totalMinted() + quantity > MAX_SUPPLY) {\\n            revert TooManyRequested();\\n        }\\n\\n        // check we have the right amount of ethereum with the tx\\n        if (msg.value != (quantity - free) * MINT_PRICE) {\\n            revert WrongValue();\\n        }\\n\\n        // there is supply, mint price is good, lfgo\\n        uint256 nextTokenId = _nextTokenId();\\n\\n        if (addHoldersTrait) {\\n            _extraDataMint = 1;\\n        }\\n\\n        // here we make bundles of MINT_BUNDLE in order to have a mint not too expensive, but also\\n        // not transfer too much the cost of minting to future Transfers, which is what ERC721A does.\\n        if (quantity > MINT_BUNDLE) {\\n            uint256 times = quantity / MINT_BUNDLE;\\n            for (uint256 i; i < times; i++) {\\n                _mint(to, MINT_BUNDLE);\\n            }\\n\\n            if (quantity % MINT_BUNDLE != 0) {\\n                _mint(to, quantity % MINT_BUNDLE);\\n            }\\n        } else {\\n            _mint(to, quantity);\\n        }\\n\\n        if (addHoldersTrait) {\\n            _extraDataMint = 0;\\n            emit TokensWithHoldersTrait(nextTokenId, quantity);\\n        }\\n    }\\n\\n    /// @dev Used to set the \\\"hasHoldersTrait\\\" flag on a token at minting time\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual override returns (uint24) {\\n        // if minting, return the _extraDataMint value\\n        if (from == address(0)) {\\n            return uint24(_extraDataMint);\\n        }\\n        // else return the current value\\n        return previousExtraData;\\n    }\\n}\\n\\ninterface IERC1155Burnable {\\n    function burnBatch(\\n        address account,\\n        uint256[] memory ids,\\n        uint256[] memory values\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/EtherealStates/EtherealStatesVRF.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\nimport {VRFCoordinatorV2Interface} from '@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol';\\nimport {VRFConsumerBaseV2} from '@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol';\\n\\n/// @title EtherealStatesVRF\\n/// @author Artist: GenuineHumanArt (https://twitter.com/GenuineHumanArt)\\n/// @author Developer: dievardump (https://twitter.com/dievardump, dievardump@gmail.com)\\n/// @notice EtherealStates VRF logic\\ncontract EtherealStatesVRF is VRFConsumerBaseV2 {\\n    struct VRFConfig {\\n        bytes32 keyHash;\\n        address coordinator;\\n        uint64 subscriptionId;\\n        uint32 callbackGasLimit;\\n        uint16 requestConfirmations;\\n        uint32 numWords;\\n    }\\n\\n    /// @notice ChainLink request id\\n    uint256 public requestId;\\n\\n    /// @notice ChainLink config\\n    VRFConfig public vrfConfig;\\n\\n    constructor(VRFConfig memory vrfConfig_)\\n        VRFConsumerBaseV2(vrfConfig_.coordinator)\\n    {\\n        vrfConfig = vrfConfig_;\\n    }\\n\\n    /// @dev basic call using the vrfConfig\\n    function _requestRandomWords() internal virtual {\\n        VRFConfig memory vrfConfig_ = vrfConfig;\\n        // Will revert if subscription is not set and funded.\\n        requestId = VRFCoordinatorV2Interface(vrfConfig_.coordinator)\\n            .requestRandomWords(\\n                vrfConfig_.keyHash,\\n                vrfConfig_.subscriptionId,\\n                vrfConfig_.requestConfirmations,\\n                vrfConfig_.callbackGasLimit,\\n                vrfConfig_.numWords\\n            );\\n    }\\n\\n    /// @dev needs to be overrode in the consumer contract\\n    function fulfillRandomWords(\\n        uint256, /* requestId */\\n        uint256[] memory\\n    ) internal virtual override {}\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/PrimeList.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary PrimeList {\\n    // gets one of 100 primes in the list.\\n    function getPrime(uint256 index) internal pure returns (uint256) {\\n        return\\n            [\\n                2057982841,\\n                3869875883,\\n                8288889667,\\n                5583593761,\\n                6533057819,\\n                9823362113,\\n                7668713989,\\n                4895050343,\\n                8419848407,\\n                7466022211,\\n                3659662393,\\n                9344063951,\\n                9484074533,\\n                9033570737,\\n                4149710647,\\n                3236460443,\\n                7023522617,\\n                7557150893,\\n                4120054093,\\n                7478304191,\\n                1667055199,\\n                7911602089,\\n                2013632897,\\n                6708874279,\\n                1636635757,\\n                5424215549,\\n                7454377537,\\n                9920454443,\\n                8959001237,\\n                1389441451,\\n                3840126163,\\n                3722149259,\\n                8699921891,\\n                7956864961,\\n                5755991279,\\n                9422009873,\\n                7121899249,\\n                1221867313,\\n                2571008851,\\n                4216079773,\\n                5180142449,\\n                5884142287,\\n                8424633037,\\n                2855803127,\\n                9930029801,\\n                1655760173,\\n                8221814719,\\n                1703940299,\\n                9490790363,\\n                1988399783,\\n                7757984219,\\n                6607369759,\\n                1128581473,\\n                1641979019,\\n                2039141267,\\n                5684186393,\\n                6436080187,\\n                2420852747,\\n                4700296903,\\n                3632109049,\\n                6052282381,\\n                2222123201,\\n                2976802139,\\n                6211642961,\\n                7643093261,\\n                5019701891,\\n                4009686067,\\n                6030261227,\\n                8322941219,\\n                3113781061,\\n                5390087597,\\n                3036730759,\\n                2455383097,\\n                3754516219,\\n                1838205091,\\n                1769815771,\\n                1233893939,\\n                2023283659,\\n                2591069053,\\n                8297378923,\\n                7924516513,\\n                9132407111,\\n                1300651171,\\n                7470231641,\\n                2907967981,\\n                7991100277,\\n                9377211707,\\n                2131963397,\\n                5310841027,\\n                4630539619,\\n                3048557969,\\n                6376558717,\\n                2518366199,\\n                5481503539,\\n                8618038133,\\n                7908297451,\\n                1043354203,\\n                6745996333,\\n                3880507187,\\n                5311321111\\n            ][index % 100];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Operators.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/// @title Operators\\n/// @author Simon Fremaux (@dievardump)\\ncontract Operators {\\n    error NotAuthorized();\\n    error InvalidAddress(address invalid);\\n\\n    mapping(address => bool) public operators;\\n\\n    modifier onlyOperator() virtual {\\n        if (!isOperator(msg.sender)) revert NotAuthorized();\\n        _;\\n    }\\n\\n    /// @notice tells if an account is an operator or not\\n    /// @param account the address to check\\n    function isOperator(address account) public view virtual returns (bool) {\\n        return operators[account];\\n    }\\n\\n    /// @dev set operator state to `isOperator` for ops[]\\n    function _editOperators(address[] memory ops, bool isOperatorRole)\\n        internal\\n    {\\n        for (uint256 i; i < ops.length; i++) {\\n            if (ops[i] == address(0)) revert InvalidAddress(ops[i]);\\n            operators[ops[i]] = isOperatorRole;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/OwnableOperators.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\n\\nimport './Operators.sol';\\n\\n/// @title OwnableOperators\\n/// @author Simon Fremaux (@dievardump)\\ncontract OwnableOperators is Ownable, Operators {\\n    ////////////////////////////////////////////\\n    // Only Owner                             //\\n    ////////////////////////////////////////////\\n\\n    /// @notice add new operators\\n    /// @param ops the list of operators to add\\n    function addOperators(address[] memory ops) external onlyOwner {\\n        _editOperators(ops, true);\\n    }\\n\\n    /// @notice add a new operator\\n    /// @param operator the operator to add\\n    function addOperator(address operator) external onlyOwner {\\n        address[] memory ops = new address[](1);\\n        ops[0] = operator;\\n        _editOperators(ops, true);\\n    }\\n\\n    /// @notice remove operators\\n    /// @param ops the list of operators to remove\\n    function removeOperators(address[] memory ops) external onlyOwner {\\n        _editOperators(ops, false);\\n    }\\n\\n    /// @notice remove an operator\\n    /// @param operator the operator to remove\\n    function removeOperator(address operator) external onlyOwner {\\n        address[] memory ops = new address[](1);\\n        ops[0] = operator;\\n        _editOperators(ops, false);\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.1.0\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721A.sol';\\n\\n/**\\n * @dev ERC721 token receiver interface.\\n */\\ninterface ERC721A__IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard,\\n * including the Metadata extension. Built to optimize for lower gas during batch mints.\\n *\\n * Assumes serials are sequentially minted starting at `_startTokenId()`\\n * (defaults to 0, e.g. 0, 1, 2, 3..).\\n *\\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n *\\n * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721A is IERC721A {\\n    // Mask of an entry in packed address data.\\n    uint256 private constant BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\n\\n    // The bit position of `numberMinted` in packed address data.\\n    uint256 private constant BITPOS_NUMBER_MINTED = 64;\\n\\n    // The bit position of `numberBurned` in packed address data.\\n    uint256 private constant BITPOS_NUMBER_BURNED = 128;\\n\\n    // The bit position of `aux` in packed address data.\\n    uint256 private constant BITPOS_AUX = 192;\\n\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\n    uint256 private constant BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\n\\n    // The bit position of `startTimestamp` in packed ownership.\\n    uint256 private constant BITPOS_START_TIMESTAMP = 160;\\n\\n    // The bit mask of the `burned` bit in packed ownership.\\n    uint256 private constant BITMASK_BURNED = 1 << 224;\\n\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant BITPOS_NEXT_INITIALIZED = 225;\\n\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant BITMASK_NEXT_INITIALIZED = 1 << 225;\\n\\n    // The bit position of `extraData` in packed ownership.\\n    uint256 private constant BITPOS_EXTRA_DATA = 232;\\n\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\n    uint256 private constant BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n    // The maximum `quantity` that can be minted with `_mintERC2309`.\\n    // This limit is to prevent overflows on the address data entries.\\n    // For a limit of 5000, a total of 3.689e15 calls to `_mintERC2309`\\n    // is required to cause an overflow, which is unrealistic.\\n    uint256 private constant MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\n\\n    // The tokenId of the next token to be minted.\\n    uint256 private _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 private _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned.\\n    // See `_packedOwnershipOf` implementation for details.\\n    //\\n    // Bits Layout:\\n    // - [0..159]   `addr`\\n    // - [160..223] `startTimestamp`\\n    // - [224]      `burned`\\n    // - [225]      `nextInitialized`\\n    // - [232..255] `extraData`\\n    mapping(uint256 => uint256) private _packedOwnerships;\\n\\n    // Mapping owner address to address data.\\n    //\\n    // Bits Layout:\\n    // - [0..63]    `balance`\\n    // - [64..127]  `numberMinted`\\n    // - [128..191] `numberBurned`\\n    // - [192..255] `aux`\\n    mapping(address => uint256) private _packedAddressData;\\n\\n    // Mapping from token ID to approved address.\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see `_totalMinted`.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than `_currentIndex - _startTokenId()` times.\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view returns (uint256) {\\n        // Counter underflow is impossible as _currentIndex does not decrement,\\n        // and it is initialized to `_startTokenId()`\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens burned.\\n     */\\n    function _totalBurned() internal view returns (uint256) {\\n        return _burnCounter;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes of the XOR of\\n        // all function selectors in the interface. See: https://eips.ethereum.org/EIPS/eip-165\\n        // e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return _packedAddressData[owner] & BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> BITPOS_NUMBER_MINTED) & BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> BITPOS_NUMBER_BURNED) & BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(_packedAddressData[owner] >> BITPOS_AUX);\\n    }\\n\\n    /**\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal {\\n        uint256 packed = _packedAddressData[owner];\\n        uint256 auxCasted;\\n        // Cast `aux` with assembly to avoid redundant masking.\\n        assembly {\\n            auxCasted := aux\\n        }\\n        packed = (packed & BITMASK_AUX_COMPLEMENT) | (auxCasted << BITPOS_AUX);\\n        _packedAddressData[owner] = packed;\\n    }\\n\\n    /**\\n     * Returns the packed ownership data of `tokenId`.\\n     */\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (_startTokenId() <= curr)\\n                if (curr < _currentIndex) {\\n                    uint256 packed = _packedOwnerships[curr];\\n                    // If not burned.\\n                    if (packed & BITMASK_BURNED == 0) {\\n                        // Invariant:\\n                        // There will always be an ownership that has an address and is not burned\\n                        // before an ownership that does not have an address and is not burned.\\n                        // Hence, curr will not underflow.\\n                        //\\n                        // We can directly compare the packed value.\\n                        // If the address is zero, packed is zero.\\n                        while (packed == 0) {\\n                            packed = _packedOwnerships[--curr];\\n                        }\\n                        return packed;\\n                    }\\n                }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * Returns the unpacked `TokenOwnership` struct from `packed`.\\n     */\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed >> BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed & BITMASK_BURNED != 0;\\n        ownership.extraData = uint24(packed >> BITPOS_EXTRA_DATA);\\n    }\\n\\n    /**\\n     * Returns the unpacked `TokenOwnership` struct at `index`.\\n     */\\n    function _ownershipAt(uint256 index) internal view returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnerships[index]);\\n    }\\n\\n    /**\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\n     */\\n    function _initializeOwnershipAt(uint256 index) internal {\\n        if (_packedOwnerships[index] == 0) {\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\n        }\\n    }\\n\\n    /**\\n     * Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\n    }\\n\\n    /**\\n     * @dev Packs ownership data into a single uint256.\\n     */\\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, BITMASK_ADDRESS)\\n            // `owner | (block.timestamp << BITPOS_START_TIMESTAMP) | flags`.\\n            result := or(owner, or(shl(BITPOS_START_TIMESTAMP, timestamp()), flags))\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, it can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    /**\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\n     */\\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\\n        // For branchless setting of the `nextInitialized` flag.\\n        assembly {\\n            // `(quantity == 1) << BITPOS_NEXT_INITIALIZED`.\\n            result := shl(BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public override {\\n        address owner = ownerOf(tokenId);\\n\\n        if (_msgSenderERC721A() != owner)\\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        if (operator == _msgSenderERC721A()) revert ApproveToCaller();\\n\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        transferFrom(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            }\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return\\n            _startTokenId() <= tokenId &&\\n            tokenId < _currentIndex && // If within bounds,\\n            _packedOwnerships[tokenId] & BITMASK_BURNED == 0; // and not burned.\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     *   {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * See {_mint}.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal {\\n        _mint(to, quantity);\\n\\n        unchecked {\\n            if (to.code.length != 0) {\\n                uint256 end = _currentIndex;\\n                uint256 index = end - quantity;\\n                do {\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    }\\n                } while (index < end);\\n                // Reentrancy protection.\\n                if (_currentIndex != end) revert();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _mint(address to, uint256 quantity) internal {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\n        // `tokenId` has a maximum limit of 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            uint256 tokenId = startTokenId;\\n            uint256 end = startTokenId + quantity;\\n            do {\\n                emit Transfer(address(0), to, tokenId++);\\n            } while (tokenId < end);\\n\\n            _currentIndex = end;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * This function is intended for efficient minting only during contract creation.\\n     *\\n     * It emits only one {ConsecutiveTransfer} as defined in\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\n     * instead of a sequence of {Transfer} event(s).\\n     *\\n     * Calling this function outside of contract creation WILL make your contract\\n     * non-compliant with the ERC721 standard.\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {ConsecutiveTransfer} event.\\n     */\\n    function _mintERC2309(address to, uint256 quantity) internal {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n        if (quantity > MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\n\\n            _currentIndex = startTokenId + quantity;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\n     */\\n    function _getApprovedAddress(uint256 tokenId)\\n        private\\n        view\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\n    {\\n        mapping(uint256 => address) storage tokenApprovalsPtr = _tokenApprovals;\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId]`.\\n        assembly {\\n            // Compute the slot.\\n            mstore(0x00, tokenId)\\n            mstore(0x20, tokenApprovalsPtr.slot)\\n            approvedAddressSlot := keccak256(0x00, 0x40)\\n            // Load the slot's value from storage.\\n            approvedAddress := sload(approvedAddressSlot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether the `approvedAddress` is equals to `from` or `msgSender`.\\n     */\\n    function _isOwnerOrApproved(\\n        address approvedAddress,\\n        address from,\\n        address msgSender\\n    ) private pure returns (bool result) {\\n        assembly {\\n            // Mask `from` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            from := and(from, BITMASK_ADDRESS)\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            msgSender := and(msgSender, BITMASK_ADDRESS)\\n            // `msgSender == from || msgSender == approvedAddress`.\\n            result := or(eq(msgSender, from), eq(msgSender, approvedAddress))\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedAddress(tokenId);\\n\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\n        if (!_isOwnerOrApproved(approvedAddress, from, _msgSenderERC721A()))\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\n\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                to,\\n                BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        address from = address(uint160(prevOwnershipPacked));\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedAddress(tokenId);\\n\\n        if (approvalCheck) {\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\n            if (!_isOwnerOrApproved(approvedAddress, from, _msgSenderERC721A()))\\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance -= 1`.\\n            // - `numberBurned += 1`.\\n            //\\n            // We can directly decrement the balance, and increment the number burned.\\n            // This is equivalent to `packed -= 1; packed += 1 << BITPOS_NUMBER_BURNED;`.\\n            _packedAddressData[from] += (1 << BITPOS_NUMBER_BURNED) - 1;\\n\\n            // Updates:\\n            // - `address` to the last owner.\\n            // - `startTimestamp` to the timestamp of burning.\\n            // - `burned` to `true`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                from,\\n                (BITMASK_BURNED | BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Directly sets the extra data for the ownership data `index`.\\n     */\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal {\\n        uint256 packed = _packedOwnerships[index];\\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\\n        uint256 extraDataCasted;\\n        // Cast `extraData` with assembly to avoid redundant masking.\\n        assembly {\\n            extraDataCasted := extraData\\n        }\\n        packed = (packed & BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << BITPOS_EXTRA_DATA);\\n        _packedOwnerships[index] = packed;\\n    }\\n\\n    /**\\n     * @dev Returns the next extra data for the packed ownership data.\\n     * The returned result is shifted into position.\\n     */\\n    function _nextExtraData(\\n        address from,\\n        address to,\\n        uint256 prevOwnershipPacked\\n    ) private view returns (uint256) {\\n        uint24 extraData = uint24(prevOwnershipPacked >> BITPOS_EXTRA_DATA);\\n        return uint256(_extraData(from, to, extraData)) << BITPOS_EXTRA_DATA;\\n    }\\n\\n    /**\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\n     * Intended to be overridden by the cosumer contract.\\n     *\\n     * `previousExtraData` - the value of `extraData` before transfer.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual returns (uint24) {}\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred.\\n     * This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred.\\n     * This includes minting.\\n     * And also called after one token has been burned.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure returns (string memory ptr) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit),\\n            // but we allocate 128 bytes to keep the free memory pointer 32-byte word aliged.\\n            // We will need 1 32-byte word to store the length,\\n            // and 3 32-byte words to store a maximum of 78 digits. Total: 32 + 3 * 32 = 128.\\n            ptr := add(mload(0x40), 128)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, ptr)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := ptr\\n\\n            // We write the string from the rightmost digit to the leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // Costs a bit more than early returning for the zero case,\\n            // but cheaper in terms of deployment and overall runtime costs.\\n            for {\\n                // Initialize and perform the first pass without check.\\n                let temp := value\\n                // Move the pointer 1 byte leftwards to point to an empty character slot.\\n                ptr := sub(ptr, 1)\\n                // Write the character to the pointer. 48 is the ASCII index of '0'.\\n                mstore8(ptr, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n            } temp {\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n            } {\\n                // Body of the for loop.\\n                ptr := sub(ptr, 1)\\n                mstore8(ptr, add(48, mod(temp, 10)))\\n            }\\n\\n            let length := sub(end, ptr)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            ptr := sub(ptr, 32)\\n            // Store the length.\\n            mstore(ptr, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.1.0\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of an ERC721A compliant contract.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * The caller cannot approve to their own address.\\n     */\\n    error ApproveToCaller();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set through `_extraData`.\\n        uint24 extraData;\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     *\\n     * Burned tokens are calculated here, use `_totalMinted()` if you want to count just minted tokens.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // ==============================\\n    //            IERC165\\n    // ==============================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // ==============================\\n    //            IERC721\\n    // ==============================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // ==============================\\n    //        IERC721Metadata\\n    // ==============================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // ==============================\\n    //            IERC2309\\n    // ==============================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId` (inclusive) is transferred from `from` to `to`,\\n     * as defined in the ERC2309 standard. See `_mintERC2309` for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/ERC721ABurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.1.0\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721ABurnable.sol';\\nimport '../ERC721A.sol';\\n\\n/**\\n * @title ERC721A Burnable Token\\n * @dev ERC721A Token that can be irreversibly burned (destroyed).\\n */\\nabstract contract ERC721ABurnable is ERC721A, IERC721ABurnable {\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721A-_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 tokenId) public virtual override {\\n        _burn(tokenId, true);\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/IERC721ABurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.1.0\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\\n/**\\n * @dev Interface of an ERC721ABurnable compliant contract.\\n */\\ninterface IERC721ABurnable is IERC721A {\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721A-_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 tokenId) external;\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractURI_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"mintPasses\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newSigner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dnaGenerator_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"metadataManager_\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"coordinator\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"requestConfirmations\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"}],\"internalType\":\"struct EtherealStatesVRF.VRFConfig\",\"name\":\"vrfConfig_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveToCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"invalid\",\"type\":\"address\"}],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintERC2309QuantityExceedsLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotRevealed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OneMintCallPerBlockForContracts\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnershipNotInitializedForExtraData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooEarly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooLate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyRequested\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnknownItem\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongContext\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongMintProcess\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongValue\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomSeed\",\"type\":\"uint256\"}],\"name\":\"RandomSeedSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"oldDNA\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newDNA\",\"type\":\"bytes32\"}],\"name\":\"TokenDNAChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"TokensWithHoldersTrait\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_PER_LIST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PUBLIC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_BUNDLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_PASSES_HOLDER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"START_TOKEN_INDEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"ops\",\"type\":\"address[]\"}],\"name\":\"addOperators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowancesSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"createMessage\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nonces\",\"type\":\"uint256[]\"}],\"name\":\"createMessages\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"messages\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dnaGenerator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"hasHoldersTrait\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadataManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"mintPublic\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"mintWithAllowlist\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"addHoldersTrait\",\"type\":\"bool\"}],\"name\":\"mintWithPasses\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintsCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomSeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"ops\",\"type\":\"address[]\"}],\"name\":\"removeOperators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetRequestId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"revealDNA\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"revealedDNA\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"setAllowancesSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGenerator\",\"type\":\"address\"}],\"name\":\"setDNAGenerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"setMetadataManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTier\",\"type\":\"uint256\"}],\"name\":\"setTier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"coordinator\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"requestConfirmations\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"}],\"internalType\":\"struct EtherealStatesVRF.VRFConfig\",\"name\":\"vrfConfig_\",\"type\":\"tuple\"}],\"name\":\"setVRFConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startReveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"quantities\",\"type\":\"uint256[]\"}],\"name\":\"teamMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"addHoldersTrait\",\"type\":\"bool\"}],\"name\":\"testMints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenDNA\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"dna\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"howMany\",\"type\":\"uint256\"}],\"name\":\"tokensDNA\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"dnas\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"newDNA\",\"type\":\"bytes32\"}],\"name\":\"updateTokenDNA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"usedAllowances\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"validateSignature\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vrfConfig\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"coordinator\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"requestConfirmations\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EtherealStates", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000001600000000000000000000000007c7cabe37aa78bb3e1640633941cf23e0869a853000000000000000000000000f6d5c938644455005a00f5fb96a8863bc70afed5000000000000000000000000b9ad592b621fda46f424d010104ea5567e20874a0000000000000000000000000dd4dbad70451dc504e1c4c023a2cad3188b25328af398995b04c28e9951adb9721ef74c74f93e6a478f39e7e0777be13527e7ef000000000000000000000000271682deb8c4e0901d1a1550ad2e64d568e6990900000000000000000000000000000000000000000000000000000000000000bc00000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000035697066733a2f2f516d503155466b6b72485838527952337754435761574d767a3455555065533169336a434250786947664e41397a0000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}