{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.8.7;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address) external returns (uint256);\r\n    function transfer(address, uint256) external;\r\n}\r\n\r\ninterface IFraxGaugeUniV3 {\r\n    struct LockedNFT {\r\n        uint256 token_id; // for Uniswap V3 LPs\r\n        uint256 liquidity;\r\n        uint256 start_timestamp;\r\n        uint256 ending_timestamp;\r\n        uint256 lock_multiplier; // 6 decimals of precision. 1x = 1000000\r\n        int24 tick_lower;\r\n        int24 tick_upper;\r\n    }\r\n\r\n    function lockedNFTsOf(address account) external view returns (LockedNFT[] memory);\r\n}\r\n\r\ninterface IStrategyProxy {\r\n    function withdrawAllV3(\r\n        address _gauge,\r\n        address[] calldata _rewardTokens\r\n    ) external returns (uint256 amount);\r\n}\r\n\r\ninterface IUniswapV3PositionsNFT {\r\n    struct CollectParams {\r\n        uint256 tokenId;\r\n        address recipient;\r\n        uint128 amount0Max;\r\n        uint128 amount1Max;\r\n    }\r\n\r\n    struct DecreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint128 liquidity;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\r\n        external\r\n        payable\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\r\n}\r\n\r\ncontract BailLarryAssOut {\r\n\r\n    function getNfts() internal returns (IFraxGaugeUniV3.LockedNFT[] memory) {\r\n\r\n        address gauge = 0x3EF26504dbc8Dd7B7aa3E97Bc9f3813a9FC0B4B0;\r\n        address locker = 0xd639C2eA4eEFfAD39b599410d00252E6c80008DF;\r\n        IFraxGaugeUniV3.LockedNFT[] memory nfts = IFraxGaugeUniV3(gauge).lockedNFTsOf(locker);\r\n\r\n        uint256 count = 0;\r\n        for(uint256 i = 0; i < nfts.length; i++) {\r\n            if(nfts[i].liquidity > 0) count++;\r\n        }\r\n\r\n        uint256 j = 0;\r\n        IFraxGaugeUniV3.LockedNFT[] memory nftsRet = new IFraxGaugeUniV3.LockedNFT[](count);\r\n        for(uint256 i = 0; i < nfts.length; i++) {\r\n            if(nfts[i].liquidity > 0) {\r\n                nftsRet[j] = nfts[i];\r\n                j++;\r\n            }\r\n        }\r\n        return nftsRet;\r\n\r\n    }\r\n\r\n    function bail() external {\r\n        address recipient = 0x324E0b53CefA84CF970833939249880f814557c6;\r\n        address strategy = 0x0329867a8c457e9F75e25b0685011291CD30904F;\r\n        address gauge = 0x3EF26504dbc8Dd7B7aa3E97Bc9f3813a9FC0B4B0;\r\n\r\n        address usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n        address frax = 0x853d955aCEf822Db058eb8505911ED77F175b99e;\r\n        address fxs = 0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0;\r\n        address strategyProxy = 0x7a10B3C48216A54D1a1a1d268D24F69A77Ac94AD;\r\n\r\n        // First, we get all the Uni V3 NFTs into the strategy\r\n        address[] memory rewardTokens = new address[](3);\r\n        rewardTokens[0] = fxs;\r\n        rewardTokens[1] = usdc;\r\n        rewardTokens[2] = frax;\r\n\r\n        IFraxGaugeUniV3.LockedNFT[] memory nfts = getNfts();\r\n\r\n        IStrategyProxy(strategyProxy).withdrawAllV3(gauge, rewardTokens);\r\n\r\n        // Next, we unwind liquidity\r\n        IUniswapV3PositionsNFT nftManager = IUniswapV3PositionsNFT(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\r\n\r\n        for(uint256 i = 0; i < nfts.length; i++) {\r\n            nftManager.decreaseLiquidity(\r\n                    IUniswapV3PositionsNFT.DecreaseLiquidityParams({\r\n                        tokenId: nfts[i].token_id,\r\n                        liquidity: uint128(nfts[i].liquidity),\r\n                        amount0Min: 0,\r\n                        amount1Min: 0,\r\n                        deadline: block.timestamp + 300\r\n                    })\r\n                );\r\n\r\n            nftManager.collect(\r\n                IUniswapV3PositionsNFT.CollectParams({\r\n                    tokenId: nfts[i].token_id,\r\n                    recipient: address(this),\r\n                    amount0Max: type(uint128).max,\r\n                    amount1Max: type(uint128).max\r\n                })\r\n            );\r\n        }\r\n        IERC20(fxs).transfer(recipient, IERC20(fxs).balanceOf(address(this)));\r\n        IERC20(usdc).transfer(recipient, IERC20(usdc).balanceOf(address(this)));\r\n        IERC20(frax).transfer(recipient, IERC20(frax).balanceOf(address(this)));\r\n    }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"bail\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BailLarryAssOut", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://df661efa9b867b071db0b99eae548ab362b8b90caeb200a598d72e07698468bc"}]}