{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/allocators/CVXAllocatorV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\nimport \\\"../types/BaseAllocator.sol\\\";\\n\\nimport \\\"./interfaces/ILockedCvx.sol\\\";\\nimport \\\"./interfaces/ICrvDepositor.sol\\\";\\nimport \\\"./interfaces/IRewardStaking.sol\\\";\\nimport \\\"./interfaces/ConvexInterfaces.sol\\\";\\n\\nstruct OperationData {\\n    ILockedCvx cvxLocker;\\n    uint88 spendRatio;\\n    bool relock;\\n    ICrvDepositor crvDeposit;\\n    IRewardStaking ccStaking; // cvxcrv\\n}\\n\\ncontract CVXAllocatorV2 is BaseAllocator {\\n    OperationData public opData;\\n\\n    constructor(OperationData memory opDataArg, AllocatorInitData memory aData) BaseAllocator(aData) {\\n        opData = opDataArg;\\n        aData.tokens[0].approve(address(opDataArg.cvxLocker), type(uint256).max);\\n        aData.tokens[1].approve(address(opDataArg.crvDeposit), type(uint256).max);\\n        aData.tokens[2].approve(address(opDataArg.ccStaking), type(uint256).max);\\n    }\\n\\n    function _update(uint256 id) internal override returns (uint128 gain, uint128 loss) {\\n        // reads\\n        uint256 index = tokenIds[id];\\n\\n        IERC20 cvx = _tokens[0];\\n        IERC20 crv = _tokens[1];\\n        IERC20 cc = _tokens[2];\\n\\n        OperationData memory operation = opData;\\n        ILockedCvx locker = operation.cvxLocker;\\n        IRewardStaking ccStaking = operation.ccStaking;\\n\\n        // interactions\\n        if (_unlockable() > 0) locker.processExpiredLocks(operation.relock);\\n        if (_checkClaimableRewards(locker)) locker.getReward(address(this), true);\\n        if (ccStaking.earned(address(this)) > 0) ccStaking.getReward(address(this), true);\\n\\n        uint256 bal = cvx.balanceOf(address(this));\\n\\n        if (bal > 0) {\\n            locker.lock(address(this), bal, operation.spendRatio);\\n        }\\n\\n        bal = crv.balanceOf(address(this));\\n\\n        if (bal > 0) {\\n            operation.crvDeposit.deposit(bal, true);\\n        }\\n\\n        bal = cc.balanceOf(address(this));\\n\\n        if (bal > 0) {\\n            ccStaking.stake(bal);\\n        }\\n\\n        uint256 former = extender.getAllocatorAllocated(id) + extender.getAllocatorPerformance(id).gain;\\n        uint256 current = _amountAllocated(operation, index);\\n\\n        if (current >= former) gain = uint128(current - former);\\n        else loss = uint128(former - current);\\n    }\\n\\n    function deallocate(uint256[] memory amounts) public override onlyGuardian {\\n        uint256 length = amounts.length;\\n        OperationData memory operation = opData;\\n\\n        if (amounts[0] > 0)\\n            operation.cvxLocker.processExpiredLocks(false); // can only do full\\n        else if (amounts[2] > 0)\\n            operation.ccStaking.withdrawAndUnwrap( // need to check what it goes into\\n                amounts[2] == type(uint256).max ? operation.ccStaking.balanceOf(address(this)) : amounts[2],\\n                true\\n            );\\n    }\\n\\n    function _deactivate(bool panic) internal override {\\n        if (panic) {\\n            uint256[] memory amounts = new uint256[](3);\\n            OperationData memory operation = opData;\\n            ILockedCvx cvxLocker = operation.cvxLocker;\\n            IRewardStaking ccStaking = operation.ccStaking;\\n\\n            if (_unlockable() > 0) amounts[0] = 1;\\n            if (ccStaking.balanceOf(address(this)) > 0) amounts[2] = type(uint256).max;\\n\\n            deallocate(amounts);\\n        }\\n    }\\n\\n    function _prepareMigration() internal override {\\n        uint256[] memory amounts = new uint256[](3);\\n        amounts[0] = 1;\\n        amounts[2] = type(uint256).max;\\n        deallocate(amounts);\\n    }\\n\\n    function rewardTokens() public view override returns (IERC20[] memory) {\\n        IERC20[] memory tokens = new IERC20[](2);\\n        tokens[0] = _tokens[1];\\n        tokens[1] = _tokens[2];\\n        return tokens;\\n    }\\n\\n    function utilityTokens() public view override returns (IERC20[] memory) {\\n        IERC20[] memory tokens = new IERC20[](2);\\n        tokens[0] = _tokens[1];\\n        tokens[1] = _tokens[2];\\n        return tokens;\\n    }\\n\\n    function name() external pure override returns (string memory) {\\n        return \\\"CVXAllocatorV2\\\";\\n    }\\n\\n    function setOperationData(OperationData calldata newData) external onlyGuardian {\\n        opData = newData;\\n    }\\n\\n    function setDelegate(address delegationContract, address delegate) external onlyGuardian {\\n        IDelegation(delegationContract).setDelegate(\\\"cvx.eth\\\", delegate);\\n    }\\n\\n    function setSpendRatio(uint88 ratio) external onlyGuardian {\\n        opData.spendRatio = ratio;\\n    }\\n\\n    function setRelock(bool relock) external onlyGuardian {\\n        opData.relock = relock;\\n    }\\n\\n    /// @notice Returns amounts allocated. NOTE: returns 0 for crv because it's being swapped into cvxcrv.\\n    /// Thus, crv loss limit should be type(uint256).max;\\n    function amountAllocated(uint256 id) public view override returns (uint256) {\\n        uint256 index = tokenIds[id];\\n        OperationData memory operation = opData;\\n        return _amountAllocated(operation, index);\\n    }\\n\\n    function _checkClaimableRewards(ILockedCvx locker) internal returns (bool) {\\n        ILockedCvx.EarnedData[] memory rewards = locker.claimableRewards(address(this));\\n        for (uint256 i; i < rewards.length; i++) {\\n            if (rewards[i].amount > 0) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function _amountAllocated(OperationData memory operation, uint256 index) internal view returns (uint256) {\\n        if (index == 2) return operation.ccStaking.balanceOf(address(this));\\n        else if (index == 1) return 0;\\n        return operation.cvxLocker.lockedBalanceOf(address(this));\\n    }\\n\\n    function _unlockable() internal view returns (uint256) {\\n        (, uint256 unlockable, , ) = opData.cvxLocker.lockedBalances(address(this));\\n        return unlockable;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/types/BaseAllocator.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\n// interfaces\\nimport \\\"../interfaces/IAllocator.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\n\\n// types\\nimport \\\"../types/OlympusAccessControlledV2.sol\\\";\\n\\n// libraries\\nimport \\\"../libraries/SafeERC20.sol\\\";\\n\\nerror BaseAllocator_AllocatorNotActivated();\\nerror BaseAllocator_AllocatorNotOffline();\\nerror BaseAllocator_Migrating();\\nerror BaseAllocator_NotMigrating();\\nerror BaseAllocator_OnlyExtender(address sender);\\n\\n/**\\n * @title BaseAllocator\\n * @notice\\n *  This abstract contract serves as a template for writing new Olympus Allocators.\\n *  Many of the functionalities regarding handling of Treasury funds by the Guardian have\\n *  been delegated to the `TreasuryExtender` contract, and thus an explanation for them can be found\\n *  in `TreasuryExtender.sol`.\\n *\\n *  The main purpose of this abstract contract and the `IAllocator` interface is to provide\\n *  a unified framework for how an Allocator should behave. Below an explanation of how\\n *  we expect an Allocator to behave in general, mentioning the most important points.\\n *\\n *  Activation:\\n *   - An Allocator is first deployed with all necessary arguments.\\n *     Thereafter, each deposit is registered with the `TreasuryExtender`.\\n *     This assigns a unique id for each deposit (set of allocations) in an Allocator.\\n *   - Next, the Allocators allocation and loss limits are set via the extender function.\\n *   - Finally, the Allocator is activated by calling `activate`.\\n *\\n *  Runtime:\\n *   The Allocator is in communication with the Extender, it must inform the Extender\\n *   what the status of the tokens is which were allocated. We only care about noting down\\n *   their status in the Extender. A quick summary of the important functions on this topic:\\n *\\n *   - `update(uint256 id)` is the main function that deals with state reporting, where\\n *     `_update(uint256 id)` is the internal function to implement, which should update Allocator\\n *     internal state. `update(uint256 id)` then continues to report the Allocators state via `report`\\n *     to the extender. `_update(uint256 id)` should handle _investment_ of funds present in Contract.\\n *\\n *   - `deallocate` should handle allocated token withdrawal, preparing the tokens to be withdrawn\\n *     by the Extender. It is not necessary to handle approvals for this token, because it is automatically\\n *     approved in the constructor. For other token withdrawals, it is assumed that reward tokens will\\n *     either be sold into underlying (allocated) or that they will simply rest in the Contract, being reward tokens.\\n *     Please also check function documentation.\\n *\\n *   - `rewardTokens` and `utilityTokens` should return the above mentioned simple reward tokens for the former case,\\n *     while utility tokens should be those tokens which are continously reinvested or otherwise used by the contract\\n *     in order to accrue more rewards. A reward token can also be a utility token, but then one must prepare them\\n *     separately for withdrawal if they are to be returned to the treasury.\\n *\\n *  Migration & Deactivation:\\n *   - `prepareMigration()` together with the virtual `_prepareMigration()` sets the state of the Allocator into\\n *     MIGRATING, disabling further token deposits, enabling only withdrawals, and preparing all funds for withdrawal.\\n *\\n *   - `migrate` then executes the migration and also deactivates the Allocator.\\n *\\n *   - `deactivate` sets `status` to OFFLINE, meaning it simply deactivates the Allocator. It can be passed\\n *     a panic boolean, meaning it handles deactivation logic in `deactivate`. The Allocator panic deactivates if\\n *     this state if the loss limit is reached via `update`. The Allocator can otherwise also simply be deactivated\\n *     and funds transferred back to the Treasury.\\n *\\n *  This was a short summary of the Allocator lifecycle.\\n */\\nabstract contract BaseAllocator is OlympusAccessControlledV2, IAllocator {\\n    using SafeERC20 for IERC20;\\n\\n    // Indices which represent the ids of the deposits in the `TreasuryExtender`\\n    uint256[] internal _ids;\\n\\n    // The allocated (underlying) tokens of the Allocator\\n    IERC20[] internal _tokens;\\n\\n    // From deposit id to the token's id\\n    mapping(uint256 => uint256) public tokenIds;\\n\\n    // Allocator status: OFFLINE, ACTIVATED, MIGRATING\\n    AllocatorStatus public status;\\n\\n    // The extender with which the Allocator communicates.\\n    ITreasuryExtender public immutable extender;\\n\\n    constructor(AllocatorInitData memory data) OlympusAccessControlledV2(data.authority) {\\n        _tokens = data.tokens;\\n        extender = data.extender;\\n\\n        for (uint256 i; i < data.tokens.length; i++) {\\n            data.tokens[i].approve(address(data.extender), type(uint256).max);\\n        }\\n\\n        emit AllocatorDeployed(address(data.authority), address(data.extender));\\n    }\\n\\n    /////// MODIFIERS\\n\\n    modifier onlyExtender {\\n\\t_onlyExtender(msg.sender);\\n\\t_;\\n    }\\n\\n    modifier onlyActivated {\\n\\t_onlyActivated(status);\\n\\t_;\\n    }\\n\\n    modifier onlyOffline {\\n\\t_onlyOffline(status);\\n\\t_;\\n    }\\n\\n    modifier notMigrating {\\n\\t_notMigrating(status);\\n\\t_;\\n    }\\n\\n    modifier isMigrating {\\n\\t_isMigrating(status);\\n\\t_;\\n    }\\n\\n    /////// VIRTUAL FUNCTIONS WHICH NEED TO BE IMPLEMENTED\\n    /////// SORTED BY EXPECTED COMPLEXITY AND DEPENDENCY\\n\\n    /**\\n     * @notice\\n     *  Updates an Allocators state.\\n     * @dev\\n     *  This function should be implemented by the developer of the Allocator.\\n     *  This function should fulfill the following purposes:\\n     *   - invest token specified by deposit id\\n     *   - handle rebalancing / harvesting for token as needed\\n     *   - calculate gain / loss for token and return those values\\n     *   - handle any other necessary runtime calculations, such as fees etc.\\n     *\\n     *  In essence, this function should update the main runtime state of the Allocator\\n     *  so that everything is properly invested, harvested, accounted for.\\n     * @param id the id of the deposit in the `TreasuryExtender`\\n     */\\n    function _update(uint256 id) internal virtual returns (uint128 gain, uint128 loss);\\n\\n    /**\\n     * @notice\\n     *  Deallocates tokens, prepares tokens for return to the Treasury.\\n     * @dev\\n     *  This function should deallocate (withdraw) `amounts` of each token so that they may be withdrawn\\n     *  by the TreasuryExtender. Otherwise, this function may also prepare the withdraw if it is time-bound.\\n     * @param amounts is the amount of each of token from `_tokens` to withdraw\\n     */\\n    function deallocate(uint256[] memory amounts) public virtual;\\n\\n    /**\\n     * @notice\\n     *  Handles deactivation logic for the Allocator.\\n     */\\n    function _deactivate(bool panic) internal virtual;\\n\\n    /**\\n     * @notice\\n     *  Handles migration preparatory logic.\\n     * @dev\\n     *  Within this function, the developer should arrange the withdrawal of all assets for migration.\\n     *  A useful function, say, to be passed into this could be `deallocate` with all of the amounts,\\n     *  so with n places for n-1 utility tokens + 1 allocated token, maxed out.\\n     */\\n    function _prepareMigration() internal virtual;\\n\\n    /**\\n     * @notice\\n     *  Should estimate total amount of Allocated tokens\\n     * @dev\\n     *  The difference between this and `treasury.getAllocatorAllocated`, is that the latter is a static\\n     *  value recorded during reporting, but no data is available on _new_ amounts after reporting.\\n     *  Thus, this should take into consideration the new amounts. This can be used for say aTokens.\\n     * @param id the id of the deposit in `TreasuryExtender`\\n     */\\n    function amountAllocated(uint256 id) public view virtual returns (uint256);\\n\\n    /**\\n     * @notice\\n     *  Should return all reward token addresses\\n     */\\n    function rewardTokens() public view virtual returns (IERC20[] memory);\\n\\n    /**\\n     * @notice\\n     *  Should return all utility token addresses\\n     */\\n    function utilityTokens() public view virtual returns (IERC20[] memory);\\n\\n    /**\\n     * @notice\\n     *  Should return the Allocator name\\n     */\\n    function name() external view virtual returns (string memory);\\n\\n    /////// IMPLEMENTATION OPTIONAL\\n\\n    /**\\n     * @notice\\n     *  Should handle activation logic\\n     * @dev\\n     *  If there is a need to handle any logic during activation, this is the function you should implement it into\\n     */\\n    function _activate() internal virtual {}\\n\\n    /////// FUNCTIONS\\n\\n    /**\\n     * @notice\\n     *  Updates an Allocators state and reports to `TreasuryExtender` if necessary.\\n     * @dev\\n     *  Can only be called by the Guardian.\\n     *  Can only be called while the Allocator is activated.\\n     *\\n     *  This function should update the Allocators internal state via `_update`, which should in turn\\n     *  return the `gain` and `loss` the Allocator has sustained in underlying allocated `token` from `_tokens`\\n     *  decided by the `id`.\\n     *  Please check the docs on `_update` to see what its function should be.\\n     *\\n     *  `_lossLimitViolated` checks if the Allocators is above its loss limit and deactivates it in case\\n     *  of serious losses. The loss limit should be set to some value which is unnacceptable to be lost\\n     *  in the case of normal runtime and thus require a panic shutdown, whatever it is defined to be.\\n     *\\n     *  Lastly, the Allocator reports its state to the Extender, which handles gain, loss, allocated logic.\\n     *  The documentation on this can be found in `TreasuryExtender.sol`.\\n     * @param id the id of the deposit in `TreasuryExtender`\\n     */\\n    function update(uint256 id) external override onlyGuardian onlyActivated {\\n        // effects\\n        // handle depositing, harvesting, compounding logic inside of _update()\\n        // if gain is in allocated then gain > 0 otherwise gain == 0\\n        // we only use so we know initia\\n        // loss always in allocated\\n        (uint128 gain, uint128 loss) = _update(id);\\n\\n        if (_lossLimitViolated(id, loss)) {\\n            deactivate(true);\\n            return;\\n        }\\n\\n        // interactions\\n        // there is no interactions happening inside of report\\n        // so allocator has no state changes to make after it\\n        if (gain + loss > 0) extender.report(id, gain, loss);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Prepares the Allocator for token migration.\\n     * @dev\\n     *  This function prepares the Allocator for token migration by calling the to-be-implemented\\n     *  `_prepareMigration`, which should logically withdraw ALL allocated (1) + utility AND reward tokens\\n     *  from the contract. The ALLOCATED token and THE UTILITY TOKEN is going to be migrated, while the REWARD\\n     *  tokens can be withdrawn by the Extender to the Treasury.\\n     */\\n    function prepareMigration() external override onlyGuardian notMigrating {\\n        // effects\\n        _prepareMigration();\\n\\n        status = AllocatorStatus.MIGRATING;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Migrates the allocated and all utility tokens to the next Allocator.\\n     * @dev\\n     *  The allocated token and the utility tokens will be migrated by this function, while it is\\n     *  assumed that the reward tokens are either simply kept or already harvested into the underlying\\n     *  essentially being the edge case of this contract. This contract is also going to report to the\\n     *  Extender that a migration happened and as such it is important to follow the proper sequence of\\n     *  migrating.\\n     *\\n     *  Steps to migrate:\\n     *   - FIRST call `_prepareMigration()` to prepare funds for migration.\\n     *   - THEN deploy the new Allocator and activate it according to the normal procedure.\\n     *     NOTE: This is to be done RIGHT BEFORE migration as to avoid allocating to the wrong allocator.\\n     *   - FINALLY call migrate. This is going to migrate the funds to the LAST allocator registered.\\n     *   - Check if everything went fine.\\n     *\\n     *  End state should be that allocator amounts have been swapped for allocators, that gain + loss is netted out 0\\n     *  for original allocator, and that the new allocators gain has been set to the original allocators gain.\\n     *  We don't transfer the loss because we have the information how much was initially invested + gain,\\n     *  and the new allocator didn't cause any loss thus we don't really need to add to it.\\n     */\\n    function migrate() external override onlyGuardian isMigrating {\\n        // reads\\n        IERC20[] memory utilityTokensArray = utilityTokens();\\n        address newAllocator = extender.getAllocatorByID(extender.getTotalAllocatorCount() - 1);\\n\\tuint256 idLength = _ids.length;\\n\\tuint256 utilLength = utilityTokensArray.length;\\n\\n        // interactions\\n        for (uint256 i; i < idLength; i++) {\\n            IERC20 token = _tokens[i];\\n\\n            token.safeTransfer(newAllocator, token.balanceOf(address(this)));\\n            extender.report(_ids[i], type(uint128).max, type(uint128).max);\\n        }\\n\\n        for (uint256 i; i < utilLength; i++) {\\n            IERC20 utilityToken = utilityTokensArray[i];\\n            utilityToken.safeTransfer(newAllocator, utilityToken.balanceOf(address(this)));\\n        }\\n\\n        // turn off Allocator\\n        deactivate(false);\\n\\n        emit MigrationExecuted(newAllocator);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Activates the Allocator.\\n     * @dev\\n     *  Only the Guardian can call this.\\n     *\\n     *  Add any logic you need during activation, say interactions with Extender or something else,\\n     *  in the virtual method `_activate`.\\n     */\\n    function activate() external override onlyGuardian onlyOffline {\\n        // effects\\n        _activate();\\n        status = AllocatorStatus.ACTIVATED;\\n\\n        emit AllocatorActivated();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Adds a deposit ID to the Allocator.\\n     * @dev\\n     *  Only the Extender calls this.\\n     * @param id id to add to the allocator\\n     */\\n    function addId(uint256 id) external override onlyExtender {\\n        _ids.push(id);\\n        tokenIds[id] = _ids.length - 1;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Returns all deposit IDs registered with the Allocator.\\n     * @return the deposit IDs registered\\n     */\\n    function ids() external view override returns (uint256[] memory) {\\n        return _ids;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Returns all tokens registered with the Allocator.\\n     * @return the tokens\\n     */\\n    function tokens() external view override returns (IERC20[] memory) {\\n        return _tokens;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Deactivates the Allocator.\\n     * @dev\\n     *  Only the Guardian can call this.\\n     *\\n     *  Add any logic you need during deactivation, say interactions with Extender or something else,\\n     *  in the virtual method `_deactivate`. Be careful to specifically use the internal or public function\\n     *  depending on what you need.\\n     * @param panic should panic logic be executed\\n     */\\n    function deactivate(bool panic) public override onlyGuardian {\\n        // effects\\n        _deactivate(panic);\\n        status = AllocatorStatus.OFFLINE;\\n\\n        emit AllocatorDeactivated(panic);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Getter for Allocator version.\\n     * @return Returns the Allocators version.\\n     */\\n    function version() public pure override returns (string memory) {\\n        return \\\"v2.0.0\\\";\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check if the loss limit has been violated by the Allocator.\\n     * @dev\\n     *  Called as part of `update`. The rule is that the already sustained loss + newly sustained\\n     *  has to be larger or equal to the limit to break the contract.\\n     * @param id deposit id as in `TreasuryExtender`\\n     * @param loss the amount of newly sustained loss\\n     * @return true if the the loss limit has been broken\\n     */\\n    function _lossLimitViolated(uint256 id, uint128 loss) internal returns (bool) {\\n        // read\\n        uint128 lastLoss = extender.getAllocatorPerformance(id).loss;\\n\\n        // events\\n        if ((loss + lastLoss) >= extender.getAllocatorLimits(id).loss) {\\n            emit LossLimitViolated(lastLoss, loss, amountAllocated(tokenIds[id]));\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if sender is extender.\\n     */\\n    function _onlyExtender(address sender) internal view {\\n        if (sender != address(extender)) revert BaseAllocator_OnlyExtender(sender);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is activated.\\n     */\\n    function _onlyActivated(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus != AllocatorStatus.ACTIVATED) revert BaseAllocator_AllocatorNotActivated();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is offline.\\n     */\\n    function _onlyOffline(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus != AllocatorStatus.OFFLINE) revert BaseAllocator_AllocatorNotOffline();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is not migrating.\\n     */\\n    function _notMigrating(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus == AllocatorStatus.MIGRATING) revert BaseAllocator_Migrating();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is migrating.\\n     */\\n    function _isMigrating(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus != AllocatorStatus.MIGRATING) revert BaseAllocator_NotMigrating();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/allocators/interfaces/ILockedCvx.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\n// comments check if interface is fine with v2\\ninterface ILockedCvx {\\n    struct LockedBalance {\\n        uint112 amount;\\n        uint112 boosted;\\n        uint32 unlockTime;\\n    }\\n\\n    struct EarnedData {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    function lock(\\n        address _account,\\n        uint256 _amount,\\n        uint256 _spendRatio\\n    ) external;\\n\\n    function processExpiredLocks(bool _relock) external; // ok, was edited\\n\\n    function getReward(address _account, bool _stake) external; // ok\\n\\n    function balanceAtEpochOf(uint256 _epoch, address _user) external view returns (uint256 amount);\\n\\n    function claimableRewards(address _account) external view returns (EarnedData[] memory userRewards);\\n\\n    function totalSupplyAtEpoch(uint256 _epoch) external view returns (uint256 supply);\\n\\n    function epochCount() external view returns (uint256);\\n\\n    function epochs(uint256 _id) external view returns (uint224, uint32);\\n\\n    function checkpointEpoch() external;\\n\\n    function balanceOf(address _account) external view returns (uint256);\\n\\n    function lockedBalanceOf(address _user) external view returns (uint256 amount);\\n\\n    function pendingLockOf(address _user) external view returns (uint256 amount);\\n\\n    function pendingLockAtEpochOf(uint256 _epoch, address _user) external view returns (uint256 amount);\\n\\n    function stakingToken() external view returns (address);\\n\\n    function totalSupply() external view returns (uint256 supply);\\n\\n    function lockedBalances(address _user)\\n        external\\n        view\\n        returns (\\n            uint256 total,\\n            uint256 unlockable,\\n            uint256 locked,\\n            LockedBalance[] memory lockData\\n        );\\n\\n    function addReward(\\n        address _rewardsToken,\\n        address _distributor,\\n        bool _useBoost\\n    ) external;\\n\\n    function approveRewardDistributor(\\n        address _rewardsToken,\\n        address _distributor,\\n        bool _approved\\n    ) external;\\n\\n    function setStakeLimits(uint256 _minimum, uint256 _maximum) external;\\n\\n    function setBoost(\\n        uint256 _max,\\n        uint256 _rate,\\n        address _receivingAddress\\n    ) external;\\n\\n    function setKickIncentive(uint256 _rate, uint256 _delay) external;\\n\\n    function shutdown() external;\\n\\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external;\\n\\n    function notifyRewardAmount(address _rewardToken, uint256 _reward) external;\\n\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/allocators/interfaces/ICrvDepositor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface ICrvDepositor {\\n    function deposit(uint256, bool) external;\\n}\\n\"\r\n    },\r\n    \"contracts/allocators/interfaces/IRewardStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface IRewardStaking {\\n    function stakeFor(address, uint256) external;\\n\\n    function stake(uint256) external;\\n\\n    function withdraw(uint256 amount, bool claim) external;\\n\\n    function withdrawAndUnwrap(uint256 amount, bool claim) external;\\n\\n    function earned(address account) external view returns (uint256);\\n\\n    function getReward() external;\\n\\n    function getReward(address _account, bool _claimExtras) external;\\n\\n    function extraRewardsLength() external view returns (uint256);\\n\\n    function extraRewards(uint256 _pid) external view returns (address);\\n\\n    function stakingToken() external view returns (address);\\n\\n    function rewardToken() external view returns (address);\\n\\n    function balanceOf(address _account) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/allocators/interfaces/ConvexInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IConvex {\\n    function deposit(\\n        uint256 _pid,\\n        uint256 _amount,\\n        bool _stake\\n    ) external returns (bool);\\n\\n    function depositAll(uint256 _pid, bool _stake) external returns (bool);\\n\\n    function poolInfo(uint256)\\n        external\\n        view\\n        returns (\\n            address,\\n            address,\\n            address,\\n            address,\\n            address,\\n            bool\\n        );\\n}\\n\\ninterface IDelegation {\\n    function setDelegate(bytes32 _id, address _delegate) external;\\n}\\n\\ninterface IConvexRewards {\\n    function withdrawAndUnwrap(uint256 _amount, bool _claim) external returns (bool);\\n\\n    function withdrawAllAndUnwrap(bool claim) external;\\n\\n    function getReward() external returns (bool);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function earned(address _account) external view returns (uint256);\\n\\n    function extraRewards(uint256) external view returns (address);\\n\\n    function extraRewardsLength() external view returns (uint256);\\n}\\n\\ninterface IConvexVirtualBalanceRewards {\\n    function getReward() external returns (bool);\\n\\n    function earned(address _account) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAllocator.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\n// interfaces\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ITreasuryExtender.sol\\\";\\nimport \\\"./IOlympusAuthority.sol\\\";\\n\\nenum AllocatorStatus {\\n    OFFLINE,\\n    ACTIVATED,\\n    MIGRATING\\n}\\n\\nstruct AllocatorInitData {\\n    IOlympusAuthority authority;\\n    ITreasuryExtender extender;\\n    IERC20[] tokens;\\n}\\n\\n/**\\n * @title Interface for the BaseAllocator\\n * @dev\\n *  These are the standard functions that an Allocator should implement. A subset of these functions\\n *  is implemented in the `BaseAllocator`. Similar to those implemented, if for some reason the developer\\n *  decides to implement a dedicated base contract, or not at all and rather a dedicated Allocator contract\\n *  without base, imitate the functionalities implemented in it.\\n */\\ninterface IAllocator {\\n    /**\\n     * @notice\\n     *  Emitted when the Allocator is deployed.\\n     */\\n    event AllocatorDeployed(address authority, address extender);\\n\\n    /**\\n     * @notice\\n     *  Emitted when the Allocator is activated.\\n     */\\n    event AllocatorActivated();\\n\\n    /**\\n     * @notice\\n     *  Emitted when the Allocator is deactivated.\\n     */\\n    event AllocatorDeactivated(bool panic);\\n\\n    /**\\n     * @notice\\n     *  Emitted when the Allocators loss limit is violated.\\n     */\\n    event LossLimitViolated(uint128 lastLoss, uint128 dloss, uint256 estimatedTotalAllocated);\\n\\n    /**\\n     * @notice\\n     *  Emitted when a Migration is executed.\\n     * @dev\\n     *  After this also `AllocatorDeactivated` should follow.\\n     */\\n    event MigrationExecuted(address allocator);\\n\\n    /**\\n     * @notice\\n     *  Emitted when Ether is received by the contract.\\n     * @dev\\n     *  Only the Guardian is able to send the ether.\\n     */\\n    event EtherReceived(uint256 amount);\\n\\n    function update(uint256 id) external;\\n\\n    function deallocate(uint256[] memory amounts) external;\\n\\n    function prepareMigration() external;\\n\\n    function migrate() external;\\n\\n    function activate() external;\\n\\n    function deactivate(bool panic) external;\\n\\n    function addId(uint256 id) external;\\n\\n    function name() external view returns (string memory);\\n\\n    function ids() external view returns (uint256[] memory);\\n\\n    function tokenIds(uint256 id) external view returns (uint256);\\n\\n    function version() external view returns (string memory);\\n\\n    function status() external view returns (AllocatorStatus);\\n\\n    function tokens() external view returns (IERC20[] memory);\\n\\n    function utilityTokens() external view returns (IERC20[] memory);\\n\\n    function rewardTokens() external view returns (IERC20[] memory);\\n\\n    function amountAllocated(uint256 id) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface ITreasury {\\n    function deposit(\\n        uint256 _amount,\\n        address _token,\\n        uint256 _profit\\n    ) external returns (uint256);\\n\\n    function withdraw(uint256 _amount, address _token) external;\\n\\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\\n\\n    function mint(address _recipient, uint256 _amount) external;\\n\\n    function manage(address _token, uint256 _amount) external;\\n\\n    function incurDebt(uint256 amount_, address token_) external;\\n\\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\\n\\n    function excessReserves() external view returns (uint256);\\n\\n    function baseSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/types/OlympusAccessControlledV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\nimport \\\"../interfaces/IOlympusAuthority.sol\\\";\\n\\nerror UNAUTHORIZED();\\nerror AUTHORITY_INITIALIZED();\\n\\n/// @dev Reasoning for this contract = modifiers literaly copy code\\n/// instead of pointing towards the logic to execute. Over many\\n/// functions this bloats contract size unnecessarily.\\n/// imho modifiers are a meme.\\nabstract contract OlympusAccessControlledV2 {\\n    /* ========== EVENTS ========== */\\n\\n    event AuthorityUpdated(IOlympusAuthority authority);\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IOlympusAuthority public authority;\\n\\n    /* ========== Constructor ========== */\\n\\n    constructor(IOlympusAuthority _authority) {\\n        authority = _authority;\\n        emit AuthorityUpdated(_authority);\\n    }\\n\\n    /* ========== \\\"MODIFIERS\\\" ========== */\\n\\n    modifier onlyGovernor {\\n\\t_onlyGovernor();\\n\\t_;\\n    }\\n\\n    modifier onlyGuardian {\\n\\t_onlyGuardian();\\n\\t_;\\n    }\\n\\n    modifier onlyPolicy {\\n\\t_onlyPolicy();\\n\\t_;\\n    }\\n\\n    modifier onlyVault {\\n\\t_onlyVault();\\n\\t_;\\n    }\\n\\n    /* ========== GOV ONLY ========== */\\n\\n    function initializeAuthority(IOlympusAuthority _newAuthority) internal {\\n        if (authority != IOlympusAuthority(address(0))) revert AUTHORITY_INITIALIZED();\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n\\n    function setAuthority(IOlympusAuthority _newAuthority) external {\\n        _onlyGovernor();\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n\\n    /* ========== INTERNAL CHECKS ========== */\\n\\n    function _onlyGovernor() internal view {\\n        if (msg.sender != authority.governor()) revert UNAUTHORIZED();\\n    }\\n\\n    function _onlyGuardian() internal view {\\n        if (msg.sender != authority.guardian()) revert UNAUTHORIZED();\\n    }\\n\\n    function _onlyPolicy() internal view {\\n        if (msg.sender != authority.policy()) revert UNAUTHORIZED();\\n    }\\n\\n    function _onlyVault() internal view {\\n        if (msg.sender != authority.vault()) revert UNAUTHORIZED();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.5;\\n\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\\n/// Taken from Solmate\\nlibrary SafeERC20 {\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        (bool success, ) = to.call{value: amount}(new bytes(0));\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasuryExtender.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\nstruct AllocatorPerformance {\\n    uint128 gain;\\n    uint128 loss;\\n}\\n\\nstruct AllocatorLimits {\\n    uint128 allocated;\\n    uint128 loss;\\n}\\n\\nstruct AllocatorHoldings {\\n    uint256 allocated;\\n}\\n\\nstruct AllocatorData {\\n    AllocatorHoldings holdings;\\n    AllocatorLimits limits;\\n    AllocatorPerformance performance;\\n}\\n\\n/**\\n * @title Interface for the TreasuryExtender\\n */\\ninterface ITreasuryExtender {\\n    /**\\n     * @notice\\n     *  Emitted when a new Deposit is registered.\\n     */\\n    event NewDepositRegistered(address allocator, address token, uint256 id);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator is funded\\n     */\\n    event AllocatorFunded(uint256 id, uint256 amount, uint256 value);\\n\\n    /**\\n     * @notice\\n     *  Emitted when allocated funds are withdrawn from an Allocator\\n     */\\n    event AllocatorWithdrawal(uint256 id, uint256 amount, uint256 value);\\n\\n    /**\\n     * @notice\\n     *  Emitted when rewards are withdrawn from an Allocator\\n     */\\n    event AllocatorRewardsWithdrawal(address allocator, uint256 amount, uint256 value);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator reports a gain\\n     */\\n    event AllocatorReportedGain(uint256 id, uint128 gain);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator reports a loss\\n     */\\n    event AllocatorReportedLoss(uint256 id, uint128 loss);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator reports a migration\\n     */\\n    event AllocatorReportedMigration(uint256 id);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator limits are modified\\n     */\\n    event AllocatorLimitsChanged(uint256 id, uint128 allocationLimit, uint128 lossLimit);\\n\\n    function registerDeposit(address newAllocator) external;\\n\\n    function setAllocatorLimits(uint256 id, AllocatorLimits memory limits) external;\\n\\n    function report(\\n        uint256 id,\\n        uint128 gain,\\n        uint128 loss\\n    ) external;\\n\\n    function requestFundsFromTreasury(uint256 id, uint256 amount) external;\\n\\n    function returnFundsToTreasury(uint256 id, uint256 amount) external;\\n\\n    function returnRewardsToTreasury(\\n        uint256 id,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    function getTotalAllocatorCount() external view returns (uint256);\\n\\n    function getAllocatorByID(uint256 id) external view returns (address);\\n\\n    function getAllocatorAllocated(uint256 id) external view returns (uint256);\\n\\n    function getAllocatorLimits(uint256 id) external view returns (AllocatorLimits memory);\\n\\n    function getAllocatorPerformance(uint256 id) external view returns (AllocatorPerformance memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOlympusAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IOlympusAuthority {\\n    /* ========== EVENTS ========== */\\n\\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n\\n    event GovernorPulled(address indexed from, address indexed to);\\n    event GuardianPulled(address indexed from, address indexed to);\\n    event PolicyPulled(address indexed from, address indexed to);\\n    event VaultPulled(address indexed from, address indexed to);\\n\\n    /* ========== VIEW ========== */\\n\\n    function governor() external view returns (address);\\n\\n    function guardian() external view returns (address);\\n\\n    function policy() external view returns (address);\\n\\n    function vault() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"contract ILockedCvx\",\"name\":\"cvxLocker\",\"type\":\"address\"},{\"internalType\":\"uint88\",\"name\":\"spendRatio\",\"type\":\"uint88\"},{\"internalType\":\"bool\",\"name\":\"relock\",\"type\":\"bool\"},{\"internalType\":\"contract ICrvDepositor\",\"name\":\"crvDeposit\",\"type\":\"address\"},{\"internalType\":\"contract IRewardStaking\",\"name\":\"ccStaking\",\"type\":\"address\"}],\"internalType\":\"struct OperationData\",\"name\":\"opDataArg\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"authority\",\"type\":\"address\"},{\"internalType\":\"contract ITreasuryExtender\",\"name\":\"extender\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"internalType\":\"struct AllocatorInitData\",\"name\":\"aData\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BaseAllocator_AllocatorNotActivated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseAllocator_AllocatorNotOffline\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseAllocator_Migrating\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseAllocator_NotMigrating\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"BaseAllocator_OnlyExtender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNAUTHORIZED\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AllocatorActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"panic\",\"type\":\"bool\"}],\"name\":\"AllocatorDeactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"extender\",\"type\":\"address\"}],\"name\":\"AllocatorDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IOlympusAuthority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"lastLoss\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"dloss\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"estimatedTotalAllocated\",\"type\":\"uint256\"}],\"name\":\"LossLimitViolated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"allocator\",\"type\":\"address\"}],\"name\":\"MigrationExecuted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"addId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"amountAllocated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"panic\",\"type\":\"bool\"}],\"name\":\"deactivate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"deallocate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extender\",\"outputs\":[{\"internalType\":\"contract ITreasuryExtender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ids\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"opData\",\"outputs\":[{\"internalType\":\"contract ILockedCvx\",\"name\":\"cvxLocker\",\"type\":\"address\"},{\"internalType\":\"uint88\",\"name\":\"spendRatio\",\"type\":\"uint88\"},{\"internalType\":\"bool\",\"name\":\"relock\",\"type\":\"bool\"},{\"internalType\":\"contract ICrvDepositor\",\"name\":\"crvDeposit\",\"type\":\"address\"},{\"internalType\":\"contract IRewardStaking\",\"name\":\"ccStaking\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prepareMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"_newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegationContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"setDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract ILockedCvx\",\"name\":\"cvxLocker\",\"type\":\"address\"},{\"internalType\":\"uint88\",\"name\":\"spendRatio\",\"type\":\"uint88\"},{\"internalType\":\"bool\",\"name\":\"relock\",\"type\":\"bool\"},{\"internalType\":\"contract ICrvDepositor\",\"name\":\"crvDeposit\",\"type\":\"address\"},{\"internalType\":\"contract IRewardStaking\",\"name\":\"ccStaking\",\"type\":\"address\"}],\"internalType\":\"struct OperationData\",\"name\":\"newData\",\"type\":\"tuple\"}],\"name\":\"setOperationData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"relock\",\"type\":\"bool\"}],\"name\":\"setRelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint88\",\"name\":\"ratio\",\"type\":\"uint88\"}],\"name\":\"setSpendRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"enum AllocatorStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"utilityTokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "CVXAllocatorV2", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "00000000000000000000000072a19342e8f1838460ebfccef09f6585e32db86e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000008014595f2ab54cd7c604b00e9fb932176fdc86ae0000000000000000000000003fe65692bfcd0e6cf84cb1e7d24108e434a7587e00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000001c21f8ea7e39e2ba00bc12d2968d63f4acb38b7a000000000000000000000000b32ad041f23eafd682f57fce31d3ea4fd92d17af000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000030000000000000000000000004e3fbd56cd56c3e72c1403e103b45db9da5b9d2b000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd5200000000000000000000000062b9c7356a2dc64a1969e19c23e4f579f9810aa7", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}