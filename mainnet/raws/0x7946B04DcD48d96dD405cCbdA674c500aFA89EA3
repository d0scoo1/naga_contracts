{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"BalancerGlobal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nenum VaultType {DEFAULT, AUTOMATED, FIXED_TERM, EXPERIMENTAL}\\n\\ninterface IDetails {\\n    // get details from curve\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n}\\n\\ninterface Registry {\\n    function newVault(\\n        address _token,\\n        address _governance,\\n        address _guardian,\\n        address _rewards,\\n        string calldata _name,\\n        string calldata _symbol,\\n        uint256 _releaseDelta,\\n        VaultType _type\\n    ) external returns (address);\\n\\n    function isRegistered(address token) external view returns (bool);\\n\\n    function latestVault(address token) external view returns (address);\\n\\n    function latestVault(address token, VaultType _type)\\n        external\\n        view\\n        returns (address);\\n\\n    function endorseVault(\\n        address _vault,\\n        uint256 _releaseDelta,\\n        VaultType _type\\n    ) external;\\n}\\n\\ninterface IPoolManager {\\n    function addPool(address _gauge) external returns (bool);\\n}\\n\\ninterface ICurveGauge {\\n    function deposit(uint256) external;\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function withdraw(uint256) external;\\n\\n    function claim_rewards() external;\\n\\n    function reward_tokens(uint256) external view returns (address); //v2\\n\\n    function rewarded_token() external view returns (address); //v1\\n\\n    function lp_token() external view returns (address);\\n}\\n\\ninterface IGaugeController {\\n    function get_gauge_weight(address _gauge) external view returns (uint256);\\n\\n    function vote_user_slopes(address, address)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        ); //slope,power,end\\n\\n    function vote_for_gauge_weights(address, uint256) external;\\n\\n    function add_gauge(\\n        address,\\n        int128,\\n        uint256\\n    ) external;\\n}\\n\\ninterface IStrategy {\\n    function cloneStrategyConvex(\\n        address _vault,\\n        address _strategist,\\n        address _rewards,\\n        address _keeper,\\n        uint256 _pid,\\n        address _tradeFactory,\\n        uint256 _harvestProfitMax,\\n        address _booster,\\n        address _convexToken\\n\\n    ) external returns (address newStrategy);\\n\\n    function setHealthCheck(address) external;\\n}\\n\\ninterface IBooster {\\n    function gaugeMap(address) external view returns (bool);\\n\\n    // deposit into convex, receive a tokenized deposit.  parameter to stake immediately (we always do this).\\n    function deposit(\\n        uint256 _pid,\\n        uint256 _amount,\\n        bool _stake\\n    ) external returns (bool);\\n\\n    // burn a tokenized deposit (Convex deposit tokens) to receive curve lp tokens back\\n    function withdraw(uint256 _pid, uint256 _amount) external returns (bool);\\n\\n    function poolLength() external view returns (uint256);\\n\\n    // give us info about a pool based on its pid\\n    function poolInfo(uint256)\\n        external\\n        view\\n        returns (\\n            address,\\n            address,\\n            address,\\n            address,\\n            address,\\n            bool\\n        );\\n}\\n\\ninterface Vault {\\n    function setGovernance(address) external;\\n\\n    function setManagement(address) external;\\n\\n    function managementFee() external view returns (uint256);\\n\\n    function setManagementFee(uint256) external;\\n\\n    function performanceFee() external view returns (uint256);\\n\\n    function setPerformanceFee(uint256) external;\\n\\n    function setDepositLimit(uint256) external;\\n\\n    function addStrategy(\\n        address,\\n        uint256,\\n        uint256,\\n        uint256,\\n        uint256\\n    ) external;\\n}\\n\\ncontract BalancerGlobal {\\n    event NewAutomatedVault(\\n        uint256 indexed category,  \\n        address indexed lpToken,\\n        address indexed vault,\\n        address gauge,\\n        address strategy\\n    );\\n\\n    ///////////////////////////////////\\n    //\\n    //  Storage variables and setters\\n    //\\n    ////////////////////////////////////\\n\\n    address[] public deployedVaults;\\n    uint256 public numVaults;\\n\\n    address public constant aura = 0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF;\\n    uint256 public constant category = 1; // 1 for balancer\\n    // always owned by ychad\\n    address public owner = 0xFEB4acf3df3cDEA7399794D0869ef76A6EfAff52;\\n    address internal pendingOwner;\\n\\n    function setOwner(address newOwner) external {\\n        require(msg.sender == owner);\\n        pendingOwner = newOwner;\\n    }\\n\\n    function acceptOwner() external {\\n        require(msg.sender == pendingOwner);\\n        owner = pendingOwner;\\n    }\\n\\n    address public auraPoolManager =\\n        0xf843F61508Fc17543412DE55B10ED87f4C28DE50;\\n\\n    function setAuraPoolManager(address _auraPoolManager) external {\\n        require(msg.sender == owner);\\n        auraPoolManager = _auraPoolManager;\\n    }\\n\\n    Registry public registry; //= Registry(address(0x50c1a2eA0a861A967D9d0FFE2AE4012c2E053804));\\n\\n    function setRegistry(address _registry) external {\\n        require(msg.sender == owner);\\n        registry = Registry(_registry);\\n    }\\n\\n    IBooster public booster =\\n        IBooster(0x7818A1DA7BD1E64c199029E86Ba244a9798eEE10);\\n\\n    function setConvexDeposit(address _booster) external {\\n        require(msg.sender == owner);\\n        booster = IBooster(_booster);\\n    }\\n\\n    address public management = 0x16388463d60FFE0661Cf7F1f31a7D658aC790ff7;\\n\\n    function setManagement(address _management) external {\\n        require(msg.sender == owner);\\n        management = _management;\\n    }\\n\\n    address public guardian = 0x846e211e8ba920B353FB717631C015cf04061Cc9;\\n\\n    function setGuardian(address _guardian) external {\\n        require(msg.sender == owner);\\n        guardian = _guardian;\\n    }\\n\\n    address public treasury = 0x93A62dA5a14C80f265DAbC077fCEE437B1a0Efde;\\n\\n    function setTreasury(address _treasury) external {\\n        require(msg.sender == owner);\\n        treasury = _treasury;\\n    }\\n\\n    address public keeper = 0x256e6a486075fbAdbB881516e9b6b507fd082B5D;\\n\\n    function setKeeper(address _keeper) external {\\n        require(msg.sender == owner);\\n        keeper = _keeper;\\n    }\\n\\n    address public rewardsStrat = 0xc491599b9A20c3A2F0A85697Ee6D9434EFa9f503;\\n\\n    function setStratRewards(address _rewards) external {\\n        require(msg.sender == owner);\\n        rewardsStrat = _rewards;\\n    }\\n\\n    address public healthCheck = 0xDDCea799fF1699e98EDF118e0629A974Df7DF012;\\n\\n    function setHealthcheck(address _health) external {\\n        require(msg.sender == owner);\\n        healthCheck = _health;\\n    }\\n\\n    address public tradeFactory = 0xd6a8ae62f4d593DAf72E2D7c9f7bDB89AB069F06;\\n\\n    function setTradeFactory(address _tradeFactory) external {\\n        require(msg.sender == owner || msg.sender == management);\\n        tradeFactory = _tradeFactory;\\n    }\\n\\n    uint256 public depositLimit = 10_000_000 * 1e18; // some large number\\n\\n    function setDepositLimit(uint256 _depositLimit) external {\\n        require(msg.sender == owner || msg.sender == management);\\n        depositLimit = _depositLimit;\\n    }\\n\\n    address public auraStratImplementation;\\n\\n    function setAuraStratImplementation(address _auraStratImplementation)\\n        external\\n    {\\n        require(msg.sender == owner);\\n        auraStratImplementation = _auraStratImplementation;\\n    }\\n\\n    uint256 public keepCRV = 0; // the percentage of CRV we re-lock for boost (in basis points).Default is 0%.\\n\\n    // Set the amount of CRV to be locked in Yearn's veCRV voter from each harvest.\\n    function setKeepCRV(uint256 _keepCRV) external {\\n        require(msg.sender == owner);\\n        require(_keepCRV <= 10_000);\\n        keepCRV = _keepCRV;\\n    }\\n\\n    uint256 public harvestProfitMaxInUsdt = 25_000 * 1e6; // what profit do we need to harvest\\n\\n    function setHarvestProfitMaxInUsdt(uint256 _harvestProfitMaxInUsdt)\\n        external\\n    {\\n        require(msg.sender == owner || msg.sender == management);\\n        harvestProfitMaxInUsdt = _harvestProfitMaxInUsdt;\\n    }\\n\\n    uint256 public performanceFee = 1_000;\\n\\n    function setPerformanceFee(uint256 _performanceFee) external {\\n        require(msg.sender == owner);\\n        require(_performanceFee <= 5_000);\\n        performanceFee = _performanceFee;\\n    }\\n\\n    uint256 public managementFee = 0;\\n\\n    function setManagementFee(uint256 _managementFee) external {\\n        require(msg.sender == owner);\\n        require(_managementFee <= 1_000);\\n        managementFee = _managementFee;\\n    }\\n\\n    ///////////////////////////////////\\n    //\\n    // Functions\\n    //\\n    ////////////////////////////////////\\n\\n    constructor(address _registry, address _auraStratImplementation) public {\\n        registry = Registry(_registry);\\n        auraStratImplementation = _auraStratImplementation;\\n    }\\n\\n    function alreadyExistsFromGauge(address _gauge)\\n        public\\n        view\\n        returns (address)\\n    {\\n        address lptoken = ICurveGauge(_gauge).lp_token();\\n        return alreadyExistsFromToken(lptoken);\\n    }\\n\\n    function alreadyExistsFromToken(address lptoken)\\n        public\\n        view\\n        returns (address)\\n    {\\n        if (!registry.isRegistered(lptoken)) {\\n            return address(0);\\n        }\\n\\n        // check default vault followed by automated\\n        bytes memory data =\\n            abi.encodeWithSignature(\\\"latestVault(address)\\\", lptoken);\\n        (bool success, ) = address(registry).staticcall(data);\\n        if (success) {\\n            return registry.latestVault(lptoken);\\n        } else {\\n            return registry.latestVault(lptoken, VaultType.AUTOMATED);\\n        }\\n    }\\n\\n    //very annoying\\n    function getPid(address _gauge) public view returns (uint256 pid) {\\n        pid = type(uint256).max;\\n\\n        if (!booster.gaugeMap(_gauge)) {\\n            return pid;\\n        }\\n\\n        for (uint256 i = booster.poolLength(); i > 0; i--) {\\n            //we start at the end and work back for most recent\\n            (, , address gauge, , , ) = booster.poolInfo(i - 1);\\n\\n            if (_gauge == gauge) {\\n                return i - 1;\\n            }\\n        }\\n    }\\n\\n    // only permissioned users can deploy if there is already one endorsed\\n    function createNewVaultsAndStrategies(\\n        address _gauge,\\n        bool _allowDuplicate\\n    ) external returns (address vault, address auraStrategy) {\\n        require(msg.sender == owner || msg.sender == management);\\n\\n        return _createNewVaultsAndStrategies(_gauge, _allowDuplicate);\\n    }\\n\\n    function createNewVaultsAndStrategies(address _gauge)\\n        external\\n        returns (address vault, address auraStrategy)\\n    {\\n        return _createNewVaultsAndStrategies(_gauge, false);\\n    }\\n\\n    function _createNewVaultsAndStrategies(\\n        address _gauge,\\n        bool _allowDuplicate\\n    ) internal returns (address vault, address auraStrategy) {\\n        if (!_allowDuplicate) {\\n            require(\\n                alreadyExistsFromGauge(_gauge) == address(0),\\n                \\\"Vault already exists\\\"\\n            );\\n        }\\n        address lptoken = ICurveGauge(_gauge).lp_token();\\n\\n        //get convex pid. if no pid create one\\n        uint256 pid = getPid(_gauge);\\n        if (pid == type(uint256).max) {\\n            //when we add the new pool it will be added to the end of the pools in convexDeposit.\\n            pid = booster.poolLength();\\n            //add pool\\n            require(\\n                IPoolManager(auraPoolManager).addPool(_gauge),\\n                \\\"Unable to add pool to Aura\\\"\\n            );\\n        }\\n\\n        //now we create the vault, endorses it as well\\n        vault = registry.newVault(\\n            lptoken,\\n            address(this),\\n            guardian,\\n            treasury,\\n            string(\\n                abi.encodePacked(\\n                    \\\"Balancer \\\",\\n                    IDetails(address(lptoken)).symbol(),\\n                    \\\" Auto-Compounding yVault\\\"\\n                )\\n            ),\\n            string(\\n                abi.encodePacked(\\\"yvBlp\\\", IDetails(address(lptoken)).symbol())\\n            ),\\n            0,\\n            VaultType.AUTOMATED\\n        );\\n        deployedVaults.push(vault);\\n        numVaults = deployedVaults.length;\\n\\n        Vault v = Vault(vault);\\n        v.setManagement(management);\\n        //set governance to owner who needs to accept before it is finalised. until then governance is this factory\\n        v.setGovernance(owner);\\n        v.setDepositLimit(depositLimit);\\n\\n        if (v.managementFee() != managementFee) {\\n            v.setManagementFee(managementFee);\\n        }\\n        if (v.performanceFee() != performanceFee) {\\n            v.setPerformanceFee(performanceFee);\\n        }\\n\\n        Vault(vault).setDepositLimit(depositLimit);\\n\\n        //now we create the convex strat\\n        auraStrategy = IStrategy(auraStratImplementation)\\n            .cloneStrategyConvex(\\n            vault,\\n            management,\\n            rewardsStrat,\\n            keeper,\\n            pid,\\n            tradeFactory,\\n            harvestProfitMaxInUsdt,\\n            address(booster),\\n            aura\\n        );\\n        IStrategy(auraStrategy).setHealthCheck(healthCheck);\\n\\n        Vault(vault).addStrategy(\\n            auraStrategy,\\n            10_000,\\n            0,\\n            type(uint256).max,\\n            0\\n        );\\n\\n        emit NewAutomatedVault(category, lptoken, _gauge, vault, auraStrategy);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"BalancerGlobal.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_auraStratImplementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"category\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"NewAutomatedVault\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"alreadyExistsFromGauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lptoken\",\"type\":\"address\"}],\"name\":\"alreadyExistsFromToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aura\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auraPoolManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auraStratImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"booster\",\"outputs\":[{\"internalType\":\"contract IBooster\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"category\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_allowDuplicate\",\"type\":\"bool\"}],\"name\":\"createNewVaultsAndStrategies\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"auraStrategy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"createNewVaultsAndStrategies\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"auraStrategy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deployedVaults\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"getPid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvestProfitMaxInUsdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"healthCheck\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keepCRV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keeper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managementFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numVaults\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract Registry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsStrat\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_auraPoolManager\",\"type\":\"address\"}],\"name\":\"setAuraPoolManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_auraStratImplementation\",\"type\":\"address\"}],\"name\":\"setAuraStratImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_booster\",\"type\":\"address\"}],\"name\":\"setConvexDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositLimit\",\"type\":\"uint256\"}],\"name\":\"setDepositLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"setGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_harvestProfitMaxInUsdt\",\"type\":\"uint256\"}],\"name\":\"setHarvestProfitMaxInUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_health\",\"type\":\"address\"}],\"name\":\"setHealthcheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_keepCRV\",\"type\":\"uint256\"}],\"name\":\"setKeepCRV\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"}],\"name\":\"setKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_management\",\"type\":\"address\"}],\"name\":\"setManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_managementFee\",\"type\":\"uint256\"}],\"name\":\"setManagementFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_performanceFee\",\"type\":\"uint256\"}],\"name\":\"setPerformanceFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewards\",\"type\":\"address\"}],\"name\":\"setStratRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tradeFactory\",\"type\":\"address\"}],\"name\":\"setTradeFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BalancerGlobal", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000078f73705105a63e06b932611643e0b210fae93e9000000000000000000000000b5e1cacb567d98faadb60a1fd4820720141f064f", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}