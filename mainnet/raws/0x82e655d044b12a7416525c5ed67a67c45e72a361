{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.9 <0.9.0;\r\n\r\ncontract ERC721I {\r\n    string public name;\r\n    string public symbol;\r\n    string internal baseURI;\r\n    string internal baseExtension = \".json\";\r\n\r\n    constructor(string memory _name, string memory _symbol) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    uint256 public totalSupply;\r\n    mapping(uint256 => address) public ownerOf;\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(uint256 => address) public getApproved;\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    event Mint(address indexed to, uint256 tokenId);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    function _mint(address _to, uint256 _tokenId) internal virtual {\r\n        require(_to != address(0x0), \"ERC721I: _mint() Mint to Zero Address\");\r\n        require(\r\n            ownerOf[_tokenId] == address(0x0),\r\n            \"ERC721I: _mint() Token to Mint Already Exists!\"\r\n        );\r\n\r\n        ownerOf[_tokenId] = _to;\r\n        balanceOf[_to]++;\r\n        totalSupply++;\r\n\r\n        emit Transfer(address(0x0), _to, _tokenId);\r\n        emit Mint(_to, _tokenId);\r\n    }\r\n\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) internal virtual {\r\n        require(\r\n            _from == ownerOf[_tokenId],\r\n            \"ERC721I: _transfer() Transfer Not Owner of Token!\"\r\n        );\r\n        require(\r\n            _to != address(0x0),\r\n            \"ERC721I: _transfer() Transfer to Zero Address!\"\r\n        );\r\n\r\n        if (getApproved[_tokenId] != address(0x0)) {\r\n            _approve(address(0x0), _tokenId);\r\n        }\r\n\r\n        ownerOf[_tokenId] = _to;\r\n        balanceOf[_from]--;\r\n        balanceOf[_to]++;\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _approve(address _to, uint256 _tokenId) internal virtual {\r\n        if (getApproved[_tokenId] != _to) {\r\n            getApproved[_tokenId] = _to;\r\n            emit Approval(ownerOf[_tokenId], _to, _tokenId);\r\n        }\r\n    }\r\n\r\n    function _setApprovalForAll(\r\n        address _owner,\r\n        address _operator,\r\n        bool _approved\r\n    ) internal virtual {\r\n        require(\r\n            _owner != _operator,\r\n            \"ERC721I: _setApprovalForAll() Owner must not be the Operator!\"\r\n        );\r\n        isApprovedForAll[_owner][_operator] = _approved;\r\n        emit ApprovalForAll(_owner, _operator, _approved);\r\n    }\r\n\r\n    function _setBaseURI(string memory _uri) internal virtual {\r\n        baseURI = _uri;\r\n    }\r\n\r\n    function _toString(uint256 _value) internal pure returns (string memory) {\r\n        if (_value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 _iterate = _value;\r\n        uint256 _digits;\r\n        while (_iterate != 0) {\r\n            _digits++;\r\n            _iterate /= 10;\r\n        }\r\n        bytes memory _buffer = new bytes(_digits);\r\n        while (_value != 0) {\r\n            _digits--;\r\n            _buffer[_digits] = bytes1(uint8(48 + uint256(_value % 10)));\r\n            _value /= 10;\r\n        }\r\n        return string(_buffer);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address _spender, uint256 _tokenId)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        require(\r\n            ownerOf[_tokenId] != address(0x0),\r\n            \"ERC721I: _isApprovedOrOwner() Owner is Zero Address!\"\r\n        );\r\n        address _owner = ownerOf[_tokenId];\r\n        return (_spender == _owner ||\r\n            _spender == getApproved[_tokenId] ||\r\n            isApprovedForAll[_owner][_spender]);\r\n    }\r\n\r\n    function _exists(uint256 _tokenId) internal view virtual returns (bool) {\r\n        return ownerOf[_tokenId] != address(0x0);\r\n    }\r\n\r\n    function approve(address _to, uint256 _tokenId) public virtual {\r\n        address _owner = ownerOf[_tokenId];\r\n        require(_to != _owner, \"ERC721I: approve() Cannot approve yourself!\");\r\n        require(\r\n            msg.sender == _owner || isApprovedForAll[_owner][msg.sender],\r\n            \"ERC721I: Caller not owner or Approved!\"\r\n        );\r\n        _approve(_to, _tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved)\r\n        public\r\n        virtual\r\n    {\r\n        _setApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) public virtual {\r\n        require(\r\n            _isApprovedOrOwner(msg.sender, _tokenId),\r\n            \"ERC721I: transferFrom() _isApprovedOrOwner = false!\"\r\n        );\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes memory _data\r\n    ) public virtual {\r\n        transferFrom(_from, _to, _tokenId);\r\n        if (_to.code.length != 0) {\r\n            (, bytes memory _returned) = _to.staticcall(\r\n                abi.encodeWithSelector(\r\n                    0x150b7a02,\r\n                    msg.sender,\r\n                    _from,\r\n                    _tokenId,\r\n                    _data\r\n                )\r\n            );\r\n            bytes4 _selector = abi.decode(_returned, (bytes4));\r\n            require(\r\n                _selector == 0x150b7a02,\r\n                \"ERC721I: safeTransferFrom() to_ not ERC721Receivable!\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) public virtual {\r\n        safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    function multiTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256[] memory _tokenIds\r\n    ) public virtual {\r\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\r\n            transferFrom(_from, _to, _tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    function multiSafeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256[] memory _tokenIds,\r\n        bytes memory _data\r\n    ) public virtual {\r\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\r\n            safeTransferFrom(_from, _to, _tokenIds[i], _data);\r\n        }\r\n    }\r\n\r\n    function supportsInterface(bytes4 _interfaceId) public pure returns (bool) {\r\n        return (_interfaceId == 0x80ac58cd || _interfaceId == 0x5b5e139f);\r\n    }\r\n\r\n    function walletOfOwner(address _address)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256 _balance = balanceOf[_address];\r\n        uint256[] memory _tokens = new uint256[](_balance);\r\n        uint256 _index;\r\n        uint256 _loopThrough = totalSupply;\r\n        for (uint256 i = 0; i < _loopThrough; i++) {\r\n            if (ownerOf[i] == address(0x0) && _tokens[_balance - 1] == 0) {\r\n                _loopThrough++;\r\n            }\r\n            if (ownerOf[i] == _address) {\r\n                _tokens[_index] = i;\r\n                _index++;\r\n            }\r\n        }\r\n        return _tokens;\r\n    }\r\n}\r\n\r\nabstract contract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed _oldOwner,\r\n        address indexed _newOwner\r\n    );\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function _transferOwnership(address _newOwner) internal virtual {\r\n        address _oldOwner = owner;\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(_oldOwner, _newOwner);\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public virtual onlyOwner {\r\n        require(\r\n            _newOwner != address(0x0),\r\n            \"Ownable: new owner is the zero address!\"\r\n        );\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0x0));\r\n    }\r\n}\r\n\r\nlibrary MerkleProof {\r\n    function verify(\r\n        bytes32[] memory _proof,\r\n        bytes32 _root,\r\n        bytes32 _leaf\r\n    ) internal pure returns (bool) {\r\n        return processProof(_proof, _leaf) == _root;\r\n    }\r\n\r\n    function processProof(bytes32[] memory _proof, bytes32 _leaf)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        bytes32 _computedHash = _leaf;\r\n        for (uint256 i = 0; i < _proof.length; i++) {\r\n            bytes32 proofElement = _proof[i];\r\n            if (_computedHash <= proofElement) {\r\n                _computedHash = _efficientHash(_computedHash, proofElement);\r\n            } else {\r\n                _computedHash = _efficientHash(proofElement, _computedHash);\r\n            }\r\n        }\r\n        return _computedHash;\r\n    }\r\n\r\n    function _efficientHash(bytes32 _a, bytes32 _b)\r\n        private\r\n        pure\r\n        returns (bytes32 value)\r\n    {\r\n        assembly {\r\n            mstore(0x00, _a)\r\n            mstore(0x20, _b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\ncontract HYPEDUDES is ERC721I, Ownable {\r\n    constructor() payable ERC721I(\"HYPEDUDES\", \"HD\") {\r\n        setNotRevealedURI(\"ipfs://QmVRboxi4tnfSHPQCwANunTfEo4kiEs4EXw1Y64rB79wCX/hidden.json\");\r\n\r\n        _mintMany(msg.sender, 55);\r\n    }\r\n\r\n    uint256 public mintPrice = 0.035 ether;\r\n    uint256 public maxSupply = 5555;\r\n    uint256 public maxMintsPerTx = 4;\r\n\r\n    bytes32 public merkleRoot;\r\n\r\n    uint256 public maxMintsPerWhitelist = 4;\r\n    mapping(address => uint256) public whitelistMints;\r\n    bool public whitelistMintEnabled = false;\r\n    uint256 public whitelistMintStartTime;\r\n    uint256 public whitelistMintDuration;\r\n\r\n    bool public publicMintEnabled = false;\r\n    uint256 public publicMintStartTime;\r\n\r\n    bool public paused = false;\r\n    bool public revealed = false;\r\n    uint256 public revealedAt;\r\n    string public notRevealedUri;\r\n\r\n    modifier onlySender() {\r\n        require(msg.sender == tx.origin, \"No smart contracts!\");\r\n        _;\r\n    }\r\n\r\n    modifier whitelistMinting() {\r\n        require(\r\n            whitelistMintEnabled && block.timestamp >= whitelistMintStartTime,\r\n            \"Whitelist Mints are not enabled yet!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier publicMinting() {\r\n        require(\r\n            publicMintEnabled && block.timestamp >= publicMintStartTime,\r\n            \"Public Mints are not enabled yet!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        returns (string memory)\r\n    {\r\n        require(\r\n            ownerOf[_tokenId] != address(0x0),\r\n            \"ERC721I: tokenURI() Token does not exist!\"\r\n        );\r\n\r\n        if (revealed == false) {\r\n            return notRevealedUri;\r\n        }\r\n\r\n        return\r\n            string(\r\n                abi.encodePacked(baseURI, _toString(_tokenId), baseExtension)\r\n            );\r\n    }\r\n\r\n    function pause(bool _state) public onlyOwner {\r\n        paused = _state;\r\n    }\r\n\r\n    function reveal(string memory _uri) public onlyOwner {\r\n        require(!revealed, \"The contract is already revealed!\");\r\n\r\n        _setBaseURI(_uri);\r\n        revealed = true;\r\n        revealedAt = block.timestamp;\r\n    }\r\n\r\n    function emergencyReveal(string memory _uri) public onlyOwner {\r\n        require(\r\n            block.timestamp < revealedAt + 86400,\r\n            \"You cannot use this function. Emergency time is closed!\"\r\n        );\r\n\r\n        _setBaseURI(_uri);\r\n    }\r\n\r\n    function setMintPrice(uint256 _mintPrice) public onlyOwner {\r\n        mintPrice = _mintPrice;\r\n    }\r\n\r\n    function setMaxSupply(uint256 _maxSupply) public onlyOwner {\r\n        require(\r\n            _maxSupply >= totalSupply,\r\n            \"maxSupply cannot be set lower than totalSupply!\"\r\n        );\r\n\r\n        maxSupply = _maxSupply;\r\n    }\r\n\r\n    function setMaxMintsPerTx(uint256 _maxMintsPerTx) public onlyOwner {\r\n        maxMintsPerTx = _maxMintsPerTx;\r\n    }\r\n\r\n    function setMaxMintsPerWhitelist(uint256 _maxMintsPerWhitelist)\r\n        public\r\n        onlyOwner\r\n    {\r\n        maxMintsPerWhitelist = _maxMintsPerWhitelist;\r\n    }\r\n\r\n    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {\r\n        merkleRoot = _merkleRoot;\r\n    }\r\n\r\n    function flipWhitelist(\r\n        uint256 _whitelistMintStartTime,\r\n        uint256 _whitelistMintDuration\r\n    ) public onlyOwner {\r\n        publicMintEnabled = false;\r\n        whitelistMintEnabled = true;\r\n        whitelistMintStartTime = _whitelistMintStartTime;\r\n        whitelistMintDuration = _whitelistMintDuration;\r\n    }\r\n\r\n    function flipPublicMint(uint256 _publicMintStartTime) public onlyOwner {\r\n        whitelistMintEnabled = false;\r\n        publicMintEnabled = true;\r\n        publicMintStartTime = _publicMintStartTime;\r\n    }\r\n\r\n    function setNotRevealedURI(string memory _notRevealedURI) public onlyOwner {\r\n        notRevealedUri = _notRevealedURI;\r\n    }\r\n\r\n    function _mintMany(address _to, uint256 _amount) internal virtual {\r\n        require(\r\n            maxSupply >= totalSupply + _amount,\r\n            \"Not enough tokens remaining!\"\r\n        );\r\n\r\n        uint256 _startId = totalSupply + 1;\r\n\r\n        for (uint256 i = 0; i < _amount; i++) {\r\n            _mint(_to, _startId + i);\r\n        }\r\n    }\r\n\r\n    function ownerMint(address _to, uint256 _amount) public onlyOwner {\r\n        _mintMany(_to, _amount);\r\n    }\r\n\r\n    function ownerMintToMany(\r\n        address[] calldata _tos,\r\n        uint256[] calldata _amounts\r\n    ) public onlyOwner {\r\n        require(_tos.length == _amounts.length, \"Array lengths mismatch!\");\r\n\r\n        for (uint256 i = 0; i < _tos.length; i++) {\r\n            _mintMany(_tos[i], _amounts[i]);\r\n        }\r\n    }\r\n\r\n    function whitelistMint(uint256 _amount, bytes32[] calldata _merkleProof)\r\n        public\r\n        payable\r\n        onlySender\r\n        whitelistMinting\r\n    {\r\n        require(!paused, \"The contract is paused!\");\r\n        require(\r\n            block.timestamp < whitelistMintStartTime + whitelistMintDuration,\r\n            \"The presales is closed!\"\r\n        );\r\n        require(\r\n            MerkleProof.verify(\r\n                _merkleProof,\r\n                merkleRoot,\r\n                keccak256(abi.encodePacked(msg.sender))\r\n            ),\r\n            \"You are not whitelisted!\"\r\n        );\r\n        require(msg.value == _amount * mintPrice, \"Invalid value sent!\");\r\n        require(maxMintsPerTx >= _amount, \"Amount exceeds max mints per tx!\");\r\n        require(\r\n            maxMintsPerWhitelist >= whitelistMints[msg.sender] + _amount,\r\n            \"You don't have enough whitelist mints remaining!\"\r\n        );\r\n        require(\r\n            maxSupply >= totalSupply + _amount,\r\n            \"Not enough tokens remaining!\"\r\n        );\r\n\r\n        whitelistMints[msg.sender] += _amount;\r\n\r\n        _mintMany(msg.sender, _amount);\r\n    }\r\n\r\n    function publicMint(uint256 _amount)\r\n        public\r\n        payable\r\n        onlySender\r\n        publicMinting\r\n    {\r\n        require(!paused, \"The contract is paused!\");\r\n        require(msg.value == _amount * mintPrice, \"Invalid value sent!\");\r\n        require(maxMintsPerTx >= _amount, \"Amount exceeds max mints per tx!\");\r\n        require(\r\n            maxSupply >= totalSupply + _amount,\r\n            \"Not enough tokens remaining!\"\r\n        );\r\n\r\n        _mintMany(msg.sender, _amount);\r\n    }\r\n\r\n    function _sendETH(address payable _address, uint256 _amount) internal {\r\n        (bool success, ) = payable(_address).call{value: _amount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        uint256 _balance = address(this).balance;\r\n\r\n        _sendETH(payable(msg.sender), _balance);\r\n    }\r\n\r\n    function partialWithdraw(uint256 _amount) public onlyOwner {\r\n        require(address(this).balance >= _amount, \"Insufficient balance!\");\r\n\r\n        _sendETH(payable(msg.sender), _amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"emergencyReveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_publicMintStartTime\",\"type\":\"uint256\"}],\"name\":\"flipPublicMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_whitelistMintStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_whitelistMintDuration\",\"type\":\"uint256\"}],\"name\":\"flipWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintsPerTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintsPerWhitelist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"multiSafeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"multiTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notRevealedUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ownerMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"ownerMintToMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"partialWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"publicMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicMintEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicMintStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"reveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxMintsPerTx\",\"type\":\"uint256\"}],\"name\":\"setMaxMintsPerTx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxMintsPerWhitelist\",\"type\":\"uint256\"}],\"name\":\"setMaxMintsPerWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"}],\"name\":\"setMaxSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintPrice\",\"type\":\"uint256\"}],\"name\":\"setMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_notRevealedURI\",\"type\":\"string\"}],\"name\":\"setNotRevealedURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"walletOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"whitelistMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistMintDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistMintEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistMintStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HYPEDUDES", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://65494d3d11f139c89f54fb83dfca0016ce0a4bfc79017cc566315bd3fbf1058d"}]}