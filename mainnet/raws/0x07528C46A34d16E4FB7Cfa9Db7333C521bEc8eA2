{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/verifier/StandardVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n// gas count: 299,341 (includes 21,000 tx base cost, includes cost of 3 pub inputs. Cost of circuit without pub inputs is 298,312)\\n\\nimport {IVerifier} from '../interfaces/IVerifier.sol';\\nimport {VerificationKey} from './keys/VerificationKey.sol';\\nimport {StandardTypes} from './cryptography/StandardTypes.sol';\\n\\n/**\\n * @title Standard Plonk proof verification contract\\n * @dev Top level Plonk proof verification contract, which allows Plonk proof to be verified\\n *\\n * Copyright 2022 Aztec\\n *\\n * Licensed under the GNU General Public License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n *\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n * GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n */\\ncontract StandardVerifier is IVerifier {\\n    // VERIFICATION KEY MEMORY LOCATIONS\\n    uint256 internal constant N_LOC =                                    0x200 + 0x00;\\n    uint256 internal constant NUM_INPUTS_LOC =                           0x200 + 0x20;\\n    uint256 internal constant OMEGA_LOC =                                0x200 + 0x40;\\n    uint256 internal constant DOMAIN_INVERSE_LOC =                       0x200 + 0x60;\\n    uint256 internal constant Q1_X_LOC =                                 0x200 + 0x80;\\n    uint256 internal constant Q1_Y_LOC =                                 0x200 + 0xa0;\\n    uint256 internal constant Q2_X_LOC =                                 0x200 + 0xc0;\\n    uint256 internal constant Q2_Y_LOC =                                 0x200 + 0xe0;\\n    uint256 internal constant Q3_X_LOC =                                 0x200 + 0x100;\\n    uint256 internal constant Q3_Y_LOC =                                 0x200 + 0x120;\\n    uint256 internal constant QM_X_LOC =                                 0x200 + 0x140;\\n    uint256 internal constant QM_Y_LOC =                                 0x200 + 0x160;\\n    uint256 internal constant QC_X_LOC =                                 0x200 + 0x180;\\n    uint256 internal constant QC_Y_LOC =                                 0x200 + 0x1a0;\\n    uint256 internal constant SIGMA1_X_LOC =                             0x200 + 0x1c0;\\n    uint256 internal constant SIGMA1_Y_LOC =                             0x200 + 0x1e0;\\n    uint256 internal constant SIGMA2_X_LOC =                             0x200 + 0x200;\\n    uint256 internal constant SIGMA2_Y_LOC =                             0x200 + 0x220;\\n    uint256 internal constant SIGMA3_X_LOC =                             0x200 + 0x240;\\n    uint256 internal constant SIGMA3_Y_LOC =                             0x200 + 0x260;\\n    uint256 internal constant CONTAINS_RECURSIVE_PROOF_LOC =             0x200 + 0x280;\\n    uint256 internal constant RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC = 0x200 + 0x2a0;\\n    uint256 internal constant G2X_X0_LOC =                               0x200 + 0x2c0;\\n    uint256 internal constant G2X_X1_LOC =                               0x200 + 0x2e0;\\n    uint256 internal constant G2X_Y0_LOC =                               0x200 + 0x300;\\n    uint256 internal constant G2X_Y1_LOC =                               0x200 + 0x320;\\n    // 26\\n\\n    // ### PROOF DATA MEMORY LOCATIONS\\n    uint256 internal constant W1_X_LOC =                                 0x200 + 0x340 + 0x00;\\n    uint256 internal constant W1_Y_LOC =                                 0x200 + 0x340 + 0x20;\\n    uint256 internal constant W2_X_LOC =                                 0x200 + 0x340 + 0x40;\\n    uint256 internal constant W2_Y_LOC =                                 0x200 + 0x340 + 0x60;\\n    uint256 internal constant W3_X_LOC =                                 0x200 + 0x340 + 0x80;\\n    uint256 internal constant W3_Y_LOC =                                 0x200 + 0x340 + 0xa0;\\n    uint256 internal constant Z_X_LOC =                                  0x200 + 0x340 + 0xc0;\\n    uint256 internal constant Z_Y_LOC =                                  0x200 + 0x340 + 0xe0;\\n    uint256 internal constant T1_X_LOC =                                 0x200 + 0x340 + 0x100;\\n    uint256 internal constant T1_Y_LOC =                                 0x200 + 0x340 + 0x120;\\n    uint256 internal constant T2_X_LOC =                                 0x200 + 0x340 + 0x140;\\n    uint256 internal constant T2_Y_LOC =                                 0x200 + 0x340 + 0x160;\\n    uint256 internal constant T3_X_LOC =                                 0x200 + 0x340 + 0x180;\\n    uint256 internal constant T3_Y_LOC =                                 0x200 + 0x340 + 0x1a0;\\n    uint256 internal constant W1_EVAL_LOC =                              0x200 + 0x340 + 0x1c0;\\n    uint256 internal constant W2_EVAL_LOC =                              0x200 + 0x340 + 0x1e0;\\n    uint256 internal constant W3_EVAL_LOC =                              0x200 + 0x340 + 0x200;\\n    uint256 internal constant SIGMA1_EVAL_LOC =                          0x200 + 0x340 + 0x220;\\n    uint256 internal constant SIGMA2_EVAL_LOC =                          0x200 + 0x340 + 0x240;\\n    uint256 internal constant Z_OMEGA_EVAL_LOC =                         0x200 + 0x340 + 0x260;\\n    uint256 internal constant PI_Z_X_LOC =                               0x200 + 0x340 + 0x280;\\n    uint256 internal constant PI_Z_Y_LOC =                               0x200 + 0x340 + 0x2a0;\\n    uint256 internal constant PI_Z_OMEGA_X_LOC =                         0x200 + 0x340 + 0x2c0;\\n    uint256 internal constant PI_Z_OMEGA_Y_LOC =                         0x200 + 0x340 + 0x2e0;\\n    // 25\\n\\n    // ### CHALLENGES MEMORY OFFSETS\\n    uint256 internal constant C_BETA_LOC =                               0x200 + 0x340 + 0x300 + 0x00;\\n    uint256 internal constant C_GAMMA_LOC =                              0x200 + 0x340 + 0x300 + 0x20;\\n    uint256 internal constant C_ALPHA_LOC =                              0x200 + 0x340 + 0x300 + 0x40;\\n    uint256 internal constant C_ARITHMETIC_ALPHA_LOC =                   0x200 + 0x340 + 0x300 + 0x60;\\n    uint256 internal constant C_ZETA_LOC =                               0x200 + 0x340 + 0x300 + 0x80;\\n    uint256 internal constant C_CURRENT_LOC =                            0x200 + 0x340 + 0x300 + 0xa0;\\n    uint256 internal constant C_V0_LOC =                                 0x200 + 0x340 + 0x300 + 0xc0;\\n    uint256 internal constant C_V1_LOC =                                 0x200 + 0x340 + 0x300 + 0xe0;\\n    uint256 internal constant C_V2_LOC =                                 0x200 + 0x340 + 0x300 + 0x100;\\n    uint256 internal constant C_V3_LOC =                                 0x200 + 0x340 + 0x300 + 0x120;\\n    uint256 internal constant C_V4_LOC =                                 0x200 + 0x340 + 0x300 + 0x140;\\n    uint256 internal constant C_V5_LOC =                                 0x200 + 0x340 + 0x300 + 0x160;\\n    uint256 internal constant C_U_LOC =                                  0x200 + 0x340 + 0x300 + 0x180;\\n    // 13\\n\\n    // ### LOCAL VARIABLES MEMORY OFFSETS\\n    uint256 internal constant DELTA_NUMERATOR_LOC =                      0x200 + 0x340 + 0x300 + 0x1a0 + 0x00;\\n    uint256 internal constant DELTA_DENOMINATOR_LOC =                    0x200 + 0x340 + 0x300 + 0x1a0 + 0x20;\\n    uint256 internal constant ZETA_POW_N_LOC =                           0x200 + 0x340 + 0x300 + 0x1a0 + 0x40;\\n    uint256 internal constant PUBLIC_INPUT_DELTA_LOC =                   0x200 + 0x340 + 0x300 + 0x1a0 + 0x60;\\n    uint256 internal constant ZERO_POLY_LOC =                            0x200 + 0x340 + 0x300 + 0x1a0 + 0x80;\\n    uint256 internal constant L_START_LOC =                              0x200 + 0x340 + 0x300 + 0x1a0 + 0xa0;\\n    uint256 internal constant L_END_LOC =                                0x200 + 0x340 + 0x300 + 0x1a0 + 0xc0;\\n    uint256 internal constant R_ZERO_EVAL_LOC =                          0x200 + 0x340 + 0x300 + 0x1a0 + 0xe0;\\n    uint256 internal constant ACCUMULATOR_X_LOC =                        0x200 + 0x340 + 0x300 + 0x1a0 + 0x100;\\n    uint256 internal constant ACCUMULATOR_Y_LOC =                        0x200 + 0x340 + 0x300 + 0x1a0 + 0x120;\\n    uint256 internal constant ACCUMULATOR2_X_LOC =                       0x200 + 0x340 + 0x300 + 0x1a0 + 0x140;\\n    uint256 internal constant ACCUMULATOR2_Y_LOC =                       0x200 + 0x340 + 0x300 + 0x1a0 + 0x160;\\n    uint256 internal constant PAIRING_LHS_X_LOC =                        0x200 + 0x340 + 0x300 + 0x1a0 + 0x180;\\n    uint256 internal constant PAIRING_LHS_Y_LOC =                        0x200 + 0x340 + 0x300 + 0x1a0 + 0x1a0;\\n    uint256 internal constant PAIRING_RHS_X_LOC =                        0x200 + 0x340 + 0x300 + 0x1a0 + 0x1c0;\\n    uint256 internal constant PAIRING_RHS_Y_LOC =                        0x200 + 0x340 + 0x300 + 0x1a0 + 0x1e0;\\n    // 21\\n\\n    // ### SUCCESS FLAG MEMORY LOCATIONS\\n    uint256 internal constant GRAND_PRODUCT_SUCCESS_FLAG =               0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0x00;\\n    uint256 internal constant ARITHMETIC_TERM_SUCCESS_FLAG =             0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0x20;\\n    uint256 internal constant BATCH_OPENING_SUCCESS_FLAG =               0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0x40;\\n    uint256 internal constant OPENING_COMMITMENT_SUCCESS_FLAG =          0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0x60;\\n    uint256 internal constant PAIRING_PREAMBLE_SUCCESS_FLAG =            0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0x80;\\n    uint256 internal constant PAIRING_SUCCESS_FLAG =                     0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xa0;\\n    uint256 internal constant RESULT_FLAG =                              0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xc0;\\n    // 7\\n\\n    // misc stuff\\n    uint256 internal constant OMEGA_INVERSE_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0;\\n    uint256 internal constant C_ALPHA_SQR_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0x20;\\n    // 3\\n\\n    // ### RECURSION VARIABLE MEMORY LOCATIONS\\n    uint256 internal constant RECURSIVE_P1_X_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0x40;\\n    uint256 internal constant RECURSIVE_P1_Y_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0x60;\\n    uint256 internal constant RECURSIVE_P2_X_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0x80;\\n    uint256 internal constant RECURSIVE_P2_Y_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0xa0;\\n\\n    uint256 internal constant PUBLIC_INPUTS_HASH_LOCATION = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0xc0;\\n\\n    error PUBLIC_INPUTS_HASH_VERIFICATION_FAILED(uint256, uint256);\\n    /**\\n     * @dev Verify a Plonk proof\\n     * @param - array of serialized proof data\\n     * @param - public input hash as computed from the broadcast data\\n     */\\n    function verify(bytes calldata, uint256 public_inputs_hash) external view override returns (bool) {\\n        // validate the correctness of the public inputs hash\\n        {\\n            bool hash_matches_input;\\n            uint256 recovered_hash;\\n            assembly {\\n                recovered_hash := calldataload(add(calldataload(0x04), 0x24))\\n                hash_matches_input := eq(recovered_hash, public_inputs_hash)\\n            }\\n            if (!hash_matches_input)\\n            {\\n                revert PUBLIC_INPUTS_HASH_VERIFICATION_FAILED(public_inputs_hash, recovered_hash);\\n            }\\n        }\\n\\n        StandardTypes.VerificationKey memory vk = VerificationKey.get_verification_key();\\n\\n        assembly {\\n            /**\\n             * LOAD VKEY\\n             * TODO REPLACE THIS WITH A CONTRACT CALL\\n             */\\n            {\\n                mstore(N_LOC, mload(vk))\\n                mstore(NUM_INPUTS_LOC, mload(add(vk, 0x20)))\\n                mstore(OMEGA_LOC,           mload(add(vk, 0x40)))\\n                mstore(DOMAIN_INVERSE_LOC,  mload(add(vk, 0x60)))\\n                mstore(OMEGA_INVERSE_LOC,   mload(add(vk, 0x80)))\\n                mstore(Q1_X_LOC,            mload(mload(add(vk, 0xa0))))\\n                mstore(Q1_Y_LOC,            mload(add(mload(add(vk, 0xa0)), 0x20)))\\n                mstore(Q2_X_LOC,            mload(mload(add(vk, 0xc0))))\\n                mstore(Q2_Y_LOC,            mload(add(mload(add(vk, 0xc0)), 0x20)))\\n                mstore(Q3_X_LOC,            mload(mload(add(vk, 0xe0))))\\n                mstore(Q3_Y_LOC,            mload(add(mload(add(vk, 0xe0)), 0x20)))\\n                mstore(QM_X_LOC,            mload(mload(add(vk, 0x100))))\\n                mstore(QM_Y_LOC,            mload(add(mload(add(vk, 0x100)), 0x20)))\\n                mstore(QC_X_LOC,            mload(mload(add(vk, 0x120))))\\n                mstore(QC_Y_LOC,            mload(add(mload(add(vk, 0x120)), 0x20)))\\n                mstore(SIGMA1_X_LOC,        mload(mload(add(vk, 0x140))))\\n                mstore(SIGMA1_Y_LOC,        mload(add(mload(add(vk, 0x140)), 0x20)))\\n                mstore(SIGMA2_X_LOC,        mload(mload(add(vk, 0x160))))\\n                mstore(SIGMA2_Y_LOC,        mload(add(mload(add(vk, 0x160)), 0x20)))\\n                mstore(SIGMA3_X_LOC,        mload(mload(add(vk, 0x180))))\\n                mstore(SIGMA3_Y_LOC,        mload(add(mload(add(vk, 0x180)), 0x20)))\\n                mstore(CONTAINS_RECURSIVE_PROOF_LOC, mload(add(vk, 0x1a0)))\\n                mstore(RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC, mload(add(vk, 0x1c0)))\\n                mstore(G2X_X0_LOC, 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1)\\n                mstore(G2X_X1_LOC, 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0)\\n                mstore(G2X_Y0_LOC, 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4)\\n                mstore(G2X_Y1_LOC, 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55)\\n            }\\n\\n            let q := 21888242871839275222246405745257275088696311157297823662689037894645226208583 // EC group order\\n            let p := 21888242871839275222246405745257275088548364400416034343698204186575808495617 // Prime field order\\n\\n\\n            /**\\n             * LOAD PROOF FROM CALLDATA\\n             */\\n            {\\n                let data_ptr := add(calldataload(0x04), 0x24)\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC)\\n                {\\n                    let index_counter := add(mul(mload(RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC), 32), data_ptr)\\n\\n                    let x0 := calldataload(index_counter)\\n                    x0 := add(x0, shl(68, calldataload(add(index_counter, 0x20))))\\n                    x0 := add(x0, shl(136, calldataload(add(index_counter, 0x40))))\\n                    x0 := add(x0, shl(204, calldataload(add(index_counter, 0x60))))\\n                    let y0 := calldataload(add(index_counter, 0x80))\\n                    y0 := add(y0, shl(68, calldataload(add(index_counter, 0xa0))))\\n                    y0 := add(y0, shl(136, calldataload(add(index_counter, 0xc0))))\\n                    y0 := add(y0, shl(204, calldataload(add(index_counter, 0xe0))))\\n                    let x1 := calldataload(add(index_counter, 0x100))\\n                    x1 := add(x1, shl(68, calldataload(add(index_counter, 0x120))))\\n                    x1 := add(x1, shl(136, calldataload(add(index_counter, 0x140))))\\n                    x1 := add(x1, shl(204, calldataload(add(index_counter, 0x160))))\\n                    let y1 := calldataload(add(index_counter, 0x180))\\n                    y1 := add(y1, shl(68, calldataload(add(index_counter, 0x1a0))))\\n                    y1 := add(y1, shl(136, calldataload(add(index_counter, 0x1c0))))\\n                    y1 := add(y1, shl(204, calldataload(add(index_counter, 0x1e0))))\\n                    mstore(RECURSIVE_P1_X_LOC, x0)\\n                    mstore(RECURSIVE_P1_Y_LOC, y0)\\n                    mstore(RECURSIVE_P2_X_LOC, x1)\\n                    mstore(RECURSIVE_P2_Y_LOC, y1)\\n\\n                    // validate these are valid bn128 G1 points\\n                    if iszero(and(\\n                        and(lt(x0, q), lt(x1, q)),\\n                        and(lt(y0, q), lt(y1, q))\\n                    )) {\\n                        revert(0x00, 0x00)\\n                    }\\n                }\\n\\n            let public_input_byte_length := mul(mload(NUM_INPUTS_LOC), 32)\\n            data_ptr := add(data_ptr, public_input_byte_length)\\n\\n\\n            mstore(W1_X_LOC, mod(calldataload(add(data_ptr, 0x20)), q))\\n            mstore(W1_Y_LOC, mod(calldataload(data_ptr), q))\\n            mstore(W2_X_LOC, mod(calldataload(add(data_ptr, 0x60)), q))\\n            mstore(W2_Y_LOC, mod(calldataload(add(data_ptr, 0x40)), q))\\n            mstore(W3_X_LOC, mod(calldataload(add(data_ptr, 0xa0)), q))\\n            mstore(W3_Y_LOC, mod(calldataload(add(data_ptr, 0x80)), q))\\n            mstore(Z_X_LOC, mod(calldataload(add(data_ptr, 0xe0)), q))\\n            mstore(Z_Y_LOC, mod(calldataload(add(data_ptr, 0xc0)), q))\\n            mstore(T1_X_LOC, mod(calldataload(add(data_ptr, 0x120)), q))\\n            mstore(T1_Y_LOC, mod(calldataload(add(data_ptr, 0x100)), q))\\n            mstore(T2_X_LOC, mod(calldataload(add(data_ptr, 0x160)), q))\\n            mstore(T2_Y_LOC, mod(calldataload(add(data_ptr, 0x140)), q))\\n            mstore(T3_X_LOC, mod(calldataload(add(data_ptr, 0x1a0)), q))\\n            mstore(T3_Y_LOC, mod(calldataload(add(data_ptr, 0x180)), q))\\n            mstore(W1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x1c0)), p))\\n            mstore(W2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x1e0)), p))\\n            mstore(W3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x200)), p))\\n            mstore(SIGMA1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x220)), p))\\n            mstore(SIGMA2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x240)), p))\\n            mstore(Z_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x260)), p))\\n            mstore(PI_Z_X_LOC, mod(calldataload(add(data_ptr, 0x2a0)), q))\\n            mstore(PI_Z_Y_LOC, mod(calldataload(add(data_ptr, 0x280)), q))\\n            mstore(PI_Z_OMEGA_X_LOC, mod(calldataload(add(data_ptr, 0x2e0)), q))\\n            mstore(PI_Z_OMEGA_Y_LOC, mod(calldataload(add(data_ptr, 0x2c0)), q))\\n            }\\n\\n            {\\n            /**\\n             * Generate initial challenge\\n             **/\\n\\n            mstore(0x00, shl(224, mload(N_LOC)))\\n            mstore(0x04, shl(224, mload(NUM_INPUTS_LOC)))\\n            let challenge := keccak256(0x00, 0x08)\\n\\n            /**\\n             * Generate beta, gamma challenges\\n             */\\n            mstore(PUBLIC_INPUTS_HASH_LOCATION, challenge)\\n            let inputs_start := add(calldataload(0x04), 0x24)\\n            let num_calldata_bytes := add(0xc0, mul(mload(NUM_INPUTS_LOC), 0x20))\\n            calldatacopy(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), inputs_start, num_calldata_bytes)\\n\\n            challenge := keccak256(PUBLIC_INPUTS_HASH_LOCATION, add(num_calldata_bytes, 0x20))\\n\\n            mstore(C_BETA_LOC, mod(challenge, p))\\n\\n            mstore(0x00, challenge)\\n            mstore8(0x20, 0x01)\\n            challenge := keccak256(0x00, 0x21)\\n            mstore(C_GAMMA_LOC, mod(challenge, p))\\n\\n            /**\\n             * Generate alpha challenge\\n             */\\n            mstore(0x00, challenge)\\n            mstore(0x20, mload(Z_Y_LOC))\\n            mstore(0x40, mload(Z_X_LOC))\\n            challenge := keccak256(0x00, 0x60)\\n            mstore(C_ALPHA_LOC, mod(challenge, p))\\n            /**\\n             * Generate zeta challenge\\n             */\\n            mstore(0x00, challenge)\\n            mstore(0x20, mload(T1_Y_LOC))\\n            mstore(0x40, mload(T1_X_LOC))\\n            mstore(0x60, mload(T2_Y_LOC))\\n            mstore(0x80, mload(T2_X_LOC))\\n            mstore(0xa0, mload(T3_Y_LOC))\\n            mstore(0xc0, mload(T3_X_LOC))\\n            challenge := keccak256(0x00, 0xe0)\\n\\n            mstore(C_ZETA_LOC, mod(challenge, p))\\n            mstore(C_CURRENT_LOC, challenge)\\n            }\\n\\n            /**\\n             * EVALUATE FIELD OPERATIONS\\n             */\\n\\n            /**\\n             * COMPUTE PUBLIC INPUT DELTA\\n             */\\n            {\\n                let gamma := mload(C_GAMMA_LOC)\\n                let work_root := mload(OMEGA_LOC)\\n                let endpoint := sub(mul(mload(NUM_INPUTS_LOC), 0x20), 0x20)\\n                let public_inputs\\n                let root_1 := mload(C_BETA_LOC)\\n                let root_2 := root_1\\n                let numerator_value := 1\\n                let denominator_value := 1\\n\\n                let p_clone := p // move p to the front of the stack\\n                let valid := true\\n\\n                root_1 := mulmod(root_1, 0x05, p_clone) // k1.beta\\n                root_2 := mulmod(root_2, 0x07, p_clone) // 0x05 + 0x07 = 0x0c = external coset generator\\n\\n                public_inputs := add(calldataload(0x04), 0x24)\\n                endpoint := add(endpoint, public_inputs)\\n\\n                for {} lt(public_inputs, endpoint) {}\\n                {\\n                    let input0 := calldataload(public_inputs)\\n                    let N0 := add(root_1, add(input0, gamma))\\n                    let D0 := add(root_2, N0) // 4x overloaded\\n\\n                    root_1 := mulmod(root_1, work_root, p_clone)\\n                    root_2 := mulmod(root_2, work_root, p_clone)\\n\\n                    let input1 := calldataload(add(public_inputs, 0x20))\\n                    let N1 := add(root_1, add(input1, gamma))\\n\\n                    denominator_value := mulmod(mulmod(D0, denominator_value, p_clone), add(N1, root_2), p_clone)\\n                    numerator_value := mulmod(mulmod(N1, N0, p_clone), numerator_value, p_clone)\\n\\n                    root_1 := mulmod(root_1, work_root, p_clone)\\n                    root_2 := mulmod(root_2, work_root, p_clone)\\n\\n                    valid := and(valid, and(lt(input0, p_clone), lt(input1, p_clone)))\\n                    public_inputs := add(public_inputs, 0x40)\\n\\n                    // validate public inputs are field elements (i.e. < p)\\n                    if iszero(and(lt(input0, p), lt(input1, p)))\\n                    {\\n                        revert(0x00, 0x00)\\n                    }\\n                }\\n\\n                endpoint := add(endpoint, 0x20)\\n                for {} lt(public_inputs, endpoint) { public_inputs := add(public_inputs, 0x20) }\\n                {\\n                    let input0 := calldataload(public_inputs)\\n\\n                    // validate public inputs are field elements (i.e. < p)\\n                    if iszero(lt(input0, p))\\n                    {\\n                        revert(0x00, 0x00)\\n                    }\\n        \\n                    valid := and(valid, lt(input0, p_clone))\\n                    let T0 := addmod(input0, gamma, p_clone)\\n                    numerator_value := mulmod(\\n                        numerator_value,\\n                        add(root_1, T0), // 0x05 = coset_generator0\\n                        p\\n                    )\\n                    denominator_value := mulmod(\\n                        denominator_value,\\n                        add(add(root_1, root_2), T0), // 0x0c = coset_generator7\\n                        p\\n                    )\\n                    root_1 := mulmod(root_1, work_root, p_clone)\\n                    root_2 := mulmod(root_2, work_root, p_clone)\\n                }\\n\\n                mstore(DELTA_NUMERATOR_LOC, numerator_value)\\n                mstore(DELTA_DENOMINATOR_LOC, denominator_value)\\n            }\\n\\n            /**\\n             * Compute lagrange poly and vanishing poly fractions\\n             */\\n            {\\n                let zeta := mload(C_ZETA_LOC)\\n\\n                // compute zeta^n, where n is a power of 2\\n                let vanishing_numerator := zeta\\n                {\\n                    // pow_small\\n                    let exponent := mload(N_LOC)\\n                    let count := 1\\n                    for {} lt(count, exponent) { count := add(count, count) }\\n                    {\\n                        vanishing_numerator := mulmod(vanishing_numerator, vanishing_numerator, p)\\n                    }\\n                }\\n                mstore(ZETA_POW_N_LOC, vanishing_numerator)\\n                vanishing_numerator := addmod(vanishing_numerator, sub(p, 1), p)\\n\\n                let accumulating_root := mload(OMEGA_INVERSE_LOC)\\n                let work_root := sub(p, accumulating_root)\\n                let domain_inverse := mload(DOMAIN_INVERSE_LOC)\\n\\n                let vanishing_denominator := addmod(zeta, work_root, p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, mulmod(work_root, accumulating_root, p), p), p)\\n\\n                work_root := mload(OMEGA_LOC)\\n\\n                let lagrange_numerator := mulmod(vanishing_numerator, domain_inverse, p)\\n                let l_start_denominator := addmod(zeta, sub(p, 1), p)\\n\\n                // l_end_denominator term contains a term \\\\omega^5 to cut out 5 roots of unity from vanishing poly\\n                accumulating_root := mulmod(work_root, work_root, p)\\n\\n                let l_end_denominator := addmod(\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(accumulating_root, accumulating_root, p),\\n                            work_root, p\\n                        ),\\n                        zeta, p\\n                    ),\\n                    sub(p, 1), p\\n                )\\n\\n            /**\\n             * Compute inversions using Montgomery's batch inversion trick\\n             */\\n                let accumulator := mload(DELTA_DENOMINATOR_LOC)\\n                let t0 := accumulator\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n                let t1 := accumulator\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n                let t2 := accumulator\\n                {\\n                    mstore(0, 0x20)\\n                    mstore(0x20, 0x20)\\n                    mstore(0x40, 0x20)\\n                    mstore(0x60, mulmod(accumulator, l_end_denominator, p))\\n                    mstore(0x80, sub(p, 2))\\n                    mstore(0xa0, p)\\n                    if iszero(staticcall(gas(), 0x05, 0x00, 0xc0, 0x00, 0x20))\\n                    {\\n                        mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                        mstore(0x04, 0x20)\\n                        mstore(0x24, 32)\\n                        mstore(0x44, \\\"PROOF_VERIFICATION_FAILED_TYPE_1\\\")\\n                        revert(0x00, 0x64)\\n                    }\\n                    accumulator := mload(0x00)\\n                }\\n\\n                t2 := mulmod(accumulator, t2, p)\\n                accumulator := mulmod(accumulator, l_end_denominator, p)\\n\\n                t1 := mulmod(accumulator, t1, p)\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n\\n                t0 := mulmod(accumulator, t0, p)\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n\\n                accumulator := mulmod(mulmod(accumulator, accumulator, p), mload(DELTA_DENOMINATOR_LOC), p)\\n\\n                mstore(PUBLIC_INPUT_DELTA_LOC, mulmod(mload(DELTA_NUMERATOR_LOC), accumulator, p))\\n                mstore(ZERO_POLY_LOC, mulmod(vanishing_numerator, t0, p))\\n                mstore(L_START_LOC, mulmod(lagrange_numerator, t1, p))\\n                mstore(L_END_LOC, mulmod(lagrange_numerator, t2, p))\\n            }\\n\\n            /**\\n             * COMPUTE CONSTANT TERM (r_0) OF LINEARISATION POLYNOMIAL\\n             */\\n            {\\n                let alpha := mload(C_ALPHA_LOC)\\n                let beta := mload(C_BETA_LOC)\\n                let gamma := mload(C_GAMMA_LOC)\\n                let r_0 := sub(p,\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(\\n                                add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA1_EVAL_LOC), p)),\\n                                add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA2_EVAL_LOC), p)),\\n                                p\\n                            ),\\n                            add(mload(W3_EVAL_LOC), gamma),\\n                            p\\n                        ),\\n                        mload(Z_OMEGA_EVAL_LOC),\\n                        p\\n                    )\\n                )\\n                // r_0 = -(\u0101 + \u03b2s\u0304_\u03c31 + \u03b3)( b\u0304 + \u03b2s\u0304_\u03c32 + \u03b3)(c\u0304 + \u03b3)z\u0304_\u03c9\\n                let alpha_sqr := mulmod(alpha, alpha, p)\\n                mstore(C_ALPHA_SQR_LOC, alpha_sqr)\\n                mstore(C_ARITHMETIC_ALPHA_LOC, mulmod(alpha_sqr, alpha_sqr, p))\\n\\n                mstore(R_ZERO_EVAL_LOC,\\n                            mulmod(\\n                                addmod(\\n                                    addmod(r_0, sub(p, mulmod(mload(L_START_LOC), alpha_sqr, p)), p),\\n                                    mulmod(\\n                                        mulmod(mload(L_END_LOC), alpha, p),\\n                                        addmod(mload(Z_OMEGA_EVAL_LOC), sub(p, mload(PUBLIC_INPUT_DELTA_LOC)), p), p\\n                                    ), p\\n                                ),\\n                                alpha, p\\n                            )\\n                        )\\n            }\\n\\n\\n            /**\\n             * GENERATE NU AND SEPARATOR CHALLENGES\\n             */\\n            {\\n                let current_challenge := mload(C_CURRENT_LOC)\\n                // get a calldata pointer that points to the start of the data we want to copy\\n                let calldata_ptr := add(calldataload(0x04), 0x24)\\n                // skip over the public inputs\\n                calldata_ptr := add(calldata_ptr, mul(mload(NUM_INPUTS_LOC), 0x20))\\n                // There are SEVEN G1 group elements added into the transcript in the `beta` round, that we need to skip over\\n                // W1, W2, W3 (W4), Z, T1, T2, T3, (T4)\\n                calldata_ptr := add(calldata_ptr, 0x1c0) // 7 * 0x40 = 0x1c0\\n\\n                mstore(0x00, current_challenge)\\n                calldatacopy(0x20, calldata_ptr, 0xc0) // 6 * 0x20 = 0xc0\\n                let challenge := keccak256(0x00, 0xe0) // hash length = 0xe0 (0x20 + num field elements), we include the previous challenge in the hash\\n\\n                mstore(C_V0_LOC, mod(challenge, p))\\n\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                mstore(C_V1_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                mstore8(0x20, 0x02)\\n                mstore(C_V2_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                mstore8(0x20, 0x03)\\n                mstore(C_V3_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                mstore8(0x20, 0x04)\\n                mstore(C_V4_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                mstore8(0x20, 0x05)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_V5_LOC, mod(challenge, p))\\n\\n                // separator\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, mload(PI_Z_OMEGA_X_LOC))\\n\\n                mstore(C_U_LOC, mod(keccak256(0x00, 0xa0), p))\\n            }\\n\\n            // mstore(C_ALPHA_BASE_LOC, mload(C_ALPHA_LOC))\\n\\n            /**\\n             * COMPUTE LINEARISED OPENING TERMS\\n             */\\n            {\\n                // /**\\n                //  * COMPUTE GRAND PRODUCT OPENING GROUP ELEMENT\\n                //  */\\n                let beta := mload(C_BETA_LOC)\\n                let zeta := mload(C_ZETA_LOC)\\n                let gamma := mload(C_GAMMA_LOC)\\n                let alpha := mload(C_ALPHA_LOC)\\n                let beta_zeta := mulmod(beta, zeta, p)\\n\\n                let witness_term := addmod(mload(W1_EVAL_LOC), gamma, p)\\n                let partial_grand_product := addmod(beta_zeta, witness_term, p)\\n                let sigma_multiplier := addmod(mulmod(mload(SIGMA1_EVAL_LOC), beta, p), witness_term, p)\\n                witness_term := addmod(mload(W2_EVAL_LOC), gamma, p)\\n                sigma_multiplier := mulmod(sigma_multiplier, addmod(mulmod(mload(SIGMA2_EVAL_LOC), beta, p), witness_term, p), p)\\n                let k1_beta_zeta := mulmod(0x05, beta_zeta, p)\\n                //  partial_grand_product = mulmod( mulmod( partial_grand_product, w2 + k1.beta.zeta + gamma , p), k2.beta.zeta + gamma + w3, p)\\n                partial_grand_product := mulmod(\\n                    mulmod(\\n                        partial_grand_product,\\n                        addmod(k1_beta_zeta, witness_term, p), // w2 + k1.beta.zeta + gamma\\n                        p\\n                    ),\\n                    addmod(addmod(add(k1_beta_zeta, beta_zeta), gamma, p), mload(W3_EVAL_LOC), p), // k2.beta.zeta + gamma + w3 where k2 = k1+1\\n                    p\\n                )\\n\\n\\n                let linear_challenge := alpha // Owing to the simplified Plonk, nu =1, linear_challenge = nu * alpha = alpha\\n\\n\\n                mstore(0x00, mload(SIGMA3_X_LOC))\\n                mstore(0x20, mload(SIGMA3_Y_LOC))\\n                mstore(0x40, mulmod(\\n                    mulmod(\\n                        sub(p, mulmod(sigma_multiplier, mload(Z_OMEGA_EVAL_LOC), p)),\\n                        beta,\\n                        p\\n                    ),\\n                    linear_challenge,\\n                    p\\n                ))\\n\\n                // Validate Z\\n                let success\\n                {\\n                    let x := mload(Z_X_LOC)\\n                    let y := mload(Z_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                    mstore(0x60, x)\\n                    mstore(0x80, y)\\n                }\\n                mstore(0xa0, addmod(\\n                    mulmod(\\n                        addmod(partial_grand_product, mulmod(mload(L_START_LOC), mload(C_ALPHA_SQR_LOC), p), p),\\n                        linear_challenge,\\n                        p),\\n                    mload(C_U_LOC),\\n                    p\\n                ))\\n            // 0x00 = SIGMA3_X_LOC,\\n            // 0x20 = SIGMA3_Y_LOC,\\n            // 0x40 = \u2212(\u0101 + \u03b2s\u0304_\u03c31 + \u03b3)( b\u0304 + \u03b2s\u0304_\u03c32 + \u03b3)\u03b1\u03b2z\u0304_\u03c9,\\n            // 0x60 = Z_X_LOC,\\n            // 0x80 = Z_Y_LOC,\\n            // 0xa0 = (\u0101 + \u03b2z + \u03b3)( b\u0304 + \u03b2k_1 z + \u03b3)(c\u0304 + \u03b2k_2 z + \u03b3)\u03b1 + L_1(z)\u03b1^3 + u\\n                success := and(success, and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    // Why ACCUMULATOR_X_LOC := ACCUMULATOR_X_LOC + ACCUMULATOR2_X_LOC? Inner parenthesis is executed before?\\n                    and(\\n                        staticcall(gas(), 7, 0x60, 0x60, ACCUMULATOR_X_LOC, 0x40),\\n                        // [ACCUMULATOR_X_LOC, ACCUMULATOR_X_LOC + 0x40) = ((\u0101 + \u03b2z + \u03b3)( b\u0304 + \u03b2k_1 z + \u03b3)(c\u0304 + \u03b2k_2 z + \u03b3)\u03b1 + L_1(z)\u03b1^3 + u)*[z]_1\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                        // [ACCUMULATOR2_X_LOC, ACCUMULATOR2_X_LOC + 0x40) = \u2212(\u0101 + \u03b2s\u0304_\u03c31 + \u03b3)( b\u0304 + \u03b2s\u0304_\u03c32 + \u03b3)\u03b1\u03b2z\u0304_\u03c9 * [s_\u03c33]_1\\n                    )\\n                ))\\n\\n                mstore(GRAND_PRODUCT_SUCCESS_FLAG, success)\\n\\n            }\\n\\n            /**\\n             * COMPUTE ARITHMETIC SELECTOR OPENING GROUP ELEMENT\\n             */\\n            {\\n                let linear_challenge := mload(C_ARITHMETIC_ALPHA_LOC) // Owing to simplified Plonk, nu = 1,  linear_challenge = C_ARITHMETIC_ALPHA (= alpha^4)\\n\\n                let t1 := mulmod(mload(W1_EVAL_LOC), linear_challenge, p) // reuse this for QM scalar multiplier\\n                // Q1\\n                mstore(0x00, mload(Q1_X_LOC))\\n                mstore(0x20, mload(Q1_Y_LOC))\\n                mstore(0x40, t1)\\n\\n                // add Q1 scalar mul into grand product scalar mul\\n                // Observe that ACCUMULATOR_X_LOC and ACCUMULATOR2_X_LOC are 0x40 bytes apart. Below, ACCUMULATOR2_X_LOC\\n                // captures new terms Q1, Q2, and so on and they get accumulated to ACCUMULATOR_X_LOC\\n                let success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    // [ACCUMULATOR_X_LOC, ACCUMULATOR_X_LOC + 0x40) = ((\u0101 + \u03b2z + \u03b3)( b\u0304 + \u03b2k_1 z + \u03b3)(c\u0304 + \u03b2k_2 z + \u03b3)\u03b1 + L_1(z)\u03b1^3 + u)*[z]_1 \u2212(\u0101 + \u03b2s\u0304_\u03c31 + \u03b3)( b\u0304 + \u03b2s\u0304_\u03c32 + \u03b3)\u03b1\u03b2z\u0304_\u03c9 * [s_\u03c33]_1\\n                    staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    // [ACCUMULATOR2_X_LOC, ACCUMULATOR2_X_LOC + 0x40) = \u0101 * [q_L]_1\\n                )\\n\\n                // Q2\\n                mstore(0x00, mload(Q2_X_LOC))\\n                mstore(0x20, mload(Q2_Y_LOC))\\n                mstore(0x40, mulmod(mload(W2_EVAL_LOC), linear_challenge, p))\\n                success := and(\\n                    success,\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                // Q3\\n                mstore(0x00, mload(Q3_X_LOC))\\n                mstore(0x20, mload(Q3_Y_LOC))\\n                mstore(0x40, mulmod(mload(W3_EVAL_LOC), linear_challenge, p))\\n                success := and(\\n                    success,\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                // QM\\n                mstore(0x00, mload(QM_X_LOC))\\n                mstore(0x20, mload(QM_Y_LOC))\\n                mstore(0x40, mulmod(t1, mload(W2_EVAL_LOC), p))\\n                success := and(\\n                    success,\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                // QC\\n                mstore(0x00, mload(QC_X_LOC))\\n                mstore(0x20, mload(QC_Y_LOC))\\n                mstore(0x40, linear_challenge)\\n                success := and(\\n                    success,\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                mstore(ARITHMETIC_TERM_SUCCESS_FLAG, success)\\n            }\\n\\n             /**\\n             * COMPUTE BATCH OPENING COMMITMENT\\n             */\\n            {\\n                // previous scalar_multiplier = 1, z^n, z^2n\\n                // scalar_multiplier owing to the simplified Plonk = 1 * -Z_H(z), z^n * -Z_H(z), z^2n * -Z_H(z)\\n                // VALIDATE T1\\n                let success\\n                {\\n                    let x := mload(T1_X_LOC)\\n                    let y := mload(T1_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                    mstore(0x40, sub(p, mload(ZERO_POLY_LOC)))\\n                    // mstore(ACCUMULATOR2_X_LOC, x)\\n                    // mstore(ACCUMULATOR2_Y_LOC, y)\\n                }\\n                success := and(success,\\n                and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                ))\\n\\n                // VALIDATE T2\\n                let scalar_multiplier := mload(ZETA_POW_N_LOC)\\n                {\\n                    let x := mload(T2_X_LOC)\\n                    let y := mload(T2_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mulmod(scalar_multiplier, sub(p, mload(ZERO_POLY_LOC)), p))\\n\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                // VALIDATE T3\\n                {\\n                    let x := mload(T3_X_LOC)\\n                    let y := mload(T3_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mulmod(scalar_multiplier, mulmod(scalar_multiplier, sub(p, mload(ZERO_POLY_LOC)), p), p))\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                // VALIDATE W1\\n                {\\n                    let x := mload(W1_X_LOC)\\n                    let y := mload(W1_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mload(C_V0_LOC))\\n\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                // VALIDATE W2\\n                {\\n                    let x := mload(W2_X_LOC)\\n                    let y := mload(W2_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mload(C_V1_LOC))\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                // VALIDATE W3\\n                {\\n                    let x := mload(W3_X_LOC)\\n                    let y := mload(W3_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mload(C_V2_LOC))\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                mstore(0x00, mload(SIGMA1_X_LOC))\\n                mstore(0x20, mload(SIGMA1_Y_LOC))\\n                mstore(0x40, mload(C_V3_LOC))\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                mstore(0x00, mload(SIGMA2_X_LOC))\\n                mstore(0x20, mload(SIGMA2_Y_LOC))\\n                mstore(0x40, mload(C_V4_LOC))\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                mstore(BATCH_OPENING_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * COMPUTE BATCH EVALUATION SCALAR MULTIPLIER\\n             */\\n            {\\n                mstore(0x00, 0x01) // [1].x\\n                mstore(0x20, 0x02) // [1].y\\n                // Yul stack optimizer doing some work here...\\n                mstore(0x40, sub(p,\\n                    addmod(\\n                        mulmod(mload(C_U_LOC), mload(Z_OMEGA_EVAL_LOC), p),\\n                        addmod(\\n                            sub(p, mload(R_ZERO_EVAL_LOC)), // Change owing to the simplified Plonk\\n                                addmod(\\n                                    mulmod(mload(C_V4_LOC), mload(SIGMA2_EVAL_LOC), p),\\n                                    addmod(\\n                                        mulmod(mload(C_V3_LOC), mload(SIGMA1_EVAL_LOC), p),\\n                                        addmod(\\n                                            mulmod(mload(C_V2_LOC), mload(W3_EVAL_LOC), p),\\n                                            addmod(\\n                                                mulmod(mload(C_V1_LOC), mload(W2_EVAL_LOC), p),\\n                                                mulmod(mload(C_V0_LOC), mload(W1_EVAL_LOC), p),\\n                                                p\\n                                            ),\\n                                            p\\n                                        ),\\n                                        p\\n                                    ),\\n                                    p\\n                                ),\\n                                p\\n                            ),\\n                            p\\n                        )\\n                    )\\n                )\\n\\n                let success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                )\\n                mstore(OPENING_COMMITMENT_SUCCESS_FLAG, success)\\n            }\\n\\n             /**\\n             * PERFORM PAIRING PREAMBLE\\n             */\\n            {\\n                let u := mload(C_U_LOC)\\n                let zeta := mload(C_ZETA_LOC)\\n                let success\\n                // VALIDATE PI_Z\\n                {\\n                    let x := mload(PI_Z_X_LOC)\\n                    let y := mload(PI_Z_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                // compute zeta.[PI_Z] and add into accumulator\\n                mstore(0x40, zeta)\\n                success := and(success, and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                ))\\n\\n                // VALIDATE PI_Z_OMEGA\\n                {\\n                    let x := mload(PI_Z_OMEGA_X_LOC)\\n                    let y := mload(PI_Z_OMEGA_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                // compute u.zeta.omega.[PI_Z_OMEGA] and add into accumulator\\n                mstore(0x40, mulmod(mulmod(u, zeta, p), mload(OMEGA_LOC), p))\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, PAIRING_RHS_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                mstore(0x00, mload(PI_Z_X_LOC))\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_OMEGA_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, u)\\n                success := and(\\n                    staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x40, 0x60, 0x40, 0x40)\\n                    )\\n                )\\n                // negate lhs y-coordinate\\n                mstore(PAIRING_LHS_Y_LOC, sub(q, mload(PAIRING_LHS_Y_LOC)))\\n\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC)\\n                {\\n                    // VALIDATE RECURSIVE P1\\n                    {\\n                        let x := mload(RECURSIVE_P1_X_LOC)\\n                        let y := mload(RECURSIVE_P1_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n\\n                    // compute u.u.[recursive_p1] and write into 0x60\\n                    mstore(0x40, mulmod(u, u, p))\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x60, 0x40))\\n                    // VALIDATE RECURSIVE P2\\n                    {\\n                        let x := mload(RECURSIVE_P2_X_LOC)\\n                        let y := mload(RECURSIVE_P2_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n                    // compute u.u.[recursive_p2] and write into 0x00\\n                    // 0x40 still contains u*u\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x00, 0x40))\\n\\n                    // compute u.u.[recursiveP1] + rhs and write into rhs\\n                    mstore(0xa0, mload(PAIRING_RHS_X_LOC))\\n                    mstore(0xc0, mload(PAIRING_RHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x60, 0x80, PAIRING_RHS_X_LOC, 0x40))\\n\\n                    // compute u.u.[recursiveP2] + lhs and write into lhs\\n                    mstore(0x40, mload(PAIRING_LHS_X_LOC))\\n                    mstore(0x60, mload(PAIRING_LHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\\n                }\\n\\n                if iszero(success)\\n                {\\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                    mstore(0x04, 0x20)\\n                    mstore(0x24, 32)\\n                    mstore(0x44, \\\"PROOF_VERIFICATION_FAILED_TYPE_2\\\")\\n                    revert(0x00, 0x64)\\n                }\\n                mstore(PAIRING_PREAMBLE_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * PERFORM PAIRING\\n             */\\n            {\\n                // rhs paired with [1]_2\\n                // lhs paired with [x]_2\\n\\n                mstore(0x00, mload(PAIRING_RHS_X_LOC))\\n                mstore(0x20, mload(PAIRING_RHS_Y_LOC))\\n                mstore(0x40, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2) // this is [1]_2\\n                mstore(0x60, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\\n                mstore(0x80, 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\\n                mstore(0xa0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\\n\\n                mstore(0xc0, mload(PAIRING_LHS_X_LOC))\\n                mstore(0xe0, mload(PAIRING_LHS_Y_LOC))\\n                mstore(0x100, mload(G2X_X0_LOC))\\n                mstore(0x120, mload(G2X_X1_LOC))\\n                mstore(0x140, mload(G2X_Y0_LOC))\\n                mstore(0x160, mload(G2X_Y1_LOC))\\n\\n                let success := staticcall(\\n                    gas(),\\n                    8,\\n                    0x00,\\n                    0x180,\\n                    0x00,\\n                    0x20\\n                )\\n                mstore(PAIRING_SUCCESS_FLAG, success)\\n                mstore(RESULT_FLAG, mload(0x00))\\n            }\\n            if iszero(and(\\n                and(\\n                    and(\\n                        and(\\n                            and(\\n                                and(\\n                                    mload(PAIRING_SUCCESS_FLAG),\\n                                    mload(RESULT_FLAG)\\n                                ),\\n                                mload(PAIRING_PREAMBLE_SUCCESS_FLAG)\\n                            ),\\n                            mload(OPENING_COMMITMENT_SUCCESS_FLAG)\\n                        ),\\n                        mload(BATCH_OPENING_SUCCESS_FLAG)\\n                    ),\\n                    mload(ARITHMETIC_TERM_SUCCESS_FLAG)\\n                ),\\n                mload(GRAND_PRODUCT_SUCCESS_FLAG)\\n            ))\\n            {\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x04, 0x20)\\n                mstore(0x24, 32)\\n                mstore(0x44, \\\"PROOF_VERIFICATION_FAILED_TYPE_3\\\")\\n                revert(0x00, 0x64)\\n            }\\n            {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20) // Proof succeeded!\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\ninterface IVerifier {\\n    function verify(bytes memory serialized_proof, uint256 _publicInputsHash) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/VerificationKey.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {StandardTypes} from '../cryptography/StandardTypes.sol';\\n\\n// Placeholder VK\\nlibrary VerificationKey {\\n    function get_verification_key() external pure returns (StandardTypes.VerificationKey memory) {\\n        StandardTypes.VerificationKey memory vk;\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/cryptography/StandardTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\n/**\\n * @title Bn254Crypto library used for the fr, g1 and g2 point types\\n * @dev Used to manipulate fr, g1, g2 types, perform modular arithmetic on them and call\\n * the precompiles add, scalar mul and pairing\\n *\\n * Notes on optimisations\\n * 1) Perform addmod, mulmod etc. in assembly - removes the check that Solidity performs to confirm that\\n * the supplied modulus is not 0. This is safe as the modulus's used (r_mod, q_mod) are hard coded\\n * inside the contract and not supplied by the user\\n */\\nlibrary StandardTypes {\\n    uint256 internal constant PROGRAM_WIDTH = 3;\\n    uint256 internal constant NUM_NU_CHALLENGES = 6;\\n\\n    uint256 internal constant coset_generator0 = 0x0000000000000000000000000000000000000000000000000000000000000005;\\n    uint256 internal constant coset_generator1 = 0x0000000000000000000000000000000000000000000000000000000000000006;\\n    uint256 internal constant coset_generator2 = 0x0000000000000000000000000000000000000000000000000000000000000007;\\n\\n    // TODO: add external_coset_generator() method to compute this\\n    uint256 internal constant coset_generator7 = 0x000000000000000000000000000000000000000000000000000000000000000c;\\n\\n    struct G1Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    // G2 group element where x \\\\in Fq2 = x0 * z + x1\\n    struct G2Point {\\n        uint256 x0;\\n        uint256 x1;\\n        uint256 y0;\\n        uint256 y1;\\n    }\\n\\n    // N>B. Do not re-order these fields! They must appear in the same order as they\\n    // appear in the proof data\\n    struct Proof {\\n        G1Point W1;\\n        G1Point W2;\\n        G1Point W3;\\n        G1Point Z;\\n        G1Point T1;\\n        G1Point T2;\\n        G1Point T3;\\n        uint256 w1;\\n        uint256 w2;\\n        uint256 w3;\\n        uint256 sigma1;\\n        uint256 sigma2;\\n        //    uint256 linearization_polynomial;\\n        uint256 grand_product_at_z_omega;\\n        G1Point PI_Z;\\n        G1Point PI_Z_OMEGA;\\n        G1Point recursive_P1;\\n        G1Point recursive_P2;\\n        uint256 r_0; // Changes owing to the simplified Plonk\\n    }\\n\\n    struct ChallengeTranscript {\\n        uint256 alpha_base;\\n        uint256 alpha;\\n        uint256 zeta;\\n        uint256 beta;\\n        uint256 gamma;\\n        uint256 u;\\n        uint256 v0;\\n        uint256 v1;\\n        uint256 v2;\\n        uint256 v3;\\n        uint256 v4;\\n        uint256 v5;\\n        uint256 v6;\\n        // uint256 v7;\\n    }\\n\\n    struct VerificationKey {\\n        uint256 circuit_size;\\n        uint256 num_inputs;\\n        uint256 work_root;\\n        uint256 domain_inverse;\\n        uint256 work_root_inverse;\\n        G1Point Q1;\\n        G1Point Q2;\\n        G1Point Q3;\\n        G1Point QM;\\n        G1Point QC;\\n        G1Point SIGMA1;\\n        G1Point SIGMA2;\\n        G1Point SIGMA3;\\n        bool contains_recursive_proof;\\n        uint256 recursive_proof_indices;\\n        G2Point g2_x;\\n        // zeta challenge raised to the power of the circuit size.\\n        // Not actually part of the verification key, but we put it here to prevent stack depth errors\\n        uint256 zeta_pow_n;\\n    }\\n}\\n\\n/**\\n\\n    ### MEMORY LAYOUT\\n\\n    0x00 - 0x200 RESERVED FOR SCRATCH SPACE\\n\\n    0x200 - 0x600 RESERVED FOR VERIFICATION KEY\\n\\n    0x600 - 0x900 RESERVED FOR LOCAL VARIABLES\\n\\n    ### VERIFICATION KEY ###\\n    ### ALL LOCALTIONS ARE RELATIVE TO THE START OF THIS BLOCK IN MEMORY (0x200)\\n\\n    0x00          : n\\n    0x20          : num_inputs\\n    0x40          : omega\\n    0x60          : n^{-1}\\n    0x80          : omega^{-1}\\n    0xa0 - 0xe0   : Q1\\n    0xe0 - 0x120  : Q2\\n    0x120 - 0x160 : Q3\\n    0x160 - 0x1a0 : QM\\n    0x1a0 - 0x1e0 : QC\\n    0x1e0 - 0x220 : SIGMA1\\n    0x220 - 0x260 : SIGMA2\\n    0x260 - 0x2a0 : SIGMA3\\n    0x2a0 - 0x2c0 : contains_recursive_proof\\n    0x2c0 - 0x340 : G2_x ([x]_2)\\n\\n    ### LOCAL VARIABLES ###\\n    ### ALL LOCALTIONS ARE RELATIVE TO THE START OF THIS BLOCK IN MEMORY (0x200)\\n\\n    0x00  : zeta_pow_n\\n    0x20  : quotient_poly_eval\\n    0x40  : public_input_delta_numerator\\n    0x60  : public_input_delta_denominator\\n    0x80  : vanishing_numerator\\n    0xa0  : vanishing_denominator\\n    0xc0  : lagrange_numerator\\n    0xe0  : l_start_denominator\\n    0x100 : l_end_denominator\\n    0x120 : zero_poly_eval\\n    0x140 : public_input_delta\\n    0x160 : l_start\\n    0x180 : l_end\\n    0x200 : p\\n    0x220 : proof_calldata_ptr\\n\\n    ### PROOF ###\\n\\n    0x00  - 0x40  : W1\\n    0x40  - 0x80  : W2\\n    0x80  - 0xc0  : W3\\n    0xc0  - 0x100 : Z\\n    0x100 - 0x140 : T1\\n    0x140 - 0x180 : T2\\n    0x180 - 0x1c0 : T3\\n    0x1c0 - 0x200 : w1\\n    0x200 - 0x220 : w2\\n    0x220 - 0x240 : w3\\n    0x240 - 0x260 : sigma1\\n    0x260 - 0x280 : sigma2\\n    0x280 - 0x2a0 : r\\n    0x2a0 - 0x2c0 : z_omega\\n    0x2c0 - 0x300 : PI_Z\\n    0x300 - 0x340 : PI_Z_OMEGA\\n    0x340 - 0x380 : RECURSIVE_P1\\n    0x380 - 0x3c0 : RECURSIVE_P2\\n */\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/verifier/keys/VerificationKey.sol\": {\r\n        \"VerificationKey\": \"0x8c3b53f450e53ff14d8c9449465f79ff40668966\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PUBLIC_INPUTS_HASH_VERIFICATION_FAILED\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"public_inputs_hash\",\"type\":\"uint256\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StandardVerifier", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}