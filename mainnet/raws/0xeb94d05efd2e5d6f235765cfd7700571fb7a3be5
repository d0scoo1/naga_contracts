{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// Created by petdomaa100\r\n\r\npragma solidity 0.8.11;\r\n\r\n\r\nlibrary Address {\r\n\tfunction isContract(address _address) internal view returns(bool) {\r\n\t\treturn _address.code.length > 0;\r\n\t}\r\n}\r\n\r\nlibrary Strings {\r\n\tfunction toString(uint256 value) internal pure returns(string memory) {\r\n\t\tif (value == 0) return \"0\";\r\n\r\n\t\tuint256 temp = value;\r\n\t\tuint256 digits;\r\n\r\n\t\twhile (temp != 0) {\r\n\t\t\tdigits++;\r\n\t\t\ttemp /= 10;\r\n\t\t}\r\n\r\n\t\tbytes memory buffer = new bytes(digits);\r\n\r\n\t\twhile (value != 0) {\r\n\t\t\tdigits -= 1;\r\n\t\t\tbuffer[digits] = bytes1( uint8( 48 + uint256(value % 10) ) );\r\n\t\t\tvalue /= 10;\r\n\t\t}\r\n\r\n\t\treturn string(buffer);\r\n\t}\r\n}\r\n\r\n\r\ninterface IERC165 {\r\n\tfunction supportsInterface(bytes4 interfaceID) external view returns(bool);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenID);\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenID);\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n\tfunction balanceOf(address owner) external view returns(uint256 balance);\r\n\r\n\tfunction ownerOf(uint256 tokenID) external view returns(address owner);\r\n\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenID) external;\r\n\r\n\tfunction transferFrom(address from, address to, uint256 tokenID) external;\r\n\r\n\tfunction approve(address to, uint256 tokenID) external;\r\n\r\n\tfunction getApproved(uint256 tokenID) external view returns(address operator);\r\n\r\n\tfunction setApprovalForAll(address operator, bool _approved) external;\r\n\r\n\tfunction isApprovedForAll(address owner, address operator) external view returns(bool);\r\n\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenID, bytes calldata data) external;\r\n}\r\n\r\ninterface IERC721Receiver {\r\n\tfunction onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns(bytes4);\r\n}\r\n\r\ninterface IERC721Metadata is IERC721 {\r\n\tfunction name() external view returns(string memory);\r\n\r\n\tfunction symbol() external view returns(string memory);\r\n\r\n\tfunction tokenURI(uint256 tokenID) external view returns(string memory);\r\n}\r\n\r\ninterface IERC721Enumerable is IERC721 {\r\n\tfunction totalSupply() external view returns(uint256);\r\n\r\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) external view returns(uint256 tokenId);\r\n\r\n\tfunction tokenByIndex(uint256 index) external view returns(uint256);\r\n}\r\n\r\n\r\nabstract contract Ownable {\r\n\taddress private _owner;\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\r\n\tconstructor() {\r\n\t\t_transferOwnership(msg.sender);\r\n\t}\r\n\r\n\r\n\tfunction owner() public view virtual returns (address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\r\n\t\t_transferOwnership(newOwner);\r\n\t}\r\n\r\n\tfunction _transferOwnership(address newOwner) internal virtual {\r\n\t\taddress oldOwner = _owner;\r\n\r\n\t\t_owner = newOwner;\r\n\r\n\t\temit OwnershipTransferred(oldOwner, newOwner);\r\n\t}\r\n}\r\n\r\n\r\nabstract contract ERC165 is IERC165 {\r\n\tfunction supportsInterface(bytes4 interfaceID) public view virtual override returns(bool) {\r\n\t\treturn interfaceID == type(IERC165).interfaceId;\r\n\t}\r\n}\r\n\r\nabstract contract ERC721 is ERC165, IERC721, IERC721Metadata {\r\n\tusing Address for address;\r\n\tusing Strings for uint256;\r\n\r\n\tstring private _name;\r\n\tstring private _symbol;\r\n\r\n\tmapping(uint256 => address) private _owners;\r\n\tmapping(address => uint256) private _balances;\r\n\tmapping(uint256 => address) private _tokenApprovals;\r\n\r\n\tmapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n\r\n\tconstructor(string memory name_, string memory symbol_) {\r\n\t\t_name = name_;\r\n\t\t_symbol = symbol_;\r\n\t}\r\n\r\n\r\n\tfunction supportsInterface(bytes4 interfaceID) public view virtual override(ERC165, IERC165) returns(bool) {\r\n\t\treturn interfaceID == type(IERC721).interfaceId || interfaceID == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceID);\r\n\t}\r\n\r\n\tfunction balanceOf(address owner) public view virtual override returns(uint256) {\r\n\t\trequire(owner != address(0), \"ERC721: balance query for the zero address\");\r\n\r\n\t\treturn _balances[owner];\r\n\t}\r\n\r\n\tfunction ownerOf(uint256 tokenID) public view virtual override returns(address) {\r\n\t\taddress owner = _owners[tokenID];\r\n\r\n\t\trequire(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n\r\n\t\treturn owner;\r\n\t}\r\n\r\n\tfunction name() public view virtual override returns(string memory) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\tfunction symbol() public view virtual override returns(string memory) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\tfunction tokenURI(uint256 tokenID) public view virtual override returns(string memory) {\r\n\t\trequire(_exists(tokenID), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n\t\tstring memory baseURI = _baseURI();\r\n\r\n\t\treturn bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenID.toString())) : \"\";\r\n\t}\r\n\r\n\tfunction _baseURI() internal view virtual returns(string memory) {\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\tfunction approve(address to, uint256 tokenID) public virtual override {\r\n\t\taddress owner = ERC721.ownerOf(tokenID);\r\n\t\t\r\n\t\trequire(to != owner, \"ERC721: approval to current owner\");\r\n\r\n\t\trequire(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"ERC721: approve caller is not owner nor approved for all\");\r\n\r\n\t\t_approve(to, tokenID);\r\n\t}\r\n\r\n\tfunction getApproved(uint256 tokenID) public view virtual override returns(address) {\r\n\t\trequire(_exists(tokenID), \"ERC721: approved query for nonexistent token\");\r\n\r\n\t\treturn _tokenApprovals[tokenID];\r\n\t}\r\n\r\n\tfunction setApprovalForAll(address operator, bool approved) public virtual override {\r\n\t\t_setApprovalForAll(msg.sender, operator, approved);\r\n\t}\r\n\r\n\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns(bool) {\r\n\t\treturn _operatorApprovals[owner][operator];\r\n\t}\r\n\r\n\tfunction transferFrom(address from, address to, uint256 tokenID) public virtual override {\r\n\t\trequire(_isApprovedOrOwner(msg.sender, tokenID), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n\t\t_transfer(from, to, tokenID);\r\n\t}\r\n\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenID) public virtual override {\r\n\t\tsafeTransferFrom(from, to, tokenID, \"\");\r\n\t}\r\n\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenID, bytes memory _data) public virtual override {\r\n\t\trequire(_isApprovedOrOwner(msg.sender, tokenID), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n\t\t_safeTransfer(from, to, tokenID, _data);\r\n\t}\r\n\r\n\tfunction _safeTransfer(address from, address to, uint256 tokenID, bytes memory _data) internal virtual {\r\n\t\t_transfer(from, to, tokenID);\r\n\r\n\t\trequire(_checkOnERC721Received(from, to, tokenID, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n\t}\r\n\r\n\tfunction _exists(uint256 tokenID) internal view virtual returns(bool) {\r\n\t\treturn _owners[tokenID] != address(0);\r\n\t}\r\n\r\n\tfunction _isApprovedOrOwner(address spender, uint256 tokenID) internal view virtual returns(bool) {\r\n\t\trequire(_exists(tokenID), \"ERC721: operator query for nonexistent token\");\r\n\r\n\t\taddress owner = ERC721.ownerOf(tokenID);\r\n\r\n\t\treturn (spender == owner || getApproved(tokenID) == spender || isApprovedForAll(owner, spender));\r\n\t}\r\n\r\n\tfunction _safeMint(address to, uint256 tokenID) internal virtual {\r\n\t\t_safeMint(to, tokenID, \"\");\r\n\t}\r\n\r\n\tfunction _safeMint(address to, uint256 tokenID, bytes memory _data) internal virtual {\r\n\t\t_mint(to, tokenID);\r\n\t\t\r\n\t\trequire(_checkOnERC721Received(address(0), to, tokenID, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n\t}\r\n\r\n\tfunction _mint(address to, uint256 tokenID) internal virtual {\r\n\t\trequire(to != address(0), \"ERC721: mint to the zero address\");\r\n\t\trequire(!_exists(tokenID), \"ERC721: token already minted\");\r\n\r\n\t\t_beforeTokenTransfer(address(0), to, tokenID);\r\n\r\n\t\t_balances[to] += 1;\r\n\t\t_owners[tokenID] = to;\r\n\r\n\t\temit Transfer(address(0), to, tokenID);\r\n\r\n\t\t_afterTokenTransfer(address(0), to, tokenID);\r\n\t}\r\n\r\n\tfunction _burn(uint256 tokenID) internal virtual {\r\n\t\taddress owner = ERC721.ownerOf(tokenID);\r\n\r\n\t\t_beforeTokenTransfer(owner, address(0), tokenID);\r\n\t\t_approve(address(0), tokenID);\r\n\r\n\t\t_balances[owner] -= 1;\r\n\t\tdelete _owners[tokenID];\r\n\r\n\t\temit Transfer(owner, address(0), tokenID);\r\n\r\n\t\t_afterTokenTransfer(owner, address(0), tokenID);\r\n\t}\r\n\r\n\tfunction _transfer(address from, address to, uint256 tokenID) internal virtual {\r\n\t\trequire(ERC721.ownerOf(tokenID) == from, \"ERC721: transfer from incorrect owner\");\r\n\t\trequire(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n\t\t_beforeTokenTransfer(from, to, tokenID);\r\n\t\t_approve(address(0), tokenID);\r\n\r\n\t\t_balances[from] -= 1;\r\n\t\t_balances[to] += 1;\r\n\t\t_owners[tokenID] = to;\r\n\r\n\t\temit Transfer(from, to, tokenID);\r\n\r\n\t\t_afterTokenTransfer(from, to, tokenID);\r\n\t}\r\n\r\n\tfunction _approve(address to, uint256 tokenID) internal virtual {\r\n\t\t_tokenApprovals[tokenID] = to;\r\n\r\n\t\temit Approval(ERC721.ownerOf(tokenID), to, tokenID);\r\n\t}\r\n\r\n\tfunction _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\r\n\t\trequire(owner != operator, \"ERC721: approve to caller\");\r\n\r\n\t\t_operatorApprovals[owner][operator] = approved;\r\n\r\n\t\temit ApprovalForAll(owner, operator, approved);\r\n\t}\r\n\r\n\tfunction _checkOnERC721Received(address from, address to, uint256 tokenID, bytes memory _data) private returns(bool) {\r\n\t\tif (to == address(this)) return true;\r\n\r\n\t\telse if (to.isContract()) {\r\n\t\t\ttry IERC721Receiver(to).onERC721Received(msg.sender, from, tokenID, _data) returns(bytes4 retval) {\r\n\t\t\t\treturn retval == IERC721Receiver.onERC721Received.selector;\r\n\t\t\t} catch (bytes memory reason) {\r\n\t\t\t\tif (reason.length == 0) revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n\r\n\t\t\t\telse {\r\n\t\t\t\t\tassembly {\r\n\t\t\t\t\t\trevert(add(32, reason), mload(reason))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\telse return true;\r\n\t}\r\n\r\n\tfunction _beforeTokenTransfer(address from, address to, uint256 tokenID) internal virtual {}\r\n\r\n\tfunction _afterTokenTransfer(address from, address to, uint256 tokenID) internal virtual {}\r\n}\r\n\r\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\r\n\tmapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n\tmapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n\tuint256[] private _allTokens;\r\n\r\n\tmapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n\r\n\tfunction supportsInterface(bytes4 interfaceID) public view virtual override(IERC165, ERC721) returns(bool) {\r\n\t\treturn interfaceID == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceID);\r\n\t}\r\n\r\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns(uint256) {\r\n\t\trequire(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n\r\n\t\treturn _ownedTokens[owner][index];\r\n\t}\r\n\r\n\tfunction totalSupply() public view virtual override returns(uint256) {\r\n\t\treturn _allTokens.length;\r\n\t}\r\n\r\n\tfunction tokenByIndex(uint256 index) public view virtual override returns(uint256) {\r\n\t\trequire(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n\r\n\t\treturn _allTokens[index];\r\n\t}\r\n\r\n\tfunction _beforeTokenTransfer(address from, address to, uint256 tokenID) internal virtual override {\r\n\t\tsuper._beforeTokenTransfer(from, to, tokenID);\r\n\r\n\t\tif (from == address(0)) _addTokenToAllTokensEnumeration(tokenID);\r\n\r\n\t\telse if (from != to) _removeTokenFromOwnerEnumeration(from, tokenID);\r\n\r\n\t\tif (to == address(0)) _removeTokenFromAllTokensEnumeration(tokenID);\r\n\r\n\t\telse if (to != from) _addTokenToOwnerEnumeration(to, tokenID);\r\n\t}\r\n\r\n\tfunction _addTokenToOwnerEnumeration(address to, uint256 tokenID) private {\r\n\t\tuint256 length = ERC721.balanceOf(to);\r\n\r\n\t\t_ownedTokens[to][length] = tokenID;\r\n\t\t_ownedTokensIndex[tokenID] = length;\r\n\t}\r\n\r\n\tfunction _addTokenToAllTokensEnumeration(uint256 tokenID) private {\r\n\t\t_allTokensIndex[tokenID] = _allTokens.length;\r\n\t\t_allTokens.push(tokenID);\r\n\t}\r\n\r\n\tfunction _removeTokenFromOwnerEnumeration(address from, uint256 tokenID) private {\r\n\t\tuint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\r\n\t\tuint256 tokenIndex = _ownedTokensIndex[tokenID];\r\n\r\n\t\tif (tokenIndex != lastTokenIndex) {\r\n\t\t\tuint256 lastTokenID = _ownedTokens[from][lastTokenIndex];\r\n\r\n\t\t\t_ownedTokens[from][tokenIndex] = lastTokenID;\r\n\t\t\t_ownedTokensIndex[lastTokenID] = tokenIndex;\r\n\t\t}\r\n\r\n\t\tdelete _ownedTokensIndex[tokenID];\r\n\t\tdelete _ownedTokens[from][lastTokenIndex];\r\n\t}\r\n\r\n\tfunction _removeTokenFromAllTokensEnumeration(uint256 tokenID) private {\r\n\t\tuint256 lastTokenIndex = _allTokens.length - 1;\r\n\t\tuint256 tokenIndex = _allTokensIndex[tokenID];\r\n\t\tuint256 lastTokenID = _allTokens[lastTokenIndex];\r\n\r\n\t\t_allTokens[tokenIndex] = lastTokenID;\r\n\t\t_allTokensIndex[lastTokenID] = tokenIndex;\r\n\r\n\t\tdelete _allTokensIndex[tokenID];\r\n\t\t_allTokens.pop();\r\n\t}\r\n}\r\n\r\n\r\n\r\ncontract LilRobotApesClub is ERC721Enumerable, Ownable {\r\n\r\n\r\n\tuint256 public cost;\r\n\tuint256 public maxSupply;\r\n\r\n\tstring private baseURI;\r\n\r\n\r\n\tuint256 public interestPeriod = 1 days;\r\n\tuint256 public tokenRewardPerPeriod = 10;\r\n\r\n\r\n\tstruct Stake {\r\n\t\tuint256 tokenID;\r\n\t\taddress stakeholder;\r\n\t\tuint256 timestamp;\r\n\t\tuint256 collectedRewards;\r\n\t}\r\n\r\n\tStake[] public stakes;\r\n\r\n\tmapping(address => bool) private claimedFreeMint;\r\n\tmapping(address => uint256) private utilityTokens;\r\n    mapping(uint256=>bool) public usedOriginals;\r\n    \r\n    IERC721 MaleContract;\r\n\r\n\r\n\tevent NewStake(uint256 indexed tokenID, address indexed stakeholder);\r\n\tevent StakeWithdraw(uint256 indexed tokenID);\r\n\r\n\r\n\tconstructor(string memory _initBaseURI) ERC721(\"Lil Robot Apes Club\", \"LRAC\") {\r\n\t\tcost = 30;\r\n\t\tmaxSupply = 7000;\r\n\r\n\t\tsetBaseURI(_initBaseURI);\r\n\t\r\n\r\n\r\nMaleContract = IERC721(0xaf847F761e4FC8165f0261808D8ab5aCbb7fD77A);\r\n    }   \r\n\r\n    \r\n    function setOriginalBabyAddress(address _address) external onlyOwner{\r\n        MaleContract = IERC721(_address);\r\n    }\r\n\r\n\r\n    function _useToken(address _from, uint256 _originalTokenId) internal{\r\n        require(!usedOriginals[_originalTokenId], \"Token has been already used.\");\r\n        require(MaleContract.ownerOf(_originalTokenId) == _from, \"Address does not own the token.\");\r\n        usedOriginals[_originalTokenId]=true;\r\n    }\r\n\r\n\r\n function claimfreeMint(uint256 _originalTokenID1) external{\r\n        /*Tokens get used*/\r\n        _useToken(msg.sender, _originalTokenID1);\r\n\r\n\r\n       \r\n\r\n        /*New mint*/\r\n        _mintNFT(msg.sender, 1);\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\nfunction _mintNFT(address _to, uint256 _nftCount) private {\r\n    uint256 newSupply = totalSupply() + 1;\r\n        require(newSupply <= maxSupply, \"Number of tokens exceeded max supply!\");\r\n        require(_nftCount > 0, \"Must mint at least one NFT\");\r\n\r\n        for (uint256 i = 1; i <= _nftCount; i++) {\r\n            _safeMint(_to, newSupply);\r\n\r\n        if (newSupply == 1001 || newSupply == 2001 || newSupply == 3001 || newSupply == 4001 || newSupply == 5001 || newSupply == 6001) {\r\n\t\t\tsetNewCost(newSupply);\r\n\t\t}\r\n\r\n}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\tfunction mint() public payable {\r\n\t\tuint256 newSupply = totalSupply() + 1;\r\n\r\n\t\trequire(newSupply <= maxSupply, \"Number of tokens exceeded max supply!\");\r\n\r\n\t\tif (msg.sender != owner()) {\r\n\t\t\trequire(getUtilityTokensOfAddress(msg.sender) >= cost, \"Not enough utility tokens!\");\r\n\r\n\t\t\tutilityTokens[msg.sender] -= cost;\r\n\t\t}\r\n\r\n\r\n\t\t_safeMint(msg.sender, newSupply);\r\n\r\n\r\n\t\tif (newSupply == 1001 || newSupply == 2001 || newSupply == 3001 || newSupply == 4001 || newSupply == 5001 || newSupply == 6001) {\r\n\t\t\tsetNewCost(newSupply);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n   function gift(uint256 _mintAmount, address destination) public onlyOwner {\r\n\t   uint256 newSupply = totalSupply() + 1;\r\n\t   require(newSupply <= maxSupply, \"Number of tokens exceeded max supply!\");\r\n    require(_mintAmount > 0, \"need to mint at least 1 NFT\");\r\n\r\n\r\n      _safeMint(destination, _mintAmount);\r\n    \r\nif (newSupply == 1001 || newSupply == 2001 || newSupply == 3001 || newSupply == 4001 || newSupply == 5001 || newSupply == 6001) {\r\n\t\t\tsetNewCost(newSupply);\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\r\n\tfunction oldfunction() public payable {\r\n\t\tuint256 newSupply = totalSupply() + 1;\r\n\r\n\t\trequire(newSupply <= maxSupply, \"Number of tokens exceeded max supply!\");\r\n\r\n\t\trequire(hasFreeMint(msg.sender), \"You already used up your free mint!\");\r\n\r\n\r\n\t\tclaimedFreeMint[msg.sender] = true;\r\n\r\n\t\t_safeMint(msg.sender, newSupply);\r\n\r\n\r\n\t\tif (newSupply == 1001 || newSupply == 2001 || newSupply == 3001 || newSupply == 4001 || newSupply == 5001 || newSupply == 6001) {\r\n\t\t\tsetNewCost(newSupply);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction airDrop(address[] calldata addresses, uint8[] calldata amounts) public payable onlyOwner {\r\n\t\tassert(addresses.length > 0 && amounts.length > 0);\r\n\t\tassert(addresses.length == amounts.length);\r\n\r\n\r\n\t\tuint16 totalAmount;\r\n\t\tuint256 supply = totalSupply();\r\n\r\n\t\tfor (uint256 i = 0; i < amounts.length; i++) totalAmount += amounts[0];\r\n\r\n\t\trequire(supply + totalAmount <= maxSupply, \"Number of tokens exceeded max supply!\");\r\n\r\n\r\n\t\tfor (uint8 i = 0; i < addresses.length; i++) {\r\n\t\t\tuint8 amount = amounts[i];\r\n\t\t\taddress _address = addresses[i];\r\n\r\n\t\t\tfor (uint8 I = 1; I <= amount; I++) {\r\n\t\t\t\t_safeMint(_address, supply + i + I);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction withdraw() public payable onlyOwner {\r\n\t\t(bool success, ) = payable(owner()).call{value: address(this).balance}(\"\");\r\n\r\n\t\trequire(success, \"Ethereum Transaction: transaction reverted\");\r\n\t}\r\n\r\n\r\n\tfunction _baseURI() internal view virtual override returns(string memory) {\r\n\t\treturn baseURI;\r\n\t}\r\n\r\n\tfunction tokenURI(uint256 tokenID) public view virtual override returns(string memory) {\r\n\t\trequire(_exists(tokenID), \"ERC721 Metadata: URI query for nonexistent token!\");\r\n\r\n\t\treturn string( abi.encodePacked(baseURI, Strings.toString(tokenID), \".json\") );\r\n\t}\r\n\r\n\tfunction ownedTokens(address _address) public view returns(uint256[] memory) {\r\n\t\tuint256 ownerTokenCount = balanceOf(_address);\r\n\t\tuint256[] memory tokenIDs = new uint256[](ownerTokenCount);\r\n\r\n\t\tfor (uint256 i; i < ownerTokenCount; i++) {\r\n\t\t\ttokenIDs[i] = tokenOfOwnerByIndex(_address, i);\r\n\t\t}\r\n\r\n\t\treturn tokenIDs;\r\n\t}\r\n\r\n\tfunction hasFreeMint(address _address) public view returns(bool) {\r\n\t\treturn !claimedFreeMint[_address];\r\n\t}\r\n\r\n\tfunction getUtilityTokensOfAddress(address _address) public view returns(uint256) {\r\n\t\treturn utilityTokens[_address];\r\n\t}\r\n\r\n\r\n\tfunction setBaseURI(string memory newBaseURI) public onlyOwner {\r\n\t\tbaseURI = newBaseURI;\r\n\t}\r\n\r\n\tfunction setMaxSupply(uint256 newAmount) public onlyOwner {\r\n\t\tmaxSupply = newAmount;\r\n\t}\r\n\r\n\tfunction setInterestPeriod(uint256 newPeriod) public onlyOwner {\r\n\t\tinterestPeriod = newPeriod;\r\n\t}\r\n\r\n\tfunction setTokenRewardPerPeriod(uint256 newAmount) public onlyOwner {\r\n\t\ttokenRewardPerPeriod = newAmount;\r\n\t}\r\n\r\n\tfunction setNewCost(uint256 supply) internal {\r\n\t\tif (supply > 0 && supply <= 1000) cost = 30;\r\n\r\n\t\telse if (supply > 1000 && supply <= 2000) cost = 60;\r\n\r\n\t\telse if (supply > 2000 && supply <= 3000) cost = 120;\r\n\r\n\t\telse if (supply > 3000 && supply <= 4000) cost = 240;\r\n\r\n\t\telse if (supply > 4000 && supply <= 5000) cost = 400;\r\n\r\n\t\telse if (supply > 5000 && supply <= 6000) cost = 600;\r\n\r\n\t\telse cost = 800;\r\n\t}\r\n\r\n\r\n\tfunction stakeToken(uint256 tokenID) public {\r\n\t\trequire(ownerOf(tokenID) == msg.sender, \"ERC721 Stake: caller is not owner\");\r\n\r\n\r\n\t\tStake memory stake;\r\n\r\n\t\tstake.tokenID = tokenID;\r\n\t\tstake.stakeholder = msg.sender;\r\n\t\tstake.timestamp = block.timestamp;\r\n\t\tstake.collectedRewards = 0;\r\n\r\n\t\tstakes.push(stake);\r\n\r\n\r\n\t\t_safeTransfer(msg.sender, address(this), tokenID, \"\");\r\n\r\n\t\temit NewStake(tokenID, msg.sender);\r\n\t}\r\n\r\n\tfunction unStakeToken(uint256 tokenID) public {\r\n\t\t(bool isStaked, uint256 stakeIndex) = isTokenStaked(tokenID);\r\n\r\n\t\trequire(isStaked, \"ERC721 Stake: token is not staked\");\r\n\r\n\r\n\t\tStake memory stake = stakes[stakeIndex];\r\n\r\n\t\trequire(stake.stakeholder == msg.sender, \"ERC721 Stake: caller is not the owner\");\r\n\r\n\r\n\t\tstakes[stakeIndex] = stakes[stakes.length - 1];\r\n\t\tstakes.pop();\r\n\r\n\t\t_safeTransfer(address(this), stake.stakeholder, tokenID, \"\");\r\n\r\n\t\temit StakeWithdraw(tokenID);\r\n\t}\r\n\r\n\tfunction collectStakingRewards(uint256 tokenID) public {\r\n\t\t(bool isStaked, uint256 stakeIndex) = isTokenStaked(tokenID);\r\n\r\n\t\trequire(isStaked, \"ERC721 Stake: token is not staked\");\r\n\r\n\r\n\t\tStake memory stake = stakes[stakeIndex];\r\n\r\n\t\trequire(stake.stakeholder == msg.sender, \"ERC721 Stake: caller is not the owner\");\r\n\r\n\r\n\t\tuint256 rewards = calculateStakeRewards(tokenID);\r\n\r\n\t\trequire(rewards > 0, \"ERC721 Stake: no rewards to collect\");\r\n\r\n\r\n\t\tstakes[stakeIndex].collectedRewards += rewards;\r\n\t\tutilityTokens[msg.sender] += rewards;\r\n\t}\r\n\r\n\tfunction isTokenStaked(uint256 tokenID) public view returns(bool, uint256) {\r\n\t\tbool isStaked = false;\r\n\t\tuint256 index;\r\n\r\n\t\tfor (uint256 i = 0; i < stakes.length; i++) {\r\n\t\t\tif (stakes[i].tokenID != tokenID) continue;\r\n\r\n\t\t\tisStaked = true;\r\n\t\t\tindex = i;\r\n\t\t}\r\n\r\n\t\treturn (isStaked, index);\r\n\t}\r\n\r\n\tfunction getStakeInfo(uint256 tokenID) public view returns(Stake memory) {\r\n\t\t(bool isStaked, uint256 stakeIndex) = isTokenStaked(tokenID);\r\n\r\n\t\trequire(isStaked, \"ERC721 Stake: token is not staked\");\r\n\r\n\r\n\t\treturn stakes[stakeIndex];\r\n\t}\r\n\r\n\tfunction calculateStakeRewards(uint256 tokenID) public view returns(uint256) {\r\n\t\tStake memory stake = getStakeInfo(tokenID);\r\n\r\n        uint256 stakePeriod = block.timestamp - stake.timestamp;\r\n        uint256 periods = stakePeriod / interestPeriod;\r\n        uint256 rewards = periods * tokenRewardPerPeriod - stake.collectedRewards;\r\n\r\n        return rewards;\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_initBaseURI\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeholder\",\"type\":\"address\"}],\"name\":\"NewStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"StakeWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"amounts\",\"type\":\"uint8[]\"}],\"name\":\"airDrop\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"calculateStakeRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_originalTokenID1\",\"type\":\"uint256\"}],\"name\":\"claimfreeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"collectStakingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"getStakeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stakeholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectedRewards\",\"type\":\"uint256\"}],\"internalType\":\"struct LilRobotApesClub.Stake\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUtilityTokensOfAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"gift\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"hasFreeMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"isTokenStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldfunction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"ownedTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPeriod\",\"type\":\"uint256\"}],\"name\":\"setInterestPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setOriginalBabyAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"setTokenRewardPerPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"stakeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stakeholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectedRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenRewardPerPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"unStakeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usedOriginals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "LilRobotApesClub", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000005168747470733a2f2f676174657761792e70696e6174612e636c6f75642f697066732f516d526b68774b6a484654586731767a38564d546154425a7941554d58453347714b34486d6f6b7374686851464b2f000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d622bbf8aba9adea98d6b5f125d4d6537f05ad414ec81e6cc3ca49cfac80aa3e"}]}