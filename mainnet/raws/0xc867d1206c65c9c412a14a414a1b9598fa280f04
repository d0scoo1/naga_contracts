{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\ncontract KryptoriaTest {\r\n    using Strings for uint256;\r\n\r\n    address private _address1 = 0x474a08aBEc6eBd709a941000acD4c1EF21F9B721;\r\n    address private _address2 = 0x4CaCc7773dB97736737308e75D914B374fF9E795;\r\n\r\n    // Address to validate signature for update token uri\r\n    address private _platformAddress = 0xdf619A92247492c28Aed1CC69529bbdF8B1a9BC4;\r\n\r\n    // boolean to control NFT reveal \r\n    bool private _revealed = false;\r\n\r\n    // Owner Address\r\n    address private _ownerAddress;\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 => address) private _owners;\r\n\r\n    // Mapping for token URIs\r\n    mapping(uint256 => string) private _tokenURIs;\r\n\r\n    // TokenId to staking start time (0 means not staking)\r\n    mapping(uint256 => uint) private _stakingStartTime;\r\n\r\n    // Mapping for token to total staking time\r\n    mapping(uint256 => uint256) private _totalSakingTime;\r\n\r\n    // Mapping for wallet to whitelisting\r\n    mapping(address => bool) private _isUserWhiteListed;\r\n\r\n    // Mapping to hold token minted per wallet\r\n    mapping(address => uint) private _userTokenCount;\r\n\r\n    // Total supply of the NFTs\r\n    uint public _totalSupply ;\r\n\r\n    // variable to store miniting status (0-off, 1-only whitelisted, 2-open for all)\r\n    uint private _mintStatus = 0;\r\n\r\n    // Whether staking is currently allowed or not\r\n    bool public _stakingOpen = false;\r\n\r\n    string public _notRevealedUri = \"ipfs://QmaVbaSvU3gTKBM2uKeTSFj15QmmEqe5rQPWxNpr82umgG\";\r\n\r\n    string public _baseURI;\r\n\r\n    constructor() {\r\n        _ownerAddress = msg.sender;\r\n\r\n        // mint the token for given addresss\r\n        _owners[1] = _address1;\r\n         _userTokenCount[_address1] += 1;\r\n        _owners[2] = _address2;\r\n        _userTokenCount[_address2] += 1;\r\n        _owners[3] = _address1;\r\n        _userTokenCount[_address1] += 1;\r\n        _owners[4] = _address1;\r\n        _userTokenCount[_address1] += 1;\r\n        _totalSupply += 4;\r\n    }\r\n\r\n    function reveal() public {\r\n        require(msg.sender == _ownerAddress, \"only owner can reveal\");\r\n        _revealed = true;\r\n    }\r\n\r\n    function isRevealed() public view returns(bool) {\r\n        return _revealed;\r\n    }\r\n\r\n    function unReveal() public {\r\n        require(msg.sender == _ownerAddress, \"only owner can make reveal false\");\r\n        _revealed = false;\r\n    }\r\n\r\n    function getStakingTime(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (\r\n            bool isStaked,\r\n            uint256 current,\r\n            uint256 total\r\n        )\r\n    {\r\n        uint256 start = _stakingStartTime[tokenId];\r\n        if (start != 0) {\r\n            isStaked = true;\r\n            current = block.timestamp - start;\r\n        }\r\n        total = current + _totalSakingTime[tokenId];\r\n    }\r\n\r\n    function isWhiteListed(address wallet) public view returns(bool) {\r\n        return _isUserWhiteListed[wallet];\r\n    }\r\n\r\n    function setUserWhiteListed(address[] calldata wallets) public {\r\n        require(msg.sender == _ownerAddress, \"only owner is allowed\");\r\n        for (uint256 i = 0; i < wallets.length; ++i) {\r\n            _isUserWhiteListed[wallets[i]] = true;\r\n        }\r\n    }\r\n\r\n    // 0 => Minting close for all\r\n    // 1 => Minting is only open for whitelisted\r\n    // 2 => Minting open for all\r\n    function setMintingStatus(uint status) public {\r\n        require(msg.sender == _ownerAddress, \"only owner can set\");\r\n        require(status <= 2, \"allowed values are 0,1 and 2\");\r\n        _mintStatus = status;\r\n    }\r\n\r\n    function getMintingStatus() public view returns(string memory) {\r\n        if(_mintStatus == 0) {\r\n            return \"Minting is closed for all\";\r\n        } else if(_mintStatus == 1) {\r\n            return \"Minting is only available for white listed users\";\r\n        } else if(_mintStatus == 2) {\r\n            return \"Minting is open for all users\";\r\n        } else {\r\n            return \"Something went wrong\";\r\n        }\r\n    }\r\n\r\n    function getTokenCount(address user) public view returns(uint) {\r\n        return _userTokenCount[user];\r\n    }\r\n\r\n    function getTokenOwner(uint256 tokenId) public view returns(address) {\r\n        return _owners[tokenId];\r\n    }\r\n    \r\n\r\n    function safeMint(uint256 tokenId) public {\r\n        require(_totalSupply < 10000, \"platform reached limit of minting\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n        require(_mintStatus != 0, \"minting is closed for all\");\r\n        if(_mintStatus == 1) {\r\n            require(_isUserWhiteListed[msg.sender], \"you are not whitelisted, please contact administrator\");\r\n        }\r\n        require((_userTokenCount[msg.sender] + 1) <= 5, \"you cant mint more then 5\");\r\n        _owners[tokenId] = msg.sender;\r\n        _userTokenCount[msg.sender] += 1;\r\n        _totalSupply+=1;\r\n    }\r\n\r\n    function setBaseURI(string memory baseURI) public {\r\n        require(msg.sender == _ownerAddress, \"only owner can set uri\");\r\n        require(_revealed == false, \"Only allowed to set when its not reveled\");\r\n        _baseURI = baseURI;\r\n    }\r\n\r\n    function updateTokenURI(uint256 tokenId, string memory uri, bytes memory sig) public {\r\n        require(_exists(tokenId), \"requesting for non existing tokenId\");\r\n        require(_owners[tokenId] == msg.sender, \"you are not the owner of this nft\");\r\n        require(_revealed == true, \"only allowed to update after reveal\");\r\n        bool isValid = isValidURI(uri, sig);\r\n        require(isValid == true, \"signature validation failed!\");\r\n        _tokenURIs[tokenId] = uri;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\r\n        require(_exists(tokenId), \"URI query for nonexistent token\");\r\n        if(_revealed == false) {\r\n            return _notRevealedUri;\r\n        }\r\n        if(bytes(_tokenURIs[tokenId]).length > 0) {\r\n            return _tokenURIs[tokenId];\r\n        }\r\n        return string(abi.encodePacked(_baseURI, tokenId.toString(), \".json\"));\r\n    }\r\n\r\n    // Toggles the `stakingOpen` flag\r\n    function setStakingOpen(bool open) external {\r\n        require(msg.sender == _ownerAddress, \"only owner can set\");\r\n        _stakingOpen = open;\r\n    }\r\n\r\n    function stakeNfts(uint256[] memory _tokenIds) public {\r\n        require(_stakingOpen, \"staking is closed\");\r\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\r\n            require(_exists(_tokenIds[i]), \"requesting for non existing tokenId\");\r\n            require(_owners[_tokenIds[i]] == msg.sender, \"you are not the owner of this nft\");\r\n            require(_stakingStartTime[_tokenIds[i]] == 0, \"NFT is already staked\");\r\n            _stakingStartTime[_tokenIds[i]] = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function unstakeNfts(uint256[] memory _tokenIds) public {\r\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\r\n            require(_exists(_tokenIds[i]), \"this tokenId does not exist\");\r\n            require(_owners[_tokenIds[i]]== msg.sender || msg.sender == _ownerAddress, \"you are not the owner of this nft\");\r\n            require(_stakingStartTime[_tokenIds[i]] != 0, \"NFT is not on stake\");\r\n            uint256 start = block.timestamp - _stakingStartTime[_tokenIds[i]];\r\n            _totalSakingTime[_tokenIds[i]] += start;\r\n            _stakingStartTime[_tokenIds[i]] = 0;\r\n        }\r\n    }\r\n\r\n    function isValidURI(string memory _uri, bytes memory sig) internal view returns(bool) {\r\n        bytes32 message = keccak256(abi.encodePacked(_uri));\r\n        return (recoverSigner(message, sig) == _platformAddress);\r\n    }\r\n\r\n    function recoverSigner(bytes32 message, bytes memory sig) internal pure returns (address) {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n        (v, r, s) = splitSignature(sig);\r\n        return ecrecover(message, v, r, s);\r\n    }\r\n\r\n    function splitSignature(bytes memory sig) internal pure returns (uint8, bytes32, bytes32) {\r\n        require(sig.length == 65);\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        assembly {\r\n            // first 32 bytes, after the length prefix\r\n            r := mload(add(sig, 32))\r\n            // second 32 bytes\r\n            s := mload(add(sig, 64))\r\n            // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n        return (v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"_baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_notRevealedUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_stakingOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintingStatus\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getStakingTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isStaked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getTokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRevealed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"isWhiteListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"setMintingStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"}],\"name\":\"setStakingOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"setUserWhiteListed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"stakeNfts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unReveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unstakeNfts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"updateTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "KryptoriaTest", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4186787822df094388e2ef067336fbc7c6fed090d9d9def7116957c42d9f1dfb"}]}