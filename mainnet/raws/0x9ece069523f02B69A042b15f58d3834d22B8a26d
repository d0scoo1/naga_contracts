{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AmvNftStaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n}\\n\\n/**\\n * @dev This is a smart contract which provides staking and unstaking facilities with time-lock only for AnimeMetaverse NftTokens.\\n * Owners of AnimeMetaverse NftTokens can call `stake` function to stake their NftTokens and `unstake` function to unstake their NftTokens.\\n * When owner of the NftTokens call `stake` function he provides a list of tokenIds and a time-lock type.\\n * Based on the type of time-lock, Time-lock values are defined which can only be 0,30,60,90 days.\\n * Once the NftTokens' owner call the staking function, the ownership of these NftTokens are trasferred from the owner address to this smart contract address.\\n * The owner's address, current timestamp and time-lock are saved in a vault of this smart contrct.\\n * Later, when the owner of these NftTokens call the unstake function with a list of NftTokenIds, Firstly, it is checked that whether this caller was the previous owner\\n * of these NftTokens or not.\\n * This checking is done with the data saved in `vault`.\\n * Then the time-lock validation is checked.\\n * If these checking are done, then the NftTokens ownership is given back to the orginal owner from this smart contract address.\\n */\\n\\ncontract AmvNftStaker is Ownable {\\n    // Stores counts of staked NFT tokens.\\n    uint256 public totalStaked;\\n\\n    // Flag to enable or disable the staking.\\n    bool public isOpenForStaking = true;\\n\\n    // Flag to enable or disable the time-lock checking during unstaking.\\n    bool public isTimeLockActive = true;\\n\\n    // Stores maximum length of batch staking/unstaking tokenIds array.\\n    uint256 public maxInputSize = 10;\\n\\n    // Maximum token size to be set for batch staking and unstaking.\\n    uint256 public constant allowedMaxInputSize = 100;\\n\\n    // Stores AMV smart contract details.\\n    IERC721 public nft;\\n\\n    // String constant to determine the event type.\\n    bytes32 public constant stakingEventType = \\\"staking\\\";\\n\\n    // String constant to determine the event type.\\n    bytes32 public constant unStakingEventType = \\\"unstaking\\\";\\n\\n    // TimeLock for NFT staking\\n    // Value of ZERO_DAY = 0\\n    // Value of THIRTY_DAYS = 1\\n    // Value of SIXTY_DAYS = 2\\n    // Value of NINETY_DAYS = 3\\n    enum TimeLock {\\n        ZERO_DAY,\\n        THIRTY_DAYS,\\n        SIXTY_DAYS,\\n        NINETY_DAYS\\n    }\\n\\n    // Struct to store a stake's tokenId, address of the owner and function execution timestamp and the token's owner defined time-lock for unstaking.\\n    struct Stake {\\n        uint256 tokenId;\\n        address owner;\\n        uint256 stakedAt;\\n        uint256 timeLock;\\n    }\\n\\n    // Stores all possible value of time-locks\\n    uint256[4] public timeLocks = [0, 30 * 86400, 60 * 86400, 90 * 86400];\\n\\n    // Maps tokenId to stake details.\\n    mapping(uint256 => Stake) public vault;\\n\\n    // List of tokens that have been staked at least once.\\n    uint256[] public nftTokenIds;\\n\\n    // Maps tokenId to bool to check if tokenId has been staked at least once.\\n    mapping(uint256 => bool) public tokenIdExist;\\n\\n    /**\\n     * @dev Emits when the NFTs are staked.\\n     * @param owner The address of the owner of these NFTs.\\n     * @param tokenIds The tokenIDs of these NFTs.\\n     * @param timestamp The execution timestamp of the staking function.\\n     * @param eventType The Type of this event.\\n     */\\n    event NFTStaked(\\n        address owner,\\n        uint256[] tokenIds,\\n        uint256 timestamp,\\n        bytes32 eventType\\n    );\\n\\n    /**\\n     * @dev Emits when the NFTs are unstaked.\\n     * @param owner The address of the owner of these NFTs.\\n     * @param tokenIds The tokenIDs of these NFTs.\\n     * @param timestamp The execution timestamp of the unstaking function.\\n     * @param eventType The Type of this event.\\n     */\\n    event NFTUnstaked(\\n        address owner,\\n        uint256[] tokenIds,\\n        uint256 timestamp,\\n        bytes32 eventType\\n    );\\n\\n    /**\\n     * @dev Initializes the contract.\\n     * Creates instance of AnimeMetaverse smart contract through constructor.\\n     */\\n    constructor(address amvAddress) {\\n        nft = IERC721(amvAddress);\\n    }\\n\\n    /**\\n     * @notice Only Owner of this smart contract is allowed to call this function.\\n     * @dev public function to set the maximum length of batch staking/unstaking tokenIds array.\\n     */\\n    function setMaxInputSize(uint256 _maxInputSize) public onlyOwner {\\n        /**\\n         * @dev Throws if _maxInputSize is greater than 100.\\n         */\\n        require(\\n            _maxInputSize <= allowedMaxInputSize,\\n            \\\"Can not set MaxInputSize more than 100\\\"\\n        );\\n        /**\\n         * @dev Throws if _maxInputSize is less than 1.\\n         */\\n        require(_maxInputSize >= 1, \\\"Can not set MaxInputSize less than 1\\\");\\n        maxInputSize = _maxInputSize;\\n    }\\n\\n    /**\\n     * @notice Only Owner of this smart contract is allowed to call this function.\\n     * @dev public function to change the value of `isOpenForStaking` flag which decides whether staking to this smart contract is allowed or not .\\n     */\\n    function setIsOpenForStaking(bool _isOpenForStaking) public onlyOwner {\\n        isOpenForStaking = _isOpenForStaking;\\n    }\\n\\n    /**\\n     * @notice Only Owner of this smart contract is allowed to call this function.\\n     * @dev public function to change the value of `isTimeLockActive` flag which decides whether time-lock will be considered during unstaking or not .\\n     */\\n    function setIsTimeLockActive(bool _isTimeLockActive) public onlyOwner {\\n        isTimeLockActive = _isTimeLockActive;\\n    }\\n\\n    /**\\n     * @notice Use this function with caution. Wrong usage can have serious consequences.\\n     * @dev external function to stake AnimeMetaverse NFTs from owner address of these NFTs to this smart contract address.\\n     * @param tokenIds uint256[] tokenIDs of the AnimeMetaverse NFTs to be staked to this smart contract address.\\n     */\\n    function stake(uint256[] calldata tokenIds, uint8 timeLockType) external {\\n        /**\\n         * @dev Throws if the `isOpenForStaking` is false.\\n         */\\n        require(isOpenForStaking, \\\"Staking is not allowed\\\");\\n\\n        /**\\n         * @dev Throws if the `timeLockType` is not between 0 and 3.\\n         */\\n        require(\\n            timeLockType == uint8(TimeLock.ZERO_DAY) ||\\n                timeLockType == uint8(TimeLock.THIRTY_DAYS) ||\\n                timeLockType == uint8(TimeLock.SIXTY_DAYS) ||\\n                timeLockType == uint8(TimeLock.NINETY_DAYS),\\n            \\\"Invalid timeLock type\\\"\\n        );\\n\\n        /**\\n         * @dev Throws if the `tokenIds` is empty or count of `tokenIds` is more than 50.\\n         */\\n        require(tokenIds.length > 0, \\\"Input parameter array is empty\\\");\\n        require(\\n            tokenIds.length <= maxInputSize,\\n            \\\"Maximum Input size of tokenIds is exceded\\\"\\n        );\\n\\n        uint256 tokenId;\\n\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            tokenId = tokenIds[i];\\n\\n            /**\\n             * Getting owner's address of this tokenId from AnimeMetaverse NFT smart contract.\\n             * @dev Throws if `nftOwnerAddress` doesn't match with `msg.sender`.\\n             */\\n            address nftOwnerAddress = nft.ownerOf(tokenId);\\n            require(\\n                nftOwnerAddress == msg.sender,\\n                \\\"Sender is not the owner of the token\\\"\\n            );\\n\\n            /**\\n             * @dev Throws if the tokenId of this NFT is already staked.\\n             */\\n            require(vault[tokenId].tokenId == 0, \\\"Token is already staked\\\");\\n\\n            /**\\n             * @dev Transfers the ownership of an NFT from `msg.sender` to `address(this)`.\\n             * `address(this)` means this smart contract address.\\n             */\\n            nft.transferFrom(msg.sender, address(this), tokenId);\\n\\n            addNewNftToVault(tokenId, timeLocks[timeLockType]);\\n            addNewTokenIdToList(tokenId); //\\n        }\\n        totalStaked += tokenIds.length; // Updating the count of total staked NFT tokens.\\n        emit NFTStaked(msg.sender, tokenIds, block.timestamp, stakingEventType); // emiting NFTStaked event.\\n    }\\n\\n    /**\\n     * @dev Private function to add NFT information to the `vault`.\\n     * Stores tokenId, address of the owner and function execution timestamp against tokenId using map.\\n     * @param tokenId uint256 tokenID of the AnimeMetaverse nfts to be added to the `vault`.\\n     */\\n    function addNewNftToVault(uint256 tokenId, uint256 timeLock) private {\\n        vault[tokenId] = Stake({\\n            owner: msg.sender,\\n            tokenId: tokenId,\\n            stakedAt: uint256(block.timestamp),\\n            timeLock: timeLock\\n        });\\n    }\\n\\n    /**\\n     * @dev Private function to add tokenIds to `nftTokenIds` list.\\n     * Checks if this tokenId is already added to `nftTokenIds` list or not.\\n     * If if this tokenId is not already added to `nftTokenIds` , sets the flag for this `tokenId` true and adds to the `nftTokenIds` list\\n     * @param tokenId uint256 tokenID of the AnimeMetaverse nfts to be added to the `nftTokenIds` list.\\n     */\\n    function addNewTokenIdToList(uint256 tokenId) private {\\n        if (!tokenIdExist[tokenId]) {\\n            tokenIdExist[tokenId] = true;\\n            nftTokenIds.push(tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @notice Use this function with caution. Wrong usage can have serious consequences.\\n     * @dev External function to unstake AnimeMetaverse NFTs from this smart contract address to the owner of these NFTs tokenIds.\\n     * @param tokenIds uint256[] tokenIDs of the AnimeMetaverse NFTs to be unstaked from this smart contract address.\\n     */\\n    function unstake(uint256[] calldata tokenIds) external {\\n        /**\\n         * @dev Throws if the `tokenIds` is empty or count of `tokenIds` is more than 50.\\n         */\\n        require(tokenIds.length > 0, \\\"Input parameter array is empty\\\");\\n        require(\\n            tokenIds.length <= maxInputSize,\\n            \\\"Maximum input size of tokenIds is exceded\\\"\\n        );\\n\\n        uint256 tokenId;\\n        totalStaked -= tokenIds.length; // updating the count of total staked NFT tokens.\\n\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            tokenId = tokenIds[i];\\n\\n            /**\\n             * Getting stake information from the vault for this tokenId.\\n             * @dev Throws if `staked.owner` doesn't match with `msg.sender`.\\n             * Here, staked.owner is the owner address of this tokenId which is stored in our vault.\\n             */\\n            Stake memory staked = vault[tokenId];\\n            require(\\n                staked.owner == msg.sender,\\n                \\\"Sender is not the owner of these tokens\\\"\\n            );\\n\\n            /**\\n             * @dev Throws if this smart contract is not the owner of the token.\\n             */\\n            address nftOwnerAddress = nft.ownerOf(tokenId);\\n            require(\\n                nftOwnerAddress == address(this),\\n                \\\"This smart contract is not the owner of these tokens\\\"\\n            );\\n\\n            timeLockCheck(staked.stakedAt, staked.timeLock);\\n\\n            removeNftFromVault(tokenId);\\n\\n            /**\\n             * @dev Transfers the ownership of an NFT from `address(this)` to`msg.sender`.\\n             * Here, `address(this)` means this smart contract address.\\n             */\\n            nft.transferFrom(address(this), msg.sender, tokenId);\\n        }\\n\\n        emit NFTUnstaked(\\n            msg.sender,\\n            tokenIds,\\n            block.timestamp,\\n            unStakingEventType\\n        ); //emiting NFTUnstaked event.\\n    }\\n\\n    /**\\n     * @dev Public function to check if a token is eligible to unstake.\\n     * @param stakedAt uint256 staking timestamp of a token stored in `vault`.\\n     * @param timeLock uint256 time-lock of a token set by token's owner during staking which is stored in `vault`.\\n     */\\n    function timeLockCheck(uint256 stakedAt, uint256 timeLock) public view {\\n        /**\\n         * @dev Throws if `isTimeLockActive` is true and the differnce between the current timestamp and staking timestamp is not greater than tokens owner's predefined time-lock.\\n         */\\n        if (isTimeLockActive) {\\n            require(\\n                (block.timestamp - stakedAt) > timeLock,\\n                \\\"Tokens cannot be unstaked before its chosen minimum time lock period\\\"\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to delete NFT information from the `vault`.\\n     * @param tokenId uint256 tokenID of the AnimeMetaverse nfts to be added to the `vault`.\\n     */\\n    function removeNftFromVault(uint256 tokenId) private {\\n        delete vault[tokenId];\\n    }\\n\\n    /**\\n     * @dev Public function to get a list of NFTs which are staked in our smart contract.\\n     * Checks every stake stored in this `vault` against this `account`\\n     * If the owner of any stake matches with this `account`, then collects them in a list and are returned.\\n     * @param account address The address that owns the NFTs.\\n     * @return ownrTokens A list of tokens owned by `account` from `vault`\\n     */\\n    function tokensOfOwner(address account)\\n        public\\n        view\\n        returns (Stake[] memory ownrTokens)\\n    {\\n        uint256 supply = nftTokenIds.length;\\n        Stake[] memory tmp = new Stake[](supply);\\n\\n        uint256 nftCount = 0;\\n        for (uint256 i = 0; i < supply; i++) {\\n            Stake memory staked = vault[nftTokenIds[i]];\\n            if (staked.owner == account) {\\n                tmp[nftCount] = staked;\\n                nftCount += 1;\\n            }\\n        }\\n        Stake[] memory ownerTokens = new Stake[](nftCount);\\n        for (uint256 i = 0; i < nftCount; i++) {\\n            ownerTokens[i] = tmp[i];\\n        }\\n        return ownerTokens;\\n    }\\n\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address from,\\n        uint256,\\n        bytes calldata\\n    ) external pure returns (bytes4) {\\n        require(from == address(0x0), \\\"Cannot send nfts to Vault directly\\\");\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"amvAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"eventType\",\"type\":\"bytes32\"}],\"name\":\"NFTStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"eventType\",\"type\":\"bytes32\"}],\"name\":\"NFTUnstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allowedMaxInputSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOpenForStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTimeLockActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxInputSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftTokenIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isOpenForStaking\",\"type\":\"bool\"}],\"name\":\"setIsOpenForStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isTimeLockActive\",\"type\":\"bool\"}],\"name\":\"setIsTimeLockActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxInputSize\",\"type\":\"uint256\"}],\"name\":\"setMaxInputSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"timeLockType\",\"type\":\"uint8\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingEventType\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeLock\",\"type\":\"uint256\"}],\"name\":\"timeLockCheck\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"timeLocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdExist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeLock\",\"type\":\"uint256\"}],\"internalType\":\"struct AmvNftStaker.Stake[]\",\"name\":\"ownrTokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unStakingEventType\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeLock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AmvNftStaker", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000068cd21d362c2dae66909afd810e391fa152b2379", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}