{"status": "1", "message": "OK", "result": [{"SourceCode": "// Sources flattened with hardhat v2.6.1 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.3.2\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.3.2\r\n\r\n// : MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.3.2\r\n\r\n// : MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/MVM/iMVM_DiscountOracle.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\ninterface iMVM_DiscountOracle{\r\n\r\n    function setDiscount(\r\n        uint256 _discount\r\n    ) external;\r\n    \r\n    function setMinL2Gas(\r\n        uint256 _minL2Gas\r\n    ) external;\r\n    \r\n    function setWhitelistedXDomainSender(\r\n        address _sender,\r\n        bool _isWhitelisted\r\n    ) external;\r\n    \r\n    function isXDomainSenderAllowed(\r\n        address _sender\r\n    ) view external returns(bool);\r\n    \r\n    function setAllowAllXDomainSenders(\r\n        bool _allowAllXDomainSenders\r\n    ) external;\r\n    \r\n    function getMinL2Gas() view external returns(uint256);\r\n    function getDiscount() view external returns(uint256);\r\n    function processL2SeqGas(address sender, uint256 _chainId) external payable;\r\n}\r\n\r\n\r\n// File contracts/libraries/resolver/Lib_AddressManager.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/* External Imports */\r\n\r\n/**\r\n * @title Lib_AddressManager\r\n */\r\ncontract Lib_AddressManager is Ownable {\r\n    /**********\r\n     * Events *\r\n     **********/\r\n\r\n    event AddressSet(string indexed _name, address _newAddress, address _oldAddress);\r\n\r\n    /*************\r\n     * Variables *\r\n     *************/\r\n\r\n    mapping(bytes32 => address) private addresses;\r\n\r\n    /********************\r\n     * Public Functions *\r\n     ********************/\r\n\r\n    /**\r\n     * Changes the address associated with a particular name.\r\n     * @param _name String name to associate an address with.\r\n     * @param _address Address to associate with the name.\r\n     */\r\n    function setAddress(string memory _name, address _address) external onlyOwner {\r\n        bytes32 nameHash = _getNameHash(_name);\r\n        address oldAddress = addresses[nameHash];\r\n        addresses[nameHash] = _address;\r\n\r\n        emit AddressSet(_name, _address, oldAddress);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the address associated with a given name.\r\n     * @param _name Name to retrieve an address for.\r\n     * @return Address associated with the given name.\r\n     */\r\n    function getAddress(string memory _name) external view returns (address) {\r\n        return addresses[_getNameHash(_name)];\r\n    }\r\n\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    /**\r\n     * Computes the hash of a name.\r\n     * @param _name Name to compute a hash for.\r\n     * @return Hash of the given name.\r\n     */\r\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_name));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/resolver/Lib_AddressResolver.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/* Library Imports */\r\n\r\n/**\r\n * @title Lib_AddressResolver\r\n */\r\nabstract contract Lib_AddressResolver {\r\n    /*************\r\n     * Variables *\r\n     *************/\r\n\r\n    Lib_AddressManager public libAddressManager;\r\n\r\n    /***************\r\n     * Constructor *\r\n     ***************/\r\n\r\n    /**\r\n     * @param _libAddressManager Address of the Lib_AddressManager.\r\n     */\r\n    constructor(address _libAddressManager) {\r\n        libAddressManager = Lib_AddressManager(_libAddressManager);\r\n    }\r\n\r\n    /********************\r\n     * Public Functions *\r\n     ********************/\r\n\r\n    /**\r\n     * Resolves the address associated with a given name.\r\n     * @param _name Name to resolve an address for.\r\n     * @return Address associated with the given name.\r\n     */\r\n    function resolve(string memory _name) public view returns (address) {\r\n        return libAddressManager.getAddress(_name);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/rlp/Lib_RLPReader.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * @title Lib_RLPReader\r\n * @dev Adapted from \"RLPReader\" by Hamdi Allam (hamdi.allam97@gmail.com).\r\n */\r\nlibrary Lib_RLPReader {\r\n    /*************\r\n     * Constants *\r\n     *************/\r\n\r\n    uint256 internal constant MAX_LIST_LENGTH = 32;\r\n\r\n    /*********\r\n     * Enums *\r\n     *********/\r\n\r\n    enum RLPItemType {\r\n        DATA_ITEM,\r\n        LIST_ITEM\r\n    }\r\n\r\n    /***********\r\n     * Structs *\r\n     ***********/\r\n\r\n    struct RLPItem {\r\n        uint256 length;\r\n        uint256 ptr;\r\n    }\r\n\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    /**\r\n     * Converts bytes to a reference to memory position and length.\r\n     * @param _in Input bytes to convert.\r\n     * @return Output memory reference.\r\n     */\r\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\r\n        uint256 ptr;\r\n        assembly {\r\n            ptr := add(_in, 32)\r\n        }\r\n\r\n        return RLPItem({ length: _in.length, ptr: ptr });\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP list value into a list of RLP items.\r\n     * @param _in RLP list value.\r\n     * @return Decoded RLP list items.\r\n     */\r\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\r\n        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\r\n\r\n        require(itemType == RLPItemType.LIST_ITEM, \"Invalid RLP list value.\");\r\n\r\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\r\n        // writing to the length. Since we can't know the number of RLP items without looping over\r\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\r\n        // simply set a reasonable maximum list length and decrease the size before we finish.\r\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\r\n\r\n        uint256 itemCount = 0;\r\n        uint256 offset = listOffset;\r\n        while (offset < _in.length) {\r\n            require(itemCount < MAX_LIST_LENGTH, \"Provided RLP list exceeds max list length.\");\r\n\r\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\r\n                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })\r\n            );\r\n\r\n            out[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });\r\n\r\n            itemCount += 1;\r\n            offset += itemOffset + itemLength;\r\n        }\r\n\r\n        // Decrease the array size to match the actual item count.\r\n        assembly {\r\n            mstore(out, itemCount)\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP list value into a list of RLP items.\r\n     * @param _in RLP list value.\r\n     * @return Decoded RLP list items.\r\n     */\r\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\r\n        return readList(toRLPItem(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP bytes value into bytes.\r\n     * @param _in RLP bytes value.\r\n     * @return Decoded bytes.\r\n     */\r\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\r\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\r\n\r\n        require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes value.\");\r\n\r\n        return _copy(_in.ptr, itemOffset, itemLength);\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP bytes value into bytes.\r\n     * @param _in RLP bytes value.\r\n     * @return Decoded bytes.\r\n     */\r\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\r\n        return readBytes(toRLPItem(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP string value into a string.\r\n     * @param _in RLP string value.\r\n     * @return Decoded string.\r\n     */\r\n    function readString(RLPItem memory _in) internal pure returns (string memory) {\r\n        return string(readBytes(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP string value into a string.\r\n     * @param _in RLP string value.\r\n     * @return Decoded string.\r\n     */\r\n    function readString(bytes memory _in) internal pure returns (string memory) {\r\n        return readString(toRLPItem(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP bytes32 value into a bytes32.\r\n     * @param _in RLP bytes32 value.\r\n     * @return Decoded bytes32.\r\n     */\r\n    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\r\n        require(_in.length <= 33, \"Invalid RLP bytes32 value.\");\r\n\r\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\r\n\r\n        require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes32 value.\");\r\n\r\n        uint256 ptr = _in.ptr + itemOffset;\r\n        bytes32 out;\r\n        assembly {\r\n            out := mload(ptr)\r\n\r\n            // Shift the bytes over to match the item size.\r\n            if lt(itemLength, 32) {\r\n                out := div(out, exp(256, sub(32, itemLength)))\r\n            }\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP bytes32 value into a bytes32.\r\n     * @param _in RLP bytes32 value.\r\n     * @return Decoded bytes32.\r\n     */\r\n    function readBytes32(bytes memory _in) internal pure returns (bytes32) {\r\n        return readBytes32(toRLPItem(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP uint256 value into a uint256.\r\n     * @param _in RLP uint256 value.\r\n     * @return Decoded uint256.\r\n     */\r\n    function readUint256(RLPItem memory _in) internal pure returns (uint256) {\r\n        return uint256(readBytes32(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP uint256 value into a uint256.\r\n     * @param _in RLP uint256 value.\r\n     * @return Decoded uint256.\r\n     */\r\n    function readUint256(bytes memory _in) internal pure returns (uint256) {\r\n        return readUint256(toRLPItem(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP bool value into a bool.\r\n     * @param _in RLP bool value.\r\n     * @return Decoded bool.\r\n     */\r\n    function readBool(RLPItem memory _in) internal pure returns (bool) {\r\n        require(_in.length == 1, \"Invalid RLP boolean value.\");\r\n\r\n        uint256 ptr = _in.ptr;\r\n        uint256 out;\r\n        assembly {\r\n            out := byte(0, mload(ptr))\r\n        }\r\n\r\n        require(out == 0 || out == 1, \"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\");\r\n\r\n        return out != 0;\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP bool value into a bool.\r\n     * @param _in RLP bool value.\r\n     * @return Decoded bool.\r\n     */\r\n    function readBool(bytes memory _in) internal pure returns (bool) {\r\n        return readBool(toRLPItem(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP address value into a address.\r\n     * @param _in RLP address value.\r\n     * @return Decoded address.\r\n     */\r\n    function readAddress(RLPItem memory _in) internal pure returns (address) {\r\n        if (_in.length == 1) {\r\n            return address(0);\r\n        }\r\n\r\n        require(_in.length == 21, \"Invalid RLP address value.\");\r\n\r\n        return address(uint160(readUint256(_in)));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP address value into a address.\r\n     * @param _in RLP address value.\r\n     * @return Decoded address.\r\n     */\r\n    function readAddress(bytes memory _in) internal pure returns (address) {\r\n        return readAddress(toRLPItem(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads the raw bytes of an RLP item.\r\n     * @param _in RLP item to read.\r\n     * @return Raw RLP bytes.\r\n     */\r\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\r\n        return _copy(_in);\r\n    }\r\n\r\n    /*********************\r\n     * Private Functions *\r\n     *********************/\r\n\r\n    /**\r\n     * Decodes the length of an RLP item.\r\n     * @param _in RLP item to decode.\r\n     * @return Offset of the encoded data.\r\n     * @return Length of the encoded data.\r\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\r\n     */\r\n    function _decodeLength(RLPItem memory _in)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            RLPItemType\r\n        )\r\n    {\r\n        require(_in.length > 0, \"RLP item cannot be null.\");\r\n\r\n        uint256 ptr = _in.ptr;\r\n        uint256 prefix;\r\n        assembly {\r\n            prefix := byte(0, mload(ptr))\r\n        }\r\n\r\n        if (prefix <= 0x7f) {\r\n            // Single byte.\r\n\r\n            return (0, 1, RLPItemType.DATA_ITEM);\r\n        } else if (prefix <= 0xb7) {\r\n            // Short string.\r\n\r\n            uint256 strLen = prefix - 0x80;\r\n\r\n            require(_in.length > strLen, \"Invalid RLP short string.\");\r\n\r\n            return (1, strLen, RLPItemType.DATA_ITEM);\r\n        } else if (prefix <= 0xbf) {\r\n            // Long string.\r\n            uint256 lenOfStrLen = prefix - 0xb7;\r\n\r\n            require(_in.length > lenOfStrLen, \"Invalid RLP long string length.\");\r\n\r\n            uint256 strLen;\r\n            assembly {\r\n                // Pick out the string length.\r\n                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\r\n            }\r\n\r\n            require(_in.length > lenOfStrLen + strLen, \"Invalid RLP long string.\");\r\n\r\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\r\n        } else if (prefix <= 0xf7) {\r\n            // Short list.\r\n            uint256 listLen = prefix - 0xc0;\r\n\r\n            require(_in.length > listLen, \"Invalid RLP short list.\");\r\n\r\n            return (1, listLen, RLPItemType.LIST_ITEM);\r\n        } else {\r\n            // Long list.\r\n            uint256 lenOfListLen = prefix - 0xf7;\r\n\r\n            require(_in.length > lenOfListLen, \"Invalid RLP long list length.\");\r\n\r\n            uint256 listLen;\r\n            assembly {\r\n                // Pick out the list length.\r\n                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\r\n            }\r\n\r\n            require(_in.length > lenOfListLen + listLen, \"Invalid RLP long list.\");\r\n\r\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Copies the bytes from a memory location.\r\n     * @param _src Pointer to the location to read from.\r\n     * @param _offset Offset to start reading from.\r\n     * @param _length Number of bytes to read.\r\n     * @return Copied bytes.\r\n     */\r\n    function _copy(\r\n        uint256 _src,\r\n        uint256 _offset,\r\n        uint256 _length\r\n    ) private pure returns (bytes memory) {\r\n        bytes memory out = new bytes(_length);\r\n        if (out.length == 0) {\r\n            return out;\r\n        }\r\n\r\n        uint256 src = _src + _offset;\r\n        uint256 dest;\r\n        assembly {\r\n            dest := add(out, 32)\r\n        }\r\n\r\n        // Copy over as many complete words as we can.\r\n        for (uint256 i = 0; i < _length / 32; i++) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += 32;\r\n            dest += 32;\r\n        }\r\n\r\n        // Pick out the remaining bytes.\r\n        uint256 mask;\r\n        unchecked {\r\n            mask = 256**(32 - (_length % 32)) - 1;\r\n        }\r\n\r\n        assembly {\r\n            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Copies an RLP item into bytes.\r\n     * @param _in RLP item to copy.\r\n     * @return Copied bytes.\r\n     */\r\n    function _copy(RLPItem memory _in) private pure returns (bytes memory) {\r\n        return _copy(_in.ptr, 0, _in.length);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/rlp/Lib_RLPWriter.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * @title Lib_RLPWriter\r\n * @author Bakaoh (with modifications)\r\n */\r\nlibrary Lib_RLPWriter {\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    /**\r\n     * RLP encodes a byte string.\r\n     * @param _in The byte string to encode.\r\n     * @return The RLP encoded string in bytes.\r\n     */\r\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\r\n        bytes memory encoded;\r\n\r\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\r\n            encoded = _in;\r\n        } else {\r\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\r\n        }\r\n\r\n        return encoded;\r\n    }\r\n\r\n    /**\r\n     * RLP encodes a list of RLP encoded byte byte strings.\r\n     * @param _in The list of RLP encoded byte strings.\r\n     * @return The RLP encoded list of items in bytes.\r\n     */\r\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\r\n        bytes memory list = _flatten(_in);\r\n        return abi.encodePacked(_writeLength(list.length, 192), list);\r\n    }\r\n\r\n    /**\r\n     * RLP encodes a string.\r\n     * @param _in The string to encode.\r\n     * @return The RLP encoded string in bytes.\r\n     */\r\n    function writeString(string memory _in) internal pure returns (bytes memory) {\r\n        return writeBytes(bytes(_in));\r\n    }\r\n\r\n    /**\r\n     * RLP encodes an address.\r\n     * @param _in The address to encode.\r\n     * @return The RLP encoded address in bytes.\r\n     */\r\n    function writeAddress(address _in) internal pure returns (bytes memory) {\r\n        return writeBytes(abi.encodePacked(_in));\r\n    }\r\n\r\n    /**\r\n     * RLP encodes a uint.\r\n     * @param _in The uint256 to encode.\r\n     * @return The RLP encoded uint256 in bytes.\r\n     */\r\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\r\n        return writeBytes(_toBinary(_in));\r\n    }\r\n\r\n    /**\r\n     * RLP encodes a bool.\r\n     * @param _in The bool to encode.\r\n     * @return The RLP encoded bool in bytes.\r\n     */\r\n    function writeBool(bool _in) internal pure returns (bytes memory) {\r\n        bytes memory encoded = new bytes(1);\r\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\r\n        return encoded;\r\n    }\r\n\r\n    /*********************\r\n     * Private Functions *\r\n     *********************/\r\n\r\n    /**\r\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\r\n     * @param _len The length of the string or the payload.\r\n     * @param _offset 128 if item is string, 192 if item is list.\r\n     * @return RLP encoded bytes.\r\n     */\r\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\r\n        bytes memory encoded;\r\n\r\n        if (_len < 56) {\r\n            encoded = new bytes(1);\r\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\r\n        } else {\r\n            uint256 lenLen;\r\n            uint256 i = 1;\r\n            while (_len / i != 0) {\r\n                lenLen++;\r\n                i *= 256;\r\n            }\r\n\r\n            encoded = new bytes(lenLen + 1);\r\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\r\n            for (i = 1; i <= lenLen; i++) {\r\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\r\n            }\r\n        }\r\n\r\n        return encoded;\r\n    }\r\n\r\n    /**\r\n     * Encode integer in big endian binary form with no leading zeroes.\r\n     * @notice TODO: This should be optimized with assembly to save gas costs.\r\n     * @param _x The integer to encode.\r\n     * @return RLP encoded bytes.\r\n     */\r\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\r\n        bytes memory b = abi.encodePacked(_x);\r\n\r\n        uint256 i = 0;\r\n        for (; i < 32; i++) {\r\n            if (b[i] != 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        bytes memory res = new bytes(32 - i);\r\n        for (uint256 j = 0; j < res.length; j++) {\r\n            res[j] = b[i++];\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Copies a piece of memory to another location.\r\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\r\n     * @param _dest Destination location.\r\n     * @param _src Source location.\r\n     * @param _len Length of memory to copy.\r\n     */\r\n    function _memcpy(\r\n        uint256 _dest,\r\n        uint256 _src,\r\n        uint256 _len\r\n    ) private pure {\r\n        uint256 dest = _dest;\r\n        uint256 src = _src;\r\n        uint256 len = _len;\r\n\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        uint256 mask;\r\n        unchecked {\r\n            mask = 256**(32 - len) - 1;\r\n        }\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Flattens a list of byte strings into one byte string.\r\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\r\n     * @param _list List of byte strings to flatten.\r\n     * @return The flattened byte string.\r\n     */\r\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\r\n        if (_list.length == 0) {\r\n            return new bytes(0);\r\n        }\r\n\r\n        uint256 len;\r\n        uint256 i = 0;\r\n        for (; i < _list.length; i++) {\r\n            len += _list[i].length;\r\n        }\r\n\r\n        bytes memory flattened = new bytes(len);\r\n        uint256 flattenedPtr;\r\n        assembly {\r\n            flattenedPtr := add(flattened, 0x20)\r\n        }\r\n\r\n        for (i = 0; i < _list.length; i++) {\r\n            bytes memory item = _list[i];\r\n\r\n            uint256 listPtr;\r\n            assembly {\r\n                listPtr := add(item, 0x20)\r\n            }\r\n\r\n            _memcpy(flattenedPtr, listPtr, item.length);\r\n            flattenedPtr += _list[i].length;\r\n        }\r\n\r\n        return flattened;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/utils/Lib_BytesUtils.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * @title Lib_BytesUtils\r\n */\r\nlibrary Lib_BytesUtils {\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    ) internal pure returns (bytes memory) {\r\n        require(_length + 31 >= _length, \"slice_overflow\");\r\n        require(_start + _length >= _start, \"slice_overflow\");\r\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                //zero out the 32 bytes slice we are about to return\r\n                //we need to do it because Solidity does not garbage collect\r\n                mstore(tempBytes, 0)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\r\n        if (_start >= _bytes.length) {\r\n            return bytes(\"\");\r\n        }\r\n\r\n        return slice(_bytes, _start, _bytes.length - _start);\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {\r\n        if (_bytes.length < 32) {\r\n            bytes32 ret;\r\n            assembly {\r\n                ret := mload(add(_bytes, 32))\r\n            }\r\n            return ret;\r\n        }\r\n\r\n        return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\r\n    }\r\n\r\n    function toUint256(bytes memory _bytes) internal pure returns (uint256) {\r\n        return uint256(toBytes32(_bytes));\r\n    }\r\n\r\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\r\n        bytes memory nibbles = new bytes(_bytes.length * 2);\r\n\r\n        for (uint256 i = 0; i < _bytes.length; i++) {\r\n            nibbles[i * 2] = _bytes[i] >> 4;\r\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\r\n        }\r\n\r\n        return nibbles;\r\n    }\r\n\r\n    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\r\n        bytes memory ret = new bytes(_bytes.length / 2);\r\n\r\n        for (uint256 i = 0; i < ret.length; i++) {\r\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\r\n        return keccak256(_bytes) == keccak256(_other);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/utils/Lib_Bytes32Utils.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * @title Lib_Byte32Utils\r\n */\r\nlibrary Lib_Bytes32Utils {\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    /**\r\n     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to \"true.\"\r\n     * @param _in Input bytes32 value.\r\n     * @return Bytes32 as a boolean.\r\n     */\r\n    function toBool(bytes32 _in) internal pure returns (bool) {\r\n        return _in != 0;\r\n    }\r\n\r\n    /**\r\n     * Converts a boolean to a bytes32 value.\r\n     * @param _in Input boolean value.\r\n     * @return Boolean as a bytes32.\r\n     */\r\n    function fromBool(bool _in) internal pure returns (bytes32) {\r\n        return bytes32(uint256(_in ? 1 : 0));\r\n    }\r\n\r\n    /**\r\n     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.\r\n     * @param _in Input bytes32 value.\r\n     * @return Bytes32 as an address.\r\n     */\r\n    function toAddress(bytes32 _in) internal pure returns (address) {\r\n        return address(uint160(uint256(_in)));\r\n    }\r\n\r\n    /**\r\n     * Converts an address to a bytes32.\r\n     * @param _in Input address value.\r\n     * @return Address as a bytes32.\r\n     */\r\n    function fromAddress(address _in) internal pure returns (bytes32) {\r\n        return bytes32(uint256(uint160(_in)));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/codec/Lib_OVMCodec.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/* Library Imports */\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Lib_OVMCodec\r\n */\r\nlibrary Lib_OVMCodec {\r\n    /*********\r\n     * Enums *\r\n     *********/\r\n\r\n    enum QueueOrigin {\r\n        SEQUENCER_QUEUE,\r\n        L1TOL2_QUEUE\r\n    }\r\n\r\n    /***********\r\n     * Structs *\r\n     ***********/\r\n\r\n    struct EVMAccount {\r\n        uint256 nonce;\r\n        uint256 balance;\r\n        bytes32 storageRoot;\r\n        bytes32 codeHash;\r\n    }\r\n\r\n    struct ChainBatchHeader {\r\n        uint256 batchIndex;\r\n        bytes32 batchRoot;\r\n        uint256 batchSize;\r\n        uint256 prevTotalElements;\r\n        bytes extraData;\r\n    }\r\n\r\n    struct ChainInclusionProof {\r\n        uint256 index;\r\n        bytes32[] siblings;\r\n    }\r\n\r\n    struct Transaction {\r\n        uint256 timestamp;\r\n        uint256 blockNumber;\r\n        QueueOrigin l1QueueOrigin;\r\n        address l1TxOrigin;\r\n        address entrypoint;\r\n        uint256 gasLimit;\r\n        bytes data;\r\n    }\r\n\r\n    struct TransactionChainElement {\r\n        bool isSequenced;\r\n        uint256 queueIndex; // QUEUED TX ONLY\r\n        uint256 timestamp; // SEQUENCER TX ONLY\r\n        uint256 blockNumber; // SEQUENCER TX ONLY\r\n        bytes txData; // SEQUENCER TX ONLY\r\n    }\r\n\r\n    struct QueueElement {\r\n        bytes32 transactionHash;\r\n        uint40 timestamp;\r\n        uint40 blockNumber;\r\n    }\r\n\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    /**\r\n     * Encodes a standard OVM transaction.\r\n     * @param _transaction OVM transaction to encode.\r\n     * @return Encoded transaction bytes.\r\n     */\r\n    function encodeTransaction(Transaction memory _transaction)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            abi.encodePacked(\r\n                _transaction.timestamp,\r\n                _transaction.blockNumber,\r\n                _transaction.l1QueueOrigin,\r\n                _transaction.l1TxOrigin,\r\n                _transaction.entrypoint,\r\n                _transaction.gasLimit,\r\n                _transaction.data\r\n            );\r\n    }\r\n\r\n    /**\r\n     * Hashes a standard OVM transaction.\r\n     * @param _transaction OVM transaction to encode.\r\n     * @return Hashed transaction\r\n     */\r\n    function hashTransaction(Transaction memory _transaction) internal pure returns (bytes32) {\r\n        return keccak256(encodeTransaction(_transaction));\r\n    }\r\n\r\n    /**\r\n     * @notice Decodes an RLP-encoded account state into a useful struct.\r\n     * @param _encoded RLP-encoded account state.\r\n     * @return Account state struct.\r\n     */\r\n    function decodeEVMAccount(bytes memory _encoded) internal pure returns (EVMAccount memory) {\r\n        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\r\n\r\n        return\r\n            EVMAccount({\r\n                nonce: Lib_RLPReader.readUint256(accountState[0]),\r\n                balance: Lib_RLPReader.readUint256(accountState[1]),\r\n                storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\r\n                codeHash: Lib_RLPReader.readBytes32(accountState[3])\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Calculates a hash for a given batch header.\r\n     * @param _batchHeader Header to hash.\r\n     * @return Hash of the header.\r\n     */\r\n    function hashBatchHeader(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    _batchHeader.batchRoot,\r\n                    _batchHeader.batchSize,\r\n                    _batchHeader.prevTotalElements,\r\n                    _batchHeader.extraData\r\n                )\r\n            );\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/utils/Lib_MerkleTree.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * @title Lib_MerkleTree\r\n * @author River Keefer\r\n */\r\nlibrary Lib_MerkleTree {\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    /**\r\n     * Calculates a merkle root for a list of 32-byte leaf hashes.  WARNING: If the number\r\n     * of leaves passed in is not a power of two, it pads out the tree with zero hashes.\r\n     * If you do not know the original length of elements for the tree you are verifying, then\r\n     * this may allow empty leaves past _elements.length to pass a verification check down the line.\r\n     * Note that the _elements argument is modified, therefore it must not be used again afterwards\r\n     * @param _elements Array of hashes from which to generate a merkle root.\r\n     * @return Merkle root of the leaves, with zero hashes for non-powers-of-two (see above).\r\n     */\r\n    function getMerkleRoot(bytes32[] memory _elements) internal pure returns (bytes32) {\r\n        require(_elements.length > 0, \"Lib_MerkleTree: Must provide at least one leaf hash.\");\r\n\r\n        if (_elements.length == 1) {\r\n            return _elements[0];\r\n        }\r\n\r\n        uint256[16] memory defaults = [\r\n            0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563,\r\n            0x633dc4d7da7256660a892f8f1604a44b5432649cc8ec5cb3ced4c4e6ac94dd1d,\r\n            0x890740a8eb06ce9be422cb8da5cdafc2b58c0a5e24036c578de2a433c828ff7d,\r\n            0x3b8ec09e026fdc305365dfc94e189a81b38c7597b3d941c279f042e8206e0bd8,\r\n            0xecd50eee38e386bd62be9bedb990706951b65fe053bd9d8a521af753d139e2da,\r\n            0xdefff6d330bb5403f63b14f33b578274160de3a50df4efecf0e0db73bcdd3da5,\r\n            0x617bdd11f7c0a11f49db22f629387a12da7596f9d1704d7465177c63d88ec7d7,\r\n            0x292c23a9aa1d8bea7e2435e555a4a60e379a5a35f3f452bae60121073fb6eead,\r\n            0xe1cea92ed99acdcb045a6726b2f87107e8a61620a232cf4d7d5b5766b3952e10,\r\n            0x7ad66c0a68c72cb89e4fb4303841966e4062a76ab97451e3b9fb526a5ceb7f82,\r\n            0xe026cc5a4aed3c22a58cbd3d2ac754c9352c5436f638042dca99034e83636516,\r\n            0x3d04cffd8b46a874edf5cfae63077de85f849a660426697b06a829c70dd1409c,\r\n            0xad676aa337a485e4728a0b240d92b3ef7b3c372d06d189322bfd5f61f1e7203e,\r\n            0xa2fca4a49658f9fab7aa63289c91b7c7b6c832a6d0e69334ff5b0a3483d09dab,\r\n            0x4ebfd9cd7bca2505f7bef59cc1c12ecc708fff26ae4af19abe852afe9e20c862,\r\n            0x2def10d13dd169f550f578bda343d9717a138562e0093b380a1120789d53cf10\r\n        ];\r\n\r\n        // Reserve memory space for our hashes.\r\n        bytes memory buf = new bytes(64);\r\n\r\n        // We'll need to keep track of left and right siblings.\r\n        bytes32 leftSibling;\r\n        bytes32 rightSibling;\r\n\r\n        // Number of non-empty nodes at the current depth.\r\n        uint256 rowSize = _elements.length;\r\n\r\n        // Current depth, counting from 0 at the leaves\r\n        uint256 depth = 0;\r\n\r\n        // Common sub-expressions\r\n        uint256 halfRowSize; // rowSize / 2\r\n        bool rowSizeIsOdd; // rowSize % 2 == 1\r\n\r\n        while (rowSize > 1) {\r\n            halfRowSize = rowSize / 2;\r\n            rowSizeIsOdd = rowSize % 2 == 1;\r\n\r\n            for (uint256 i = 0; i < halfRowSize; i++) {\r\n                leftSibling = _elements[(2 * i)];\r\n                rightSibling = _elements[(2 * i) + 1];\r\n                assembly {\r\n                    mstore(add(buf, 32), leftSibling)\r\n                    mstore(add(buf, 64), rightSibling)\r\n                }\r\n\r\n                _elements[i] = keccak256(buf);\r\n            }\r\n\r\n            if (rowSizeIsOdd) {\r\n                leftSibling = _elements[rowSize - 1];\r\n                rightSibling = bytes32(defaults[depth]);\r\n                assembly {\r\n                    mstore(add(buf, 32), leftSibling)\r\n                    mstore(add(buf, 64), rightSibling)\r\n                }\r\n\r\n                _elements[halfRowSize] = keccak256(buf);\r\n            }\r\n\r\n            rowSize = halfRowSize + (rowSizeIsOdd ? 1 : 0);\r\n            depth++;\r\n        }\r\n\r\n        return _elements[0];\r\n    }\r\n\r\n    /**\r\n     * Verifies a merkle branch for the given leaf hash.  Assumes the original length\r\n     * of leaves generated is a known, correct input, and does not return true for indices\r\n     * extending past that index (even if _siblings would be otherwise valid.)\r\n     * @param _root The Merkle root to verify against.\r\n     * @param _leaf The leaf hash to verify inclusion of.\r\n     * @param _index The index in the tree of this leaf.\r\n     * @param _siblings Array of sibline nodes in the inclusion proof, starting from depth 0\r\n     * (bottom of the tree).\r\n     * @param _totalLeaves The total number of leaves originally passed into.\r\n     * @return Whether or not the merkle branch and leaf passes verification.\r\n     */\r\n    function verify(\r\n        bytes32 _root,\r\n        bytes32 _leaf,\r\n        uint256 _index,\r\n        bytes32[] memory _siblings,\r\n        uint256 _totalLeaves\r\n    ) internal pure returns (bool) {\r\n        require(_totalLeaves > 0, \"Lib_MerkleTree: Total leaves must be greater than zero.\");\r\n\r\n        require(_index < _totalLeaves, \"Lib_MerkleTree: Index out of bounds.\");\r\n\r\n        require(\r\n            _siblings.length == _ceilLog2(_totalLeaves),\r\n            \"Lib_MerkleTree: Total siblings does not correctly correspond to total leaves.\"\r\n        );\r\n\r\n        bytes32 computedRoot = _leaf;\r\n\r\n        for (uint256 i = 0; i < _siblings.length; i++) {\r\n            if ((_index & 1) == 1) {\r\n                computedRoot = keccak256(abi.encodePacked(_siblings[i], computedRoot));\r\n            } else {\r\n                computedRoot = keccak256(abi.encodePacked(computedRoot, _siblings[i]));\r\n            }\r\n\r\n            _index >>= 1;\r\n        }\r\n\r\n        return _root == computedRoot;\r\n    }\r\n\r\n    /*********************\r\n     * Private Functions *\r\n     *********************/\r\n\r\n    /**\r\n     * Calculates the integer ceiling of the log base 2 of an input.\r\n     * @param _in Unsigned input to calculate the log.\r\n     * @return ceil(log_base_2(_in))\r\n     */\r\n    function _ceilLog2(uint256 _in) private pure returns (uint256) {\r\n        require(_in > 0, \"Lib_MerkleTree: Cannot compute ceil(log_2) of 0.\");\r\n\r\n        if (_in == 1) {\r\n            return 0;\r\n        }\r\n\r\n        // Find the highest set bit (will be floor(log_2)).\r\n        // Borrowed with <3 from https://github.com/ethereum/solidity-examples\r\n        uint256 val = _in;\r\n        uint256 highest = 0;\r\n        for (uint256 i = 128; i >= 1; i >>= 1) {\r\n            if (val & (((uint256(1) << i) - 1) << i) != 0) {\r\n                highest += i;\r\n                val >>= i;\r\n            }\r\n        }\r\n\r\n        // Increment by one if this is not a perfect logarithm.\r\n        if ((uint256(1) << highest) != _in) {\r\n            highest += 1;\r\n        }\r\n\r\n        return highest;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/L1/rollup/IChainStorageContainer.sol\r\n\r\n// : MIT\r\npragma solidity >0.5.0 <0.9.0;\r\n\r\n/**\r\n * @title IChainStorageContainer\r\n */\r\ninterface IChainStorageContainer {\r\n    /********************\r\n     * Public Functions *\r\n     ********************/\r\n\r\n    /**\r\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\r\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\r\n     * 27 bytes to store arbitrary data.\r\n     * @param _globalMetadata New global metadata to set.\r\n     */\r\n    function setGlobalMetadata(bytes27 _globalMetadata) external;\r\n\r\n    /**\r\n     * Retrieves the container's global metadata field.\r\n     * @return Container global metadata field.\r\n     */\r\n    function getGlobalMetadata() external view returns (bytes27);\r\n\r\n    /**\r\n     * Retrieves the number of objects stored in the container.\r\n     * @return Number of objects in the container.\r\n     */\r\n    function length() external view returns (uint256);\r\n\r\n    /**\r\n     * Pushes an object into the container.\r\n     * @param _object A 32 byte value to insert into the container.\r\n     */\r\n    function push(bytes32 _object) external;\r\n\r\n    /**\r\n     * Pushes an object into the container. Function allows setting the global metadata since\r\n     * we'll need to touch the \"length\" storage slot anyway, which also contains the global\r\n     * metadata (it's an optimization).\r\n     * @param _object A 32 byte value to insert into the container.\r\n     * @param _globalMetadata New global metadata for the container.\r\n     */\r\n    function push(bytes32 _object, bytes27 _globalMetadata) external;\r\n\r\n    /**\r\n     * Set an object into the container. Function allows setting the global metadata since\r\n     * we'll need to touch the \"length\" storage slot anyway, which also contains the global\r\n     * metadata (it's an optimization).\r\n     * @param _index position.\r\n     * @param _object A 32 byte value to insert into the container.\r\n     */  \r\n    function setByChainId(\r\n        uint256 _chainId,\r\n        uint256 _index,\r\n        bytes32 _object\r\n    )\r\n        external;\r\n        \r\n    /**\r\n     * Retrieves an object from the container.\r\n     * @param _index Index of the particular object to access.\r\n     * @return 32 byte object value.\r\n     */\r\n    function get(uint256 _index) external view returns (bytes32);\r\n\r\n    /**\r\n     * Removes all objects after and including a given index.\r\n     * @param _index Object index to delete from.\r\n     */\r\n    function deleteElementsAfterInclusive(uint256 _index) external;\r\n\r\n    /**\r\n     * Removes all objects after and including a given index. Also allows setting the global\r\n     * metadata field.\r\n     * @param _index Object index to delete from.\r\n     * @param _globalMetadata New global metadata for the container.\r\n     */\r\n    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata) external;\r\n\r\n    /**\r\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\r\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\r\n     * 27 bytes to store arbitrary data.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _globalMetadata New global metadata to set.\r\n     */\r\n    function setGlobalMetadataByChainId(\r\n        uint256 _chainId,\r\n        bytes27 _globalMetadata\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Retrieves the container's global metadata field.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return Container global metadata field.\r\n     */\r\n    function getGlobalMetadataByChainId(\r\n        uint256 _chainId\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            bytes27\r\n        );\r\n\r\n    /**\r\n     * Retrieves the number of objects stored in the container.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return Number of objects in the container.\r\n     */\r\n    function lengthByChainId(\r\n        uint256 _chainId\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint256\r\n        );\r\n\r\n    /**\r\n     * Pushes an object into the container.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _object A 32 byte value to insert into the container.\r\n     */\r\n    function pushByChainId(\r\n        uint256 _chainId,\r\n        bytes32 _object\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Pushes an object into the container. Function allows setting the global metadata since\r\n     * we'll need to touch the \"length\" storage slot anyway, which also contains the global\r\n     * metadata (it's an optimization).\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _object A 32 byte value to insert into the container.\r\n     * @param _globalMetadata New global metadata for the container.\r\n     */\r\n    function pushByChainId(\r\n        uint256 _chainId,\r\n        bytes32 _object,\r\n        bytes27 _globalMetadata\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Retrieves an object from the container.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _index Index of the particular object to access.\r\n     * @return 32 byte object value.\r\n     */\r\n    function getByChainId(\r\n        uint256 _chainId,\r\n        uint256 _index\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32\r\n        );\r\n\r\n    /**\r\n     * Removes all objects after and including a given index.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _index Object index to delete from.\r\n     */\r\n    function deleteElementsAfterInclusiveByChainId(\r\n        uint256 _chainId,\r\n        uint256 _index\r\n    )\r\n        external;\r\n        \r\n    /**\r\n     * Removes all objects after and including a given index. Also allows setting the global\r\n     * metadata field.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _index Object index to delete from.\r\n     * @param _globalMetadata New global metadata for the container.\r\n     */\r\n    function deleteElementsAfterInclusiveByChainId(\r\n        uint256 _chainId,\r\n        uint256 _index,\r\n        bytes27 _globalMetadata\r\n    )\r\n        external;\r\n        \r\n}\r\n\r\n\r\n// File contracts/L1/rollup/IStateCommitmentChain.sol\r\n\r\n// : MIT\r\npragma solidity >0.5.0 <0.9.0;\r\n\r\n/* Library Imports */\r\n\r\n\r\n/**\r\n * @title IStateCommitmentChain\r\n */\r\ninterface IStateCommitmentChain {\r\n    /**********\r\n     * Events *\r\n     **********/\r\n\r\n    event StateBatchAppended(\r\n        uint256 _chainId,\r\n        uint256 indexed _batchIndex,\r\n        bytes32 _batchRoot,\r\n        uint256 _batchSize,\r\n        uint256 _prevTotalElements,\r\n        bytes _extraData\r\n    );\r\n\r\n    event StateBatchDeleted(\r\n        uint256 _chainId,\r\n        uint256 indexed _batchIndex,\r\n        bytes32 _batchRoot\r\n    );\r\n\r\n\r\n    /********************\r\n     * Public Functions *\r\n     ********************/\r\n    \r\n    function batches() external view returns (IChainStorageContainer);\r\n    \r\n    /**\r\n     * Retrieves the total number of elements submitted.\r\n     * @return _totalElements Total submitted elements.\r\n     */\r\n    function getTotalElements() external view returns (uint256 _totalElements);\r\n\r\n    /**\r\n     * Retrieves the total number of batches submitted.\r\n     * @return _totalBatches Total submitted batches.\r\n     */\r\n    function getTotalBatches() external view returns (uint256 _totalBatches);\r\n\r\n    /**\r\n     * Retrieves the timestamp of the last batch submitted by the sequencer.\r\n     * @return _lastSequencerTimestamp Last sequencer batch timestamp.\r\n     */\r\n    function getLastSequencerTimestamp() external view returns (uint256 _lastSequencerTimestamp);\r\n\r\n    /**\r\n     * Appends a batch of state roots to the chain.\r\n     * @param _batch Batch of state roots.\r\n     * @param _shouldStartAtElement Index of the element at which this batch should start.\r\n     */\r\n    function appendStateBatch(bytes32[] calldata _batch, uint256 _shouldStartAtElement) external;\r\n\r\n    /**\r\n     * Deletes all state roots after (and including) a given batch.\r\n     * @param _batchHeader Header of the batch to start deleting from.\r\n     */\r\n    function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) external;\r\n\r\n    /**\r\n     * Verifies a batch inclusion proof.\r\n     * @param _element Hash of the element to verify a proof for.\r\n     * @param _batchHeader Header of the batch in which the element was included.\r\n     * @param _proof Merkle inclusion proof for the element.\r\n     */\r\n    function verifyStateCommitment(\r\n        bytes32 _element,\r\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\r\n        Lib_OVMCodec.ChainInclusionProof memory _proof\r\n    ) external view returns (bool _verified);\r\n\r\n    /**\r\n     * Checks whether a given batch is still inside its fraud proof window.\r\n     * @param _batchHeader Header of the batch to check.\r\n     * @return _inside Whether or not the batch is inside the fraud proof window.\r\n     */\r\n    function insideFraudProofWindow(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\r\n        external\r\n        view\r\n        returns (\r\n            bool _inside\r\n        );\r\n        \r\n        \r\n        \r\n     /********************\r\n     * chain id added func *\r\n     ********************/\r\n\r\n    /**\r\n     * Retrieves the total number of elements submitted.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return _totalElements Total submitted elements.\r\n     */\r\n    function getTotalElementsByChainId(uint256 _chainId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 _totalElements\r\n        );\r\n\r\n    /**\r\n     * Retrieves the total number of batches submitted.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return _totalBatches Total submitted batches.\r\n     */\r\n    function getTotalBatchesByChainId(uint256 _chainId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 _totalBatches\r\n        );\r\n\r\n    /**\r\n     * Retrieves the timestamp of the last batch submitted by the sequencer.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return _lastSequencerTimestamp Last sequencer batch timestamp.\r\n     */\r\n    function getLastSequencerTimestampByChainId(uint256 _chainId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 _lastSequencerTimestamp\r\n        );\r\n        \r\n    /**\r\n     * Appends a batch of state roots to the chain.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _batch Batch of state roots.\r\n     * @param _shouldStartAtElement Index of the element at which this batch should start.\r\n     */\r\n    function appendStateBatchByChainId(\r\n        uint256 _chainId,\r\n        bytes32[] calldata _batch,\r\n        uint256 _shouldStartAtElement,\r\n        string calldata proposer\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Deletes all state roots after (and including) a given batch.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _batchHeader Header of the batch to start deleting from.\r\n     */\r\n    function deleteStateBatchByChainId(\r\n        uint256 _chainId,\r\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Verifies a batch inclusion proof.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _element Hash of the element to verify a proof for.\r\n     * @param _batchHeader Header of the batch in which the element was included.\r\n     * @param _proof Merkle inclusion proof for the element.\r\n     */\r\n    function verifyStateCommitmentByChainId(\r\n        uint256 _chainId,\r\n        bytes32 _element,\r\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\r\n        Lib_OVMCodec.ChainInclusionProof memory _proof\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bool _verified\r\n        );\r\n\r\n    /**\r\n     * Checks whether a given batch is still inside its fraud proof window.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _batchHeader Header of the batch to check.\r\n     * @return _inside Whether or not the batch is inside the fraud proof window.\r\n     */\r\n    function insideFraudProofWindowByChainId(\r\n        uint256 _chainId,\r\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bool _inside\r\n        );\r\n}\r\n\r\n\r\n// File contracts/MVM/MVM_Verifier.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n/* Contract Imports */\r\n/* External Imports */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MVM_Verifier is Lib_AddressResolver{\r\n    // second slot\r\n    address public metis;\r\n\r\n    enum SETTLEMENT {NOT_ENOUGH_VERIFIER, SAME_ROOT, AGREE, DISAGREE, PASS}\r\n\r\n    event NewChallenge(uint256 cIndex, uint256 chainID, Lib_OVMCodec.ChainBatchHeader header, uint256 timestamp);\r\n    event Verify1(uint256 cIndex, address verifier);\r\n    event Verify2(uint256 cIndex, address verifier);\r\n    event Finalize(uint256 cIndex, address sender, SETTLEMENT result);\r\n    event Penalize(address sender, uint256 stakeLost);\r\n    event Reward(address target, uint256 amount);\r\n    event Claim(address sender, uint256 amount);\r\n    event Withdraw(address sender, uint256 amount);\r\n    event Stake(address verifier, uint256 amount);\r\n    event SlashSequencer(uint256 chainID, address seq);\r\n\r\n    /*************\r\n     * Constants *\r\n     *************/\r\n    string constant public CONFIG_OWNER_KEY = \"METIS_MANAGER\";\r\n\r\n    //challenge info\r\n    struct Challenge {\r\n       address challenger;\r\n       uint256 chainID;\r\n       uint256 index;\r\n       Lib_OVMCodec.ChainBatchHeader header;\r\n       uint256 timestamp;\r\n       uint256 numQualifiedVerifiers;\r\n       uint256 numVerifiers;\r\n       address[] verifiers;\r\n       bool done;\r\n    }\r\n\r\n    mapping (address => uint256) public verifier_stakes;\r\n    mapping (uint256 => mapping (address=>bytes)) private challenge_keys;\r\n    mapping (uint256 => mapping (address=>bytes)) private challenge_key_hashes;\r\n    mapping (uint256 => mapping (address=>bytes)) private challenge_hashes;\r\n\r\n    mapping (address => uint256) public rewards;\r\n    mapping (address => uint8) public absence_strikes;\r\n    mapping (address => uint8) public consensus_strikes;\r\n\r\n    // only one active challenge for each chain  chainid=>cIndex\r\n    mapping (uint256 => uint256) public chain_under_challenge;\r\n\r\n    // white list\r\n    mapping (address => bool) public whitelist;\r\n    bool useWhiteList;\r\n\r\n    address[] public verifiers;\r\n    Challenge[] public challenges;\r\n\r\n    uint public verifyWindow = 3600 * 24; // 24 hours of window to complete the each verify phase\r\n    uint public activeChallenges;\r\n\r\n    uint256 public minStake;\r\n    uint256 public seqStake;\r\n\r\n    uint256 public numQualifiedVerifiers;\r\n\r\n    uint FAIL_THRESHOLD = 2;  // 1 time grace\r\n    uint ABSENCE_THRESHOLD = 4;  // 2 times grace\r\n\r\n    modifier onlyManager {\r\n        require(\r\n            msg.sender == resolve(CONFIG_OWNER_KEY),\r\n            \"MVM_Verifier: Function can only be called by the METIS_MANAGER.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhitelisted {\r\n        require(isWhiteListed(msg.sender), \"only whitelisted verifiers can call\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyStaked {\r\n        require(isSufficientlyStaked(msg.sender), \"insufficient stake\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n      address _addressManager,\r\n      address _metis\r\n    )\r\n      Lib_AddressResolver(_addressManager)\r\n    {\r\n       minStake = 200 ether;  // 200 metis\r\n       metis = _metis;\r\n       useWhiteList = true;\r\n    }\r\n\r\n    // add stake as a verifier\r\n    function verifierStake(uint256 stake) public onlyWhitelisted{\r\n       require(activeChallenges == 0, \"stake is currently prohibited\"); //ongoing challenge\r\n       require(stake > 0, \"zero stake not allowed\");\r\n       require(IERC20(metis).transferFrom(msg.sender, address(this), stake), \"transfer metis failed\");\r\n\r\n       uint256 previousBalance = verifier_stakes[msg.sender];\r\n       verifier_stakes[msg.sender] += stake;\r\n\r\n       require(isSufficientlyStaked(msg.sender), \"insufficient stake to qualify as a verifier\");\r\n\r\n       if (previousBalance == 0) {\r\n          numQualifiedVerifiers++;\r\n          verifiers.push(msg.sender);\r\n       }\r\n\r\n       emit Stake(msg.sender, stake);\r\n    }\r\n\r\n    // start a new challenge\r\n    // @param chainID chainid\r\n    // @param header chainbatch header\r\n    // @param proposedHash encrypted hash of the correct state\r\n    // @param keyhash hash of the decryption key\r\n    //\r\n    // @dev why do we ask for key and keyhash? because we want verifiers compute the state instead\r\n    // of just copying from other verifiers.\r\n    function newChallenge(uint256 chainID, Lib_OVMCodec.ChainBatchHeader calldata header, bytes calldata proposedHash, bytes calldata keyhash)\r\n       public onlyWhitelisted onlyStaked {\r\n\r\n       uint tempIndex = chain_under_challenge[chainID] - 1;\r\n       require(tempIndex == 0 || block.timestamp - challenges[tempIndex].timestamp > verifyWindow * 2, \"there is an ongoing challenge\");\r\n       if (tempIndex > 0) {\r\n          finalize(tempIndex);\r\n       }\r\n       IStateCommitmentChain stateChain = IStateCommitmentChain(resolve(\"StateCommitmentChain\"));\r\n\r\n       // while the root is encrypted, the timestamp is available in the extradata field of the header\r\n       require(stateChain.insideFraudProofWindow(header), \"the batch is outside of the fraud proof window\");\r\n\r\n       Challenge memory c;\r\n       c.chainID = chainID;\r\n       c.challenger = msg.sender;\r\n       c.timestamp = block.timestamp;\r\n       c.header = header;\r\n\r\n       challenges.push(c);\r\n       uint cIndex = challenges.length - 1;\r\n\r\n       // house keeping\r\n       challenge_hashes[cIndex][msg.sender] = proposedHash;\r\n       challenge_key_hashes[cIndex][msg.sender] = keyhash;\r\n       challenges[cIndex].numVerifiers++; // the challenger\r\n\r\n       // this will prevent stake change\r\n       activeChallenges++;\r\n\r\n       chain_under_challenge[chainID] = cIndex + 1; // +1 because 0 means no in-progress challenge\r\n       emit NewChallenge(cIndex, chainID, header, block.timestamp);\r\n    }\r\n\r\n    // phase 1 of the verify, provide an encrypted hash and the hash of the decryption key\r\n    // @param cIndex index of the challenge\r\n    // @param hash encrypted hash of the correct state (for the index referred in the challenge)\r\n    // @param keyhash hash of the decryption key\r\n    function verify1(uint256 cIndex, bytes calldata hash, bytes calldata keyhash) public onlyWhitelisted onlyStaked{\r\n       require(challenge_hashes[cIndex][msg.sender].length == 0, \"verify1 already completed for the sender\");\r\n       challenge_hashes[cIndex][msg.sender] = hash;\r\n       challenge_key_hashes[cIndex][msg.sender] = keyhash;\r\n       challenges[cIndex].numVerifiers++;\r\n       emit Verify1(cIndex, msg.sender);\r\n    }\r\n\r\n    // phase 2 of the verify, provide the actual key to decrypt the hash\r\n    // @param cIndex index of the challenge\r\n    // @param key the decryption key\r\n    function verify2(uint256 cIndex, bytes calldata key) public onlyStaked onlyWhitelisted{\r\n        require(challenges[cIndex].numVerifiers == numQualifiedVerifiers\r\n               || block.timestamp - challenges[cIndex].timestamp > verifyWindow, \"phase 2 not ready\");\r\n        require(challenge_hashes[cIndex][msg.sender].length > 0, \"you didn't participate in phase 1\");\r\n        if (challenge_keys[cIndex][msg.sender].length > 0) {\r\n            finalize(cIndex);\r\n            return;\r\n        }\r\n\r\n        //verify whether the key matches the keyhash initially provided.\r\n        require(sha256(key) == bytes32(challenge_key_hashes[cIndex][msg.sender]), \"key and keyhash don't match\");\r\n\r\n        if (msg.sender == challenges[cIndex].challenger) {\r\n            //decode the root in the header too\r\n            challenges[cIndex].header.batchRoot = bytes32(decrypt(abi.encodePacked(challenges[cIndex].header.batchRoot), key));\r\n        }\r\n        challenge_keys[cIndex][msg.sender] = key;\r\n        challenge_hashes[cIndex][msg.sender] = decrypt(challenge_hashes[cIndex][msg.sender], key);\r\n        challenges[cIndex].verifiers.push(msg.sender);\r\n        emit Verify2(cIndex, msg.sender);\r\n\r\n        finalize(cIndex);\r\n    }\r\n\r\n    function finalize(uint256 cIndex) internal {\r\n\r\n        Challenge storage challenge = challenges[cIndex];\r\n\r\n        require(challenge.done == false, \"challenge is closed\");\r\n\r\n        if (challenge.verifiers.length != challenge.numVerifiers\r\n           && block.timestamp - challenge.timestamp < verifyWindow * 2) {\r\n           // not ready to finalize. do nothing\r\n           return;\r\n        }\r\n\r\n        IStateCommitmentChain stateChain = IStateCommitmentChain(resolve(\"StateCommitmentChain\"));\r\n        bytes32 proposedHash = bytes32(challenge_hashes[cIndex][challenge.challenger]);\r\n\r\n        uint reward = 0;\r\n\r\n        address[] memory agrees = new address[](challenge.verifiers.length);\r\n        uint numAgrees = 0;\r\n        address[] memory disagrees = new address[](challenge.verifiers.length);\r\n        uint numDisagrees = 0;\r\n\r\n        for (uint256 i = 0; i < verifiers.length; i++) {\r\n            if (!isSufficientlyStaked(verifiers[i]) || !isWhiteListed(verifiers[i])) {\r\n                // not qualified as a verifier\r\n                continue;\r\n            }\r\n\r\n            //record the agreement\r\n            if (bytes32(challenge_hashes[cIndex][verifiers[i]]) == proposedHash) {\r\n                //agree with the challenger\r\n                if (absence_strikes[verifiers[i]] > 0) {\r\n                    absence_strikes[verifiers[i]] -= 1; // slowly clear the strike\r\n                }\r\n                agrees[numAgrees] = verifiers[i];\r\n                numAgrees++;\r\n            } else if (challenge_keys[cIndex][verifiers[i]].length == 0) {\r\n                //absent\r\n                absence_strikes[verifiers[i]] += 2;\r\n                if (absence_strikes[verifiers[i]] > ABSENCE_THRESHOLD) {\r\n                    reward += penalize(verifiers[i]);\r\n                }\r\n            } else {\r\n                //disagree with the challenger\r\n                if (absence_strikes[verifiers[i]] > 0) {\r\n                    absence_strikes[verifiers[i]] -= 1; // slowly clear the strike\r\n                }\r\n                disagrees[numDisagrees] = verifiers[i];\r\n                numDisagrees++;\r\n            }\r\n        }\r\n\r\n        if (Lib_OVMCodec.hashBatchHeader(challenge.header) !=\r\n                stateChain.batches().getByChainId(challenge.chainID, challenge.header.batchIndex)) {\r\n            // wrong header, penalize the challenger\r\n            reward += penalize(challenge.challenger);\r\n\r\n            // reward the disagrees. but no penalty on agrees because the input\r\n            // is garbage.\r\n            distributeReward(reward, disagrees, challenge.verifiers.length - 1);\r\n            emit Finalize(cIndex, msg.sender, SETTLEMENT.DISAGREE);\r\n\r\n        } else if (challenge.verifiers.length < numQualifiedVerifiers * 75 / 100) {\r\n            // the absent verifiers get a absense strike. no other penalties. already done\r\n            emit Finalize(cIndex, msg.sender, SETTLEMENT.NOT_ENOUGH_VERIFIER);\r\n        }\r\n        else if (proposedHash != challenge.header.batchRoot) {\r\n            if (numAgrees <= numDisagrees) {\r\n               // no consensus, challenge failed.\r\n               for (uint i = 0; i < numAgrees; i++) {\r\n                    consensus_strikes[agrees[i]] += 2;\r\n                    if (consensus_strikes[agrees[i]] > FAIL_THRESHOLD) {\r\n                        reward += penalize(agrees[i]);\r\n                    }\r\n               }\r\n               distributeReward(reward, disagrees, disagrees.length);\r\n               emit Finalize(cIndex, msg.sender, SETTLEMENT.DISAGREE);\r\n            } else {\r\n               // reached agreement. delete the batch root and slash the sequencer if the header is still valid\r\n               if(stateChain.insideFraudProofWindow(challenge.header)) {\r\n                    // this header needs to be within the window\r\n                    stateChain.deleteStateBatchByChainId(challenge.chainID, challenge.header);\r\n\r\n                    // temporary for the p1 of the decentralization roadmap\r\n                    if (seqStake > 0) {\r\n                        reward += seqStake;\r\n\r\n                        for (uint i = 0; i < numDisagrees; i++) {\r\n                            consensus_strikes[disagrees[i]] += 2;\r\n                            if (consensus_strikes[disagrees[i]] > FAIL_THRESHOLD) {\r\n                                reward += penalize(disagrees[i]);\r\n                            }\r\n                        }\r\n                        distributeReward(reward, agrees, agrees.length);\r\n                    }\r\n                    emit Finalize(cIndex, msg.sender, SETTLEMENT.AGREE);\r\n                } else {\r\n                    //not in the window anymore. let it pass... no penalty\r\n                    emit Finalize(cIndex, msg.sender, SETTLEMENT.PASS);\r\n                }\r\n            }\r\n        } else {\r\n            //wasteful challenge, add consensus_strikes to the challenger\r\n            consensus_strikes[challenge.challenger] += 2;\r\n            if (consensus_strikes[challenge.challenger] > FAIL_THRESHOLD) {\r\n                reward += penalize(challenge.challenger);\r\n            }\r\n            distributeReward(reward, challenge.verifiers, challenge.verifiers.length - 1);\r\n            emit Finalize(cIndex, msg.sender, SETTLEMENT.SAME_ROOT);\r\n        }\r\n\r\n        challenge.done = true;\r\n        activeChallenges--;\r\n        chain_under_challenge[challenge.chainID] = 0;\r\n    }\r\n\r\n    function depositSeqStake(uint256 amount) public onlyManager {\r\n        require(IERC20(metis).transferFrom(msg.sender, address(this), amount), \"transfer metis failed\");\r\n        seqStake += amount;\r\n        emit Stake(msg.sender, amount);\r\n    }\r\n\r\n    function withdrawSeqStake(address to) public onlyManager {\r\n        require(seqStake > 0, \"no stake\");\r\n        emit Withdraw(msg.sender, seqStake);\r\n        uint256 amount = seqStake;\r\n        seqStake = 0;\r\n\r\n        require(IERC20(metis).transfer(to, amount), \"transfer metis failed\");\r\n    }\r\n\r\n    function claim() public {\r\n       require(rewards[msg.sender] > 0, \"no reward to claim\");\r\n       uint256 amount = rewards[msg.sender];\r\n       rewards[msg.sender] = 0;\r\n\r\n       require(IERC20(metis).transfer(msg.sender, amount), \"token transfer failed\");\r\n\r\n       emit Claim(msg.sender, amount);\r\n    }\r\n\r\n    function withdraw(uint256 amount) public {\r\n       require(activeChallenges == 0, \"withdraw is currently prohibited\"); //ongoing challenge\r\n\r\n       uint256 balance = verifier_stakes[msg.sender];\r\n       require(balance >= amount, \"insufficient stake to withdraw\");\r\n\r\n       if (balance - amount < minStake && balance >= minStake) {\r\n           numQualifiedVerifiers--;\r\n           deleteVerifier(msg.sender);\r\n       }\r\n       verifier_stakes[msg.sender] -= amount;\r\n\r\n       require(IERC20(metis).transfer(msg.sender, amount), \"token transfer failed\");\r\n    }\r\n\r\n    function setMinStake(\r\n        uint256 _minStake\r\n    )\r\n        public\r\n        onlyManager\r\n    {\r\n        minStake = _minStake;\r\n        uint num = 0;\r\n        if (verifiers.length > 0) {\r\n            address[] memory arr = new address[](verifiers.length);\r\n            for (uint i = 0; i < verifiers.length; ++i) {\r\n                if (verifier_stakes[verifiers[i]] >= minStake) {\r\n                    arr[num] = verifiers[i];\r\n                    num++;\r\n                }\r\n            }\r\n            if (num < verifiers.length) {\r\n                delete verifiers;\r\n                for (uint i = 0; i < num; i++) {\r\n                    verifiers.push(arr[i]);\r\n                }\r\n            }\r\n        }\r\n        numQualifiedVerifiers = num;\r\n    }\r\n\r\n    // helper\r\n    function isWhiteListed(address verifier) view public returns(bool){\r\n        return !useWhiteList || whitelist[verifier];\r\n    }\r\n    function isSufficientlyStaked (address target) view public returns(bool) {\r\n       return (verifier_stakes[target] >= minStake);\r\n    }\r\n\r\n    // set the length of the time windows for each verification phase\r\n    function setVerifyWindow (uint256 window) onlyManager public {\r\n        verifyWindow = window;\r\n    }\r\n\r\n    // add the verifier to the whitelist\r\n    function setWhiteList(address verifier, bool allowed) public onlyManager {\r\n        whitelist[verifier] = allowed;\r\n        useWhiteList = true;\r\n    }\r\n\r\n    // allow everyone to be the verifier\r\n    function disableWhiteList() public onlyManager {\r\n        useWhiteList = false;\r\n    }\r\n\r\n    function setThreshold(uint absence_threshold, uint fail_threshold) public onlyManager {\r\n        ABSENCE_THRESHOLD = absence_threshold;\r\n        FAIL_THRESHOLD = fail_threshold;\r\n    }\r\n\r\n    function getMerkleRoot(bytes32[] calldata elements) pure public returns (bytes32) {\r\n        return Lib_MerkleTree.getMerkleRoot(elements);\r\n    }\r\n\r\n    //helper fucntion to encrypt data\r\n    function encrypt(bytes calldata data, bytes calldata key) pure public returns (bytes memory) {\r\n      bytes memory encryptedData = data;\r\n      uint j = 0;\r\n\r\n      for (uint i = 0; i < encryptedData.length; i++) {\r\n          if (j == key.length) {\r\n             j = 0;\r\n          }\r\n          encryptedData[i] = encryptByte(encryptedData[i], uint8(key[j]));\r\n          j++;\r\n      }\r\n\r\n      return encryptedData;\r\n    }\r\n\r\n    function encryptByte(bytes1 b, uint8 k) pure internal returns (bytes1) {\r\n      uint16 temp16 = uint16(uint8(b));\r\n      temp16 += k;\r\n\r\n      if (temp16 > 255) {\r\n         temp16 -= 256;\r\n      }\r\n      return bytes1(uint8(temp16));\r\n    }\r\n\r\n    // helper fucntion to decrypt the data\r\n    function decrypt(bytes memory data, bytes memory key) pure public returns (bytes memory) {\r\n      bytes memory decryptedData = data;\r\n      uint j = 0;\r\n\r\n      for (uint i = 0; i < decryptedData.length; i++) {\r\n          if (j == key.length) {\r\n             j = 0;\r\n          }\r\n\r\n          decryptedData[i] = decryptByte(decryptedData[i], uint8(key[j]));\r\n\r\n          j++;\r\n      }\r\n\r\n      return decryptedData;\r\n    }\r\n\r\n    function decryptByte(bytes1 b, uint8 k) pure internal returns (bytes1) {\r\n      uint16 temp16 = uint16(uint8(b));\r\n      if (temp16 > k) {\r\n         temp16 -= k;\r\n      } else {\r\n         temp16 = 256 - k;\r\n      }\r\n\r\n      return bytes1(uint8(temp16));\r\n    }\r\n\r\n    // calculate the rewards\r\n    function distributeReward(uint256 amount, address[] memory list, uint num) internal {\r\n        uint reward = amount / num;\r\n        if (reward == 0) {\r\n            return;\r\n        }\r\n        uint total = 0;\r\n        for (uint i; i < list.length; i++) {\r\n            if (isSufficientlyStaked(list[i])) {\r\n               rewards[list[i]] += reward;\r\n               total += reward;\r\n               emit Reward(list[i], reward);\r\n            }\r\n        }\r\n\r\n        if (total < amount) {\r\n            if (isSufficientlyStaked(list[0])) {\r\n                rewards[list[0]] += total - amount;\r\n                emit Reward(list[0], total - amount);\r\n            } else {\r\n                rewards[list[1]] += total - amount;\r\n                emit Reward(list[1], total - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    // slash the verifier stake\r\n    function penalize(address target) internal returns(uint256) {\r\n        uint256 stake = verifier_stakes[target];\r\n        verifier_stakes[target] = 0;\r\n        numQualifiedVerifiers--;\r\n        deleteVerifier(target);\r\n        emit Penalize(target, stake);\r\n\r\n        return stake;\r\n    }\r\n\r\n    function deleteVerifier(address target) internal {\r\n        bool hasVerifier = false;\r\n        uint pos = 0;\r\n        for (uint i = 0; i < verifiers.length; i++){\r\n            if (verifiers[i] == target) {\r\n                hasVerifier = true;\r\n                pos = i;\r\n                break;\r\n            }\r\n        }\r\n        if (hasVerifier) {\r\n            for (uint i = pos; i < verifiers.length-1; i++) {\r\n                verifiers[i] = verifiers[i+1];\r\n            }\r\n            verifiers.pop();\r\n        }\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_metis\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum MVM_Verifier.SETTLEMENT\",\"name\":\"result\",\"type\":\"uint8\"}],\"name\":\"Finalize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevTotalElements\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct Lib_OVMCodec.ChainBatchHeader\",\"name\":\"header\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"NewChallenge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeLost\",\"type\":\"uint256\"}],\"name\":\"Penalize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seq\",\"type\":\"address\"}],\"name\":\"SlashSequencer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"Verify1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"Verify2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONFIG_OWNER_KEY\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"absence_strikes\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeChallenges\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"chain_under_challenge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"challenges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevTotalElements\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.ChainBatchHeader\",\"name\":\"header\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numQualifiedVerifiers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numVerifiers\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"done\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"consensus_strikes\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"key\",\"type\":\"bytes\"}],\"name\":\"decrypt\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositSeqStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"key\",\"type\":\"bytes\"}],\"name\":\"encrypt\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"elements\",\"type\":\"bytes32[]\"}],\"name\":\"getMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"isSufficientlyStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"isWhiteListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"libAddressManager\",\"outputs\":[{\"internalType\":\"contract Lib_AddressManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metis\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevTotalElements\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.ChainBatchHeader\",\"name\":\"header\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"proposedHash\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"keyhash\",\"type\":\"bytes\"}],\"name\":\"newChallenge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numQualifiedVerifiers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seqStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStake\",\"type\":\"uint256\"}],\"name\":\"setMinStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"absence_threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fail_threshold\",\"type\":\"uint256\"}],\"name\":\"setThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"window\",\"type\":\"uint256\"}],\"name\":\"setVerifyWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"verifierStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"verifier_stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"verifiers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"keyhash\",\"type\":\"bytes\"}],\"name\":\"verify1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"key\",\"type\":\"bytes\"}],\"name\":\"verify2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifyWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawSeqStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MVM_Verifier", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000918778e825747a892b17c66fe7d24c618262867d0000000000000000000000009e32b13ce7f2e80a01932b42553652e053d6ed8e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://287a7ae9ed86d3dcb62f7dbd3de7e543adf323187fc4075851cb144fbabbd6a2"}]}