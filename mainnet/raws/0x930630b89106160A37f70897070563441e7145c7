{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TokensSaleReserver.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\r\\n\\r\\n// CAUTION\\r\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\r\\n// because it relies on the compiler's built in overflow checks.\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations.\\r\\n *\\r\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\r\\n * now has built in overflow checking.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c < a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b > a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n            // benefit is lost if 'b' is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b <= a, errorMessage);\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b > 0, errorMessage);\\r\\n            return a / b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting with custom message when dividing by zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b > 0, errorMessage);\\r\\n            return a % b;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\r\\n\\r\\n/**\\r\\n * @dev Contract module which allows children to implement an emergency stop\\r\\n * mechanism that can be triggered by an authorized account.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the\\r\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\r\\n * the functions of your contract. Note that they will not be pausable by\\r\\n * simply including this module, only once the modifiers are put in place.\\r\\n */\\r\\nabstract contract Pausable is Context {\\r\\n    /**\\r\\n     * @dev Emitted when the pause is triggered by `account`.\\r\\n     */\\r\\n    event Paused(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the pause is lifted by `account`.\\r\\n     */\\r\\n    event Unpaused(address account);\\r\\n\\r\\n    bool private _paused;\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract in unpaused state.\\r\\n     */\\r\\n    constructor() {\\r\\n        _paused = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the contract is paused, and false otherwise.\\r\\n     */\\r\\n    function paused() public view virtual returns (bool) {\\r\\n        return _paused;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    modifier whenNotPaused() {\\r\\n        require(!paused(), \\\"Pausable: paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    modifier whenPaused() {\\r\\n        require(paused(), \\\"Pausable: not paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Triggers stopped state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    function _pause() internal virtual whenNotPaused {\\r\\n        _paused = true;\\r\\n        emit Paused(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns to normal state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    function _unpause() internal virtual whenPaused {\\r\\n        _paused = false;\\r\\n        emit Unpaused(_msgSender());\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Contract that allows users who holds Rebel Bots NFTs, when the sale is open, to buy the reservation of the RBLS tokens,\\r\\n * based on the amount of Rebel Bots in the wallet. Contract accept ETH payments for this operation and stores the data about\\r\\n * the buyer, tokens number, and address for the RBLS token receiving ('airdrop' address on Polygon network) in the blockchain.\\r\\n *\\r\\n * After the sale is closed, appropriate amounts of RBLS token will be sent to each buyer to their airdrop addresses\\r\\n * on the Polygon network.\\r\\n*/\\r\\ncontract TokensSaleReserver is Ownable, Pausable {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    // Reservation start timestamp\\r\\n    uint _saleStartTs;\\r\\n    // Reservation end timestamp\\r\\n    uint _saleEndTs;\\r\\n\\r\\n    // RBLS token reservation price\\r\\n    uint256 private _tokenPrice = 352300;\\r\\n\\r\\n    // Limit of max amount of RBLS tokens that is allowed to reserve for users that holds less or equal then {_rbNumbersPriceThreshold} Rebel Bots tokens\\r\\n    uint256 private _plainRbHolderTokensLimit = 250000000000;\\r\\n    // Limit of max amount of RBLS tokens that is allowed to reserve for users that holds more then {_rbNumbersPriceThreshold} Rebel Bots tokens\\r\\n    uint256 private _majorRbHoldersTokensLimit = 750000000000;\\r\\n    // Threshold of the owned Rebel Bots NFTs that regulates limit of the RBLS tokens that is possible to reserve\\r\\n    uint256 private _rbNumbersPriceThreshold = 5;\\r\\n    // Snapshot of the RebelBots balance per each holder wallet\\r\\n    mapping(address => uint256) private _rebelBotsBalances;\\r\\n\\r\\n    // Array with all buyers addresses, used for enumeration\\r\\n    address[] private _allBuyers;\\r\\n\\r\\n    struct AirdropData {\\r\\n        address receiver;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    // Mapping from buyer address array of airdrop address and appropriate number of reserved RBLS tokens\\r\\n    mapping(address => AirdropData[]) private airdropsDataSet;\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `buyer` reserves 'tokensNumber' RBLS tokens\\r\\n    */\\r\\n    event TokensSell(\\r\\n        address indexed buyer,\\r\\n        address airdropAddress,\\r\\n        uint tokensNumber,\\r\\n        uint256 rbOwnedNumber\\r\\n    );\\r\\n\\r\\n    constructor(uint saleStartTs, uint saleEndTs) {\\r\\n        _saleStartTs = saleStartTs;\\r\\n        _saleEndTs = saleEndTs;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev updates limits of RBLS tokens allowed for the reservation\\r\\n    */\\r\\n    function updateLimits(uint256 plainRbHolderTokensLimit, uint256 majorRbHoldersTokensLimit, uint rbNumbersPriceThreshold) public onlyOwner {\\r\\n        require(plainRbHolderTokensLimit >= 0, \\\"plainRbHolderTokensLimit should be positive\\\");\\r\\n        require(majorRbHoldersTokensLimit >= 0, \\\"majorRbHoldersTokensLimit should be positive\\\");\\r\\n        require(rbNumbersPriceThreshold > 0, \\\"rbNumbersPriceThreshold should be positive\\\");\\r\\n        _plainRbHolderTokensLimit = plainRbHolderTokensLimit;\\r\\n        _majorRbHoldersTokensLimit = majorRbHoldersTokensLimit;\\r\\n        _rbNumbersPriceThreshold = rbNumbersPriceThreshold;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev updates sale start and sale end dates\\r\\n    */\\r\\n    function updateSalePeriod(uint saleStartTs, uint saleEndTs) public onlyOwner {\\r\\n        require(saleStartTs >= 0, \\\"plainRbHolderTokensLimit should be positive\\\");\\r\\n        require(saleEndTs > saleStartTs, \\\"saleEndTs should be greater then saleStartTs\\\");\\r\\n        _saleStartTs = saleStartTs;\\r\\n        _saleEndTs = saleEndTs;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev updates RBLS token reservation price\\r\\n     */\\r\\n    function updatePrice(uint256 tokenPrice) public onlyOwner {\\r\\n        require(tokenPrice >= 0, \\\"tokenPrice should be positive\\\");\\r\\n        _tokenPrice = tokenPrice;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev get the RBLS token reservation price\\r\\n     */\\r\\n    function getPrice() public view returns(uint256) {\\r\\n        return _tokenPrice;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns the maximum possible amount of RBLS tokens that is allowed to reserve for 'rbHolder' address\\r\\n    */\\r\\n    function getMaxTokensBuyLimit(address rbHolder) public view returns (uint256) {\\r\\n        uint256 rbTokensBalance = getRebelBotsHolderBalance(rbHolder);\\r\\n\\r\\n        return getMaxTokensBuyLimit(rbHolder, rbTokensBalance);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns the maximum possible amount of RBLS tokens that is allowed to reserve for 'rbHolder' address\\r\\n     * 'rbTokensBalance' - balance of th Rebel Bots NFT tokens of the 'rbHolder' address\\r\\n    */\\r\\n    function getMaxTokensBuyLimit(address rbHolder, uint256 rbTokensBalance) private view returns (uint256) {\\r\\n        uint256 totalTokensLimit;\\r\\n        if (rbTokensBalance == 0) {\\r\\n            return 0;\\r\\n        } else if (rbTokensBalance <= _rbNumbersPriceThreshold) {\\r\\n            totalTokensLimit = _plainRbHolderTokensLimit;\\r\\n        } else {\\r\\n            totalTokensLimit = _majorRbHoldersTokensLimit;\\r\\n        }\\r\\n        uint256 reservedTokensNumber = getTotalReservedTokens(rbHolder);\\r\\n        if (reservedTokensNumber >= totalTokensLimit) {\\r\\n            return 0;\\r\\n        }\\r\\n        return totalTokensLimit.sub(reservedTokensNumber);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns the total amount of RBLS tokens that were reserved by 'buyer'\\r\\n    */\\r\\n    function getTotalReservedTokens(address buyer) public view returns (uint256) {\\r\\n        AirdropData[] memory buyerAirdropData = airdropsDataSet[buyer];\\r\\n        uint256 totalTokens = 0;\\r\\n        for (uint i = 0; i < buyerAirdropData.length; i++) {\\r\\n            AirdropData memory ai = buyerAirdropData[i];\\r\\n            totalTokens = totalTokens + ai.amount;\\r\\n        }\\r\\n        return totalTokens;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev reserves 'tokensNumber' RBLS tokens for the airdrop to the 'airdropAddress' address\\r\\n    */\\r\\n    function reserveTokens(uint256 tokensNumber, address airdropAddress) whenNotPaused public payable {\\r\\n        require(airdropAddress != address(this) && airdropAddress != address(0), \\\"Incorrect airdrop address\\\");\\r\\n        require(_tokenPrice.mul(tokensNumber) == msg.value, \\\"Ether value sent is incorrect\\\");\\r\\n        require(block.timestamp >= _saleStartTs && block.timestamp <= _saleEndTs, \\\"Token sale is not available now\\\");\\r\\n\\r\\n        address buyer = _msgSender();\\r\\n        uint256 rbTokensBalance = getRebelBotsHolderBalance(buyer);\\r\\n        uint256 maxTokensBuyLimit = getMaxTokensBuyLimit(buyer, rbTokensBalance);\\r\\n\\r\\n        require(tokensNumber <= maxTokensBuyLimit, \\\"Tokens number exceeds the allowed number to reserve\\\");\\r\\n\\r\\n        if (airdropsDataSet[buyer].length == 0) {\\r\\n            _allBuyers.push(buyer);\\r\\n        }\\r\\n        airdropsDataSet[buyer].push(AirdropData(airdropAddress, tokensNumber));\\r\\n\\r\\n        emit TokensSell(buyer, airdropAddress, tokensNumber, rbTokensBalance);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev returns airdrop address for RBLS token for certain buyer address\\r\\n    */\\r\\n    function getBuyerReservationsCount(address buyer) public view returns (uint256) {\\r\\n        return airdropsDataSet[buyer].length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns airdrop address for RBLS token for certain buyer address\\r\\n    */\\r\\n    function getBuyerReservationByIndex(address buyer, uint256 index) public view returns (AirdropData memory) {\\r\\n        return airdropsDataSet[buyer][index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev returns total count of addresses that made the reservation\\r\\n    */\\r\\n    function buyersCount() public view returns (uint256) {\\r\\n        return _allBuyers.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev returns buyer address at a given `index` of all the reservation addresses\\r\\n    */\\r\\n    function buyerByIndex(uint256 index) public view returns (address) {\\r\\n        return _allBuyers[index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev returns number of RB tokens on the snapshot\\r\\n    */\\r\\n    function getRebelBotsHolderBalance(address holder) public view returns(uint) {\\r\\n        return _rebelBotsBalances[holder];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev adds a batch of the RB holder data\\r\\n    */\\r\\n    function addRebelBotsHoldersBalancesBatch(address[] memory holders, uint[] memory balances) public onlyOwner {\\r\\n        require(holders.length == balances.length, \\\"The arrays should be wth the same length\\\");\\r\\n        for (uint i = 0; i < holders.length; i++) {\\r\\n            _rebelBotsBalances[holders[i]] = balances[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev withdraws contract balance\\r\\n    */\\r\\n    function withdraw() public onlyOwner {\\r\\n        uint balance = address(this).balance;\\r\\n        payable(msg.sender).transfer(balance);\\r\\n    }\\r\\n\\r\\n    function pause() public onlyOwner {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    function unpause() public onlyOwner {\\r\\n        _unpause();\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"saleStartTs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleEndTs\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"airdropAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rbOwnedNumber\",\"type\":\"uint256\"}],\"name\":\"TokensSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"holders\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"name\":\"addRebelBotsHoldersBalancesBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"buyerByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getBuyerReservationByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokensSaleReserver.AirdropData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"getBuyerReservationsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rbHolder\",\"type\":\"address\"}],\"name\":\"getMaxTokensBuyLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getRebelBotsHolderBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"getTotalReservedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"airdropAddress\",\"type\":\"address\"}],\"name\":\"reserveTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"plainRbHolderTokensLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"majorRbHoldersTokensLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rbNumbersPriceThreshold\",\"type\":\"uint256\"}],\"name\":\"updateLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"name\":\"updatePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"saleStartTs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleEndTs\",\"type\":\"uint256\"}],\"name\":\"updateSalePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokensSaleReserver", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000062039c7800000000000000000000000000000000000000000000000000000000620b87b0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}