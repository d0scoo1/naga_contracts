{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@divergencetech/ethier/contracts/utils/DynamicBuffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (c) 2021 the ethier authors (github.com/divergencetech/ethier)\\n\\npragma solidity >=0.8.0;\\n\\n/// @title DynamicBuffer\\n/// @author David Huber (@cxkoda) and Simon Fremaux (@dievardump). See also\\n///         https://raw.githubusercontent.com/dievardump/solidity-dynamic-buffer\\n/// @notice This library is used to allocate a big amount of container memory\\n//          which will be subsequently filled without needing to reallocate\\n///         memory.\\n/// @dev First, allocate memory.\\n///      Then use `buffer.appendUnchecked(theBytes)` or `appendSafe()` if\\n///      bounds checking is required.\\nlibrary DynamicBuffer {\\n    /// @notice Allocates container space for the DynamicBuffer\\n    /// @param capacity The intended max amount of bytes in the buffer\\n    /// @return buffer The memory location of the buffer\\n    /// @dev Allocates `capacity + 0x60` bytes of space\\n    ///      The buffer array starts at the first container data position,\\n    ///      (i.e. `buffer = container + 0x20`)\\n    function allocate(uint256 capacity)\\n        internal\\n        pure\\n        returns (bytes memory buffer)\\n    {\\n        assembly {\\n            // Get next-free memory address\\n            let container := mload(0x40)\\n\\n            // Allocate memory by setting a new next-free address\\n            {\\n                // Add 2 x 32 bytes in size for the two length fields\\n                // Add 32 bytes safety space for 32B chunked copy\\n                let size := add(capacity, 0x60)\\n                let newNextFree := add(container, size)\\n                mstore(0x40, newNextFree)\\n            }\\n\\n            // Set the correct container length\\n            {\\n                let length := add(capacity, 0x40)\\n                mstore(container, length)\\n            }\\n\\n            // The buffer starts at idx 1 in the container (0 is length)\\n            buffer := add(container, 0x20)\\n\\n            // Init content with length 0\\n            mstore(buffer, 0)\\n        }\\n\\n        return buffer;\\n    }\\n\\n    /// @notice Appends data to buffer, and update buffer length\\n    /// @param buffer the buffer to append the data to\\n    /// @param data the data to append\\n    /// @dev Does not perform out-of-bound checks (container capacity)\\n    ///      for efficiency.\\n    function appendUnchecked(bytes memory buffer, bytes memory data)\\n        internal\\n        pure\\n    {\\n        assembly {\\n            let length := mload(data)\\n            for {\\n                data := add(data, 0x20)\\n                let dataEnd := add(data, length)\\n                let copyTo := add(buffer, add(mload(buffer), 0x20))\\n            } lt(data, dataEnd) {\\n                data := add(data, 0x20)\\n                copyTo := add(copyTo, 0x20)\\n            } {\\n                // Copy 32B chunks from data to buffer.\\n                // This may read over data array boundaries and copy invalid\\n                // bytes, which doesn't matter in the end since we will\\n                // later set the correct buffer length, and have allocated an\\n                // additional word to avoid buffer overflow.\\n                mstore(copyTo, mload(data))\\n            }\\n\\n            // Update buffer length\\n            mstore(buffer, add(mload(buffer), length))\\n        }\\n    }\\n\\n    /// @notice Appends data to buffer, and update buffer length\\n    /// @param buffer the buffer to append the data to\\n    /// @param data the data to append\\n    /// @dev Performs out-of-bound checks and calls `appendUnchecked`.\\n    function appendSafe(bytes memory buffer, bytes memory data) internal pure {\\n        uint256 capacity;\\n        uint256 length;\\n        assembly {\\n            capacity := sub(mload(sub(buffer, 0x20)), 0x40)\\n            length := mload(buffer)\\n        }\\n\\n        require(\\n            length + data.length <= capacity,\\n            \\\"DynamicBuffer: Appending out of bounds.\\\"\\n        );\\n        appendUnchecked(buffer, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/code-repository/GmStudioBlobStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright (c) 2022 GmDAO\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\nimport \\\"./IGmStudioBlobStorage.sol\\\";\\nimport \\\"../utils/sstore2/SSTORE2.sol\\\";\\n\\n/// @notice Canonical implementation of a blob storage contract.\\n/// @dev Stores data in contract bytecode.\\ncontract GmStudioBlobStorage is ERC165, IGmStudioBlobStorage {\\n    address private immutable pointer;\\n\\n    constructor(bytes memory code) {\\n        pointer = SSTORE2.write(code);\\n    }\\n\\n    function getBlob() external view override returns (bytes memory) {\\n        return SSTORE2.read(pointer);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        override(ERC165, IERC165)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IGmStudioBlobStorage).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/code-repository/GmStudioCodeRepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright (c) 2022 GmDAO\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@divergencetech/ethier/contracts/utils/DynamicBuffer.sol\\\";\\n\\nimport \\\"./IGmStudioBlobStorage.sol\\\";\\nimport \\\"./GmStudioBlobStorage.sol\\\";\\n\\n//                                           __                    __ __\\n//                                          |  \\\\                  |  \\\\  \\\\\\n//   ______  ______ ____           _______ _| \u2593\u2593_   __    __  ____| \u2593\u2593\\\\\u2593\u2593 ______\\n//  /      \\\\|      \\\\    \\\\         /       \\\\   \u2593\u2593 \\\\ |  \\\\  |  \\\\/      \u2593\u2593  \\\\/      \\\\\\n// |  \u2593\u2593\u2593\u2593\u2593\u2593\\\\ \u2593\u2593\u2593\u2593\u2593\u2593\\\\\u2593\u2593\u2593\u2593\\\\       |  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\\\\\u2593\u2593\u2593\u2593\u2593\u2593 | \u2593\u2593  | \u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\\\\\\n// | \u2593\u2593  | \u2593\u2593 \u2593\u2593 | \u2593\u2593 | \u2593\u2593        \\\\\u2593\u2593    \\\\  | \u2593\u2593 __| \u2593\u2593  | \u2593\u2593 \u2593\u2593  | \u2593\u2593 \u2593\u2593 \u2593\u2593  | \u2593\u2593\\n// | \u2593\u2593__| \u2593\u2593 \u2593\u2593 | \u2593\u2593 | \u2593\u2593__      _\\\\\u2593\u2593\u2593\u2593\u2593\u2593\\\\ | \u2593\u2593|  \\\\ \u2593\u2593__/ \u2593\u2593 \u2593\u2593__| \u2593\u2593 \u2593\u2593 \u2593\u2593__/ \u2593\u2593\\n//  \\\\\u2593\u2593    \u2593\u2593 \u2593\u2593 | \u2593\u2593 | \u2593\u2593  \\\\    |       \u2593\u2593  \\\\\u2593\u2593  \u2593\u2593\\\\\u2593\u2593    \u2593\u2593\\\\\u2593\u2593    \u2593\u2593 \u2593\u2593\\\\\u2593\u2593    \u2593\u2593\\n//  _\\\\\u2593\u2593\u2593\u2593\u2593\u2593\u2593\\\\\u2593\u2593  \\\\\u2593\u2593  \\\\\u2593\u2593\\\\\u2593\u2593     \\\\\u2593\u2593\u2593\u2593\u2593\u2593\u2593    \\\\\u2593\u2593\u2593\u2593  \\\\\u2593\u2593\u2593\u2593\u2593\u2593  \\\\\u2593\u2593\u2593\u2593\u2593\u2593\u2593\\\\\u2593\u2593 \\\\\u2593\u2593\u2593\u2593\u2593\u2593\\n// |  \\\\__| \u2593\u2593\\n//  \\\\\u2593\u2593    \u2593\u2593\\n//   \\\\\u2593\u2593\u2593\u2593\u2593\u2593\\n//\\ncontract GmStudioCodeRepository is Ownable {\\n    using DynamicBuffer for bytes;\\n\\n    /// @notice The possible types of registered collections.\\n    enum CollectionType {\\n        Unknown,\\n        OnChain,\\n        InChain\\n    }\\n\\n    /// @notice The data entries for a collection.\\n    /// @dev `id` corresponds to the index in `collectionList`\\n    /// `exists` is used to indicate if a collection is in the repo (due to zero\\n    /// default values of mappings)\\n    /// `locked` if a collection cannot be changed anymore\\n    /// `collectionType` indicates if the collection is on- or in-chain\\n    /// `storageContracts` is the list of contracts used for code storage\\n    /// `artist` is the artist address used to sign the registry entry (equals\\n    /// zero if the entry is not signed)\\n    /// `version` allows for possible future versioning requirements.\\n    struct CollectionData {\\n        bool locked;\\n        bool exists;\\n        CollectionType collectionType;\\n        uint8 version;\\n        address artist;\\n        uint64 id;\\n        IGmStudioBlobStorage[] storageContracts;\\n    }\\n\\n    /// @notice The type and code blob of a given collection.\\n    /// @dev Return type of `getBlob`\\n    /// @dev `data` corresponds to a GZip'ed tarball.\\n    struct CollectionBlob {\\n        CollectionType collectionType;\\n        bytes data;\\n    }\\n\\n    /// @notice The collection contract addresses in the repository\\n    address[] internal collectionList;\\n\\n    /// @notice The collection data in the repository\\n    mapping(address => CollectionData) internal collectionData;\\n\\n    /// @notice Managers are addresses are allowed to perform special actions\\n    /// in place of owner\\n    mapping(address => bool) public isManager;\\n\\n    /// @notice The collections supplementary notes. Used for post-lock\\n    /// informational addendums that are not part of standardized collection\\n    /// data.\\n    mapping(address => string[]) internal collectionNotes;\\n\\n    constructor(address newOwner, address manager_) {\\n        isManager[manager_] = true;\\n        _transferOwnership(newOwner);\\n    }\\n\\n    // -------------------------------------------------------------------------\\n    //\\n    //  Getters\\n    //\\n    // -------------------------------------------------------------------------\\n\\n    /// @notice Returns the list of registered collections in the repository.\\n    function getCollections() external view returns (address[] memory) {\\n        return collectionList;\\n    }\\n\\n    /// @notice Checks if a registered collection is locked.\\n    /// @param collection The collection of interest.\\n    /// @dev Reverts if the collection is not in the repository.\\n    function isLocked(address collection)\\n        external\\n        view\\n        collectionExists(collection)\\n        returns (bool)\\n    {\\n        return collectionData[collection].locked;\\n    }\\n\\n    /// @notice Returns the code blob for a registered collection.\\n    /// @param collection The collection of interest.\\n    /// @dev For on-chain projects the return contains a GZip'ed tarball, that\\n    /// is already concatenated if multiple storage contracts were used.\\n    /// @dev Reverts if the collection is not in the repository.\\n    function getBlob(address collection)\\n        external\\n        view\\n        collectionExists(collection)\\n        returns (CollectionBlob memory)\\n    {\\n        CollectionBlob memory blob;\\n        CollectionData storage data = collectionData[collection];\\n        blob.collectionType = CollectionType(data.collectionType);\\n\\n        if (blob.collectionType == CollectionType.InChain) {\\n            return blob;\\n        }\\n\\n        // Concatenate all blobs\\n        IGmStudioBlobStorage[] storage stores = data.storageContracts;\\n        uint256 num = stores.length;\\n        blob.data = DynamicBuffer.allocate(num * 25000);\\n        for (uint256 idx = 0; idx < num; ++idx) {\\n            blob.data.appendSafe(stores[idx].getBlob());\\n        }\\n\\n        return blob;\\n    }\\n\\n    /// @notice Returns the storage addresses for a registered collection.\\n    /// @param collection The collection of interest.\\n    /// @dev Reverts if the collection is not in the repository.\\n    function getStorageContracts(address collection)\\n        external\\n        view\\n        collectionExists(collection)\\n        returns (IGmStudioBlobStorage[] memory)\\n    {\\n        return collectionData[collection].storageContracts;\\n    }\\n\\n    /// @notice Returns the registry data for a registered collection.\\n    /// @param collection The collection of interest.\\n    /// @dev Reverts if the collection is not in the repository.\\n    function getCollectionData(address collection)\\n        external\\n        view\\n        collectionExists(collection)\\n        returns (CollectionData memory)\\n    {\\n        return collectionData[collection];\\n    }\\n\\n    /// @notice Returns the storage type of a registered collection.\\n    /// @param collection The collection contract address of interest.\\n    /// @dev Reverts if the collection is not in the repository.\\n    function getCollectionType(address collection)\\n        public\\n        view\\n        collectionExists(collection)\\n        returns (CollectionType)\\n    {\\n        return CollectionType(collectionData[collection].collectionType);\\n    }\\n\\n    /// @notice Returns the list of notes attached to a registered collection.\\n    /// @param collection The collection contract address of interest.\\n    /// @dev Reverts if the collection is not in the repository.\\n    function getNotes(address collection)\\n        public\\n        view\\n        collectionExists(collection)\\n        returns (string[] memory)\\n    {\\n        return collectionNotes[collection];\\n    }\\n\\n    // -------------------------------------------------------------------------\\n    //\\n    //  Setters\\n    //\\n    // -------------------------------------------------------------------------\\n\\n    /// @notice A convenience interface to store blobs on-chain\\n    /// @dev Stores blobs in contract bytecode for efficiency\\n    /// @param blob The bytes of the blob to be stored\\n    function store(bytes calldata blob)\\n        external\\n        returns (IGmStudioBlobStorage)\\n    {\\n        IGmStudioBlobStorage storageContract = new GmStudioBlobStorage(blob);\\n        emit NewBlobStorage(storageContract);\\n        return storageContract;\\n    }\\n\\n    /// @notice Adds a new collection to the repository.\\n    /// @param collection The collection of interest.\\n    /// @param storageContracts The contracts storing the code blobs.\\n    /// @dev Reverts if the collection already exists.\\n    function addOnChainCollection(\\n        address collection,\\n        IGmStudioBlobStorage[] calldata storageContracts\\n    ) external onlyManagerOrOwner {\\n        _addOnChainCollection(collection, storageContracts);\\n    }\\n\\n    function addInChainCollection(address collection)\\n        external\\n        onlyManagerOrOwner\\n    {\\n        _addInchainCollection(collection);\\n    }\\n\\n    /// @notice Pops collections from the internal list.\\n    /// @dev Reverts if the collection is locked.\\n    function popCollection() external onlyManagerOrOwner {\\n        _popCollection();\\n    }\\n\\n    /// @notice Sets the storage contract addresses for a registered collection.\\n    /// @param collection The collection of interest.\\n    /// @param storageContracts The contract storing the code.\\n    /// @dev Reverts if the collection is locked, is not in the repository, or\\n    /// is not an on-chain collection.\\n    /// @dev Invalidates existing artist signatures.\\n    function setStorageContracts(\\n        address collection,\\n        IGmStudioBlobStorage[] calldata storageContracts\\n    ) external onlyManagerOrOwner {\\n        _setStorageContracts(collection, storageContracts);\\n    }\\n\\n    /// @notice Changes the address of a registered collection.\\n    /// @param addrOld The previous address of the collection.\\n    /// @param addrNew The new address of the collection.\\n    /// @dev Reverts if the collection is locked or is not in the repository.\\n    /// @dev Invalidates existing artist signatures.\\n    function setCollectionAddress(address addrOld, address addrNew)\\n        external\\n        onlyManagerOrOwner\\n    {\\n        _setCollectionAddress(addrOld, addrNew);\\n    }\\n\\n    /// @notice Adds a note to a locked collection.\\n    /// @param collection The collection to have notes added to.\\n    /// @param note The note to be added. If technical in nature, preferred to\\n    /// be structured JSON.\\n    /// @dev Reverts if the collection is not locked or is not in the repository\\n    function addNote(address collection, string calldata note)\\n        external\\n        onlyManagerOrOwner\\n        onlyLockedExistingCollection(collection)\\n    {\\n        collectionNotes[collection].push(note);\\n    }\\n\\n    /// @notice Adds an artist to a registered collection.\\n    /// @param collection The collection of interest.\\n    /// @param artist The signing artist's address.\\n    /// @param signature The artist's signature.\\n    /// @dev Reverts if the collection is not in the repository or is locked, or\\n    /// if the given signature is invalid.\\n    /// @dev The signature is not stored explicitly within the contract.\\n    /// However, this method is the only way to add an artist to a collection.\\n    /// Hence, a collection can be regarded as signed if the artist is set.\\n    function addArtistWithSignature(\\n        address collection,\\n        address artist,\\n        bytes calldata signature\\n    ) external onlyManagerOrOwner {\\n        _addArtistWithSignature(collection, artist, signature);\\n    }\\n\\n    /// @notice Locks a collection.\\n    /// @param collection The collection to be locked.\\n    /// @dev Reverts if the collection is locked or is not in the repository.\\n    function lock(address collection) external onlyOwner {\\n        _lock(collection);\\n    }\\n\\n    /// @notice Sets or removes manager permissions for an address.\\n    /// @param manager The manager address.\\n    /// @param status Manager status to be set. True corresponds to granting\\n    /// elevated permissions.\\n    function setManager(address manager, bool status) external onlyOwner {\\n        isManager[manager] = status;\\n    }\\n\\n    // -------------------------------------------------------------------------\\n    //\\n    //  Internal\\n    //\\n    // -------------------------------------------------------------------------\\n\\n    /// @dev Restrics access to owner and manager\\n    modifier onlyManagerOrOwner() {\\n        if (!(msg.sender == owner() || isManager[msg.sender]))\\n            revert OnlyManagerOrOwner();\\n        _;\\n    }\\n\\n    /// @notice Reverts if a collection is locked or nonexistent.\\n    modifier onlyUnlockedExistingCollection(address collection) {\\n        if (!collectionData[collection].exists) revert CollectionNotFound();\\n        if (collectionData[collection].locked) revert CollectionIsLocked();\\n        _;\\n    }\\n\\n    /// @notice Reverts if a collection is not locked or nonexistent.\\n    modifier onlyLockedExistingCollection(address collection) {\\n        if (!collectionData[collection].exists) revert CollectionNotFound();\\n        if (!collectionData[collection].locked) revert CollectionIsNotLocked();\\n        _;\\n    }\\n\\n    /// @notice Reverts if a collection is nonexistent.\\n    modifier collectionExists(address collection) {\\n        if (!collectionData[collection].exists) revert CollectionNotFound();\\n        _;\\n    }\\n\\n    /// @notice Reverts if a collection.isOnChain does not match onChain.\\n    modifier hasCollectionType(\\n        address collection,\\n        CollectionType collectionType\\n    ) {\\n        if (\\n            CollectionType(collectionData[collection].collectionType) !=\\n            collectionType\\n        ) {\\n            revert WrongCollectionType(\\n                collectionData[collection].collectionType\\n            );\\n        }\\n        _;\\n    }\\n\\n    /// @notice Reverts if a collection exists.\\n    modifier onlyNewCollections(address collection) {\\n        if (collectionData[collection].exists) revert CollectionAlreadyExists();\\n        _;\\n    }\\n\\n    /// @notice Reverts if at least one of the given storageContracts does not\\n    /// satisfy the IGmStudioBlobStorage interface according to EIP-165.\\n    modifier onlyValidStorageContracts(\\n        IGmStudioBlobStorage[] calldata storageContracts\\n    ) {\\n        uint256 num = storageContracts.length;\\n        for (uint256 idx = 0; idx < num; ++idx) {\\n            (bool success, bytes memory returnData) = address(\\n                storageContracts[idx]\\n            ).call(\\n                    abi.encodePacked(\\n                        IERC165.supportsInterface.selector,\\n                        abi.encode(type(IGmStudioBlobStorage).interfaceId)\\n                    )\\n                );\\n\\n            if (!success || returnData.length == 0) {\\n                revert InvalidStorageContract();\\n            }\\n\\n            bool supported = abi.decode(returnData, (bool));\\n            if (!supported) {\\n                revert InvalidStorageContract();\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @notice Adds a collection\\n    function _addOnChainCollection(\\n        address collection,\\n        IGmStudioBlobStorage[] calldata storageContracts\\n    )\\n        internal\\n        onlyNewCollections(collection)\\n        onlyValidStorageContracts(storageContracts)\\n    {\\n        uint256 nextId = collectionList.length;\\n        collectionList.push(collection);\\n        collectionData[collection] = CollectionData({\\n            locked: false,\\n            exists: true,\\n            collectionType: CollectionType.OnChain,\\n            artist: address(0),\\n            version: 0,\\n            id: uint64(nextId),\\n            storageContracts: storageContracts\\n        });\\n    }\\n\\n    /// @notice Adds a collection\\n    function _addInchainCollection(address collection)\\n        internal\\n        onlyNewCollections(collection)\\n    {\\n        uint256 nextId = collectionList.length;\\n        collectionList.push(collection);\\n        collectionData[collection] = CollectionData({\\n            locked: false,\\n            exists: true,\\n            collectionType: CollectionType.InChain,\\n            artist: address(0),\\n            version: 0,\\n            id: uint64(nextId),\\n            storageContracts: new IGmStudioBlobStorage[](0)\\n        });\\n    }\\n\\n    /// @notice Sets the storage contract addresses for a registered colleciton\\n    function _setStorageContracts(\\n        address collection,\\n        IGmStudioBlobStorage[] calldata storageContracts\\n    )\\n        internal\\n        onlyUnlockedExistingCollection(collection)\\n        hasCollectionType(collection, CollectionType.OnChain)\\n        onlyValidStorageContracts(storageContracts)\\n    {\\n        collectionData[collection].artist = address(0);\\n        collectionData[collection].storageContracts = storageContracts;\\n    }\\n\\n    /// @notice Sets a new contract address for an existing collection.\\n    /// @dev Overwrites if `id` exists, reverts otherwise.\\n    /// @dev Reverts if the collection is locked or isn't in the repo.\\n    function _setCollectionAddress(address addrOld, address addrNew) internal {\\n        CollectionData memory data = collectionData[addrOld];\\n        data.artist = address(0);\\n        collectionData[addrNew] = data;\\n        collectionList[data.id] = addrNew;\\n        _removeCollectionData(addrOld);\\n    }\\n\\n    /// @notice Pops an existing collection.\\n    /// @dev Reverts if the latest collection is locked.\\n    function _popCollection() internal {\\n        address collection = collectionList[collectionList.length - 1];\\n        _removeCollectionData(collection);\\n        collectionList.pop();\\n    }\\n\\n    /// @notice Removes a registered collection.\\n    function _removeCollectionData(address collection)\\n        internal\\n        onlyUnlockedExistingCollection(collection)\\n    {\\n        delete collectionData[collection];\\n    }\\n\\n    /// @notice Locks a collection.\\n    function _lock(address collection)\\n        internal\\n        onlyUnlockedExistingCollection(collection)\\n    {\\n        CollectionData storage data = collectionData[collection];\\n        if (\\n            (data.collectionType == CollectionType.OnChain &&\\n                data.storageContracts.length == 0) ||\\n            data.collectionType == CollectionType.Unknown\\n        ) revert StorageContractsNotSet();\\n        collectionData[collection].locked = true;\\n    }\\n\\n    /// @notice Adds an artist to a registered collection\\n    /// @dev Reverts if the signature is invalid.\\n    function _addArtistWithSignature(\\n        address collection,\\n        address artist,\\n        bytes calldata signature\\n    ) internal onlyUnlockedExistingCollection(collection) {\\n        CollectionData storage data = collectionData[collection];\\n        data.artist = artist;\\n\\n        bytes32 message = ECDSA.toEthSignedMessageHash(\\n            abi.encodePacked(collection, data.storageContracts)\\n        );\\n        address signer = ECDSA.recover(message, signature);\\n        if (signer != artist) revert InvalidSignature();\\n    }\\n\\n    // -------------------------------------------------------------------------\\n    //\\n    //  Events\\n    //\\n    // -------------------------------------------------------------------------\\n\\n    event NewBlobStorage(IGmStudioBlobStorage indexed storageAddress);\\n\\n    // -------------------------------------------------------------------------\\n    //\\n    //  Errors\\n    //\\n    // -------------------------------------------------------------------------\\n\\n    error CollectionIsLocked();\\n    error CollectionIsNotLocked();\\n    error WrongCollectionType(CollectionType);\\n    error CollectionNotFound();\\n    error OnlyManagerOrOwner();\\n    error StorageContractsNotSet();\\n    error CollectionAlreadyExists();\\n    error InvalidStorageContract();\\n    error InvalidSignature();\\n}\\n\"\r\n    },\r\n    \"contracts/code-repository/IGmStudioBlobStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright (c) 2022 GmDAO\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @notice Interface for on-chain data storage\\ninterface IGmStudioBlobStorage is IERC165 {\\n    /// @notice Returns the stored code blob\\n    /// @dev Conforming to (a slice of) a GZip'ed tarball.\\n    function getBlob() external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/sstore2/SSTORE2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./utils/Bytecode.sol\\\";\\n\\n/**\\n  @title A key-value storage with auto-generated keys for storing chunks of data with a lower write & read cost.\\n  @author Agustin Aguilar <aa@horizon.io>\\n\\n  Readme: https://github.com/0xsequence/sstore2#readme\\n*/\\nlibrary SSTORE2 {\\n    error WriteError();\\n\\n    /**\\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\\n    @dev The pointer is a contract address with `_data` as code\\n    @param _data to be written\\n    @return pointer Pointer to the written `_data`\\n  */\\n    function write(bytes memory _data) internal returns (address pointer) {\\n        // Append 00 to _data so contract can't be called\\n        // Build init code\\n        bytes memory code = Bytecode.creationCodeFor(\\n            abi.encodePacked(hex\\\"00\\\", _data)\\n        );\\n\\n        // Deploy contract using create\\n        assembly {\\n            pointer := create(0, add(code, 32), mload(code))\\n        }\\n\\n        // Address MUST be non-zero\\n        if (pointer == address(0)) revert WriteError();\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @return data read from `_pointer` contract\\n  */\\n    function read(address _pointer) internal view returns (bytes memory) {\\n        return Bytecode.codeAt(_pointer, 1, type(uint256).max);\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @return data read from `_pointer` contract\\n  */\\n    function read(address _pointer, uint256 _start)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @param _end index before which to end extraction\\n    @return data read from `_pointer` contract\\n  */\\n    function read(\\n        address _pointer,\\n        uint256 _start,\\n        uint256 _end\\n    ) internal view returns (bytes memory) {\\n        return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/sstore2/utils/Bytecode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Bytecode {\\n    error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\\n\\n    /**\\n    @notice Generate a creation code that results on a contract with `_code` as bytecode\\n    @param _code The returning value of the resulting `creationCode`\\n    @return creationCode (constructor) for new contract\\n  */\\n    function creationCodeFor(bytes memory _code)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        /*\\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\\n      0x01    0x80         0x80        DUP1                size size\\n      0x02    0x60         0x600e      PUSH1 14            14 size size\\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\\n      0x04    0x39         0x39        CODECOPY            size\\n      0x05    0x60         0x6000      PUSH1 00            0 size\\n      0x06    0xf3         0xf3        RETURN\\n      <CODE>\\n    */\\n\\n        return\\n            abi.encodePacked(\\n                hex\\\"63\\\",\\n                uint32(_code.length),\\n                hex\\\"80_60_0E_60_00_39_60_00_F3\\\",\\n                _code\\n            );\\n    }\\n\\n    /**\\n    @notice Returns the size of the code on a given address\\n    @param _addr Address that may or may not contain code\\n    @return size of the code on the given `_addr`\\n  */\\n    function codeSize(address _addr) internal view returns (uint256 size) {\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n    }\\n\\n    /**\\n    @notice Returns the code of a given address\\n    @dev It will fail if `_end < _start`\\n    @param _addr Address that may or may not contain code\\n    @param _start number of bytes of code to skip on read\\n    @param _end index before which to end extraction\\n    @return oCode read from `_addr` deployed bytecode\\n\\n    Forked from: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\\n  */\\n    function codeAt(\\n        address _addr,\\n        uint256 _start,\\n        uint256 _end\\n    ) internal view returns (bytes memory oCode) {\\n        uint256 csize = codeSize(_addr);\\n        if (csize == 0) return bytes(\\\"\\\");\\n\\n        if (_start > csize) return bytes(\\\"\\\");\\n        if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end);\\n\\n        unchecked {\\n            uint256 reqSize = _end - _start;\\n            uint256 maxSize = csize - _start;\\n\\n            uint256 size = maxSize < reqSize ? maxSize : reqSize;\\n\\n            assembly {\\n                // allocate output byte array - this could also be done without assembly\\n                // by using o_code = new bytes(size)\\n                oCode := mload(0x40)\\n                // new \\\"memory end\\\" including padding\\n                mstore(\\n                    0x40,\\n                    add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f)))\\n                )\\n                // store length in memory\\n                mstore(oCode, size)\\n                // actually retrieve the code, this needs assembly\\n                extcodecopy(_addr, add(oCode, 0x20), _start, size)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CollectionAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollectionIsLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollectionIsNotLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollectionNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStorageContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyManagerOrOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StorageContractsNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum GmStudioCodeRepository.CollectionType\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"WrongCollectionType\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IGmStudioBlobStorage\",\"name\":\"storageAddress\",\"type\":\"address\"}],\"name\":\"NewBlobStorage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"addArtistWithSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"addInChainCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"note\",\"type\":\"string\"}],\"name\":\"addNote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"contract IGmStudioBlobStorage[]\",\"name\":\"storageContracts\",\"type\":\"address[]\"}],\"name\":\"addOnChainCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"getBlob\",\"outputs\":[{\"components\":[{\"internalType\":\"enum GmStudioCodeRepository.CollectionType\",\"name\":\"collectionType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct GmStudioCodeRepository.CollectionBlob\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"getCollectionData\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"enum GmStudioCodeRepository.CollectionType\",\"name\":\"collectionType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"id\",\"type\":\"uint64\"},{\"internalType\":\"contract IGmStudioBlobStorage[]\",\"name\":\"storageContracts\",\"type\":\"address[]\"}],\"internalType\":\"struct GmStudioCodeRepository.CollectionData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"getCollectionType\",\"outputs\":[{\"internalType\":\"enum GmStudioCodeRepository.CollectionType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCollections\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"getNotes\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"getStorageContracts\",\"outputs\":[{\"internalType\":\"contract IGmStudioBlobStorage[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"popCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addrOld\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addrNew\",\"type\":\"address\"}],\"name\":\"setCollectionAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"contract IGmStudioBlobStorage[]\",\"name\":\"storageContracts\",\"type\":\"address[]\"}],\"name\":\"setStorageContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"blob\",\"type\":\"bytes\"}],\"name\":\"store\",\"outputs\":[{\"internalType\":\"contract IGmStudioBlobStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GmStudioCodeRepository", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000016485319aa0ad7a4e68176fbaada235c92acae2e000000000000000000000000edb7c032fef116163214fcdb6ca481e94794b187", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}