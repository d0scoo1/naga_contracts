{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: contracts/library/BridgeSecurity.sol\r\n\r\npragma solidity ^0.8.7;\r\n\r\nlibrary BridgeSecurity {\r\n    function generateSignerMsgHash(uint64 epoch, address[] memory signers)\r\n        internal\r\n        pure\r\n        returns (bytes32 msgHash)\r\n    {\r\n        msgHash = keccak256(\r\n            abi.encodePacked(\r\n                bytes1(0x19),\r\n                bytes1(0),\r\n                address(0),\r\n                epoch,\r\n                _encodeAddressArr(signers)\r\n            )\r\n        );\r\n    }\r\n\r\n    function generatePackMsgHash(\r\n        address thisAddr,\r\n        uint64 epoch,\r\n        uint8 networkId,\r\n        uint64[2] memory blockScanRange,\r\n        uint256[] memory txHashes,\r\n        address[] memory tokens,\r\n        address[] memory recipients,\r\n        uint256[] memory amounts\r\n    ) internal pure returns (bytes32 msgHash) {\r\n        msgHash = keccak256(\r\n            abi.encodePacked(\r\n                bytes1(0x19),\r\n                bytes1(0),\r\n                thisAddr,\r\n                epoch,\r\n                _encodeFixed2Uint64Arr(blockScanRange),\r\n                networkId,\r\n                _encodeUint256Arr(txHashes),\r\n                _encodeAddressArr(tokens),\r\n                _encodeAddressArr(recipients),\r\n                _encodeUint256Arr(amounts)\r\n            )\r\n        );\r\n    }\r\n\r\n    function signersVerification(\r\n        bytes32 msgHash,\r\n        uint8[] memory v,\r\n        bytes32[] memory r,\r\n        bytes32[] memory s,\r\n        address[] memory signers,\r\n        mapping(address => bool) storage mapSigners\r\n    ) internal view returns (bool) {\r\n        uint64 totalSigners = 0;\r\n        for (uint64 i = 0; i < signers.length; i++) {\r\n            if (mapSigners[signers[i]]) totalSigners++;\r\n        }\r\n        return (_getVerifiedSigners(msgHash, v, r, s, mapSigners) ==\r\n            (totalSigners / 2) + 1);\r\n    }\r\n\r\n    function _getVerifiedSigners(\r\n        bytes32 msgHash,\r\n        uint8[] memory v,\r\n        bytes32[] memory r,\r\n        bytes32[] memory s,\r\n        mapping(address => bool) storage mapSigners\r\n    ) private view returns (uint8 verifiedSigners) {\r\n        address lastAddr = address(0);\r\n        verifiedSigners = 0;\r\n        for (uint64 i = 0; i < v.length; i++) {\r\n            address recovered = ecrecover(msgHash, v[i], r[i], s[i]);\r\n            if (recovered > lastAddr && mapSigners[recovered])\r\n                verifiedSigners++;\r\n            lastAddr = recovered;\r\n        }\r\n    }\r\n\r\n    function _encodeAddressArr(address[] memory arr)\r\n        private\r\n        pure\r\n        returns (bytes memory data)\r\n    {\r\n        for (uint64 i = 0; i < arr.length; i++) {\r\n            data = abi.encodePacked(data, arr[i]);\r\n        }\r\n    }\r\n\r\n    function _encodeUint256Arr(uint256[] memory arr)\r\n        private\r\n        pure\r\n        returns (bytes memory data)\r\n    {\r\n        for (uint64 i = 0; i < arr.length; i++) {\r\n            data = abi.encodePacked(data, arr[i]);\r\n        }\r\n    }\r\n\r\n    function _encodeFixed2Uint64Arr(uint64[2] memory arr)\r\n        private\r\n        pure\r\n        returns (bytes memory data)\r\n    {\r\n        for (uint64 i = 0; i < arr.length; i++) {\r\n            data = abi.encodePacked(data, arr[i]);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/BaseToken/interface/ITokenFactory.sol\r\n\r\npragma solidity ^0.8.7;\r\n\r\ninterface ITokenFactory {\r\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\r\n\r\n    event BridgeChanged(address indexed oldBridge, address indexed newBridge);\r\n\r\n    event AdminChanged(address indexed oldAdmin, address indexed newAdmin);\r\n\r\n    event TokenCreated(\r\n        string name,\r\n        string indexed symbol,\r\n        uint256 amount,\r\n        uint256 cap,\r\n        address indexed token\r\n    );\r\n\r\n    event TokenRemoved(address indexed token);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function tokens() external view returns (address[] memory);\r\n\r\n    function tokenExist(address token) external view returns (bool);\r\n\r\n    function bridge() external view returns (address);\r\n\r\n    function admin() external view returns (address);\r\n\r\n    function setBridge(address bridge) external;\r\n\r\n    function setAdmin(address admin) external;\r\n\r\n    function createToken(\r\n        string memory name,\r\n        string memory symbol,\r\n        uint256 amount,\r\n        uint256 cap\r\n    ) external returns (address token);\r\n\r\n    function removeToken(address token) external;\r\n}\r\n\r\n// File: contracts/BaseCrossBridge/interface/ICrossBridgeStorageToken.sol\r\n\r\npragma solidity ^0.8.7;\r\n\r\ninterface ICrossBridgeStorageToken {\r\n    event TokenConnected(\r\n        address indexed token,\r\n        uint256 amount,\r\n        uint256 percent,\r\n        address indexed crossToken,\r\n        string symbol\r\n    );\r\n\r\n    event TokenRequirementChanged(\r\n        uint64 blockIndex,\r\n        address indexed token,\r\n        uint256[2] amount,\r\n        uint256[2] percent\r\n    );\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function admin() external view returns (address);\r\n\r\n    function bridge() external view returns (address);\r\n\r\n    function mapToken(address token) external view returns (bool);\r\n\r\n    function mapOcToken(address token) external view returns (address);\r\n\r\n    function mapCoToken(address token) external view returns (address);\r\n\r\n    function blockScanRange() external view returns (uint64[] memory);\r\n\r\n    function crossToken(address token)\r\n        external\r\n        view\r\n        returns (string memory, string memory);\r\n\r\n    function tokens(\r\n        ITokenFactory tf,\r\n        uint64 futureBlock,\r\n        uint64 searchBlockIndex\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint8[] memory,\r\n            address[][] memory,\r\n            address[][] memory,\r\n            uint256[][] memory,\r\n            uint256[][] memory,\r\n            uint8[][] memory\r\n        );\r\n\r\n    function tokens(\r\n        ITokenFactory tf,\r\n        uint8 id,\r\n        uint64 futureBlock,\r\n        uint64 searchBlockIndex\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            address[] memory,\r\n            address[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint8[] memory\r\n        );\r\n\r\n    function charges()\r\n        external\r\n        view\r\n        returns (address[] memory tokens, uint256[] memory charges);\r\n\r\n    function txHash(uint256 txHash) external view returns (bool);\r\n\r\n    function transactionInfo(\r\n        uint64 futureBlock,\r\n        address token,\r\n        uint256 amount\r\n    ) external view returns (uint256 fee, uint256 amountAfterCharge);\r\n\r\n    function setCallers(address admin, address bridge) external;\r\n\r\n    function resetConnection(address token, address crossToken) external;\r\n\r\n    function setConnection(\r\n        address token,\r\n        uint256 amount,\r\n        uint256 percent,\r\n        address crossToken,\r\n        string memory name,\r\n        string memory symbol\r\n    ) external;\r\n\r\n    function setInfo(\r\n        address token,\r\n        uint256 amount,\r\n        uint256 percent\r\n    ) external;\r\n\r\n    function setAmount(address token, uint256 amount) external;\r\n\r\n    function setPercent(address token, uint256 percent) external;\r\n\r\n    function setTxHash(uint256 txHash) external;\r\n\r\n    function setCollectedCharges(address token, uint256 amount) external;\r\n\r\n    function setScanRange(uint64[2] memory scanRange) external;\r\n}\r\n\r\n// File: contracts/BaseBridge/interface/IBridge.sol\r\n\r\npragma solidity ^0.8.7;\r\n\r\nstruct TokenReq {\r\n    bool exist;\r\n    uint256 minAmount;\r\n    uint256 chargePercent;\r\n}\r\n\r\nstruct CrossTokenInfo {\r\n    string name;\r\n    string symbol;\r\n}\r\n\r\nstruct NetworkInfo {\r\n    uint8 id;\r\n    string name;\r\n}\r\n\r\nstruct TokenData {\r\n    address[] tokens;\r\n    address[] crossTokens;\r\n    uint256[] minAmounts;\r\n    uint256[] chargePercents;\r\n    uint8[] tokenTypes;\r\n}\r\n\r\nstruct TokensInfo {\r\n    uint8[] ids;\r\n    address[][] tokens;\r\n    address[][] crossTokens;\r\n    uint256[][] minAmounts;\r\n    uint256[][] chargePercents;\r\n    uint8[][] tokenTypes;\r\n}\r\n\r\nstruct TokensChargesInfo {\r\n    uint8[] ids;\r\n    address[][] tokens;\r\n    uint256[][] charges;\r\n}\r\n\r\ninterface IBridge {\r\n    event TokenConnected(\r\n        address indexed token,\r\n        uint256 amount,\r\n        uint256 percent,\r\n        address indexed crossToken,\r\n        string symbol\r\n    );\r\n\r\n    event TokenReqChanged(\r\n        uint64 blockIndex,\r\n        address indexed token,\r\n        uint256[2] amount,\r\n        uint256[2] percent\r\n    );\r\n\r\n    function initialize(\r\n        address factory,\r\n        address admin,\r\n        address tokenFactory,\r\n        address wMech,\r\n        uint8 id,\r\n        string memory name\r\n    ) external;\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function admin() external view returns (address);\r\n\r\n    function network() external view returns (uint8, string memory);\r\n\r\n    function activeTokenCount() external view returns (uint8);\r\n\r\n    function crossToken(address crossToken)\r\n        external\r\n        view\r\n        returns (string memory, string memory);\r\n\r\n    function tokens(uint64 futureBlock, uint64 searchBlockIndex)\r\n        external\r\n        view\r\n        returns (TokenData memory data);\r\n\r\n    function blockScanRange() external view returns (uint64[] memory);\r\n\r\n    function charges()\r\n        external\r\n        view\r\n        returns (address[] memory tokens, uint256[] memory charges);\r\n\r\n    function txHash(uint256 txHash_) external view returns (bool);\r\n\r\n    function setConnection(\r\n        address token,\r\n        uint256 amount,\r\n        uint256 percent,\r\n        address crossToken,\r\n        string memory name,\r\n        string memory symbol\r\n    ) external;\r\n\r\n    function setInfo(\r\n        address token,\r\n        uint256 amount,\r\n        uint256 percent\r\n    ) external;\r\n\r\n    function setAmount(address token, uint256 amount) external;\r\n\r\n    function setPercent(address token, uint256 percent) external;\r\n\r\n    function resetConnection(address token, address crossToken) external;\r\n\r\n    function processPack(\r\n        uint64[2] memory blockScanRange,\r\n        uint256[] memory txHashes,\r\n        address[] memory tokens,\r\n        address[] memory recipients,\r\n        uint256[] memory amounts\r\n    ) external;\r\n}\r\n\r\n// File: contracts/library/BridgeUtils.sol\r\n\r\npragma solidity ^0.8.7;\r\n\r\nlibrary BridgeUtils {\r\n    uint256 internal constant FUTURE_BLOCK_INTERVAL = 100;\r\n    uint256 public constant CHARGE_PERCENTAGE_DIVIDER = 10000;\r\n\r\n    function roundFuture(uint256 blockIndex) internal pure returns (uint64) {\r\n        uint256 _futureBlockIndex;\r\n        if (blockIndex <= FUTURE_BLOCK_INTERVAL) {\r\n            _futureBlockIndex = FUTURE_BLOCK_INTERVAL;\r\n        } else {\r\n            _futureBlockIndex =\r\n                FUTURE_BLOCK_INTERVAL *\r\n                ((blockIndex / FUTURE_BLOCK_INTERVAL) + 1);\r\n        }\r\n        return uint64(_futureBlockIndex);\r\n    }\r\n\r\n    function getFuture(uint256 blockIndex)\r\n        internal\r\n        pure\r\n        returns (uint64 futureBlockIndex)\r\n    {\r\n        uint256 _futureBlockIndex;\r\n        if (blockIndex <= FUTURE_BLOCK_INTERVAL) {\r\n            _futureBlockIndex = 0;\r\n        } else {\r\n            _futureBlockIndex =\r\n                FUTURE_BLOCK_INTERVAL *\r\n                (blockIndex / FUTURE_BLOCK_INTERVAL);\r\n        }\r\n        return uint64(_futureBlockIndex);\r\n    }\r\n\r\n    function getBlockScanRange(\r\n        uint16 count,\r\n        uint8[] memory networks,\r\n        mapping(uint8 => address) storage bridges\r\n    )\r\n        internal\r\n        view\r\n        returns (uint8[] memory _networks, uint64[][] memory _ranges)\r\n    {\r\n        _networks = new uint8[](count);\r\n        _ranges = new uint64[][](count);\r\n        uint64 k = 0;\r\n        for (uint64 i = 0; i < networks.length; i++) {\r\n            if (bridges[networks[i]] != address(0)) {\r\n                _networks[k] = networks[i];\r\n                _ranges[k] = IBridge(bridges[networks[i]]).blockScanRange();\r\n                k++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getCharges(\r\n        uint16 count,\r\n        uint8[] memory networks,\r\n        mapping(uint8 => address) storage bridges\r\n    ) internal view returns (TokensChargesInfo memory info) {\r\n        uint8[] memory _networks = new uint8[](count);\r\n        address[][] memory _tokens = new address[][](count);\r\n        uint256[][] memory _charges = new uint256[][](count);\r\n        uint64 k = 0;\r\n        for (uint64 i = 0; i < networks.length; i++) {\r\n            if (bridges[networks[i]] != address(0)) {\r\n                _networks[k] = networks[i];\r\n                (_tokens[k], _charges[k]) = IBridge(bridges[networks[i]])\r\n                    .charges();\r\n                k++;\r\n            }\r\n        }\r\n        info.ids = _networks;\r\n        info.tokens = _tokens;\r\n        info.charges = _charges;\r\n    }\r\n\r\n    function getTokenReq(\r\n        uint64 futureBlock,\r\n        address token,\r\n        uint64[] memory futureBlocks,\r\n        mapping(address => mapping(uint64 => TokenReq)) storage tokenReqs\r\n    ) internal view returns (uint256 amount, uint256 percent) {\r\n        TokenReq memory _req = getReq(\r\n            futureBlock,\r\n            token,\r\n            futureBlocks,\r\n            tokenReqs\r\n        );\r\n        amount = _req.minAmount;\r\n        percent = _req.chargePercent;\r\n    }\r\n\r\n    function getCollectedChargesCN(\r\n        ICrossBridgeStorageToken bridgeStorage,\r\n        uint8 networkId\r\n    ) internal view returns (TokensChargesInfo memory info) {\r\n        uint8[] memory _networks = new uint8[](1);\r\n        address[][] memory _tokens = new address[][](1);\r\n        uint256[][] memory _charges = new uint256[][](1);\r\n        _networks[0] = networkId;\r\n        (_tokens[0], _charges[0]) = bridgeStorage.charges();\r\n        info.ids = _networks;\r\n        info.tokens = _tokens;\r\n        info.charges = _charges;\r\n    }\r\n\r\n    function getTransactionInfo(\r\n        uint64 futureBlock,\r\n        address token,\r\n        uint256 amount,\r\n        uint64[] memory futureBlocks,\r\n        mapping(address => mapping(uint64 => TokenReq)) storage tokenReqs\r\n    ) internal view returns (uint256 fee, uint256 amountAfterCharge) {\r\n        TokenReq memory _req = getReq(\r\n            futureBlock,\r\n            token,\r\n            futureBlocks,\r\n            tokenReqs\r\n        );\r\n        fee = (amount * _req.chargePercent) / CHARGE_PERCENTAGE_DIVIDER;\r\n        amountAfterCharge = amount - fee;\r\n    }\r\n\r\n    function updateMap(\r\n        address[] memory arr,\r\n        bool status,\r\n        mapping(address => bool) storage map\r\n    ) internal {\r\n        for (uint64 i = 0; i < arr.length; i++) {\r\n            map[arr[i]] = status;\r\n        }\r\n    }\r\n\r\n    function getReq(\r\n        uint64 blockIndex,\r\n        address token,\r\n        uint64[] memory futureBlocks,\r\n        mapping(address => mapping(uint64 => TokenReq)) storage tokenReqs\r\n    ) internal view returns (TokenReq memory req) {\r\n        req = tokenReqs[token][blockIndex];\r\n        if (!req.exist) {\r\n            for (uint256 i = futureBlocks.length; i > 0; i--) {\r\n                if (futureBlocks[i - 1] <= blockIndex) {\r\n                    req = tokenReqs[token][futureBlocks[i - 1]];\r\n                    if (req.exist) return req;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getCountBySearchIndex(\r\n        uint64 searchBlockIndex,\r\n        address[] memory tokens,\r\n        mapping(address => bool) storage mapTokens,\r\n        mapping(address => uint64) storage mapTokenCreatedBlockIndex\r\n    ) internal view returns (uint64 k) {\r\n        for (uint64 i = 0; i < tokens.length; i++) {\r\n            if (\r\n                mapTokens[tokens[i]] &&\r\n                (mapTokenCreatedBlockIndex[tokens[i]] <= searchBlockIndex)\r\n            ) {\r\n                k++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/BaseCrossBridge/interface/ICrossBridgeStorage.sol\r\n\r\npragma solidity ^0.8.7;\r\n\r\ninterface ICrossBridgeStorage {\r\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\r\n\r\n    event SignersChanged(\r\n        address[] indexed oldSigners,\r\n        address[] indexed newSigners\r\n    );\r\n\r\n    event RelayersChanged(\r\n        address[] indexed oldRelayers,\r\n        address[] indexed newRelayers\r\n    );\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function admin() external view returns (address);\r\n\r\n    function bridge() external view returns (address);\r\n\r\n    function network() external view returns (NetworkInfo memory);\r\n\r\n    function epoch() external view returns (uint64);\r\n\r\n    function signers() external view returns (address[] memory);\r\n\r\n    function relayers() external view returns (address[] memory);\r\n\r\n    function mapSigner(address signer) external view returns (bool);\r\n\r\n    function mapRelayer(address relayer) external view returns (bool);\r\n\r\n    function setCallers(address admin, address bridge) external;\r\n\r\n    function setEpoch(uint64 epoch) external;\r\n\r\n    function setSigners(address[] memory signers_) external;\r\n\r\n    function setRelayers(address[] memory relayers_) external;\r\n\r\n    function signerVerification(\r\n        bytes32 msgHash,\r\n        uint8[] memory v,\r\n        bytes32[] memory r,\r\n        bytes32[] memory s\r\n    ) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\r\n\r\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/Initializable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\r\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() initializer {}\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(\r\n            _initializing || !_initialized,\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal initializer {\r\n        __Context_init_unchained();\r\n    }\r\n\r\n    function __Context_init_unchained() internal initializer {}\r\n\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\r\n\r\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init() internal initializer {\r\n        __Context_init_unchained();\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal initializer {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    uint256[49] private __gap;\r\n}\r\n\r\n// File: contracts/BaseCrossBridge/base/CrossBridgeStorageUpgradeable.sol\r\n\r\npragma solidity ^0.8.7;\r\n\r\ncontract CrossBridgeStorageUpgradeable is\r\n    Initializable,\r\n    OwnableUpgradeable,\r\n    ICrossBridgeStorage\r\n{\r\n    using BridgeSecurity for *;\r\n    using BridgeUtils for *;\r\n\r\n    address private _admin;\r\n    address private _bridge;\r\n\r\n    NetworkInfo private _network;\r\n    uint64 private _epoch;\r\n    address[] private _signers;\r\n    address[] private _relayers;\r\n    mapping(address => bool) private _mapSigners;\r\n    mapping(address => bool) private _mapRelayers;\r\n\r\n    function __CrossBridgeStorage_init(\r\n        uint8 networkId,\r\n        string memory networkName\r\n    ) internal initializer {\r\n        __Ownable_init();\r\n        _network.id = networkId;\r\n        _network.name = networkName;\r\n    }\r\n\r\n    function owner()\r\n        public\r\n        view\r\n        override(OwnableUpgradeable, ICrossBridgeStorage)\r\n        returns (address)\r\n    {\r\n        return OwnableUpgradeable.owner();\r\n    }\r\n\r\n    function admin() public view virtual override returns (address) {\r\n        return _admin;\r\n    }\r\n\r\n    function bridge() public view virtual override returns (address) {\r\n        return _bridge;\r\n    }\r\n\r\n    modifier onlyAllowedOwner() {\r\n        require(msg.sender == bridge() || msg.sender == admin());\r\n        _;\r\n    }\r\n\r\n    function network()\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (NetworkInfo memory)\r\n    {\r\n        return _network;\r\n    }\r\n\r\n    function epoch() external view virtual override returns (uint64) {\r\n        return _epoch;\r\n    }\r\n\r\n    function signers()\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (address[] memory)\r\n    {\r\n        return _signers;\r\n    }\r\n\r\n    function relayers()\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (address[] memory)\r\n    {\r\n        return _relayers;\r\n    }\r\n\r\n    function mapSigner(address signer)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _mapSigners[signer];\r\n    }\r\n\r\n    function mapRelayer(address relayer)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _mapRelayers[relayer];\r\n    }\r\n\r\n    function setCallers(address admin_, address bridge_)\r\n        external\r\n        virtual\r\n        override\r\n        onlyOwner\r\n    {\r\n        _admin = admin_;\r\n        _bridge = bridge_;\r\n    }\r\n\r\n    function setEpoch(uint64 epoch_)\r\n        external\r\n        virtual\r\n        override\r\n        onlyAllowedOwner\r\n    {\r\n        _epoch = epoch_;\r\n    }\r\n\r\n    function setSigners(address[] memory signers_)\r\n        external\r\n        virtual\r\n        override\r\n        onlyAllowedOwner\r\n    {\r\n        emit SignersChanged(_signers, signers_);\r\n        BridgeUtils.updateMap(_signers, false, _mapSigners);\r\n        delete _signers;\r\n        _signers = signers_;\r\n        BridgeUtils.updateMap(signers_, true, _mapSigners);\r\n    }\r\n\r\n    function setRelayers(address[] memory relayers_)\r\n        external\r\n        virtual\r\n        override\r\n        onlyAllowedOwner\r\n    {\r\n        emit RelayersChanged(_relayers, relayers_);\r\n        BridgeUtils.updateMap(_relayers, false, _mapRelayers);\r\n        delete _relayers;\r\n        _relayers = relayers_;\r\n        BridgeUtils.updateMap(relayers_, true, _mapRelayers);\r\n    }\r\n\r\n    function signerVerification(\r\n        bytes32 msgHash,\r\n        uint8[] memory v,\r\n        bytes32[] memory r,\r\n        bytes32[] memory s\r\n    ) external view virtual override returns (bool) {\r\n        return msgHash.signersVerification(v, r, s, _signers, _mapSigners);\r\n    }\r\n}\r\n\r\n// File: contracts/Net-Ethereum/Bridge/EthereumBridgeStorage.sol\r\n\r\npragma solidity ^0.8.7;\r\n\r\ncontract EthereumBridgeStorage is CrossBridgeStorageUpgradeable {\r\n    function initialize(uint8 networkId, string memory networkName)\r\n        public\r\n        initializer\r\n    {\r\n        __CrossBridgeStorage_init(networkId, networkName);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"oldRelayers\",\"type\":\"address[]\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"newRelayers\",\"type\":\"address[]\"}],\"name\":\"RelayersChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"oldSigners\",\"type\":\"address[]\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"newSigners\",\"type\":\"address[]\"}],\"name\":\"SignersChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"networkId\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"networkName\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"mapRelayer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"mapSigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"network\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct NetworkInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bridge_\",\"type\":\"address\"}],\"name\":\"setCallers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"epoch_\",\"type\":\"uint64\"}],\"name\":\"setEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"relayers_\",\"type\":\"address[]\"}],\"name\":\"setRelayers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"signers_\",\"type\":\"address[]\"}],\"name\":\"setSigners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"signerVerification\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EthereumBridgeStorage", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://386add1dcac5094ef22cc836bbbf10a8f9e02833a3f4c115319e9275a7bf0e8f"}]}