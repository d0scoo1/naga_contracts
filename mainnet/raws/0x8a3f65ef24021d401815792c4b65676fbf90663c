{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ArtblocksRoyaltyOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport \\\"./IRoyaltyOracle.sol\\\";\\n\\n/// Upstream royalty data interface implemented by Art Blocks contracts at\\n/// mainnet 0xa7d8d9ef8d8ce8992df33d8b8cf4aebabd5bd270 (standard) and\\n/// 0x059edd72cd353df5106d2b9cc5ab83a52287ac3a (legacy).\\ninterface IArtblocksRoyaltyDataSource {\\n    function artblocksAddress() external view returns (address);\\n\\n    function getRoyaltyData(uint256 _tokenId)\\n        external\\n        view\\n        returns (\\n            address artistAddress,\\n            address additionalPayee,\\n            uint256 additionalPayeePercentage,\\n            uint256 royaltyFeeByID\\n        );\\n}\\n\\ncontract ArtblocksRoyaltyOracle is IRoyaltyOracle {\\n    string constant ERR_PLATFORM_ROYALTY_TOO_HIGH =\\n        \\\"ArtblocksRoyaltyOracle: Art Blocks platform royalty exceeds total royalty\\\";\\n\\n    // There are three potential payees: the Art Blocks platform, the primary\\n    // artist, and the secondary artist.\\n    //\\n    // A fixed number of micros (specified in the `_data` parameter, and not to\\n    // exceed the total `_micros`) will be allocated to the Art Blocks\\n    // platform. The rest will be divided between the primary and secondary\\n    // artists according to the split percentage returned by `getRoyaltyData`,\\n    // which is clamped between `0` and `100` (i.e., splits higher than 100%\\n    // are treated as 100%).\\n    //\\n    // For example, if `_data == uint64(25000)` and `_micros == uint64(75000)`,\\n    // then a 2.5% royalty will be paid to Art Blocks and a 5% royalty will be\\n    // either paid to the sole artist or split between the two artists.\\n    //\\n    // Any payee address may be null. If the Art Blocks platform payee is null,\\n    // the platform royalty will be dropped. If both artists are null, the\\n    // artist royalty will be dropped. If exactly one artist is null, their\\n    // share will be allocated to the other artist. In no circumstance will a\\n    // royalty be paid to the zero address. If a call to `artblocksAddress` or\\n    // `getRoyaltyData` fails, the associated payees will be treated as null.\\n    function royalties(\\n        IERC721 _tokenContract,\\n        uint256 _tokenId,\\n        uint32 _micros,\\n        uint64 _data\\n    ) external view returns (RoyaltyResult[] memory) {\\n        IArtblocksRoyaltyDataSource _dataSource = IArtblocksRoyaltyDataSource(\\n            address(_tokenContract)\\n        );\\n\\n        if (uint256(_data) > uint256(_micros))\\n            revert(ERR_PLATFORM_ROYALTY_TOO_HIGH);\\n        uint32 _microsToArtblocks = uint32(_data);\\n        uint32 _microsToArtists = _micros - _microsToArtblocks;\\n\\n        address _artblocks = _getArtblocksAddress(_dataSource);\\n        if (_artblocks == address(0)) {\\n            _microsToArtblocks = 0;\\n            // Note: `_microsToArtists` has already been set; artists don't get\\n            // a higher royalty share just because the platform royalty payee\\n            // is null.\\n        }\\n\\n        (\\n            address _artist0,\\n            address _artist1,\\n            uint256 _artist1Percentage,\\n            uint256 _unusedRoyaltyFeeById\\n        ) = _getRoyaltyData(_dataSource, _tokenId);\\n        // Unused: `royaltyFeeByID` is meant to be an artist-specified total\\n        // royalty amount (as a percentage of sale price), but other\\n        // marketplaces don't actually honor this, so many projects have it set\\n        // to zero---presumably unintentionally. We don't want to unfairly\\n        // leave those artists out to dry, so we instead determine the total\\n        // royalty amount by the standard `_micros` argument to this function\\n        // (after subtracting the Art Blocks platform fee).\\n        _unusedRoyaltyFeeById;\\n\\n        // If the primary artist is the null address or would get nothing\\n        // because the split is too high, promote the secondary artist to\\n        // primary. (If this would make the primary artist null, we'll pay no\\n        // artist royalties at all; we may still pay Art Blocks royalties.)\\n        if (_artist0 == address(0) || _artist1Percentage >= 100) {\\n            _artist0 = _artist1;\\n            _artist1Percentage = 0;\\n        }\\n        // If the secondary artist is the null address, ignore it.\\n        if (_artist1 == address(0)) _artist1Percentage = 0;\\n\\n        // See which royalties we're actually going to pay.\\n        bool _hasArtblocks = _microsToArtblocks > 0;\\n        bool _hasArtist0 = _microsToArtists > 0 && _artist0 != address(0);\\n        bool _hasArtist1 = _hasArtist0 && _artist1Percentage > 0;\\n\\n        // Allocate appropriately sized return array.\\n        uint256 _nPayees = 0;\\n        if (_hasArtblocks) _nPayees++;\\n        if (_hasArtist0) _nPayees++;\\n        if (_hasArtist1) _nPayees++;\\n        RoyaltyResult[] memory _result = new RoyaltyResult[](_nPayees);\\n\\n        // Populate royalty entries.\\n        uint256 _nextRoyalty = 0;\\n        if (_hasArtblocks) {\\n            RoyaltyResult memory _royalty = _result[_nextRoyalty++];\\n            _royalty.recipient = _artblocks;\\n            _royalty.micros = _microsToArtblocks;\\n        }\\n        // This cast is lossless because `_micros` is a `uint32` and\\n        // `_artist1Percentage` is at most `100`.\\n        uint32 _microsToArtist0 = uint32(\\n            (uint256(_microsToArtists) * (100 - _artist1Percentage)) / 100\\n        );\\n        if (_hasArtist0) {\\n            RoyaltyResult memory _royalty = _result[_nextRoyalty++];\\n            _royalty.recipient = _artist0;\\n            _royalty.micros = _microsToArtist0;\\n        }\\n        if (_hasArtist1) {\\n            RoyaltyResult memory _royalty = _result[_nextRoyalty++];\\n            _royalty.recipient = _artist1;\\n            _royalty.micros = _microsToArtists - _microsToArtist0;\\n        }\\n        return _result;\\n    }\\n\\n    /// Infallibly gets the Art Blocks payee address, which may be null if the\\n    /// external call fails.\\n    function _getArtblocksAddress(IArtblocksRoyaltyDataSource _dataSource)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        try _dataSource.artblocksAddress() returns (address _artblocksAddress) {\\n            return _artblocksAddress;\\n        } catch {\\n            return address(0);\\n        }\\n    }\\n\\n    /// Infallibly gets the royalty data for a token, which may be null if the\\n    /// external call fails.\\n    function _getRoyaltyData(\\n        IArtblocksRoyaltyDataSource _dataSource,\\n        uint256 _tokenId\\n    )\\n        internal\\n        view\\n        returns (\\n            address artistAddress,\\n            address additionalPayee,\\n            uint256 additionalPayeePercentage,\\n            uint256 royaltyFeeByID\\n        )\\n    {\\n        try _dataSource.getRoyaltyData(_tokenId) returns (\\n            address _artistAddress,\\n            address _additionalPayee,\\n            uint256 _additionalPayeePercentage,\\n            uint256 _royaltyFeeByID\\n        ) {\\n            return (\\n                _artistAddress,\\n                _additionalPayee,\\n                _additionalPayeePercentage,\\n                _royaltyFeeByID\\n            );\\n        } catch {\\n            return (address(0), address(0), 0, 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IRoyaltyOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IRoyaltyOracle {\\n    function royalties(\\n        IERC721 _tokenContract,\\n        uint256 _tokenId,\\n        uint32 _micros,\\n        uint64 _data\\n    ) external view returns (RoyaltyResult[] memory);\\n}\\n\\nstruct RoyaltyResult {\\n    address recipient;\\n    uint32 micros;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_micros\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"_data\",\"type\":\"uint64\"}],\"name\":\"royalties\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"micros\",\"type\":\"uint32\"}],\"internalType\":\"struct RoyaltyResult[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ArtblocksRoyaltyOracle", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}