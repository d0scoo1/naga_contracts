{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"address-utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.4.11;\\n\\n/**\\n * @dev Utility library of inline functions on addresses.\\n * @notice Based on:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\\n * Requires EIP-1052.\\n */\\nlibrary AddressUtils\\n{\\n\\n  /**\\n   * @dev Returns whether the target address is a contract.\\n   * @param _addr Address to check.\\n   * @return addressCheck True if _addr is a contract, false if not.\\n   */\\n  function isContract(\\n    address _addr\\n  )\\n    internal\\n    view\\n    returns (bool addressCheck)\\n  {\\n    // This method relies in extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n //   assembly { codehash := extcodehash(_addr) } // solhint-disable-line\\n    addressCheck = (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\n  }\\n\\n}\\n\"},\"EpigeonInterfaces.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.4.11;\\r\\n\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface IERC777 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function granularity() external view returns (uint256);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n    function send(address recipient, uint256 amount, bytes data) external;\\r\\n    function burn(uint256 amount, bytes data) external;\\r\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\r\\n    function authorizeOperator(address operator) external;\\r\\n    function revokeOperator(address operator) external;\\r\\n    function defaultOperators() external view returns (address[] memory);\\r\\n    function operatorSend(address sender, address recipient, uint256 amount, bytes data, bytes operatorData) external;\\r\\n    function operatorBurn(address account, uint256 amount, bytes data, bytes operatorData) external;\\r\\n    event Sent( address indexed operator, address indexed from, address indexed to, uint256 amount, bytes data, bytes operatorData);\\r\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\r\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\r\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\r\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface ILockable {\\r\\n    function lock(address to, uint256 amount, bytes32 hash) external;\\r\\n    function operatorLock(address from, address to, uint256 amount, bytes32 hash, bytes data, bytes operatorData) external;\\r\\n    function unlock(string unlockerPhrase) external;\\r\\n    function operatorUnlock(address to, string unlockerPhrase, bytes data, bytes operatorData) external;\\r\\n    function reclaim(address to, string unlockerPhrase) external;\\r\\n    function operatorReclaim(address from, address to, string unlockerPhrase, bytes data, bytes operatorData) external;\\r\\n    function unlockByLockedCoinContract(address to, bytes32 hash) external;\\r\\n    function reclaimByLockedCoinContract(address from, address to, bytes32 hash) external;\\r\\n    function lockedSupply() external view returns (uint256 locked_supply);\\r\\n    function lockedAmount(address from, bytes32 hash) external view returns (uint256 amount);\\r\\n    function lockedBalanceOf(address account) external view returns (uint256);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface IPigeonFactory {\\r\\n    function createCryptoPigeon(address to) external returns (ICryptoPigeon pigeonAddress);    \\r\\n    function iAmFactory() external pure returns (bool);\\r\\n    function amIEpigeon() external returns (bool);\\r\\n    function factoryId() external view returns (uint256 id);\\r\\n    function getMetaDataForPigeon(address pigeon) external view returns (string metadata);\\r\\n    function mintingPrice() external view returns (uint256 price);\\r\\n    function totalSupply() external view returns (uint256 supply);\\r\\n    function maxSupply() external view returns (uint256 supply);\\r\\n    function getFactoryTokenPrice(address ERC20Token) external view returns (uint256 price);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface ICryptoPigeon {\\r\\n    function burnPigeon() external;    \\r\\n    function iAmPigeon() external pure returns (bool); \\r\\n    function transferPigeon(address newOwner) external; \\r\\n    function hasFlown() external view returns (bool);\\r\\n    function toAddress() external view returns (address addressee);   \\r\\n    function owner() external view returns (address ownerAddress);\\r\\n    function manager() external view returns (address managerAddress);\\r\\n    function factoryId() external view returns (uint256 id);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface IEpigeon {\\r\\n    function pigeonDestinations() external view returns (IPigeonDestinationDirectory destinations);\\r\\n    function nameAndKeyDirectory() external view returns (INameAndPublicKeyDirectory directory);\\r\\n    function getLastFactoryId() external view returns (uint256 id);\\r\\n    function getFactoryAddresstoId(uint256 id) external view returns (address factoryAddress);\\r\\n    function getPigeonPriceForFactory(uint256 factoryId) external view returns (uint256 price);\\r\\n    function getPigeonTokenPriceForFactory(address ERC20Token, uint256 factoryId) external view returns (uint256 price);\\r\\n    function createCryptoPigeonNFT(address to, uint256 factoryId) external returns (address pigeonaddress);\\r\\n    function transferPigeon(address from, address to, address pigeon) external;\\r\\n    function burnPigeon(address pigeon) external;\\r\\n    function nftContractAddress() external view returns (address nftContract);\\r\\n    function validPigeon(address pigeon, address pigeonOwner) external view returns (bool);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface IEpigeonNFT {\\r\\n    function isTokenizedPigeon(address pigeon) external view returns (bool);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface INameAndPublicKeyDirectory {\\r\\n    function getPublicKeyForAddress (address owner) external view returns (string key); \\r\\n    function getUserNameForAddress (address owner) external view returns (string name);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface IPigeonDestinationDirectory{\\r\\n    function changeToAddress(address newToAddress, address oldToAddress) external;\\r\\n    function setToAddress(address newToAddress) external;\\r\\n    function deleteToAddress(address oldToAddress) external;\\r\\n    function deleteToAddressByEpigeon(address pigeon) external;\\r\\n    function pigeonsSentToAddressLenght(address toAddress) external view returns (uint256 length);\\r\\n    function pigeonSentToAddressByIndex(address toAddress, uint index) external view returns (address pigeonAddress);   \\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface IPigeonManagerDirectory{\\r\\n    function changeManager(address newManager, address oldManager) external;\\r\\n    function deleteManager(address oldManager) external;\\r\\n    function setManager(address newManager) external;\\r\\n    function pigeonsOfManagerLenght(address toAddress) external view returns (uint256 length);\\r\\n    function pigeonOfManagerByIndex(address toAddress, uint index) external view returns (address pigeonAddress);   \\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\n\\r\\n\"},\"EpigeonNFT.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.4.11;\\n\\nimport \\\"./nf-token-enumerable.sol\\\";\\nimport \\\"./EpigeonInterfaces.sol\\\";\\n\\n//----------------------------------------------------------------------------------\\n\\ncontract EpigeonNFT is NFTokenEnumerable{\\n    IEpigeon public epigeon;\\n      \\n    address public owner;\\n    string public name;\\n    string public symbol;\\n    mapping (uint256 =\\u003e address) internal idtoCryptoPigeon;\\n    mapping (address =\\u003e uint256) internal cryptoPigeonToId;\\n    uint256 public mintingPrice = 1000000000000000;\\n    uint256 public highestTokenId;\\n    bool public freeMintEnabled;\\n    mapping (address =\\u003e uint256) internal approvedTokenPrice;\\n    \\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    \\n    constructor (string memory _name, string memory _symbol, address _epigeon){\\n        owner = msg.sender;\\n        epigeon = IEpigeon(_epigeon);\\n        name = _name;\\n        symbol = _symbol;\\n        highestTokenId = 0;\\n    }\\n    \\n    function burn(uint256 tokenId) public {\\n        require(msg.sender == ICryptoPigeon(idtoCryptoPigeon[tokenId]).owner());\\n        require(epigeon.nftContractAddress() == address(this));\\n        epigeon.burnPigeon(idtoCryptoPigeon[tokenId]);\\n        delete cryptoPigeonToId[idtoCryptoPigeon[tokenId]];\\n        delete idtoCryptoPigeon[tokenId];\\n        super._burn(tokenId);\\n    }\\n    \\n    function burnPigeonToken(uint256 tokenId) public {\\n        require(msg.sender == ICryptoPigeon(idtoCryptoPigeon[tokenId]).owner());\\n        require(epigeon.nftContractAddress() == address(this));\\n        delete cryptoPigeonToId[idtoCryptoPigeon[tokenId]];\\n        delete idtoCryptoPigeon[tokenId];\\n        super._burn(tokenId);\\n    }\\n    \\n    function isTokenizedPigeon(address pigeon) public view returns (bool tokenized){\\n        return idtoCryptoPigeon[cryptoPigeonToId[pigeon]] == pigeon;\\n    }\\n    \\n    function mintingTokenPrice(address ERC20Token) public view returns (uint256 price){\\n        return approvedTokenPrice[ERC20Token];\\n    }\\n    \\n    function mintForEther(uint256 factoryId) public payable {\\n        require(msg.value \\u003e= mintingPrice + epigeon.getPigeonPriceForFactory(factoryId), \\\"Not enough value\\\");      \\n        _mintForAddress(msg.sender, factoryId);\\n    }\\n    \\n    function mintForFree() public {\\n        require(freeMintEnabled || msg.sender == owner);                \\n        _mintForAddress(msg.sender, epigeon.getLastFactoryId());\\n    }\\n    \\n    function mintForToken(address ERC20Token, uint256 factoryId) public returns (bool){\\n        require (approvedTokenPrice[ERC20Token] \\u003e 0);\\n        require (epigeon.getPigeonTokenPriceForFactory(ERC20Token, factoryId) \\u003e 0);\\n        uint256 price = approvedTokenPrice[ERC20Token] + epigeon.getPigeonTokenPriceForFactory(ERC20Token, factoryId);\\n        if (IERC20(ERC20Token).transferFrom(msg.sender, owner, price) == true)\\n        {\\n            _mintForAddress(msg.sender, factoryId);\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    function payout() public {\\n        require(msg.sender == owner);\\n        owner.transfer(address(this).balance);\\n    }\\n    \\n    function pigeonAddressToToken(address pigeon) public view returns (uint256  tokenId){\\n        return cryptoPigeonToId[pigeon];\\n    }\\n    \\n    function setFreeMintEnabled(bool enabled) public {\\n        require(msg.sender == owner);\\n        freeMintEnabled = enabled;\\n    }\\n    \\n    function setMintingPrice(uint256 price) public {\\n        require(msg.sender == owner);\\n        mintingPrice = price;\\n    }\\n    \\n    function setMintingPrice(address ERC20Token, uint256 price) public {\\n        require(msg.sender == owner);\\n        approvedTokenPrice[ERC20Token] = price;\\n    }\\n    \\n    function tokenContractAddress(uint256  tokenId) public view validNFToken(tokenId) returns (address rpigeon){\\n        return idtoCryptoPigeon[tokenId];\\n    }\\n    \\n    function tokenizePigeon(address pigeon) public payable{\\n        require(msg.value \\u003e= mintingPrice, \\\"Not enough value\\\");\\n        require(cryptoPigeonToId[pigeon] == 0);\\n        require(ICryptoPigeon(pigeon).owner() == msg.sender);\\n        require(ICryptoPigeon(pigeon).iAmPigeon());\\n        require(epigeon.validPigeon(pigeon, msg.sender));\\n        require(epigeon.nftContractAddress() == address(this));\\n        highestTokenId++;\\n        uint256 tokenId = highestTokenId;\\n        super._mint(msg.sender, tokenId);\\n        _setTokenContractAddress(tokenId, pigeon);\\n    }\\n    \\n    function tokenURI(uint256 tokenId) public view returns (string metadata){\\n        metadata = IPigeonFactory(epigeon.getFactoryAddresstoId(ICryptoPigeon(idtoCryptoPigeon[tokenId]).factoryId())).getMetaDataForPigeon(idtoCryptoPigeon[tokenId]);\\n        return metadata;\\n    }\\n    \\n    function _mintForAddress(address to, uint256 factoryId) internal {\\n        require(epigeon.nftContractAddress() == address(this));\\n        highestTokenId++;\\n        uint256 tokenId = highestTokenId;\\n        address pigeon = epigeon.createCryptoPigeonNFT(to, factoryId);\\n        super._mint(to, tokenId);\\n        _setTokenContractAddress(tokenId, pigeon);\\n    }\\n    \\n    function _setTokenContractAddress(uint256  tokenId, address  pigeon) internal validNFToken(tokenId) {\\n        idtoCryptoPigeon[tokenId] = pigeon;\\n        cryptoPigeonToId[pigeon] = tokenId;\\n    }\\n    \\n    function transferOwnership(address newOwner) public {    \\n        require(owner == msg.sender, \\\"Only owner\\\");\\n        require(newOwner != address(0), \\\"Zero address\\\");\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner.transfer(address(this).balance);\\n        owner = newOwner;\\n    }\\n    \\n    function _transfer(address to, uint256 tokenId) internal {\\n        require(epigeon.nftContractAddress() == address(this));\\n        epigeon.transferPigeon(ICryptoPigeon(idtoCryptoPigeon[tokenId]).owner(), to, idtoCryptoPigeon[tokenId]);\\n        super._transfer(to, tokenId);\\n    }\\n}\\n\\n\\n\"},\"erc165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.4.11;\\n\\n/**\\n * @dev A standard for detecting smart contract interfaces. \\n * See: https://eips.ethereum.org/EIPS/eip-165.\\n */\\ninterface ERC165\\n{\\n\\n  /**\\n   * @dev Checks if the smart contract includes a specific interface.\\n   * This function uses less than 30,000 gas.\\n   * @param _interfaceID The interface identifier, as specified in ERC-165.\\n   * @return True if _interfaceID is supported, false otherwise.\\n   */\\n  function supportsInterface(\\n    bytes4 _interfaceID\\n  )\\n    external\\n    view\\n    returns (bool);\\n    \\n}\\n\"},\"erc721-enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.4.11;\\n\\n/**\\n * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\n */\\ninterface ERC721Enumerable\\n{\\n\\n  /**\\n   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\\n   * assigned and queryable owner not equal to the zero address.\\n   * @return Total supply of NFTs.\\n   */\\n  function totalSupply()\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\\n   * @param _index A counter less than `totalSupply()`.\\n   * @return Token id.\\n   */\\n  function tokenByIndex(\\n    uint256 _index\\n  )\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\\n   * not specified. It throws if `_index` \\u003e= `balanceOf(_owner)` or if `_owner` is the zero address,\\n   * representing invalid NFTs.\\n   * @param _owner An address where we are interested in NFTs owned by them.\\n   * @param _index A counter less than `balanceOf(_owner)`.\\n   * @return Token id.\\n   */\\n  function tokenOfOwnerByIndex(\\n    address _owner,\\n    uint256 _index\\n  )\\n    external\\n    view\\n    returns (uint256);\\n\\n}\\n\"},\"erc721-token-receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.4.11;\\n\\n/**\\n * @dev ERC-721 interface for accepting safe transfers.\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\n */\\ninterface ERC721TokenReceiver\\n{\\n\\n  /**\\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\\n   * of other than the magic value MUST result in the transaction being reverted.\\n   * Returns `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))` unless throwing.\\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\\n   * MUST implement the wallet interface if it will accept safe transfers.\\n   * @param _operator The address which called `safeTransferFrom` function.\\n   * @param _from The address which previously owned the token.\\n   * @param _tokenId The NFT identifier which is being transferred.\\n   * @param _data Additional data with no specified format.\\n   * @return Returns `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n   */\\n  function onERC721Received(\\n    address _operator,\\n    address _from,\\n    uint256 _tokenId,\\n    bytes _data\\n  )\\n    external\\n    returns(bytes4);\\n\\n}\\n\"},\"erc721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.4.11;\\n\\n/**\\n * @dev ERC-721 non-fungible token standard.\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\n */\\ninterface ERC721\\n{\\n\\n  /**\\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\\n   * transfer, the approved address for that NFT (if any) is reset to none.\\n   */\\n  event Transfer(\\n    address indexed _from,\\n    address indexed _to,\\n    uint256 indexed _tokenId\\n  );\\n\\n  /**\\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\\n   * address indicates there is no approved address. When a Transfer event emits, this also\\n   * indicates that the approved address for that NFT (if any) is reset to none.\\n   */\\n  event Approval(\\n    address indexed _owner,\\n    address indexed _approved,\\n    uint256 indexed _tokenId\\n  );\\n\\n  /**\\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\\n   * all NFTs of the owner.\\n   */\\n  event ApprovalForAll(\\n    address indexed _owner,\\n    address indexed _operator,\\n    bool _approved\\n  );\\n\\n  /**\\n   * @dev Transfers the ownership of an NFT from one address to another address.\\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\\n   * function checks if `_to` is a smart contract (code size \\u003e 0). If so, it calls\\n   * `onERC721Received` on `_to` and throws if the return value is not\\n   * `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   * @param _data Additional data with no specified format, sent in call to `_to`.\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes _data\\n  )\\n    external;\\n\\n  /**\\n   * @dev Transfers the ownership of an NFT from one address to another address.\\n   * @notice This works identically to the other function with an extra data parameter, except this\\n   * function just sets data to \\\"\\\"\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    external;\\n\\n  /**\\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\\n   * address. Throws if `_tokenId` is not a valid NFT.\\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\\n   * they mayb be permanently lost.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   */\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    external;\\n\\n  /**\\n   * @dev Set or reaffirm the approved address for an NFT.\\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\\n   * the current NFT owner, or an authorized operator of the current owner.\\n   * @param _approved The new approved NFT controller.\\n   * @param _tokenId The NFT to approve.\\n   */\\n  function approve(\\n    address _approved,\\n    uint256 _tokenId\\n  )\\n    external;\\n\\n  /**\\n   * @dev Enables or disables approval for a third party (\\\"operator\\\") to manage all of\\n   * `msg.sender`\\u0027s assets. It also emits the ApprovalForAll event.\\n   * @notice The contract MUST allow multiple operators per owner.\\n   * @param _operator Address to add to the set of authorized operators.\\n   * @param _approved True if the operators is approved, false to revoke approval.\\n   */\\n  function setApprovalForAll(\\n    address _operator,\\n    bool _approved\\n  )\\n    external;\\n\\n  /**\\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\\n   * considered invalid, and this function throws for queries about the zero address.\\n   * @param _owner Address for whom to query the balance.\\n   * @return Balance of _owner.\\n   */\\n  function balanceOf(\\n    address _owner\\n  )\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\\n   * invalid, and queries about them do throw.\\n   * @param _tokenId The identifier for an NFT.\\n   * @return Address of _tokenId owner.\\n   */\\n  function ownerOf(\\n    uint256 _tokenId\\n  )\\n    external\\n    view\\n    returns (address);\\n\\n  /**\\n   * @dev Get the approved address for a single NFT.\\n   * @notice Throws if `_tokenId` is not a valid NFT.\\n   * @param _tokenId The NFT to find the approved address for.\\n   * @return Address that _tokenId is approved for.\\n   */\\n  function getApproved(\\n    uint256 _tokenId\\n  )\\n    external\\n    view\\n    returns (address);\\n\\n  /**\\n   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\\n   * @param _owner The address that owns the NFTs.\\n   * @param _operator The address that acts on behalf of the owner.\\n   * @return True if approved for all, false otherwise.\\n   */\\n  function isApprovedForAll(\\n    address _owner,\\n    address _operator\\n  )\\n    external\\n    view\\n    returns (bool);\\n\\n}\\n\"},\"nf-token-enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.4.11;\\n\\nimport \\\"./nf-token.sol\\\";\\nimport \\\"./erc721-enumerable.sol\\\";\\n\\n/**\\n * @dev Optional enumeration implementation for ERC-721 non-fungible token standard.\\n */\\ncontract NFTokenEnumerable is\\n  NFToken,\\n  ERC721Enumerable\\n{\\n\\n  /**\\n   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\\n   * Based on 0xcert framework error codes.\\n   */\\n  string constant INVALID_INDEX = \\\"005007\\\";\\n\\n  /**\\n   * @dev Array of all NFT IDs.\\n   */\\n  uint256[] internal tokens;\\n\\n  /**\\n   * @dev Mapping from token ID to its index in global tokens array.\\n   */\\n  mapping(uint256 =\\u003e uint256) internal idToIndex;\\n\\n  /**\\n   * @dev Mapping from owner to list of owned NFT IDs.\\n   */\\n  mapping(address =\\u003e uint256[]) internal ownerToIds;\\n\\n  /**\\n   * @dev Mapping from NFT ID to its index in the owner tokens list.\\n   */\\n  mapping(uint256 =\\u003e uint256) internal idToOwnerIndex;\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor()\\n  {\\n    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\\n  }\\n\\n  /**\\n   * @dev Returns the count of all existing NFTokens.\\n   * @return Total supply of NFTs.\\n   */\\n  function totalSupply()\\n    external\\n    //override\\n    view\\n    returns (uint256)\\n  {\\n    return tokens.length;\\n  }\\n\\n  /**\\n   * @dev Returns NFT ID by its index.\\n   * @param _index A counter less than `totalSupply()`.\\n   * @return Token id.\\n   */\\n  function tokenByIndex(\\n    uint256 _index\\n  )\\n    external\\n    //override\\n    view\\n    returns (uint256)\\n  {\\n    require(_index \\u003c tokens.length, INVALID_INDEX);\\n    return tokens[_index];\\n  }\\n\\n  /**\\n   * @dev returns the n-th NFT ID from a list of owner\\u0027s tokens.\\n   * @param _owner Token owner\\u0027s address.\\n   * @param _index Index number representing n-th token in owner\\u0027s list of tokens.\\n   * @return Token id.\\n   */\\n  function tokenOfOwnerByIndex(\\n    address _owner,\\n    uint256 _index\\n  )\\n    external\\n   // override\\n    view\\n    returns (uint256)\\n  {\\n    require(_index \\u003c ownerToIds[_owner].length, INVALID_INDEX);\\n    return ownerToIds[_owner][_index];\\n  }\\n\\n  /**\\n   * @dev Mints a new NFT.\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * mint function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation.\\n   * @param _to The address that will own the minted NFT.\\n   * @param _tokenId of the NFT to be minted by the msg.sender.\\n   */\\n  function _mint(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n    //override\\n    //virtual\\n  {\\n    super._mint(_to, _tokenId);\\n    tokens.push(_tokenId);\\n    idToIndex[_tokenId] = tokens.length - 1;\\n  }\\n\\n  /**\\n   * @dev Burns a NFT.\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * burn function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\\n   * NFT.\\n   * @param _tokenId ID of the NFT to be burned.\\n   */\\n  function _burn(\\n    uint256 _tokenId\\n  )\\n    internal\\n  //  override\\n   // virtual\\n  {\\n    super._burn(_tokenId);\\n\\n    uint256 tokenIndex = idToIndex[_tokenId];\\n    uint256 lastTokenIndex = tokens.length - 1;\\n    uint256 lastToken = tokens[lastTokenIndex];\\n\\n    tokens[tokenIndex] = lastToken;\\n\\n    //tokens.pop();\\n    delete tokens[lastTokenIndex];\\n    tokens.length--;\\n    // This wastes gas if you are burning the last token but saves a little gas if you are not.\\n    idToIndex[lastToken] = tokenIndex;\\n    idToIndex[_tokenId] = 0;\\n  }\\n\\n  /**\\n   * @dev Removes a NFT from an address.\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @param _from Address from wich we want to remove the NFT.\\n   * @param _tokenId Which NFT we want to remove.\\n   */\\n  function _removeNFToken(\\n    address _from,\\n    uint256 _tokenId\\n  )\\n    internal\\n  //  override\\n  //  virtual\\n  {\\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\\n    delete idToOwner[_tokenId];\\n\\n    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\\n    uint256 lastTokenIndex = ownerToIds[_from].length - 1;\\n\\n    if (lastTokenIndex != tokenToRemoveIndex)\\n    {\\n      uint256 lastToken = ownerToIds[_from][lastTokenIndex];\\n      ownerToIds[_from][tokenToRemoveIndex] = lastToken;\\n      idToOwnerIndex[lastToken] = tokenToRemoveIndex;\\n    }\\n\\n    //ownerToIds[_from].pop();\\n    delete ownerToIds[_from][lastTokenIndex];\\n    ownerToIds[_from].length--;\\n  }\\n\\n  /**\\n   * @dev Assignes a new NFT to an address.\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @param _to Address to wich we want to add the NFT.\\n   * @param _tokenId Which NFT we want to add.\\n   */\\n  function _addNFToken(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n //   override\\n  //  virtual\\n  {\\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\\n    idToOwner[_tokenId] = _to;\\n\\n    ownerToIds[_to].push(_tokenId);\\n    idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;\\n  }\\n\\n  /**\\n   *\u00a0@dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\\n   * extension to remove double storage(gas optimization) of owner nft count.\\n   * @param _owner Address for whom to query the count.\\n   * @return Number of _owner NFTs.\\n   */\\n  function _getOwnerNFTCount(\\n    address _owner\\n  )\\n    internal\\n //   override\\n  //  virtual\\n    view\\n    returns (uint256)\\n  {\\n    return ownerToIds[_owner].length;\\n  }\\n}\\n\"},\"nf-token.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.4.11;\\n\\nimport \\\"./erc721.sol\\\";\\nimport \\\"./erc721-token-receiver.sol\\\";\\nimport \\\"./supports-interface.sol\\\";\\nimport \\\"./address-utils.sol\\\";\\n\\n/**\\n * @dev Implementation of ERC-721 non-fungible token standard.\\n */\\ncontract NFToken is\\n  ERC721,\\n  SupportsInterface\\n{\\n  using AddressUtils for address;\\n\\n  /**\\n   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\\n   * Based on 0xcert framework error codes.\\n   */\\n  string constant ZERO_ADDRESS = \\\"003001\\\";\\n  string constant NOT_VALID_NFT = \\\"003002\\\";\\n  string constant NOT_OWNER_OR_OPERATOR = \\\"003003\\\";\\n  string constant NOT_OWNER_APPROVED_OR_OPERATOR = \\\"003004\\\";\\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \\\"003005\\\";\\n  string constant NFT_ALREADY_EXISTS = \\\"003006\\\";\\n  string constant NOT_OWNER = \\\"003007\\\";\\n  string constant IS_OWNER = \\\"003008\\\";\\n\\n  /**\\n   * @dev Magic value of a smart contract that can recieve NFT.\\n   * Equal to: bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\")).\\n   */\\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\\n\\n  /**\\n   * @dev A mapping from NFT ID to the address that owns it.\\n   */\\n  mapping (uint256 =\\u003e address) internal idToOwner;\\n\\n  /**\\n   * @dev Mapping from NFT ID to approved address.\\n   */\\n  mapping (uint256 =\\u003e address) internal idToApproval;\\n\\n   /**\\n   * @dev Mapping from owner address to count of his tokens.\\n   */\\n  mapping (address =\\u003e uint256) private ownerToNFTokenCount;\\n\\n  /**\\n   * @dev Mapping from owner address to mapping of operator addresses.\\n   */\\n  mapping (address =\\u003e mapping (address =\\u003e bool)) internal ownerToOperators;\\n\\n  /**\\n   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\\n   * @param _tokenId ID of the NFT to validate.\\n   */\\n  modifier canOperate(\\n    uint256 _tokenId\\n  )\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    require(\\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\\n      NOT_OWNER_OR_OPERATOR\\n    );\\n    _;\\n  }\\n\\n  /**\\n   * @dev Guarantees that the msg.sender is allowed to transfer NFT.\\n   * @param _tokenId ID of the NFT to transfer.\\n   */\\n  modifier canTransfer(\\n    uint256 _tokenId\\n  )\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    require(\\n      tokenOwner == msg.sender\\n      || idToApproval[_tokenId] == msg.sender\\n      || ownerToOperators[tokenOwner][msg.sender],\\n      NOT_OWNER_APPROVED_OR_OPERATOR\\n    );\\n    _;\\n  }\\n\\n  /**\\n   * @dev Guarantees that _tokenId is a valid Token.\\n   * @param _tokenId ID of the NFT to validate.\\n   */\\n  modifier validNFToken(\\n    uint256 _tokenId\\n  )\\n  {\\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor()\\n  {\\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\\n  }\\n\\n  /**\\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\\n   * be changed to payable.\\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\\n   * function checks if `_to` is a smart contract (code size \\u003e 0). If so, it calls\\n   * `onERC721Received` on `_to` and throws if the return value is not\\n   * `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   * @param _data Additional data with no specified format, sent in call to `_to`.\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes  _data\\n  )\\n    external\\n   // override\\n  {\\n    _safeTransferFrom(_from, _to, _tokenId, _data);\\n  }\\n\\n  /**\\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\\n   * be changed to payable.\\n   * @notice This works identically to the other function with an extra data parameter, except this\\n   * function just sets data to \\\"\\\"\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    external\\n    //override\\n  {\\n    _safeTransferFrom(_from, _to, _tokenId, \\\"\\\");\\n  }\\n\\n  /**\\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\\n   * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\\n   * they maybe be permanently lost.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   */\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    external\\n  //  override\\n    canTransfer(_tokenId)\\n    validNFToken(_tokenId)\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    require(tokenOwner == _from, NOT_OWNER);\\n    require(_to != address(0), ZERO_ADDRESS);\\n\\n    _transfer(_to, _tokenId);\\n  }\\n\\n  /**\\n   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\\n   * the current NFT owner, or an authorized operator of the current owner.\\n   * @param _approved Address to be approved for the given NFT ID.\\n   * @param _tokenId ID of the token to be approved.\\n   */\\n  function approve(\\n    address _approved,\\n    uint256 _tokenId\\n  )\\n    external\\n//    override\\n    canOperate(_tokenId)\\n    validNFToken(_tokenId)\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    require(_approved != tokenOwner, IS_OWNER);\\n\\n    idToApproval[_tokenId] = _approved;\\n    emit Approval(tokenOwner, _approved, _tokenId);\\n  }\\n\\n  /**\\n   * @dev Enables or disables approval for a third party (\\\"operator\\\") to manage all of\\n   * `msg.sender`\\u0027s assets. It also emits the ApprovalForAll event.\\n   * @notice This works even if sender doesn\\u0027t own any tokens at the time.\\n   * @param _operator Address to add to the set of authorized operators.\\n   * @param _approved True if the operators is approved, false to revoke approval.\\n   */\\n  function setApprovalForAll(\\n    address _operator,\\n    bool _approved\\n  )\\n    external\\n//    override\\n  {\\n    ownerToOperators[msg.sender][_operator] = _approved;\\n    emit ApprovalForAll(msg.sender, _operator, _approved);\\n  }\\n\\n  /**\\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\\n   * considered invalid, and this function throws for queries about the zero address.\\n   * @param _owner Address for whom to query the balance.\\n   * @return Balance of _owner.\\n   */\\n  function balanceOf(\\n    address _owner\\n  )\\n    external\\n //   override\\n    view\\n    returns (uint256)\\n  {\\n    require(_owner != address(0), ZERO_ADDRESS);\\n    return _getOwnerNFTCount(_owner);\\n  }\\n\\n  /**\\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\\n   * invalid, and queries about them do throw.\\n   * @param _tokenId The identifier for an NFT.\\n   * @return _owner Address of _tokenId owner.\\n   */\\n  function ownerOf(\\n    uint256 _tokenId\\n  )\\n    external\\n//    override\\n    view\\n    returns (address _owner)\\n  {\\n    _owner = idToOwner[_tokenId];\\n    require(_owner != address(0), NOT_VALID_NFT);\\n  }\\n\\n  /**\\n   * @dev Get the approved address for a single NFT.\\n   * @notice Throws if `_tokenId` is not a valid NFT.\\n   * @param _tokenId ID of the NFT to query the approval of.\\n   * @return Address that _tokenId is approved for.\\n   */\\n  function getApproved(\\n    uint256 _tokenId\\n  )\\n    external\\n//    override\\n    view\\n    validNFToken(_tokenId)\\n    returns (address)\\n  {\\n    return idToApproval[_tokenId];\\n  }\\n\\n  /**\\n   * @dev Checks if `_operator` is an approved operator for `_owner`.\\n   * @param _owner The address that owns the NFTs.\\n   * @param _operator The address that acts on behalf of the owner.\\n   * @return True if approved for all, false otherwise.\\n   */\\n  function isApprovedForAll(\\n    address _owner,\\n    address _operator\\n  )\\n    external\\n//    override\\n    view\\n    returns (bool)\\n  {\\n    return ownerToOperators[_owner][_operator];\\n  }\\n\\n  /**\\n   * @dev Actually preforms the transfer.\\n   * @notice Does NO checks.\\n   * @param _to Address of a new owner.\\n   * @param _tokenId The NFT that is being transferred.\\n   */\\n  function _transfer(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n//    virtual\\n  {\\n    address from = idToOwner[_tokenId];\\n    _clearApproval(_tokenId);\\n\\n    _removeNFToken(from, _tokenId);\\n    _addNFToken(_to, _tokenId);\\n\\n    emit Transfer(from, _to, _tokenId);\\n  }\\n\\n  /**\\n   * @dev Mints a new NFT.\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * mint function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation.\\n   * @param _to The address that will own the minted NFT.\\n   * @param _tokenId of the NFT to be minted by the msg.sender.\\n   */\\n  function _mint(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n//    virtual\\n  {\\n    require(_to != address(0), ZERO_ADDRESS);\\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\\n\\n    _addNFToken(_to, _tokenId);\\n\\n    emit Transfer(address(0), _to, _tokenId);\\n  }\\n\\n  /**\\n   * @dev Burns a NFT.\\n   * @notice This is an internal function which should be called from user-implemented external burn\\n   * function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\\n   * NFT.\\n   * @param _tokenId ID of the NFT to be burned.\\n   */\\n  function _burn(\\n    uint256 _tokenId\\n  )\\n    internal\\n//    virtual\\n    validNFToken(_tokenId)\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    _clearApproval(_tokenId);\\n    _removeNFToken(tokenOwner, _tokenId);\\n    emit Transfer(tokenOwner, address(0), _tokenId);\\n  }\\n\\n  /**\\n   * @dev Removes a NFT from owner.\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @param _from Address from wich we want to remove the NFT.\\n   * @param _tokenId Which NFT we want to remove.\\n   */\\n  function _removeNFToken(\\n    address _from,\\n    uint256 _tokenId\\n  )\\n    internal\\n//    virtual\\n  {\\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\\n    ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\\n    delete idToOwner[_tokenId];\\n  }\\n\\n  /**\\n   * @dev Assignes a new NFT to owner.\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @param _to Address to wich we want to add the NFT.\\n   * @param _tokenId Which NFT we want to add.\\n   */\\n  function _addNFToken(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n//    virtual\\n  {\\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\\n\\n    idToOwner[_tokenId] = _to;\\n    ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to] + 1;\\n  }\\n\\n  /**\\n   *\u00a0@dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\\n   * extension to remove double storage (gas optimization) of owner nft count.\\n   * @param _owner Address for whom to query the count.\\n   * @return Number of _owner NFTs.\\n   */\\n  function _getOwnerNFTCount(\\n    address _owner\\n  )\\n    internal\\n//    virtual\\n    view\\n    returns (uint256)\\n  {\\n    return ownerToNFTokenCount[_owner];\\n  }\\n\\n  /**\\n   * @dev Actually perform the safeTransferFrom.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   * @param _data Additional data with no specified format, sent in call to `_to`.\\n   */\\n  function _safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes memory _data\\n  )\\n    private\\n    canTransfer(_tokenId)\\n    validNFToken(_tokenId)\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    require(tokenOwner == _from, NOT_OWNER);\\n    require(_to != address(0), ZERO_ADDRESS);\\n\\n    _transfer(_to, _tokenId);\\n\\n    if (_to.isContract())\\n    {\\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\\n      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\\n    }\\n  }\\n\\n  /**\\n   * @dev Clears the current approval of a given NFT ID.\\n   * @param _tokenId ID of the NFT to be transferred.\\n   */\\n  function _clearApproval(\\n    uint256 _tokenId\\n  )\\n    private\\n  {\\n    if (idToApproval[_tokenId] != address(0))\\n    {\\n      delete idToApproval[_tokenId];\\n    }\\n  }\\n\\n}\\n\"},\"supports-interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.4.11;\\n\\nimport \\\"./erc165.sol\\\";\\n\\n/**\\n * @dev Implementation of standard for detect smart contract interfaces.\\n */\\ncontract SupportsInterface is\\n  ERC165\\n{\\n\\n  /**\\n   * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.\\n   */\\n  mapping(bytes4 =\\u003e bool) internal supportedInterfaces;\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor()\\n  {\\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\\n  }\\n\\n  /**\\n   * @dev Function to check which interfaces are suported by this contract.\\n   * @param _interfaceID Id of the interface.\\n   * @return True if _interfaceID is supported, false otherwise.\\n   */\\n  function supportsInterface(\\n    bytes4 _interfaceID\\n  )\\n    external\\n    //override\\n    view\\n    returns (bool)\\n  {\\n    return supportedInterfaces[_interfaceID];\\n  }\\n\\n}\\n\"}}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"pigeon\",\"type\":\"address\"}],\"name\":\"isTokenizedPigeon\",\"outputs\":[{\"name\":\"tokenized\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burnPigeonToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ERC20Token\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setMintingPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"highestTokenId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setFreeMintEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freeMintEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"factoryId\",\"type\":\"uint256\"}],\"name\":\"mintForEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setMintingPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ERC20Token\",\"type\":\"address\"},{\"name\":\"factoryId\",\"type\":\"uint256\"}],\"name\":\"mintForToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mintForFree\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenContractAddress\",\"outputs\":[{\"name\":\"rpigeon\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"metadata\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epigeon\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ERC20Token\",\"type\":\"address\"}],\"name\":\"mintingTokenPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pigeon\",\"type\":\"address\"}],\"name\":\"pigeonAddressToToken\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pigeon\",\"type\":\"address\"}],\"name\":\"tokenizePigeon\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_epigeon\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]", "ContractName": "EpigeonNFT", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000ab23af9a571c03e4b23ed919c23f570e95e7fc5000000000000000000000000000000000000000000000000000000000000000745706967656f6e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034550470000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://3fd2d1fde77741ce875b50abfdcc9f618f5254c7d03ad47b58480abc102dd6ee"}]}