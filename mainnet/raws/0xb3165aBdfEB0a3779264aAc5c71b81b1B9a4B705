{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\",\r\n          \"stackAllocation\": true\r\n        }\r\n      },\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PirateGames.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\r\\nimport \\\"./interfaces/IPirateGames.sol\\\";\\r\\nimport \\\"./interfaces/IPytheas.sol\\\";\\r\\nimport \\\"./interfaces/IOrbitalBlockade.sol\\\";\\r\\nimport \\\"./interfaces/ITPirates.sol\\\";\\r\\nimport \\\"./interfaces/IRAW.sol\\\";\\r\\nimport \\\"./interfaces/IEON.sol\\\";\\r\\nimport \\\"./interfaces/IPirates.sol\\\";\\r\\nimport \\\"./interfaces/IColonist.sol\\\";\\r\\nimport \\\"./interfaces/IImperialGuild.sol\\\";\\r\\nimport \\\"./interfaces/IRandomizer.sol\\\";\\r\\n\\r\\ncontract PirateGames is IPirateGames, Pausable {\\r\\n    uint8[][6] public rarities;\\r\\n    uint8[][6] public aliases;\\r\\n\\r\\n    uint256 public OnosiaLiquorId;\\r\\n\\r\\n    uint256 private maxRawEonCost;\\r\\n\\r\\n    uint256 public eonMintCost;\\r\\n\\r\\n    uint256 public imperialFee;\\r\\n\\r\\n    // address => can call\\r\\n    mapping(address => bool) private admins;\\r\\n\\r\\n    bool public eonMintsEnabled;\\r\\n\\r\\n    address public auth;\\r\\n\\r\\n    // reference to Pytheas for checking that a colonist has mined enough\\r\\n    //rEON to make an attempt as well as pay from this amount, either the  current mint cost on\\r\\n    //a successful pirate mint, or pirate tax on a failed attempt.\\r\\n    IPytheas public pytheas;\\r\\n    //reference to the OrbitalBlockade, where pirates are staked out, awaiting weak colonist miners.\\r\\n    IOrbitalBlockade public orbital;\\r\\n    // reference to raw Eon for attempts\\r\\n    IRAW public raw;\\r\\n    // reference to refined EON for if EonOnlyMints are enabled (all raw eon mined)\\r\\n    IEON public eon;\\r\\n    // reference to pirate collection\\r\\n    IPirates public pirateNFT;\\r\\n    // reference to the colonist NFT collection\\r\\n    IColonist public colonistNFT;\\r\\n    // reference to the galactic imperialGuild collection\\r\\n    IImperialGuild public imperialGuild;\\r\\n    //randy the randomizer\\r\\n    IRandomizer private randomizer;\\r\\n\\r\\n    //ratio chance\\r\\n\\r\\n    constructor() {\\r\\n        auth = msg.sender;\\r\\n        admins[msg.sender] = true;\\r\\n\\r\\n        //RatioChance 90\\r\\n        rarities[0] = [230, 27];\\r\\n        aliases[0] = [1, 0];\\r\\n        //RatioChance 80\\r\\n        rarities[1] = [204, 51];\\r\\n        aliases[1] = [1, 0];\\r\\n        //RatioChance 60\\r\\n        rarities[2] = [175, 90];\\r\\n        aliases[2] = [1, 0];\\r\\n        //RatioChance 40\\r\\n        rarities[3] = [132, 155];\\r\\n        aliases[3] = [1, 0];\\r\\n        //RatioChance 10\\r\\n        rarities[4] = [60, 200];\\r\\n        aliases[4] = [1, 0];\\r\\n        //RatioChance 0\\r\\n        rarities[5] = [255];\\r\\n        aliases[5] = [0];\\r\\n    }\\r\\n\\r\\n    modifier noCheaters() {\\r\\n        uint256 size = 0;\\r\\n        address acc = msg.sender;\\r\\n        assembly {\\r\\n            size := extcodesize(acc)\\r\\n        }\\r\\n\\r\\n        require(\\r\\n            admins[msg.sender] || (msg.sender == tx.origin && size == 0),\\r\\n            \\\"you're trying to cheat!\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == auth);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /** CRITICAL TO SETUP */\\r\\n    modifier requireContractsSet() {\\r\\n        require(\\r\\n            address(raw) != address(0) &&\\r\\n                address(eon) != address(0) &&\\r\\n                address(pirateNFT) != address(0) &&\\r\\n                address(colonistNFT) != address(0) &&\\r\\n                address(pytheas) != address(0) &&\\r\\n                address(orbital) != address(0) &&\\r\\n                address(imperialGuild) != address(0) &&\\r\\n                address(randomizer) != address(0),\\r\\n            \\\"Contracts not set\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setContracts(\\r\\n        address _rEON,\\r\\n        address _eon,\\r\\n        address _pirateNFT,\\r\\n        address _colonistNFT,\\r\\n        address _pytheas,\\r\\n        address _orbital,\\r\\n        address _imperialGuild,\\r\\n        address _randomizer\\r\\n    ) external onlyOwner {\\r\\n        raw = IRAW(_rEON);\\r\\n        eon = IEON(_eon);\\r\\n        pirateNFT = IPirates(_pirateNFT);\\r\\n        colonistNFT = IColonist(_colonistNFT);\\r\\n        pytheas = IPytheas(_pytheas);\\r\\n        orbital = IOrbitalBlockade(_orbital);\\r\\n        imperialGuild = IImperialGuild(_imperialGuild);\\r\\n        randomizer = IRandomizer(_randomizer);\\r\\n    }\\r\\n\\r\\n    function pirateAttempt(uint16 tokenId, bool stake) external noCheaters {\\r\\n        require(eonMintsEnabled == false, \\\"Eon Mints Only\\\");\\r\\n        uint16 piratesMinted = pirateNFT.piratesMinted();\\r\\n        uint256 totalCir = colonistNFT.totalCir();\\r\\n        uint256 minted = colonistNFT.minted();\\r\\n        uint256 seed = random(minted);\\r\\n        uint256 maxTokens = colonistNFT.getMaxTokens();\\r\\n        uint256 rawCost = rawMintCost(minted, maxTokens);\\r\\n        require(minted >= 10000, \\\"Pirates available starting Colonist Gen 1\\\");\\r\\n        uint256 mined = pytheas.getColonistMined(msg.sender, tokenId);\\r\\n        require(\\r\\n            mined >= rawCost,\\r\\n            \\\"You have not mined enough to attempt this action\\\"\\r\\n        );\\r\\n        uint8 chanceTable = getRatioChance(piratesMinted, totalCir);\\r\\n        uint8 yayNay = getPirateResults(seed, chanceTable);\\r\\n        // if the attempt fails, pay pirate tax and claim remaining\\r\\n        if (yayNay == 0) {\\r\\n            pytheas.payUp(tokenId, mined, msg.sender);\\r\\n        } else {\\r\\n            pytheas.handleJoinPirates(msg.sender, tokenId);\\r\\n            uint256 outStanding = mined - rawCost;\\r\\n            raw.updateMintBurns(1, mined, rawCost);\\r\\n            raw.mint(1, outStanding, msg.sender);\\r\\n            uint16[] memory pirateId = new uint16[](1);\\r\\n            for (uint256 i = 0; i < 1; i++) {\\r\\n                piratesMinted++;\\r\\n                address recipient = selectRecipient(seed);\\r\\n                if (\\r\\n                    recipient != msg.sender &&\\r\\n                    imperialGuild.getBalance(msg.sender, OnosiaLiquorId) > 0\\r\\n                ) {\\r\\n                    // If the mint is going to be stolen, there's a 50% chance\\r\\n                    //  a pirate will prefer a fine crafted EON liquor over it\\r\\n                    if (seed & 1 == 1) {\\r\\n                        imperialGuild.safeTransferFrom(\\r\\n                            msg.sender,\\r\\n                            recipient,\\r\\n                            OnosiaLiquorId,\\r\\n                            1,\\r\\n                            \\\"\\\"\\r\\n                        );\\r\\n                        recipient = msg.sender;\\r\\n                    }\\r\\n                }\\r\\n                pirateId[i] = piratesMinted;\\r\\n                if (!stake || recipient != msg.sender) {\\r\\n                    pirateNFT._mintPirate(recipient, seed);\\r\\n                } else {\\r\\n                    pirateNFT._mintPirate(address(orbital), seed);\\r\\n                    pirateId[i] = piratesMinted;\\r\\n                }\\r\\n            }\\r\\n            if (stake) {\\r\\n                orbital.addPiratesToCrew(msg.sender, pirateId);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function pirateAttemptEon(uint256 tokenId, bool stake) external noCheaters {\\r\\n        require(eonMintsEnabled == true, \\\"Raw Eon attempts only\\\");\\r\\n        uint16 piratesMinted = pirateNFT.piratesMinted();\\r\\n        uint256 totalCir = colonistNFT.totalCir();\\r\\n        uint256 seed = random(totalCir);\\r\\n        uint8 chanceTable = getRatioChance(piratesMinted, totalCir);\\r\\n        uint8 yayNay = getPirateResults(seed, chanceTable);\\r\\n        // if the attempt fails, pay imperial bailout fee and return remianing\\r\\n        if (yayNay == 0) {\\r\\n            imperialGuild.handlePayment(imperialFee);\\r\\n        } else {\\r\\n            colonistNFT.burn(tokenId);\\r\\n            imperialGuild.handlePayment(eonMintCost);\\r\\n            uint16[] memory pirateId = new uint16[](1);\\r\\n            for (uint256 i = 0; i < 1; i++) {\\r\\n                piratesMinted++;\\r\\n                address recipient = selectRecipient(seed);\\r\\n                if (\\r\\n                    recipient != msg.sender &&\\r\\n                    imperialGuild.getBalance(msg.sender, OnosiaLiquorId) > 0\\r\\n                ) {\\r\\n                    if (seed & 1 == 1) {\\r\\n                        imperialGuild.safeTransferFrom(\\r\\n                            msg.sender,\\r\\n                            recipient,\\r\\n                            OnosiaLiquorId,\\r\\n                            1,\\r\\n                            \\\"\\\"\\r\\n                        );\\r\\n                        recipient = msg.sender;\\r\\n                    }\\r\\n                }\\r\\n                pirateId[i] = piratesMinted;\\r\\n                if (!stake || recipient != msg.sender) {\\r\\n                    pirateNFT._mintPirate(recipient, seed);\\r\\n                } else {\\r\\n                    pirateNFT._mintPirate(address(orbital), seed);\\r\\n                    pirateId[i] = piratesMinted;\\r\\n                }\\r\\n            }\\r\\n            if (stake) {\\r\\n                orbital.addPiratesToCrew(msg.sender, pirateId);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param tokenId the ID to check the cost of to mint\\r\\n     * @return the cost of the given token ID\\r\\n     */\\r\\n    function rawMintCost(uint256 tokenId, uint256 maxTokens)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        if (tokenId <= (maxTokens * 8) / 24) return 4000; //10k-20k\\r\\n        if (tokenId <= (maxTokens * 12) / 24) return 16000; //20k-30k\\r\\n        if (tokenId <= (maxTokens * 16) / 24) return 48000; //30k-40k\\r\\n        if (tokenId <= (maxTokens * 20) / 24) return 122500; //40k-50k\\r\\n        if (tokenId <= (maxTokens * 22) / 24) return 250000; //50k-55k\\r\\n        return maxRawEonCost;\\r\\n    }\\r\\n\\r\\n    function getRatioChance(uint256 pirates, uint256 circulation)\\r\\n        public\\r\\n        pure\\r\\n        returns (uint8)\\r\\n    {\\r\\n        uint256 ratio = (pirates * 10000) / circulation;\\r\\n\\r\\n        if (ratio <= 100) {\\r\\n            return 0;\\r\\n        } else if (ratio <= 300 && ratio >= 100) {\\r\\n            return 1;\\r\\n        } else if (ratio <= 500 && ratio >= 300) {\\r\\n            return 2;\\r\\n        } else if (ratio <= 800 && ratio >= 500) {\\r\\n            return 3;\\r\\n        } else if (ratio <= 999 && ratio >= 800) {\\r\\n            return 4;\\r\\n        } else {\\r\\n            return 5;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n  Determines if an attempt to join the pirates is successful or not \\r\\n  granting a higher chance of success when the pirate to colonist ratio is\\r\\n  low, as the ratio gets closer to 10% the harder a chance at joining the pirates\\r\\n  becomes until ultimately they will not accept anyone else if the ratio is += 10%\\r\\n */\\r\\n\\r\\n    function getPirateResults(uint256 seed, uint8 chanceTable)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint8)\\r\\n    {\\r\\n        seed >>= 16;\\r\\n        uint8 yayNay = getResult(uint16(seed & 0xFFFF), chanceTable);\\r\\n        return yayNay;\\r\\n    }\\r\\n\\r\\n    function getResult(uint256 seed, uint8 chanceTable)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint8)\\r\\n    {\\r\\n        uint8 result = uint8(seed) % uint8(rarities[chanceTable].length);\\r\\n        // If the selected chance talbles rareity is selected (biased coin) return that\\r\\n        if (seed >> 8 < rarities[chanceTable][result]) return result;\\r\\n        // else return the aliases\\r\\n        return aliases[chanceTable][result];\\r\\n    }\\r\\n\\r\\n    /** INTERNAL */\\r\\n\\r\\n    /**\\r\\n     * the first 10k colonist mints go to the minter\\r\\n     * the remaining 80% have a 10% chance to be given to a random staked pirate\\r\\n     * @param seed a random value to select a recipient from\\r\\n     * @return the address of the recipient (either the minter or the pirate thief's owner)\\r\\n     */\\r\\n    function selectRecipient(uint256 seed) internal view returns (address) {\\r\\n        if (((seed >> 245) % 10) != 0) return msg.sender; // top 10 bits\\r\\n        address thief = orbital.randomPirateOwner(seed >> 144); // 144 bits reserved for trait selection\\r\\n        if (thief == address(0x0)) return msg.sender;\\r\\n        return thief;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * enables owner to pause / unpause contract\\r\\n     */\\r\\n    function setPaused(bool _paused) external requireContractsSet onlyOwner {\\r\\n        if (_paused) _pause();\\r\\n        else _unpause();\\r\\n    }\\r\\n\\r\\n    function activateEonMints(bool _eonMintsEnabled) external onlyOwner {\\r\\n        eonMintsEnabled = _eonMintsEnabled;\\r\\n    }\\r\\n\\r\\n    function setEonMintCost(uint256 _eonMintCost, uint256 _imperialFee)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        eonMintCost = _eonMintCost;\\r\\n        imperialFee = _imperialFee;\\r\\n    }\\r\\n\\r\\n    function setOnosiaLiquorId(uint256 typeId) external onlyOwner {\\r\\n        OnosiaLiquorId = typeId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * enables an address to mint / burn\\r\\n     * @param addr the address to enable\\r\\n     */\\r\\n    function addAdmin(address addr) external onlyOwner {\\r\\n        admins[addr] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * disables an address from minting / burning\\r\\n     * @param addr the address to disable\\r\\n     */\\r\\n    function removeAdmin(address addr) external onlyOwner {\\r\\n        admins[addr] = false;\\r\\n    }\\r\\n\\r\\n    function random(uint256 seed) internal view returns (uint256) {\\r\\n        return\\r\\n            uint256(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        tx.origin,\\r\\n                        blockhash(block.number - 1),\\r\\n                        block.timestamp,\\r\\n                        seed\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IColonist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IColonist {\\r\\n    // struct to store each Colonist's traits\\r\\n    struct Colonist {\\r\\n        bool isColonist;\\r\\n        uint8 background;\\r\\n        uint8 body;\\r\\n        uint8 shirt;\\r\\n        uint8 jacket;\\r\\n        uint8 jaw;\\r\\n        uint8 eyes;\\r\\n        uint8 hair;\\r\\n        uint8 held;\\r\\n        uint8 gen;\\r\\n    }\\r\\n\\r\\n    struct HColonist {\\r\\n        uint8 Legendary;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function isOwner(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function minted() external returns (uint16);\\r\\n\\r\\n    function totalCir() external returns (uint256);\\r\\n\\r\\n    function _mintColonist(address recipient, uint256 seed) external;\\r\\n\\r\\n    function _mintToHonors(address recipient, uint256 seed) external;\\r\\n\\r\\n    function _mintHonors(address recipient, uint8 id) external;\\r\\n\\r\\n    function burn(uint256 tokenId) external;\\r\\n\\r\\n    function getMaxTokens() external view returns (uint256);\\r\\n\\r\\n    function getPaidTokens() external view returns (uint256);\\r\\n\\r\\n    function getTokenTraitsColonist(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (Colonist memory);\\r\\n\\r\\n    function getTokenTraitsHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (HColonist memory);\\r\\n\\r\\n    function tokenNameByIndex(uint256 index)\\r\\n        external\\r\\n        view\\r\\n        returns (string memory);\\r\\n\\r\\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\\r\\n\\r\\n    function nameColonist(uint256 tokenId, string memory newName) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IEON.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IEON {\\r\\n    function mint(address to, uint256 amount) external;\\r\\n\\r\\n    function burn(address from, uint256 amount) external;\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IImperialGuild.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IImperialGuild {\\r\\n\\r\\n    function getBalance(\\r\\n        address account,\\r\\n        uint256 id\\r\\n    ) external returns(uint256);\\r\\n\\r\\n    function mint(\\r\\n        uint256 typeId,\\r\\n        uint256 paymentId,\\r\\n        uint16 qty,\\r\\n        address recipient\\r\\n    ) external;\\r\\n\\r\\n    function burn(\\r\\n        uint256 typeId,\\r\\n        uint16 qty,\\r\\n        address burnFrom\\r\\n    ) external;\\r\\n\\r\\n    function handlePayment(uint256 amount) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IOrbitalBlockade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.0;\\n\\ninterface IOrbitalBlockade {\\n    function addPiratesToCrew(address account, uint16[] calldata tokenIds)\\n        external;\\n    \\n    function claimPiratesFromCrew(address account, uint16[] calldata tokenIds, bool unstake)\\n        external;\\n\\n    function payPirateTax(uint256 amount) external;\\n\\n    function randomPirateOwner(uint256 seed) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPirateGames.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPirateGames {}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPirates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPirates {\\r\\n    // struct to store each Colonist's traits\\r\\n    struct Pirate {\\r\\n        bool isPirate;\\r\\n        uint8 sky;\\r\\n        uint8 cockpit;\\r\\n        uint8 base;\\r\\n        uint8 engine;\\r\\n        uint8 nose;\\r\\n        uint8 wing;\\r\\n        uint8 weapon1;\\r\\n        uint8 weapon2;\\r\\n        uint8 rank;\\r\\n    }\\r\\n\\r\\n    struct HPirates {\\r\\n        uint8 Legendary;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) external;\\r\\n\\r\\n    function minted() external returns (uint16);\\r\\n\\r\\n    function piratesMinted() external returns (uint16);\\r\\n\\r\\n    function isOwner(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function _mintPirate(address recipient, uint256 seed) external;\\r\\n\\r\\n    function burn(uint256 tokenId) external;\\r\\n\\r\\n    function getTokenTraitsPirate(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (Pirate memory);\\r\\n\\r\\n    function getTokenTraitsHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (HPirates memory);\\r\\n\\r\\n    function tokenNameByIndex(uint256 index)\\r\\n        external\\r\\n        view\\r\\n        returns (string memory);\\r\\n    \\r\\n    function isHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\\r\\n\\r\\n    function namePirate(uint256 tokenId, string memory newName) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPytheas.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPytheas {\\r\\n    function addColonistToPytheas(address account, uint16[] calldata tokenIds)\\r\\n        external;\\r\\n\\r\\n    function claimColonistFromPytheas(address account, uint16[] calldata tokenIds, bool unstake)\\r\\n        external;\\r\\n\\r\\n    function getColonistMined(address account, uint16 tokenId)\\r\\n        external\\r\\n        returns (uint256);\\r\\n\\r\\n    function handleJoinPirates(address addr, uint16 tokenId) external;\\r\\n\\r\\n    function payUp(\\r\\n        uint16 tokenId,\\r\\n        uint256 amtMined,\\r\\n        address addr\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IRAW.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IRAW {\\r\\n\\r\\n    function getBalance(\\r\\n        address account,\\r\\n        uint256 id\\r\\n    ) external returns(uint256);\\r\\n\\r\\n    function mint(\\r\\n        uint256 typeId,\\r\\n        uint256 qty,\\r\\n        address recipient\\r\\n    ) external;\\r\\n\\r\\n    function burn(\\r\\n        uint256 typeId,\\r\\n        uint256 qty,\\r\\n        address burnFrom\\r\\n    ) external;\\r\\n\\r\\n    function updateMintBurns(\\r\\n        uint256 typeId,\\r\\n        uint256 mintQty,\\r\\n        uint256 burnQty\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IRandomizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IRandomizer {\\r\\n    function random(uint256) external returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ITPirates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ITPirates {\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"OnosiaLiquorId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_eonMintsEnabled\",\"type\":\"bool\"}],\"name\":\"activateEonMints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"aliases\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"colonistNFT\",\"outputs\":[{\"internalType\":\"contract IColonist\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eon\",\"outputs\":[{\"internalType\":\"contract IEON\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eonMintCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eonMintsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pirates\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"circulation\",\"type\":\"uint256\"}],\"name\":\"getRatioChance\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"imperialFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"imperialGuild\",\"outputs\":[{\"internalType\":\"contract IImperialGuild\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orbital\",\"outputs\":[{\"internalType\":\"contract IOrbitalBlockade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"pirateAttempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"pirateAttemptEon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pirateNFT\",\"outputs\":[{\"internalType\":\"contract IPirates\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pytheas\",\"outputs\":[{\"internalType\":\"contract IPytheas\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rarities\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raw\",\"outputs\":[{\"internalType\":\"contract IRAW\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokens\",\"type\":\"uint256\"}],\"name\":\"rawMintCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rEON\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_eon\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pirateNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_colonistNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pytheas\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_orbital\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_imperialGuild\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_randomizer\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_eonMintCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_imperialFee\",\"type\":\"uint256\"}],\"name\":\"setEonMintCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeId\",\"type\":\"uint256\"}],\"name\":\"setOnosiaLiquorId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PirateGames", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}