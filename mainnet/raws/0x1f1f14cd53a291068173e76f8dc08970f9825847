{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"LlamaPayFactory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: None\\npragma solidity ^0.8.0;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"LlamaPay.sol\\\";\\n\\ncontract LlamaPayFactory is Ownable {\\n    mapping(address => address) public payContracts;\\n    mapping(uint => address) public payContractsArray;\\n    uint public payContractsArrayLength;\\n\\n    event LlamaPayCreated(address token, address llamaPay);\\n\\n    address public token;\\n    function createPayContract(address _token) external returns (address newContract) {\\n        require(payContracts[_token] == address(0), \\\"already exists\\\");\\n        token = _token;\\n        newContract = address(new LlamaPay());\\n        delete token;\\n        payContracts[_token] = newContract;\\n        payContractsArray[payContractsArrayLength] = newContract;\\n        unchecked{\\n            payContractsArrayLength++;\\n        }\\n        emit LlamaPayCreated(_token, address(newContract));\\n    }\\n}\\n\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"LlamaPay.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: None\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\n\\ninterface Factory {\\n    function owner() external returns (address);\\n    function token() external returns (address);\\n}\\n\\ninterface IERC20WithDecimals {\\n    function decimals() external view returns (uint8);\\n}\\n\\n// All amountPerSec and all internal numbers use 20 decimals, these are converted to the right decimal on withdrawal/deposit\\n// The reason for that is to minimize precision errors caused by integer math on tokens with low decimals (eg: USDC)\\n\\n// Invariant through the whole contract: lastPayerUpdate[anyone] <= block.timestamp\\n// Reason: timestamps can't go back in time (https://github.com/ethereum/go-ethereum/blob/master/consensus/ethash/consensus.go#L274)\\n// and we always set lastPayerUpdate[anyone] either to the current block.timestamp or a value lower than it\\n\\ncontract LlamaPay {\\n    struct Payer {\\n        uint40 lastPayerUpdate; // we will only hit overflow in year 231,800 so no need to worry\\n        uint216 totalPaidPerSec; // uint216 is enough to hold 1M streams of 3e51 tokens/yr, which is enough\\n    }\\n\\n    mapping (bytes32 => uint) public streamToStart;\\n    mapping (address => Payer) public payers;\\n    mapping (address => uint) public balances; // could be packed together with lastPayerUpdate but gains are not high\\n    IERC20 immutable public token;\\n    address immutable public factory;\\n    uint immutable public DECIMALS_DIVISOR;\\n\\n    event StreamCreated(address indexed from, address indexed to, uint216 amountPerSec, bytes32 streamId);\\n    event StreamCancelled(address indexed from, address indexed to, uint216 amountPerSec, bytes32 streamId);\\n\\n    constructor(){\\n        address _token = Factory(msg.sender).token();\\n        token = IERC20(_token);\\n        factory = msg.sender;\\n        uint8 tokenDecimals = IERC20WithDecimals(_token).decimals();\\n        DECIMALS_DIVISOR = 10**(20 - tokenDecimals);\\n    }\\n\\n    function getStreamId(address from, address to, uint216 amountPerSec) public pure returns (bytes32){\\n        return keccak256(abi.encodePacked(from, to, amountPerSec));\\n    }\\n\\n    function createStream(address to, uint216 amountPerSec) public {\\n        bytes32 streamId = getStreamId(msg.sender, to, amountPerSec);\\n        require(amountPerSec > 0, \\\"amountPerSec can't be 0\\\");\\n        require(streamToStart[streamId] == 0, \\\"stream already exists\\\");\\n        streamToStart[streamId] = block.timestamp;\\n\\n        Payer storage payer = payers[msg.sender];\\n        uint totalPaid;\\n        unchecked {\\n            uint delta = block.timestamp - payer.lastPayerUpdate;\\n            totalPaid = delta * uint(payer.totalPaidPerSec);\\n        }\\n        balances[msg.sender] -= totalPaid; // implicit check that balance >= totalPaid, can't create a new stream unless there's no debt\\n\\n        payer.lastPayerUpdate = uint40(block.timestamp);\\n        payer.totalPaidPerSec += amountPerSec;\\n\\n        // checking that no overflow will ever happen on totalPaidPerSec is important because if there's an overflow later:\\n        //   - if we don't have overflow checks -> it would be possible to steal money from other people\\n        //   - if there are overflow checks -> money will be stuck forever as all txs (from payees of the same payer) will revert\\n        //     which can be used to rug employees and make them unable to withdraw their earnings\\n        // Thus it's extremely important that no user is allowed to enter any value that later on could trigger an overflow.\\n        // We implicitly prevent this here because amountPerSec/totalPaidPerSec is uint216 and is only ever multiplied by timestamps\\n        // which will always fit in a uint40. Thus the result of the multiplication will always fit inside a uint256 and never overflow\\n        // This however introduces a new invariant: the only operations that can be done with amountPerSec/totalPaidPerSec are muls against timestamps\\n        // and we need to make sure they happen in uint256 contexts, not any other\\n        emit StreamCreated(msg.sender, to, amountPerSec, streamId);\\n    }\\n\\n    /*\\n        proof that lastUpdate < block.timestamp:\\n\\n        let's start by assuming the opposite, that lastUpdate > block.timestamp, and then we'll prove that this is impossible\\n        lastUpdate > block.timestamp\\n            -> timePaid = lastUpdate - lastPayerUpdate[from] > block.timestamp - lastPayerUpdate[from] = payerDelta\\n            -> timePaid > payerDelta\\n            -> payerBalance = timePaid * totalPaidPerSec[from] > payerDelta * totalPaidPerSec[from] = totalPayerPayment\\n            -> payerBalance > totalPayerPayment\\n        but this last statement is impossible because if it were true we'd have gone into the first if branch!\\n    */\\n    /*\\n        proof that totalPaidPerSec[from] != 0:\\n\\n        totalPaidPerSec[from] is a sum of uint that are different from zero (since we test that on createStream())\\n        and we test that there's at least one stream active with `streamToStart[streamId] != 0`,\\n        so it's a sum of one or more elements that are higher than zero, thus it can never be zero\\n    */\\n\\n    // Make it possible to withdraw on behalf of others, important for people that don't have a metamask wallet (eg: cex address, trustwallet...)\\n    function _withdraw(address from, address to, uint216 amountPerSec) private returns (uint40 lastUpdate, bytes32 streamId, uint amountToTransfer) {\\n        streamId = getStreamId(from, to, amountPerSec);\\n        require(streamToStart[streamId] != 0, \\\"stream doesn't exist\\\");\\n\\n        Payer storage payer = payers[from];\\n        uint totalPayerPayment;\\n        unchecked{\\n            uint payerDelta = block.timestamp - payer.lastPayerUpdate;\\n            totalPayerPayment = payerDelta * uint(payer.totalPaidPerSec);\\n        }\\n        uint payerBalance = balances[from];\\n        if(payerBalance >= totalPayerPayment){\\n            unchecked {\\n                balances[from] = payerBalance - totalPayerPayment;   \\n            }\\n            lastUpdate = uint40(block.timestamp);\\n        } else {\\n            // invariant: totalPaidPerSec[from] != 0\\n            unchecked {\\n                uint timePaid = payerBalance/uint(payer.totalPaidPerSec);\\n                lastUpdate = uint40(payer.lastPayerUpdate + timePaid);\\n                // invariant: lastUpdate < block.timestamp (we need to maintain it)\\n                balances[from] = payerBalance % uint(payer.totalPaidPerSec);\\n            }\\n        }\\n        uint delta = lastUpdate - streamToStart[streamId]; // Could use unchecked here too I think\\n        unchecked {\\n            // We push transfers to be done outside this function and at the end of public functions to avoid reentrancy exploits\\n            amountToTransfer = (delta*uint(amountPerSec))/DECIMALS_DIVISOR;\\n        }\\n    }\\n\\n    // Copy of _withdraw that is view-only and returns how much can be withdrawn from a stream, purely for convenience on frontend\\n    // No need to review since this does nothing\\n    function withdrawable(address from, address to, uint216 amountPerSec) external view returns (uint withdrawableAmount, uint lastUpdate, uint owed) {\\n        bytes32 streamId = getStreamId(from, to, amountPerSec);\\n        require(streamToStart[streamId] != 0, \\\"stream doesn't exist\\\");\\n\\n        Payer storage payer = payers[from];\\n        uint totalPayerPayment;\\n        unchecked{\\n            uint payerDelta = block.timestamp - payer.lastPayerUpdate;\\n            totalPayerPayment = payerDelta * uint(payer.totalPaidPerSec);\\n        }\\n        uint payerBalance = balances[from];\\n        if(payerBalance >= totalPayerPayment){\\n            lastUpdate = block.timestamp;\\n        } else {\\n            unchecked {\\n                uint timePaid = payerBalance/uint(payer.totalPaidPerSec);\\n                lastUpdate = payer.lastPayerUpdate + timePaid;\\n            }\\n        }\\n        uint delta = lastUpdate - streamToStart[streamId];\\n        withdrawableAmount = (delta*uint(amountPerSec))/DECIMALS_DIVISOR;\\n        owed = ((block.timestamp - lastUpdate)*uint(amountPerSec))/DECIMALS_DIVISOR;\\n    }\\n\\n    function withdraw(address from, address to, uint216 amountPerSec) external {\\n        (uint40 lastUpdate, bytes32 streamId, uint amountToTransfer) = _withdraw(from, to, amountPerSec);\\n        streamToStart[streamId] = lastUpdate;\\n        payers[from].lastPayerUpdate = lastUpdate;\\n        token.transfer(to, amountToTransfer);\\n    }\\n\\n    function cancelStream(address to, uint216 amountPerSec) public {\\n        (uint40 lastUpdate, bytes32 streamId, uint amountToTransfer) = _withdraw(msg.sender, to, amountPerSec);\\n        streamToStart[streamId] = 0;\\n        Payer storage payer = payers[msg.sender];\\n        unchecked{\\n            // totalPaidPerSec is a sum of items which include amountPerSec, so totalPaidPerSec >= amountPerSec\\n            payer.totalPaidPerSec -= amountPerSec;\\n        }\\n        payer.lastPayerUpdate = lastUpdate;\\n        emit StreamCancelled(msg.sender, to, amountPerSec, streamId);\\n        token.transfer(to, amountToTransfer);\\n    }\\n\\n    function modifyStream(address oldTo, uint216 oldAmountPerSec, address to, uint216 amountPerSec) external {\\n        // Can be optimized but I don't think extra complexity is worth it\\n        cancelStream(oldTo, oldAmountPerSec);\\n        createStream(to, amountPerSec);\\n    }\\n\\n    function deposit(uint amount) public {\\n        balances[msg.sender] += amount * DECIMALS_DIVISOR;\\n        token.transferFrom(msg.sender, address(this), amount);\\n    }\\n\\n    function depositAndCreate(uint amountToDeposit, address to, uint216 amountPerSec) external {\\n        deposit(amountToDeposit);\\n        createStream(to, amountPerSec);\\n    }\\n\\n    function withdrawPayer(uint amount) external {\\n        Payer storage payer = payers[msg.sender];\\n        balances[msg.sender] -= amount; // implicit check that balance > amount\\n        unchecked {\\n            uint delta = block.timestamp - payer.lastPayerUpdate;\\n            require(balances[msg.sender] >= delta*uint(payer.totalPaidPerSec), \\\"pls no rug\\\");\\n            token.transfer(msg.sender, amount/DECIMALS_DIVISOR);\\n        }\\n    }\\n\\n    function withdrawPayerAll() external {\\n        Payer storage payer = payers[msg.sender];\\n        uint totalPaid;\\n        unchecked {\\n            uint delta = block.timestamp - payer.lastPayerUpdate;\\n            totalPaid = delta*uint(payer.totalPaidPerSec);\\n        }\\n        balances[msg.sender] -= totalPaid;\\n        unchecked {\\n            token.transfer(msg.sender, balances[msg.sender]/DECIMALS_DIVISOR);\\n        }\\n    }\\n\\n    function getPayerBalance(address payerAddress) external view returns (int) {\\n        Payer storage payer = payers[payerAddress];\\n        int balance = int(balances[payerAddress]);\\n        uint delta = block.timestamp - payer.lastPayerUpdate;\\n        return (balance - int(delta*uint(payer.totalPaidPerSec)))/int(DECIMALS_DIVISOR);\\n    }\\n\\n    // Performs an arbitrary call\\n    // This will be under a heavy timelock and only used in case something goes very wrong (eg: with yield engine)\\n    function emergencyRug(address to, uint amount) external {\\n        require(Factory(factory).owner() == msg.sender, \\\"not owner\\\");\\n        if(amount == 0){\\n            amount = token.balanceOf(address(this));\\n        }\\n        token.transfer(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"LlamaPayFactory.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint216\",\"name\":\"amountPerSec\",\"type\":\"uint216\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"streamId\",\"type\":\"bytes32\"}],\"name\":\"StreamCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint216\",\"name\":\"amountPerSec\",\"type\":\"uint216\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"streamId\",\"type\":\"bytes32\"}],\"name\":\"StreamCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DECIMALS_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint216\",\"name\":\"amountPerSec\",\"type\":\"uint216\"}],\"name\":\"cancelStream\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint216\",\"name\":\"amountPerSec\",\"type\":\"uint216\"}],\"name\":\"createStream\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToDeposit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint216\",\"name\":\"amountPerSec\",\"type\":\"uint216\"}],\"name\":\"depositAndCreate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyRug\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"payerAddress\",\"type\":\"address\"}],\"name\":\"getPayerBalance\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint216\",\"name\":\"amountPerSec\",\"type\":\"uint216\"}],\"name\":\"getStreamId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldTo\",\"type\":\"address\"},{\"internalType\":\"uint216\",\"name\":\"oldAmountPerSec\",\"type\":\"uint216\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint216\",\"name\":\"amountPerSec\",\"type\":\"uint216\"}],\"name\":\"modifyStream\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"payers\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"lastPayerUpdate\",\"type\":\"uint40\"},{\"internalType\":\"uint216\",\"name\":\"totalPaidPerSec\",\"type\":\"uint216\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"streamToStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint216\",\"name\":\"amountPerSec\",\"type\":\"uint216\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawPayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawPayerAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint216\",\"name\":\"amountPerSec\",\"type\":\"uint216\"}],\"name\":\"withdrawable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawableAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LlamaPay", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3a5f3b4509ca4c37253c04bcb94e57e5826cc5d9c3aaf23cbee0bb2cc7fe68fc"}]}