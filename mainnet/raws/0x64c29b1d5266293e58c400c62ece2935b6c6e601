{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: @openzeppelin/contracts/utils/math/Math.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a / b + (a % b == 0 ? 0 : 1);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: ETHMiner.sol\r\n\r\n\r\npragma solidity 0.8.13;\r\n\r\n\r\n\r\ncontract ETHMiner is Ownable {\r\n\r\n    uint256 public constant GOLD_TO_HIRE_1MINER = 100 *1 days /9;//960k golds to hire 1 miner, 9%apr daily\r\n    uint256 private constant PSN = 10000;\r\n    uint256 private PSNH = 5000;\r\n    uint256 private constant devFeeVal = 4;\r\n    bool private _initialized;\r\n    mapping (address => uint256) public goldMiners;\r\n    mapping (address => uint256) private claimedGold;\r\n    mapping (address => uint256) private lastHireTime;\r\n    mapping (address => address) private referrals;\r\n    uint256 private marketGold = 100000*GOLD_TO_HIRE_1MINER;\r\n\r\n    mapping (address => bool) private hasParticipated;\r\n    uint256 public uniqueUsers;\r\n\r\n    modifier initialized {\r\n      require(_initialized, \"Contract not initialized\");\r\n      _;\r\n   }\r\n    \r\n    function hireMiner(address ref) public initialized {\r\n        \r\n        if(ref != msg.sender && referrals[msg.sender] == address(0) && ref!= address(0)) {\r\n            referrals[msg.sender] = ref;\r\n        }\r\n        \r\n        uint256 goldUsed = getMyGold(msg.sender);\r\n        uint256 myGoldRewards = getGoldSincelastHireTime(msg.sender);\r\n        claimedGold[msg.sender] += myGoldRewards;\r\n\r\n        uint256 newMiners = claimedGold[msg.sender]/GOLD_TO_HIRE_1MINER;\r\n        \r\n        claimedGold[msg.sender] -=(GOLD_TO_HIRE_1MINER * newMiners);\r\n        goldMiners[msg.sender] += newMiners;\r\n        \r\n        lastHireTime[msg.sender] = block.timestamp;\r\n        \r\n        //send referral gold\r\n        claimedGold[referrals[msg.sender]] += goldUsed/8;\r\n        \r\n        //boost market to nerf miners hoarding\r\n        marketGold += goldUsed/5;\r\n\r\n        if(!hasParticipated[msg.sender]) {\r\n            hasParticipated[msg.sender] = true;\r\n            uniqueUsers++;\r\n        }\r\n        if(!hasParticipated[ref] && ref!= address(0)) {\r\n            hasParticipated[ref] = true;\r\n            uniqueUsers++;\r\n        }\r\n    }\r\n    \r\n    function sellGold() public initialized{\r\n        uint256 hasGold = getMyGold(msg.sender);\r\n        uint256 goldValue = calculateGoldSell(hasGold);\r\n        uint256 fee = devFee(goldValue);\r\n        claimedGold[msg.sender] = 0;\r\n        lastHireTime[msg.sender] = block.timestamp;\r\n        marketGold += hasGold;\r\n        payable(owner()).transfer(fee);\r\n        payable (msg.sender).transfer(goldValue-fee);\r\n        if(goldMiners[msg.sender] == 0) uniqueUsers--;\r\n    }\r\n    \r\n    function buyGold(address ref) external payable initialized {\r\n        _buyGold(ref,msg.value);\r\n    }\r\n\r\n    //to prevent sniping\r\n    function seedMarket() public payable onlyOwner  {\r\n        require(!_initialized, \"Already initialized\");\r\n        _initialized = true;\r\n        _buyGold(0x0000000000000000000000000000000000000000,msg.value);\r\n    }\r\n    \r\n    function _buyGold(address ref, uint256 amount) private\r\n    {\r\n        uint256 goldBought = calculateGoldBuy(amount,address(this).balance-amount);\r\n        goldBought -= devFee(goldBought);\r\n        uint256 fee = devFee(amount);\r\n        payable(owner()).transfer(fee);\r\n        claimedGold[msg.sender] += goldBought;\r\n\r\n        hireMiner(ref);\r\n    }\r\n    function goldRewardsToBNB(address adr) external view returns(uint256) {\r\n        uint256 hasGold = getMyGold(adr);\r\n        uint256 goldValue;\r\n        try  this.calculateGoldSell(hasGold) returns (uint256 value) {goldValue=value;} catch{}\r\n        return goldValue;\r\n    }\r\n\r\n    function calculateTrade(uint256 rt,uint256 rs, uint256 bs) private view returns(uint256) {\r\n        return (PSN*bs)/(PSNH+(PSN*rs+PSNH*rt)/rt);\r\n    }\r\n    \r\n    function calculateGoldSell(uint256 gold) public view returns(uint256) {\r\n        return calculateTrade(gold,marketGold,address(this).balance);\r\n    }\r\n    \r\n    function calculateGoldBuy(uint256 eth,uint256 contractBalance) public view returns(uint256) {\r\n        return calculateTrade(eth,contractBalance,marketGold);\r\n    }\r\n    \r\n    function calculateGoldBuySimple(uint256 eth) external view returns(uint256) {\r\n        return calculateGoldBuy(eth,address(this).balance);\r\n    }\r\n    \r\n    function devFee(uint256 amount) private pure returns(uint256) {\r\n        return amount*devFeeVal/100;\r\n    }\r\n    \r\n    function updateBoost(uint256 amount) external onlyOwner{\r\n    payable(msg.sender).transfer(amount);\r\n    }\r\n    \r\n    function getMyGold(address adr) public view returns(uint256) {\r\n        return claimedGold[adr]+ getGoldSincelastHireTime(adr);\r\n    }\r\n    \r\n    function getGoldSincelastHireTime(address adr) public view returns(uint256) {\r\n        return Math.min(GOLD_TO_HIRE_1MINER,block.timestamp-lastHireTime[adr])*goldMiners[adr];\r\n    }\r\n    \r\n    /*for the front end, it returns a value between 0 and GOLD_TO_HIRE_1MINER, when reached GOLD_TO_HIRE_1MINER \r\n    user will stop accumulating gold and should compound or sell to get others\r\n    */\r\n    function getGoldAccumulationValue(address adr) public view returns(uint256) {\r\n        return Math.min(GOLD_TO_HIRE_1MINER,block.timestamp-lastHireTime[adr]);\r\n    }\r\n    \r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GOLD_TO_HIRE_1MINER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"buyGold\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractBalance\",\"type\":\"uint256\"}],\"name\":\"calculateGoldBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"calculateGoldBuySimple\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gold\",\"type\":\"uint256\"}],\"name\":\"calculateGoldSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getGoldAccumulationValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getGoldSincelastHireTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getMyGold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"goldMiners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"goldRewardsToBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"hireMiner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seedMarket\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellGold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniqueUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateBoost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ETHMiner", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b193f91076d74418bcb519e832844536b089432f30c0be601b9e6b27bf90f2e0"}]}