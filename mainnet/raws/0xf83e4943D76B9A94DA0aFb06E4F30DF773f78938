{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/misc/FRAX3CRVOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n// Using the same Copyleft License as in the original Repository\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport './interfaces/IOracle.sol';\\nimport '../interfaces/IChainlinkAggregator.sol';\\nimport '../interfaces/ICurvePool.sol';\\nimport {Math} from '../dependencies/openzeppelin/contracts/Math.sol';\\n\\n/**\\n * @dev Oracle contract for FRAX3CRV LP Token\\n */\\ncontract FRAX3CRVOracle is IOracle {\\n  ICurvePool private constant FRAX3CRV = ICurvePool(0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B);\\n  ICurvePool private constant CRV3 = ICurvePool(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);\\n\\n  IChainlinkAggregator private constant DAI =\\n    IChainlinkAggregator(0x773616E4d11A78F511299002da57A0a94577F1f4);\\n  IChainlinkAggregator private constant USDC =\\n    IChainlinkAggregator(0x986b5E1e1755e3C2440e960477f25201B0a8bbD4);\\n  IChainlinkAggregator private constant USDT =\\n    IChainlinkAggregator(0xEe9F2375b4bdF6387aa8265dD4FB8F16512A1d46);\\n  IChainlinkAggregator private constant FRAX =\\n    IChainlinkAggregator(0x14d04Fff8D21bd62987a5cE9ce543d2F1edF5D3E);\\n\\n  /**\\n   * @dev Get price for 3Pool LP Token\\n   */\\n  function _get3CRVPrice() internal view returns (uint256) {\\n    uint256 daiPrice = uint256(DAI.latestAnswer());\\n    uint256 usdcPrice = uint256(USDC.latestAnswer());\\n    uint256 usdtPrice = uint256(USDT.latestAnswer());\\n    uint256 minStable = Math.min(daiPrice, Math.min(usdcPrice, usdtPrice));\\n    return (CRV3.get_virtual_price() * minStable) / 1e18;\\n  }\\n\\n  /**\\n   * @dev Get LP Token Price\\n   */\\n  function _get() internal view returns (uint256) {\\n    uint256 lp3crvPrice = _get3CRVPrice();\\n    uint256 fraxPrice = uint256(FRAX.latestAnswer());\\n    uint256 minValue = Math.min(fraxPrice, lp3crvPrice);\\n\\n    return (FRAX3CRV.get_virtual_price() * minValue) / 1e18;\\n  }\\n\\n  // Get the latest exchange rate, if no valid (recent) rate is available, return false\\n  /// @inheritdoc IOracle\\n  function get() public view override returns (bool, uint256) {\\n    return (true, _get());\\n  }\\n\\n  // Check the last exchange rate without any state changes\\n  /// @inheritdoc IOracle\\n  function peek() public view override returns (bool, int256) {\\n    return (true, int256(_get()));\\n  }\\n\\n  // Check the current spot exchange rate without any state changes\\n  /// @inheritdoc IOracle\\n  function latestAnswer() external view override returns (int256 rate) {\\n    return int256(_get());\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/misc/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOracle {\\n  /// @notice Get the latest price.\\n  /// @return success if no valid (recent) rate is available, return false else true.\\n  /// @return rate The rate of the requested asset / pair / pool.\\n  function get() external returns (bool success, uint256 rate);\\n\\n  /// @notice Check the last price without any state changes.\\n  /// @return success if no valid (recent) rate is available, return false else true.\\n  /// @return rate The rate of the requested asset / pair / pool.\\n  function peek() external view returns (bool success, int256 rate);\\n\\n  /// @notice Check the current spot price without any state changes. For oracles like TWAP this will be different from peek().\\n  /// @return rate The rate of the requested asset / pair / pool.\\n  function latestAnswer() external view returns (int256 rate);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IChainlinkAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IChainlinkAggregator {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n  event NewRound(uint256 indexed roundId, address indexed startedBy);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICurvePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\ninterface ICurvePool {\\n  function get_virtual_price() external view returns (uint256 price);\\n\\n  function coins(uint256) external view returns (address);\\n\\n  function calc_withdraw_one_coin(\\n    uint256 _burn_amount,\\n    int128 i,\\n    bool _previous\\n  ) external view returns (uint256);\\n\\n  function calc_withdraw_one_coin(uint256 _burn_amount, int128 i) external view returns (uint256);\\n\\n  function remove_liquidity_one_coin(\\n    uint256 _burn_amount,\\n    int128 i,\\n    uint256 _min_received,\\n    address _receiver\\n  ) external returns (uint256);\\n\\n  function remove_liquidity_one_coin(\\n    uint256 _burn_amount,\\n    int128 i,\\n    uint256 _min_received\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Index values can be found via the `coins` public getter method\\n   * @param i Index value for the coin to send\\n   * @param j Index valie of the coin to recieve\\n   * @param dx Amount of `i` being exchanged\\n   * @param min_dy Minimum amount of `j` to receive\\n   * @return Actual amount of `j` received\\n   **/\\n  function exchange(\\n    int128 i,\\n    int128 j,\\n    uint256 dx,\\n    uint256 min_dy\\n  ) external payable returns (uint256);\\n\\n  function get_dy(\\n    int128 i,\\n    int128 j,\\n    uint256 dx\\n  ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n  /**\\n   * @dev Returns the largest of two numbers.\\n   */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a >= b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n   */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n   * zero.\\n   */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n   *\\n   * This differs from standard division with `/` in that it rounds up instead\\n   * of rounding down.\\n   */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b - 1) / b can overflow on addition, so we distribute.\\n    return a / b + (a % b == 0 ? 0 : 1);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"get\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"rate\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"peek\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FRAX3CRVOracle", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}