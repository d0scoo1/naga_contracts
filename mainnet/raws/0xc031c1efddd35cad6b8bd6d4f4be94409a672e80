{"status": "1", "message": "OK", "result": [{"SourceCode": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\ninterface IUniswapV2Pair {\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n  function name() external pure returns (string memory);\r\n  function symbol() external pure returns (string memory);\r\n  function decimals() external pure returns (uint8);\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address owner) external view returns (uint);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n  function nonces(address owner) external view returns (uint);\r\n\r\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n  event Mint(address indexed sender, uint amount0, uint amount1);\r\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n  event Swap(\r\n      address indexed sender,\r\n      uint amount0In,\r\n      uint amount1In,\r\n      uint amount0Out,\r\n      uint amount1Out,\r\n      address indexed to\r\n  );\r\n  event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n  function factory() external view returns (address);\r\n  function token0() external view returns (address);\r\n  function token1() external view returns (address);\r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n  function price0CumulativeLast() external view returns (uint);\r\n  function price1CumulativeLast() external view returns (uint);\r\n  function kLast() external view returns (uint);\r\n\r\n  function mint(address to) external returns (uint liquidity);\r\n  function burn(address to) external returns (uint amount0, uint amount1);\r\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n  function skim(address to) external;\r\n  function sync() external;\r\n}\r\ninterface IUniswapV2Router01 {\r\n  function factory() external pure returns (address);\r\n  function WETH() external pure returns (address);\r\n\r\n  function addLiquidity(\r\n      address tokenA,\r\n      address tokenB,\r\n      uint amountADesired,\r\n      uint amountBDesired,\r\n      uint amountAMin,\r\n      uint amountBMin,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint amountA, uint amountB, uint liquidity);\r\n  function addLiquidityETH(\r\n      address token,\r\n      uint amountTokenDesired,\r\n      uint amountTokenMin,\r\n      uint amountETHMin,\r\n      address to,\r\n      uint deadline\r\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n  function removeLiquidity(\r\n      address tokenA,\r\n      address tokenB,\r\n      uint liquidity,\r\n      uint amountAMin,\r\n      uint amountBMin,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint amountA, uint amountB);\r\n  function removeLiquidityETH(\r\n      address token,\r\n      uint liquidity,\r\n      uint amountTokenMin,\r\n      uint amountETHMin,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint amountToken, uint amountETH);\r\n  function removeLiquidityWithPermit(\r\n      address tokenA,\r\n      address tokenB,\r\n      uint liquidity,\r\n      uint amountAMin,\r\n      uint amountBMin,\r\n      address to,\r\n      uint deadline,\r\n      bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n  ) external returns (uint amountA, uint amountB);\r\n  function removeLiquidityETHWithPermit(\r\n      address token,\r\n      uint liquidity,\r\n      uint amountTokenMin,\r\n      uint amountETHMin,\r\n      address to,\r\n      uint deadline,\r\n      bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n  ) external returns (uint amountToken, uint amountETH);\r\n  function swapExactTokensForTokens(\r\n      uint amountIn,\r\n      uint amountOutMin,\r\n      address[] calldata path,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n  function swapTokensForExactTokens(\r\n      uint amountOut,\r\n      uint amountInMax,\r\n      address[] calldata path,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n      external\r\n      payable\r\n      returns (uint[] memory amounts);\r\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n      external\r\n      returns (uint[] memory amounts);\r\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n      external\r\n      returns (uint[] memory amounts);\r\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n      external\r\n      payable\r\n      returns (uint[] memory amounts);\r\n\r\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\ninterface IUniswapV2Factory {\r\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n  function allPairs(uint) external view returns (address pair);\r\n  function allPairsLength() external view returns (uint);\r\n\r\n  function feeTo() external view returns (address);\r\n  function feeToSetter() external view returns (address);\r\n\r\n  function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\ninterface ERC20 {\r\n    function decimals() external view returns(uint);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface ERC20RewardToken is ERC20 {\r\n    function mint_rewards(uint256 qty, address receiver) external;\r\n\r\n    function burn_tokens(uint256 qty, address burned) external;\r\n}\r\n\r\ncontract protected {\r\n    mapping(address => bool) is_auth;\r\n\r\n    function is_it_auth(address addy) public view returns (bool) {\r\n        return is_auth[addy];\r\n    }\r\n\r\n    function set_is_auth(address addy, bool booly) public onlyAuth {\r\n        is_auth[addy] = booly;\r\n    }\r\n\r\n    modifier onlyAuth() {\r\n        require(is_auth[msg.sender] || msg.sender == owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    address owner;\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    bool locked;\r\n    modifier safe() {\r\n        require(!locked, \"reentrant\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\n\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface ERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ninterface IUniswapFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapRouter01 {\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getamountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getamountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getamountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getamountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapRouter02 is IUniswapRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\ncontract smart {\r\n    address router_address = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    IUniswapRouter02 router = IUniswapRouter02(router_address);\r\n\r\n    uint kaiBalance;\r\n    uint meishuBalance;\r\n    uint kaiTax = 1; // 1%\r\n    uint meishuFee = 100000000000000000; // 0,1 ETH\r\n\r\n    function create_weth_pair(address token) private returns (address, IUniswapV2Pair) {\r\n       address pair_address = IUniswapFactory(router.factory()).createPair(token, router.WETH());\r\n       return (pair_address, IUniswapV2Pair(pair_address));\r\n    }\r\n\r\n    function get_weth_reserve(address pair_address) private  view returns(uint, uint) {\r\n        IUniswapV2Pair pair = IUniswapV2Pair(pair_address);\r\n        uint112 token_reserve;\r\n        uint112 native_reserve;\r\n        uint32 last_timestamp;\r\n        (token_reserve, native_reserve, last_timestamp) = pair.getReserves();\r\n        return (token_reserve, native_reserve);\r\n    }\r\n\r\n    function get_weth_price_impact(address token, uint amount, bool sell) private view returns(uint) {\r\n        address pair_address = IUniswapFactory(router.factory()).getPair(token, router.WETH());\r\n        (uint res_token, uint res_weth) = get_weth_reserve(pair_address);\r\n        uint impact;\r\n        if(sell) {\r\n            impact = (amount * 100) / res_token;\r\n        } else {\r\n            impact = (amount * 100) / res_weth;\r\n        }\r\n        return impact;\r\n    }\r\n}\r\n\r\ncontract  calendar {\r\n    function get_year_to_uint() public pure returns(uint) {\r\n        return(365 days);\r\n    }\r\n    function get_month_to_uint() public pure returns(uint) {\r\n        return(30 days);\r\n    } \r\n    function get_week_to_uint() public pure returns(uint) {\r\n        return(7 days);\r\n    }\r\n    function get_day_to_uint() public pure returns(uint) {\r\n        return(1 days);\r\n    }\r\n    function get_x_days_to_uint(uint16 _days) public pure returns(uint) {\r\n        return((1 days*_days));\r\n    }\r\n}\r\n\r\n/********************  MEISHU NFT STAKING  *********************/\r\n\r\ncontract MeishuStake is protected, smart,calendar {\r\n    receive() payable external {}\r\n    fallback() external {}\r\n\r\n    mapping(address => bool) public nft_addresses;\r\n    bool public nft_lock;\r\n\r\n    address public default_earning;\r\n    mapping(address => address) public custom_earning;\r\n\r\n    mapping(address => mapping(uint => uint)) public nft_rewards;\r\n\r\n    mapping(address => uint) public custom_floor;\r\n\r\n    uint public _common_reward;\r\n\r\n    ///@dev Modifiers rates\r\n    uint burn_rate;\r\n    uint penalty_rate;\r\n\r\n\r\n    ///@dev Updated each time a floor is added or removed\r\n    uint total_floors;\r\n\r\n    struct SINGLE_STAKE {\r\n        address nft;\r\n        uint token_id;\r\n        ERC721 nft_token;\r\n        address earned;\r\n        ERC20 earned_token;\r\n        uint8 qty;\r\n        uint floor;\r\n        uint start_time;\r\n        uint timelocked;\r\n        uint rewards;\r\n        bool active;\r\n        bool exists;\r\n        bool floor_based;\r\n    }\r\n\r\n    mapping(uint => bool) public times;\r\n\r\n    struct STAKEHOLDER {\r\n        mapping(uint => SINGLE_STAKE) stakes;\r\n        uint total_withdraw;\r\n        uint total_staked_value;\r\n        uint last_stake;\r\n        uint[] closed_pools;\r\n        bool blacklisted;\r\n    }\r\n\r\n    mapping (address => STAKEHOLDER) stakeholder;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        is_auth[owner] = true;\r\n        times[30 days] = true;\r\n        times[60 days] = true;\r\n        times[90 days] = true;\r\n        /*\r\n        30 days = 2592000\r\n        60 days = 5184000\r\n        90 days = 7776000\r\n        */\r\n    }\r\n\r\n    ///@dev Stake a specific NFT\r\n    function stake_nft(address _nft, uint id, uint timelock) payable public safe {\r\n        if(nft_lock) {\r\n            require(nft_addresses[_nft], \"This staking support other nfts\");\r\n        }\r\n        require(times[timelock], \"Timelock wrong\");\r\n        require(msg.value==meishuFee, \"Underpaid or overpaid\"); // 0.1 ETH pays for fees and gas\r\n        uint kaiPart = (meishuFee * kaiTax)/100;\r\n        kaiBalance += kaiPart; // 1% to Kaiba \r\n        meishuBalance = meishuFee - kaiPart;\r\n\r\n        require(ERC721(_nft).isApprovedForAll(msg.sender, address(this)), \"Pleasea approve transfer status\");\r\n        stakeholder[msg.sender].last_stake = stakeholder[msg.sender].last_stake + 1;\r\n        uint last_stake = stakeholder[msg.sender].last_stake;\r\n        // Configure the stake\r\n        stakeholder[msg.sender].stakes[last_stake].nft  = _nft;\r\n        stakeholder[msg.sender].stakes[last_stake].nft_token  = ERC721(_nft);\r\n        // Check if there is a particular token to earn\r\n        if(custom_earning[_nft]==DEAD) {\r\n            stakeholder[msg.sender].stakes[last_stake].earned = default_earning;\r\n            stakeholder[msg.sender].stakes[last_stake].earned_token = ERC20(default_earning);\r\n        } else {\r\n            stakeholder[msg.sender].stakes[last_stake].earned = custom_earning[_nft];\r\n            stakeholder[msg.sender].stakes[last_stake].earned_token = ERC20(custom_earning[_nft]);     \r\n        }\r\n        // Check if there is a particular reward rate\r\n        stakeholder[msg.sender].stakes[last_stake].rewards = _common_reward;\r\n        \r\n        // Transfer and last settings\r\n        ERC721(_nft).transferFrom(msg.sender, address(this), id);\r\n        stakeholder[msg.sender].stakes[last_stake].token_id = id;\r\n        stakeholder[msg.sender].stakes[last_stake].qty = 1;\r\n        stakeholder[msg.sender].stakes[last_stake].floor = custom_floor[_nft];\r\n        stakeholder[msg.sender].stakes[last_stake].start_time = block.timestamp;\r\n        stakeholder[msg.sender].stakes[last_stake].active = true;\r\n        stakeholder[msg.sender].stakes[last_stake].exists = true;\r\n        total_floors += custom_floor[_nft];\r\n    }\r\n\r\n    ///@dev Approve the transfer of a token (must be called before staking)\r\n    function approve_nft_on_contract(address _nft) public {\r\n        ERC721(_nft).setApprovalForAll(address(this), true);\r\n    }\r\n\r\n    ///@dev Set the burn rate\r\n    function set_burn_rate(uint rate) public onlyAuth {\r\n        burn_rate = rate;\r\n    }\r\n\r\n    ///@dev Set the penalty rate\r\n    function set_penalty_rate(uint rate) public onlyAuth {\r\n        penalty_rate = rate;\r\n    }\r\n\r\n    ///@dev Set the default earning token\r\n    function set_base_earning(address _earning) public onlyAuth {\r\n        default_earning = _earning;\r\n    }\r\n\r\n    ///@dev Set custom reward for an nft (yearly based)\r\n    function set_nft_reward(address _nft, uint _time, uint _reward) public onlyAuth {\r\n        nft_rewards[_nft][_time] = _reward;\r\n    }\r\n\r\n    function set_common_reward(uint _reward) public onlyAuth {\r\n        _common_reward = _reward;\r\n    }\r\n\r\n    ///@dev Set custom earning token for an nft\r\n    function set_custom_earning(address _nft, address _earning) public onlyAuth {\r\n        custom_earning[_nft] = _earning;\r\n    }\r\n\r\n    ///@dev set floor for a specific nft\r\n    function set_floor_on(address _nft, uint _floor) public onlyAuth {\r\n        custom_floor[_nft] = _floor;\r\n    }\r\n\r\n    ///@dev set floor for a specific pool updating total_floors\r\n    function set_pool_floor(address _stakeholder, uint _id, uint _floor) public onlyAuth {\r\n        require(stakeholder[_stakeholder].stakes[_id].exists, \"Pool is unconfigured\");\r\n        uint old_floor = stakeholder[_stakeholder].stakes[_id].floor;\r\n        total_floors -= old_floor;\r\n        stakeholder[_stakeholder].stakes[_id].floor = _floor;\r\n        total_floors += _floor;\r\n    }\r\n\r\n    ///@dev invalidate a pool\r\n    function invalidate_pool(address _stakeholder, uint _id) public onlyAuth {\r\n        require(stakeholder[_stakeholder].stakes[_id].exists, \"Pool is unconfigured\");\r\n        stakeholder[_stakeholder].stakes[_id].exists = false;\r\n        uint old_floor = stakeholder[_stakeholder].stakes[_id].floor;\r\n        total_floors -= old_floor;\r\n    }\r\n\r\n    ///@dev Enable or disable a time\r\n    function set_time_status(uint timed, bool booly) public onlyAuth {\r\n        times[timed] = booly;\r\n    }\r\n\r\n    ///@dev get balance\r\n    function set_staking_fee(uint wei_fee) public onlyAuth {\r\n        meishuFee = wei_fee;\r\n    }\r\n\r\n    ///@dev get balance\r\n    function set_kaiba_share(uint perc_share) public onlyAuth {\r\n        kaiTax = perc_share;\r\n    }\r\n\r\n    ///@dev get balance\r\n    function retrieve_meishu_balance() public onlyAuth {\r\n        if(!(address(this).balance >= meishuBalance)) {\r\n            meishuBalance = (address(this).balance*kaiTax)/100;\r\n            kaiBalance = address(this).balance - meishuBalance;\r\n        }\r\n        (bool sent,) = msg.sender.call{value: meishuBalance}(\"\");\r\n        require(sent, \"Can't withdraw\");\r\n    }\r\n\r\n    ///@dev get kaiba share    \r\n    function retrieve_kaiba_balance() public onlyAuth {\r\n        if(!(address(this).balance >= kaiBalance)) {\r\n            meishuBalance = (address(this).balance*kaiTax)/100;\r\n            kaiBalance = address(this).balance - meishuBalance;\r\n        }\r\n        (bool sent,) = msg.sender.call{value: kaiBalance}(\"\");\r\n        require(sent, \"Can't withdraw\");\r\n    }\r\n\r\n    ///@dev solve stuck problems\r\n    function unstuck() public onlyAuth {\r\n        meishuBalance = 0;\r\n        kaiBalance = 0;\r\n        (bool sent,) = msg.sender.call{value: address(this).balance-1}(\"\");\r\n        require(sent, \"Can't withdraw\");\r\n    }\r\n    /************************* Views *************************/\r\n\r\n    ///@dev get a single pool\r\n    function get_stakeholder_single_pool(address _stakeholder, uint _id) public view returns(\r\n        address _nft,\r\n        uint _nft_id,\r\n        address _earned,\r\n        uint _start_time,\r\n        uint _locktime,\r\n        uint _reward)\r\n        {\r\n        require(stakeholder[_stakeholder].stakes[_id].exists, \"Pool is unconfigured\");\r\n        return(\r\n            stakeholder[_stakeholder].stakes[_id].nft,\r\n            stakeholder[_stakeholder].stakes[_id].token_id,\r\n            stakeholder[_stakeholder].stakes[_id].earned,\r\n            stakeholder[_stakeholder].stakes[_id].start_time,\r\n            stakeholder[_stakeholder].stakes[_id].timelocked,\r\n            stakeholder[_stakeholder].stakes[_id].rewards\r\n        );\r\n    }\r\n\r\n    ///@dev get all the pools\r\n\r\n    function get_all_pools(address stkholder) public view returns (uint all_pools, uint[] memory closed_pools) {\r\n        return( stakeholder[stkholder].last_stake,\r\n                stakeholder[stkholder].closed_pools);\r\n    }\r\n\r\n    ///@dev calculate reward based on emission\r\n\r\n    function get_rewards_on(address _stakeholder, uint _id) public view returns(uint _reward) {\r\n        require(stakeholder[_stakeholder].stakes[_id].exists, \"Pool is unconfigured\");\r\n        require(stakeholder[_stakeholder].stakes[_id].active, \"Pool is inactive\");\r\n        uint reward = _common_reward;\r\n        uint start_time = stakeholder[_stakeholder].stakes[_id].start_time;\r\n        uint this_reward = _get_rewards(reward, start_time);\r\n        return this_reward;\r\n    }\r\n\r\n    function _get_rewards(uint reward, uint start_time) private view returns (uint uf_reward){\r\n        uint delta_time = block.timestamp - start_time;\r\n        uint year_perc = (delta_time * 1000000) / get_year_to_uint();\r\n        uint actual_reward = ((reward * year_perc) / 100)/10000;\r\n        return actual_reward;\r\n    }\r\n\r\n    ///@dev Calculate annual return\r\n    function get_annual_return(address _stakeholder, uint _id) public view returns (uint _reward_value){\r\n        address reward = stakeholder[_stakeholder].stakes[_id].earned;\r\n        uint amount = get_rewards_on(_stakeholder, _id);\r\n        uint reward_value = getTokenPrice(reward, amount);\r\n        return reward_value;\r\n    }\r\n\r\n    ///@dev Calculate APY\r\n    /* function get_apy(address _stakeholder, uint _id) public view returns (uint _apy){\r\n        address _nft = stakeholder[_stakeholder].stakes[_id].nft;\r\n        address earned;\r\n        uint reward;\r\n        if(custom_earning[_nft]==DEAD) {\r\n            earned = default_earning;\r\n        } else {\r\n            earned = custom_earning[_nft]; \r\n        }\r\n        // Check if there is a particular reward rate\r\n        if(custom_reward[_nft]==0) {\r\n            reward = default_reward;\r\n        } else {\r\n            reward = custom_reward[_nft];     \r\n        }\r\n        uint reward_value = getTokenPrice(earned, reward);\r\n        uint apy = (reward_value*100)/reward;\r\n        return apy;\r\n    } */\r\n\r\n    ///@dev Tokens (ERC20) price\r\n    function getTokenPrice(address tkn, uint amount) public view returns(uint)\r\n        {\r\n            IUniswapFactory factory = IUniswapFactory(router.factory());\r\n            address pairAddress = factory.getPair(tkn, router.WETH());\r\n            IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\r\n            ERC20 token1 = ERC20(pair.token1());\r\n        \r\n        \r\n            (uint Res0, uint Res1,) = pair.getReserves();\r\n\r\n            // decimals\r\n            uint res0 = Res0*(10**token1.decimals());\r\n            return((amount*res0)/Res1); // return amount of token0 needed to buy token1\r\n    }\r\n\r\n    ///@dev Payout earnings\r\n    function withdraw_earnings(address _stakeholder, uint _id) public safe {\r\n        require(msg.sender == _stakeholder, \"Don't steal\");\r\n        require(block.timestamp >= (stakeholder[_stakeholder].stakes[_id].start_time+1 hours),\"Wait.\");\r\n        bool penalty;\r\n        if(block.timestamp < (stakeholder[_stakeholder].stakes[_id].start_time + 15 days)) {\r\n            penalty = true;\r\n        }\r\n        address earning = stakeholder[_stakeholder].stakes[_id].earned;\r\n        uint reward_amount_raw = get_rewards_on(_stakeholder, _id);\r\n        uint burn_amount = (reward_amount_raw * burn_rate)/100;\r\n        uint penalty_amount;\r\n        if(penalty) {\r\n            penalty_amount = (reward_amount_raw * penalty_rate)/100;\r\n        }\r\n        uint reward_amount = reward_amount_raw - burn_amount - penalty_amount;\r\n        require(ERC20(earning).balanceOf(address(this)) >= reward_amount, \"Not enough tokens\");\r\n        ERC20(earning).transfer(_stakeholder, reward_amount);\r\n        ERC20(earning).transfer(DEAD, burn_amount);\r\n        stakeholder[_stakeholder].total_withdraw += reward_amount;\r\n        stakeholder[_stakeholder].stakes[_id].start_time = block.timestamp;\r\n        private_recover_pool(_stakeholder, _id, msg.sender, stakeholder[_stakeholder].stakes[_id].token_id);\r\n\r\n    } \r\n\r\n    /************************* Control Panel *************************/\r\n\r\n    function ctrl_disband() public onlyAuth {\r\n        selfdestruct(payable(owner));\r\n    }\r\n\r\n    function ctrl_allow_nft(address nftaddy, bool booly) public onlyAuth {\r\n        nft_addresses[nftaddy] = booly;\r\n    }\r\n\r\n    function ctrl_universal_staking(bool booly) public onlyAuth {\r\n        nft_lock = booly;\r\n    }\r\n\r\n    /// @dev Forcibly unset a pool\r\n    function ctrl_unstuck_token(address _stakeholder, uint _id, address caller, uint _token_id) public onlyAuth {\r\n        private_recover_pool(_stakeholder, _id, caller, _token_id);\r\n    }\r\n\r\n    /// @dev Forcibly set a pool\r\n    function ctrl_remake_pool(address _nft, uint id, address staker) public onlyAuth {\r\n        require(ERC721(_nft).isApprovedForAll(msg.sender, address(this)), \"Pleasea approve transfer status\");\r\n        stakeholder[staker].last_stake = stakeholder[staker].last_stake + 1;\r\n        uint last_stake = stakeholder[staker].last_stake;\r\n        // Configure the stake\r\n        stakeholder[staker].stakes[last_stake].nft  = _nft;\r\n        stakeholder[staker].stakes[last_stake].nft_token  = ERC721(_nft);\r\n        // Check if there is a particular token to earn\r\n        if(custom_earning[_nft]==DEAD) {\r\n            stakeholder[staker].stakes[last_stake].earned = default_earning;\r\n            stakeholder[staker].stakes[last_stake].earned_token = ERC20(default_earning);\r\n        } else {\r\n            stakeholder[staker].stakes[last_stake].earned = custom_earning[_nft];\r\n            stakeholder[staker].stakes[last_stake].earned_token = ERC20(custom_earning[_nft]);     \r\n        }\r\n        // Check if there is a particular reward rate\r\n        stakeholder[staker].stakes[last_stake].rewards = _common_reward;\r\n        \r\n        // Transfer and last settings\r\n        ERC721(_nft).transferFrom(msg.sender, address(this), id);\r\n        stakeholder[staker].stakes[last_stake].token_id = id;\r\n        stakeholder[staker].stakes[last_stake].qty = 1;\r\n        stakeholder[staker].stakes[last_stake].floor = custom_floor[_nft];\r\n        stakeholder[staker].stakes[last_stake].start_time = block.timestamp;\r\n        stakeholder[staker].stakes[last_stake].active = true;\r\n        stakeholder[staker].stakes[last_stake].exists = true;\r\n        total_floors += custom_floor[_nft];\r\n    }\r\n    /************************* Private Helpers *************************/\r\n\r\n    function private_recover_pool(address _stakeholder, uint _id, address caller, uint _token_id) private {\r\n        // Update total floor\r\n        uint old_floor = stakeholder[_stakeholder].stakes[_id].floor;\r\n        total_floors -= old_floor;\r\n        // Takes back nft\r\n        if(!is_auth[caller]) {\r\n            require(ERC721(stakeholder[_stakeholder].stakes[_id].nft).ownerOf(_token_id) == address(this), \"Nope\");\r\n        }\r\n        ERC721(stakeholder[_stakeholder].stakes[_id].nft).transferFrom(address(this), caller, _token_id);\r\n        // Unsetting all\r\n        stakeholder[_stakeholder].closed_pools.push(_id);\r\n        stakeholder[_stakeholder].stakes[_id].nft = DEAD;\r\n        stakeholder[_stakeholder].stakes[_id].earned  = DEAD;\r\n        stakeholder[_stakeholder].stakes[_id].qty  = 0;\r\n        stakeholder[_stakeholder].stakes[_id].floor = 0;\r\n        stakeholder[_stakeholder].stakes[_id].start_time = 0;\r\n        stakeholder[_stakeholder].stakes[_id].rewards = 0;\r\n        stakeholder[_stakeholder].stakes[_id].active = false;\r\n        stakeholder[_stakeholder].stakes[_id].exists = false;\r\n        stakeholder[_stakeholder].stakes[_id].floor_based = false;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"_common_reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"}],\"name\":\"approve_nft_on_contract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftaddy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"ctrl_allow_nft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ctrl_disband\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"ctrl_remake_pool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"ctrl_universal_staking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_token_id\",\"type\":\"uint256\"}],\"name\":\"ctrl_unstuck_token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"custom_earning\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"custom_floor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"default_earning\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stkholder\",\"type\":\"address\"}],\"name\":\"get_all_pools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"all_pools\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"closed_pools\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"get_annual_return\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_reward_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_day_to_uint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_month_to_uint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"get_rewards_on\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"get_stakeholder_single_pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nft_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_earned\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_start_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_locktime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_week_to_uint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_days\",\"type\":\"uint16\"}],\"name\":\"get_x_days_to_uint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_year_to_uint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"invalidate_pool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"is_it_auth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nft_addresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft_lock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nft_rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retrieve_kaiba_balance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retrieve_meishu_balance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_earning\",\"type\":\"address\"}],\"name\":\"set_base_earning\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"set_burn_rate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"set_common_reward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_earning\",\"type\":\"address\"}],\"name\":\"set_custom_earning\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_floor\",\"type\":\"uint256\"}],\"name\":\"set_floor_on\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"set_is_auth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"perc_share\",\"type\":\"uint256\"}],\"name\":\"set_kaiba_share\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"set_nft_reward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"set_penalty_rate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_floor\",\"type\":\"uint256\"}],\"name\":\"set_pool_floor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wei_fee\",\"type\":\"uint256\"}],\"name\":\"set_staking_fee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timed\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"set_time_status\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timelock\",\"type\":\"uint256\"}],\"name\":\"stake_nft\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"times\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstuck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"withdraw_earnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MeishuStake", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://80f7bc0ad6d88a994a07ace2f394df789008e6587facac76d1d7ec45c68abbd6"}]}