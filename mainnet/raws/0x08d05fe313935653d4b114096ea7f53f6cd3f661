{"status": "1", "message": "OK", "result": [{"SourceCode": "//SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n/// @title Rac Token Distributor smart contract\r\n/// @author coinvise\r\n/**  @notice This contract allows active RAC patreon subscribers to claim tokens based on subscription type per month\r\nwhen a user who has been whitelisted to claim for a month does not claim, that user looses the access to claim till whitelisted again \r\n*/\r\ncontract RacTokenDistributor {\r\n  // subscribe() will take in a uint for any of this\r\n  // 1 will represent Basic\r\n  // 2 will represent Premium\r\n  // 3 will represent VIP and so on as set by the admin\r\n\r\n  /** @notice maps and address to a subsription type, subscription types are represented with number\r\n   */\r\n  mapping(address => uint256) public subscriptionType;\r\n\r\n  /** @notice maps a subscription type(which is a uint) to amount of claimable tokens\r\n   */\r\n  mapping(uint256 => uint256) public claimableTokensPerSubType;\r\n\r\n  /** @notice maps an address to a bool value if user has claimed or not till whitelisted again\r\n   */\r\n  mapping(address => bool) public hasClaimedForTheMonth;\r\n\r\n  /** @notice maps an address to the time last whitelised, this helps to check if its past one month a user was lastwhitelised,\r\n      if so, user won't be able to claim till whitelisted again\r\n   */\r\n  mapping(address => uint256) public lastTimeWhiteListed;\r\n\r\n  /// @notice max number of valid subscription type\r\n  uint256 public numOfValidSubTypes;\r\n\r\n  /// @notice Emitted when user is whitelisted\r\n  /// @param user The address of user\r\n  /// @param subType subscripton type for user\r\n  event Whitelisted(address indexed user, uint256 indexed subType);\r\n\r\n  /// @notice Emitted when user claims\r\n  /// @param user The address of user\r\n  /// @param amountClaimed amount claimed\r\n  event Claimed(address indexed user, uint256 amountClaimed);\r\n\r\n  /// @notice instantiates Rac token\r\n  IERC20 racInstance = IERC20(0xc22B30E4cce6b78aaaADae91E44E73593929a3e9);\r\n\r\n  /// @notice admin address\r\n  address public admin = 0xD4B8DBAaa4FeFE1f033CfB1e77e2315EB6df8CFB;\r\n\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == admin, \"only admin can do this\");\r\n    _;\r\n  }\r\n\r\n  /// @notice batch whiteList addresses\r\n  /// @param _users arrays of users\r\n  /// @param _subscriptionType arrays of subscription types which users will be mapped to respectively\r\n  /// @dev this function is callable by only admin\r\n\r\n  function batchWhitelist(\r\n    address[] memory _users,\r\n    uint256[] memory _subscriptionType\r\n  ) public onlyAdmin {\r\n    require(\r\n      _users.length == _subscriptionType.length,\r\n      \"users and subscriptionType length mismatch\"\r\n    );\r\n    for (uint256 i = 0; i < _users.length; i++) {\r\n      require(\r\n        _subscriptionType[i] <= numOfValidSubTypes && _subscriptionType[i] != 0,\r\n        \"number passed not within subscription range\"\r\n      );\r\n      subscriptionType[_users[i]] = _subscriptionType[i];\r\n      hasClaimedForTheMonth[_users[i]] = false;\r\n      lastTimeWhiteListed[_users[i]] = block.timestamp;\r\n      emit Whitelisted(_users[i], _subscriptionType[i]);\r\n    }\r\n  }\r\n\r\n  /// @notice batch set claimable tokens per sub type\r\n  /// @dev this function checks the subtypes passed and increments the numOfValidSubTypes if sub types doesnt yet exists\r\n  /// @param _subType arrays of subscription types\r\n  /// @param _amountClaimable arrays of claimable amount per sub types\r\n  /// @return returns bool when function runs successfully\r\n\r\n  function batchSetClaimableTokensPerSub(\r\n    uint256[] memory _subType,\r\n    uint256[] memory _amountClaimable\r\n  ) public onlyAdmin returns (bool) {\r\n    require(\r\n      _subType.length == _amountClaimable.length,\r\n      \"subtype length should be equal to claimable amount length\"\r\n    );\r\n\r\n    for (uint256 i = 0; i < _subType.length; i++) {\r\n      claimableTokensPerSubType[_subType[i]] = _amountClaimable[i];\r\n\r\n      if (_subType[i] > numOfValidSubTypes) {\r\n        numOfValidSubTypes = numOfValidSubTypes + 1;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // withdraws contract rac token balance only by admin\r\n\r\n  function withdrawContractBalance(address _address) public onlyAdmin {\r\n    uint256 bal = racInstance.balanceOf(address(this));\r\n    racInstance.transfer(_address, bal);\r\n  }\r\n\r\n  /**\r\n         @notice users call this function to claim rac token- the contracts sends the matched claimable tokens per thier respective subscription type\r\n         this function checks users subscription type, checked if they have claimed within the set time(mostly a month) and finally checks if they are attempting\r\n         claim within the specified time(mostly a month)\r\n      */\r\n\r\n  function claimRacForTheMonth() public {\r\n    require(\r\n      subscriptionType[msg.sender] <= numOfValidSubTypes &&\r\n        subscriptionType[msg.sender] != 0,\r\n      \"You do not have a valid subscription on this platform\"\r\n    );\r\n    require(\r\n      hasClaimedForTheMonth[msg.sender] == false,\r\n      \"you have claimed already, kindly wait to be whiteListed for another round\"\r\n    );\r\n    require(\r\n      block.timestamp - (lastTimeWhiteListed[msg.sender]) <= 60 * 60 * 24 * 31,\r\n      \"you don't seem whitelisted to claim for this month\"\r\n    );\r\n\r\n    //check user sub type to determine how much token to claimable\r\n    uint256 userSubType = subscriptionType[msg.sender];\r\n\r\n    // change mapping to true that address has claimedDateInterval\r\n    hasClaimedForTheMonth[msg.sender] = true;\r\n\r\n    // change subscription type to 0\r\n    subscriptionType[msg.sender] = 0;\r\n\r\n    // use userSubType to check how much claimableTokensPerSub token\r\n    racInstance.transfer(msg.sender, claimableTokensPerSubType[userSubType]);\r\n\r\n    emit Claimed(msg.sender, claimableTokensPerSubType[userSubType]);\r\n  }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subType\",\"type\":\"uint256\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_subType\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amountClaimable\",\"type\":\"uint256[]\"}],\"name\":\"batchSetClaimableTokensPerSub\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_subscriptionType\",\"type\":\"uint256[]\"}],\"name\":\"batchWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRacForTheMonth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimableTokensPerSubType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimedForTheMonth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastTimeWhiteListed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numOfValidSubTypes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"subscriptionType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"withdrawContractBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RacTokenDistributor", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dfb33a80b1f9630e0bfdb77491bdd47490bd3d79884ce8a0930451618c643a06"}]}