{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LosslessStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\n\\nimport \\\"./Interfaces/ILosslessERC20.sol\\\";\\nimport \\\"./Interfaces/ILosslessController.sol\\\";\\nimport \\\"./Interfaces/ILosslessGovernance.sol\\\";\\nimport \\\"./Interfaces/ILosslessReporting.sol\\\";\\nimport \\\"./Interfaces/ILosslessStaking.sol\\\";\\n\\n/// @title Lossless Staking Contract\\n/// @notice The Staking contract is in charge of handling the staking done on reports\\ncontract LosslessStaking is ILssStaking, Initializable, ContextUpgradeable, PausableUpgradeable {\\n\\n    struct Stake {\\n        mapping(uint256 => StakeInfo) stakeInfoOnReport;\\n    }\\n\\n    struct StakeInfo {\\n        uint256 timestamp;\\n        uint256 coefficient;\\n        uint256 totalStakedOnReport;\\n        bool staked;\\n        bool payed;\\n    }\\n\\n    ILERC20 override public stakingToken;\\n    ILssReporting override public losslessReporting;\\n    ILssController override public losslessController;\\n    ILssGovernance override public losslessGovernance;\\n\\n    uint256 public override stakingAmount;\\n    uint256 public constant HUNDRED = 1e2;\\n    uint256 public constant MILLION = 1e6;\\n\\n    mapping(address => Stake) private stakes;\\n\\n    mapping(uint256 => uint256) public reportCoefficient;\\n\\n    mapping(address => PerReportAmount) stakedOnReport;\\n\\n    struct PerReportAmount {\\n        mapping(uint256 => uint256) report;\\n    }\\n\\n    function initialize(ILssReporting _losslessReporting, ILssController _losslessController, uint256 _stakingAmount) public initializer {\\n       losslessReporting = _losslessReporting;\\n       losslessController = _losslessController;\\n       stakingAmount = _stakingAmount;\\n    }\\n\\n    // --- MODIFIERS ---\\n\\n    modifier onlyLosslessAdmin() {\\n        require(msg.sender == losslessController.admin(), \\\"LSS: Must be admin\\\");\\n        _;\\n    }\\n\\n    modifier onlyLosslessPauseAdmin() {\\n        require(msg.sender == losslessController.pauseAdmin(), \\\"LSS: Must be pauseAdmin\\\");\\n        _;\\n    }\\n\\n    modifier notBlacklisted() {\\n        require(!losslessController.blacklist(msg.sender), \\\"LSS: You cannot operate\\\");\\n        _;\\n    }\\n\\n    // --- SETTERS ---\\n\\n    /// @notice This function pauses the contract\\n    function pause() override public onlyLosslessPauseAdmin {\\n        _pause();\\n    }    \\n\\n    /// @notice This function unpauses the contract\\n    function unpause() override public onlyLosslessPauseAdmin {\\n        _unpause();\\n    }\\n\\n    /// @notice This function sets the address of the Lossless Reporting contract\\n    /// @dev Only can be called by the Lossless Admin\\n    /// @param _losslessReporting Address corresponding to the Lossless Reporting contract\\n    function setLssReporting(ILssReporting _losslessReporting) override public onlyLosslessAdmin {\\n        require(address(_losslessReporting) != address(0), \\\"LERC20: Cannot be zero address\\\");\\n        losslessReporting = _losslessReporting;\\n        emit NewReportingContract(_losslessReporting);\\n    }\\n\\n    /// @notice This function sets the address of the Lossless Governance Token\\n    /// @dev Only can be called by the Lossless Admin\\n    /// @param _stakingToken Address corresponding to the Lossless Governance Token\\n    function setStakingToken(ILERC20 _stakingToken) override public onlyLosslessAdmin {\\n        require(address(_stakingToken) != address(0), \\\"LERC20: Cannot be zero address\\\");\\n        stakingToken = _stakingToken;\\n        emit NewStakingToken(_stakingToken);\\n    }\\n\\n    /// @notice This function sets the address of the Lossless Governance contract\\n    /// @dev Only can be called by the Lossless Admin\\n    /// @param _losslessGovernance Address corresponding to the Lossless Governance contract\\n    function setLosslessGovernance(ILssGovernance _losslessGovernance) override public onlyLosslessAdmin {\\n        require(address(_losslessGovernance) != address(0), \\\"LERC20: Cannot be zero address\\\");\\n        losslessGovernance = _losslessGovernance;\\n        emit NewGovernanceContract(_losslessGovernance);\\n    }\\n\\n    /// @notice This function sets the amount of tokens to be staked when staking\\n    /// @dev Only can be called by the Lossless Admin\\n    /// @param _stakingAmount Amount to be staked\\n    function setStakingAmount(uint256 _stakingAmount) override public onlyLosslessAdmin {\\n        require(_stakingAmount != 0, \\\"LSS: Must be greater than zero\\\");\\n        require(_stakingAmount != stakingAmount, \\\"LSS: Already set to that amount\\\");\\n        stakingAmount = _stakingAmount;\\n        emit NewStakingAmount(_stakingAmount);\\n    }\\n\\n    // STAKING\\n\\n    /// @notice This function generates a stake on a report\\n    /// @dev The earlier the stake is placed on the report, the higher the reward is.\\n    /// The reporter cannot stake as it'll have a fixed percentage reward.\\n    /// A reported address cannot stake.\\n    /// @param _reportId Report to stake\\n    function stake(uint256 _reportId) override public notBlacklisted whenNotPaused {\\n        require(!losslessGovernance.isReportSolved(_reportId), \\\"LSS: Report already resolved\\\");\\n\\n        StakeInfo storage stakeInfo = stakes[msg.sender].stakeInfoOnReport[_reportId];\\n\\n        (address reporter,,, uint256 reportTimestamps, ILERC20 reportTokens,,) = losslessReporting.getReportInfo(_reportId);\\n\\n        require(!stakeInfo.staked, \\\"LSS: already staked\\\");\\n        require(msg.sender != reporter, \\\"LSS: reporter can not stake\\\");   \\n\\n        uint256 reportTimestamp = reportTimestamps;\\n        uint256 reportLifetime = losslessReporting.reportLifetime();\\n\\n        require(_reportId != 0 && (reportTimestamp + reportLifetime) > block.timestamp, \\\"LSS: report does not exists\\\");\\n\\n        uint256 stakerCoefficient = reportTimestamp + reportLifetime - block.timestamp;\\n\\n        stakeInfo.timestamp = block.timestamp;\\n        stakeInfo.coefficient = stakerCoefficient;\\n        stakeInfo.staked = true;\\n\\n        reportCoefficient[_reportId] += stakerCoefficient;\\n        \\n        require(stakingToken.transferFrom(msg.sender, address(this), stakingAmount),\\n        \\\"LSS: Staking transfer failed\\\");\\n\\n        stakeInfo.totalStakedOnReport += stakingAmount;\\n        stakedOnReport[msg.sender].report[_reportId] = stakingAmount;\\n        \\n        emit NewStake(reportTokens, msg.sender, _reportId, stakingAmount);\\n    }\\n\\n    // --- CLAIM ---\\n    \\n    /// @notice This function returns the claimable amount by the stakers\\n    /// @dev It takes into consideration the staker coefficient in order to return the percentage rewarded.\\n    /// @param _reportId Staked report\\n    function stakerClaimableAmount(uint256 _reportId) override public view returns (uint256) {\\n        (,,, uint256 stakersReward) = losslessReporting.getRewards();\\n        uint256 amountStakedOnReport = losslessGovernance.getAmountReported(_reportId);\\n        uint256 amountDistributedToStakers = (amountStakedOnReport * stakersReward) / HUNDRED;\\n        uint256 stakerCoefficient = getStakerCoefficient(_reportId, msg.sender);\\n        uint256 coefficientMultiplier = ((amountDistributedToStakers * MILLION) / reportCoefficient[_reportId]);\\n        uint256 stakerAmountToClaim = (coefficientMultiplier * stakerCoefficient) / MILLION;\\n        return stakerAmountToClaim;\\n    }\\n\\n\\n    /// @notice This function is for the stakers to claim their rewards\\n    /// @param _reportId Staked report\\n    function stakerClaim(uint256 _reportId) override public whenNotPaused {\\n        StakeInfo storage stakeInfo = stakes[msg.sender].stakeInfoOnReport[_reportId];\\n\\n        require(!stakeInfo.payed, \\\"LSS: You already claimed\\\");\\n        require(losslessGovernance.reportResolution(_reportId), \\\"LSS: Report solved negatively\\\");\\n\\n        stakeInfo.payed = true;\\n\\n        uint256 amountToClaim = stakerClaimableAmount(_reportId);\\n\\n        (,,,, ILERC20 reportTokens,,) = losslessReporting.getReportInfo(_reportId);\\n\\n        require(reportTokens.transfer(msg.sender, amountToClaim),\\n        \\\"LSS: Reward transfer failed\\\");\\n        require(stakingToken.transfer(msg.sender, stakedOnReport[msg.sender].report[_reportId]),\\n        \\\"LSS: Staking transfer failed\\\");\\n\\n        emit StakerClaim(msg.sender, reportTokens, _reportId, amountToClaim);\\n    }\\n\\n    // --- GETTERS ---\\n\\n    /// @notice This function returns the contract version\\n    /// @return Returns the Smart Contract version\\n    function getVersion() override public pure returns (uint256) {\\n        return 1;\\n    }\\n\\n    \\n    /// @notice This function returns if an address is already staking on a report\\n    /// @param _reportId Report being staked\\n    /// @param _account Address to consult\\n    /// @return True if the account is already staking\\n    function getIsAccountStaked(uint256 _reportId, address _account) override public view returns(bool) {\\n        return stakes[_account].stakeInfoOnReport[_reportId].staked;\\n    }\\n\\n    /// @notice This function returns the coefficient of a staker in a report\\n    /// @param _reportId Report where the address staked\\n    /// @param _address Staking address\\n    /// @return The coefficient calculated for the staker\\n    function getStakerCoefficient(uint256 _reportId, address _address) override public view returns (uint256) {\\n        return stakes[_address].stakeInfoOnReport[_reportId].coefficient;\\n    }\\n\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ILosslessERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ILERC20 {\\n    function name() external view returns (string memory);\\n    function admin() external view returns (address);\\n    function getAdmin() external view returns (address);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address _account) external view returns (uint256);\\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n    function approve(address _spender, uint256 _amount) external returns (bool);\\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);\\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool);\\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool);\\n    \\n    function transferOutBlacklistedFunds(address[] calldata _from) external;\\n    function setLosslessAdmin(address _newAdmin) external;\\n    function transferRecoveryAdminOwnership(address _candidate, bytes32 _keyHash) external;\\n    function acceptRecoveryAdminOwnership(bytes memory _key) external;\\n    function proposeLosslessTurnOff() external;\\n    function executeLosslessTurnOff() external;\\n    function executeLosslessTurnOn() external;\\n\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n    event NewAdmin(address indexed _newAdmin);\\n    event NewRecoveryAdminProposal(address indexed _candidate);\\n    event NewRecoveryAdmin(address indexed _newAdmin);\\n    event LosslessTurnOffProposal(uint256 _turnOffDate);\\n    event LosslessOff();\\n    event LosslessOn();\\n}\"\r\n    },\r\n    \"contracts/Interfaces/ILosslessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ILosslessERC20.sol\\\";\\nimport \\\"./ILosslessGovernance.sol\\\";\\nimport \\\"./ILosslessStaking.sol\\\";\\nimport \\\"./ILosslessReporting.sol\\\";\\nimport \\\"./IProtectionStrategy.sol\\\";\\n\\ninterface ILssController {\\n    // function getLockedAmount(ILERC20 _token, address _account)  returns (uint256);\\n    // function getAvailableAmount(ILERC20 _token, address _account) external view returns (uint256 amount);\\n    function retrieveBlacklistedFunds(address[] calldata _addresses, ILERC20 _token, uint256 _reportId) external returns(uint256);\\n    function whitelist(address _adr) external view returns (bool);\\n    function dexList(address _dexAddress) external returns (bool);\\n    function blacklist(address _adr) external view returns (bool);\\n    function admin() external view returns (address);\\n    function pauseAdmin() external view returns (address);\\n    function recoveryAdmin() external view returns (address);\\n    function guardian() external view returns (address);\\n    function losslessStaking() external view returns (ILssStaking);\\n    function losslessReporting() external view returns (ILssReporting);\\n    function losslessGovernance() external view returns (ILssGovernance);\\n    function dexTranferThreshold() external view returns (uint256);\\n    function settlementTimeLock() external view returns (uint256);\\n    \\n    function pause() external;\\n    function unpause() external;\\n    function setAdmin(address _newAdmin) external;\\n    function setRecoveryAdmin(address _newRecoveryAdmin) external;\\n    function setPauseAdmin(address _newPauseAdmin) external;\\n    function setSettlementTimeLock(uint256 _newTimelock) external;\\n    function setDexTransferThreshold(uint256 _newThreshold) external;\\n    function setDexList(address[] calldata _dexList, bool _value) external;\\n    function setWhitelist(address[] calldata _addrList, bool _value) external;\\n    function addToBlacklist(address _adr) external;\\n    function resolvedNegatively(address _adr) external;\\n    function setStakingContractAddress(ILssStaking _adr) external;\\n    function setReportingContractAddress(ILssReporting _adr) external; \\n    function setGovernanceContractAddress(ILssGovernance _adr) external;\\n    function proposeNewSettlementPeriod(ILERC20 _token, uint256 _seconds) external;\\n    function executeNewSettlementPeriod(ILERC20 _token) external;\\n    function activateEmergency(ILERC20 _token) external;\\n    function deactivateEmergency(ILERC20 _token) external;\\n    function setGuardian(address _newGuardian) external;\\n    function removeProtectedAddress(ILERC20 _token, address _protectedAddresss) external;\\n    function beforeTransfer(address _sender, address _recipient, uint256 _amount) external;\\n    function beforeTransferFrom(address _msgSender, address _sender, address _recipient, uint256 _amount) external;\\n    function beforeApprove(address _sender, address _spender, uint256 _amount) external;\\n    function beforeIncreaseAllowance(address _msgSender, address _spender, uint256 _addedValue) external;\\n    function beforeDecreaseAllowance(address _msgSender, address _spender, uint256 _subtractedValue) external;\\n    function beforeMint(address _to, uint256 _amount) external;\\n    function beforeBurn(address _account, uint256 _amount) external;\\n    function setProtectedAddress(ILERC20 _token, address _protectedAddress, ProtectionStrategy _strategy) external;\\n\\n    event AdminChange(address indexed _newAdmin);\\n    event RecoveryAdminChange(address indexed _newAdmin);\\n    event PauseAdminChange(address indexed _newAdmin);\\n    event GuardianSet(address indexed _oldGuardian, address indexed _newGuardian);\\n    event NewProtectedAddress(ILERC20 indexed _token, address indexed _protectedAddress, address indexed _strategy);\\n    event RemovedProtectedAddress(ILERC20 indexed _token, address indexed _protectedAddress);\\n    event NewSettlementPeriodProposal(ILERC20 indexed _token, uint256 _seconds);\\n    event SettlementPeriodChange(ILERC20 indexed _token, uint256 _proposedTokenLockTimeframe);\\n    event NewSettlementTimelock(uint256 indexed _timelock);\\n    event NewDexThreshold(uint256 indexed _newThreshold);\\n    event NewDex(address indexed _dexAddress);\\n    event DexRemoval(address indexed _dexAddress);\\n    event NewWhitelistedAddress(address indexed _whitelistAdr);\\n    event WhitelistedAddressRemoval(address indexed _whitelistAdr);\\n    event NewBlacklistedAddress(address indexed _blacklistedAddres);\\n    event AccountBlacklistRemoval(address indexed _adr);\\n    event NewStakingContract(ILssStaking indexed _newAdr);\\n    event NewReportingContract(ILssReporting indexed _newAdr);\\n    event NewGovernanceContract(ILssGovernance indexed _newAdr);\\n    event EmergencyActive(ILERC20 indexed _token);\\n    event EmergencyDeactivation(ILERC20 indexed _token);\\n}\"\r\n    },\r\n    \"contracts/Interfaces/ILosslessGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ILosslessERC20.sol\\\";\\nimport \\\"./ILosslessStaking.sol\\\";\\nimport \\\"./ILosslessReporting.sol\\\";\\nimport \\\"./ILosslessController.sol\\\";\\n\\ninterface ILssGovernance {\\n    function LSS_TEAM_INDEX() external view returns(uint256);\\n    function TOKEN_OWNER_INDEX() external view returns(uint256);\\n    function COMMITEE_INDEX() external view returns(uint256);\\n    function committeeMembersCount() external view returns(uint256);\\n    function walletDisputePeriod() external view returns(uint256);\\n    function losslessStaking() external view returns (ILssStaking);\\n    function losslessReporting() external view returns (ILssReporting);\\n    function losslessController() external view returns (ILssController);\\n    function isCommitteeMember(address _account) external view returns(bool);\\n    function getIsVoted(uint256 _reportId, uint256 _voterIndex) external view returns(bool);\\n    function getVote(uint256 _reportId, uint256 _voterIndex) external view returns(bool);\\n    function isReportSolved(uint256 _reportId) external view returns(bool);\\n    function reportResolution(uint256 _reportId) external view returns(bool);\\n    function getAmountReported(uint256 _reportId) external view returns(uint256);\\n    \\n    function setDisputePeriod(uint256 _timeFrame) external;\\n    function addCommitteeMembers(address[] memory _members) external;\\n    function removeCommitteeMembers(address[] memory _members) external;\\n    function losslessVote(uint256 _reportId, bool _vote) external;\\n    function tokenOwnersVote(uint256 _reportId, bool _vote) external;\\n    function committeeMemberVote(uint256 _reportId, bool _vote) external;\\n    function resolveReport(uint256 _reportId) external;\\n    function proposeWallet(uint256 _reportId, address wallet) external;\\n    function rejectWallet(uint256 _reportId) external;\\n    function retrieveFunds(uint256 _reportId) external;\\n    function retrieveCompensation() external;\\n    function claimCommitteeReward(uint256 _reportId) external;\\n    function setCompensationAmount(uint256 _amount) external;\\n    function losslessClaim(uint256 _reportId) external;\\n    function setRevshareAdmin(address _address) external;\\n    function setRevsharePercentage(uint256 _amount) external;\\n    function revshareClaim(uint256 _reportId) external;\\n\\n    event NewCommitteeMembers(address[] _members);\\n    event CommitteeMembersRemoval(address[] _members);\\n    event LosslessTeamPositiveVote(uint256 indexed _reportId);\\n    event LosslessTeamNegativeVote(uint256 indexed _reportId);\\n    event TokenOwnersPositiveVote(uint256 indexed _reportId);\\n    event TokenOwnersNegativeVote(uint256 indexed _reportId);\\n    event CommitteeMemberPositiveVote(uint256 indexed _reportId, address indexed _member);\\n    event CommitteeMemberNegativeVote(uint256 indexed _reportId, address indexed _member);\\n    event ReportResolve(uint256 indexed _reportId, bool indexed _resolution);\\n    event WalletProposal(uint256 indexed _reportId, address indexed _wallet);\\n    event CommitteeMemberClaim(uint256 indexed _reportId, address indexed _member, uint256 indexed _amount);\\n    event CommitteeMajorityReach(uint256 indexed _reportId, bool indexed _result);\\n    event NewDisputePeriod(uint256 indexed _newPeriod);\\n    event WalletRejection(uint256 indexed _reportId);\\n    event FundsRetrieval(uint256 indexed _reportId, uint256 indexed _amount);\\n    event CompensationRetrieval(address indexed _wallet, uint256 indexed _amount);\\n    event LosslessClaim(ILERC20 indexed _token, uint256 indexed _reportID, uint256 indexed _amount);\\n    event NewCompensationPercentage(uint256 indexed _compensationPercentage);\\n    event NewRevshareAdmin(address indexed _revshareAdmin);\\n    event NewRevsharePercentage(uint256 indexed _revsharePercentage);\\n    event RevshareClaim(ILERC20 indexed _token, uint256 indexed _reportID, uint256 indexed _amount);\\n}\\n\\n\"\r\n    },\r\n    \"contracts/Interfaces/ILosslessReporting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ILosslessERC20.sol\\\";\\nimport \\\"./ILosslessGovernance.sol\\\";\\nimport \\\"./ILosslessStaking.sol\\\";\\nimport \\\"./ILosslessController.sol\\\";\\n\\ninterface ILssReporting {\\n  function reporterReward() external returns(uint256);\\n  function losslessReward() external returns(uint256);\\n  function stakersReward() external returns(uint256);\\n  function committeeReward() external returns(uint256);\\n  function reportLifetime() external view returns(uint256);\\n  function reportingAmount() external returns(uint256);\\n  function reportCount() external returns(uint256);\\n  function stakingToken() external returns(ILERC20);\\n  function losslessController() external returns(ILssController);\\n  function losslessGovernance() external returns(ILssGovernance);\\n  function getVersion() external pure returns (uint256);\\n  function getRewards() external view returns (uint256 _reporter, uint256 _lossless, uint256 _committee, uint256 _stakers);\\n  function report(ILERC20 _token, address _account) external returns (uint256);\\n  function reporterClaimableAmount(uint256 _reportId) external view returns (uint256);\\n  function getReportInfo(uint256 _reportId) external view returns(address _reporter,\\n        address _reportedAddress,\\n        address _secondReportedAddress,\\n        uint256 _reportTimestamps,\\n        ILERC20 _reportTokens,\\n        bool _secondReports,\\n        bool _reporterClaimStatus);\\n  \\n  function pause() external;\\n  function unpause() external;\\n  function setStakingToken(ILERC20 _stakingToken) external;\\n  function setLosslessGovernance(ILssGovernance _losslessGovernance) external;\\n  function setReportingAmount(uint256 _reportingAmount) external;\\n  function setReporterReward(uint256 _reward) external;\\n  function setLosslessReward(uint256 _reward) external;\\n  function setStakersReward(uint256 _reward) external;\\n  function setCommitteeReward(uint256 _reward) external;\\n  function setReportLifetime(uint256 _lifetime) external;\\n  function secondReport(uint256 _reportId, address _account) external;\\n  function reporterClaim(uint256 _reportId) external;\\n  function retrieveCompensation(address _adr, uint256 _amount) external;\\n\\n  event ReportSubmission(ILERC20 indexed _token, address indexed _account, uint256 indexed _reportId, uint256 _amount);\\n  event SecondReportSubmission(ILERC20 indexed _token, address indexed _account, uint256 indexed _reportId);\\n  event NewReportingAmount(uint256 indexed _newAmount);\\n  event NewStakingToken(ILERC20 indexed _token);\\n  event NewGovernanceContract(ILssGovernance indexed _adr);\\n  event NewReporterReward(uint256 indexed _newValue);\\n  event NewLosslessReward(uint256 indexed _newValue);\\n  event NewStakersReward(uint256 indexed _newValue);\\n  event NewCommitteeReward(uint256 indexed _newValue);\\n  event NewReportLifetime(uint256 indexed _newValue);\\n  event ReporterClaim(address indexed _reporter, uint256 indexed _reportId, uint256 indexed _amount);\\n  event CompensationRetrieve(address indexed _adr, uint256 indexed _amount);\\n}\"\r\n    },\r\n    \"contracts/Interfaces/ILosslessStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ILosslessERC20.sol\\\";\\nimport \\\"./ILosslessGovernance.sol\\\";\\nimport \\\"./ILosslessReporting.sol\\\";\\nimport \\\"./ILosslessController.sol\\\";\\n\\ninterface ILssStaking {\\n  function stakingToken() external returns(ILERC20);\\n  function losslessReporting() external returns(ILssReporting);\\n  function losslessController() external returns(ILssController);\\n  function losslessGovernance() external returns(ILssGovernance);\\n  function stakingAmount() external returns(uint256);\\n  function getVersion() external pure returns (uint256);\\n  function getIsAccountStaked(uint256 _reportId, address _account) external view returns(bool);\\n  function getStakerCoefficient(uint256 _reportId, address _address) external view returns (uint256);\\n  function stakerClaimableAmount(uint256 _reportId) external view returns (uint256);\\n  \\n  function pause() external;\\n  function unpause() external;\\n  function setLssReporting(ILssReporting _losslessReporting) external;\\n  function setStakingToken(ILERC20 _stakingToken) external;\\n  function setLosslessGovernance(ILssGovernance _losslessGovernance) external;\\n  function setStakingAmount(uint256 _stakingAmount) external;\\n  function stake(uint256 _reportId) external;\\n  function stakerClaim(uint256 _reportId) external;\\n\\n  event NewStake(ILERC20 indexed _token, address indexed _account, uint256 indexed _reportId, uint256 _amount);\\n  event StakerClaim(address indexed _staker, ILERC20 indexed _token, uint256 indexed _reportID, uint256 _amount);\\n  event NewStakingAmount(uint256 indexed _newAmount);\\n  event NewStakingToken(ILERC20 indexed _newToken);\\n  event NewReportingContract(ILssReporting indexed _newContract);\\n  event NewGovernanceContract(ILssGovernance indexed _newContract);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IProtectionStrategy.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\ninterface ProtectionStrategy {\\n    function isTransferAllowed(address token, address sender, address recipient, uint256 amount) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILssGovernance\",\"name\":\"_newContract\",\"type\":\"address\"}],\"name\":\"NewGovernanceContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILssReporting\",\"name\":\"_newContract\",\"type\":\"address\"}],\"name\":\"NewReportingContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"NewStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_newAmount\",\"type\":\"uint256\"}],\"name\":\"NewStakingAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILERC20\",\"name\":\"_newToken\",\"type\":\"address\"}],\"name\":\"NewStakingToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"StakerClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HUNDRED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MILLION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getIsAccountStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getStakerCoefficient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILssReporting\",\"name\":\"_losslessReporting\",\"type\":\"address\"},{\"internalType\":\"contract ILssController\",\"name\":\"_losslessController\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakingAmount\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"losslessController\",\"outputs\":[{\"internalType\":\"contract ILssController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"losslessGovernance\",\"outputs\":[{\"internalType\":\"contract ILssGovernance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"losslessReporting\",\"outputs\":[{\"internalType\":\"contract ILssReporting\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reportCoefficient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILssGovernance\",\"name\":\"_losslessGovernance\",\"type\":\"address\"}],\"name\":\"setLosslessGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILssReporting\",\"name\":\"_losslessReporting\",\"type\":\"address\"}],\"name\":\"setLssReporting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakingAmount\",\"type\":\"uint256\"}],\"name\":\"setStakingAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILERC20\",\"name\":\"_stakingToken\",\"type\":\"address\"}],\"name\":\"setStakingToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"stakerClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"stakerClaimableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract ILERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LosslessStaking", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}