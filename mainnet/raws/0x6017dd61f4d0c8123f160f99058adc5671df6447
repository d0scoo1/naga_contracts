{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Vester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {DssVestTransferrable} from \\\"dss-vest/DssVest.sol\\\";\\n\\ncontract Vester is DssVestTransferrable {\\n  constructor(address _czar, address _gem) DssVestTransferrable(_czar, _gem) {}\\n}\\n\"\r\n    },\r\n    \"lib/dss-vest/src/DssVest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n// DssVest - Token vesting contract\\n//\\n// Copyright (C) 2021 Dai Foundation\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.13;\\n\\ninterface MintLike {\\n    function mint(address, uint256) external;\\n}\\n\\ninterface ChainlogLike {\\n    function getAddress(bytes32) external view returns (address);\\n}\\n\\ninterface DaiJoinLike {\\n    function exit(address, uint256) external;\\n}\\n\\ninterface VatLike {\\n    function hope(address) external;\\n    function suck(address, address, uint256) external;\\n}\\n\\ninterface TokenLike {\\n    function transferFrom(address, address, uint256) external returns (bool);\\n}\\n\\nabstract contract DssVest {\\n\\n    uint256 public   constant  TWENTY_YEARS = 20 * 365 days;\\n\\n    uint256 internal locked;\\n\\n    event Rely(address indexed usr);\\n    event Deny(address indexed usr);\\n    event Init(uint256 indexed id, address indexed usr);\\n    event Vest(uint256 indexed id, uint256 amt);\\n    event Move(uint256 indexed id, address indexed dst);\\n    event File(bytes32 indexed what, uint256 data);\\n    event Yank(uint256 indexed id, uint256 end);\\n    event Restrict(uint256 indexed id);\\n    event Unrestrict(uint256 indexed id);\\n    event Bless(uint256 indexed id);\\n    event Unbless(uint256 indexed id);\\n\\n\\n    // --- Auth ---\\n    mapping (address => uint256) public wards;\\n    function rely(address _usr) external auth { wards[_usr] = 1; emit Rely(_usr); }\\n    function deny(address _usr) external auth { wards[_usr] = 0; emit Deny(_usr); }\\n    modifier auth {\\n        require(wards[msg.sender] == 1, \\\"DssVest/not-authorized\\\");\\n        _;\\n    }\\n\\n    // --- Mutex  ---\\n    modifier lock {\\n        require(locked == 0, \\\"DssVest/system-locked\\\");\\n        locked = 1;\\n        _;\\n        locked = 0;\\n    }\\n\\n    struct Award {\\n        address usr;   // Vesting recipient\\n        uint48  bgn;   // Start of vesting period  [timestamp]\\n        uint48  clf;   // The cliff date           [timestamp]\\n        uint48  fin;   // End of vesting period    [timestamp]\\n        address mgr;   // A manager address that can yank\\n        uint8   res;   // Restricted\\n        uint128 tot;   // Total reward amount\\n        uint128 rxd;   // Amount of vest claimed\\n        uint8   bls;   // Blessed (uninterruptible)\\n    }\\n    mapping (uint256 => Award) public awards;\\n    uint256 public ids;\\n\\n    uint256 public cap; // Maximum per-second issuance token rate\\n\\n    // Getters to access only to the value desired\\n    function usr(uint256 _id) external view returns (address) {\\n        return awards[_id].usr;\\n    }\\n\\n    function bgn(uint256 _id) external view returns (uint256) {\\n        return awards[_id].bgn;\\n    }\\n\\n    function clf(uint256 _id) external view returns (uint256) {\\n        return awards[_id].clf;\\n    }\\n\\n    function fin(uint256 _id) external view returns (uint256) {\\n        return awards[_id].fin;\\n    }\\n\\n    function mgr(uint256 _id) external view returns (address) {\\n        return awards[_id].mgr;\\n    }\\n\\n    function res(uint256 _id) external view returns (uint256) {\\n        return awards[_id].res;\\n    }\\n\\n    function tot(uint256 _id) external view returns (uint256) {\\n        return awards[_id].tot;\\n    }\\n\\n    function rxd(uint256 _id) external view returns (uint256) {\\n        return awards[_id].rxd;\\n    }\\n\\n    function bls(uint256 _id) external view returns (uint256) {\\n        return awards[_id].bls;\\n    }\\n\\n    /**\\n        @dev Base vesting logic contract constructor\\n    */\\n    constructor() {\\n        wards[msg.sender] = 1;\\n        emit Rely(msg.sender);\\n    }\\n\\n    /**\\n        @dev (Required) Set the per-second token issuance rate.\\n        @param what  The tag of the value to change (ex. bytes32(\\\"cap\\\"))\\n        @param data  The value to update (ex. cap of 1000 tokens/yr == 1000*WAD/365 days)\\n    */\\n    function file(bytes32 what, uint256 data) external auth lock {\\n        if      (what == \\\"cap\\\")         cap = data;     // The maximum amount of tokens that can be streamed per-second per vest\\n        else revert(\\\"DssVest/file-unrecognized-param\\\");\\n        emit File(what, data);\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x > y ? y : x;\\n    }\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"DssVest/add-overflow\\\");\\n    }\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"DssVest/sub-underflow\\\");\\n    }\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"DssVest/mul-overflow\\\");\\n    }\\n    function toUint48(uint256 x) internal pure returns (uint48 z) {\\n        require((z = uint48(x)) == x, \\\"DssVest/uint48-overflow\\\");\\n    }\\n    function toUint128(uint256 x) internal pure returns (uint128 z) {\\n        require((z = uint128(x)) == x, \\\"DssVest/uint128-overflow\\\");\\n    }\\n\\n    /**\\n        @dev Govanance adds a vesting contract\\n        @param _usr The recipient of the reward\\n        @param _tot The total amount of the vest\\n        @param _bgn The starting timestamp of the vest\\n        @param _tau The duration of the vest (in seconds)\\n        @param _eta The cliff duration in seconds (i.e. 1 years)\\n        @param _mgr An optional manager for the contract. Can yank if vesting ends prematurely.\\n        @return id  The id of the vesting contract\\n    */\\n    function _create(address _usr, uint256 _tot, uint256 _bgn, uint256 _tau, uint256 _eta, address _mgr) internal auth lock returns (uint256 id) {\\n        require(_usr != address(0),                        \\\"DssVest/invalid-user\\\");\\n        require(_tot > 0,                                  \\\"DssVest/no-vest-total-amount\\\");\\n        require(_bgn < add(block.timestamp, TWENTY_YEARS), \\\"DssVest/bgn-too-far\\\");\\n        require(_bgn > sub(block.timestamp, TWENTY_YEARS), \\\"DssVest/bgn-too-long-ago\\\");\\n        require(_tau > 0,                                  \\\"DssVest/tau-zero\\\");\\n        require(_tot / _tau <= cap,                        \\\"DssVest/rate-too-high\\\");\\n        require(_tau <= TWENTY_YEARS,                      \\\"DssVest/tau-too-long\\\");\\n        require(_eta <= _tau,                              \\\"DssVest/eta-too-long\\\");\\n        require(ids < type(uint256).max,                   \\\"DssVest/ids-overflow\\\");\\n\\n        id = ++ids;\\n        awards[id] = Award({\\n            usr: _usr,\\n            bgn: toUint48(_bgn),\\n            clf: toUint48(add(_bgn, _eta)),\\n            fin: toUint48(add(_bgn, _tau)),\\n            tot: toUint128(_tot),\\n            rxd: 0,\\n            mgr: _mgr,\\n            res: 0,\\n            bls: 0\\n        });\\n        emit Init(id, _usr);\\n    }\\n\\n    /**\\n        @dev Govanance adds a vesting contract\\n        @param _usr The recipient of the reward\\n        @param _tot The total amount of the vest\\n        @param _bgn The starting timestamp of the vest\\n        @param _tau The duration of the vest (in seconds)\\n        @param _eta The cliff duration in seconds (i.e. 1 years)\\n        @param _mgr An optional manager for the contract. Can yank if vesting ends prematurely.\\n        @return id  The id of the vesting contract\\n    */\\n    function create(address _usr, uint256 _tot, uint256 _bgn, uint256 _tau, uint256 _eta, address _mgr) external returns (uint256 id) {\\n        return _create(_usr,_tot,_bgn,_tau,_eta,_mgr);\\n    }\\n\\n    /**\\n        @dev Govanance adds a vesting contract with all options customizable\\n        @param _usr The recipient of the reward\\n        @param _tot The total amount of the vest\\n        @param _bgn The starting timestamp of the vest\\n        @param _tau The duration of the vest (in seconds)\\n        @param _eta The cliff duration in seconds (i.e. 1 years)\\n        @param _mgr An optional manager for the contract. Can yank if vesting ends prematurely.\\n        @param _res Whether the vesting can be claimed by the usr only\\n        @param _bls Whether the vesting is uninterruptible\\n        @return id  The id of the vesting contract\\n    */\\n    function create_custom(address _usr, uint256 _tot, uint256 _bgn, uint256 _tau, uint256 _eta, address _mgr, bool _res, bool _bls) external returns (uint256 id) {\\n        id = _create(_usr,_tot,_bgn,_tau,_eta,_mgr);\\n        if (_res) { _restrict(id); }\\n        if (_bls) { _bless(id); }\\n        return id;\\n    }\\n\\n    /**\\n        @dev Anyone (or only owner of a vesting contract if restricted) calls this to claim all available rewards\\n        @param _id     The id of the vesting contract\\n    */\\n    function vest(uint256 _id) external {\\n        _vest(_id, type(uint256).max);\\n    }\\n\\n    /**\\n        @dev Anyone (or only owner of a vesting contract if restricted) calls this to claim rewards\\n        @param _id     The id of the vesting contract\\n        @param _maxAmt The maximum amount to vest\\n    */\\n    function vest(uint256 _id, uint256 _maxAmt) external {\\n        _vest(_id, _maxAmt);\\n    }\\n\\n    /**\\n        @dev Anyone (or only owner of a vesting contract if restricted) calls this to claim rewards\\n        @param _id     The id of the vesting contract\\n        @param _maxAmt The maximum amount to vest\\n    */\\n    function _vest(uint256 _id, uint256 _maxAmt) internal lock {\\n        Award memory _award = awards[_id];\\n        require(_award.usr != address(0), \\\"DssVest/invalid-award\\\");\\n        require(_award.res == 0 || _award.usr == msg.sender, \\\"DssVest/only-user-can-claim\\\");\\n        uint256 amt = unpaid(block.timestamp, _award.bgn, _award.clf, _award.fin, _award.tot, _award.rxd);\\n        amt = min(amt, _maxAmt);\\n        awards[_id].rxd = toUint128(add(_award.rxd, amt));\\n        pay(_award.usr, amt);\\n        emit Vest(_id, amt);\\n    }\\n\\n    /**\\n        @dev amount of tokens accrued, not accounting for tokens paid\\n        @param _id  The id of the vesting contract\\n        @return amt The accrued amount\\n    */\\n    function accrued(uint256 _id) external view returns (uint256 amt) {\\n        Award memory _award = awards[_id];\\n        require(_award.usr != address(0), \\\"DssVest/invalid-award\\\");\\n        amt = accrued(block.timestamp, _award.bgn, _award.fin, _award.tot);\\n    }\\n\\n    /**\\n        @dev amount of tokens accrued, not accounting for tokens paid\\n        @param _time The timestamp to perform the calculation\\n        @param _bgn  The start time of the contract\\n        @param _fin  The end time of the contract\\n        @param _tot  The total amount of the contract\\n        @return amt  The accrued amount\\n    */\\n    function accrued(uint256 _time, uint48 _bgn, uint48 _fin, uint128 _tot) internal pure returns (uint256 amt) {\\n        if (_time < _bgn) {\\n            amt = 0;\\n        } else if (_time >= _fin) {\\n            amt = _tot;\\n        } else {\\n            amt = mul(_tot, sub(_time, _bgn)) / sub(_fin, _bgn); // 0 <= amt < _award.tot\\n        }\\n    }\\n\\n    /**\\n        @dev return the amount of vested, claimable GEM for a given ID\\n        @param _id  The id of the vesting contract\\n        @return amt The claimable amount\\n    */\\n    function unpaid(uint256 _id) external view returns (uint256 amt) {\\n        Award memory _award = awards[_id];\\n        require(_award.usr != address(0), \\\"DssVest/invalid-award\\\");\\n        amt = unpaid(block.timestamp, _award.bgn, _award.clf, _award.fin, _award.tot, _award.rxd);\\n    }\\n\\n    /**\\n        @dev amount of tokens accrued, not accounting for tokens paid\\n        @param _time The timestamp to perform the calculation\\n        @param _bgn  The start time of the contract\\n        @param _clf  The timestamp of the cliff\\n        @param _fin  The end time of the contract\\n        @param _tot  The total amount of the contract\\n        @param _rxd  The number of gems received\\n        @return amt  The claimable amount\\n    */\\n    function unpaid(uint256 _time, uint48 _bgn, uint48 _clf, uint48 _fin, uint128 _tot, uint128 _rxd) internal pure returns (uint256 amt) {\\n        amt = _time < _clf ? 0 : sub(accrued(_time, _bgn, _fin, _tot), _rxd);\\n    }\\n\\n    /**\\n        @dev Allows governance or the owner to restrict vesting to the owner only\\n        @param _id The id of the vesting contract\\n    */\\n    function _restrict(uint256 _id) internal lock {\\n        address usr_ = awards[_id].usr;\\n        require(usr_ != address(0), \\\"DssVest/invalid-award\\\");\\n        require(wards[msg.sender] == 1 || usr_ == msg.sender, \\\"DssVest/not-authorized\\\");\\n        awards[_id].res = 1;\\n        emit Restrict(_id);\\n    }\\n\\n    /**\\n        @dev Allows governance or the owner to restrict vesting to the owner only\\n        @param _id The id of the vesting contract\\n    */\\n    function restrict(uint256 _id) external {\\n        _restrict(_id);\\n    }\\n\\n    /**\\n        @dev Make vesting uninterruptible\\n        @param _id The id of the vesting contract\\n    */\\n    function _bless(uint256 _id) internal lock {\\n        address usr_ = awards[_id].usr;\\n        require(usr_ != address(0), \\\"DssVest/invalid-award\\\");\\n        require(wards[msg.sender] == 1, \\\"DssVest/not-authorized\\\");\\n        awards[_id].bls = 1;\\n        emit Bless(_id);\\n    }\\n\\n    /**\\n        @dev Make vesting uninterruptible\\n        @param _id The id of the vesting contract\\n    */\\n    function bless(uint256 _id) external {\\n        _bless(_id);\\n    }\\n\\n    /**\\n        @dev Make vesting interruptible\\n        @param _id The id of the vesting contract\\n    */\\n    function unbless(uint256 _id) external lock {\\n        address usr_ = awards[_id].usr;\\n        require(usr_ != address(0), \\\"DssVest/invalid-award\\\");\\n        require(wards[msg.sender] == 1, \\\"DssVest/not-authorized\\\");\\n        awards[_id].bls = 0;\\n        emit Unbless(_id);\\n    }\\n\\n    /**\\n        @dev Allows governance or the owner to enable permissionless vesting\\n        @param _id The id of the vesting contract\\n    */\\n    function unrestrict(uint256 _id) external lock {\\n        address usr_ = awards[_id].usr;\\n        require(usr_ != address(0), \\\"DssVest/invalid-award\\\");\\n        require(wards[msg.sender] == 1 || usr_ == msg.sender, \\\"DssVest/not-authorized\\\");\\n        awards[_id].res = 0;\\n        emit Unrestrict(_id);\\n    }\\n\\n    /**\\n        @dev Allows governance or the manager to remove a vesting contract immediately\\n        @param _id The id of the vesting contract\\n    */\\n    function yank(uint256 _id) external {\\n        _yank(_id, block.timestamp);\\n    }\\n\\n    /**\\n        @dev Allows governance or the manager to remove a vesting contract at a future time\\n        @param _id  The id of the vesting contract\\n        @param _end A scheduled time to end the vest\\n    */\\n    function yank(uint256 _id, uint256 _end) external {\\n        _yank(_id, _end);\\n    }\\n\\n    /**\\n        @dev Allows governance or the manager to end pre-maturely a vesting contract\\n        @param _id  The id of the vesting contract\\n        @param _end A scheduled time to end the vest\\n    */\\n    function _yank(uint256 _id, uint256 _end) internal lock {\\n        require(wards[msg.sender] == 1 || awards[_id].mgr == msg.sender, \\\"DssVest/not-authorized\\\");\\n        Award memory _award = awards[_id];\\n        require(_award.usr != address(0), \\\"DssVest/invalid-award\\\");\\n        require(_award.bls == 0, \\\"DssVest/no-yanking-blessed\\\");\\n        if (_end < block.timestamp) {\\n            _end = block.timestamp;\\n        }\\n        if (_end < _award.fin) {\\n            uint48 end = toUint48(_end);\\n            awards[_id].fin = end;\\n            if (end < _award.bgn) {\\n                awards[_id].bgn = end;\\n                awards[_id].clf = end;\\n                awards[_id].tot = 0;\\n            } else if (end < _award.clf) {\\n                awards[_id].clf = end;\\n                awards[_id].tot = 0;\\n            } else {\\n                awards[_id].tot = toUint128(\\n                                    add(\\n                                        unpaid(_end, _award.bgn, _award.clf, _award.fin, _award.tot, _award.rxd),\\n                                        _award.rxd\\n                                    )\\n                                );\\n            }\\n        }\\n\\n        emit Yank(_id, _end);\\n    }\\n\\n    /**\\n        @dev Allows owner to move a contract to a different address\\n        @param _id  The id of the vesting contract\\n        @param _dst The address to send ownership of the contract to\\n    */\\n    function move(uint256 _id, address _dst) external lock {\\n        require(awards[_id].usr == msg.sender, \\\"DssVest/only-user-can-move\\\");\\n        require(_dst != address(0), \\\"DssVest/zero-address-invalid\\\");\\n        awards[_id].usr = _dst;\\n        emit Move(_id, _dst);\\n    }\\n\\n    /**\\n        @dev Return true if a contract is valid\\n        @param _id The id of the vesting contract\\n        @return isValid True for valid contract\\n    */\\n    function valid(uint256 _id) external view returns (bool isValid) {\\n        isValid = awards[_id].rxd < awards[_id].tot;\\n    }\\n\\n    /**\\n        @dev Override this to implement payment logic.\\n        @param _guy The payment target.\\n        @param _amt The payment amount. [units are implementation-specific]\\n    */\\n    function pay(address _guy, uint256 _amt) virtual internal;\\n}\\n\\ncontract DssVestMintable is DssVest {\\n\\n    MintLike public immutable gem;\\n\\n    /**\\n        @dev This contract must be authorized to 'mint' on the token\\n        @param _gem The contract address of the mintable token\\n    */\\n    constructor(address _gem) DssVest() {\\n        require(_gem != address(0), \\\"DssVest/Invalid-token-address\\\");\\n        gem = MintLike(_gem);\\n    }\\n\\n    /**\\n        @dev Override pay to handle mint logic\\n        @param _guy The recipient of the minted token\\n        @param _amt The amount of token units to send to the _guy\\n    */\\n    function pay(address _guy, uint256 _amt) override internal {\\n        gem.mint(_guy, _amt);\\n    }\\n}\\n\\ncontract DssVestSuckable is DssVest {\\n\\n    uint256 internal constant RAY = 10**27;\\n\\n    ChainlogLike public immutable chainlog;\\n    VatLike      public immutable vat;\\n    DaiJoinLike  public immutable daiJoin;\\n\\n    /**\\n        @dev This contract must be authorized to 'suck' on the vat\\n        @param _chainlog The contract address of the MCD chainlog\\n    */\\n    constructor(address _chainlog) DssVest() {\\n        require(_chainlog != address(0), \\\"DssVest/Invalid-chainlog-address\\\");\\n        ChainlogLike chainlog_ = chainlog = ChainlogLike(_chainlog);\\n        VatLike vat_ = vat = VatLike(chainlog_.getAddress(\\\"MCD_VAT\\\"));\\n        DaiJoinLike daiJoin_ = daiJoin = DaiJoinLike(chainlog_.getAddress(\\\"MCD_JOIN_DAI\\\"));\\n\\n        vat_.hope(address(daiJoin_));\\n    }\\n\\n    /**\\n        @dev Override pay to handle suck logic\\n        @param _guy The recipient of the ERC-20 Dai\\n        @param _amt The amount of Dai to send to the _guy [WAD]\\n    */\\n    function pay(address _guy, uint256 _amt) override internal {\\n        vat.suck(chainlog.getAddress(\\\"MCD_VOW\\\"), address(this), mul(_amt, RAY));\\n        daiJoin.exit(_guy, _amt);\\n    }\\n}\\n\\n/*\\n    Transferrable token DssVest. Can be used to enable streaming payments of\\n     any arbitrary token from an address (i.e. CU multisig) to individual\\n     contributors.\\n*/\\ncontract DssVestTransferrable is DssVest {\\n\\n    address   public immutable czar;\\n    TokenLike public immutable gem;\\n\\n    /**\\n        @dev This contract must be approved for transfer of the gem on the czar\\n        @param _czar The owner of the tokens to be distributed\\n        @param _gem  The token to be distributed\\n    */\\n    constructor(address _czar, address _gem) DssVest() {\\n        require(_czar != address(0), \\\"DssVest/Invalid-distributor-address\\\");\\n        require(_gem  != address(0), \\\"DssVest/Invalid-token-address\\\");\\n        czar = _czar;\\n        gem  = TokenLike(_gem);\\n    }\\n\\n    /**\\n        @dev Override pay to handle transfer logic\\n        @param _guy The recipient of the ERC-20 Dai\\n        @param _amt The amount of gem to send to the _guy (in native token units)\\n    */\\n    function pay(address _guy, uint256 _amt) override internal {\\n        require(gem.transferFrom(czar, _guy, _amt));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/dss-vest/lib/ds-test/src/\",\r\n      \"dss-vest/=lib/dss-vest/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"semitransferable-token/=lib/semitransferable-token/src/\",\r\n      \"solmate/=lib/semitransferable-token/lib/solmate/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\",\r\n      \"script/=script/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_czar\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gem\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Bless\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Deny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"File\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Init\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"Move\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Rely\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Restrict\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Unbless\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Unrestrict\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Vest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"Yank\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TWENTY_YEARS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"accrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"awards\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"bgn\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"clf\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"fin\",\"type\":\"uint48\"},{\"internalType\":\"address\",\"name\":\"mgr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"res\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"tot\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rxd\",\"type\":\"uint128\"},{\"internalType\":\"uint8\",\"name\":\"bls\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"bgn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"bless\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"bls\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"clf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bgn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tau\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_eta\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_mgr\",\"type\":\"address\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bgn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tau\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_eta\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_mgr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_res\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_bls\",\"type\":\"bool\"}],\"name\":\"create_custom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"czar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"file\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"fin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gem\",\"outputs\":[{\"internalType\":\"contract TokenLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ids\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"mgr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"}],\"name\":\"move\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"res\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"restrict\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"rxd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"tot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"unbless\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"unpaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"unrestrict\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"usr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"valid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"vest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmt\",\"type\":\"uint256\"}],\"name\":\"vest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"yank\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"yank\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Vester", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006abfd6139c7c3cc270ee2ce132e309f59caaf6a20000000000000000000000009994e35db50125e0df82e4c2dde62496ce330999", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}