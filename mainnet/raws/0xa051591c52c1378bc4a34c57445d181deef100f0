{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.8.4;\r\n\r\n/// @notice Modern and gas-optimized ERC-20 + EIP-2612 implementation with COMP-style governance and pausing.\r\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/erc20/ERC20.sol)\r\n/// License-Identifier: AGPL-3.0-only\r\nabstract contract KaliDAOtoken {\r\n    /*///////////////////////////////////////////////////////////////\r\n                            EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\r\n\r\n    event PauseFlipped(bool paused);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERRORS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    error NoArrayParity();\r\n\r\n    error Paused();\r\n\r\n    error SignatureExpired();\r\n\r\n    error NullAddress();\r\n\r\n    error InvalidNonce();\r\n\r\n    error NotDetermined();\r\n\r\n    error InvalidSignature();\r\n\r\n    error Uint32max();\r\n\r\n    error Uint96max();\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public constant decimals = 18;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERC-20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\r\n\r\n    uint256 internal INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            DAO STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    bool public paused;\r\n\r\n    bytes32 public constant DELEGATION_TYPEHASH = \r\n        keccak256('Delegation(address delegatee,uint256 nonce,uint256 deadline)');\r\n\r\n    mapping(address => address) internal _delegates;\r\n\r\n    mapping(address => mapping(uint256 => Checkpoint)) public checkpoints;\r\n\r\n    mapping(address => uint256) public numCheckpoints;\r\n\r\n    struct Checkpoint {\r\n        uint32 fromTimestamp;\r\n        uint96 votes;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _init(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        bool paused_,\r\n        address[] memory voters_,\r\n        uint256[] memory shares_\r\n    ) internal virtual {\r\n        if (voters_.length != shares_.length) revert NoArrayParity();\r\n\r\n        name = name_;\r\n        \r\n        symbol = symbol_;\r\n        \r\n        paused = paused_;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        \r\n        INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\r\n        \r\n        // cannot realistically overflow on human timescales\r\n        unchecked {\r\n            for (uint256 i; i < voters_.length; i++) {\r\n                _mint(voters_[i], shares_[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERC-20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public notPaused virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n        \r\n        _moveDelegates(delegates(msg.sender), delegates(to), amount);\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public notPaused virtual returns (bool) {\r\n        if (allowance[from][msg.sender] != type(uint256).max) \r\n            allowance[from][msg.sender] -= amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n        \r\n        _moveDelegates(delegates(from), delegates(to), amount);\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n    \r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        if (block.timestamp > deadline) revert SignatureExpired();\r\n\r\n        // cannot realistically overflow on human timescales\r\n        unchecked {\r\n            bytes32 digest = keccak256(\r\n                abi.encodePacked(\r\n                    '\\x19\\x01',\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n                )\r\n            );\r\n\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n\r\n            if (recoveredAddress == address(0) || recoveredAddress != owner) revert InvalidSignature();\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : _computeDomainSeparator();\r\n    }\r\n\r\n    function _computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return \r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                    keccak256(bytes(name)),\r\n                    keccak256('1'),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            DAO LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    modifier notPaused() {\r\n        if (paused) revert Paused();\r\n\r\n        _;\r\n    }\r\n    \r\n    function delegates(address delegator) public view virtual returns (address) {\r\n        address current = _delegates[delegator];\r\n        \r\n        return current == address(0) ? delegator : current;\r\n    }\r\n\r\n    function getCurrentVotes(address account) public view virtual returns (uint256) {\r\n        // this is safe from underflow because decrement only occurs if `nCheckpoints` is positive\r\n        unchecked {\r\n            uint256 nCheckpoints = numCheckpoints[account];\r\n\r\n            return nCheckpoints != 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n        }\r\n    }\r\n\r\n    function delegate(address delegatee) public virtual {\r\n        _delegate(msg.sender, delegatee);\r\n    }\r\n\r\n    function delegateBySig(\r\n        address delegatee, \r\n        uint256 nonce, \r\n        uint256 deadline, \r\n        uint8 v, \r\n        bytes32 r, \r\n        bytes32 s\r\n    ) public virtual {\r\n        if (block.timestamp > deadline) revert SignatureExpired();\r\n\r\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, deadline));\r\n\r\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', DOMAIN_SEPARATOR(), structHash));\r\n\r\n        address signatory = ecrecover(digest, v, r, s);\r\n\r\n        if (signatory == address(0)) revert NullAddress();\r\n        \r\n        // cannot realistically overflow on human timescales\r\n        unchecked {\r\n            if (nonce != nonces[signatory]++) revert InvalidNonce();\r\n        }\r\n\r\n        _delegate(signatory, delegatee);\r\n    }\r\n\r\n    function getPriorVotes(address account, uint256 timestamp) public view virtual returns (uint96) {\r\n        if (block.timestamp <= timestamp) revert NotDetermined();\r\n\r\n        uint256 nCheckpoints = numCheckpoints[account];\r\n\r\n        if (nCheckpoints == 0) return 0;\r\n        \r\n        // this is safe from underflow because decrement only occurs if `nCheckpoints` is positive\r\n        unchecked {\r\n            if (checkpoints[account][nCheckpoints - 1].fromTimestamp <= timestamp)\r\n                return checkpoints[account][nCheckpoints - 1].votes;\r\n\r\n            if (checkpoints[account][0].fromTimestamp > timestamp) return 0;\r\n\r\n            uint256 lower;\r\n            \r\n            // this is safe from underflow because decrement only occurs if `nCheckpoints` is positive\r\n            uint256 upper = nCheckpoints - 1;\r\n\r\n            while (upper > lower) {\r\n                // this is safe from underflow because `upper` ceiling is provided\r\n                uint256 center = upper - (upper - lower) / 2;\r\n\r\n                Checkpoint memory cp = checkpoints[account][center];\r\n\r\n                if (cp.fromTimestamp == timestamp) {\r\n                    return cp.votes;\r\n                } else if (cp.fromTimestamp < timestamp) {\r\n                    lower = center;\r\n                } else {\r\n                    upper = center - 1;\r\n                }\r\n            }\r\n\r\n        return checkpoints[account][lower].votes;\r\n\r\n        }\r\n    }\r\n\r\n    function _delegate(address delegator, address delegatee) internal virtual {\r\n        address currentDelegate = delegates(delegator);\r\n\r\n        _delegates[delegator] = delegatee;\r\n\r\n        _moveDelegates(currentDelegate, delegatee, balanceOf[delegator]);\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n    }\r\n\r\n    function _moveDelegates(\r\n        address srcRep, \r\n        address dstRep, \r\n        uint256 amount\r\n    ) internal virtual {\r\n        if (srcRep != dstRep && amount != 0) \r\n            if (srcRep != address(0)) {\r\n                uint256 srcRepNum = numCheckpoints[srcRep];\r\n                \r\n                uint256 srcRepOld = srcRepNum != 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n\r\n                uint256 srcRepNew = srcRepOld - amount;\r\n\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n            \r\n            if (dstRep != address(0)) {\r\n                uint256 dstRepNum = numCheckpoints[dstRep];\r\n\r\n                uint256 dstRepOld = dstRepNum != 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n\r\n                uint256 dstRepNew = dstRepOld + amount;\r\n\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }\r\n    }\r\n\r\n    function _writeCheckpoint(\r\n        address delegatee, \r\n        uint256 nCheckpoints, \r\n        uint256 oldVotes, \r\n        uint256 newVotes\r\n    ) internal virtual {\r\n        unchecked {\r\n            // this is safe from underflow because decrement only occurs if `nCheckpoints` is positive\r\n            if (nCheckpoints != 0 && checkpoints[delegatee][nCheckpoints - 1].fromTimestamp == block.timestamp) {\r\n                checkpoints[delegatee][nCheckpoints - 1].votes = _safeCastTo96(newVotes);\r\n            } else {\r\n                checkpoints[delegatee][nCheckpoints] = Checkpoint(_safeCastTo32(block.timestamp), _safeCastTo96(newVotes));\r\n                \r\n                // cannot realistically overflow on human timescales\r\n                numCheckpoints[delegatee] = nCheckpoints + 1;\r\n            }\r\n        }\r\n\r\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n\r\n        // cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        _moveDelegates(address(0), delegates(to), amount);\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n\r\n        // cannot underflow because a user's balance\r\n        // will never be larger than the total supply\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        _moveDelegates(delegates(from), address(0), amount);\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n    \r\n    function burn(uint256 amount) public virtual {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    function burnFrom(address from, uint256 amount) public virtual {\r\n        if (allowance[from][msg.sender] != type(uint256).max) \r\n            allowance[from][msg.sender] -= amount;\r\n\r\n        _burn(from, amount);\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            PAUSE LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _flipPause() internal virtual {\r\n        paused = !paused;\r\n\r\n        emit PauseFlipped(paused);\r\n    }\r\n    \r\n    /*///////////////////////////////////////////////////////////////\r\n                            SAFECAST LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n    \r\n    function _safeCastTo32(uint256 x) internal pure virtual returns (uint32) {\r\n        if (x > type(uint32).max) revert Uint32max();\r\n\r\n        return uint32(x);\r\n    }\r\n    \r\n    function _safeCastTo96(uint256 x) internal pure virtual returns (uint96) {\r\n        if (x > type(uint96).max) revert Uint96max();\r\n\r\n        return uint96(x);\r\n    }\r\n}\r\n\r\n/// @notice Helper utility that enables calling multiple local methods in a single call.\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol)\r\nabstract contract Multicall {\r\n    function multicall(bytes[] calldata data) public virtual returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        \r\n        // cannot realistically overflow on human timescales\r\n        unchecked {\r\n            for (uint256 i = 0; i < data.length; i++) {\r\n                (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n\r\n                if (!success) {\r\n                    if (result.length < 68) revert();\r\n                    \r\n                    assembly {\r\n                        result := add(result, 0x04)\r\n                    }\r\n                    \r\n                    revert(abi.decode(result, (string)));\r\n                }\r\n                results[i] = result;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Helper utility for NFT 'safe' transfers.\r\nabstract contract NFThelper {\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external pure returns (bytes4 sig) {\r\n        sig = 0x150b7a02; // 'onERC721Received(address,address,uint256,bytes)'\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes calldata\r\n    ) external pure returns (bytes4 sig) {\r\n        sig = 0xf23a6e61; // 'onERC1155Received(address,address,uint256,uint256,bytes)'\r\n    }\r\n    \r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] calldata,\r\n        uint256[] calldata,\r\n        bytes calldata\r\n    ) external pure returns (bytes4 sig) {\r\n        sig = 0xbc197c81; // 'onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)'\r\n    }\r\n}\r\n\r\n/// @notice Gas-optimized reentrancy protection.\r\n/// @author Modified from OpenZeppelin \r\n/// (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\r\n/// License-Identifier: MIT\r\nabstract contract ReentrancyGuard {\r\n    error Reentrancy();\r\n\r\n    uint256 private constant NOT_ENTERED = 1;\r\n\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private status = NOT_ENTERED;\r\n\r\n    modifier nonReentrant() {\r\n        if (status == ENTERED) revert Reentrancy();\r\n\r\n        status = ENTERED;\r\n\r\n        _;\r\n\r\n        status = NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/// @notice Kali DAO membership extension interface.\r\ninterface IKaliDAOextension {\r\n    function setExtension(bytes calldata extensionData) external;\r\n\r\n    function callExtension(\r\n        address account, \r\n        uint256 amount, \r\n        bytes calldata extensionData\r\n    ) external payable returns (bool mint, uint256 amountOut);\r\n}\r\n\r\n/// @notice Simple gas-optimized Kali DAO core module.\r\ncontract KaliDAO is KaliDAOtoken, Multicall, NFThelper, ReentrancyGuard {\r\n    /*///////////////////////////////////////////////////////////////\r\n                            EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event NewProposal(\r\n        address indexed proposer, \r\n        uint256 indexed proposal, \r\n        ProposalType indexed proposalType, \r\n        string description, \r\n        address[] accounts, \r\n        uint256[] amounts, \r\n        bytes[] payloads\r\n    );\r\n\r\n    event ProposalCancelled(address indexed proposer, uint256 indexed proposal);\r\n\r\n    event ProposalSponsored(address indexed sponsor, uint256 indexed proposal);\r\n    \r\n    event VoteCast(address indexed voter, uint256 indexed proposal, bool indexed approve);\r\n\r\n    event ProposalProcessed(uint256 indexed proposal, bool indexed didProposalPass);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERRORS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    error Initialized();\r\n\r\n    error PeriodBounds();\r\n\r\n    error QuorumMax();\r\n\r\n    error SupermajorityBounds();\r\n\r\n    error InitCallFail();\r\n\r\n    error TypeBounds();\r\n\r\n    error NotProposer();\r\n\r\n    error Sponsored();\r\n\r\n    error NotMember();\r\n\r\n    error NotCurrentProposal();\r\n\r\n    error AlreadyVoted();\r\n\r\n    error NotVoteable();\r\n\r\n    error VotingNotEnded();\r\n\r\n    error PrevNotProcessed();\r\n\r\n    error NotExtension();\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            DAO STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public docs;\r\n\r\n    uint256 private currentSponsoredProposal;\r\n    \r\n    uint256 public proposalCount;\r\n\r\n    uint32 public votingPeriod;\r\n\r\n    uint32 public gracePeriod;\r\n\r\n    uint32 public quorum; // 1-100\r\n\r\n    uint32 public supermajority; // 1-100\r\n    \r\n    bytes32 public constant VOTE_HASH = \r\n        keccak256('SignVote(address signer,uint256 proposal,bool approve)');\r\n    \r\n    mapping(address => bool) public extensions;\r\n\r\n    mapping(uint256 => Proposal) public proposals;\r\n\r\n    mapping(uint256 => ProposalState) public proposalStates;\r\n\r\n    mapping(ProposalType => VoteType) public proposalVoteTypes;\r\n    \r\n    mapping(uint256 => mapping(address => bool)) public voted;\r\n\r\n    mapping(address => uint256) public lastYesVote;\r\n\r\n    enum ProposalType {\r\n        MINT, // add membership\r\n        BURN, // revoke membership\r\n        CALL, // call contracts\r\n        VPERIOD, // set `votingPeriod`\r\n        GPERIOD, // set `gracePeriod`\r\n        QUORUM, // set `quorum`\r\n        SUPERMAJORITY, // set `supermajority`\r\n        TYPE, // set `VoteType` to `ProposalType`\r\n        PAUSE, // flip membership transferability\r\n        EXTENSION, // flip `extensions` whitelisting\r\n        ESCAPE, // delete pending proposal in case of revert\r\n        DOCS // amend org docs\r\n    }\r\n\r\n    enum VoteType {\r\n        SIMPLE_MAJORITY,\r\n        SIMPLE_MAJORITY_QUORUM_REQUIRED,\r\n        SUPERMAJORITY,\r\n        SUPERMAJORITY_QUORUM_REQUIRED\r\n    }\r\n\r\n    struct Proposal {\r\n        ProposalType proposalType;\r\n        string description;\r\n        address[] accounts; // member(s) being added/kicked; account(s) receiving payload\r\n        uint256[] amounts; // value(s) to be minted/burned/spent; gov setting [0]\r\n        bytes[] payloads; // data for CALL proposals\r\n        uint256 prevProposal;\r\n        uint96 yesVotes;\r\n        uint96 noVotes;\r\n        uint32 creationTime;\r\n        address proposer;\r\n    }\r\n\r\n    struct ProposalState {\r\n        bool passed;\r\n        bool processed;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function init(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        string memory docs_,\r\n        bool paused_,\r\n        address[] memory extensions_,\r\n        bytes[] memory extensionsData_,\r\n        address[] calldata voters_,\r\n        uint256[] calldata shares_,\r\n        uint32[16] memory govSettings_\r\n    ) public nonReentrant virtual {\r\n        if (extensions_.length != extensionsData_.length) revert NoArrayParity();\r\n\r\n        if (votingPeriod != 0) revert Initialized();\r\n\r\n        if (govSettings_[0] == 0 || govSettings_[0] > 365 days) revert PeriodBounds();\r\n\r\n        if (govSettings_[1] > 365 days) revert PeriodBounds();\r\n\r\n        if (govSettings_[2] > 100) revert QuorumMax();\r\n\r\n        if (govSettings_[3] <= 51 || govSettings_[3] > 100) revert SupermajorityBounds();\r\n\r\n        KaliDAOtoken._init(name_, symbol_, paused_, voters_, shares_);\r\n\r\n        if (extensions_.length != 0) {\r\n            // cannot realistically overflow on human timescales\r\n            unchecked {\r\n                for (uint256 i; i < extensions_.length; i++) {\r\n                    extensions[extensions_[i]] = true;\r\n\r\n                    if (extensionsData_[i].length > 3) {\r\n                        (bool success, ) = extensions_[i].call(extensionsData_[i]);\r\n\r\n                        if (!success) revert InitCallFail();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        docs = docs_;\r\n        \r\n        votingPeriod = govSettings_[0];\r\n\r\n        gracePeriod = govSettings_[1];\r\n        \r\n        quorum = govSettings_[2];\r\n        \r\n        supermajority = govSettings_[3];\r\n\r\n        // set initial vote types\r\n        proposalVoteTypes[ProposalType.MINT] = VoteType(govSettings_[4]);\r\n\r\n        proposalVoteTypes[ProposalType.BURN] = VoteType(govSettings_[5]);\r\n\r\n        proposalVoteTypes[ProposalType.CALL] = VoteType(govSettings_[6]);\r\n\r\n        proposalVoteTypes[ProposalType.VPERIOD] = VoteType(govSettings_[7]);\r\n\r\n        proposalVoteTypes[ProposalType.GPERIOD] = VoteType(govSettings_[8]);\r\n        \r\n        proposalVoteTypes[ProposalType.QUORUM] = VoteType(govSettings_[9]);\r\n        \r\n        proposalVoteTypes[ProposalType.SUPERMAJORITY] = VoteType(govSettings_[10]);\r\n\r\n        proposalVoteTypes[ProposalType.TYPE] = VoteType(govSettings_[11]);\r\n        \r\n        proposalVoteTypes[ProposalType.PAUSE] = VoteType(govSettings_[12]);\r\n        \r\n        proposalVoteTypes[ProposalType.EXTENSION] = VoteType(govSettings_[13]);\r\n\r\n        proposalVoteTypes[ProposalType.ESCAPE] = VoteType(govSettings_[14]);\r\n\r\n        proposalVoteTypes[ProposalType.DOCS] = VoteType(govSettings_[15]);\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            PROPOSAL LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function getProposalArrays(uint256 proposal) public view virtual returns (\r\n        address[] memory accounts, \r\n        uint256[] memory amounts, \r\n        bytes[] memory payloads\r\n    ) {\r\n        Proposal storage prop = proposals[proposal];\r\n        \r\n        (accounts, amounts, payloads) = (prop.accounts, prop.amounts, prop.payloads);\r\n    }\r\n\r\n    function propose(\r\n        ProposalType proposalType,\r\n        string calldata description,\r\n        address[] calldata accounts,\r\n        uint256[] calldata amounts,\r\n        bytes[] calldata payloads\r\n    ) public nonReentrant virtual returns (uint256 proposal) {\r\n        if (accounts.length != amounts.length || amounts.length != payloads.length) revert NoArrayParity();\r\n        \r\n        if (proposalType == ProposalType.VPERIOD) if (amounts[0] == 0 || amounts[0] > 365 days) revert PeriodBounds();\r\n\r\n        if (proposalType == ProposalType.GPERIOD) if (amounts[0] > 365 days) revert PeriodBounds();\r\n        \r\n        if (proposalType == ProposalType.QUORUM) if (amounts[0] > 100) revert QuorumMax();\r\n        \r\n        if (proposalType == ProposalType.SUPERMAJORITY) if (amounts[0] <= 51 || amounts[0] > 100) revert SupermajorityBounds();\r\n\r\n        if (proposalType == ProposalType.TYPE) if (amounts[0] > 11 || amounts[1] > 3 || amounts.length != 2) revert TypeBounds();\r\n\r\n        bool selfSponsor;\r\n\r\n        // if member or extension is making proposal, include sponsorship\r\n        if (balanceOf[msg.sender] != 0 || extensions[msg.sender]) selfSponsor = true;\r\n\r\n        // cannot realistically overflow on human timescales\r\n        unchecked {\r\n            proposalCount++;\r\n        }\r\n\r\n        proposal = proposalCount;\r\n\r\n        proposals[proposal] = Proposal({\r\n            proposalType: proposalType,\r\n            description: description,\r\n            accounts: accounts,\r\n            amounts: amounts,\r\n            payloads: payloads,\r\n            prevProposal: selfSponsor ? currentSponsoredProposal : 0,\r\n            yesVotes: 0,\r\n            noVotes: 0,\r\n            creationTime: selfSponsor ? _safeCastTo32(block.timestamp) : 0,\r\n            proposer: msg.sender\r\n        });\r\n\r\n        if (selfSponsor) currentSponsoredProposal = proposal;\r\n\r\n        emit NewProposal(msg.sender, proposal, proposalType, description, accounts, amounts, payloads);\r\n    }\r\n\r\n    function cancelProposal(uint256 proposal) public nonReentrant virtual {\r\n        Proposal storage prop = proposals[proposal];\r\n\r\n        if (msg.sender != prop.proposer) revert NotProposer();\r\n\r\n        if (prop.creationTime != 0) revert Sponsored();\r\n\r\n        delete proposals[proposal];\r\n\r\n        emit ProposalCancelled(msg.sender, proposal);\r\n    }\r\n\r\n    function sponsorProposal(uint256 proposal) public nonReentrant virtual {\r\n        Proposal storage prop = proposals[proposal];\r\n\r\n        if (balanceOf[msg.sender] == 0) revert NotMember();\r\n\r\n        if (prop.proposer == address(0)) revert NotCurrentProposal();\r\n\r\n        if (prop.creationTime != 0) revert Sponsored();\r\n\r\n        prop.prevProposal = currentSponsoredProposal;\r\n\r\n        currentSponsoredProposal = proposal;\r\n\r\n        prop.creationTime = _safeCastTo32(block.timestamp);\r\n\r\n        emit ProposalSponsored(msg.sender, proposal);\r\n    } \r\n\r\n    function vote(uint256 proposal, bool approve) public nonReentrant virtual {\r\n        _vote(msg.sender, proposal, approve);\r\n    }\r\n    \r\n    function voteBySig(\r\n        address signer, \r\n        uint256 proposal, \r\n        bool approve, \r\n        uint8 v, \r\n        bytes32 r, \r\n        bytes32 s\r\n    ) public nonReentrant virtual {\r\n        bytes32 digest =\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    '\\x19\\x01',\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(\r\n                        abi.encode(\r\n                            VOTE_HASH,\r\n                            signer,\r\n                            proposal,\r\n                            approve\r\n                        )\r\n                    )\r\n                )\r\n            );\r\n            \r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n\r\n        if (recoveredAddress == address(0) || recoveredAddress != signer) revert InvalidSignature();\r\n        \r\n        _vote(signer, proposal, approve);\r\n    }\r\n    \r\n    function _vote(\r\n        address signer, \r\n        uint256 proposal, \r\n        bool approve\r\n    ) internal virtual {\r\n        Proposal storage prop = proposals[proposal];\r\n\r\n        if (balanceOf[signer] == 0) revert NotMember();\r\n\r\n        if (voted[proposal][signer]) revert AlreadyVoted();\r\n        \r\n        // this is safe from overflow because `votingPeriod` is capped so it will not combine\r\n        // with unix time to exceed the max uint256 value\r\n        unchecked {\r\n            if (block.timestamp > prop.creationTime + votingPeriod) revert NotVoteable();\r\n        }\r\n\r\n        uint96 weight = getPriorVotes(signer, prop.creationTime);\r\n        \r\n        // this is safe from overflow because `yesVotes` and `noVotes` are capped by `totalSupply`\r\n        // which is checked for overflow in `KaliDAOtoken` contract\r\n        unchecked { \r\n            if (approve) {\r\n                prop.yesVotes += weight;\r\n\r\n                lastYesVote[signer] = proposal;\r\n            } else {\r\n                prop.noVotes += weight;\r\n            }\r\n        }\r\n        \r\n        voted[proposal][signer] = true;\r\n        \r\n        emit VoteCast(signer, proposal, approve);\r\n    }\r\n\r\n    function processProposal(uint256 proposal) public nonReentrant virtual returns (\r\n        bool didProposalPass, bytes[] memory results\r\n    ) {\r\n        Proposal storage prop = proposals[proposal];\r\n\r\n        VoteType voteType = proposalVoteTypes[prop.proposalType];\r\n\r\n        if (prop.creationTime == 0) revert NotCurrentProposal();\r\n        \r\n        // this is safe from overflow because `votingPeriod` and `gracePeriod` are capped so they will not combine\r\n        // with unix time to exceed the max uint256 value\r\n        unchecked {\r\n            if (block.timestamp <= prop.creationTime + votingPeriod + gracePeriod) revert VotingNotEnded();\r\n        }\r\n\r\n        // skip previous proposal processing requirement in case of escape hatch\r\n        if (prop.proposalType != ProposalType.ESCAPE) \r\n            if (proposals[prop.prevProposal].creationTime != 0) revert PrevNotProcessed();\r\n\r\n        didProposalPass = _countVotes(voteType, prop.yesVotes, prop.noVotes);\r\n        \r\n        if (didProposalPass) {\r\n            // cannot realistically overflow on human timescales\r\n            unchecked {\r\n                if (prop.proposalType == ProposalType.MINT) \r\n                    for (uint256 i; i < prop.accounts.length; i++) {\r\n                        _mint(prop.accounts[i], prop.amounts[i]);\r\n                    }\r\n                    \r\n                if (prop.proposalType == ProposalType.BURN) \r\n                    for (uint256 i; i < prop.accounts.length; i++) {\r\n                        _burn(prop.accounts[i], prop.amounts[i]);\r\n                    }\r\n                    \r\n                if (prop.proposalType == ProposalType.CALL) \r\n                    for (uint256 i; i < prop.accounts.length; i++) {\r\n                        results = new bytes[](prop.accounts.length);\r\n                        \r\n                        (, bytes memory result) = prop.accounts[i].call{value: prop.amounts[i]}\r\n                            (prop.payloads[i]);\r\n                        \r\n                        results[i] = result;\r\n                    }\r\n                    \r\n                // governance settings\r\n                if (prop.proposalType == ProposalType.VPERIOD) \r\n                    if (prop.amounts[0] != 0) votingPeriod = uint32(prop.amounts[0]);\r\n                \r\n                if (prop.proposalType == ProposalType.GPERIOD) \r\n                    if (prop.amounts[0] != 0) gracePeriod = uint32(prop.amounts[0]);\r\n                \r\n                if (prop.proposalType == ProposalType.QUORUM) \r\n                    if (prop.amounts[0] != 0) quorum = uint32(prop.amounts[0]);\r\n                \r\n                if (prop.proposalType == ProposalType.SUPERMAJORITY) \r\n                    if (prop.amounts[0] != 0) supermajority = uint32(prop.amounts[0]);\r\n                \r\n                if (prop.proposalType == ProposalType.TYPE) \r\n                    proposalVoteTypes[ProposalType(prop.amounts[0])] = VoteType(prop.amounts[1]);\r\n                \r\n                if (prop.proposalType == ProposalType.PAUSE) \r\n                    _flipPause();\r\n                \r\n                if (prop.proposalType == ProposalType.EXTENSION) \r\n                    for (uint256 i; i < prop.accounts.length; i++) {\r\n                        if (prop.amounts[i] != 0) \r\n                            extensions[prop.accounts[i]] = !extensions[prop.accounts[i]];\r\n                    \r\n                        if (prop.payloads[i].length > 3) IKaliDAOextension(prop.accounts[i])\r\n                            .setExtension(prop.payloads[i]);\r\n                    }\r\n                \r\n                if (prop.proposalType == ProposalType.ESCAPE)\r\n                    delete proposals[prop.amounts[0]];\r\n\r\n                if (prop.proposalType == ProposalType.DOCS)\r\n                    docs = prop.description;\r\n                \r\n                proposalStates[proposal].passed = true;\r\n            }\r\n        }\r\n\r\n        delete proposals[proposal];\r\n\r\n        proposalStates[proposal].processed = true;\r\n\r\n        emit ProposalProcessed(proposal, didProposalPass);\r\n    }\r\n\r\n    function _countVotes(\r\n        VoteType voteType,\r\n        uint256 yesVotes,\r\n        uint256 noVotes\r\n    ) internal view virtual returns (bool didProposalPass) {\r\n        // fail proposal if no participation\r\n        if (yesVotes == 0 && noVotes == 0) return false;\r\n\r\n        // rule out any failed quorums\r\n        if (voteType == VoteType.SIMPLE_MAJORITY_QUORUM_REQUIRED || voteType == VoteType.SUPERMAJORITY_QUORUM_REQUIRED) {\r\n            uint256 minVotes = (totalSupply * quorum) / 100;\r\n            \r\n            // this is safe from overflow because `yesVotes` and `noVotes` \r\n            // supply are checked in `KaliDAOtoken` contract\r\n            unchecked {\r\n                uint256 votes = yesVotes + noVotes;\r\n\r\n                if (votes < minVotes) return false;\r\n            }\r\n        }\r\n        \r\n        // simple majority check\r\n        if (voteType == VoteType.SIMPLE_MAJORITY || voteType == VoteType.SIMPLE_MAJORITY_QUORUM_REQUIRED) {\r\n            if (yesVotes > noVotes) return true;\r\n        // supermajority check\r\n        } else {\r\n            // example: 7 yes, 2 no, supermajority = 66\r\n            // ((7+2) * 66) / 100 = 5.94; 7 yes will pass\r\n            uint256 minYes = ((yesVotes + noVotes) * supermajority) / 100;\r\n\r\n            if (yesVotes >= minYes) return true;\r\n        }\r\n    }\r\n    \r\n    /*///////////////////////////////////////////////////////////////\r\n                            EXTENSIONS \r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    receive() external payable virtual {}\r\n\r\n    modifier onlyExtension {\r\n        if (!extensions[msg.sender]) revert NotExtension();\r\n\r\n        _;\r\n    }\r\n\r\n    function callExtension(\r\n        address extension, \r\n        uint256 amount, \r\n        bytes calldata extensionData\r\n    ) public payable nonReentrant virtual returns (bool mint, uint256 amountOut) {\r\n        if (!extensions[extension]) revert NotExtension();\r\n        \r\n        (mint, amountOut) = IKaliDAOextension(extension).callExtension{value: msg.value}\r\n            (msg.sender, amount, extensionData);\r\n        \r\n        if (mint) {\r\n            if (amountOut != 0) _mint(msg.sender, amountOut); \r\n        } else {\r\n            if (amountOut != 0) _burn(msg.sender, amount);\r\n        }\r\n    }\r\n\r\n    function mintShares(address to, uint256 amount) public onlyExtension virtual {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function burnShares(address from, uint256 amount) public onlyExtension virtual {\r\n        _burn(from, amount);\r\n    }\r\n}\r\n\r\n/// @notice Ricardian LLC formation interface.\r\ninterface IRicardianLLC {\r\n    function mintLLC(address to) external payable;\r\n}\r\n\r\n/// @notice Factory to deploy Kali DAO.\r\ncontract KaliDAOfactory is Multicall {\r\n    event DAOdeployed(\r\n        KaliDAO indexed kaliDAO, \r\n        string name, \r\n        string symbol, \r\n        string docs, \r\n        bool paused, \r\n        address[] extensions, \r\n        bytes[] extensionsData,\r\n        address[] voters,\r\n        uint256[] shares,\r\n        uint32[16] govSettings\r\n    );\r\n\r\n    error NullDeploy();\r\n\r\n    address payable private immutable kaliMaster;\r\n\r\n    IRicardianLLC private immutable ricardianLLC;\r\n\r\n    constructor(address payable kaliMaster_, IRicardianLLC ricardianLLC_) {\r\n        kaliMaster = kaliMaster_;\r\n\r\n        ricardianLLC = ricardianLLC_;\r\n    }\r\n    \r\n    function deployKaliDAO(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        string memory docs_,\r\n        bool paused_,\r\n        address[] memory extensions_,\r\n        bytes[] memory extensionsData_,\r\n        address[] calldata voters_,\r\n        uint256[] calldata shares_,\r\n        uint32[16] memory govSettings_\r\n    ) public payable virtual returns (KaliDAO kaliDAO) {\r\n        kaliDAO = KaliDAO(_cloneAsMinimalProxy(kaliMaster, name_));\r\n        \r\n        kaliDAO.init(\r\n            name_, \r\n            symbol_, \r\n            docs_,\r\n            paused_, \r\n            extensions_,\r\n            extensionsData_,\r\n            voters_, \r\n            shares_,  \r\n            govSettings_\r\n        );\r\n\r\n        bytes memory docs = bytes(docs_);\r\n\r\n        if (docs.length == 0) {\r\n            ricardianLLC.mintLLC{value: msg.value}(address(kaliDAO));\r\n        }\r\n\r\n        emit DAOdeployed(kaliDAO, name_, symbol_, docs_, paused_, extensions_, extensionsData_, voters_, shares_, govSettings_);\r\n    }\r\n\r\n    /// @dev modified from Aelin (https://github.com/AelinXYZ/aelin/blob/main/contracts/MinimalProxyFactory.sol)\r\n    function _cloneAsMinimalProxy(address payable base, string memory name_) internal virtual returns (address payable clone) {\r\n        bytes memory createData = abi.encodePacked(\r\n            // constructor\r\n            bytes10(0x3d602d80600a3d3981f3),\r\n            // proxy code\r\n            bytes10(0x363d3d373d3d3d363d73),\r\n            base,\r\n            bytes15(0x5af43d82803e903d91602b57fd5bf3)\r\n        );\r\n\r\n        bytes32 salt = keccak256(bytes(name_));\r\n\r\n        assembly {\r\n            clone := create2(\r\n                0, // no value\r\n                add(createData, 0x20), // data\r\n                mload(createData),\r\n                salt\r\n            )\r\n        }\r\n        // if CREATE2 fails for some reason, address(0) is returned\r\n        if (clone == address(0)) revert NullDeploy();\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"kaliMaster_\",\"type\":\"address\"},{\"internalType\":\"contract IRicardianLLC\",\"name\":\"ricardianLLC_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NullDeploy\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract KaliDAO\",\"name\":\"kaliDAO\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"docs\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"extensions\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"extensionsData\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"voters\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"shares\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint32[16]\",\"name\":\"govSettings\",\"type\":\"uint32[16]\"}],\"name\":\"DAOdeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"docs_\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"paused_\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"extensions_\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"extensionsData_\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"voters_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shares_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint32[16]\",\"name\":\"govSettings_\",\"type\":\"uint32[16]\"}],\"name\":\"deployKaliDAO\",\"outputs\":[{\"internalType\":\"contract KaliDAO\",\"name\":\"kaliDAO\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "KaliDAOfactory", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "11111", "ConstructorArguments": "0000000000000000000000002d91d263909b589edb18e66b9a157cb43619a8750000000000000000000000001a49a558557c9fcd5073fb6641d2dc32233cb5d9", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ec88197e49a381f45825ec4b0530c9338d8bf6e97386388124242696cc1b1881"}]}