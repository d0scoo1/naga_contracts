{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/PredictionMarket.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./RealitioERC20.sol\\\";\\n\\n// openzeppelin imports\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary CeilDiv {\\n  // calculates ceil(x/y)\\n  function ceildiv(uint256 x, uint256 y) internal pure returns (uint256) {\\n    if (x > 0) return ((x - 1) / y) + 1;\\n    return x / y;\\n  }\\n}\\n\\n/// @title Market Contract Factory\\ncontract PredictionMarket {\\n  using SafeMath for uint256;\\n  using CeilDiv for uint256;\\n\\n  // ------ Events ------\\n\\n  event MarketCreated(address indexed user, uint256 indexed marketId, uint256 outcomes, string question, string image);\\n\\n  event MarketActionTx(\\n    address indexed user,\\n    MarketAction indexed action,\\n    uint256 indexed marketId,\\n    uint256 outcomeId,\\n    uint256 shares,\\n    uint256 value,\\n    uint256 timestamp\\n  );\\n\\n  event MarketOutcomePrice(uint256 indexed marketId, uint256 indexed outcomeId, uint256 value, uint256 timestamp);\\n\\n  event MarketLiquidity(\\n    uint256 indexed marketId,\\n    uint256 value, // total liquidity\\n    uint256 price, // value of one liquidity share; max: 1 (50-50 situation)\\n    uint256 timestamp\\n  );\\n\\n  event MarketResolved(address indexed user, uint256 indexed marketId, uint256 outcomeId, uint256 timestamp);\\n\\n  // ------ Events End ------\\n\\n  uint256 public constant MAX_UINT_256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n  uint256 public constant ONE = 10**18;\\n\\n  enum MarketState {\\n    open,\\n    closed,\\n    resolved\\n  }\\n  enum MarketAction {\\n    buy,\\n    sell,\\n    addLiquidity,\\n    removeLiquidity,\\n    claimWinnings,\\n    claimLiquidity,\\n    claimFees,\\n    claimVoided\\n  }\\n\\n  struct Market {\\n    // market details\\n    uint256 closesAtTimestamp;\\n    uint256 balance; // total stake\\n    uint256 liquidity; // stake held\\n    uint256 sharesAvailable; // shares held (all outcomes)\\n    mapping(address => uint256) liquidityShares;\\n    mapping(address => bool) liquidityClaims; // wether user has claimed liquidity earnings\\n    MarketState state; // resolution variables\\n    MarketResolution resolution; // fees\\n    MarketFees fees;\\n    // market outcomes\\n    uint256[] outcomeIds;\\n    mapping(uint256 => MarketOutcome) outcomes;\\n  }\\n\\n  struct MarketFees {\\n    uint256 value; // fee % taken from every transaction\\n    uint256 poolWeight; // internal var used to ensure pro-rate fee distribution\\n    mapping(address => uint256) claimed;\\n  }\\n\\n  struct MarketResolution {\\n    bool resolved;\\n    uint256 outcomeId;\\n    bytes32 questionId; // realitio questionId\\n  }\\n\\n  struct MarketOutcome {\\n    uint256 marketId;\\n    uint256 id;\\n    Shares shares;\\n  }\\n\\n  struct Shares {\\n    uint256 total; // number of shares\\n    uint256 available; // available shares\\n    mapping(address => uint256) holders;\\n    mapping(address => bool) claims; // wether user has claimed winnings\\n    mapping(address => bool) voidedClaims; // wether user has claimed voided market shares\\n  }\\n\\n  uint256[] marketIds;\\n  mapping(uint256 => Market) markets;\\n  uint256 public marketIndex;\\n\\n  // governance\\n  uint256 public fee; // fee % taken from every transaction\\n  address public treasury;\\n  // realitio configs\\n  address public realitioAddress;\\n  uint256 public realitioTimeout;\\n  // market creation\\n  IERC20 public token; // token used for rewards / market creation\\n  uint256 public requiredBalance; // required balance for market creation\\n\\n  // ------ Modifiers ------\\n\\n  modifier isMarket(uint256 marketId) {\\n    require(marketId < marketIndex, \\\"Market not found\\\");\\n    _;\\n  }\\n\\n  modifier timeTransitions(uint256 marketId) {\\n    if (now > markets[marketId].closesAtTimestamp && markets[marketId].state == MarketState.open) {\\n      nextState(marketId);\\n    }\\n    _;\\n  }\\n\\n  modifier atState(uint256 marketId, MarketState state) {\\n    require(markets[marketId].state == state, \\\"Market in incorrect state\\\");\\n    _;\\n  }\\n\\n  modifier notAtState(uint256 marketId, MarketState state) {\\n    require(markets[marketId].state != state, \\\"Market in incorrect state\\\");\\n    _;\\n  }\\n\\n  modifier transitionNext(uint256 marketId) {\\n    _;\\n    nextState(marketId);\\n  }\\n\\n  modifier mustHoldRequiredBalance() {\\n    require(token.balanceOf(msg.sender) >= requiredBalance, \\\"msg.sender must hold minimum erc20 balance\\\");\\n    _;\\n  }\\n\\n  // ------ Modifiers End ------\\n\\n  /// @dev protocol is immutable and has no ownership\\n  constructor(\\n    uint256 _fee,\\n    IERC20 _token,\\n    uint256 _requiredBalance,\\n    address _realitioAddress,\\n    uint256 _realitioTimeout,\\n    address _treasury\\n  ) public {\\n    require(_realitioAddress != address(0), \\\"_realitioAddress is address 0\\\");\\n    require(_realitioTimeout > 0, \\\"timeout must be positive\\\");\\n\\n    fee = _fee;\\n    token = _token;\\n    requiredBalance = _requiredBalance;\\n    realitioAddress = _realitioAddress;\\n    realitioTimeout = _realitioTimeout;\\n    treasury = _treasury;\\n  }\\n\\n  // ------ Core Functions ------\\n\\n  /// @dev Creates a market, initializes the outcome shares pool and submits a question in Realitio\\n  function createMarket(\\n    string calldata question,\\n    string calldata image,\\n    uint256 closesAt,\\n    address arbitrator,\\n    uint256 outcomes\\n  ) external payable mustHoldRequiredBalance() returns (uint256) {\\n    uint256 marketId = marketIndex;\\n    marketIds.push(marketId);\\n\\n    Market storage market = markets[marketId];\\n\\n    require(msg.value > 0, \\\"stake needs to be > 0\\\");\\n    require(closesAt > now, \\\"market must resolve after the current date\\\");\\n    require(arbitrator != address(0), \\\"invalid arbitrator address\\\");\\n    // v1 - only binary markets\\n    require(outcomes == 2, \\\"number of outcomes has to be 2\\\");\\n\\n    market.closesAtTimestamp = closesAt;\\n    market.state = MarketState.open;\\n    market.fees.value = fee;\\n    // setting intial value to an integer that does not map to any outcomeId\\n    market.resolution.outcomeId = MAX_UINT_256;\\n\\n    // creating market outcomes\\n    for (uint256 i = 0; i < outcomes; i++) {\\n      market.outcomeIds.push(i);\\n      MarketOutcome storage outcome = market.outcomes[i];\\n\\n      outcome.marketId = marketId;\\n      outcome.id = i;\\n    }\\n\\n    // creating question in realitio\\n    RealitioERC20 realitio = RealitioERC20(realitioAddress);\\n\\n    market.resolution.questionId = realitio.askQuestionERC20(\\n      2,\\n      question,\\n      arbitrator,\\n      uint32(realitioTimeout),\\n      uint32(closesAt),\\n      0,\\n      0\\n    );\\n\\n    addLiquidity(marketId, msg.value);\\n\\n    // emiting initial price events\\n    emitMarketOutcomePriceEvents(marketId);\\n    emit MarketCreated(msg.sender, marketId, outcomes, question, image);\\n\\n    // incrementing market array index\\n    marketIndex = marketIndex + 1;\\n\\n    return marketId;\\n  }\\n\\n  /// @dev Calculates the number of shares bought with \\\"amount\\\" balance\\n  function calcBuyAmount(\\n    uint256 amount,\\n    uint256 marketId,\\n    uint256 outcomeId\\n  ) public view returns (uint256) {\\n    Market storage market = markets[marketId];\\n\\n    uint256[] memory outcomesShares = getMarketOutcomesShares(marketId);\\n    uint256 amountMinusFees = amount.sub(amount.mul(market.fees.value) / ONE);\\n    uint256 buyTokenPoolBalance = outcomesShares[outcomeId];\\n    uint256 endingOutcomeBalance = buyTokenPoolBalance.mul(ONE);\\n    for (uint256 i = 0; i < outcomesShares.length; i++) {\\n      if (i != outcomeId) {\\n        uint256 outcomeShares = outcomesShares[i];\\n        endingOutcomeBalance = endingOutcomeBalance.mul(outcomeShares).ceildiv(outcomeShares.add(amountMinusFees));\\n      }\\n    }\\n    require(endingOutcomeBalance > 0, \\\"must have non-zero balances\\\");\\n\\n    return buyTokenPoolBalance.add(amountMinusFees).sub(endingOutcomeBalance.ceildiv(ONE));\\n  }\\n\\n  /// @dev Calculates the number of shares needed to be sold in order to receive \\\"amount\\\" in balance\\n  function calcSellAmount(\\n    uint256 amount,\\n    uint256 marketId,\\n    uint256 outcomeId\\n  ) public view returns (uint256 outcomeTokenSellAmount) {\\n    Market storage market = markets[marketId];\\n\\n    uint256[] memory outcomesShares = getMarketOutcomesShares(marketId);\\n    uint256 amountPlusFees = amount.mul(ONE) / ONE.sub(market.fees.value);\\n    uint256 sellTokenPoolBalance = outcomesShares[outcomeId];\\n    uint256 endingOutcomeBalance = sellTokenPoolBalance.mul(ONE);\\n    for (uint256 i = 0; i < outcomesShares.length; i++) {\\n      if (i != outcomeId) {\\n        uint256 outcomeShares = outcomesShares[i];\\n        endingOutcomeBalance = endingOutcomeBalance.mul(outcomeShares).ceildiv(outcomeShares.sub(amountPlusFees));\\n      }\\n    }\\n    require(endingOutcomeBalance > 0, \\\"must have non-zero balances\\\");\\n\\n    return amountPlusFees.add(endingOutcomeBalance.ceildiv(ONE)).sub(sellTokenPoolBalance);\\n  }\\n\\n  /// @dev Buy shares of a market outcome\\n  function buy(\\n    uint256 marketId,\\n    uint256 outcomeId,\\n    uint256 minOutcomeSharesToBuy\\n  ) external payable timeTransitions(marketId) atState(marketId, MarketState.open) {\\n    Market storage market = markets[marketId];\\n\\n    uint256 value = msg.value;\\n    uint256 shares = calcBuyAmount(value, marketId, outcomeId);\\n    require(shares >= minOutcomeSharesToBuy, \\\"minimum buy amount not reached\\\");\\n    require(shares > 0, \\\"shares amount is 0\\\");\\n\\n    // subtracting fee from transaction value\\n    uint256 feeAmount = value.mul(market.fees.value) / ONE;\\n    market.fees.poolWeight = market.fees.poolWeight.add(feeAmount / 2);\\n    {\\n      (bool sent,) = payable(treasury).call{ value: feeAmount - feeAmount / 2 }(\\\"\\\");\\n      require(sent, \\\"PredictionMarket: fail to send value to platform fee address\\\");\\n    }\\n    uint256 valueMinusFees = value.sub(feeAmount);\\n\\n    MarketOutcome storage outcome = market.outcomes[outcomeId];\\n\\n    // Funding market shares with received funds\\n    addSharesToMarket(marketId, valueMinusFees);\\n\\n    require(outcome.shares.available >= shares, \\\"outcome shares pool balance is too low\\\");\\n\\n    transferOutcomeSharesfromPool(msg.sender, marketId, outcomeId, shares);\\n\\n    emit MarketActionTx(msg.sender, MarketAction.buy, marketId, outcomeId, shares, value, now);\\n    emitMarketOutcomePriceEvents(marketId);\\n  }\\n\\n  /// @dev Sell shares of a market outcome\\n  function sell(\\n    uint256 marketId,\\n    uint256 outcomeId,\\n    uint256 value,\\n    uint256 maxOutcomeSharesToSell\\n  ) external payable timeTransitions(marketId) atState(marketId, MarketState.open) {\\n    Market storage market = markets[marketId];\\n    MarketOutcome storage outcome = market.outcomes[outcomeId];\\n\\n    uint256 shares = calcSellAmount(value, marketId, outcomeId);\\n\\n    require(shares <= maxOutcomeSharesToSell, \\\"maximum sell amount exceeded\\\");\\n    require(shares > 0, \\\"shares amount is 0\\\");\\n    require(outcome.shares.holders[msg.sender] >= shares, \\\"user does not have enough balance\\\");\\n\\n    transferOutcomeSharesToPool(msg.sender, marketId, outcomeId, shares);\\n\\n    // adding fee to transaction value\\n    uint256 feeAmount = value.mul(market.fees.value) / (ONE.sub(fee));\\n    market.fees.poolWeight = market.fees.poolWeight.add(feeAmount / 2);\\n    {\\n      (bool sent,) = payable(treasury).call{ value: feeAmount - feeAmount / 2 }(\\\"\\\");\\n      require(sent, \\\"PredictionMarket: fail to send value to platform fee address\\\");\\n    }\\n    uint256 valuePlusFees = value.add(feeAmount);\\n\\n    require(market.balance >= valuePlusFees, \\\"market does not have enough balance\\\");\\n\\n    // Rebalancing market shares\\n    removeSharesFromMarket(marketId, valuePlusFees);\\n\\n    // Transferring funds to user\\n    msg.sender.transfer(value);\\n\\n    emit MarketActionTx(msg.sender, MarketAction.sell, marketId, outcomeId, shares, value, now);\\n    emitMarketOutcomePriceEvents(marketId);\\n  }\\n\\n  /// @dev Adds liquidity to a market - external\\n  function addLiquidity(uint256 marketId)\\n    external\\n    payable\\n    timeTransitions(marketId)\\n    atState(marketId, MarketState.open)\\n  {\\n    addLiquidity(marketId, msg.value);\\n  }\\n\\n  /// @dev Private function, used by addLiquidity and CreateMarket\\n  function addLiquidity(uint256 marketId, uint256 value)\\n    private\\n    timeTransitions(marketId)\\n    atState(marketId, MarketState.open)\\n  {\\n    Market storage market = markets[marketId];\\n\\n    require(value > 0, \\\"stake has to be greater than 0.\\\");\\n\\n    uint256 liquidityAmount;\\n\\n    uint256[] memory outcomesShares = getMarketOutcomesShares(marketId);\\n    uint256[] memory sendBackAmounts = new uint256[](outcomesShares.length);\\n    uint256 poolWeight = 0;\\n\\n    if (market.liquidity > 0) {\\n      // part of the liquidity is exchanged for outcome shares if market is not balanced\\n      for (uint256 i = 0; i < outcomesShares.length; i++) {\\n        uint256 outcomeShares = outcomesShares[i];\\n        if (poolWeight < outcomeShares) poolWeight = outcomeShares;\\n      }\\n\\n      for (uint256 i = 0; i < outcomesShares.length; i++) {\\n        uint256 remaining = value.mul(outcomesShares[i]) / poolWeight;\\n        sendBackAmounts[i] = value.sub(remaining);\\n      }\\n\\n      liquidityAmount = value.mul(market.liquidity) / poolWeight;\\n\\n      // re-balancing fees pool\\n      rebalanceFeesPool(marketId, liquidityAmount, MarketAction.addLiquidity);\\n    } else {\\n      // funding market with no liquidity\\n      liquidityAmount = value;\\n    }\\n\\n    // funding market\\n    market.liquidity = market.liquidity.add(liquidityAmount);\\n    market.liquidityShares[msg.sender] = market.liquidityShares[msg.sender].add(liquidityAmount);\\n\\n    addSharesToMarket(marketId, value);\\n\\n    // transform sendBackAmounts to array of amounts added\\n    for (uint256 i = 0; i < sendBackAmounts.length; i++) {\\n      if (sendBackAmounts[i] > 0) {\\n        uint256 marketShares = market.sharesAvailable;\\n        uint256 outcomeShares = market.outcomes[i].shares.available;\\n        transferOutcomeSharesfromPool(msg.sender, marketId, i, sendBackAmounts[i]);\\n        emit MarketActionTx(\\n          msg.sender,\\n          MarketAction.buy,\\n          marketId,\\n          i,\\n          sendBackAmounts[i],\\n          (marketShares.sub(outcomeShares)).mul(sendBackAmounts[i]).div(market.sharesAvailable), // price * shares\\n          now\\n        );\\n      }\\n    }\\n\\n    uint256 liquidityPrice = getMarketLiquidityPrice(marketId);\\n    uint256 liquidityValue = liquidityPrice.mul(liquidityAmount) / ONE;\\n    emit MarketActionTx(msg.sender, MarketAction.addLiquidity, marketId, 0, liquidityAmount, liquidityValue, now);\\n    emit MarketLiquidity(marketId, market.liquidity, liquidityPrice, now);\\n  }\\n\\n  /// @dev Removes liquidity to a market - external\\n  function removeLiquidity(uint256 marketId, uint256 shares)\\n    external\\n    payable\\n    timeTransitions(marketId)\\n    atState(marketId, MarketState.open)\\n  {\\n    Market storage market = markets[marketId];\\n\\n    require(market.liquidityShares[msg.sender] >= shares, \\\"user does not have enough balance\\\");\\n    // claiming any pending fees\\n    claimFees(marketId);\\n\\n    // re-balancing fees pool\\n    rebalanceFeesPool(marketId, shares, MarketAction.removeLiquidity);\\n\\n    uint256[] memory outcomesShares = getMarketOutcomesShares(marketId);\\n    uint256[] memory sendAmounts = new uint256[](outcomesShares.length);\\n    uint256 poolWeight = MAX_UINT_256;\\n\\n    // part of the liquidity is exchanged for outcome shares if market is not balanced\\n    for (uint256 i = 0; i < outcomesShares.length; i++) {\\n      uint256 outcomeShares = outcomesShares[i];\\n      if (poolWeight > outcomeShares) poolWeight = outcomeShares;\\n    }\\n\\n    uint256 liquidityAmount = shares.mul(poolWeight).div(market.liquidity);\\n\\n    for (uint256 i = 0; i < outcomesShares.length; i++) {\\n      sendAmounts[i] = outcomesShares[i].mul(shares) / market.liquidity;\\n      sendAmounts[i] = sendAmounts[i].sub(liquidityAmount);\\n    }\\n\\n    // removing liquidity from market\\n    removeSharesFromMarket(marketId, liquidityAmount);\\n    market.liquidity = market.liquidity.sub(shares);\\n    // removing liquidity tokens from market creator\\n    market.liquidityShares[msg.sender] = market.liquidityShares[msg.sender].sub(shares);\\n\\n    for (uint256 i = 0; i < outcomesShares.length; i++) {\\n      if (sendAmounts[i] > 0) {\\n        uint256 marketShares = market.sharesAvailable;\\n        uint256 outcomeShares = market.outcomes[i].shares.available;\\n\\n        transferOutcomeSharesfromPool(msg.sender, marketId, i, sendAmounts[i]);\\n        emit MarketActionTx(\\n          msg.sender,\\n          MarketAction.buy,\\n          marketId,\\n          i,\\n          sendAmounts[i],\\n          (marketShares.sub(outcomeShares)).mul(sendAmounts[i]).div(market.sharesAvailable), // price * shares\\n          now\\n        );\\n      }\\n    }\\n\\n    // transferring user funds from liquidity removed\\n    msg.sender.transfer(liquidityAmount);\\n\\n    emit MarketActionTx(msg.sender, MarketAction.removeLiquidity, marketId, 0, shares, liquidityAmount, now);\\n    emit MarketLiquidity(marketId, market.liquidity, getMarketLiquidityPrice(marketId), now);\\n  }\\n\\n  /// @dev Fetches winning outcome from Realitio and resolves the market\\n  function resolveMarketOutcome(uint256 marketId)\\n    external\\n    timeTransitions(marketId)\\n    atState(marketId, MarketState.closed)\\n    transitionNext(marketId)\\n    returns (uint256)\\n  {\\n    Market storage market = markets[marketId];\\n\\n    RealitioERC20 realitio = RealitioERC20(realitioAddress);\\n    // will fail if question is not finalized\\n    uint256 outcomeId = uint256(realitio.resultFor(market.resolution.questionId));\\n\\n    market.resolution.outcomeId = outcomeId;\\n\\n    emit MarketResolved(msg.sender, marketId, outcomeId, now);\\n    emitMarketOutcomePriceEvents(marketId);\\n\\n    return market.resolution.outcomeId;\\n  }\\n\\n  /// @dev Allows holders of resolved outcome shares to claim earnings.\\n  function claimWinnings(uint256 marketId) external atState(marketId, MarketState.resolved) {\\n    Market storage market = markets[marketId];\\n    MarketOutcome storage resolvedOutcome = market.outcomes[market.resolution.outcomeId];\\n\\n    require(resolvedOutcome.shares.holders[msg.sender] > 0, \\\"user does not hold resolved outcome shares\\\");\\n    require(resolvedOutcome.shares.claims[msg.sender] == false, \\\"user already claimed resolved outcome winnings\\\");\\n\\n    // 1 share => price = 1\\n    uint256 value = resolvedOutcome.shares.holders[msg.sender];\\n\\n    // assuring market has enough funds\\n    require(market.balance >= value, \\\"Market does not have enough balance\\\");\\n\\n    market.balance = market.balance.sub(value);\\n    resolvedOutcome.shares.claims[msg.sender] = true;\\n\\n    emit MarketActionTx(\\n      msg.sender,\\n      MarketAction.claimWinnings,\\n      marketId,\\n      market.resolution.outcomeId,\\n      resolvedOutcome.shares.holders[msg.sender],\\n      value,\\n      now\\n    );\\n\\n    msg.sender.transfer(value);\\n  }\\n\\n  /// @dev Allows holders of voided outcome shares to claim balance back.\\n  function claimVoidedOutcomeShares(uint256 marketId, uint256 outcomeId)\\n    external\\n    atState(marketId, MarketState.resolved)\\n  {\\n    Market storage market = markets[marketId];\\n    MarketOutcome storage outcome = market.outcomes[outcomeId];\\n\\n    require(outcome.shares.holders[msg.sender] > 0, \\\"user does not hold outcome shares\\\");\\n    require(outcome.shares.voidedClaims[msg.sender] == false, \\\"user already claimed outcome shares\\\");\\n\\n    // voided market - shares are valued at last market price\\n    uint256 price = getMarketOutcomePrice(marketId, outcomeId);\\n    uint256 value = price.mul(outcome.shares.holders[msg.sender]).div(ONE);\\n\\n    // assuring market has enough funds\\n    require(market.balance >= value, \\\"Market does not have enough balance\\\");\\n\\n    market.balance = market.balance.sub(value);\\n    outcome.shares.voidedClaims[msg.sender] = true;\\n\\n    emit MarketActionTx(\\n      msg.sender,\\n      MarketAction.claimVoided,\\n      marketId,\\n      outcomeId,\\n      outcome.shares.holders[msg.sender],\\n      value,\\n      now\\n    );\\n\\n    msg.sender.transfer(value);\\n  }\\n\\n  /// @dev Allows liquidity providers to claim earnings from liquidity providing.\\n  function claimLiquidity(uint256 marketId) external atState(marketId, MarketState.resolved) {\\n    Market storage market = markets[marketId];\\n\\n    // claiming any pending fees\\n    claimFees(marketId);\\n\\n    require(market.liquidityShares[msg.sender] > 0, \\\"user does not hold liquidity shares\\\");\\n    require(market.liquidityClaims[msg.sender] == false, \\\"user already claimed liquidity winnings\\\");\\n\\n    // value = total resolved outcome pool shares * pool share (%)\\n    uint256 liquidityPrice = getMarketLiquidityPrice(marketId);\\n    uint256 value = liquidityPrice.mul(market.liquidityShares[msg.sender]) / ONE;\\n\\n    // assuring market has enough funds\\n    require(market.balance >= value, \\\"Market does not have enough balance\\\");\\n\\n    market.balance = market.balance.sub(value);\\n    market.liquidityClaims[msg.sender] = true;\\n\\n    emit MarketActionTx(\\n      msg.sender,\\n      MarketAction.claimLiquidity,\\n      marketId,\\n      0,\\n      market.liquidityShares[msg.sender],\\n      value,\\n      now\\n    );\\n\\n    msg.sender.transfer(value);\\n  }\\n\\n  /// @dev Allows liquidity providers to claim their fees share from fees pool\\n  function claimFees(uint256 marketId) public payable {\\n    Market storage market = markets[marketId];\\n\\n    uint256 claimableFees = getUserClaimableFees(marketId, msg.sender);\\n\\n    if (claimableFees > 0) {\\n      market.fees.claimed[msg.sender] = market.fees.claimed[msg.sender].add(claimableFees);\\n      msg.sender.transfer(claimableFees);\\n    }\\n\\n    emit MarketActionTx(\\n      msg.sender,\\n      MarketAction.claimFees,\\n      marketId,\\n      0,\\n      market.liquidityShares[msg.sender],\\n      claimableFees,\\n      now\\n    );\\n  }\\n\\n  /// @dev Rebalances the fees pool. Needed in every AddLiquidity / RemoveLiquidity call\\n  function rebalanceFeesPool(\\n    uint256 marketId,\\n    uint256 liquidityShares,\\n    MarketAction action\\n  ) private returns (uint256) {\\n    Market storage market = markets[marketId];\\n\\n    uint256 poolWeight = liquidityShares.mul(market.fees.poolWeight).div(market.liquidity);\\n\\n    if (action == MarketAction.addLiquidity) {\\n      market.fees.poolWeight = market.fees.poolWeight.add(poolWeight);\\n      market.fees.claimed[msg.sender] = market.fees.claimed[msg.sender].add(poolWeight);\\n    } else {\\n      market.fees.poolWeight = market.fees.poolWeight.sub(poolWeight);\\n      market.fees.claimed[msg.sender] = market.fees.claimed[msg.sender].sub(poolWeight);\\n    }\\n  }\\n\\n  /// @dev Transitions market to next state\\n  function nextState(uint256 marketId) private {\\n    Market storage market = markets[marketId];\\n    market.state = MarketState(uint256(market.state) + 1);\\n  }\\n\\n  /// @dev Emits a outcome price event for every outcome\\n  function emitMarketOutcomePriceEvents(uint256 marketId) private {\\n    Market storage market = markets[marketId];\\n\\n    for (uint256 i = 0; i < market.outcomeIds.length; i++) {\\n      emit MarketOutcomePrice(marketId, i, getMarketOutcomePrice(marketId, i), now);\\n    }\\n\\n    // liquidity shares also change value\\n    emit MarketLiquidity(marketId, market.liquidity, getMarketLiquidityPrice(marketId), now);\\n  }\\n\\n  /// @dev Adds outcome shares to shares pool\\n  function addSharesToMarket(uint256 marketId, uint256 shares) private {\\n    Market storage market = markets[marketId];\\n\\n    for (uint256 i = 0; i < market.outcomeIds.length; i++) {\\n      MarketOutcome storage outcome = market.outcomes[i];\\n\\n      outcome.shares.available = outcome.shares.available.add(shares);\\n      outcome.shares.total = outcome.shares.total.add(shares);\\n\\n      // only adding to market total shares, the available remains\\n      market.sharesAvailable = market.sharesAvailable.add(shares);\\n    }\\n\\n    market.balance = market.balance.add(shares);\\n  }\\n\\n  /// @dev Removes outcome shares from shares pool\\n  function removeSharesFromMarket(uint256 marketId, uint256 shares) private {\\n    Market storage market = markets[marketId];\\n\\n    for (uint256 i = 0; i < market.outcomeIds.length; i++) {\\n      MarketOutcome storage outcome = market.outcomes[i];\\n\\n      outcome.shares.available = outcome.shares.available.sub(shares);\\n      outcome.shares.total = outcome.shares.total.sub(shares);\\n\\n      // only subtracting from market total shares, the available remains\\n      market.sharesAvailable = market.sharesAvailable.sub(shares);\\n    }\\n\\n    market.balance = market.balance.sub(shares);\\n  }\\n\\n  /// @dev Transfer outcome shares from pool to user balance\\n  function transferOutcomeSharesfromPool(\\n    address user,\\n    uint256 marketId,\\n    uint256 outcomeId,\\n    uint256 shares\\n  ) private {\\n    Market storage market = markets[marketId];\\n    MarketOutcome storage outcome = market.outcomes[outcomeId];\\n\\n    // transfering shares from shares pool to user\\n    outcome.shares.holders[user] = outcome.shares.holders[user].add(shares);\\n    outcome.shares.available = outcome.shares.available.sub(shares);\\n    market.sharesAvailable = market.sharesAvailable.sub(shares);\\n  }\\n\\n  /// @dev Transfer outcome shares from user balance back to pool\\n  function transferOutcomeSharesToPool(\\n    address user,\\n    uint256 marketId,\\n    uint256 outcomeId,\\n    uint256 shares\\n  ) private {\\n    Market storage market = markets[marketId];\\n    MarketOutcome storage outcome = market.outcomes[outcomeId];\\n\\n    // adding shares back to pool\\n    outcome.shares.holders[user] = outcome.shares.holders[user].sub(shares);\\n    outcome.shares.available = outcome.shares.available.add(shares);\\n    market.sharesAvailable = market.sharesAvailable.add(shares);\\n  }\\n\\n  // ------ Core Functions End ------\\n\\n  // ------ Getters ------\\n\\n  function getUserMarketShares(uint256 marketId, address user)\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    Market storage market = markets[marketId];\\n\\n    return (\\n      market.liquidityShares[user],\\n      market.outcomes[0].shares.holders[user],\\n      market.outcomes[1].shares.holders[user]\\n    );\\n  }\\n\\n  function getUserClaimStatus(uint256 marketId, address user)\\n    external\\n    view\\n    returns (\\n      bool,\\n      bool,\\n      bool,\\n      bool,\\n      uint256\\n    )\\n  {\\n    Market storage market = markets[marketId];\\n\\n    // market still not resolved\\n    if (market.state != MarketState.resolved) {\\n      return (false, false, false, false, getUserClaimableFees(marketId, user));\\n    }\\n\\n    MarketOutcome storage outcome = market.outcomes[market.resolution.outcomeId];\\n\\n    return (\\n      outcome.shares.holders[user] > 0,\\n      outcome.shares.claims[user],\\n      market.liquidityShares[user] > 0,\\n      market.liquidityClaims[user],\\n      getUserClaimableFees(marketId, user)\\n    );\\n  }\\n\\n  function getUserLiquidityPoolShare(uint256 marketId, address user) external view returns (uint256) {\\n    Market storage market = markets[marketId];\\n\\n    return market.liquidityShares[user].mul(ONE).div(market.liquidity);\\n  }\\n\\n  function getUserClaimableFees(uint256 marketId, address user) public view returns (uint256) {\\n    Market storage market = markets[marketId];\\n\\n    uint256 rawAmount = market.fees.poolWeight.mul(market.liquidityShares[user]).div(market.liquidity);\\n\\n    // No fees left to claim\\n    if (market.fees.claimed[user] > rawAmount) return 0;\\n\\n    return rawAmount.sub(market.fees.claimed[user]);\\n  }\\n\\n  function getMarkets() external view returns (uint256[] memory) {\\n    return marketIds;\\n  }\\n\\n  function getMarketData(uint256 marketId)\\n    external\\n    view\\n    returns (\\n      MarketState,\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256,\\n      int256\\n    )\\n  {\\n    Market storage market = markets[marketId];\\n\\n    return (\\n      market.state,\\n      market.closesAtTimestamp,\\n      market.liquidity,\\n      market.balance,\\n      market.sharesAvailable,\\n      getMarketResolvedOutcome(marketId)\\n    );\\n  }\\n\\n  function getMarketAltData(uint256 marketId)\\n    external\\n    view\\n    returns (\\n      uint256,\\n      bytes32,\\n      uint256\\n    )\\n  {\\n    Market storage market = markets[marketId];\\n\\n    return (market.fees.value, market.resolution.questionId, uint256(market.resolution.questionId));\\n  }\\n\\n  function getMarketQuestion(uint256 marketId) external view returns (bytes32) {\\n    Market storage market = markets[marketId];\\n\\n    return (market.resolution.questionId);\\n  }\\n\\n  function getMarketPrices(uint256 marketId)\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    return (getMarketLiquidityPrice(marketId), getMarketOutcomePrice(marketId, 0), getMarketOutcomePrice(marketId, 1));\\n  }\\n\\n  function getMarketLiquidityPrice(uint256 marketId) public view returns (uint256) {\\n    Market storage market = markets[marketId];\\n\\n    if (market.state == MarketState.resolved && !isMarketVoided(marketId)) {\\n      // resolved market, price is either 0 or 1\\n      // final liquidity price = outcome shares / liquidity shares\\n      return market.outcomes[market.resolution.outcomeId].shares.available.mul(ONE).div(market.liquidity);\\n    }\\n\\n    // liquidity price = # liquidity shares / # outcome shares * # outcomes\\n    return market.liquidity.mul(ONE * market.outcomeIds.length).div(market.sharesAvailable);\\n  }\\n\\n  function getMarketResolvedOutcome(uint256 marketId) public view returns (int256) {\\n    Market storage market = markets[marketId];\\n\\n    // returning -1 if market still not resolved\\n    if (market.state != MarketState.resolved) {\\n      return -1;\\n    }\\n\\n    return int256(market.resolution.outcomeId);\\n  }\\n\\n  function isMarketVoided(uint256 marketId) public view returns (bool) {\\n    Market storage market = markets[marketId];\\n\\n    // market still not resolved, still in valid state\\n    if (market.state != MarketState.resolved) {\\n      return false;\\n    }\\n\\n    // resolved market id does not match any of the market ids\\n    return market.resolution.outcomeId >= market.outcomeIds.length;\\n  }\\n\\n  // ------ Outcome Getters ------\\n\\n  function getMarketOutcomeIds(uint256 marketId) external view returns (uint256[] memory) {\\n    Market storage market = markets[marketId];\\n    return market.outcomeIds;\\n  }\\n\\n  function getMarketOutcomePrice(uint256 marketId, uint256 outcomeId) public view returns (uint256) {\\n    Market storage market = markets[marketId];\\n    MarketOutcome storage outcome = market.outcomes[outcomeId];\\n\\n    if (market.state == MarketState.resolved && !isMarketVoided(marketId)) {\\n      // resolved market, price is either 0 or 1\\n      return outcomeId == market.resolution.outcomeId ? ONE : 0;\\n    }\\n\\n    return (market.sharesAvailable.sub(outcome.shares.available)).mul(ONE).div(market.sharesAvailable);\\n  }\\n\\n  function getMarketOutcomeData(uint256 marketId, uint256 outcomeId)\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    Market storage market = markets[marketId];\\n    MarketOutcome storage outcome = market.outcomes[outcomeId];\\n\\n    return (getMarketOutcomePrice(marketId, outcomeId), outcome.shares.available, outcome.shares.total);\\n  }\\n\\n  function getMarketOutcomesShares(uint256 marketId) private view returns (uint256[] memory) {\\n    Market storage market = markets[marketId];\\n\\n    uint256[] memory shares = new uint256[](market.outcomeIds.length);\\n    for (uint256 i = 0; i < market.outcomeIds.length; i++) {\\n      shares[i] = market.outcomes[i].shares.available;\\n    }\\n\\n    return shares;\\n  }\\n}\\n\"\r\n    },\r\n    \"/contracts/RealitioERC20.sol\": {\r\n      \"content\": \"/**\\n *Submitted for verification at Etherscan.io on 2021-06-09\\n*/\\n\\npragma solidity >0.4.24;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\npragma solidity >0.4.24;\\n\\n/**\\n * @title ReailtioSafeMath256\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary RealitioSafeMath256 {\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint256 c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\\npragma solidity >0.4.24;\\n\\n/**\\n * @title RealitioSafeMath32\\n * @dev Math operations with safety checks that throw on error\\n * @dev Copy of SafeMath but for uint32 instead of uint256\\n * @dev Deleted functions we don't use\\n */\\nlibrary RealitioSafeMath32 {\\n  function add(uint32 a, uint32 b) internal pure returns (uint32) {\\n    uint32 c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\\npragma solidity >0.4.18;\\n\\n\\ncontract BalanceHolder {\\n\\n    IERC20 public token;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    event LogWithdraw(\\n        address indexed user,\\n        uint256 amount\\n    );\\n\\n    function withdraw()\\n    public {\\n        uint256 bal = balanceOf[msg.sender];\\n        balanceOf[msg.sender] = 0;\\n        require(token.transfer(msg.sender, bal));\\n        emit LogWithdraw(msg.sender, bal);\\n    }\\n\\n}\\npragma solidity >0.4.24;\\n\\n\\ncontract RealitioERC20 is BalanceHolder {\\n\\n    using RealitioSafeMath256 for uint256;\\n    using RealitioSafeMath32 for uint32;\\n\\n    address constant NULL_ADDRESS = address(0);\\n\\n    // History hash when no history is created, or history has been cleared\\n    bytes32 constant NULL_HASH = bytes32(0);\\n\\n    // An unitinalized finalize_ts for a question will indicate an unanswered question.\\n    uint32 constant UNANSWERED = 0;\\n\\n    // An unanswered reveal_ts for a commitment will indicate that it does not exist.\\n    uint256 constant COMMITMENT_NON_EXISTENT = 0;\\n\\n    // Commit->reveal timeout is 1/8 of the question timeout (rounded down).\\n    uint32 constant COMMITMENT_TIMEOUT_RATIO = 8;\\n\\n    event LogSetQuestionFee(\\n        address arbitrator,\\n        uint256 amount\\n    );\\n\\n    event LogNewTemplate(\\n        uint256 indexed template_id,\\n        address indexed user,\\n        string question_text\\n    );\\n\\n    event LogNewQuestion(\\n        bytes32 indexed question_id,\\n        address indexed user,\\n        uint256 template_id,\\n        string question,\\n        bytes32 indexed content_hash,\\n        address arbitrator,\\n        uint32 timeout,\\n        uint32 opening_ts,\\n        uint256 nonce,\\n        uint256 created\\n    );\\n\\n    event LogFundAnswerBounty(\\n        bytes32 indexed question_id,\\n        uint256 bounty_added,\\n        uint256 bounty,\\n        address indexed user\\n    );\\n\\n    event LogNewAnswer(\\n        bytes32 answer,\\n        bytes32 indexed question_id,\\n        bytes32 history_hash,\\n        address indexed user,\\n        uint256 bond,\\n        uint256 ts,\\n        bool is_commitment\\n    );\\n\\n    event LogAnswerReveal(\\n        bytes32 indexed question_id,\\n        address indexed user,\\n        bytes32 indexed answer_hash,\\n        bytes32 answer,\\n        uint256 nonce,\\n        uint256 bond\\n    );\\n\\n    event LogNotifyOfArbitrationRequest(\\n        bytes32 indexed question_id,\\n        address indexed user\\n    );\\n\\n    event LogFinalize(\\n        bytes32 indexed question_id,\\n        bytes32 indexed answer\\n    );\\n\\n    event LogClaim(\\n        bytes32 indexed question_id,\\n        address indexed user,\\n        uint256 amount\\n    );\\n\\n    struct Question {\\n        bytes32 content_hash;\\n        address arbitrator;\\n        uint32 opening_ts;\\n        uint32 timeout;\\n        uint32 finalize_ts;\\n        bool is_pending_arbitration;\\n        uint256 bounty;\\n        bytes32 best_answer;\\n        bytes32 history_hash;\\n        uint256 bond;\\n    }\\n\\n    // Stored in a mapping indexed by commitment_id, a hash of commitment hash, question, bond.\\n    struct Commitment {\\n        uint32 reveal_ts;\\n        bool is_revealed;\\n        bytes32 revealed_answer;\\n    }\\n\\n    // Only used when claiming more bonds than fits into a transaction\\n    // Stored in a mapping indexed by question_id.\\n    struct Claim {\\n        address payee;\\n        uint256 last_bond;\\n        uint256 queued_funds;\\n    }\\n\\n    uint256 nextTemplateID = 0;\\n    mapping(uint256 => uint256) public templates;\\n    mapping(uint256 => bytes32) public template_hashes;\\n    mapping(bytes32 => Question) public questions;\\n    mapping(bytes32 => Claim) public question_claims;\\n    mapping(bytes32 => Commitment) public commitments;\\n    mapping(address => uint256) public arbitrator_question_fees;\\n\\n    modifier onlyArbitrator(bytes32 question_id) {\\n        require(msg.sender == questions[question_id].arbitrator, \\\"msg.sender must be arbitrator\\\");\\n        _;\\n    }\\n\\n    modifier stateAny() {\\n        _;\\n    }\\n\\n    modifier stateNotCreated(bytes32 question_id) {\\n        require(questions[question_id].timeout == 0, \\\"question must not exist\\\");\\n        _;\\n    }\\n\\n    modifier stateOpen(bytes32 question_id) {\\n        require(questions[question_id].timeout > 0, \\\"question must exist\\\");\\n        require(!questions[question_id].is_pending_arbitration, \\\"question must not be pending arbitration\\\");\\n        uint32 finalize_ts = questions[question_id].finalize_ts;\\n        require(finalize_ts == UNANSWERED || finalize_ts > uint32(now), \\\"finalization deadline must not have passed\\\");\\n        uint32 opening_ts = questions[question_id].opening_ts;\\n        require(opening_ts == 0 || opening_ts <= uint32(now), \\\"opening date must have passed\\\");\\n        _;\\n    }\\n\\n    modifier statePendingArbitration(bytes32 question_id) {\\n        require(questions[question_id].is_pending_arbitration, \\\"question must be pending arbitration\\\");\\n        _;\\n    }\\n\\n    modifier stateOpenOrPendingArbitration(bytes32 question_id) {\\n        require(questions[question_id].timeout > 0, \\\"question must exist\\\");\\n        uint32 finalize_ts = questions[question_id].finalize_ts;\\n        require(finalize_ts == UNANSWERED || finalize_ts > uint32(now), \\\"finalization dealine must not have passed\\\");\\n        uint32 opening_ts = questions[question_id].opening_ts;\\n        require(opening_ts == 0 || opening_ts <= uint32(now), \\\"opening date must have passed\\\");\\n        _;\\n    }\\n\\n    modifier stateFinalized(bytes32 question_id) {\\n        require(isFinalized(question_id), \\\"question must be finalized\\\");\\n        _;\\n    }\\n\\n    modifier bondMustDouble(bytes32 question_id, uint256 tokens) {\\n        require(tokens > 0, \\\"bond must be positive\\\");\\n        require(tokens >= (questions[question_id].bond.mul(2)), \\\"bond must be double at least previous bond\\\");\\n        _;\\n    }\\n\\n    modifier previousBondMustNotBeatMaxPrevious(bytes32 question_id, uint256 max_previous) {\\n        if (max_previous > 0) {\\n            require(questions[question_id].bond <= max_previous, \\\"bond must exceed max_previous\\\");\\n        }\\n        _;\\n    }\\n\\n    function setToken(IERC20 _token)\\n    public\\n    {\\n        require(token == IERC20(0x0), \\\"Token can only be initialized once\\\");\\n        token = _token;\\n    }\\n\\n    /// @notice Constructor, sets up some initial templates\\n    /// @dev Creates some generalized templates for different question types used in the DApp.\\n    constructor()\\n    public {\\n        createTemplate('{\\\"title\\\": \\\"%s\\\", \\\"type\\\": \\\"bool\\\", \\\"category\\\": \\\"%s\\\", \\\"lang\\\": \\\"%s\\\"}');\\n        createTemplate('{\\\"title\\\": \\\"%s\\\", \\\"type\\\": \\\"uint\\\", \\\"decimals\\\": 18, \\\"category\\\": \\\"%s\\\", \\\"lang\\\": \\\"%s\\\"}');\\n        createTemplate('{\\\"title\\\": \\\"%s\\\", \\\"type\\\": \\\"single-select\\\", \\\"outcomes\\\": [%s], \\\"category\\\": \\\"%s\\\", \\\"lang\\\": \\\"%s\\\"}');\\n        createTemplate('{\\\"title\\\": \\\"%s\\\", \\\"type\\\": \\\"multiple-select\\\", \\\"outcomes\\\": [%s], \\\"category\\\": \\\"%s\\\", \\\"lang\\\": \\\"%s\\\"}');\\n        createTemplate('{\\\"title\\\": \\\"%s\\\", \\\"type\\\": \\\"datetime\\\", \\\"category\\\": \\\"%s\\\", \\\"lang\\\": \\\"%s\\\"}');\\n    }\\n\\n    /// @notice Function for arbitrator to set an optional per-question fee.\\n    /// @dev The per-question fee, charged when a question is asked, is intended as an anti-spam measure.\\n    /// @param fee The fee to be charged by the arbitrator when a question is asked\\n    function setQuestionFee(uint256 fee)\\n        stateAny()\\n    external {\\n        arbitrator_question_fees[msg.sender] = fee;\\n        emit LogSetQuestionFee(msg.sender, fee);\\n    }\\n\\n    /// @notice Create a reusable template, which should be a JSON document.\\n    /// Placeholders should use gettext() syntax, eg %s.\\n    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\\n    /// @param content The template content\\n    /// @return The ID of the newly-created template, which is created sequentially.\\n    function createTemplate(string memory content)\\n        stateAny()\\n    public returns (uint256) {\\n        uint256 id = nextTemplateID;\\n        templates[id] = block.number;\\n        template_hashes[id] = keccak256(abi.encodePacked(content));\\n        emit LogNewTemplate(id, msg.sender, content);\\n        nextTemplateID = id.add(1);\\n        return id;\\n    }\\n\\n    /// @notice Create a new reusable template and use it to ask a question\\n    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\\n    /// @param content The template content\\n    /// @param question A string containing the parameters that will be passed into the template to make the question\\n    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\\n    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\\n    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\\n    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\\n    /// @return The ID of the newly-created template, which is created sequentially.\\n    function createTemplateAndAskQuestion(\\n        string memory content,\\n        string memory question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce\\n    )\\n        // stateNotCreated is enforced by the internal _askQuestion\\n    public returns (bytes32) {\\n        uint256 template_id = createTemplate(content);\\n        return askQuestion(template_id, question, arbitrator, timeout, opening_ts, nonce);\\n    }\\n\\n    /// @notice Ask a new question without a bounty and return the ID\\n    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\\n    /// @dev Calling without the token param will only work if there is no arbitrator-set question fee.\\n    /// @dev This has the same function signature as askQuestion() in the non-ERC20 version, which is optionally payable.\\n    /// @param template_id The ID number of the template the question will use\\n    /// @param question A string containing the parameters that will be passed into the template to make the question\\n    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\\n    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\\n    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\\n    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\\n    /// @return The ID of the newly-created question, created deterministically.\\n    function askQuestion(uint256 template_id, string memory question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce)\\n        // stateNotCreated is enforced by the internal _askQuestion\\n    public returns (bytes32) {\\n\\n        require(templates[template_id] > 0, \\\"template must exist\\\");\\n\\n        bytes32 content_hash = keccak256(abi.encodePacked(template_id, opening_ts, question));\\n        bytes32 question_id = keccak256(abi.encodePacked(content_hash, arbitrator, timeout, msg.sender, nonce));\\n\\n        _askQuestion(question_id, content_hash, arbitrator, timeout, opening_ts, 0);\\n        emit LogNewQuestion(question_id, msg.sender, template_id, question, content_hash, arbitrator, timeout, opening_ts, nonce, now);\\n\\n        return question_id;\\n    }\\n\\n    /// @notice Ask a new question with a bounty and return the ID\\n    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\\n    /// @param template_id The ID number of the template the question will use\\n    /// @param question A string containing the parameters that will be passed into the template to make the question\\n    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\\n    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\\n    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\\n    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\\n    /// @param tokens The combined initial question bounty and question fee\\n    /// @return The ID of the newly-created question, created deterministically.\\n    function askQuestionERC20(uint256 template_id, string memory question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 tokens)\\n        // stateNotCreated is enforced by the internal _askQuestion\\n    public returns (bytes32) {\\n\\n        _deductTokensOrRevert(tokens);\\n\\n        require(templates[template_id] > 0, \\\"template must exist\\\");\\n\\n        bytes32 content_hash = keccak256(abi.encodePacked(template_id, opening_ts, question));\\n        bytes32 question_id = keccak256(abi.encodePacked(content_hash, arbitrator, timeout, msg.sender, nonce));\\n\\n        _askQuestion(question_id, content_hash, arbitrator, timeout, opening_ts, tokens);\\n        emit LogNewQuestion(question_id, msg.sender, template_id, question, content_hash, arbitrator, timeout, opening_ts, nonce, now);\\n\\n        return question_id;\\n    }\\n\\n    function _deductTokensOrRevert(uint256 tokens)\\n    internal {\\n\\n        if (tokens == 0) {\\n            return;\\n        }\\n\\n        uint256 bal = balanceOf[msg.sender];\\n\\n        // Deduct any tokens you have in your internal balance first\\n        if (bal > 0) {\\n            if (bal >= tokens) {\\n                balanceOf[msg.sender] = bal.sub(tokens);\\n                return;\\n            } else {\\n                tokens = tokens.sub(bal);\\n                balanceOf[msg.sender] = 0;\\n            }\\n        }\\n        // Now we need to charge the rest from\\n        require(token.transferFrom(msg.sender, address(this), tokens), \\\"Transfer of tokens failed, insufficient approved balance?\\\");\\n        return;\\n\\n    }\\n\\n    function _askQuestion(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 tokens)\\n        stateNotCreated(question_id)\\n    internal {\\n\\n        uint256 bounty = tokens;\\n\\n        // A timeout of 0 makes no sense, and we will use this to check existence\\n        require(timeout > 0, \\\"timeout must be positive\\\");\\n        require(timeout < 365 days, \\\"timeout must be less than 365 days\\\");\\n        require(arbitrator != NULL_ADDRESS, \\\"arbitrator must be set\\\");\\n\\n        // The arbitrator can set a fee for asking a question.\\n        // This is intended as an anti-spam defence.\\n        // The fee is waived if the arbitrator is asking the question.\\n        // This allows them to set an impossibly high fee and make users proxy the question through them.\\n        // This would allow more sophisticated pricing, question whitelisting etc.\\n        if (msg.sender != arbitrator) {\\n            uint256 question_fee = arbitrator_question_fees[arbitrator];\\n            require(bounty >= question_fee, \\\"Tokens provided must cover question fee\\\");\\n            bounty = bounty.sub(question_fee);\\n            balanceOf[arbitrator] = balanceOf[arbitrator].add(question_fee);\\n        }\\n\\n        questions[question_id].content_hash = content_hash;\\n        questions[question_id].arbitrator = arbitrator;\\n        questions[question_id].opening_ts = opening_ts;\\n        questions[question_id].timeout = timeout;\\n        questions[question_id].bounty = bounty;\\n\\n    }\\n\\n    /// @notice Add funds to the bounty for a question\\n    /// @dev Add bounty funds after the initial question creation. Can be done any time until the question is finalized.\\n    /// @param question_id The ID of the question you wish to fund\\n    /// @param tokens The number of tokens to fund\\n    function fundAnswerBountyERC20(bytes32 question_id, uint256 tokens)\\n        stateOpen(question_id)\\n    external {\\n        _deductTokensOrRevert(tokens);\\n        questions[question_id].bounty = questions[question_id].bounty.add(tokens);\\n        emit LogFundAnswerBounty(question_id, tokens, questions[question_id].bounty, msg.sender);\\n    }\\n\\n    /// @notice Submit an answer for a question.\\n    /// @dev Adds the answer to the history and updates the current \\\"best\\\" answer.\\n    /// May be subject to front-running attacks; Substitute submitAnswerCommitment()->submitAnswerReveal() to prevent them.\\n    /// @param question_id The ID of the question\\n    /// @param answer The answer, encoded into bytes32\\n    /// @param max_previous If specified, reverts if a bond higher than this was submitted after you sent your transaction.\\n    /// @param tokens The amount of tokens to submit\\n    function submitAnswerERC20(bytes32 question_id, bytes32 answer, uint256 max_previous, uint256 tokens)\\n        stateOpen(question_id)\\n        bondMustDouble(question_id, tokens)\\n        previousBondMustNotBeatMaxPrevious(question_id, max_previous)\\n    external {\\n        _deductTokensOrRevert(tokens);\\n        _addAnswerToHistory(question_id, answer, msg.sender, tokens, false);\\n        _updateCurrentAnswer(question_id, answer, questions[question_id].timeout);\\n    }\\n\\n    // @notice Verify and store a commitment, including an appropriate timeout\\n    // @param question_id The ID of the question to store\\n    // @param commitment The ID of the commitment\\n    function _storeCommitment(bytes32 question_id, bytes32 commitment_id)\\n    internal\\n    {\\n        require(commitments[commitment_id].reveal_ts == COMMITMENT_NON_EXISTENT, \\\"commitment must not already exist\\\");\\n\\n        uint32 commitment_timeout = questions[question_id].timeout / COMMITMENT_TIMEOUT_RATIO;\\n        commitments[commitment_id].reveal_ts = uint32(now).add(commitment_timeout);\\n    }\\n\\n    /// @notice Submit the hash of an answer, laying your claim to that answer if you reveal it in a subsequent transaction.\\n    /// @dev Creates a hash, commitment_id, uniquely identifying this answer, to this question, with this bond.\\n    /// The commitment_id is stored in the answer history where the answer would normally go.\\n    /// Does not update the current best answer - this is left to the later submitAnswerReveal() transaction.\\n    /// @param question_id The ID of the question\\n    /// @param answer_hash The hash of your answer, plus a nonce that you will later reveal\\n    /// @param max_previous If specified, reverts if a bond higher than this was submitted after you sent your transaction.\\n    /// @param _answerer If specified, the address to be given as the question answerer. Defaults to the sender.\\n    /// @param tokens Number of tokens sent\\n    /// @dev Specifying the answerer is useful if you want to delegate the commit-and-reveal to a third-party.\\n    function submitAnswerCommitmentERC20(bytes32 question_id, bytes32 answer_hash, uint256 max_previous, address _answerer, uint256 tokens)\\n        stateOpen(question_id)\\n        bondMustDouble(question_id, tokens)\\n        previousBondMustNotBeatMaxPrevious(question_id, max_previous)\\n    external {\\n\\n        _deductTokensOrRevert(tokens);\\n\\n        bytes32 commitment_id = keccak256(abi.encodePacked(question_id, answer_hash, tokens));\\n        address answerer = (_answerer == NULL_ADDRESS) ? msg.sender : _answerer;\\n\\n        _storeCommitment(question_id, commitment_id);\\n        _addAnswerToHistory(question_id, commitment_id, answerer, tokens, true);\\n\\n    }\\n\\n    /// @notice Submit the answer whose hash you sent in a previous submitAnswerCommitment() transaction\\n    /// @dev Checks the parameters supplied recreate an existing commitment, and stores the revealed answer\\n    /// Updates the current answer unless someone has since supplied a new answer with a higher bond\\n    /// msg.sender is intentionally not restricted to the user who originally sent the commitment;\\n    /// For example, the user may want to provide the answer+nonce to a third-party service and let them send the tx\\n    /// NB If we are pending arbitration, it will be up to the arbitrator to wait and see any outstanding reveal is sent\\n    /// @param question_id The ID of the question\\n    /// @param answer The answer, encoded as bytes32\\n    /// @param nonce The nonce that, combined with the answer, recreates the answer_hash you gave in submitAnswerCommitment()\\n    /// @param bond The bond that you paid in your submitAnswerCommitment() transaction\\n    function submitAnswerReveal(bytes32 question_id, bytes32 answer, uint256 nonce, uint256 bond)\\n        stateOpenOrPendingArbitration(question_id)\\n    external {\\n\\n        bytes32 answer_hash = keccak256(abi.encodePacked(answer, nonce));\\n        bytes32 commitment_id = keccak256(abi.encodePacked(question_id, answer_hash, bond));\\n\\n        require(!commitments[commitment_id].is_revealed, \\\"commitment must not have been revealed yet\\\");\\n        require(commitments[commitment_id].reveal_ts > uint32(now), \\\"reveal deadline must not have passed\\\");\\n\\n        commitments[commitment_id].revealed_answer = answer;\\n        commitments[commitment_id].is_revealed = true;\\n\\n        if (bond == questions[question_id].bond) {\\n            _updateCurrentAnswer(question_id, answer, questions[question_id].timeout);\\n        }\\n\\n        emit LogAnswerReveal(question_id, msg.sender, answer_hash, answer, nonce, bond);\\n\\n    }\\n\\n    function _addAnswerToHistory(bytes32 question_id, bytes32 answer_or_commitment_id, address answerer, uint256 bond, bool is_commitment)\\n    internal\\n    {\\n        bytes32 new_history_hash = keccak256(abi.encodePacked(questions[question_id].history_hash, answer_or_commitment_id, bond, answerer, is_commitment));\\n\\n        // Update the current bond level, if there's a bond (ie anything except arbitration)\\n        if (bond > 0) {\\n            questions[question_id].bond = bond;\\n        }\\n        questions[question_id].history_hash = new_history_hash;\\n\\n        emit LogNewAnswer(answer_or_commitment_id, question_id, new_history_hash, answerer, bond, now, is_commitment);\\n    }\\n\\n    function _updateCurrentAnswer(bytes32 question_id, bytes32 answer, uint32 timeout_secs)\\n    internal {\\n        questions[question_id].best_answer = answer;\\n        questions[question_id].finalize_ts = uint32(now).add(timeout_secs);\\n    }\\n\\n    /// @notice Notify the contract that the arbitrator has been paid for a question, freezing it pending their decision.\\n    /// @dev The arbitrator contract is trusted to only call this if they've been paid, and tell us who paid them.\\n    /// @param question_id The ID of the question\\n    /// @param requester The account that requested arbitration\\n    /// @param max_previous If specified, reverts if a bond higher than this was submitted after you sent your transaction.\\n    function notifyOfArbitrationRequest(bytes32 question_id, address requester, uint256 max_previous)\\n        onlyArbitrator(question_id)\\n        stateOpen(question_id)\\n        previousBondMustNotBeatMaxPrevious(question_id, max_previous)\\n    external {\\n        require(questions[question_id].bond > 0, \\\"Question must already have an answer when arbitration is requested\\\");\\n        questions[question_id].is_pending_arbitration = true;\\n        emit LogNotifyOfArbitrationRequest(question_id, requester);\\n    }\\n\\n    /// @notice Submit the answer for a question, for use by the arbitrator.\\n    /// @dev Doesn't require (or allow) a bond.\\n    /// If the current final answer is correct, the account should be whoever submitted it.\\n    /// If the current final answer is wrong, the account should be whoever paid for arbitration.\\n    /// However, the answerer stipulations are not enforced by the contract.\\n    /// @param question_id The ID of the question\\n    /// @param answer The answer, encoded into bytes32\\n    /// @param answerer The account credited with this answer for the purpose of bond claims\\n    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer)\\n        onlyArbitrator(question_id)\\n        statePendingArbitration(question_id)\\n    external {\\n\\n        require(answerer != NULL_ADDRESS, \\\"answerer must be provided\\\");\\n        emit LogFinalize(question_id, answer);\\n\\n        questions[question_id].is_pending_arbitration = false;\\n        _addAnswerToHistory(question_id, answer, answerer, 0, false);\\n        _updateCurrentAnswer(question_id, answer, 0);\\n\\n    }\\n\\n    /// @notice Report whether the answer to the specified question is finalized\\n    /// @param question_id The ID of the question\\n    /// @return Return true if finalized\\n    function isFinalized(bytes32 question_id)\\n    view public returns (bool) {\\n        uint32 finalize_ts = questions[question_id].finalize_ts;\\n        return ( !questions[question_id].is_pending_arbitration && (finalize_ts > UNANSWERED) && (finalize_ts <= uint32(now)) );\\n    }\\n\\n    /// @notice (Deprecated) Return the final answer to the specified question, or revert if there isn't one\\n    /// @param question_id The ID of the question\\n    /// @return The answer formatted as a bytes32\\n    function getFinalAnswer(bytes32 question_id)\\n        stateFinalized(question_id)\\n    external view returns (bytes32) {\\n        return questions[question_id].best_answer;\\n    }\\n\\n    /// @notice Return the final answer to the specified question, or revert if there isn't one\\n    /// @param question_id The ID of the question\\n    /// @return The answer formatted as a bytes32\\n    function resultFor(bytes32 question_id)\\n        stateFinalized(question_id)\\n    external view returns (bytes32) {\\n        return questions[question_id].best_answer;\\n    }\\n\\n\\n    /// @notice Return the final answer to the specified question, provided it matches the specified criteria.\\n    /// @dev Reverts if the question is not finalized, or if it does not match the specified criteria.\\n    /// @param question_id The ID of the question\\n    /// @param content_hash The hash of the question content (template ID + opening time + question parameter string)\\n    /// @param arbitrator The arbitrator chosen for the question (regardless of whether they are asked to arbitrate)\\n    /// @param min_timeout The timeout set in the initial question settings must be this high or higher\\n    /// @param min_bond The bond sent with the final answer must be this high or higher\\n    /// @return The answer formatted as a bytes32\\n    function getFinalAnswerIfMatches(\\n        bytes32 question_id,\\n        bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond\\n    )\\n        stateFinalized(question_id)\\n    external view returns (bytes32) {\\n        require(content_hash == questions[question_id].content_hash, \\\"content hash must match\\\");\\n        require(arbitrator == questions[question_id].arbitrator, \\\"arbitrator must match\\\");\\n        require(min_timeout <= questions[question_id].timeout, \\\"timeout must be long enough\\\");\\n        require(min_bond <= questions[question_id].bond, \\\"bond must be high enough\\\");\\n        return questions[question_id].best_answer;\\n    }\\n\\n    /// @notice Assigns the winnings (bounty and bonds) to everyone who gave the accepted answer\\n    /// Caller must provide the answer history, in reverse order\\n    /// @dev Works up the chain and assign bonds to the person who gave the right answer\\n    /// If someone gave the winning answer earlier, they must get paid from the higher bond\\n    /// That means we can't pay out the bond added at n until we have looked at n-1\\n    /// The first answer is authenticated by checking against the stored history_hash.\\n    /// One of the inputs to history_hash is the history_hash before it, so we use that to authenticate the next entry, etc\\n    /// Once we get to a null hash we'll know we're done and there are no more answers.\\n    /// Usually you would call the whole thing in a single transaction, but if not then the data is persisted to pick up later.\\n    /// @param question_id The ID of the question\\n    /// @param history_hashes Second-last-to-first, the hash of each history entry. (Final one should be empty).\\n    /// @param addrs Last-to-first, the address of each answerer or commitment sender\\n    /// @param bonds Last-to-first, the bond supplied with each answer or commitment\\n    /// @param answers Last-to-first, each answer supplied, or commitment ID if the answer was supplied with commit->reveal\\n    function claimWinnings(\\n        bytes32 question_id,\\n        bytes32[] memory history_hashes, address[] memory addrs, uint256[] memory bonds, bytes32[] memory answers\\n    )\\n        stateFinalized(question_id)\\n    public {\\n\\n        require(history_hashes.length > 0, \\\"at least one history hash entry must be provided\\\");\\n\\n        // These are only set if we split our claim over multiple transactions.\\n        address payee = question_claims[question_id].payee;\\n        uint256 last_bond = question_claims[question_id].last_bond;\\n        uint256 queued_funds = question_claims[question_id].queued_funds;\\n\\n        // Starts as the hash of the final answer submitted. It'll be cleared when we're done.\\n        // If we're splitting the claim over multiple transactions, it'll be the hash where we left off last time\\n        bytes32 last_history_hash = questions[question_id].history_hash;\\n\\n        bytes32 best_answer = questions[question_id].best_answer;\\n\\n        uint256 i;\\n        for (i = 0; i < history_hashes.length; i++) {\\n\\n            // Check input against the history hash, and see which of 2 possible values of is_commitment fits.\\n            bool is_commitment = _verifyHistoryInputOrRevert(last_history_hash, history_hashes[i], answers[i], bonds[i], addrs[i]);\\n\\n            queued_funds = queued_funds.add(last_bond);\\n            (queued_funds, payee) = _processHistoryItem(\\n                question_id, best_answer, queued_funds, payee,\\n                addrs[i], bonds[i], answers[i], is_commitment);\\n\\n            // Line the bond up for next time, when it will be added to somebody's queued_funds\\n            last_bond = bonds[i];\\n            last_history_hash = history_hashes[i];\\n\\n        }\\n\\n        if (last_history_hash != NULL_HASH) {\\n            // We haven't yet got to the null hash (1st answer), ie the caller didn't supply the full answer chain.\\n            // Persist the details so we can pick up later where we left off later.\\n\\n            // If we know who to pay we can go ahead and pay them out, only keeping back last_bond\\n            // (We always know who to pay unless all we saw were unrevealed commits)\\n            if (payee != NULL_ADDRESS) {\\n                _payPayee(question_id, payee, queued_funds);\\n                queued_funds = 0;\\n            }\\n\\n            question_claims[question_id].payee = payee;\\n            question_claims[question_id].last_bond = last_bond;\\n            question_claims[question_id].queued_funds = queued_funds;\\n        } else {\\n            // There is nothing left below us so the payee can keep what remains\\n            _payPayee(question_id, payee, queued_funds.add(last_bond));\\n            delete question_claims[question_id];\\n        }\\n\\n        questions[question_id].history_hash = last_history_hash;\\n\\n    }\\n\\n    function _payPayee(bytes32 question_id, address payee, uint256 value)\\n    internal {\\n        balanceOf[payee] = balanceOf[payee].add(value);\\n        emit LogClaim(question_id, payee, value);\\n    }\\n\\n    function _verifyHistoryInputOrRevert(\\n        bytes32 last_history_hash,\\n        bytes32 history_hash, bytes32 answer, uint256 bond, address addr\\n    )\\n    internal pure returns (bool) {\\n        if (last_history_hash == keccak256(abi.encodePacked(history_hash, answer, bond, addr, true)) ) {\\n            return true;\\n        }\\n        if (last_history_hash == keccak256(abi.encodePacked(history_hash, answer, bond, addr, false)) ) {\\n            return false;\\n        }\\n        revert(\\\"History input provided did not match the expected hash\\\");\\n    }\\n\\n    function _processHistoryItem(\\n        bytes32 question_id, bytes32 best_answer,\\n        uint256 queued_funds, address payee,\\n        address addr, uint256 bond, bytes32 answer, bool is_commitment\\n    )\\n    internal returns (uint256, address) {\\n\\n        // For commit-and-reveal, the answer history holds the commitment ID instead of the answer.\\n        // We look at the referenced commitment ID and switch in the actual answer.\\n        if (is_commitment) {\\n            bytes32 commitment_id = answer;\\n            // If it's a commit but it hasn't been revealed, it will always be considered wrong.\\n            if (!commitments[commitment_id].is_revealed) {\\n                delete commitments[commitment_id];\\n                return (queued_funds, payee);\\n            } else {\\n                answer = commitments[commitment_id].revealed_answer;\\n                delete commitments[commitment_id];\\n            }\\n        }\\n\\n        if (answer == best_answer) {\\n\\n            if (payee == NULL_ADDRESS) {\\n\\n                // The entry is for the first payee we come to, ie the winner.\\n                // They get the question bounty.\\n                payee = addr;\\n                queued_funds = queued_funds.add(questions[question_id].bounty);\\n                questions[question_id].bounty = 0;\\n\\n            } else if (addr != payee) {\\n\\n                // Answerer has changed, ie we found someone lower down who needs to be paid\\n\\n                // The lower answerer will take over receiving bonds from higher answerer.\\n                // They should also be paid the takeover fee, which is set at a rate equivalent to their bond.\\n                // (This is our arbitrary rule, to give consistent right-answerers a defence against high-rollers.)\\n\\n                // There should be enough for the fee, but if not, take what we have.\\n                // There's an edge case involving weird arbitrator behaviour where we may be short.\\n                uint256 answer_takeover_fee = (queued_funds >= bond) ? bond : queued_funds;\\n\\n                // Settle up with the old (higher-bonded) payee\\n                _payPayee(question_id, payee, queued_funds.sub(answer_takeover_fee));\\n\\n                // Now start queued_funds again for the new (lower-bonded) payee\\n                payee = addr;\\n                queued_funds = answer_takeover_fee;\\n\\n            }\\n\\n        }\\n\\n        return (queued_funds, payee);\\n\\n    }\\n\\n    /// @notice Convenience function to assign bounties/bonds for multiple questions in one go, then withdraw all your funds.\\n    /// Caller must provide the answer history for each question, in reverse order\\n    /// @dev Can be called by anyone to assign bonds/bounties, but funds are only withdrawn for the user making the call.\\n    /// @param question_ids The IDs of the questions you want to claim for\\n    /// @param lengths The number of history entries you will supply for each question ID\\n    /// @param hist_hashes In a single list for all supplied questions, the hash of each history entry.\\n    /// @param addrs In a single list for all supplied questions, the address of each answerer or commitment sender\\n    /// @param bonds In a single list for all supplied questions, the bond supplied with each answer or commitment\\n    /// @param answers In a single list for all supplied questions, each answer supplied, or commitment ID\\n    function claimMultipleAndWithdrawBalance(\\n        bytes32[] memory question_ids, uint256[] memory lengths,\\n        bytes32[] memory hist_hashes, address[] memory addrs, uint256[] memory bonds, bytes32[] memory answers\\n    )\\n        stateAny() // The finalization checks are done in the claimWinnings function\\n    public {\\n\\n        uint256 qi;\\n        uint256 i;\\n        for (qi = 0; qi < question_ids.length; qi++) {\\n            bytes32 qid = question_ids[qi];\\n            uint256 ln = lengths[qi];\\n            bytes32[] memory hh = new bytes32[](ln);\\n            address[] memory ad = new address[](ln);\\n            uint256[] memory bo = new uint256[](ln);\\n            bytes32[] memory an = new bytes32[](ln);\\n            uint256 j;\\n            for (j = 0; j < ln; j++) {\\n                hh[j] = hist_hashes[i];\\n                ad[j] = addrs[i];\\n                bo[j] = bonds[i];\\n                an[j] = answers[i];\\n                i++;\\n            }\\n            claimWinnings(qid, hh, ad, bo, an);\\n        }\\n        withdraw();\\n    }\\n\\n    /// @notice Returns the questions's content hash, identifying the question content\\n    /// @param question_id The ID of the question\\n    function getContentHash(bytes32 question_id)\\n    public view returns(bytes32) {\\n        return questions[question_id].content_hash;\\n    }\\n\\n    /// @notice Returns the arbitrator address for the question\\n    /// @param question_id The ID of the question\\n    function getArbitrator(bytes32 question_id)\\n    public view returns(address) {\\n        return questions[question_id].arbitrator;\\n    }\\n\\n    /// @notice Returns the timestamp when the question can first be answered\\n    /// @param question_id The ID of the question\\n    function getOpeningTS(bytes32 question_id)\\n    public view returns(uint32) {\\n        return questions[question_id].opening_ts;\\n    }\\n\\n    /// @notice Returns the timeout in seconds used after each answer\\n    /// @param question_id The ID of the question\\n    function getTimeout(bytes32 question_id)\\n    public view returns(uint32) {\\n        return questions[question_id].timeout;\\n    }\\n\\n    /// @notice Returns the timestamp at which the question will be/was finalized\\n    /// @param question_id The ID of the question\\n    function getFinalizeTS(bytes32 question_id)\\n    public view returns(uint32) {\\n        return questions[question_id].finalize_ts;\\n    }\\n\\n    /// @notice Returns whether the question is pending arbitration\\n    /// @param question_id The ID of the question\\n    function isPendingArbitration(bytes32 question_id)\\n    public view returns(bool) {\\n        return questions[question_id].is_pending_arbitration;\\n    }\\n\\n    /// @notice Returns the current total unclaimed bounty\\n    /// @dev Set back to zero once the bounty has been claimed\\n    /// @param question_id The ID of the question\\n    function getBounty(bytes32 question_id)\\n    public view returns(uint256) {\\n        return questions[question_id].bounty;\\n    }\\n\\n    /// @notice Returns the current best answer\\n    /// @param question_id The ID of the question\\n    function getBestAnswer(bytes32 question_id)\\n    public view returns(bytes32) {\\n        return questions[question_id].best_answer;\\n    }\\n\\n    /// @notice Returns the history hash of the question\\n    /// @param question_id The ID of the question\\n    /// @dev Updated on each answer, then rewound as each is claimed\\n    function getHistoryHash(bytes32 question_id)\\n    public view returns(bytes32) {\\n        return questions[question_id].history_hash;\\n    }\\n\\n    /// @notice Returns the highest bond posted so far for a question\\n    /// @param question_id The ID of the question\\n    function getBond(bytes32 question_id)\\n    public view returns(uint256) {\\n        return questions[question_id].bond;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_requiredBalance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_realitioAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_realitioTimeout\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum PredictionMarket.MarketAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outcomeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"MarketActionTx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outcomes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"question\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"image\",\"type\":\"string\"}],\"name\":\"MarketCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"MarketLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"outcomeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"MarketOutcomePrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outcomeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"MarketResolved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_UINT_256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outcomeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOutcomeSharesToBuy\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outcomeId\",\"type\":\"uint256\"}],\"name\":\"calcBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outcomeId\",\"type\":\"uint256\"}],\"name\":\"calcSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outcomeTokenSellAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"claimFees\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"claimLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outcomeId\",\"type\":\"uint256\"}],\"name\":\"claimVoidedOutcomeShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"claimWinnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"question\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"image\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"closesAt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outcomes\",\"type\":\"uint256\"}],\"name\":\"createMarket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getMarketAltData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getMarketData\",\"outputs\":[{\"internalType\":\"enum PredictionMarket.MarketState\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getMarketLiquidityPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outcomeId\",\"type\":\"uint256\"}],\"name\":\"getMarketOutcomeData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getMarketOutcomeIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outcomeId\",\"type\":\"uint256\"}],\"name\":\"getMarketOutcomePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getMarketPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getMarketQuestion\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getMarketResolvedOutcome\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarkets\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserClaimStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserClaimableFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserLiquidityPoolShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserMarketShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"isMarketVoided\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"realitioAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"realitioTimeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requiredBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"resolveMarketOutcome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outcomeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxOutcomeSharesToSell\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PredictionMarket", "CompilerVersion": "v0.6.2+commit.bacdbe57", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "00000000000000000000000000000000000000000000000000b1a2bc2ec500000000000000000000000000003b484b82567a09e2588a13d54d032153f0c0aee000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000fa443f0ec4aed3e87c6d608ecf737a83d950427b000000000000000000000000000000000000000000000000000000000003f480000000000000000000000000578ff4c0ee51bdc90e8acc9990cd09a897ef36ab", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}