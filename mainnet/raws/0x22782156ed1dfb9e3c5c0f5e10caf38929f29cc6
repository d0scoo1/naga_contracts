{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.4;\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n\ninterface ICodex {\n    function init(address vault) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address,\n        bytes32,\n        uint256\n    ) external;\n\n    function credit(address) external view returns (uint256);\n\n    function unbackedDebt(address) external view returns (uint256);\n\n    function balances(\n        address,\n        uint256,\n        address\n    ) external view returns (uint256);\n\n    function vaults(address vault)\n        external\n        view\n        returns (\n            uint256 totalNormalDebt,\n            uint256 rate,\n            uint256 debtCeiling,\n            uint256 debtFloor\n        );\n\n    function positions(\n        address vault,\n        uint256 tokenId,\n        address position\n    ) external view returns (uint256 collateral, uint256 normalDebt);\n\n    function globalDebt() external view returns (uint256);\n\n    function globalUnbackedDebt() external view returns (uint256);\n\n    function globalDebtCeiling() external view returns (uint256);\n\n    function delegates(address, address) external view returns (uint256);\n\n    function grantDelegate(address) external;\n\n    function revokeDelegate(address) external;\n\n    function modifyBalance(\n        address,\n        uint256,\n        address,\n        int256\n    ) external;\n\n    function transferBalance(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function transferCredit(\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function modifyCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function transferCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function confiscateCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function settleUnbackedDebt(uint256 debt) external;\n\n    function createUnbackedDebt(\n        address debtor,\n        address creditor,\n        uint256 debt\n    ) external;\n\n    function modifyRate(\n        address vault,\n        address creditor,\n        int256 rate\n    ) external;\n\n    function lock() external;\n}interface IPriceFeed {\n    function peek() external returns (bytes32, bool);\n\n    function read() external view returns (bytes32);\n}\n\ninterface ICollybus {\n    function vaults(address) external view returns (uint128, uint128);\n\n    function spots(address) external view returns (uint256);\n\n    function rates(uint256) external view returns (uint256);\n\n    function rateIds(address, uint256) external view returns (uint256);\n\n    function redemptionPrice() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint128 data\n    ) external;\n\n    function setParam(\n        address vault,\n        uint256 tokenId,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function updateDiscountRate(uint256 rateId, uint256 rate) external;\n\n    function updateSpot(address token, uint256 spot) external;\n\n    function read(\n        address vault,\n        address underlier,\n        uint256 tokenId,\n        uint256 maturity,\n        bool net\n    ) external view returns (uint256 price);\n\n    function lock() external;\n}\n\ninterface IVault {\n    function codex() external view returns (ICodex);\n\n    function collybus() external view returns (ICollybus);\n\n    function token() external view returns (address);\n\n    function tokenScale() external view returns (uint256);\n\n    function underlierToken() external view returns (address);\n\n    function underlierScale() external view returns (uint256);\n\n    function vaultType() external view returns (bytes32);\n\n    function live() external view returns (uint256);\n\n    function lock() external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function maturity(uint256 tokenId) external returns (uint256);\n\n    function fairPrice(\n        uint256 tokenId,\n        bool net,\n        bool face\n    ) external view returns (uint256);\n\n    function enter(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n\n    function exit(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n}\ninterface IGuarded {\n    function ANY_SIG() external view returns (bytes32);\n\n    function ANY_CALLER() external view returns (address);\n\n    function allowCaller(bytes32 sig, address who) external;\n\n    function blockCaller(bytes32 sig, address who) external;\n\n    function canCall(bytes32 sig, address who) external view returns (bool);\n}\n/// @title Guarded\n/// @notice Mixin implementing an authentication scheme on a method level\nabstract contract Guarded is IGuarded {\n    /// ======== Custom Errors ======== ///\n\n    error Guarded__notRoot();\n    error Guarded__notGranted();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Wildcard for granting a caller to call every guarded method\n    bytes32 public constant override ANY_SIG = keccak256(\"ANY_SIG\");\n    /// @notice Wildcard for granting a caller to call every guarded method\n    address public constant override ANY_CALLER = address(uint160(uint256(bytes32(keccak256(\"ANY_CALLER\")))));\n\n    /// @notice Mapping storing who is granted to which method\n    /// @dev Method Signature => Caller => Bool\n    mapping(bytes32 => mapping(address => bool)) private _canCall;\n\n    /// ======== Events ======== ///\n\n    event AllowCaller(bytes32 sig, address who);\n    event BlockCaller(bytes32 sig, address who);\n\n    constructor() {\n        // set root\n        _setRoot(msg.sender);\n    }\n\n    /// ======== Auth ======== ///\n\n    modifier callerIsRoot() {\n        if (_canCall[ANY_SIG][msg.sender]) {\n            _;\n        } else revert Guarded__notRoot();\n    }\n\n    modifier checkCaller() {\n        if (canCall(msg.sig, msg.sender)) {\n            _;\n        } else revert Guarded__notGranted();\n    }\n\n    /// @notice Grant the right to call method `sig` to `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function allowCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = true;\n        emit AllowCaller(sig, who);\n    }\n\n    /// @notice Revoke the right to call method `sig` from `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should not be able to call `sig` anymore\n    function blockCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = false;\n        emit BlockCaller(sig, who);\n    }\n\n    /// @notice Returns if `who` can call `sig`\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function canCall(bytes32 sig, address who) public view override returns (bool) {\n        return (_canCall[sig][who] || _canCall[ANY_SIG][who] || _canCall[sig][ANY_CALLER]);\n    }\n\n    /// @notice Sets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be set as root\n    function _setRoot(address root) internal {\n        _canCall[ANY_SIG][root] = true;\n        emit AllowCaller(ANY_SIG, root);\n    }\n\n    /// @notice Unsets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be unset as root\n    function _unsetRoot(address root) internal {\n        _canCall[ANY_SIG][root] = false;\n        emit AllowCaller(ANY_SIG, root);\n    }\n}// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n\nuint256 constant MLN = 10**6;\nuint256 constant BLN = 10**9;\nuint256 constant WAD = 10**18;\nuint256 constant RAY = 10**18;\nuint256 constant RAD = 10**18;\n\n/* solhint-disable func-visibility, no-inline-assembly */\n\nerror Math__toInt256_overflow(uint256 x);\n\nfunction toInt256(uint256 x) pure returns (int256) {\n    if (x > uint256(type(int256).max)) revert Math__toInt256_overflow(x);\n    return int256(x);\n}\n\nfunction min(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x <= y ? x : y;\n    }\n}\n\nfunction max(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x >= y ? x : y;\n    }\n}\n\nerror Math__diff_overflow(uint256 x, uint256 y);\n\nfunction diff(uint256 x, uint256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) - int256(y);\n        if (!(int256(x) >= 0 && int256(y) >= 0)) revert Math__diff_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow(uint256 x, uint256 y);\n\nfunction add(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add_overflow(x, y);\n    }\n}\n\nerror Math__add48_overflow(uint256 x, uint256 y);\n\nfunction add48(uint48 x, uint48 y) pure returns (uint48 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add48_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow_signed(uint256 x, int256 y);\n\nfunction add(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x + uint256(y);\n        if (!(y >= 0 || z <= x)) revert Math__add_overflow_signed(x, y);\n        if (!(y <= 0 || z >= x)) revert Math__add_overflow_signed(x, y);\n    }\n}\n\nerror Math__sub_overflow(uint256 x, uint256 y);\n\nfunction sub(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x - y) > x) revert Math__sub_overflow(x, y);\n    }\n}\n\nerror Math__sub_overflow_signed(uint256 x, int256 y);\n\nfunction sub(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x - uint256(y);\n        if (!(y <= 0 || z <= x)) revert Math__sub_overflow_signed(x, y);\n        if (!(y >= 0 || z >= x)) revert Math__sub_overflow_signed(x, y);\n    }\n}\n\nerror Math__mul_overflow(uint256 x, uint256 y);\n\nfunction mul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (!(y == 0 || (z = x * y) / y == x)) revert Math__mul_overflow(x, y);\n    }\n}\n\nerror Math__mul_overflow_signed(uint256 x, int256 y);\n\nfunction mul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) * y;\n        if (int256(x) < 0) revert Math__mul_overflow_signed(x, y);\n        if (!(y == 0 || z / y == int256(x))) revert Math__mul_overflow_signed(x, y);\n    }\n}\n\nfunction wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, y) / WAD;\n    }\n}\n\nfunction wmul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = mul(x, y) / int256(WAD);\n    }\n}\n\nerror Math__div_overflow(uint256 x, uint256 y);\n\nfunction div(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (y == 0) revert Math__div_overflow(x, y);\n        return x / y;\n    }\n}\n\nfunction wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, WAD) / y;\n    }\n}\n\n// optimized version from dss PR #78\nfunction wpow(\n    uint256 x,\n    uint256 n,\n    uint256 b\n) pure returns (uint256 z) {\n    unchecked {\n        assembly {\n            switch n\n            case 0 {\n                z := b\n            }\n            default {\n                switch x\n                case 0 {\n                    z := 0\n                }\n                default {\n                    switch mod(n, 2)\n                    case 0 {\n                        z := b\n                    }\n                    default {\n                        z := x\n                    }\n                    let half := div(b, 2) // for rounding.\n                    for {\n                        n := div(n, 2)\n                    } n {\n                        n := div(n, 2)\n                    } {\n                        let xx := mul(x, x)\n                        if shr(128, x) {\n                            revert(0, 0)\n                        }\n                        let xxRound := add(xx, half)\n                        if lt(xxRound, xx) {\n                            revert(0, 0)\n                        }\n                        x := div(xxRound, b)\n                        if mod(n, 2) {\n                            let zx := mul(z, x)\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                                revert(0, 0)\n                            }\n                            let zxRound := add(zx, half)\n                            if lt(zxRound, zx) {\n                                revert(0, 0)\n                            }\n                            z := div(zxRound, b)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/* solhint-disable func-visibility, no-inline-assembly */\n/// @title Codex\n/// @notice `Codex` is responsible for the accounting of collateral and debt balances\n/// Uses Vat.sol from DSS (MakerDAO) / SafeEngine.sol from GEB (Reflexer Labs) as a blueprint\n/// Changes from Vat.sol / SafeEngine.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract Codex is Guarded, ICodex {\n    /// ======== Custom Errors ======== ///\n\n    error Codex__init_vaultAlreadyInit();\n    error Codex__setParam_notLive();\n    error Codex__setParam_unrecognizedParam();\n    error Codex__transferBalance_notAllowed();\n    error Codex__transferCredit_notAllowed();\n    error Codex__modifyCollateralAndDebt_notLive();\n    error Codex__modifyCollateralAndDebt_vaultNotInit();\n    error Codex__modifyCollateralAndDebt_ceilingExceeded();\n    error Codex__modifyCollateralAndDebt_notSafe();\n    error Codex__modifyCollateralAndDebt_notAllowedSender();\n    error Codex__modifyCollateralAndDebt_notAllowedCollateralizer();\n    error Codex__modifyCollateralAndDebt_notAllowedDebtor();\n    error Codex__modifyCollateralAndDebt_debtFloor();\n    error Codex__transferCollateralAndDebt_notAllowed();\n    error Codex__transferCollateralAndDebt_notSafeSrc();\n    error Codex__transferCollateralAndDebt_notSafeDst();\n    error Codex__transferCollateralAndDebt_debtFloorSrc();\n    error Codex__transferCollateralAndDebt_debtFloorDst();\n    error Codex__modifyRate_notLive();\n\n    /// ======== Storage ======== ///\n\n    // Vault Data\n    struct Vault {\n        // Total Normalised Debt in Vault [wad]\n        uint256 totalNormalDebt;\n        // Vault's Accumulation Rate [wad]\n        uint256 rate;\n        // Vault's Debt Ceiling [wad]\n        uint256 debtCeiling;\n        // Debt Floor for Positions corresponding to this Vault [wad]\n        uint256 debtFloor;\n    }\n    // Position Data\n    struct Position {\n        // Locked Collateral in Position [wad]\n        uint256 collateral;\n        // Normalised Debt (gross debt before rate is applied) generated by Position [wad]\n        uint256 normalDebt;\n    }\n\n    /// @notice Map of delegatees who can modify collateral, debt and credit on behalf of a delegator\n    /// @dev Delegator => Delegatee => hasDelegate\n    mapping(address => mapping(address => uint256)) public override delegates;\n    /// @notice Vaults\n    /// @dev Vault => Vault Data\n    mapping(address => Vault) public override vaults;\n    /// @notice Positions\n    /// @dev Vault => TokenId => Owner => Position\n    mapping(address => mapping(uint256 => mapping(address => Position))) public override positions;\n    /// @notice Token balances not put up for collateral in a Position\n    /// @dev Vault => TokenId => Owner => Balance [wad]\n    mapping(address => mapping(uint256 => mapping(address => uint256))) public override balances;\n    /// @notice Credit balances\n    /// @dev Account => Credit [wad]\n    mapping(address => uint256) public override credit;\n    /// @notice Unbacked Debt balances\n    /// @dev Account => Unbacked Debt [wad]\n    mapping(address => uint256) public override unbackedDebt;\n\n    /// @notice Global Debt (incl. rate) outstanding == Credit Issued [wad]\n    uint256 public override globalDebt;\n    /// @notice Global Unbacked Debt (incl. rate) oustanding == Total Credit [wad]\n    uint256 public override globalUnbackedDebt;\n    /// @notice Global Debt Ceiling [wad]\n    uint256 public override globalDebtCeiling;\n\n    /// @notice Boolean indicating if this contract is live (0 - not live, 1 - live)\n    uint256 public live;\n\n    /// ======== Events ======== ///\n    event Init(address indexed vault);\n    event SetParam(address indexed vault, bytes32 indexed param, uint256 data);\n    event GrantDelegate(address indexed delegator, address indexed delegatee);\n    event RevokeDelegate(address indexed delegator, address indexed delegatee);\n    event ModifyBalance(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        int256 amount,\n        uint256 balance\n    );\n    event TransferBalance(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed src,\n        address dst,\n        uint256 amount,\n        uint256 srcBalance,\n        uint256 dstBalance\n    );\n    event TransferCredit(\n        address indexed src,\n        address indexed dst,\n        uint256 amount,\n        uint256 srcCredit,\n        uint256 dstCredit\n    );\n    event ModifyCollateralAndDebt(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        address collateralizer,\n        address creditor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    );\n    event TransferCollateralAndDebt(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    );\n    event ConfiscateCollateralAndDebt(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    );\n    event SettleUnbackedDebt(address indexed debtor, uint256 debt);\n    event CreateUnbackedDebt(address indexed debtor, address indexed creditor, uint256 debt);\n    event ModifyRate(address indexed vault, address indexed creditor, int256 deltaRate);\n    event Lock();\n\n    constructor() Guarded() {\n        live = 1;\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Initializes a new Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    function init(address vault) external override checkCaller {\n        if (vaults[vault].rate != 0) revert Codex__init_vaultAlreadyInit();\n        vaults[vault].rate = WAD;\n        emit Init(vault);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (live == 0) revert Codex__setParam_notLive();\n        if (param == \"globalDebtCeiling\") globalDebtCeiling = data;\n        else revert Codex__setParam_unrecognizedParam();\n        emit SetParam(address(0), param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external override checkCaller {\n        if (live == 0) revert Codex__setParam_notLive();\n        if (param == \"debtCeiling\") vaults[vault].debtCeiling = data;\n        else if (param == \"debtFloor\") vaults[vault].debtFloor = data;\n        else revert Codex__setParam_unrecognizedParam();\n        emit SetParam(vault, param, data);\n    }\n\n    /// ======== Caller Delegation ======== ///\n\n    /// @notice Grants the delegatee the ability to modify collateral, debt and credit balances on behalf of the caller\n    /// @param delegatee Address of the delegatee\n    function grantDelegate(address delegatee) external override {\n        delegates[msg.sender][delegatee] = 1;\n        emit GrantDelegate(msg.sender, delegatee);\n    }\n\n    /// @notice Revokes the delegatee's ability to modify collateral, debt and credit balances on behalf of the caller\n    /// @param delegatee Address of the delegatee\n    function revokeDelegate(address delegatee) external override {\n        delegates[msg.sender][delegatee] = 0;\n        emit RevokeDelegate(msg.sender, delegatee);\n    }\n\n    /// @notice Checks the delegate\n    /// @param delegator Address of the delegator\n    /// @param delegatee Address of the delegatee\n    /// @return True if delegate is granted\n    function hasDelegate(address delegator, address delegatee) internal view returns (bool) {\n        return delegator == delegatee || delegates[delegator][delegatee] == 1;\n    }\n\n    /// ======== Credit and Token Balance Administration ======== ///\n\n    /// @notice Updates the token balance for a `user`\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param user Address of the user\n    /// @param amount Amount to add (positive) or subtract (negative) [wad]\n    function modifyBalance(\n        address vault,\n        uint256 tokenId,\n        address user,\n        int256 amount\n    ) external override checkCaller {\n        balances[vault][tokenId][user] = add(balances[vault][tokenId][user], amount);\n        emit ModifyBalance(vault, tokenId, user, amount, balances[vault][tokenId][user]);\n    }\n\n    /// @notice Transfer an `amount` of tokens from `src` to `dst`\n    /// @dev Sender has to be delegated by `src`\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param src From address\n    /// @param dst To address\n    /// @param amount Amount to be transferred [wad]\n    function transferBalance(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        uint256 amount\n    ) external override {\n        if (!hasDelegate(src, msg.sender)) revert Codex__transferBalance_notAllowed();\n        balances[vault][tokenId][src] = sub(balances[vault][tokenId][src], amount);\n        balances[vault][tokenId][dst] = add(balances[vault][tokenId][dst], amount);\n        emit TransferBalance(\n            vault,\n            tokenId,\n            src,\n            dst,\n            amount,\n            balances[vault][tokenId][src],\n            balances[vault][tokenId][dst]\n        );\n    }\n\n    /// @notice Transfer an `amount` of Credit from `src` to `dst`\n    /// @dev Sender has to be delegated by `src`\n    /// @param src From address\n    /// @param dst To address\n    /// @param amount Amount to be transferred [wad]\n    function transferCredit(\n        address src,\n        address dst,\n        uint256 amount\n    ) external override {\n        if (!hasDelegate(src, msg.sender)) revert Codex__transferCredit_notAllowed();\n        credit[src] = sub(credit[src], amount);\n        credit[dst] = add(credit[dst], amount);\n        emit TransferCredit(src, dst, amount, credit[src], credit[dst]);\n    }\n\n    /// ======== Position Administration ======== ///\n\n    /// @notice Modifies a Position's collateral and debt balances\n    /// @dev Checks that the global debt ceiling and the vault's debt ceiling have not been exceeded,\n    /// that the Position is still safe after the modification,\n    /// that the sender is delegated by the owner if the collateral-to-debt ratio decreased,\n    /// that the sender is delegated by the collateralizer if new collateral is put up,\n    /// that the sender is delegated by the creditor if debt is settled,\n    /// and that the vault debt floor is exceeded\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param user Address of the user\n    /// @param collateralizer Address of who puts up or receives the collateral delta\n    /// @param creditor Address of who provides or receives the credit delta for the debt delta\n    /// @param deltaCollateral Amount of collateral to put up (+) for or remove (-) from this Position [wad]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) on this Position [wad]\n    function modifyCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address creditor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external override {\n        // system is live\n        if (live == 0) revert Codex__modifyCollateralAndDebt_notLive();\n\n        Position memory p = positions[vault][tokenId][user];\n        Vault memory v = vaults[vault];\n        // vault has been initialised\n        if (v.rate == 0) revert Codex__modifyCollateralAndDebt_vaultNotInit();\n\n        p.collateral = add(p.collateral, deltaCollateral);\n        p.normalDebt = add(p.normalDebt, deltaNormalDebt);\n        v.totalNormalDebt = add(v.totalNormalDebt, deltaNormalDebt);\n\n        int256 deltaDebt = wmul(v.rate, deltaNormalDebt);\n        uint256 debt = wmul(v.rate, p.normalDebt);\n        globalDebt = add(globalDebt, deltaDebt);\n\n        // either debt has decreased, or debt ceilings are not exceeded\n        if (deltaNormalDebt > 0 && (wmul(v.totalNormalDebt, v.rate) > v.debtCeiling || globalDebt > globalDebtCeiling))\n            revert Codex__modifyCollateralAndDebt_ceilingExceeded();\n        // position is either less risky than before, or it is safe\n        if (\n            (deltaNormalDebt > 0 || deltaCollateral < 0) &&\n            debt > wmul(p.collateral, IVault(vault).fairPrice(tokenId, true, false))\n        ) revert Codex__modifyCollateralAndDebt_notSafe();\n\n        // position is either more safe, or the owner consents\n        if ((deltaNormalDebt > 0 || deltaCollateral < 0) && !hasDelegate(user, msg.sender))\n            revert Codex__modifyCollateralAndDebt_notAllowedSender();\n        // collateralizer consents if new collateral is put up\n        if (deltaCollateral > 0 && !hasDelegate(collateralizer, msg.sender))\n            revert Codex__modifyCollateralAndDebt_notAllowedCollateralizer();\n\n        // creditor consents if debt is settled with credit\n        if (deltaNormalDebt < 0 && !hasDelegate(creditor, msg.sender))\n            revert Codex__modifyCollateralAndDebt_notAllowedDebtor();\n\n        // position has no debt, or a non-dusty amount\n        if (p.normalDebt != 0 && debt < v.debtFloor) revert Codex__modifyCollateralAndDebt_debtFloor();\n\n        balances[vault][tokenId][collateralizer] = sub(balances[vault][tokenId][collateralizer], deltaCollateral);\n        credit[creditor] = add(credit[creditor], deltaDebt);\n\n        positions[vault][tokenId][user] = p;\n        vaults[vault] = v;\n\n        emit ModifyCollateralAndDebt(vault, tokenId, user, collateralizer, creditor, deltaCollateral, deltaNormalDebt);\n    }\n\n    /// @notice Transfers a Position's collateral and debt balances to another Position\n    /// @dev Checks that the sender is delegated by `src` and `dst` Position owners,\n    /// that the `src` and `dst` Positions are still safe after the transfer,\n    /// and that the `src` and `dst` Positions' debt exceed the vault's debt floor\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param src Address of the `src` Positions owner\n    /// @param dst Address of the `dst` Positions owner\n    /// @param deltaCollateral Amount of collateral to send to (+) or from (-) the `src` Position [wad]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to send to (+) or\n    /// from (-) the `dst` Position [wad]\n    function transferCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external override {\n        Position storage pSrc = positions[vault][tokenId][src];\n        Position storage pDst = positions[vault][tokenId][dst];\n        Vault storage v = vaults[vault];\n\n        pSrc.collateral = sub(pSrc.collateral, deltaCollateral);\n        pSrc.normalDebt = sub(pSrc.normalDebt, deltaNormalDebt);\n        pDst.collateral = add(pDst.collateral, deltaCollateral);\n        pDst.normalDebt = add(pDst.normalDebt, deltaNormalDebt);\n\n        uint256 debtSrc = wmul(pSrc.normalDebt, v.rate);\n        uint256 debtDst = wmul(pDst.normalDebt, v.rate);\n\n        // both sides consent\n        if (!hasDelegate(src, msg.sender) || !hasDelegate(dst, msg.sender))\n            revert Codex__transferCollateralAndDebt_notAllowed();\n\n        // both sides safe\n        if (debtSrc > wmul(pSrc.collateral, IVault(vault).fairPrice(tokenId, true, false)))\n            revert Codex__transferCollateralAndDebt_notSafeSrc();\n        if (debtDst > wmul(pDst.collateral, IVault(vault).fairPrice(tokenId, true, false)))\n            revert Codex__transferCollateralAndDebt_notSafeDst();\n\n        // both sides non-dusty\n        if (pSrc.normalDebt != 0 && debtSrc < v.debtFloor) revert Codex__transferCollateralAndDebt_debtFloorSrc();\n        if (pDst.normalDebt != 0 && debtDst < v.debtFloor) revert Codex__transferCollateralAndDebt_debtFloorDst();\n\n        emit TransferCollateralAndDebt(vault, tokenId, src, dst, deltaCollateral, deltaNormalDebt);\n    }\n\n    /// @notice Confiscates a Position's collateral and debt balances\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param user Address of the user\n    /// @param collateralizer Address of who puts up or receives the collateral delta\n    /// @param debtor Address of who provides or receives the debt delta\n    /// @param deltaCollateral Amount of collateral to put up (+) for or remove (-) from this Position [wad]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) on this Position [wad]\n    function confiscateCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external override checkCaller {\n        Position storage position = positions[vault][tokenId][user];\n        Vault storage v = vaults[vault];\n\n        position.collateral = add(position.collateral, deltaCollateral);\n        position.normalDebt = add(position.normalDebt, deltaNormalDebt);\n        v.totalNormalDebt = add(v.totalNormalDebt, deltaNormalDebt);\n\n        int256 deltaDebt = wmul(v.rate, deltaNormalDebt);\n\n        balances[vault][tokenId][collateralizer] = sub(balances[vault][tokenId][collateralizer], deltaCollateral);\n        unbackedDebt[debtor] = sub(unbackedDebt[debtor], deltaDebt);\n        globalUnbackedDebt = sub(globalUnbackedDebt, deltaDebt);\n\n        emit ConfiscateCollateralAndDebt(\n            vault,\n            tokenId,\n            user,\n            collateralizer,\n            debtor,\n            deltaCollateral,\n            deltaNormalDebt\n        );\n    }\n\n    /// ======== Unbacked Debt ======== ///\n\n    /// @notice Settles unbacked debt with the sender's credit\n    /// @dev Reverts if the sender does not have sufficient credit available to settle the debt\n    /// @param debt Amount of debt to settle [wawd]\n    function settleUnbackedDebt(uint256 debt) external override {\n        address debtor = msg.sender;\n        unbackedDebt[debtor] = sub(unbackedDebt[debtor], debt);\n        credit[debtor] = sub(credit[debtor], debt);\n        globalUnbackedDebt = sub(globalUnbackedDebt, debt);\n        globalDebt = sub(globalDebt, debt);\n        emit SettleUnbackedDebt(debtor, debt);\n    }\n\n    /// @notice Create unbacked debt / credit\n    /// @dev Sender has to be allowed to call this method\n    /// @param debtor Address of the account who takes the unbacked debt\n    /// @param creditor Address of the account who gets the credit\n    /// @param debt Amount of unbacked debt / credit to generate [wad]\n    function createUnbackedDebt(\n        address debtor,\n        address creditor,\n        uint256 debt\n    ) external override checkCaller {\n        unbackedDebt[debtor] = add(unbackedDebt[debtor], debt);\n        credit[creditor] = add(credit[creditor], debt);\n        globalUnbackedDebt = add(globalUnbackedDebt, debt);\n        globalDebt = add(globalDebt, debt);\n        emit CreateUnbackedDebt(debtor, creditor, debt);\n    }\n\n    /// ======== Debt Interest Rates ======== ///\n\n    /// @notice Updates the rate value and collects the accrued interest for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the vault\n    /// @param creditor Address of the account who gets the accrued interest\n    /// @param deltaRate Delta to increase (+) or decrease (-) the rate [percentage in wad]\n    function modifyRate(\n        address vault,\n        address creditor,\n        int256 deltaRate\n    ) external override checkCaller {\n        if (live == 0) revert Codex__modifyRate_notLive();\n        Vault storage v = vaults[vault];\n        v.rate = add(v.rate, deltaRate);\n        int256 wad = wmul(v.totalNormalDebt, deltaRate);\n        credit[creditor] = add(credit[creditor], wad);\n        globalDebt = add(globalDebt, wad);\n        emit ModifyRate(vault, creditor, deltaRate);\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Locks the contract\n    /// @dev Sender has to be allowed to call this method\n    function lock() external override checkCaller {\n        live = 0;\n        emit Lock();\n    }\n}// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\ninterface IDebtAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function tokenToSellBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function aer() external view returns (address);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(\n        address recipient,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock() external;\n\n    function cancelAuction(uint256 id) external;\n}\ninterface ISurplusAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(uint256 creditToSell, uint256 bid) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 creditToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock(uint256 credit) external;\n\n    function cancelAuction(uint256 id) external;\n}\n\ninterface IAer {\n    function codex() external view returns (ICodex);\n\n    function surplusAuction() external view returns (ISurplusAuction);\n\n    function debtAuction() external view returns (IDebtAuction);\n\n    function debtQueue(uint256) external view returns (uint256);\n\n    function queuedDebt() external view returns (uint256);\n\n    function debtOnAuction() external view returns (uint256);\n\n    function auctionDelay() external view returns (uint256);\n\n    function debtAuctionSellSize() external view returns (uint256);\n\n    function debtAuctionBidSize() external view returns (uint256);\n\n    function surplusAuctionSellSize() external view returns (uint256);\n\n    function surplusBuffer() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function queueDebt(uint256 debt) external;\n\n    function unqueueDebt(uint256 queuedAt) external;\n\n    function settleDebtWithSurplus(uint256 debt) external;\n\n    function settleAuctionedDebt(uint256 debt) external;\n\n    function startDebtAuction() external returns (uint256 auctionId);\n\n    function startSurplusAuction() external returns (uint256 auctionId);\n\n    function transferCredit(address to, uint256 credit) external;\n\n    function lock() external;\n}interface IPublican {\n    function vaults(address vault) external view returns (uint256, uint256);\n\n    function codex() external view returns (ICodex);\n\n    function aer() external view returns (IAer);\n\n    function baseInterest() external view returns (uint256);\n\n    function init(address vault) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function virtualRate(address vault) external returns (uint256 rate);\n\n    function collect(address vault) external returns (uint256 rate);\n}\n\n/// @title Publican\n/// @notice `Publican` is responsible for setting the debt interest rate and collecting interest\n/// Uses Jug.sol from DSS (MakerDAO) / TaxCollector.sol from GEB (Reflexer Labs) as a blueprint\n/// Changes from Jug.sol / TaxCollector.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - configuration by Vaults\ncontract Publican is Guarded, IPublican {\n    /// ======== Custom Errors ======== ///\n\n    error Publican__init_vaultAlreadyInit();\n    error Publican__setParam_notCollected();\n    error Publican__setParam_unrecognizedParam();\n    error Publican__collect_invalidBlockTimestamp();\n\n    /// ======== Storage ======== ///\n\n    // Vault specific configuration data\n    struct VaultConfig {\n        // Collateral-specific, per-second stability fee contribution [wad]\n        uint256 interestPerSecond;\n        // Time of last drip [unix epoch time]\n        uint256 lastCollected;\n    }\n\n    /// @notice Vault Configs\n    /// @dev Vault => Vault Config\n    mapping(address => VaultConfig) public override vaults;\n\n    /// @notice Codex\n    ICodex public immutable override codex;\n    /// @notice Aer\n    IAer public override aer;\n\n    /// @notice Global, per-second stability fee contribution [wad]\n    uint256 public override baseInterest;\n\n    /// ======== Events ======== ///\n    event Init(address indexed vault);\n    event SetParam(address indexed vault, bytes32 indexed param, uint256 data);\n    event SetParam(bytes32 indexed param, address indexed data);\n    event Collect(address indexed vault);\n\n    constructor(address codex_) Guarded() {\n        codex = ICodex(codex_);\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Initializes a new Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    function init(address vault) external override checkCaller {\n        VaultConfig storage v = vaults[vault];\n        if (v.interestPerSecond != 0) revert Publican__init_vaultAlreadyInit();\n        v.interestPerSecond = WAD;\n        v.lastCollected = block.timestamp;\n        emit Init(vault);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external override checkCaller {\n        if (block.timestamp != vaults[vault].lastCollected) revert Publican__setParam_notCollected();\n        if (param == \"interestPerSecond\") vaults[vault].interestPerSecond = data;\n        else revert Publican__setParam_unrecognizedParam();\n        emit SetParam(vault, param, data);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (param == \"baseInterest\") baseInterest = data;\n        else revert Publican__setParam_unrecognizedParam();\n        emit SetParam(address(0), param, data);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(bytes32 param, address data) external override checkCaller {\n        if (param == \"aer\") aer = IAer(data);\n        else revert Publican__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== Interest Rates ======== ///\n\n    /// @notice Returns the up to date rate (virtual rate) for a given vault as the rate stored in Codex\n    /// might be outdated\n    /// @param vault Address of the Vault\n    /// @return rate Virtual rate\n    function virtualRate(address vault) external view override returns (uint256 rate) {\n        (, uint256 prev, , ) = codex.vaults(vault);\n        if (block.timestamp < vaults[vault].lastCollected) return prev;\n        rate = wmul(\n            wpow(\n                add(baseInterest, vaults[vault].interestPerSecond),\n                sub(block.timestamp, vaults[vault].lastCollected),\n                WAD\n            ),\n            prev\n        );\n    }\n\n    /// @notice Collects accrued interest from all Position on a Vault by updating the Vault's rate\n    /// @param vault Address of the Vault\n    /// @return rate Set rate\n    function collect(address vault) public override returns (uint256 rate) {\n        if (block.timestamp < vaults[vault].lastCollected) revert Publican__collect_invalidBlockTimestamp();\n        (, uint256 prev, , ) = codex.vaults(vault);\n        rate = wmul(\n            wpow(\n                add(baseInterest, vaults[vault].interestPerSecond),\n                sub(block.timestamp, vaults[vault].lastCollected),\n                WAD\n            ),\n            prev\n        );\n        codex.modifyRate(vault, address(aer), diff(rate, prev));\n        vaults[vault].lastCollected = block.timestamp;\n        emit Collect(vault);\n    }\n\n    /// @notice Batches interest collection. See `collect(address vault)`.\n    /// @param vaults_ Array of Vault addresses\n    /// @return rates Set rates for each updated Vault\n    function collectMany(address[] memory vaults_) external returns (uint256[] memory) {\n        uint256[] memory rates = new uint256[](vaults_.length);\n        for (uint256 i = 0; i < vaults_.length; i++) {\n            rates[i] = collect(vaults_[i]);\n        }\n        return rates;\n    }\n}// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n\n\n\n/// @title Aer (short for Aerarium)\n/// @notice `Aer` is used for managing the protocol's debt and surplus balances via the DebtAuction and\n/// SurplusAuction contracts.\n/// Uses Vow.sol from DSS (MakerDAO) / AccountingEngine.sol from GEB (Reflexer Labs) as a blueprint\n/// Changes from Vow.sol / AccountingEngine.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\ncontract Aer is Guarded, IAer {\n    /// ======== Custom Errors ======== ///\n\n    error Aer__setParam_unrecognizedParam();\n    error Aer__unqueueDebt_auctionDelayNotPassed();\n    error Aer__settleDebtWithSurplus_insufficientSurplus();\n    error Aer__settleDebtWithSurplus_insufficientDebt();\n    error Aer__settleAuctionedDebt_notEnoughDebtOnAuction();\n    error Aer__settleAuctionedDebt_insufficientSurplus();\n    error Aer__startDebtAuction_insufficientDebt();\n    error Aer__startDebtAuction_surplusNotZero();\n    error Aer__startSurplusAuction_insufficientSurplus();\n    error Aer__startSurplusAuction_debtNotZero();\n    error Aer__transferCredit_insufficientCredit();\n    error Aer__lock_notLive();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Codex\n    ICodex public immutable override codex;\n    /// @notice SurplusAuction\n    ISurplusAuction public override surplusAuction;\n    /// @notice DebtAuction\n    IDebtAuction public override debtAuction;\n\n    /// @notice List of debt amounts to be auctioned sorted by the time at which they where queued\n    /// @dev Queued at timestamp => Debt [wad]\n    mapping(uint256 => uint256) public override debtQueue;\n    /// @notice Queued debt amount [wad]\n    uint256 public override queuedDebt;\n    /// @notice Amount of debt currently on auction [wad]\n    uint256 public override debtOnAuction;\n\n    /// @notice Time after which queued debt can be put up for auction [seconds]\n    uint256 public override auctionDelay;\n    /// @notice Amount of tokens to sell in each debt auction [wad]\n    uint256 public override debtAuctionSellSize;\n    /// @notice Min. amount of (credit to bid or debt to sell) for tokens [wad]\n    uint256 public override debtAuctionBidSize;\n\n    /// @notice Amount of credit to sell in each surplus auction [wad]\n    uint256 public override surplusAuctionSellSize;\n    /// @notice Amount of credit required for starting a surplus auction [wad]\n    uint256 public override surplusBuffer;\n\n    /// @notice Boolean indicating if this contract is live (0 - not live, 1 - live)\n    uint256 public override live;\n\n    /// ======== Events ======== ///\n    event SetParam(bytes32 indexed param, uint256 data);\n    event SetParam(bytes32 indexed param, address indexed data);\n    event QueueDebt(uint256 indexed queuedAt, uint256 debtQueue, uint256 queuedDebt);\n    event UnqueueDebt(uint256 indexed queuedAt, uint256 queuedDebt);\n    event StartDebtAuction(uint256 debtOnAuction, uint256 indexed auctionId);\n    event SettleAuctionedDebt(uint256 debtOnAuction);\n    event StartSurplusAuction(uint256 indexed auctionId);\n    event SettleDebtWithSurplus(uint256 debt);\n    event Lock();\n\n    constructor(\n        address codex_,\n        address surplusAuction_,\n        address debtAuction_\n    ) Guarded() {\n        codex = ICodex(codex_);\n        surplusAuction = ISurplusAuction(surplusAuction_);\n        debtAuction = IDebtAuction(debtAuction_);\n        ICodex(codex_).grantDelegate(surplusAuction_);\n        live = 1;\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (param == \"auctionDelay\") auctionDelay = data;\n        else if (param == \"surplusAuctionSellSize\") surplusAuctionSellSize = data;\n        else if (param == \"debtAuctionBidSize\") debtAuctionBidSize = data;\n        else if (param == \"debtAuctionSellSize\") debtAuctionSellSize = data;\n        else if (param == \"surplusBuffer\") surplusBuffer = data;\n        else revert Aer__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(bytes32 param, address data) external override checkCaller {\n        if (param == \"surplusAuction\") {\n            codex.revokeDelegate(address(surplusAuction));\n            surplusAuction = ISurplusAuction(data);\n            codex.grantDelegate(data);\n        } else if (param == \"debtAuction\") debtAuction = IDebtAuction(data);\n        else revert Aer__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== Debt Auction ======== ///\n\n    /// @notice Pushes new debt to the debt queue\n    /// @dev Sender has to be allowed to call this method\n    /// @param debt Amount of debt [wad]\n    function queueDebt(uint256 debt) external override checkCaller {\n        debtQueue[block.timestamp] = add(debtQueue[block.timestamp], debt);\n        queuedDebt = add(queuedDebt, debt);\n        emit QueueDebt(block.timestamp, debtQueue[block.timestamp], queuedDebt);\n    }\n\n    /// @notice Pops debt from the debt queue\n    /// @param queuedAt Timestamp at which the debt has been queued [seconds]\n    function unqueueDebt(uint256 queuedAt) external override {\n        if (add(queuedAt, auctionDelay) > block.timestamp) revert Aer__unqueueDebt_auctionDelayNotPassed();\n        queuedDebt = sub(queuedDebt, debtQueue[queuedAt]);\n        debtQueue[queuedAt] = 0;\n        emit UnqueueDebt(queuedAt, queuedDebt);\n    }\n\n    /// @notice Starts a debt auction\n    /// @dev Sender has to be allowed to call this method\n    /// Checks if enough debt exists to be put up for auction\n    /// debtAuctionBidSize > (unbackedDebt - queuedDebt - debtOnAuction)\n    /// @return auctionId Id of the debt auction\n    function startDebtAuction() external override checkCaller returns (uint256 auctionId) {\n        if (debtAuctionBidSize > sub(sub(codex.unbackedDebt(address(this)), queuedDebt), debtOnAuction))\n            revert Aer__startDebtAuction_insufficientDebt();\n        if (codex.credit(address(this)) != 0) revert Aer__startDebtAuction_surplusNotZero();\n        debtOnAuction = add(debtOnAuction, debtAuctionBidSize);\n        auctionId = debtAuction.startAuction(address(this), debtAuctionSellSize, debtAuctionBidSize);\n        emit StartDebtAuction(debtOnAuction, auctionId);\n    }\n\n    /// @notice Settles debt collected from debt auctions\n    /// @dev Cannot settle debt with accrued surplus (only from debt auctions)\n    /// @param debt Amount of debt to settle [wad]\n    function settleAuctionedDebt(uint256 debt) external override {\n        if (debt > debtOnAuction) revert Aer__settleAuctionedDebt_notEnoughDebtOnAuction();\n        if (debt > codex.credit(address(this))) revert Aer__settleAuctionedDebt_insufficientSurplus();\n        debtOnAuction = sub(debtOnAuction, debt);\n        codex.settleUnbackedDebt(debt);\n        emit SettleAuctionedDebt(debtOnAuction);\n    }\n\n    /// ======== Surplus Auction ======== ///\n\n    /// @notice Starts a surplus auction\n    /// @dev Sender has to be allowed to call this method\n    /// Checks if enough surplus has accrued (surplusAuctionSellSize + surplusBuffer) and there's\n    /// no queued debt to be put up for a debt auction\n    /// @return auctionId Id of the surplus auction\n    function startSurplusAuction() external override checkCaller returns (uint256 auctionId) {\n        if (\n            codex.credit(address(this)) <\n            add(add(codex.unbackedDebt(address(this)), surplusAuctionSellSize), surplusBuffer)\n        ) revert Aer__startSurplusAuction_insufficientSurplus();\n        if (sub(sub(codex.unbackedDebt(address(this)), queuedDebt), debtOnAuction) != 0)\n            revert Aer__startSurplusAuction_debtNotZero();\n        auctionId = surplusAuction.startAuction(surplusAuctionSellSize, 0);\n        emit StartSurplusAuction(auctionId);\n    }\n\n    /// @notice Settles debt with the accrued surplus\n    /// @dev Sender has to be allowed to call this method\n    /// Can not settle more debt than there's unbacked debt and which is not expected\n    /// to be settled via debt auctions (queuedDebt + debtOnAuction)\n    /// @param debt Amount of debt to settle [wad]\n    function settleDebtWithSurplus(uint256 debt) external override checkCaller {\n        if (debt > codex.credit(address(this))) revert Aer__settleDebtWithSurplus_insufficientSurplus();\n        if (debt > sub(sub(codex.unbackedDebt(address(this)), queuedDebt), debtOnAuction))\n            revert Aer__settleDebtWithSurplus_insufficientDebt();\n        codex.settleUnbackedDebt(debt);\n        emit SettleDebtWithSurplus(debt);\n    }\n\n    /// @notice Transfer accrued credit surplus to another account\n    /// @dev Can only transfer backed credit out of Aer\n    /// @param credit Amount of debt to settle [wad]\n    function transferCredit(address to, uint256 credit) external override checkCaller {\n        if (credit > sub(codex.credit(address(this)), codex.unbackedDebt(address(this))))\n            revert Aer__transferCredit_insufficientCredit();\n        codex.transferCredit(address(this), to, credit);\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Locks the contract\n    /// @dev Sender has to be allowed to call this method\n    /// Wipes queued debt and debt on auction, locks DebtAuction and SurplusAuction and\n    /// settles debt with what it has available\n    function lock() external override checkCaller {\n        if (live == 0) revert Aer__lock_notLive();\n        live = 0;\n        queuedDebt = 0;\n        debtOnAuction = 0;\n        surplusAuction.lock(codex.credit(address(surplusAuction)));\n        debtAuction.lock();\n        codex.settleUnbackedDebt(min(codex.credit(address(this)), codex.unbackedDebt(address(this))));\n        emit Lock();\n    }\n}// Copyright (C) 2020-2021 Maker Ecosystem Growth Holdings, INC.\n\ninterface IPriceCalculator {\n    // 1st arg: initial price [wad]\n    // 2nd arg: seconds since auction start [seconds]\n    // returns: current auction price [wad]\n    function price(uint256, uint256) external view returns (uint256);\n}\n\n\n\ninterface ILimes {\n    function codex() external view returns (ICodex);\n\n    function aer() external view returns (IAer);\n\n    function vaults(address)\n        external\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function live() external view returns (uint256);\n\n    function globalMaxDebtOnAuction() external view returns (uint256);\n\n    function globalDebtOnAuction() external view returns (uint256);\n\n    function setParam(bytes32 param, address data) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        address collateralAuction\n    ) external;\n\n    function liquidationPenalty(address vault) external view returns (uint256);\n\n    function liquidate(\n        address vault,\n        uint256 tokenId,\n        address position,\n        address keeper\n    ) external returns (uint256 auctionId);\n\n    function liquidated(\n        address vault,\n        uint256 tokenId,\n        uint256 debt\n    ) external;\n\n    function lock() external;\n}\n\ninterface CollateralAuctionCallee {\n    function collateralAuctionCall(\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external;\n}\n\ninterface ICollateralAuction {\n    function vaults(address)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            ICollybus,\n            IPriceCalculator\n        );\n\n    function codex() external view returns (ICodex);\n\n    function limes() external view returns (ILimes);\n\n    function aer() external view returns (IAer);\n\n    function feeTip() external view returns (uint64);\n\n    function flatTip() external view returns (uint192);\n\n    function auctionCounter() external view returns (uint256);\n\n    function activeAuctions(uint256) external view returns (uint256);\n\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            address,\n            uint96,\n            uint256\n        );\n\n    function stopped() external view returns (uint256);\n\n    function init(address vault, address collybus) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        address data\n    ) external;\n\n    function startAuction(\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address keeper\n    ) external returns (uint256 auctionId);\n\n    function redoAuction(uint256 auctionId, address keeper) external;\n\n    function takeCollateral(\n        uint256 auctionId,\n        uint256 collateralAmount,\n        uint256 maxPrice,\n        address recipient,\n        bytes calldata data\n    ) external;\n\n    function count() external view returns (uint256);\n\n    function list() external view returns (uint256[] memory);\n\n    function getStatus(uint256 auctionId)\n        external\n        view\n        returns (\n            bool needsRedo,\n            uint256 price,\n            uint256 collateralToSell,\n            uint256 debt\n        );\n\n    function updateAuctionDebtFloor(address vault) external;\n\n    function cancelAuction(uint256 auctionId) external;\n}\n\n/// @title Limes\n/// @notice `Limes` is responsible for triggering liquidations of unsafe Positions and\n/// putting the Position's collateral up for auction\n/// Uses Dog.sol from DSS (MakerDAO) as a blueprint\n/// Changes from Dog.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract Limes is Guarded, ILimes {\n    /// ======== Custom Errors ======== ///\n\n    error Limes__setParam_liquidationPenaltyLtWad();\n    error Limes__setParam_unrecognizedParam();\n    error Limes__liquidate_notLive();\n    error Limes__liquidate_notUnsafe();\n    error Limes__liquidate_maxDebtOnAuction();\n    error Limes__liquidate_dustyAuctionFromPartialLiquidation();\n    error Limes__liquidate_nullAuction();\n    error Limes__liquidate_overflow();\n\n    /// ======== Storage ======== ///\n\n    // Vault specific configuration data\n    struct VaultConfig {\n        // Auction contract for collateral\n        address collateralAuction;\n        // Liquidation penalty [wad]\n        uint256 liquidationPenalty;\n        // Max credit needed to cover debt+fees of active auctions per vault [wad]\n        uint256 maxDebtOnAuction;\n        // Amount of credit needed to cover debt+fees for all active auctions per vault [wad]\n        uint256 debtOnAuction;\n    }\n\n    /// @notice Vault Configs\n    /// @dev Vault => Vault Config\n    mapping(address => VaultConfig) public override vaults;\n\n    /// @notice Codex\n    ICodex public immutable override codex;\n    /// @notice Aer\n    IAer public override aer;\n\n    /// @notice Max credit needed to cover debt+fees of active auctions [wad]\n    uint256 public override globalMaxDebtOnAuction;\n    /// @notice Amount of credit needed to cover debt+fees for all active auctions [wad]\n    uint256 public override globalDebtOnAuction;\n\n    /// @notice Boolean indicating if this contract is live (0 - not live, 1 - live)\n    uint256 public override live;\n\n    /// ======== Events ======== ///\n\n    event SetParam(bytes32 indexed param, uint256 data);\n    event SetParam(bytes32 indexed param, address data);\n    event SetParam(address indexed vault, bytes32 indexed param, uint256 data);\n    event SetParam(address indexed vault, bytes32 indexed param, address collateralAuction);\n\n    event Liquidate(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address position,\n        uint256 collateral,\n        uint256 normalDebt,\n        uint256 due,\n        address collateralAuction,\n        uint256 indexed auctionId\n    );\n    event Liquidated(address indexed vault, uint256 indexed tokenId, uint256 debt);\n    event Lock();\n\n    constructor(address codex_) Guarded() {\n        codex = ICodex(codex_);\n        live = 1;\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(bytes32 param, address data) external override checkCaller {\n        if (param == \"aer\") aer = IAer(data);\n        else revert Limes__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (param == \"globalMaxDebtOnAuction\") globalMaxDebtOnAuction = data;\n        else revert Limes__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external override checkCaller {\n        if (param == \"liquidationPenalty\") {\n            if (data < WAD) revert Limes__setParam_liquidationPenaltyLtWad();\n            vaults[vault].liquidationPenalty = data;\n        } else if (param == \"maxDebtOnAuction\") vaults[vault].maxDebtOnAuction = data;\n        else revert Limes__setParam_unrecognizedParam();\n        emit SetParam(vault, param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(\n        address vault,\n        bytes32 param,\n        address data\n    ) external override checkCaller {\n        if (param == \"collateralAuction\") {\n            vaults[vault].collateralAuction = data;\n        } else revert Limes__setParam_unrecognizedParam();\n        emit SetParam(vault, param, data);\n    }\n\n    /// ======== Liquidations ======== ///\n\n    /// @notice Direct access to the current liquidation penalty set for a Vault\n    /// @param vault Address of the Vault\n    /// @return liquidation penalty [wad]\n    function liquidationPenalty(address vault) external view override returns (uint256) {\n        return vaults[vault].liquidationPenalty;\n    }\n\n    /// @notice Liquidate a Position and start a Dutch auction to sell its collateral for credit.\n    /// @dev The third argument is the address that will receive the liquidation reward, if any.\n    /// The entire Position will be liquidated except when the target amount of credit to be raised in\n    /// the resulting auction (debt of Position + liquidation penalty) causes either globalDebtOnAuction to exceed\n    /// globalMaxDebtOnAuction or vault.debtOnAuction to exceed vault.maxDebtOnAuction by an economically\n    /// significant amount. In that case, a partial liquidation is performed to respect the global and per-vault limits\n    /// on outstanding credit target. The one exception is if the resulting auction would likely\n    /// have too little collateral to be of interest to Keepers (debt taken from Position < vault.debtFloor),\n    /// in which case the function reverts. Please refer to the code and comments within if more detail is desired.\n    /// @param vault Address of the Position's Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20) of the Position\n    /// @param position Address of the owner of the Position\n    /// @param keeper Address of the keeper who triggers the liquidation and receives the reward\n    /// @return auctionId Indentifier of the started auction\n    function liquidate(\n        address vault,\n        uint256 tokenId,\n        address position,\n        address keeper\n    ) external override returns (uint256 auctionId) {\n        if (live == 0) revert Limes__liquidate_notLive();\n\n        VaultConfig memory mvault = vaults[vault];\n        uint256 deltaNormalDebt;\n        uint256 rate;\n        uint256 debtFloor;\n        uint256 deltaCollateral;\n        unchecked {\n            {\n                (uint256 collateral, uint256 normalDebt) = codex.positions(vault, tokenId, position);\n                uint256 price = IVault(vault).fairPrice(tokenId, true, false);\n                (, rate, , debtFloor) = codex.vaults(vault);\n                if (price == 0 || mul(collateral, price) >= mul(normalDebt, rate)) revert Limes__liquidate_notUnsafe();\n\n                // Get the minimum value between:\n                // 1) Remaining space in the globalMaxDebtOnAuction\n                // 2) Remaining space in the vault.maxDebtOnAuction\n                if (!(globalMaxDebtOnAuction > globalDebtOnAuction && mvault.maxDebtOnAuction > mvault.debtOnAuction))\n                    revert Limes__liquidate_maxDebtOnAuction();\n\n                uint256 room = min(\n                    globalMaxDebtOnAuction - globalDebtOnAuction,\n                    mvault.maxDebtOnAuction - mvault.debtOnAuction\n                );\n\n                // normalize room by subtracting rate and liquidationPenalty\n                deltaNormalDebt = min(normalDebt, (((room * WAD) / rate) * WAD) / mvault.liquidationPenalty);\n\n                // Partial liquidation edge case logic\n                if (normalDebt > deltaNormalDebt) {\n                    if (wmul(normalDebt - deltaNormalDebt, rate) < debtFloor) {\n                        // If the leftover Position would be dusty, just liquidate it entirely.\n                        // This will result in at least one of v.debtOnAuction > v.maxDebtOnAuction or\n                        // globalDebtOnAuction > globalMaxDebtOnAuction becoming true. The amount of excess will\n                        // be bounded above by ceiling(v.debtFloor * v.liquidationPenalty / WAD). This deviation is\n                        // assumed to be small compared to both v.maxDebtOnAuction and globalMaxDebtOnAuction, so that\n                        // the extra amount of credit is not of economic concern.\n                        deltaNormalDebt = normalDebt;\n                    } else {\n                        // In a partial liquidation, the resulting auction should also be non-dusty.\n                        if (wmul(deltaNormalDebt, rate) < debtFloor)\n                            revert Limes__liquidate_dustyAuctionFromPartialLiquidation();\n                    }\n                }\n\n                deltaCollateral = mul(collateral, deltaNormalDebt) / normalDebt;\n            }\n        }\n\n        if (deltaCollateral == 0) revert Limes__liquidate_nullAuction();\n        if (!(deltaNormalDebt <= 2**255 && deltaCollateral <= 2**255)) revert Limes__liquidate_overflow();\n\n        codex.confiscateCollateralAndDebt(\n            vault,\n            tokenId,\n            position,\n            mvault.collateralAuction,\n            address(aer),\n            -int256(deltaCollateral),\n            -int256(deltaNormalDebt)\n        );\n\n        uint256 due = wmul(deltaNormalDebt, rate);\n        aer.queueDebt(due);\n\n        {\n            // Avoid stack too deep\n            // This calcuation will overflow if deltaNormalDebt*rate exceeds ~10^14\n            uint256 debt = wmul(due, mvault.liquidationPenalty);\n            globalDebtOnAuction = add(globalDebtOnAuction, debt);\n            vaults[vault].debtOnAuction = add(mvault.debtOnAuction, debt);\n\n            auctionId = ICollateralAuction(mvault.collateralAuction).startAuction({\n                debt: debt,\n                collateralToSell: deltaCollateral,\n                vault: vault,\n                tokenId: tokenId,\n                user: position,\n                keeper: keeper\n            });\n        }\n\n        emit Liquidate(\n            vault,\n            tokenId,\n            position,\n            deltaCollateral,\n            deltaNormalDebt,\n            due,\n            mvault.collateralAuction,\n            auctionId\n        );\n    }\n\n    /// @notice Marks the liquidated Position's debt as sold\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the liquidated Position's Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20) of the liquidated Position\n    /// @param debt Amount of debt sold\n    function liquidated(\n        address vault,\n        uint256 tokenId,\n        uint256 debt\n    ) external override checkCaller {\n        globalDebtOnAuction = sub(globalDebtOnAuction, debt);\n        vaults[vault].debtOnAuction = sub(vaults[vault].debtOnAuction, debt);\n        emit Liquidated(vault, tokenId, debt);\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Locks the contract\n    /// @dev Sender has to be allowed to call this method\n    function lock() external override checkCaller {\n        live = 0;\n        emit Lock();\n    }\n}// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\n\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\n\n\n\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\ninterface IFIATExcl {\n    function mint(address to, uint256 amount) external;\n\n    function burn(address from, uint256 amount) external;\n}\n\ninterface IFIAT is IFIATExcl, IERC20, IERC20Permit, IERC20Metadata {}interface IMoneta {\n    function codex() external view returns (ICodex);\n\n    function fiat() external view returns (IFIAT);\n\n    function live() external view returns (uint256);\n\n    function lock() external;\n\n    function enter(address user, uint256 amount) external;\n\n    function exit(address user, uint256 amount) external;\n}\n\n/// @title Moneta (FIAT Mint)\n/// @notice The canonical mint for FIAT (Fixed Income Asset Token),\n/// where users can redeem their internal credit for FIAT\ncontract Moneta is Guarded, IMoneta {\n    /// ======== Custom Errors ======== ///\n\n    error Moneta__exit_notLive();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Codex\n    ICodex public immutable override codex;\n    /// @notice FIAT (Fixed Income Asset Token)\n    IFIAT public immutable override fiat;\n\n    /// @notice Boolean indicating if this contract is live (0 - not live, 1 - live)\n    uint256 public override live;\n\n    /// ======== Events ======== ///\n\n    event Enter(address indexed user, uint256 amount);\n    event Exit(address indexed user, uint256 amount);\n    event Lock();\n\n    constructor(address codex_, address fiat_) Guarded() {\n        live = 1;\n        codex = ICodex(codex_);\n        fiat = IFIAT(fiat_);\n    }\n\n    /// ======== Redemption ======== ///\n\n    /// @notice Redeems FIAT for internal credit\n    /// @dev User has to set allowance for Moneta to burn FIAT\n    /// @param user Address of the user\n    /// @param amount Amount of FIAT to be redeemed for internal credit\n    function enter(address user, uint256 amount) external override {\n        codex.transferCredit(address(this), user, amount);\n        fiat.burn(msg.sender, amount);\n        emit Enter(user, amount);\n    }\n\n    /// @notice Redeems internal credit for FIAT\n    /// @dev User has to grant the delegate of transferring credit to Moneta\n    /// @param user Address of the user\n    /// @param amount Amount of credit to be redeemed for FIAT\n    function exit(address user, uint256 amount) external override {\n        if (live == 0) revert Moneta__exit_notLive();\n        codex.transferCredit(msg.sender, address(this), amount);\n        fiat.mint(user, amount);\n        emit Exit(user, amount);\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Locks the contract\n    /// @dev Sender has to be allowed to call this method\n    function lock() external override checkCaller {\n        live = 0;\n        emit Lock();\n    }\n}// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n\n\n\n\n/// @title SurplusAuction\n/// @notice\n/// Uses Flap.sol from DSS (MakerDAO) as a blueprint\n/// Changes from Flap.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract SurplusAuction is Guarded, ISurplusAuction {\n    /// ======== Custom Errors ======== ///\n\n    error SurplusAuction__setParam_unrecognizedParam();\n    error SurplusAuction__startAuction_notLive();\n    error SurplusAuction__startAuction_overflow();\n    error SurplusAuction__redoAuction_notFinished();\n    error SurplusAuction__redoAuction_bidAlreadyPlaced();\n    error SurplusAuction__submitBid_notLive();\n    error SurplusAuction__submit_recipientNotSet();\n    error SurplusAuction__submitBid_alreadyFinishedBidExpiry();\n    error SurplusAuction__submitBid_alreadyFinishedAuctionExpiry();\n    error SurplusAuction__submitBid_creditToSellNotMatching();\n    error SurplusAuction__submitBid_bidNotHigher();\n    error SurplusAuction__submitBid_insufficientIncrease();\n    error SurplusAuction__closeAuction_notLive();\n    error SurplusAuction__closeAuction_notFinished();\n    error SurplusAuction__cancelAuction_stillLive();\n    error SurplusAuction__cancelAuction_recipientNotSet();\n\n    /// ======== Storage ======== ///\n\n    // Auction State\n    struct Auction {\n        // tokens paid for credit [wad]\n        uint256 bid;\n        // amount of credit to sell for tokens (bid) [wad]\n        uint256 creditToSell;\n        // current highest bidder\n        address recipient;\n        // bid expiry time [unix epoch time]\n        uint48 bidExpiry;\n        // auction expiry time [unix epoch time]\n        uint48 auctionExpiry;\n    }\n\n    /// @notice State of auctions\n    // AuctionId => Auction\n    mapping(uint256 => Auction) public override auctions;\n\n    /// @notice Codex\n    ICodex public immutable override codex;\n    /// @notice Tokens to receive for credit\n    IERC20 public immutable override token;\n\n    /// @notice 5% minimum bid increase\n    uint256 public override minBidBump = 1.05e18;\n    /// @notice 3 hours bid duration [seconds]\n    uint48 public override bidDuration = 3 hours;\n    /// @notice 2 days total auction length [seconds]\n    uint48 public override auctionDuration = 2 days;\n    /// @notice Auction Counter\n    uint256 public override auctionCounter = 0;\n\n    /// @notice Boolean indicating if this contract is live (0 - not live, 1 - live)\n    uint256 public override live;\n\n    /// ======== Events ======== ///\n\n    event StartAuction(uint256 id, uint256 creditToSell, uint256 bid);\n\n    constructor(address codex_, address token_) Guarded() {\n        codex = ICodex(codex_);\n        token = IERC20(token_);\n        live = 1;\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (param == \"minBidBump\") minBidBump = data;\n        else if (param == \"bidDuration\") bidDuration = uint48(data);\n        else if (param == \"auctionDuration\") auctionDuration = uint48(data);\n        else revert SurplusAuction__setParam_unrecognizedParam();\n    }\n\n    /// ======== Surplus Auction ======== ///\n\n    /// @notice Start a new surplus auction\n    /// @dev Sender has to be allowed to call this method\n    /// @param creditToSell Amount of credit to sell for tokens [wad]\n    /// @param bid Starting bid (in tokens) of the auction [wad]\n    /// @return auctionId Id of the started surplus auction\n    function startAuction(uint256 creditToSell, uint256 bid) external override checkCaller returns (uint256 auctionId) {\n        if (live == 0) revert SurplusAuction__startAuction_notLive();\n        if (auctionCounter >= ~uint256(0)) revert SurplusAuction__startAuction_overflow();\n        unchecked {\n            auctionId = ++auctionCounter;\n        }\n\n        auctions[auctionId].bid = bid;\n        auctions[auctionId].creditToSell = creditToSell;\n        auctions[auctionId].recipient = msg.sender; // configurable??\n        auctions[auctionId].auctionExpiry = add48(uint48(block.timestamp), auctionDuration);\n\n        codex.transferCredit(msg.sender, address(this), creditToSell);\n\n        emit StartAuction(auctionId, creditToSell, bid);\n    }\n\n    /// @notice Resets an existing surplus auction\n    /// @dev Auction expiry has to be exceeded and no bids have to be made\n    /// @param auctionId Id of the auction to reset\n    function redoAuction(uint256 auctionId) external override {\n        if (auctions[auctionId].auctionExpiry >= block.timestamp) revert SurplusAuction__redoAuction_notFinished();\n        if (auctions[auctionId].bidExpiry != 0) revert SurplusAuction__redoAuction_bidAlreadyPlaced();\n        auctions[auctionId].auctionExpiry = add48(uint48(block.timestamp), auctionDuration);\n    }\n\n    /// @notice Bid for the fixed credit amount (`creditToSell`) with a higher amount of tokens (`bid`)\n    /// @param auctionId Id of the debt auction\n    /// @param creditToSell Amount of credit to receive (has to match)\n    /// @param bid Amount of tokens to pay for credit (has to be higher than prev. bid)\n    function submitBid(\n        uint256 auctionId,\n        uint256 creditToSell,\n        uint256 bid\n    ) external override {\n        if (live == 0) revert SurplusAuction__submitBid_notLive();\n        if (auctions[auctionId].recipient == address(0)) revert SurplusAuction__submit_recipientNotSet();\n        if (auctions[auctionId].bidExpiry <= block.timestamp && auctions[auctionId].bidExpiry != 0)\n            revert SurplusAuction__submitBid_alreadyFinishedBidExpiry();\n        if (auctions[auctionId].auctionExpiry <= block.timestamp)\n            revert SurplusAuction__submitBid_alreadyFinishedAuctionExpiry();\n\n        if (creditToSell != auctions[auctionId].creditToSell)\n            revert SurplusAuction__submitBid_creditToSellNotMatching();\n        if (bid <= auctions[auctionId].bid) revert SurplusAuction__submitBid_bidNotHigher();\n        if (mul(bid, WAD) < mul(minBidBump, auctions[auctionId].bid))\n            revert SurplusAuction__submitBid_insufficientIncrease();\n\n        if (msg.sender != auctions[auctionId].recipient) {\n            token.transferFrom(msg.sender, auctions[auctionId].recipient, auctions[auctionId].bid);\n            auctions[auctionId].recipient = msg.sender;\n        }\n        token.transferFrom(msg.sender, address(this), sub(bid, auctions[auctionId].bid));\n\n        auctions[auctionId].bid = bid;\n        auctions[auctionId].bidExpiry = add48(uint48(block.timestamp), bidDuration);\n    }\n\n    /// @notice Closes a finished auction and mints new tokens to the winning bidders\n    /// @param auctionId Id of the debt auction to close\n    function closeAuction(uint256 auctionId) external override {\n        if (live == 0) revert SurplusAuction__closeAuction_notLive();\n        if (\n            !(auctions[auctionId].bidExpiry != 0 &&\n                (auctions[auctionId].bidExpiry < block.timestamp ||\n                    auctions[auctionId].auctionExpiry < block.timestamp))\n        ) revert SurplusAuction__closeAuction_notFinished();\n        codex.transferCredit(address(this), auctions[auctionId].recipient, auctions[auctionId].creditToSell);\n        token.transfer(address(0), auctions[auctionId].bid);\n        delete auctions[auctionId];\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Locks the contract and transfer the credit in this contract to the caller\n    /// @dev Sender has to be allowed to call this method\n    function lock(uint256 credit) external override checkCaller {\n        live = 0;\n        codex.transferCredit(address(this), msg.sender, credit);\n    }\n\n    /// @notice Cancels an existing auction by returning the tokens bid to its bidder\n    /// @dev Can only be called when the contract is locked\n    /// @param auctionId Id of the surplus auction to cancel\n    function cancelAuction(uint256 auctionId) external override {\n        if (live == 1) revert SurplusAuction__cancelAuction_stillLive();\n        if (auctions[auctionId].recipient == address(0)) revert SurplusAuction__cancelAuction_recipientNotSet();\n        token.transferFrom(address(this), auctions[auctionId].recipient, auctions[auctionId].bid);\n        delete auctions[auctionId];\n    }\n}// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n\n\n\n\n/// @title DebtAuction\n/// @notice\n/// Uses Flop.sol from DSS (MakerDAO) as a blueprint\n/// Changes from Flop.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract DebtAuction is Guarded, IDebtAuction {\n    /// ======== Custom Errors ======== ///\n\n    error DebtAuction__setParam_unrecognizedParam();\n    error DebtAuction__startAuction_notLive();\n    error DebtAuction__startAuction_overflow();\n    error DebtAuction__redoAuction_notFinished();\n    error DebtAuction__redoAuction_bidAlreadyPlaced();\n    error DebtAuction__submitBid_notLive();\n    error DebtAuction__submitBid_recipientNotSet();\n    error DebtAuction__submitBid_expired();\n    error DebtAuction__submitBid_alreadyFinishedAuctionExpiry();\n    error DebtAuction__submitBid_notMatchingBid();\n    error DebtAuction__submitBid_tokensToSellNotLower();\n    error DebtAuction__submitBid_insufficientDecrease();\n    error DebtAuction__closeAuction_notLive();\n    error DebtAuction__closeAuction_notFinished();\n    error DebtAuction__cancelAuction_stillLive();\n    error DebtAuction__cancelAuction_recipientNotSet();\n\n    /// ======== Storage ======== ///\n\n    // Auction State\n    struct Auction {\n        // credit paid [wad]\n        uint256 bid;\n        // tokens in return for bid [wad]\n        uint256 tokensToSell;\n        // high bidder\n        address recipient;\n        // bid expiry time [unix epoch time]\n        uint48 bidExpiry;\n        // auction expiry time [unix epoch time]\n        uint48 auctionExpiry;\n    }\n\n    /// @notice State of auctions\n    // AuctionId => Auction\n    mapping(uint256 => Auction) public override auctions;\n\n    /// @notice Codex\n    ICodex public immutable override codex;\n    /// @notice Token to sell for debt\n    IERC20 public immutable override token;\n\n    /// @notice 5% minimum bid increase\n    uint256 public override minBidBump = 1.05e18;\n    /// @notice 50% tokensToSell increase for redoAuction\n    uint256 public override tokenToSellBump = 1.50e18;\n    /// @notice 3 hours bid lifetime [seconds]\n    uint48 public override bidDuration = 3 hours;\n    /// @notice 2 days total auction length [seconds]\n    uint48 public override auctionDuration = 2 days;\n    /// @notice Auction Counter\n    uint256 public override auctionCounter = 0;\n\n    /// @notice Boolean indicating if this contract is live (0 - not live, 1 - live)\n    uint256 public override live;\n\n    /// @notice Aer, not used until shutdown\n    address public override aer;\n\n    /// ======== Events ======== ///\n\n    event StartAuction(uint256 id, uint256 tokensToSell, uint256 bid, address indexed recipient);\n\n    constructor(address codex_, address token_) Guarded() {\n        codex = ICodex(codex_);\n        token = IERC20(token_);\n        live = 1;\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (param == \"minBidBump\") minBidBump = data;\n        else if (param == \"tokenToSellBump\") tokenToSellBump = data;\n        else if (param == \"bidDuration\") bidDuration = uint48(data);\n        else if (param == \"auctionDuration\") auctionDuration = uint48(data);\n        else revert DebtAuction__setParam_unrecognizedParam();\n    }\n\n    /// ======== Debt Auction ======== ///\n\n    /// @notice Start a new debt auction\n    /// @dev Sender has to be allowed to call this method\n    /// @param recipient Initial recipient of the credit\n    /// @param tokensToSell Amount of tokens to sell for credit [wad]\n    /// @param bid Starting bid (in credit) of the auction [wad]\n    /// @return auctionId Id of the started debt auction\n    function startAuction(\n        address recipient,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external override checkCaller returns (uint256 auctionId) {\n        if (live == 0) revert DebtAuction__startAuction_notLive();\n        if (auctionCounter >= type(uint256).max) revert DebtAuction__startAuction_overflow();\n        unchecked {\n            auctionId = ++auctionCounter;\n        }\n\n        auctions[auctionId].bid = bid;\n        auctions[auctionId].tokensToSell = tokensToSell;\n        auctions[auctionId].recipient = recipient;\n        auctions[auctionId].auctionExpiry = add48(uint48(block.timestamp), uint48(auctionDuration));\n\n        emit StartAuction(auctionId, tokensToSell, bid, recipient);\n    }\n\n    /// @notice Resets an existing debt auction\n    /// @dev Auction expiry has to be exceeded and no bids have to be made\n    /// @param auctionId Id of the auction to reset\n    function redoAuction(uint256 auctionId) external override {\n        if (auctions[auctionId].auctionExpiry >= block.timestamp) revert DebtAuction__redoAuction_notFinished();\n        if (auctions[auctionId].bidExpiry != 0) revert DebtAuction__redoAuction_bidAlreadyPlaced();\n        auctions[auctionId].tokensToSell = mul(tokenToSellBump, auctions[auctionId].tokensToSell) / WAD;\n        auctions[auctionId].auctionExpiry = add48(uint48(block.timestamp), auctionDuration);\n    }\n\n    /// @notice Bid for the fixed credit amount (`bid`) by accepting a lower amount of `tokensToSell`\n    /// @param auctionId Id of the debt auction\n    /// @param tokensToSell Amount of tokens to receive (has to be lower than prev. bid)\n    /// @param bid Amount of credit to pay for tokens (has to match)\n    function submitBid(\n        uint256 auctionId,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external override {\n        if (live == 0) revert DebtAuction__submitBid_notLive();\n        if (auctions[auctionId].recipient == address(0)) revert DebtAuction__submitBid_recipientNotSet();\n        if (auctions[auctionId].bidExpiry <= block.timestamp && auctions[auctionId].bidExpiry != 0)\n            revert DebtAuction__submitBid_expired();\n        if (auctions[auctionId].auctionExpiry <= block.timestamp)\n            revert DebtAuction__submitBid_alreadyFinishedAuctionExpiry();\n\n        if (bid != auctions[auctionId].bid) revert DebtAuction__submitBid_notMatchingBid();\n        if (tokensToSell >= auctions[auctionId].tokensToSell) revert DebtAuction__submitBid_tokensToSellNotLower();\n        if (mul(minBidBump, tokensToSell) > mul(auctions[auctionId].tokensToSell, WAD))\n            revert DebtAuction__submitBid_insufficientDecrease();\n\n        if (msg.sender != auctions[auctionId].recipient) {\n            codex.transferCredit(msg.sender, auctions[auctionId].recipient, bid);\n\n            // on first submitBid, clear as much debtOnAuction as possible\n            if (auctions[auctionId].bidExpiry == 0) {\n                uint256 debtOnAuction = IAer(auctions[auctionId].recipient).debtOnAuction();\n                IAer(auctions[auctionId].recipient).settleAuctionedDebt(min(bid, debtOnAuction));\n            }\n\n            auctions[auctionId].recipient = msg.sender;\n        }\n\n        auctions[auctionId].tokensToSell = tokensToSell;\n        auctions[auctionId].bidExpiry = add48(uint48(block.timestamp), bidDuration);\n    }\n\n    /// @notice Closes a finished auction and transfers tokens to the winning bidders\n    /// @param auctionId Id of the debt auction to close\n    function closeAuction(uint256 auctionId) external override {\n        if (live == 0) revert DebtAuction__closeAuction_notLive();\n        if (\n            !(auctions[auctionId].bidExpiry != 0 &&\n                (auctions[auctionId].bidExpiry < block.timestamp ||\n                    auctions[auctionId].auctionExpiry < block.timestamp))\n        ) revert DebtAuction__closeAuction_notFinished();\n        token.transfer(auctions[auctionId].recipient, auctions[auctionId].tokensToSell);\n        delete auctions[auctionId];\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Locks the contract and sets the address of Aer\n    /// @dev Sender has to be allowed to call this method\n    function lock() external override checkCaller {\n        live = 0;\n        aer = msg.sender;\n    }\n\n    /// @notice Cancels an existing auction by minting new credit directly to the auctions recipient\n    /// @dev Can only be called when the contract is locked\n    /// @param auctionId Id of the debt auction to cancel\n    function cancelAuction(uint256 auctionId) external override {\n        if (live == 1) revert DebtAuction__cancelAuction_stillLive();\n        if (auctions[auctionId].recipient == address(0)) revert DebtAuction__cancelAuction_recipientNotSet();\n        codex.createUnbackedDebt(aer, auctions[auctionId].recipient, auctions[auctionId].bid);\n        delete auctions[auctionId];\n    }\n}// Copyright (C) 2020-2021 Maker Ecosystem Growth Holdings, INC.\n\ninterface INoLossCollateralAuction {\n    function vaults(address)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            ICollybus,\n            IPriceCalculator\n        );\n\n    function codex() external view returns (ICodex);\n\n    function limes() external view returns (ILimes);\n\n    function aer() external view returns (IAer);\n\n    function feeTip() external view returns (uint64);\n\n    function flatTip() external view returns (uint192);\n\n    function auctionCounter() external view returns (uint256);\n\n    function activeAuctions(uint256) external view returns (uint256);\n\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            address,\n            uint96,\n            uint256\n        );\n\n    function stopped() external view returns (uint256);\n\n    function init(address vault, address collybus) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        address data\n    ) external;\n\n    function startAuction(\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address keeper\n    ) external returns (uint256 auctionId);\n\n    function redoAuction(uint256 auctionId, address keeper) external;\n\n    function takeCollateral(\n        uint256 auctionId,\n        uint256 collateralAmount,\n        uint256 maxPrice,\n        address recipient,\n        bytes calldata data\n    ) external;\n\n    function count() external view returns (uint256);\n\n    function list() external view returns (uint256[] memory);\n\n    function getStatus(uint256 auctionId)\n        external\n        view\n        returns (\n            bool needsRedo,\n            uint256 price,\n            uint256 collateralToSell,\n            uint256 debt\n        );\n\n    function updateAuctionDebtFloor(address vault) external;\n\n    function cancelAuction(uint256 auctionId) external;\n}\n\n/// @title NoLossCollateralAuction\n/// @notice Same as CollateralAuction but enforces a floor price of debt / collateral\n/// Uses Clip.sol from DSS (MakerDAO) as a blueprint\n/// Changes from Clip.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract NoLossCollateralAuction is Guarded, INoLossCollateralAuction {\n    /// ======== Custom Errors ======== ///\n\n    error NoLossCollateralAuction__init_vaultAlreadyInit();\n    error NoLossCollateralAuction__checkReentrancy_reentered();\n    error NoLossCollateralAuction__isStopped_stoppedIncorrect();\n    error NoLossCollateralAuction__setParam_unrecognizedParam();\n    error NoLossCollateralAuction__startAuction_zeroDebt();\n    error NoLossCollateralAuction__startAuction_zeroCollateralToSell();\n    error NoLossCollateralAuction__startAuction_zeroUser();\n    error NoLossCollateralAuction__startAuction_overflow();\n    error NoLossCollateralAuction__startAuction_zeroStartPrice();\n    error NoLossCollateralAuction__redoAuction_notRunningAuction();\n    error NoLossCollateralAuction__redoAuction_cannotReset();\n    error NoLossCollateralAuction__redoAuction_zeroStartPrice();\n    error NoLossCollateralAuction__takeCollateral_notRunningAuction();\n    error NoLossCollateralAuction__takeCollateral_needsReset();\n    error NoLossCollateralAuction__takeCollateral_tooExpensive();\n    error NoLossCollateralAuction__takeCollateral_noPartialPurchase();\n    error NoLossCollateralAuction__cancelAuction_notRunningAction();\n\n    /// ======== Storage ======== ///\n\n    // Vault specific configuration data\n    struct VaultConfig {\n        // Multiplicative factor to increase start price [wad]\n        uint256 multiplier;\n        // Time elapsed before auction reset [seconds]\n        uint256 maxAuctionDuration;\n        // Cache (v.debtFloor * v.liquidationPenalty) to prevent excessive SLOADs [wad]\n        uint256 auctionDebtFloor;\n        // Collateral price module\n        ICollybus collybus;\n        // Current price calculator\n        IPriceCalculator calculator;\n    }\n\n    /// @notice Vault Configs\n    /// @dev Vault => Vault Config\n    mapping(address => VaultConfig) public override vaults;\n\n    /// @notice Codex\n    ICodex public immutable override codex;\n    /// @notice Limes\n    ILimes public override limes;\n    /// @notice Aer (Recipient of credit raised in auctions)\n    IAer public override aer;\n    /// @notice Percentage of debt to mint from aer to incentivize keepers [wad]\n    uint64 public override feeTip;\n    /// @notice Flat fee to mint from aer to incentivize keepers [wad]\n    uint192 public override flatTip;\n    /// @notice Total auctions (includes past auctions)\n    uint256 public override auctionCounter;\n    /// @notice Array of active auction ids\n    uint256[] public override activeAuctions;\n\n    // Auction State\n    struct Auction {\n        // Index in activeAuctions array\n        uint256 index;\n        // Debt to sell == Credit to raise [wad]\n        uint256 debt;\n        // collateral to sell [wad]\n        uint256 collateralToSell;\n        // Vault of the liquidated Positions collateral\n        address vault;\n        // TokenId of the liquidated Positions collateral\n        uint256 tokenId;\n        // Owner of the liquidated Position\n        address user;\n        // Auction start time\n        uint96 startsAt;\n        // Starting price [wad]\n        uint256 startPrice;\n    }\n    /// @notice State of auctions\n    /// @dev AuctionId => Auction\n    mapping(uint256 => Auction) public override auctions;\n\n    // reentrancy guard\n    uint256 private entered;\n\n    /// @notice Circuit breaker level\n    /// Levels for circuit breaker\n    /// 0: no breaker\n    /// 1: no new startAuction()\n    /// 2: no new startAuction() or redoAuction()\n    /// 3: no new startAuction(), redoAuction(), or takeCollateral()\n    uint256 public override stopped = 0;\n\n    /// ======== Events ======== ///\n\n    event Init(address vault);\n\n    event SetParam(bytes32 indexed param, uint256 data);\n    event SetParam(bytes32 indexed param, address data);\n\n    event StartAuction(\n        uint256 indexed auctionId,\n        uint256 startPrice,\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address indexed keeper,\n        uint256 tip\n    );\n    event TakeCollateral(\n        uint256 indexed auctionId,\n        uint256 maxPrice,\n        uint256 price,\n        uint256 owe,\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address indexed user\n    );\n    event RedoAuction(\n        uint256 indexed auctionId,\n        uint256 startPrice,\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address indexed keeper,\n        uint256 tip\n    );\n\n    event StopAuction(uint256 auctionId);\n\n    event UpdateAuctionDebtFloor(address indexed vault, uint256 auctionDebtFloor);\n\n    constructor(address codex_, address limes_) Guarded() {\n        codex = ICodex(codex_);\n        limes = ILimes(limes_);\n    }\n\n    modifier checkReentrancy() {\n        if (entered == 0) {\n            entered = 1;\n            _;\n            entered = 0;\n        } else revert NoLossCollateralAuction__checkReentrancy_reentered();\n    }\n\n    modifier isStopped(uint256 level) {\n        if (stopped < level) {\n            _;\n        } else revert NoLossCollateralAuction__isStopped_stoppedIncorrect();\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Initializes a new Vault for which collateral can be auctioned off\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param collybus Address of the Collybus the Vault uses for pricing\n    function init(address vault, address collybus) external override checkCaller {\n        if (vaults[vault].calculator != IPriceCalculator(address(0)))\n            revert NoLossCollateralAuction__init_vaultAlreadyInit();\n        vaults[vault].multiplier = WAD;\n        vaults[vault].collybus = ICollybus(collybus);\n\n        emit Init(vault);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller checkReentrancy {\n        if (param == \"feeTip\")\n            feeTip = uint64(data); // Percentage of debt to incentivize (max: 2^64 - 1 => 18.xxx WAD = 18xx%)\n        else if (param == \"flatTip\")\n            flatTip = uint192(data); // Flat fee to incentivize keepers (max: 2^192 - 1 => 6.277T WAD)\n        else if (param == \"stopped\")\n            stopped = data; // Set breaker (0, 1, 2, or 3)\n        else revert NoLossCollateralAuction__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(bytes32 param, address data) external override checkCaller checkReentrancy {\n        if (param == \"limes\") limes = ILimes(data);\n        else if (param == \"aer\") aer = IAer(data);\n        else revert NoLossCollateralAuction__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external override checkCaller checkReentrancy {\n        if (param == \"multiplier\") vaults[vault].multiplier = data;\n        else if (param == \"maxAuctionDuration\")\n            vaults[vault].maxAuctionDuration = data; // Time elapsed before auction reset\n        else revert NoLossCollateralAuction__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(\n        address vault,\n        bytes32 param,\n        address data\n    ) external override checkCaller checkReentrancy {\n        if (param == \"collybus\") vaults[vault].collybus = ICollybus(data);\n        else if (param == \"calculator\") vaults[vault].calculator = IPriceCalculator(data);\n        else revert NoLossCollateralAuction__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== No Loss Collateral Auction ======== ///\n\n    // get price at maturity\n    function _getPrice(address vault, uint256 tokenId) internal view returns (uint256) {\n        return IVault(vault).fairPrice(tokenId, false, true);\n    }\n\n    /// @notice Starts a collateral auction\n    /// The start price `startPrice` is obtained as follows:\n    ///     startPrice = val * multiplier / redemptionPrice\n    /// Where `val` is the collateral's unitary value in USD, `multiplier` is a\n    /// multiplicative factor to increase the start price, and `redemptionPrice` is a reference per Credit.\n    /// @dev Sender has to be allowed to call this method\n    /// - trusts the caller to transfer collateral to the contract\n    /// - reverts if circuit breaker is set to 1 (no new auctions)\n    /// @param debt Amount of debt to sell / credit to buy [wad]\n    /// @param collateralToSell Amount of collateral to sell [wad]\n    /// @param vault Address of the collaterals Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20) of the collateral\n    /// @param user Address that will receive any leftover collateral\n    /// @param keeper Address that will receive incentives\n    /// @return auctionId Identifier of started auction\n    function startAuction(\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address keeper\n    ) external override checkCaller checkReentrancy isStopped(1) returns (uint256 auctionId) {\n        // Input validation\n        if (debt == 0) revert NoLossCollateralAuction__startAuction_zeroDebt();\n        if (collateralToSell == 0) revert NoLossCollateralAuction__startAuction_zeroCollateralToSell();\n        if (user == address(0)) revert NoLossCollateralAuction__startAuction_zeroUser();\n        unchecked {\n            auctionId = ++auctionCounter;\n        }\n        if (auctionId == 0) revert NoLossCollateralAuction__startAuction_overflow();\n\n        activeAuctions.push(auctionId);\n\n        auctions[auctionId].index = activeAuctions.length - 1;\n\n        auctions[auctionId].debt = debt;\n        auctions[auctionId].collateralToSell = collateralToSell;\n        auctions[auctionId].vault = vault;\n        auctions[auctionId].tokenId = tokenId;\n        auctions[auctionId].user = user;\n        auctions[auctionId].startsAt = uint96(block.timestamp);\n\n        uint256 startPrice;\n        startPrice = wmul(_getPrice(vault, tokenId), vaults[vault].multiplier);\n        if (startPrice <= 0) revert NoLossCollateralAuction__startAuction_zeroStartPrice();\n        auctions[auctionId].startPrice = startPrice;\n\n        // incentive to startAuction auction\n        uint256 _tip = flatTip;\n        uint256 _feeTip = feeTip;\n        uint256 tip;\n        if (_tip > 0 || _feeTip > 0) {\n            tip = add(_tip, wmul(debt, _feeTip));\n            codex.createUnbackedDebt(address(aer), keeper, tip);\n        }\n\n        emit StartAuction(auctionId, startPrice, debt, collateralToSell, vault, tokenId, user, keeper, tip);\n    }\n\n    /// @notice Resets an existing collateral auction\n    /// See `startAuction` above for an explanation of the computation of `startPrice`.\n    /// multiplicative factor to increase the start price, and `redemptionPrice` is a reference per Credit.\n    /// @dev Reverts if circuit breaker is set to 2 (no new auctions and no redos of auctions)\n    /// @param auctionId Id of the auction to reset\n    /// @param keeper Address that will receive incentives\n    function redoAuction(uint256 auctionId, address keeper) external override checkReentrancy isStopped(2) {\n        // Read auction data\n        Auction memory auction = auctions[auctionId];\n\n        if (auction.user == address(0)) revert NoLossCollateralAuction__redoAuction_notRunningAuction();\n\n        // Check that auction needs reset\n        // and compute current price [wad]\n        {\n            (bool done, ) = status(auction);\n            if (!done) revert NoLossCollateralAuction__redoAuction_cannotReset();\n        }\n\n        uint256 debt = auctions[auctionId].debt;\n        uint256 collateralToSell = auctions[auctionId].collateralToSell;\n        auctions[auctionId].startsAt = uint96(block.timestamp);\n\n        uint256 price = _getPrice(auction.vault, auction.tokenId);\n        uint256 startPrice = wmul(price, vaults[auction.vault].multiplier);\n        if (startPrice <= 0) revert NoLossCollateralAuction__redoAuction_zeroStartPrice();\n        auctions[auctionId].startPrice = startPrice;\n\n        // incentive to redoAuction auction\n        uint256 tip;\n        {\n            uint256 _tip = flatTip;\n            uint256 _feeTip = feeTip;\n            if (_tip > 0 || _feeTip > 0) {\n                uint256 _auctionDebtFloor = vaults[auction.vault].auctionDebtFloor;\n                if (debt >= _auctionDebtFloor && wmul(collateralToSell, price) >= _auctionDebtFloor) {\n                    tip = add(_tip, wmul(debt, _feeTip));\n                    codex.createUnbackedDebt(address(aer), keeper, tip);\n                }\n            }\n        }\n\n        emit RedoAuction(\n            auctionId,\n            startPrice,\n            debt,\n            collateralToSell,\n            auction.vault,\n            auction.tokenId,\n            auction.user,\n            keeper,\n            tip\n        );\n    }\n\n    /// @notice Buy up to `collateralAmount` of collateral from the auction indexed by `id`\n    ///\n    /// Auctions will not collect more Credit than their assigned Credit target,`debt`;\n    /// thus, if `collateralAmount` would cost more Credit than `debt` at the current price, the\n    /// amount of collateral purchased will instead be just enough to collect `debt` in Credit.\n    ///\n    /// To avoid partial purchases resulting in very small leftover auctions that will\n    /// never be cleared, any partial purchase must leave at least `CollateralAuction.auctionDebtFloor`\n    /// remaining Credit target. `auctionDebtFloor` is an asynchronously updated value equal to\n    /// (Codex.debtFloor * Limes.liquidationPenalty(vault) / WAD) where the values are understood to be determined\n    /// by whatever they were when CollateralAuction.updateAuctionDebtFloor() was last called. Purchase amounts\n    /// will be minimally decreased when necessary to respect this limit; i.e., if the\n    /// specified `collateralAmount` would leave `debt < auctionDebtFloor` but `debt > 0`, the amount actually\n    /// purchased will be such that `debt == auctionDebtFloor`.\n    ///\n    /// If `debt <= auctionDebtFloor`, partial purchases are no longer possible; that is, the remaining\n    /// collateral can only be purchased entirely, or not at all.\n    ///\n    /// Enforces a price floor of debt / collateral\n    ///\n    /// @dev Reverts if circuit breaker is set to 3 (no new auctions, no redos of auctions and no collateral buying)\n    /// @param auctionId Id of the auction to buy collateral from\n    /// @param collateralAmount Upper limit on amount of collateral to buy [wad]\n    /// @param maxPrice Maximum acceptable price (Credit / collateral) [wad]\n    /// @param recipient Receiver of collateral and external call address\n    /// @param data Data to pass in external call; if length 0, no call is done\n    function takeCollateral(\n        uint256 auctionId, // Auction id\n        uint256 collateralAmount, // Upper limit on amount of collateral to buy [wad]\n        uint256 maxPrice, // Maximum acceptable price (Credit / collateral) [wad]\n        address recipient, // Receiver of collateral and external call address\n        bytes calldata data // Data to pass in external call; if length 0, no call is done\n    ) external override checkReentrancy isStopped(3) {\n        Auction memory auction = auctions[auctionId];\n\n        if (auction.user == address(0)) revert NoLossCollateralAuction__takeCollateral_notRunningAuction();\n\n        uint256 price;\n        {\n            bool done;\n            (done, price) = status(auction);\n\n            // Check that auction doesn't need reset\n            if (done) revert NoLossCollateralAuction__takeCollateral_needsReset();\n            // Ensure price is acceptable to buyer\n            if (maxPrice < price) revert NoLossCollateralAuction__takeCollateral_tooExpensive();\n        }\n\n        uint256 collateralToSell = auction.collateralToSell;\n        uint256 debt = auction.debt;\n        uint256 owe;\n\n        unchecked {\n            {\n                // Purchase as much as possible, up to collateralAmount\n                // collateralSlice <= collateralToSell\n                uint256 collateralSlice = min(collateralToSell, collateralAmount);\n\n                // Credit needed to buy a collateralSlice of this auction\n                owe = wmul(collateralSlice, price);\n\n                // owe can be greater than debt and thus user would pay a premium to the recipient\n\n                if (owe < debt && collateralSlice < collateralToSell) {\n                    // If collateralSlice == collateralToSell => auction completed => debtFloor doesn't matter\n                    uint256 _auctionDebtFloor = vaults[auction.vault].auctionDebtFloor;\n                    if (debt - owe < _auctionDebtFloor) {\n                        // safe as owe < debt\n                        // If debt <= auctionDebtFloor, buyers have to take the entire collateralToSell.\n                        if (debt <= _auctionDebtFloor)\n                            revert NoLossCollateralAuction__takeCollateral_noPartialPurchase();\n                        // Adjust amount to pay\n                        owe = debt - _auctionDebtFloor; // owe' <= owe\n                        // Adjust collateralSlice\n                        // collateralSlice' = owe' / price < owe / price == collateralSlice < collateralToSell\n                        collateralSlice = wdiv(owe, price);\n                    }\n                }\n\n                // Calculate remaining collateralToSell after operation\n                collateralToSell = collateralToSell - collateralSlice;\n\n                // Send collateral to recipient\n                codex.transferBalance(auction.vault, auction.tokenId, address(this), recipient, collateralSlice);\n\n                // Do external call (if data is defined) but to be\n                // extremely careful we don't allow to do it to the two\n                // contracts which the CollateralAuction needs to be authorized\n                ILimes limes_ = limes;\n                if (data.length > 0 && recipient != address(codex) && recipient != address(limes_)) {\n                    CollateralAuctionCallee(recipient).collateralAuctionCall(msg.sender, owe, collateralSlice, data);\n                }\n\n                // Get Credit from caller\n                codex.transferCredit(msg.sender, address(aer), owe);\n\n                // Removes Credit out for liquidation from accumulator\n                // if all collateral has been sold or owe is larger than remaining debt\n                //  then just remove the remaining debt from the accumulator\n                limes_.liquidated(auction.vault, auction.tokenId, (collateralToSell == 0 || debt < owe) ? debt : owe);\n\n                // Calculate remaining debt after operation\n                debt = (owe < debt) ? debt - owe : 0; // safe since owe <= debt\n            }\n        }\n\n        if (collateralToSell == 0) {\n            _remove(auctionId);\n        } else if (debt == 0) {\n            codex.transferBalance(auction.vault, auction.tokenId, address(this), auction.user, collateralToSell);\n            _remove(auctionId);\n        } else {\n            auctions[auctionId].debt = debt;\n            auctions[auctionId].collateralToSell = collateralToSell;\n        }\n\n        emit TakeCollateral(\n            auctionId,\n            maxPrice,\n            price,\n            owe,\n            debt,\n            collateralToSell,\n            auction.vault,\n            auction.tokenId,\n            auction.user\n        );\n    }\n\n    // Removes an auction from the active auctions array\n    function _remove(uint256 auctionId) internal {\n        uint256 _move = activeAuctions[activeAuctions.length - 1];\n        if (auctionId != _move) {\n            uint256 _index = auctions[auctionId].index;\n            activeAuctions[_index] = _move;\n            auctions[_move].index = _index;\n        }\n        activeAuctions.pop();\n        delete auctions[auctionId];\n    }\n\n    /// @notice The number of active auctions\n    /// @return Number of active auctions\n    function count() external view override returns (uint256) {\n        return activeAuctions.length;\n    }\n\n    /// @notice Returns the entire array of active auctions\n    /// @return List of active auctions\n    function list() external view override returns (uint256[] memory) {\n        return activeAuctions;\n    }\n\n    /// @notice Externally returns boolean for if an auction needs a redo and also the current price\n    /// @param auctionId Id of the auction to get the status for\n    /// @return needsRedo If the auction needs a redo (max duration or max discount exceeded)\n    /// @return price Current price of the collateral determined by the calculator [wad]\n    /// @return collateralToSell Amount of collateral left to buy for credit [wad]\n    /// @return debt Amount of debt / credit to sell for collateral [wad]\n    function getStatus(uint256 auctionId)\n        external\n        view\n        override\n        returns (\n            bool needsRedo,\n            uint256 price,\n            uint256 collateralToSell,\n            uint256 debt\n        )\n    {\n        Auction memory auction = auctions[auctionId];\n\n        bool done;\n        (done, price) = status(auction);\n\n        needsRedo = auction.user != address(0) && done;\n        collateralToSell = auction.collateralToSell;\n        debt = auction.debt;\n    }\n\n    // Internally returns boolean for if an auction needs a redo\n    function status(Auction memory auction) internal view returns (bool done, uint256 price) {\n        uint256 floorPrice = wdiv(auction.debt, auction.collateralToSell);\n        price = max(\n            floorPrice,\n            vaults[auction.vault].calculator.price(auction.startPrice, sub(block.timestamp, auction.startsAt))\n        );\n        done = (sub(block.timestamp, auction.startsAt) > vaults[auction.vault].maxAuctionDuration ||\n            price == floorPrice);\n    }\n\n    /// @notice Public function to update the cached vault.debtFloor*vault.liquidationPenalty value\n    /// @param vault Address of the Vault for which to update the auctionDebtFloor variable\n    function updateAuctionDebtFloor(address vault) external override {\n        (, , , uint256 _debtFloor) = ICodex(codex).vaults(vault);\n        uint256 auctionDebtFloor = wmul(_debtFloor, limes.liquidationPenalty(vault));\n        vaults[vault].auctionDebtFloor = auctionDebtFloor;\n        emit UpdateAuctionDebtFloor(vault, auctionDebtFloor);\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Cancels an auction during shutdown or via governance action\n    /// @dev Sender has to be allowed to call this method\n    /// @param auctionId Id of the auction to cancel\n    function cancelAuction(uint256 auctionId) external override checkCaller checkReentrancy {\n        if (auctions[auctionId].user == address(0)) revert NoLossCollateralAuction__cancelAuction_notRunningAction();\n        address vault = auctions[auctionId].vault;\n        uint256 tokenId = auctions[auctionId].tokenId;\n        limes.liquidated(vault, tokenId, auctions[auctionId].debt);\n        codex.transferBalance(vault, tokenId, address(this), msg.sender, auctions[auctionId].collateralToSell);\n        _remove(auctionId);\n        emit StopAuction(auctionId);\n    }\n}// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\n\n\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\n\n\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\n\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\n\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\n\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n\n\n\n\n\n/// @title Fixed Income Asset Token (FIAT)\n/// @notice `FIAT` is the protocol's stable asset which can be redeemed for `Credit` via `Moneta`\ncontract FIAT is Guarded, ERC20Permit, IFIATExcl {\n    constructor() Guarded() ERC20(\"Fixed Income Asset Token\", \"FIAT\") ERC20Permit(\"Fixed Income Asset Token\") {}\n\n    /// ======== Minting and Burning ======== ///\n\n    /// @notice Increases the totalSupply by `amount` and transfers the new tokens to `to`\n    /// @dev Sender has to be allowed to call this method\n    /// @param to Address to which tokens should be credited to\n    /// @param amount Amount of tokens to be minted [wad]\n    function mint(address to, uint256 amount) external override checkCaller {\n        _mint(to, amount);\n    }\n\n    /// @notice Decreases the totalSupply by `amount` and using the tokens from `from`\n    /// @dev If `from` is not the caller, caller needs to have sufficient allowance from `from`,\n    /// `amount` is then deducted from the caller's allowance\n    /// @param from Address from which tokens should be burned from\n    /// @param amount Amount of tokens to be burned [wad]\n    function burn(address from, uint256 amount) public virtual {\n        _spendAllowance(from, _msgSender(), amount);\n        _burn(from, amount);\n    }\n\n    /// @notice Overrides `_spendAllowance` behaviour exempting the case where owner == spender\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal override {\n        if (owner == spender) return;\n        super._spendAllowance(owner, spender, amount);\n    }\n}// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n// Copyright (C) 2018 Lev Livnev <lev@liv.nev.org.uk>\n// Copyright (C) 2020-2021 Maker Ecosystem Growth Holdings, INC.\n\ninterface ITenebrae {\n    function codex() external view returns (ICodex);\n\n    function limes() external view returns (ILimes);\n\n    function aer() external view returns (IAer);\n\n    function collybus() external view returns (ICollybus);\n\n    function live() external view returns (uint256);\n\n    function lockedAt() external view returns (uint256);\n\n    function cooldownDuration() external view returns (uint256);\n\n    function debt() external view returns (uint256);\n\n    function lostCollateral(address, uint256) external view returns (uint256);\n\n    function normalDebtByTokenId(address, uint256) external view returns (uint256);\n\n    function claimed(\n        address,\n        uint256,\n        address\n    ) external view returns (uint256);\n\n    function setParam(bytes32 param, address data) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function lockPrice(address vault, uint256 tokenId) external view returns (uint256);\n\n    function redemptionPrice(address vault, uint256 tokenId) external view returns (uint256);\n\n    function lock() external;\n\n    function skipAuction(address vault, uint256 auctionId) external;\n\n    function offsetPosition(\n        address vault,\n        uint256 tokenId,\n        address user\n    ) external;\n\n    function closePosition(address vault, uint256 tokenId) external;\n\n    function fixGlobalDebt() external;\n\n    function redeem(\n        address vault,\n        uint256 tokenId,\n        uint256 credit\n    ) external;\n}\n\n/// @title Tenebrae\n/// @notice `Tenebrae` coordinates Global Settlement. This is an involved, stateful process that takes\n/// place over nine steps.\n///\n/// Uses End.sol from DSS (MakerDAO) / GlobalSettlement SafeEngine.sol from GEB (Reflexer Labs) as a blueprint\n/// Changes from End.sol / GlobalSettlement.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\n///\n/// @dev\n/// First we freeze the system and lock the prices for each vault and TokenId.\n///\n/// 1. `lock()`:\n///     - freezes user entrypoints\n///     - cancels debtAuction/surplusAuction auctions\n///     - starts cooldown period\n///\n/// We must process some system state before it is possible to calculate\n/// the final credit / collateral price. In particular, we need to determine\n///\n///     a. `debt`, the outstanding credit supply after including system surplus / deficit\n///\n///     b. `lostCollateral`, the collateral shortfall per collateral type by\n///     considering under-collateralised Positions.\n///\n/// We determine (a) by processing ongoing credit generating processes,\n/// i.e. auctions. We need to ensure that auctions will not generate any\n/// further credit income.\n///\n/// In the case of the Dutch Auctions model (CollateralAuction) they keep recovering\n/// debt during the whole lifetime and there isn't a max duration time\n/// guaranteed for the auction to end.\n/// So the way to ensure the protocol will not receive extra credit income is:\n///\n///     2a. i) `skipAuctions`: cancel all ongoing auctions and seize the collateral.\n///\n///         `skipAuctions(vault, id)`:\n///          - cancel individual running collateralAuction auctions\n///          - retrieves remaining collateral and debt (including penalty) to owner's Position\n///\n/// We determine (b) by processing all under-collateralised Positions with `offsetPosition`:\n///\n/// 3. `offsetPosition(vault, tokenId, position)`:\n///     - cancels the Position's debt with an equal amount of collateral\n///\n/// When a Position has been processed and has no debt remaining, the\n/// remaining collateral can be removed.\n///\n/// 4. `closePosition(vault)`:\n///     - remove collateral from the caller's Position\n///     - owner can call as needed\n///\n/// After the processing period has elapsed, we enable calculation of\n/// the final price for each collateral type.\n///\n/// 5. `fixGlobalDebt()`:\n///     - only callable after processing time period elapsed\n///     - assumption that all under-collateralised Positions are processed\n///     - fixes the total outstanding supply of credit\n///     - may also require extra Position processing to cover aer surplus\n///\n/// At this point we have computed the final price for each collateral\n/// type and credit holders can now turn their credit into collateral. Each\n/// unit credit can claim a fixed basket of collateral.\n///\n/// Finally, collateral can be obtained with `redeem`.\n///\n/// 6. `redeem(vault, tokenId wad)`:\n///     - exchange some credit for collateral tokens from a specific vault and tokenId\ncontract Tenebrae is Guarded, ITenebrae {\n    /// ======== Custom Errors ======== ///\n\n    error Tenebrae__setParam_notLive();\n    error Tenebrae__setParam_unknownParam();\n    error Tenebrae__lock_notLive();\n    error Tenebrae__skipAuction_debtNotZero();\n    error Tenebrae__skipAuction_overflow();\n    error Tenebrae__offsetPosition_debtNotZero();\n    error Tenebrae__offsetPosition_overflow();\n    error Tenebrae__closePosition_stillLive();\n    error Tenebrae__closePosition_debtNotZero();\n    error Tenebrae__closePosition_normalDebtNotZero();\n    error Tenebrae__closePosition_overflow();\n    error Tenebrae__fixGlobalDebt_stillLive();\n    error Tenebrae__fixGlobalDebt_debtNotZero();\n    error Tenebrae__fixGlobalDebt_surplusNotZero();\n    error Tenebrae__fixGlobalDebt_cooldownNotFinished();\n    error Tenebrae__redeem_redemptionPriceZero();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Codex\n    ICodex public override codex;\n    /// @notice Limes\n    ILimes public override limes;\n    /// @notice Aer\n    IAer public override aer;\n    /// @notice Collybus\n    ICollybus public override collybus;\n\n    /// @notice Time of lock [unix epoch time]\n    uint256 public override lockedAt;\n    /// @notice  // Processing Cooldown Length [seconds]\n    uint256 public override cooldownDuration;\n    /// @notice Total outstanding credit after processing all positions and auctions [wad]\n    uint256 public override debt;\n\n    /// @notice Boolean indicating if this contract is live (0 - not live, 1 - live)\n    uint256 public override live;\n\n    /// @notice Total collateral shortfall for each asset\n    /// @dev Vault => TokenId => Collateral shortfall [wad]\n    mapping(address => mapping(uint256 => uint256)) public override lostCollateral;\n    /// @notice Total normalized debt for each asset\n    /// @dev Vault => TokenId => Total debt per vault [wad]\n    mapping(address => mapping(uint256 => uint256)) public override normalDebtByTokenId;\n    /// @notice Amount of collateral claimed by users\n    /// @dev Vault => TokenId => Account => Collateral claimed [wad]\n    mapping(address => mapping(uint256 => mapping(address => uint256))) public override claimed;\n\n    /// ======== Events ======== ///\n\n    event SetParam(bytes32 indexed param, uint256 data);\n    event SetParam(bytes32 indexed param, address data);\n\n    event Lock();\n    event SkipAuction(\n        uint256 indexed auctionId,\n        address vault,\n        uint256 tokenId,\n        address indexed user,\n        uint256 debt,\n        uint256 collateralToSell,\n        uint256 normalDebt\n    );\n    event SettlePosition(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        uint256 settledCollateral,\n        uint256 normalDebt\n    );\n    event ClosePosition(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        uint256 collateral,\n        uint256 normalDebt\n    );\n    event FixGlobalDebt();\n    event Redeem(address indexed vault, uint256 indexed tokenId, address indexed user, uint256 credit);\n\n    constructor() Guarded() {\n        live = 1;\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(bytes32 param, address data) external override checkCaller {\n        if (live == 0) revert Tenebrae__setParam_notLive();\n        if (param == \"codex\") codex = ICodex(data);\n        else if (param == \"limes\") limes = ILimes(data);\n        else if (param == \"aer\") aer = IAer(data);\n        else if (param == \"collybus\") collybus = ICollybus(data);\n        else revert Tenebrae__setParam_unknownParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (live == 0) revert Tenebrae__setParam_notLive();\n        if (param == \"cooldownDuration\") cooldownDuration = data;\n        else revert Tenebrae__setParam_unknownParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Returns the price fixed when the system got locked\n    /// @dev Fair price remains fixed since no new rates or spot prices are submitted to Collybus\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @return lockPrice [wad]\n    function lockPrice(address vault, uint256 tokenId) public view override returns (uint256) {\n        return wdiv(collybus.redemptionPrice(), IVault(vault).fairPrice(tokenId, false, true));\n    }\n\n    /// @notice Returns the price at which credit can be redeemed for collateral\n    /// @notice vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @return redemptionPrice [wad]\n    function redemptionPrice(address vault, uint256 tokenId) public view override returns (uint256) {\n        if (debt == 0) return 0;\n        (, uint256 rate, , ) = codex.vaults(vault);\n        uint256 collateral = wmul(wmul(normalDebtByTokenId[vault][tokenId], rate), lockPrice(vault, tokenId));\n        return wdiv(sub(collateral, lostCollateral[vault][tokenId]), wmul(debt, WAD));\n    }\n\n    /// @notice Locks the system. See 1.\n    /// @dev Sender has to be allowed to call this method\n    function lock() external override checkCaller {\n        if (live == 0) revert Tenebrae__lock_notLive();\n        live = 0;\n        lockedAt = block.timestamp;\n        codex.lock();\n        limes.lock();\n        aer.lock();\n        collybus.lock();\n        emit Lock();\n    }\n\n    /// @notice Skips on-going collateral auction. See 2.\n    /// @dev Has to be performed before global debt is fixed\n    /// @param vault Address of the Vault\n    /// @param auctionId Id of the collateral auction the skip\n    function skipAuction(address vault, uint256 auctionId) external override {\n        if (debt != 0) revert Tenebrae__skipAuction_debtNotZero();\n        (address _collateralAuction, , , ) = limes.vaults(vault);\n        ICollateralAuction collateralAuction = ICollateralAuction(_collateralAuction);\n        (, uint256 rate, , ) = codex.vaults(vault);\n        (, uint256 debt_, uint256 collateralToSell, , uint256 tokenId, address user, , ) = collateralAuction.auctions(\n            auctionId\n        );\n        codex.createUnbackedDebt(address(aer), address(aer), debt_);\n        collateralAuction.cancelAuction(auctionId);\n        uint256 normalDebt = wdiv(debt_, rate);\n        if (!(int256(collateralToSell) >= 0 && int256(normalDebt) >= 0)) revert Tenebrae__skipAuction_overflow();\n        codex.confiscateCollateralAndDebt(\n            vault,\n            tokenId,\n            user,\n            address(this),\n            address(aer),\n            int256(collateralToSell),\n            int256(normalDebt)\n        );\n        emit SkipAuction(auctionId, vault, tokenId, user, debt_, collateralToSell, normalDebt);\n    }\n\n    /// @notice Offsets the debt of a Position with its collateral. See 3.\n    /// @dev Has to be performed before global debt is fixed\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param user Address of the Position's owner\n    function offsetPosition(\n        address vault,\n        uint256 tokenId,\n        address user\n    ) external override {\n        if (debt != 0) revert Tenebrae__offsetPosition_debtNotZero();\n        (, uint256 rate, , ) = codex.vaults(vault);\n        (uint256 collateral, uint256 normalDebt) = codex.positions(vault, tokenId, user);\n        // get price at maturity\n        uint256 owedCollateral = wdiv(wmul(normalDebt, rate), IVault(vault).fairPrice(tokenId, false, true));\n        uint256 offsetCollateral;\n        if (owedCollateral > collateral) {\n            // owing more collateral than the Position has\n            lostCollateral[vault][tokenId] = add(lostCollateral[vault][tokenId], sub(owedCollateral, collateral));\n            offsetCollateral = collateral;\n        } else {\n            offsetCollateral = owedCollateral;\n        }\n        normalDebtByTokenId[vault][tokenId] = add(normalDebtByTokenId[vault][tokenId], normalDebt);\n        if (!(offsetCollateral <= 2**255 && normalDebt <= 2**255)) revert Tenebrae__offsetPosition_overflow();\n        codex.confiscateCollateralAndDebt(\n            vault,\n            tokenId,\n            user,\n            address(this),\n            address(aer),\n            -int256(offsetCollateral),\n            -int256(normalDebt)\n        );\n        emit SettlePosition(vault, tokenId, user, offsetCollateral, normalDebt);\n    }\n\n    /// @notice Closes a user's position, such that the user can exit part of their collateral. See 4.\n    /// @dev Has to be performed before global debt is fixed\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    function closePosition(address vault, uint256 tokenId) external override {\n        if (live != 0) revert Tenebrae__closePosition_stillLive();\n        if (debt != 0) revert Tenebrae__closePosition_debtNotZero();\n        (uint256 collateral, uint256 normalDebt) = codex.positions(vault, tokenId, msg.sender);\n        if (normalDebt != 0) revert Tenebrae__closePosition_normalDebtNotZero();\n        normalDebtByTokenId[vault][tokenId] = add(normalDebtByTokenId[vault][tokenId], normalDebt);\n        if (collateral > 2**255) revert Tenebrae__closePosition_overflow();\n        codex.confiscateCollateralAndDebt(vault, tokenId, msg.sender, msg.sender, address(aer), -int256(collateral), 0);\n        emit ClosePosition(vault, tokenId, msg.sender, collateral, normalDebt);\n    }\n\n    /// @notice Fixes the global debt of the system. See 5.\n    /// @dev Can only be called once.\n    function fixGlobalDebt() external override {\n        if (live != 0) revert Tenebrae__fixGlobalDebt_stillLive();\n        if (debt != 0) revert Tenebrae__fixGlobalDebt_debtNotZero();\n        if (codex.credit(address(aer)) != 0) revert Tenebrae__fixGlobalDebt_surplusNotZero();\n        if (block.timestamp < add(lockedAt, cooldownDuration)) revert Tenebrae__fixGlobalDebt_cooldownNotFinished();\n        debt = codex.globalDebt();\n        emit FixGlobalDebt();\n    }\n\n    /// @notice Gives users the ability to redeem their remaining collateral with credit. See 6.\n    /// @dev Has to be performed after global debt is fixed otherwise redemptionPrice is 0\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param credit Amount of credit to redeem for collateral [wad]\n    function redeem(\n        address vault,\n        uint256 tokenId,\n        uint256 credit // credit amount\n    ) external override {\n        uint256 price = redemptionPrice(vault, tokenId);\n        if (price == 0) revert Tenebrae__redeem_redemptionPriceZero();\n        codex.transferCredit(msg.sender, address(aer), credit);\n        aer.settleDebtWithSurplus(credit);\n        codex.transferBalance(vault, tokenId, address(this), msg.sender, wmul(credit, price));\n        claimed[vault][tokenId][msg.sender] = add(claimed[vault][tokenId][msg.sender], credit);\n        emit Redeem(vault, tokenId, msg.sender, credit);\n    }\n}/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y\u00f71e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)\u00f7denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n/// @title PRBMathUD60x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\n/// maximum values permitted by the Solidity type uint256.\nlibrary PRBMathUD60x18 {\n    /// @dev Half the SCALE number.\n    uint256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\n    uint256 internal constant LOG2_E = 1_442695040888963407;\n\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\n\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_WHOLE_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // The operations can never overflow.\n        unchecked {\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function ceil(uint256 x) internal pure returns (uint256 result) {\n        if (x > MAX_WHOLE_UD60x18) {\n            revert PRBMathUD60x18__CeilOverflow(x);\n        }\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"SCALE - remainder\" but faster.\n            let delta := sub(SCALE, remainder)\n\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\n            result := add(x, mul(delta, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\n    ///\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    ///\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDiv(x, SCALE, y);\n    }\n\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (uint256 result) {\n        result = 2_718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp(uint256 x) internal pure returns (uint256 result) {\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133_084258667509499441) {\n            revert PRBMathUD60x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            uint256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (x >= 192e18) {\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x192x64 = (x << 64) / SCALE;\n\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\n            result = PRBMath.exp2(x192x64);\n        }\n    }\n\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function floor(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\n            result := sub(x, mul(remainder, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x.\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\n    function frac(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            result := mod(x, SCALE)\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__FromUintOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\n    ///\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            uint256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathUD60x18__GmOverflow(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = PRBMath.sqrt(xy);\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding toward zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\n    function inv(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\n    function ln(uint256 x) internal pure returns (uint256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 196205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log10(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\n        // in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\n            default {\n                result := MAX_UD60x18\n            }\n        }\n\n        if (result == MAX_UD60x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3_321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\n    ///\n    /// Caveats:\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log2(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\n\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255 and SCALE is 1e18.\n            result = n * SCALE;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n        }\n    }\n\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\n    /// fixed-point number.\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDivFixedPoint(x, y);\n    }\n\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\n    function pi() internal pure returns (uint256 result) {\n        result = 3_141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : uint256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// Caveats:\n    /// - All from \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // Calculate the first iteration of the loop in advance.\n        result = y & 1 > 0 ? x : SCALE;\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        for (y >>= 1; y > 0; y >>= 1) {\n            x = PRBMath.mulDivFixedPoint(x, x);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (y & 1 > 0) {\n                result = PRBMath.mulDivFixedPoint(result, x);\n            }\n        }\n    }\n\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\n    function scale() internal pure returns (uint256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x must be less than MAX_UD60x18 / SCALE.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = PRBMath.sqrt(x * SCALE);\n        }\n    }\n\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n\n\n/// @title Collybus\n/// @notice `Collybus` stores a spot price and discount rate for every Vault / asset.\ncontract Collybus is Guarded, ICollybus {\n    /// ======== Custom Errors ======== ///\n\n    error Collybus__setParam_notLive();\n    error Collybus__setParam_unrecognizedParam();\n    error Collybus__updateSpot_notLive();\n    error Collybus__updateDiscountRate_notLive();\n    error Collybus__updateDiscountRate_invalidRateId();\n    error Collybus__updateDiscountRate_invalidRate();\n\n    using PRBMathUD60x18 for uint256;\n\n    /// ======== Storage ======== ///\n\n    struct VaultConfig {\n        // Liquidation ratio [wad]\n        uint128 liquidationRatio;\n        // Default fixed interest rate oracle system rateId\n        uint128 defaultRateId;\n    }\n\n    /// @notice Vault Configuration\n    /// @dev Vault => Vault Config\n    mapping(address => VaultConfig) public override vaults;\n    /// @notice Spot prices by token address\n    /// @dev Token address => spot price [wad]\n    mapping(address => uint256) public override spots;\n    /// @notice Fixed interest rate oracle system rateId\n    /// @dev RateId => Discount Rate [wad]\n    mapping(uint256 => uint256) public override rates;\n    // Fixed interest rate oracle system rateId for each TokenId\n    // Vault => TokenId => RateId\n    mapping(address => mapping(uint256 => uint256)) public override rateIds;\n\n    /// @notice Redemption Price of a Credit unit [wad]\n    uint256 public immutable override redemptionPrice;\n\n    /// @notice Boolean indicating if this contract is live (0 - not live, 1 - live)\n    uint256 public override live;\n\n    /// ======== Events ======== ///\n    event SetParam(bytes32 indexed param, uint256 data);\n    event SetParam(address indexed vault, bytes32 indexed param, uint256 data);\n    event SetParam(address indexed vault, uint256 indexed tokenId, bytes32 indexed param, uint256 data);\n    event UpdateSpot(address indexed token, uint256 spot);\n    event UpdateDiscountRate(uint256 indexed rateId, uint256 rate);\n    event Lock();\n\n    // TODO: why not making timeScale and redemption price function arguments?\n    constructor() Guarded() {\n        redemptionPrice = WAD; // 1.0\n        live = 1;\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (live == 0) revert Collybus__setParam_notLive();\n        if (param == \"live\") live = data;\n        else revert Collybus__setParam_unrecognizedParam();\n        emit SetParam(address(0), param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint128 data\n    ) external override checkCaller {\n        if (live == 0) revert Collybus__setParam_notLive();\n        if (param == \"liquidationRatio\") vaults[vault].liquidationRatio = data;\n        else if (param == \"defaultRateId\") vaults[vault].defaultRateId = data;\n        else revert Collybus__setParam_unrecognizedParam();\n        emit SetParam(vault, param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        uint256 tokenId,\n        bytes32 param,\n        uint256 data\n    ) external override checkCaller {\n        if (live == 0) revert Collybus__setParam_notLive();\n        if (param == \"rateId\") rateIds[vault][tokenId] = data;\n        else revert Collybus__setParam_unrecognizedParam();\n        emit SetParam(vault, tokenId, param, data);\n    }\n\n    /// ======== Spot Prices ======== ///\n\n    /// @notice Sets a token's spot price\n    /// @dev Sender has to be allowed to call this method\n    /// @param token Address of the token\n    /// @param spot Spot price [wad]\n    function updateSpot(address token, uint256 spot) external override checkCaller {\n        if (live == 0) revert Collybus__updateSpot_notLive();\n        spots[token] = spot;\n        emit UpdateSpot(token, spot);\n    }\n\n    /// ======== Discount Rate ======== ///\n\n    /// @notice Sets the discount rate by RateId\n    /// @param rateId RateId of the discount rate feed\n    /// @param rate Discount rate [wad]\n    function updateDiscountRate(uint256 rateId, uint256 rate) external override checkCaller {\n        if (live == 0) revert Collybus__updateDiscountRate_notLive();\n        if (rateId >= type(uint128).max) revert Collybus__updateDiscountRate_invalidRateId();\n        if (rate >= 2e10) revert Collybus__updateDiscountRate_invalidRate();\n        rates[rateId] = rate;\n        emit UpdateDiscountRate(rateId, rate);\n    }\n\n    /// @notice Returns the internal price for an asset\n    /// @dev\n    ///                 redemptionPrice\n    /// v = ----------------------------------------\n    ///                       (maturity - timestamp)\n    ///     (1 + discountRate)\n    ///\n    /// @param vault Address of the asset corresponding Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param maturity Maturity of the asset [unix timestamp in seconds]\n    /// @param net Boolean (true - with liquidation safety margin, false - without)\n    /// @return price Internal price [wad]\n    function read(\n        address vault,\n        address underlier,\n        uint256 tokenId,\n        uint256 maturity,\n        bool net\n    ) external view override returns (uint256 price) {\n        VaultConfig memory vaultConfig = vaults[vault];\n        // fetch applicable fixed interest rate oracle system rateId\n        uint256 rateId = rateIds[vault][tokenId];\n        if (rateId == uint256(0)) rateId = vaultConfig.defaultRateId; // if not set, use default rateId\n        // fetch discount rate\n        uint256 discountRate = rates[rateId];\n        // apply discount rate if discountRate > 0\n        if (discountRate != 0 && maturity > block.timestamp) {\n            uint256 rate = add(WAD, discountRate).powu(sub(maturity, block.timestamp));\n            price = wdiv(redemptionPrice, rate); // den. in Underlier\n        } else {\n            price = redemptionPrice; // den. in Underlier\n        }\n        price = wmul(price, spots[underlier]); // den. in USD\n        if (net) price = wdiv(price, vaultConfig.liquidationRatio); // with liquidation safety margin\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Locks the contract\n    /// @dev Sender has to be allowed to call this method\n    function lock() external override checkCaller {\n        live = 0;\n        emit Lock();\n    }\n}\ninterface IGuard {\n    function isGuard() external view returns (bool);\n}\ncontract CodexFactory {\n    function newCodex(address owner) public returns (Codex codex) {\n        codex = new Codex();\n        codex.allowCaller(codex.ANY_SIG(), owner);\n        codex.blockCaller(codex.ANY_SIG(), address(this));\n    }\n}\n\ncontract PublicanFactory {\n    function newPublican(address owner, address codex) public returns (Publican publican) {\n        publican = new Publican(codex);\n        publican.allowCaller(publican.ANY_SIG(), owner);\n        publican.blockCaller(publican.ANY_SIG(), address(this));\n    }\n}\n\ncontract AerFactory {\n    function newAer(\n        address owner,\n        address codex,\n        address surplusAuction,\n        address debtAuction\n    ) public returns (Aer aer) {\n        aer = new Aer(codex, surplusAuction, debtAuction);\n        aer.allowCaller(aer.ANY_SIG(), owner);\n        aer.blockCaller(aer.ANY_SIG(), address(this));\n    }\n}\n\ncontract LimesFactory {\n    function newLimes(address owner, address codex) public returns (Limes limes) {\n        limes = new Limes(codex);\n        limes.allowCaller(limes.ANY_SIG(), owner);\n        limes.blockCaller(limes.ANY_SIG(), address(this));\n    }\n}\n\ncontract FIATFactory {\n    function newFIAT(address owner) public returns (FIAT fiat) {\n        fiat = new FIAT();\n        fiat.allowCaller(fiat.ANY_SIG(), owner);\n        fiat.blockCaller(fiat.ANY_SIG(), address(this));\n    }\n}\n\ncontract MonetaFactory {\n    function newMoneta(address codex, address fiat) public returns (Moneta moneta) {\n        moneta = new Moneta(codex, fiat);\n    }\n}\n\ncontract SurplusAuctionFactory {\n    function newSurplusAuction(\n        address owner,\n        address codex,\n        address gov\n    ) public returns (SurplusAuction surplusAuction) {\n        surplusAuction = new SurplusAuction(codex, gov);\n        surplusAuction.allowCaller(surplusAuction.ANY_SIG(), owner);\n        surplusAuction.blockCaller(surplusAuction.ANY_SIG(), address(this));\n    }\n}\n\ncontract DebtAuctionFactory {\n    function newDebtAuction(\n        address owner,\n        address codex,\n        address gov\n    ) public returns (DebtAuction debtAuction) {\n        debtAuction = new DebtAuction(codex, gov);\n        debtAuction.allowCaller(debtAuction.ANY_SIG(), owner);\n        debtAuction.blockCaller(debtAuction.ANY_SIG(), address(this));\n    }\n}\n\ncontract NoLossCollateralAuctionFactory {\n    function newNoLossCollateralAuction(\n        address owner,\n        address codex,\n        address limes\n    ) public returns (NoLossCollateralAuction collateralAuction) {\n        collateralAuction = new NoLossCollateralAuction(codex, limes);\n        collateralAuction.allowCaller(collateralAuction.ANY_SIG(), owner);\n        collateralAuction.blockCaller(collateralAuction.ANY_SIG(), address(this));\n    }\n}\n\ncontract CollybusFactory {\n    function newCollybus(address owner) public returns (Collybus collybus) {\n        collybus = new Collybus();\n        collybus.allowCaller(collybus.ANY_SIG(), owner);\n        collybus.blockCaller(collybus.ANY_SIG(), address(this));\n    }\n}\n\ncontract TenebraeFactory {\n    function newTenebrae(address owner) public returns (Tenebrae tenebrae) {\n        tenebrae = new Tenebrae();\n        tenebrae.allowCaller(tenebrae.ANY_SIG(), owner);\n        tenebrae.blockCaller(tenebrae.ANY_SIG(), address(this));\n    }\n}\n\n/// @title Deployer\n/// @notice Stateful contract managing the deployment of the protocol\ncontract Deployer is Guarded {\n    /// ======== Custom Errors ======== ///\n\n    error Deployer__checkStep_missingPreviousStep();\n    error Deployer__deployAuctions_zeroGovToken();\n    error Deployer__setGuard_notGuard();\n\n    /// ======== Storage ======== ///\n\n    CodexFactory public codexFactory;\n    PublicanFactory public publicanFactory;\n    AerFactory public aerFactory;\n    LimesFactory public limesFactory;\n    FIATFactory public fiatFactory;\n    MonetaFactory public monetaFactory;\n    SurplusAuctionFactory public surplusAuctionFactory;\n    DebtAuctionFactory public debtAuctionFactory;\n    NoLossCollateralAuctionFactory public collateralAuctionFactory;\n    CollybusFactory public collybusFactory;\n    TenebraeFactory public tenebraeFactory;\n\n    Codex public codex;\n    Publican public publican;\n    Aer public aer;\n    Limes public limes;\n    FIAT public fiat;\n    Moneta public moneta;\n    NoLossCollateralAuction public collateralAuction;\n    SurplusAuction public surplusAuction;\n    DebtAuction public debtAuction;\n    Collybus public collybus;\n    Tenebrae public tenebrae;\n\n    uint256 public step;\n\n    modifier checkStep(uint256 prevStep) {\n        uint256 _step = step;\n        if (_step != prevStep) revert Deployer__checkStep_missingPreviousStep();\n        _;\n        step++;\n    }\n\n    /// ======== Deploy ======== ///\n\n    function setFactory(\n        CodexFactory codexFactory_,\n        PublicanFactory publicanFactory_,\n        AerFactory aerFactory_,\n        LimesFactory limesFactory_,\n        FIATFactory fiatFactory_,\n        MonetaFactory monetaFactory_,\n        SurplusAuctionFactory surplusAuctionFactory_,\n        DebtAuctionFactory debtAuctionFactory_,\n        NoLossCollateralAuctionFactory collateralAuctionFactory_,\n        CollybusFactory collybusFactory_,\n        TenebraeFactory tenebraeFactory_\n    ) public checkCaller checkStep(0) {\n        codexFactory = codexFactory_;\n        publicanFactory = publicanFactory_;\n        aerFactory = aerFactory_;\n        limesFactory = limesFactory_;\n        fiatFactory = fiatFactory_;\n        monetaFactory = monetaFactory_;\n        surplusAuctionFactory = surplusAuctionFactory_;\n        debtAuctionFactory = debtAuctionFactory_;\n        collateralAuctionFactory = collateralAuctionFactory_;\n        collybusFactory = collybusFactory_;\n        tenebraeFactory = tenebraeFactory_;\n    }\n\n    function deployCodex() public checkCaller checkStep(1) {\n        codex = codexFactory.newCodex(address(this));\n        collybus = collybusFactory.newCollybus(address(this));\n    }\n\n    function deployFIAT() public checkCaller checkStep(2) {\n        fiat = fiatFactory.newFIAT(address(this));\n        moneta = monetaFactory.newMoneta(address(codex), address(fiat));\n\n        // contract permissions\n        fiat.allowCaller(fiat.mint.selector, address(moneta));\n    }\n\n    function deployPublican() public checkCaller checkStep(3) {\n        publican = publicanFactory.newPublican(address(this), address(codex));\n\n        // contract permissions\n        codex.allowCaller(codex.modifyRate.selector, address(publican));\n    }\n\n    function deployAuctions(address govToken) public checkCaller checkStep(4) {\n        if (govToken == address(0)) revert Deployer__deployAuctions_zeroGovToken();\n\n        surplusAuction = surplusAuctionFactory.newSurplusAuction(address(this), address(codex), govToken);\n        debtAuction = debtAuctionFactory.newDebtAuction(address(this), address(codex), govToken);\n        aer = aerFactory.newAer(address(this), address(codex), address(surplusAuction), address(debtAuction));\n        // aer.surplusBuffer = 1M FIAT\n\n        // contract references\n        publican.setParam(\"aer\", address(aer));\n\n        // contract permissions\n        codex.allowCaller(codex.createUnbackedDebt.selector, address(debtAuction));\n        surplusAuction.allowCaller(surplusAuction.startAuction.selector, address(aer));\n        surplusAuction.allowCaller(surplusAuction.lock.selector, address(aer));\n        debtAuction.allowCaller(debtAuction.startAuction.selector, address(aer));\n        debtAuction.allowCaller(debtAuction.lock.selector, address(aer));\n    }\n\n    function deployLimes() public checkCaller checkStep(5) {\n        limes = limesFactory.newLimes(address(this), address(codex));\n\n        // contract references\n        limes.setParam(\"aer\", address(aer));\n\n        // contract permissions\n        codex.allowCaller(codex.confiscateCollateralAndDebt.selector, address(limes));\n        aer.allowCaller(aer.queueDebt.selector, address(limes));\n    }\n\n    function deployTenebrae() public checkCaller checkStep(6) {\n        tenebrae = tenebraeFactory.newTenebrae(address(this));\n\n        // contract references\n        tenebrae.setParam(\"codex\", address(codex));\n        tenebrae.setParam(\"limes\", address(limes));\n        tenebrae.setParam(\"aer\", address(aer));\n        tenebrae.setParam(\"collybus\", address(collybus));\n\n        // contract permissions\n        codex.allowCaller(codex.lock.selector, address(tenebrae));\n        limes.allowCaller(limes.ANY_SIG(), address(tenebrae));\n        aer.allowCaller(aer.ANY_SIG(), address(tenebrae));\n        collybus.allowCaller(collybus.ANY_SIG(), address(tenebrae));\n    }\n\n    function deployCollateralAuction() public checkCaller checkStep(7) {\n        collateralAuction = collateralAuctionFactory.newNoLossCollateralAuction(\n            address(this),\n            address(codex),\n            address(limes)\n        );\n\n        // contract references\n        collateralAuction.setParam(\"aer\", address(aer));\n        collateralAuction.setParam(\"limes\", address(limes));\n\n        // contract permissions\n        codex.allowCaller(codex.transferCredit.selector, address(moneta));\n        codex.allowCaller(codex.createUnbackedDebt.selector, address(collateralAuction));\n        collateralAuction.allowCaller(collateralAuction.startAuction.selector, address(limes));\n        collateralAuction.allowCaller(collateralAuction.cancelAuction.selector, address(tenebrae));\n        limes.allowCaller(limes.liquidated.selector, address(collateralAuction));\n    }\n\n    /// ======== Setup Parameters ======== ///\n\n    function setDao(address dao) public checkCaller checkStep(8) {\n        _setCaller(dao);\n    }\n\n    function setAerGuard(address guard) public checkCaller checkStep(9) {\n        _setGuard(guard);\n    }\n\n    function setAuctionGuard(address guard) public checkCaller checkStep(10) {\n        _setGuard(guard);\n    }\n\n    function setCodexGuard(address guard, uint256 globalDebtCeiling) public checkCaller checkStep(11) {\n        _setGuard(guard);\n        codex.setParam(\"globalDebtCeiling\", globalDebtCeiling);\n    }\n\n    function setCollybusGuard(\n        address guard, \n        address[] memory discountRateRelayerList, \n        address[] memory spotRelayerList\n    ) public checkCaller checkStep(12) {\n        _setGuard(guard);\n        for (uint256 i = 0; i < discountRateRelayerList.length; ++i) {\n            collybus.allowCaller(Collybus.updateDiscountRate.selector, discountRateRelayerList[i]);\n        }\n        for (uint256 i = 0; i < spotRelayerList.length; ++i) {\n            collybus.allowCaller(Collybus.updateSpot.selector, spotRelayerList[i]);\n        }\n    }\n\n    function setLimesGuard(address guard, uint256 globalMaxDebtOnAuction) public checkCaller checkStep(13) {\n        _setGuard(guard);\n        limes.setParam(\"globalMaxDebtOnAuction\", globalMaxDebtOnAuction);\n    }\n\n    function setPublicanGuard(address guard) public checkCaller checkStep(14) {\n        _setGuard(guard);\n    }\n\n    function setVaultGuard(address guard) public checkCaller checkStep(15) {\n        _setGuard(guard);\n    }\n\n    function renounce() public checkCaller checkStep(16) {\n        codex.blockCaller(codex.ANY_SIG(), address(this));\n        limes.blockCaller(limes.ANY_SIG(), address(this));\n        aer.blockCaller(aer.ANY_SIG(), address(this));\n        publican.blockCaller(publican.ANY_SIG(), address(this));\n        fiat.blockCaller(fiat.ANY_SIG(), address(this));\n        collybus.blockCaller(collybus.ANY_SIG(), address(this));\n        collateralAuction.blockCaller(collateralAuction.ANY_SIG(), address(this));\n        surplusAuction.blockCaller(surplusAuction.ANY_SIG(), address(this));\n        debtAuction.blockCaller(debtAuction.ANY_SIG(), address(this));\n        tenebrae.blockCaller(tenebrae.ANY_SIG(), address(this));\n    }\n\n    function _setGuard(address guard) internal {\n        _setCaller(guard);\n        if (!IGuard(guard).isGuard()) revert Deployer__setGuard_notGuard();\n    }\n\n    function _setCaller(address caller) internal {\n        aer.allowCaller(aer.ANY_SIG(), caller);\n        codex.allowCaller(codex.ANY_SIG(), caller);\n        collateralAuction.allowCaller(collateralAuction.ANY_SIG(), caller);\n        collybus.allowCaller(collybus.ANY_SIG(), caller);\n        debtAuction.allowCaller(debtAuction.ANY_SIG(), caller);\n        fiat.allowCaller(fiat.ANY_SIG(), caller);\n        limes.allowCaller(limes.ANY_SIG(), caller);\n        publican.allowCaller(publican.ANY_SIG(), caller);\n        surplusAuction.allowCaller(surplusAuction.ANY_SIG(), caller);\n        tenebrae.allowCaller(tenebrae.ANY_SIG(), caller);\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"newCodex\",\"outputs\":[{\"internalType\":\"contract Codex\",\"name\":\"codex\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CodexFactory", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "8000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}