{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.8.11;\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/// @notice An error used to indicate that an argument passed to a function is illegal or\r\n///         inappropriate.\r\n///\r\n/// @param message The error message.\r\nerror IllegalArgument(string message);\r\n\r\n/// @notice An error used to indicate that a function has encountered an unrecoverable state.\r\n///\r\n/// @param message The error message.\r\nerror IllegalState(string message);\r\n\r\n/// @notice An error used to indicate that an operation is unsupported.\r\n///\r\n/// @param message The error message.\r\nerror UnsupportedOperation(string message);\r\n\r\n/// @notice An error used to indicate that a message sender tried to execute a privileged function.\r\n///\r\n/// @param message The error message.\r\nerror Unauthorized(string message);\r\n/// @title  Mutex\r\n/// @author Alchemix Finance\r\n///\r\n/// @notice Provides a mutual exclusion lock for implementing contracts.\r\nabstract contract Mutex {\r\n    enum State {\r\n        RESERVED,\r\n        UNLOCKED,\r\n        LOCKED\r\n    }\r\n\r\n    /// @notice The lock state.\r\n    State private _lockState = State.UNLOCKED;\r\n\r\n    /// @dev A modifier which acquires the mutex.\r\n    modifier lock() {\r\n        _claimLock();\r\n\r\n        _;\r\n\r\n        _freeLock();\r\n    }\r\n\r\n    /// @dev Gets if the mutex is locked.\r\n    ///\r\n    /// @return if the mutex is locked.\r\n    function _isLocked() internal view returns (bool) {\r\n        return _lockState == State.LOCKED;\r\n    }\r\n\r\n    /// @dev Claims the lock. If the lock is already claimed, then this will revert.\r\n    function _claimLock() internal {\r\n        // Check that the lock has not been claimed yet.\r\n        if (_lockState != State.UNLOCKED) {\r\n            revert IllegalState(\"Lock already claimed\");\r\n        }\r\n\r\n        // Claim the lock.\r\n        _lockState = State.LOCKED;\r\n    }\r\n\r\n    /// @dev Frees the lock.\r\n    function _freeLock() internal {\r\n        _lockState = State.UNLOCKED;\r\n    }\r\n}\r\n/// @title  SafeERC20\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// @author Alchemix Finance\r\nlibrary SafeERC20 {\r\n    /// @dev Expects the token to return the number of decimals that it uses.\r\n    ///\r\n    /// @param token The address of the token.\r\n    ///\r\n    /// @return The number of decimals that the token has.\r\n    function expectDecimals(address token) internal view returns (uint256) {\r\n        bool status;\r\n        assembly {\r\n            let pointer := mload(0x40)\r\n\r\n            mstore(pointer, 0x313ce56700000000000000000000000000000000000000000000000000000000)\r\n\r\n            status := staticcall(gas(), token, pointer, 4, 0, 0)\r\n        }\r\n\r\n        (uint256 decimals, bool success) = expectUInt256Response(status);\r\n        if (!success) {\r\n            revert IllegalState(\"Decimals call malformed response\");\r\n        }\r\n\r\n        return decimals;\r\n    }\r\n\r\n    /// @dev Safely sets an allowance.\r\n    ///\r\n    /// @param token   The address of the token.\r\n    /// @param spender The address to allow to transfer tokens.\r\n    /// @param value   The amount of tokens to allow to be transferred.\r\n    function safeApprove(address token, address spender, uint256 value) internal {\r\n        bool status;\r\n        assembly {\r\n            let pointer := mload(0x40)\r\n\r\n            mstore(pointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(pointer,  4), and(spender, 0xffffffffffffffffffffffffffffffffffffffff))\r\n            mstore(add(pointer, 36), value)\r\n\r\n            status := call(gas(), token, 0, pointer, 68, 0, 0)\r\n        }\r\n\r\n        if (!checkBooleanResponse(status)) {\r\n            revert IllegalState(\"Expected approval to succeed\");\r\n        }\r\n    }\r\n\r\n    /// @dev Safely transfers tokens from an address to another.\r\n    ///\r\n    /// @param token    The address of the token.\r\n    /// @param receiver The address to transfer tokens to.\r\n    /// @param amount   The amount of tokens to transfer.\r\n    function safeTransfer(address token, address receiver, uint256 amount) internal {\r\n        bool status;\r\n        assembly {\r\n            let pointer := mload(0x40)\r\n\r\n            mstore(pointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(pointer,  4), and(receiver, 0xffffffffffffffffffffffffffffffffffffffff))\r\n            mstore(add(pointer, 36), amount)\r\n\r\n            status := call(gas(), token, 0, pointer, 68, 0, 0)\r\n        }\r\n\r\n        if (!checkBooleanResponse(status)) {\r\n            revert IllegalState(\"Expected transfer to succeed\");\r\n        }\r\n    }\r\n\r\n    /// @dev Safely transfers tokens from an address to another using an allowance.\r\n    ///\r\n    /// @param token    The address of the token.\r\n    /// @param owner    The address to transfer tokens from.\r\n    /// @param receiver The address to transfer tokens to.\r\n    /// @param amount   The amount of tokens to transfer.\r\n    function safeTransferFrom(\r\n        address token,\r\n        address owner,\r\n        address receiver,\r\n        uint256 amount\r\n    ) internal {\r\n        bool status;\r\n        assembly {\r\n            let pointer := mload(0x40)\r\n\r\n            mstore(pointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(pointer,  4), and(owner,    0xffffffffffffffffffffffffffffffffffffffff))\r\n            mstore(add(pointer, 36), and(receiver, 0xffffffffffffffffffffffffffffffffffffffff))\r\n            mstore(add(pointer, 68), amount)\r\n\r\n            status := call(gas(), token, 0, pointer, 100, 0, 0)\r\n        }\r\n\r\n        if (!checkBooleanResponse(status)) {\r\n            revert IllegalState(\"Expected transfer from to succeed\");\r\n        }\r\n    }\r\n\r\n    /// @dev Checks the call response and gets if the call was successful.\r\n    ///\r\n    /// When a call is unsuccessful the return data is expected to be error data. The data is\r\n    /// rethrown to bubble up the error to the caller.\r\n    ///\r\n    /// When a call is successful it is expected that the return data is empty or exactly 32\r\n    /// bytes in length. Any other return size is treated as an error. When the return data is\r\n    /// non-empty, it is expected that the return data is non-zero to indicate that the call was\r\n    /// successful.\r\n    ///\r\n    /// @param status A flag indicating if the call has reverted or not.\r\n    ///\r\n    /// @return success If the call was successful.\r\n    function checkBooleanResponse(bool status) private pure returns (bool success) {\r\n        assembly {\r\n            if iszero(status) {\r\n                returndatacopy(0, 0, returndatasize())\r\n\r\n                revert(0, returndatasize())\r\n            }\r\n\r\n            switch returndatasize()\r\n            case 32 {\r\n                returndatacopy(0, 0, returndatasize())\r\n\r\n                success := iszero(iszero(mload(0)))\r\n            }\r\n            case 0 {\r\n                success := 1\r\n            }\r\n            default {\r\n                success := 0\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Checks that the call responded with a 256 bit integer.\r\n    ///\r\n    /// When a call is unsuccessful the return data is expected to be error data. The data is\r\n    /// rethrown to bubble up the error to the caller.\r\n    ///\r\n    /// When a call is successful it is expected that the return data is exactly 32 bytes in\r\n    /// length. Any other return size is treated as an error. When the return data is non-empty,\r\n    /// it is expected that the return data is a unsigned 256 bit integer.\r\n    ///\r\n    /// @param status A flag indicating if the call has reverted or not.\r\n    ///\r\n    /// @return value   The returned 256 bit integer value.\r\n    /// @return success If the call was successful.\r\n    function expectUInt256Response(bool status) private pure returns (uint256 value, bool success) {\r\n        assembly {\r\n            if iszero(status) {\r\n                returndatacopy(0, 0, returndatasize())\r\n\r\n                revert(0, returndatasize())\r\n            }\r\n\r\n            switch returndatasize()\r\n            case 32 {\r\n                returndatacopy(0, 0, returndatasize())\r\n\r\n                value   := mload(0)\r\n                success := 1\r\n            }\r\n            default {\r\n                success := 0\r\n            }\r\n        }\r\n    }\r\n}/// @title  IERC20Metadata\r\n/// @author Alchemix Finance\r\ninterface IERC20Metadata {\r\n    /// @notice Gets the name of the token.\r\n    ///\r\n    /// @return The name.\r\n    function name() external view returns (string memory);\r\n\r\n    /// @notice Gets the symbol of the token.\r\n    ///\r\n    /// @return The symbol.\r\n    function symbol() external view returns (string memory);\r\n\r\n    /// @notice Gets the number of decimals that the token has.\r\n    ///\r\n    /// @return The number of decimals.\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface IRETH is IERC20, IERC20Metadata {\r\n    function getEthValue(uint256 amount) external view returns (uint256);\r\n    function getRethValue(uint256 amount) external view returns (uint256);\r\n    function getExchangeRate() external view returns (uint256);\r\n    function getTotalCollateral() external view returns (uint256);\r\n    function getCollateralRate() external view returns (uint256);\r\n    function depositExcess() external payable;\r\n    function depositExcessCollateral() external;\r\n    function mint(uint256 amount, address receiver) external;\r\n    function burn(uint256 amount) external;\r\n}\r\ninterface IRocketStorage {\r\n    function getDeployedStatus() external view returns (bool);\r\n    function getGuardian() external view returns(address);\r\n    function setGuardian(address value) external;\r\n    function confirmGuardian() external;\r\n\r\n    function getAddress(bytes32 key) external view returns (address);\r\n    function getUint(bytes32 key) external view returns (uint);\r\n    function getString(bytes32 key) external view returns (string memory);\r\n    function getBytes(bytes32 key) external view returns (bytes memory);\r\n    function getBool(bytes32 key) external view returns (bool);\r\n    function getInt(bytes32 key) external view returns (int);\r\n    function getBytes32(bytes32 key) external view returns (bytes32);\r\n\r\n    function setAddress(bytes32 key, address value) external;\r\n    function setUint(bytes32 key, uint value) external;\r\n    function setString(bytes32 key, string calldata value) external;\r\n    function setBytes(bytes32 key, bytes calldata value) external;\r\n    function setBool(bytes32 key, bool value) external;\r\n    function setInt(bytes32 key, int value) external;\r\n    function setBytes32(bytes32 key, bytes32 value) external;\r\n\r\n    function deleteAddress(bytes32 key) external;\r\n    function deleteUint(bytes32 key) external;\r\n    function deleteString(bytes32 key) external;\r\n    function deleteBytes(bytes32 key) external;\r\n    function deleteBool(bytes32 key) external;\r\n    function deleteInt(bytes32 key) external;\r\n    function deleteBytes32(bytes32 key) external;\r\n\r\n    function addUint(bytes32 key, uint256 amount) external;\r\n    function subUint(bytes32 key, uint256 amount) external;\r\n\r\n    function getNodeWithdrawalAddress(address nodeAddress) external view returns (address);\r\n    function getNodePendingWithdrawalAddress(address nodeAddress) external view returns (address);\r\n    function setWithdrawalAddress(address nodeAddress, address newWithdrawalAddress, bool confirm) external;\r\n    function confirmWithdrawalAddress(address nodeAddress) external;\r\n}\r\n\r\nlibrary RocketPool {\r\n    /// @dev Gets the current rETH contract.\r\n    ///\r\n    /// @param self The rocket storage contract to read from.\r\n    ///\r\n    /// @return The current rETH contract.\r\n    function getRETH(IRocketStorage self) internal view returns (IRETH) {\r\n        return IRETH(self.getAddress(\r\n            keccak256(abi.encodePacked(\"contract.address\", \"rocketTokenRETH\"))\r\n        ));\r\n    }\r\n}\r\n/// @title  ITokenAdapter\r\n/// @author Alchemix Finance\r\ninterface ITokenAdapter {\r\n    /// @notice Gets the current version.\r\n    ///\r\n    /// @return The version.\r\n    function version() external view returns (string memory);\r\n\r\n    /// @notice Gets the address of the yield token that this adapter supports.\r\n    ///\r\n    /// @return The address of the yield token.\r\n    function token() external view returns (address);\r\n\r\n    /// @notice Gets the address of the underlying token that the yield token wraps.\r\n    ///\r\n    /// @return The address of the underlying token.\r\n    function underlyingToken() external view returns (address);\r\n\r\n    /// @notice Gets the number of underlying tokens that a single whole yield token is redeemable\r\n    ///         for.\r\n    ///\r\n    /// @return The price.\r\n    function price() external view returns (uint256);\r\n\r\n    /// @notice Wraps `amount` underlying tokens into the yield token.\r\n    ///\r\n    /// @param amount    The amount of the underlying token to wrap.\r\n    /// @param recipient The address which will receive the yield tokens.\r\n    ///\r\n    /// @return amountYieldTokens The amount of yield tokens minted to `recipient`.\r\n    function wrap(uint256 amount, address recipient)\r\n        external\r\n        returns (uint256 amountYieldTokens);\r\n\r\n    /// @notice Unwraps `amount` yield tokens into the underlying token.\r\n    ///\r\n    /// @param amount    The amount of yield-tokens to redeem.\r\n    /// @param recipient The recipient of the resulting underlying-tokens.\r\n    ///\r\n    /// @return amountUnderlyingTokens The amount of underlying tokens unwrapped to `recipient`.\r\n    function unwrap(uint256 amount, address recipient)\r\n        external\r\n        returns (uint256 amountUnderlyingTokens);\r\n}/// @title IWETH9\r\ninterface IWETH9 is IERC20, IERC20Metadata {\r\n  /// @notice Deposits `msg.value` ethereum into the contract and mints `msg.value` tokens.\r\n  function deposit() external payable;\r\n\r\n  /// @notice Burns `amount` tokens to retrieve `amount` ethereum from the contract.\r\n  ///\r\n  /// @dev This version of WETH utilizes the `transfer` function which hard codes the amount of gas\r\n  ///      that is allowed to be utilized to be exactly 2300 when receiving ethereum.\r\n  ///\r\n  /// @param amount The amount of tokens to burn.\r\n  function withdraw(uint256 amount) external;\r\n}\r\nstruct InitializationParams {\r\n    address alchemist;\r\n    address token;\r\n    address underlyingToken;\r\n}\r\n\r\ncontract RETHAdapterV1 is ITokenAdapter, Mutex {\r\n    using RocketPool for IRocketStorage;\r\n\r\n    string public override version = \"1.0.0\";\r\n\r\n    address public immutable alchemist;\r\n    address public immutable override token;\r\n    address public immutable override underlyingToken;\r\n\r\n    constructor(InitializationParams memory params) {\r\n        alchemist       = params.alchemist;\r\n        token           = params.token;\r\n        underlyingToken = params.underlyingToken;\r\n    }\r\n\r\n    /// @dev Checks that the message sender is the alchemist that the adapter is bound to.\r\n    modifier onlyAlchemist() {\r\n        if (msg.sender != alchemist) {\r\n            revert Unauthorized(\"Not alchemist\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    receive() external payable {\r\n        if (msg.sender != underlyingToken && msg.sender != token) {\r\n            revert Unauthorized(\"Payments only permitted from WETH or rETH\");\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc ITokenAdapter\r\n    function price() external view returns (uint256) {\r\n        return IRETH(token).getEthValue(10**SafeERC20.expectDecimals(token));\r\n    }\r\n\r\n    /// @inheritdoc ITokenAdapter\r\n    function wrap(\r\n        uint256 amount,\r\n        address recipient\r\n    ) external onlyAlchemist returns (uint256) {\r\n        amount; recipient; // Silence, compiler!\r\n\r\n        // NOTE: Wrapping is currently unsupported because the Rocket Pool requires that all\r\n        //       addresses that mint rETH to wait approximately 24 hours before transferring\r\n        //       tokens. In the future when the minting restriction is removed, an adapter\r\n        //       that supports this operation will be written.\r\n        //\r\n        //       We had considered exchanging ETH for rETH here, however, the liquidity on the\r\n        //       majority of the pools is too limited. Also, the landscape of those pools are very\r\n        //       likely to change in the coming months. We recommend that users exchange for\r\n        //       rETH on a pool of their liking or mint rETH and then deposit it at a later time.\r\n        revert UnsupportedOperation(\"Wrapping is not supported\");\r\n    }\r\n\r\n    // @inheritdoc ITokenAdapter\r\n    function unwrap(\r\n        uint256 amount,\r\n        address recipient\r\n    ) external lock onlyAlchemist returns (uint256) {\r\n        // Transfer the rETH from the message sender.\r\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), amount);\r\n\r\n        // Burn the rETH to receive ETH.\r\n        uint256 startingEthBalance = address(this).balance;\r\n        IRETH(token).burn(amount);\r\n        uint256 receivedEth = address(this).balance - startingEthBalance;\r\n\r\n        // Wrap the ETH that we received from the burn.\r\n        IWETH9(underlyingToken).deposit{value: receivedEth}();\r\n\r\n        // Transfer the tokens to the recipient.\r\n        SafeERC20.safeTransfer(underlyingToken, recipient, receivedEth);\r\n\r\n        return receivedEth;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"alchemist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingToken\",\"type\":\"address\"}],\"internalType\":\"struct InitializationParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"UnsupportedOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"alchemist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"unwrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"wrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RETHAdapterV1", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000062bf725dc4cdf947aa79ca2aaccd4f385b13b5c000000000000000000000000ae78736cd615f374d3085123a210448e74fc6393000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://28adafb4e53bca4816fcab1c409a5aed7291af9910af4f5d721b8ee0add84a3d"}]}