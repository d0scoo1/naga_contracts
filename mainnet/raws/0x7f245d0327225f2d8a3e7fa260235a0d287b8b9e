{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.15;\r\n\r\nstruct TDates\r\n{\r\n uint raffleStartDate;\r\n uint raffleEndDate;\r\n uint presalesDate;\r\n uint salesDate;\r\n}\r\n\r\nstruct TQuantities\r\n{\r\n uint mint;\r\n uint vip;\r\n uint whitelist;\r\n uint claim;\r\n}\r\n\r\n//==============================================================================\r\ninterface IERC165\r\n{\r\n function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n//==============================================================================\r\ninterface IERC721 is IERC165\r\n{\r\n event Transfer( address indexed from, address indexed to, uint indexed tokenId);\r\n event Approval( address indexed owner, address indexed approved, uint indexed tokenId);\r\n event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n function balanceOf( address owner) external view returns (uint balance);\r\n function ownerOf( uint tokenId) external view returns (address owner);\r\n function safeTransferFrom( address from, address to, uint tokenId) external;\r\n function transferFrom( address from, address to, uint tokenId) external;\r\n function approve( address to, uint tokenId) external;\r\n function getApproved( uint tokenId) external view returns (address operator);\r\n function setApprovalForAll(address operator, bool _approved) external;\r\n function isApprovedForAll( address owner, address operator) external view returns (bool);\r\n function safeTransferFrom( address from, address to, uint tokenId, bytes calldata data) external;\r\n}\r\n//==============================================================================\r\ninterface IERC721Metadata is IERC721\r\n{\r\n function name() external view returns (string memory);\r\n function symbol() external view returns (string memory);\r\n function tokenURI(uint tokenId) external view returns (string memory);\r\n}\r\n//==============================================================================\r\ninterface IERC721Enumerable is IERC721\r\n{\r\n function totalSupply() external view returns (uint);\r\n function tokenOfOwnerByIndex(address owner, uint index) external view returns (uint tokenId);\r\n function tokenByIndex(uint index) external view returns (uint);\r\n}\r\n//==============================================================================\r\ninterface IERC721Receiver\r\n{\r\n function onERC721Received(address operator, address from, uint tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n//================================================================================\r\nlibrary Strings\r\n{\r\n bytes16 private constant alphabet = \"0123456789abcdef\";\r\n\r\n function toString(uint value) internal pure returns (string memory)\r\n {\r\n if (value==0) return \"0\";\r\n \r\n uint temp = value;\r\n uint digits;\r\n \r\n while (temp!=0)\r\n {\r\n digits++;\r\n temp /= 10;\r\n }\r\n \r\n bytes memory buffer = new bytes(digits);\r\n \r\n while (value!=0)\r\n {\r\n digits -= 1;\r\n buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\r\n value /= 10;\r\n }\r\n \r\n return string(buffer);\r\n }\r\n}\r\n//================================================================================\r\nlibrary Address\r\n{\r\n function isContract(address account) internal view returns (bool)\r\n {\r\n uint size;\r\n \r\n assembly { size := extcodesize(account) } // solhint-disable-next-line no-inline-assembly\r\n return size > 0;\r\n }\r\n}\r\n//==============================================================================\r\nabstract contract ERC165 is IERC165\r\n{\r\n function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool)\r\n {\r\n return (interfaceId == type(IERC165).interfaceId);\r\n }\r\n}\r\n//==============================================================================\r\nabstract contract Context\r\n{\r\n function _msgSender() internal view virtual returns (address)\r\n {\r\n return msg.sender;\r\n }\r\n //----------------------------------------------------------------\r\n function _msgData() internal view virtual returns (bytes calldata)\r\n {\r\n this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n return msg.data;\r\n }\r\n}\r\n//--------------------------------------------------------------------------------\r\nabstract contract Ownable is Context\r\n{\r\n address private _owner;\r\n address private _admin;\r\n\r\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n constructor ()\r\n {\r\n address msgSender = _msgSender();\r\n _owner = msgSender;\r\n _admin = 0x738C30758b22bCe4EE64d4dd2dc9f0dcCd097229;\r\n \r\n emit OwnershipTransferred(address(0), msgSender);\r\n }\r\n \r\n function admin() public view virtual returns (address)\r\n {\r\n return _admin;\r\n }\r\n \r\n function owner() public view virtual returns (address)\r\n {\r\n return _owner;\r\n }\r\n \r\n function setAdmin(address newAdmin) public onlyOwner\r\n {\r\n address previousAdmin = _admin;\r\n _admin = newAdmin;\r\n\r\n emit AdminChanged(previousAdmin, newAdmin);\r\n }\r\n\r\n modifier onlyOwner()\r\n {\r\n require(owner() == _msgSender(), \"Not owner\");\r\n _;\r\n }\r\n \r\n modifier onlyAdminOrOwner()\r\n {\r\n require(_msgSender()==owner() || _msgSender()==admin(), \"Owner or Admin only\");\r\n _;\r\n }\r\n\r\n function transferOwnership(address newOwner) public virtual onlyOwner\r\n {\r\n require(newOwner != address(0), \"Bad addr\");\r\n \r\n emit OwnershipTransferred(_owner, newOwner);\r\n \r\n _owner = newOwner;\r\n }\r\n}\r\n//==============================================================================\r\nabstract contract ReentrancyGuard \r\n{\r\n uint private constant _NOT_ENTERED = 1;\r\n uint private constant _ENTERED = 2;\r\n\r\n uint private _status;\r\n\r\n constructor() \r\n { \r\n _status = _NOT_ENTERED;\r\n }\r\n\r\n modifier nonReentrant() // Prevents a contract from calling itself, directly or indirectly.\r\n {\r\n require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); // On the first call to nonReentrant, _notEntered will be true\r\n _status = _ENTERED; // Any calls to nonReentrant after this point will fail\r\n _;\r\n _status = _NOT_ENTERED; // By storing the original value once again, a refund is triggered (see // https://eips.ethereum.org/EIPS/eip-2200)\r\n }\r\n}\r\n//==============================================================================\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, Ownable, ReentrancyGuard\r\n{\r\n using Address for address;\r\n using Strings for uint;\r\n\r\n string private _name; // Token name\r\n string private _symbol; // Token symbol\r\n\r\n mapping(uint => address) internal _owners; // Mapping from token ID to owner address\r\n mapping(address => uint) internal _balances; // Mapping owner address to token count\r\n mapping(uint => address) private _tokenApprovals; // Mapping from token ID to approved address\r\n mapping(address => mapping(address => bool)) private _operatorApprovals; // Mapping from owner to operator approvals\r\n \r\n constructor(string memory name_, string memory symbol_)\r\n {\r\n _name = name_;\r\n _symbol = symbol_;\r\n }\r\n function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool)\r\n {\r\n return interfaceId == type(IERC721).interfaceId ||\r\n interfaceId == type(IERC721Metadata).interfaceId ||\r\n super.supportsInterface(interfaceId);\r\n }\r\n function balanceOf(address owner) public view virtual override returns (uint)\r\n {\r\n require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n \r\n return _balances[owner];\r\n }\r\n function ownerOf(uint tokenId) public view virtual override returns (address)\r\n {\r\n address owner = _owners[tokenId];\r\n require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n return owner;\r\n }\r\n function name() public view virtual override returns (string memory)\r\n {\r\n return _name;\r\n }\r\n function symbol() public view virtual override returns (string memory)\r\n {\r\n return _symbol;\r\n }\r\n function tokenURI(uint tokenId) public view virtual override returns (string memory)\r\n {\r\n require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n string memory baseURI = _baseURI();\r\n \r\n return (bytes(baseURI).length>0) ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n }\r\n function _baseURI() internal view virtual returns (string memory)\r\n {\r\n return \"\";\r\n }\r\n function approve(address to, uint tokenId) public virtual override\r\n {\r\n address owner = ERC721.ownerOf(tokenId);\r\n \r\n require(to!=owner, \"ERC721: approval to current owner\");\r\n require(_msgSender()==owner || ERC721.isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not owner nor approved for all\");\r\n\r\n _approve(to, tokenId);\r\n }\r\n function getApproved(uint tokenId) public view virtual override returns (address)\r\n {\r\n require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n return _tokenApprovals[tokenId];\r\n }\r\n function setApprovalForAll(address operator, bool approved) public virtual override\r\n {\r\n require(operator != _msgSender(), \"ERC721: approve to caller\");\r\n\r\n _operatorApprovals[_msgSender()][operator] = approved;\r\n \r\n emit ApprovalForAll(_msgSender(), operator, approved);\r\n }\r\n function isApprovedForAll(address owner, address operator) public view virtual override returns (bool)\r\n {\r\n return _operatorApprovals[owner][operator];\r\n }\r\n function transferFrom(address from, address to, uint tokenId) public virtual override\r\n {\r\n //----- solhint-disable-next-line max-line-length\r\n \r\n require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n _transfer(from, to, tokenId);\r\n }\r\n function safeTransferFrom(address from, address to, uint tokenId) public virtual override\r\n {\r\n safeTransferFrom(from, to, tokenId, \"\");\r\n }\r\n function safeTransferFrom(address from, address to, uint tokenId, bytes memory _data) public virtual override\r\n {\r\n require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n \r\n _safeTransfer(from, to, tokenId, _data);\r\n }\r\n function _safeTransfer(address from, address to, uint tokenId, bytes memory _data) internal virtual\r\n {\r\n _transfer(from, to, tokenId);\r\n \r\n require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n }\r\n function _exists(uint tokenId) internal view virtual returns (bool)\r\n {\r\n return _owners[tokenId] != address(0);\r\n }\r\n function _isApprovedOrOwner(address spender, uint tokenId) internal view virtual returns (bool)\r\n {\r\n require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n \r\n address owner = ERC721.ownerOf(tokenId);\r\n \r\n return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\r\n }\r\n function _safeMint(address to, uint tokenId) internal virtual\r\n {\r\n _safeMint(to, tokenId, \"\");\r\n }\r\n function _safeMint(address to, uint tokenId, bytes memory _data) internal virtual\r\n {\r\n _mint(to, tokenId);\r\n \r\n require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n }\r\n function _mint(address to, uint tokenId) internal virtual\r\n {\r\n require(to != address(0), \"ERC721: mint to the zero address\");\r\n require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n _balances[to] += 1;\r\n _owners[tokenId] = to;\r\n\r\n emit Transfer(address(0), to, tokenId);\r\n }\r\n function _batchMint(address to, uint[] memory tokenIds) internal virtual\r\n {\r\n require(to != address(0), \"ERC721: mint to the zero address\");\r\n \r\n _balances[to] += tokenIds.length;\r\n\r\n for (uint i=0; i < tokenIds.length; i++)\r\n {\r\n require(!_exists(tokenIds[i]), \"ERC721: token already minted\");\r\n\r\n _beforeTokenTransfer(address(0), to, tokenIds[i]);\r\n\r\n _owners[tokenIds[i]] = to;\r\n\r\n emit Transfer(address(0), to, tokenIds[i]);\r\n }\r\n }\r\n function _burn(uint tokenId) internal virtual\r\n {\r\n address owner = ERC721.ownerOf(tokenId);\r\n\r\n _beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n _approve(address(0), tokenId); // Clear approvals\r\n\r\n _balances[owner] -= 1;\r\n\r\n delete _owners[tokenId];\r\n\r\n emit Transfer(owner, address(0), tokenId);\r\n }\r\n function _transfer(address from, address to, uint tokenId) internal virtual\r\n {\r\n require(ERC721.ownerOf(tokenId)==from, \"ERC721: transfer of token that is not own\");\r\n require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n _beforeTokenTransfer(from, to, tokenId);\r\n\r\n _approve(address(0), tokenId); // Clear approvals from the previous owner\r\n\r\n _balances[from] -= 1;\r\n _balances[to] += 1;\r\n _owners[tokenId] = to;\r\n\r\n emit Transfer(from, to, tokenId);\r\n }\r\n function _approve(address to, uint tokenId) internal virtual\r\n {\r\n _tokenApprovals[tokenId] = to;\r\n \r\n emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n }\r\n function _checkOnERC721Received(address from,address to,uint tokenId,bytes memory _data) private returns (bool)\r\n {\r\n if (to.isContract())\r\n {\r\n try\r\n \r\n IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data)\r\n \r\n returns (bytes4 retval)\r\n {\r\n return retval == IERC721Receiver(to).onERC721Received.selector;\r\n }\r\n catch (bytes memory reason)\r\n {\r\n if (reason.length==0)\r\n {\r\n revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n }\r\n else\r\n {\r\n assembly { revert(add(32, reason), mload(reason)) } //// solhint-disable-next-line no-inline-assembly\r\n }\r\n }\r\n }\r\n else\r\n {\r\n return true;\r\n }\r\n }\r\n function _beforeTokenTransfer(address from, address to, uint tokenId) internal virtual\r\n {\r\n //\r\n }\r\n}\r\n//==============================================================================\r\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable\r\n{\r\n mapping(address => mapping(uint => uint)) private _ownedTokens; // Mapping from owner to list of owned token IDs\r\n mapping(uint => uint) private _ownedTokensIndex; // Mapping from token ID to index of the owner tokens list\r\n mapping(uint => uint) private _allTokensIndex; // Mapping from token id to position in the allTokens array\r\n\r\n uint[] private _allTokens; // Array with all token ids, used for enumeration\r\n\r\n function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool)\r\n {\r\n return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\r\n }\r\n function totalSupply() public view virtual override returns (uint)\r\n {\r\n return _allTokens.length;\r\n }\r\n function tokenOfOwnerByIndex(address owner, uint index) public view virtual override returns (uint)\r\n {\r\n require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n \r\n return _ownedTokens[owner][index];\r\n }\r\n function tokenByIndex(uint index) public view virtual override returns (uint)\r\n {\r\n require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n \r\n return _allTokens[index];\r\n }\r\n function _beforeTokenTransfer(address from,address to,uint tokenId) internal virtual override\r\n {\r\n super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n if (from == address(0)) _addTokenToAllTokensEnumeration(tokenId);\r\n else if (from != to) _removeTokenFromOwnerEnumeration(from, tokenId);\r\n \r\n if (to == address(0)) _removeTokenFromAllTokensEnumeration(tokenId);\r\n else if (to != from) _addTokenToOwnerEnumeration(to, tokenId);\r\n }\r\n function _addTokenToOwnerEnumeration(address to, uint tokenId) private\r\n {\r\n uint length = ERC721.balanceOf(to);\r\n \r\n _ownedTokens[to][length] = tokenId;\r\n _ownedTokensIndex[tokenId] = length;\r\n }\r\n function _addTokenToAllTokensEnumeration(uint tokenId) private\r\n {\r\n _allTokensIndex[tokenId] = _allTokens.length;\r\n \r\n _allTokens.push(tokenId);\r\n }\r\n function _removeTokenFromOwnerEnumeration(address from, uint tokenId) private\r\n {\r\n // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n // then delete the last slot (swap and pop).\r\n\r\n uint lastTokenIndex = ERC721.balanceOf(from) - 1;\r\n uint tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n // When the token to delete is the last token, the swap operation is unnecessary\r\n if (tokenIndex != lastTokenIndex) {\r\n uint lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n }\r\n\r\n // This also deletes the contents at the last position of the array\r\n delete _ownedTokensIndex[tokenId];\r\n delete _ownedTokens[from][lastTokenIndex];\r\n }\r\n function _removeTokenFromAllTokensEnumeration(uint tokenId) private\r\n {\r\n // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n // then delete the last slot (swap and pop).\r\n\r\n uint lastTokenIndex = _allTokens.length - 1;\r\n uint tokenIndex = _allTokensIndex[tokenId];\r\n\r\n // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n uint lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n // This also deletes the contents at the last position of the array\r\n delete _allTokensIndex[tokenId];\r\n _allTokens.pop();\r\n }\r\n}\r\n//==============================================================================\r\ncontract NtfULoanGenesis is ERC721Enumerable\r\n{\r\n using Address for address;\r\n using Strings for uint;\r\n\r\n modifier callerIsUser()\r\n {\r\n require(tx.origin == msg.sender, \"The caller is another contract\");\r\n _;\r\n }\r\n\r\n event onWidthdrawal(address from, address to, uint amount);\r\n event Reserved(address wallet, uint amount);\r\n event SetRaffleDates(uint startDate, uint endDate);\r\n event SetPresalesDate(uint newDate, uint oldDate);\r\n event SetSalesDate(uint newDate, uint oldDate);\r\n event SetWhitelistPrice(uint newPrice);\r\n event SetSalesPrice(uint newPrice);\r\n event SetVIPPrice(uint newPrice);\r\n \r\n uint private totalTokens = 3555; \r\n uint private maxMintable = 3333;\r\n uint private leftTokenCount = totalTokens;\r\n uint private mintedTokenCount = 0;\r\n uint private generatedTokenCount = 0;\r\n\r\n string private baseURI = '/';\r\n\r\n address private ownerWallet;\r\n\r\n uint[] whitelistPrices = [ 0.2 ether, 0.2 ether ];\r\n uint[] salesPrices = [ 0.3 ether, 0.3 ether ];\r\n uint[] vipPrices = [ 0.2 ether, 0.2 ether ];\r\n\r\n uint public whitelistPrice;\r\n uint public salesPrice;\r\n uint public vipPrice;\r\n\r\n uint public raffleStartDate = 1656262800;\r\n uint public raffleEndDate = 1656277199;\r\n uint public presalesDate = 1656277200;\r\n uint public salesDate = 1656338400;\r\n\r\n string private signHeader = \"\\x19Ethereum Signed Message:\\n32\";\r\n\r\n mapping(bytes32 => bool) private proposedHashes; // used to avoid using the same hash on CreateLoan calls\r\n\r\n mapping(address => uint) private walletMintedTokenIds;\r\n\r\n mapping(address => uint) private mintedQuantities;\r\n mapping(address => uint) private vipQuantities;\r\n mapping(address => uint) private whitelistedQuantities;\r\n mapping(address => uint) private claimedQuantities;\r\n\r\n mapping(uint => uint) private mintedTokenTimestamps;\r\n\r\n string private magicLettersCode = \"FFFNTNTAFAANAFOANTNTFNTLONOFNFNNTNOFFAAUTOOUNTNFNNANAFTNOFNNLTOLNNNOFNNNFTTFFNFTNTNFNOLUTTTUTUTATNFL\";\r\n mapping(uint => string) private tokenMagicLetters;\r\n\r\n constructor() ERC721(\"Genesis Alpha\", \"ULGAP\") // temporary Symbol and title\r\n //constructor() ERC721(\"ULoan Genesis Pass\", \"ULGP\")\r\n {\r\n ownerWallet = msg.sender;\r\n\r\n uint priceIdx = 0;\r\n if (block.chainid!=1) priceIdx = 1;\r\n\r\n whitelistPrice = whitelistPrices[priceIdx];\r\n salesPrice = salesPrices[priceIdx];\r\n vipPrice = vipPrices[priceIdx];\r\n }\r\n //------------------------------------------------------------------------\r\n function isERC721ReceivedCheck(address from,address to,uint tokenId,bytes memory _data) private returns (bool)\r\n {\r\n if (to.isContract())\r\n {\r\n try\r\n \r\n IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data)\r\n \r\n returns (bytes4 retval)\r\n {\r\n return retval == IERC721Receiver(to).onERC721Received.selector;\r\n }\r\n catch (bytes memory reason)\r\n {\r\n if (reason.length==0)\r\n {\r\n revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n }\r\n else\r\n {\r\n assembly { revert(add(32, reason), mload(reason)) } //// solhint-disable-next-line no-inline-assembly\r\n }\r\n }\r\n }\r\n else\r\n {\r\n return true;\r\n }\r\n }\r\n //------------------------------------------------------------------------\r\n function setBaseTokenURI(string memory newUri) external onlyOwner\r\n {\r\n baseURI = newUri;\r\n }\r\n //------------------------------------------------------------------------\r\n function baseTokenURI() external view returns (string memory)\r\n {\r\n return baseURI;\r\n }\r\n //------------------------------------------------------------------------\r\n function getAvailableTokens() external view returns (uint)\r\n {\r\n return leftTokenCount;\r\n }\r\n //------------------------------------------------------------------------\r\n function _baseURI() internal view virtual override returns (string memory)\r\n {\r\n return baseURI;\r\n }\r\n //------------------------------------------------------------------------\r\n function getTokenIdsByWallet(address walletAddress) external view returns(uint[] memory)\r\n {\r\n require(walletAddress!=address(0), \"BlackHole wallet is not a real owner\");\r\n \r\n uint count = balanceOf(walletAddress);\r\n uint[] memory result = new uint[](count);\r\n \r\n for (uint i=0; i<count; i++)\r\n {\r\n result[i] = tokenOfOwnerByIndex(walletAddress, i);\r\n }\r\n \r\n return result;\r\n }\r\n //---------------------------------------------------------------------------\r\n function setWhitelistPrice(uint newPrice) external onlyOwner\r\n {\r\n whitelistPrice = newPrice;\r\n\r\n emit SetWhitelistPrice(newPrice);\r\n }\r\n //---------------------------------------------------------------------------\r\n function setVIPPrice(uint newPrice) external onlyOwner\r\n {\r\n vipPrice = newPrice;\r\n\r\n emit SetVIPPrice(newPrice);\r\n }\r\n //---------------------------------------------------------------------------\r\n function getVIPPrice() external view returns(uint price)\r\n {\r\n return vipPrice;\r\n }\r\n //---------------------------------------------------------------------------\r\n function setSalesPrice(uint newPrice) external onlyOwner\r\n {\r\n salesPrice = newPrice;\r\n\r\n emit SetSalesPrice(newPrice);\r\n }\r\n //---------------------------------------------------------------------------\r\n function reserve(uint amount) external onlyOwner\r\n {\r\n require(leftTokenCount >= amount, \"Not enough tokens left to reserve anymore\");\r\n\r\n for (uint i=0; i < amount; i++)\r\n {\r\n generatedTokenCount++;\r\n \r\n mintedTokenTimestamps[generatedTokenCount] = block.timestamp;\r\n \r\n _safeMint(msg.sender, generatedTokenCount);\r\n\r\n setTokenMagicLetter(generatedTokenCount);\r\n }\r\n\r\n leftTokenCount = totalTokens - generatedTokenCount;\r\n\r\n emit Reserved(msg.sender, amount);\r\n }\r\n //---------------------------------------------------------------------------\r\n function mint(address toWallet, uint quantity) external payable // toWallet is used for compatibility with crossmint.io\r\n {\r\n require(block.timestamp>=salesDate, \"Minting is closed\"); // mint possible only during public sales\r\n require(toWallet!=address(0), \"Blackhole forbidden\");\r\n require(salesPrice!=0, \"Invalid internal price\");\r\n require(quantity>0 && quantity<=2, \"Invalid NFT quantity\");\r\n require(msg.value==salesPrice*quantity, \"Send exact Amount to claim your Nft\");\r\n require(leftTokenCount > 0, \"No tokens left to be claimed\");\r\n require(mintedTokenCount<maxMintable, \"Sold-out\");\r\n require(mintedTokenCount+quantity<=maxMintable, \"Not enough NFT left to mint\");\r\n\r\n uint qty = mintedQuantities[toWallet] + quantity;\r\n\r\n require(qty<=2, \"Too many claimed\"); \r\n\r\n mintedQuantities[toWallet] += quantity;\r\n\r\n for (uint i=0; i < quantity; i++)\r\n {\r\n mintedTokenCount++;\r\n generatedTokenCount++;\r\n leftTokenCount--;\r\n\r\n mintedTokenTimestamps[generatedTokenCount] = block.timestamp;\r\n\r\n _mint(toWallet, generatedTokenCount);\r\n\r\n setTokenMagicLetter(generatedTokenCount);\r\n }\r\n }\r\n //---------------------------------------------------------------------------\r\n function whitelistMint(address toWallet, uint quantity, bytes32 proposedHash,uint8 v,bytes32 r,bytes32 s) external payable // toWallet is used for compatibility with crossmint.io\r\n {\r\n //----- Signed function checker\r\n\r\n bool isProposedHashedUsed = proposedHashes[proposedHash];\r\n\r\n require(isProposedHashedUsed==false, \"Bad Hash\");\r\n\r\n proposedHashes[proposedHash] = true;\r\n\r\n bytes32 messageDigest = keccak256(abi.encodePacked(signHeader, proposedHash));\r\n bool isFromAdmin = (ecrecover(messageDigest, v, r, s)==admin());\r\n\r\n require(isFromAdmin==true, \"Bad call\");\r\n\r\n //----- \r\n\r\n require(block.timestamp>=presalesDate, \"Pre-minting is not opened\"); \r\n require(block.timestamp<salesDate, \"Pre-minting is closed\");\r\n require(toWallet!=address(0), \"Blackhole forbidden\");\r\n require(quantity>0 && quantity<=2, \"Invalid NFT quantity\");\r\n require(whitelistPrice!=0, \"Invalid internal price\");\r\n require(msg.value==whitelistPrice*quantity, \"Send exact Amount to claim your Nft\");\r\n require(leftTokenCount > 0, \"No tokens left to be claimed\");\r\n require(mintedTokenCount<maxMintable, \"Sold-out\");\r\n require(mintedTokenCount+quantity<=maxMintable, \"Not enough NFT left to mint\");\r\n\r\n uint qty = whitelistedQuantities[toWallet] + quantity;\r\n\r\n require(qty<=2, \"Too many claimed\"); \r\n\r\n whitelistedQuantities[toWallet] += quantity;\r\n\r\n for (uint i=0; i < quantity; i++)\r\n {\r\n mintedTokenCount++;\r\n generatedTokenCount++;\r\n leftTokenCount--;\r\n\r\n mintedTokenTimestamps[generatedTokenCount] = block.timestamp;\r\n\r\n _mint(toWallet, generatedTokenCount);\r\n\r\n setTokenMagicLetter(generatedTokenCount);\r\n }\r\n }\r\n //---------------------------------------------------------------------------\r\n function vipMint(address toWallet, uint quantity, bytes32 proposedHash,uint8 v,bytes32 r,bytes32 s) external payable // toWallet is used for compatibility with crossmint.io\r\n {\r\n //----- Signed function checker\r\n\r\n bool isProposedHashedUsed = proposedHashes[proposedHash];\r\n\r\n require(isProposedHashedUsed==false, \"Bad Hash\");\r\n\r\n proposedHashes[proposedHash] = true;\r\n\r\n bytes32 messageDigest = keccak256(abi.encodePacked(signHeader, proposedHash));\r\n bool isFromAdmin = (ecrecover(messageDigest, v, r, s)==admin());\r\n\r\n require(isFromAdmin==true, \"Bad call\");\r\n\r\n //-----\r\n \r\n require(quantity>0 && quantity<=3, \"Invalid NFT quantity\");\r\n require(leftTokenCount>= quantity, \"No tokens left to be minted\");\r\n require(vipPrice!=0, \"Invalid internal price\");\r\n require(msg.value==vipPrice*quantity, \"Bad price amount\");\r\n require(getGenesisPassMode()!=0, \"Mint is closed\");\r\n\r\n uint qty = vipQuantities[toWallet] + quantity;\r\n\r\n require(qty<=3, \"You cannot mint any more\"); \r\n\r\n //-----\r\n\r\n vipQuantities[toWallet] += quantity;\r\n\r\n for (uint i=0; i < quantity; i++)\r\n {\r\n mintedTokenCount++;\r\n generatedTokenCount++;\r\n leftTokenCount--;\r\n\r\n mintedTokenTimestamps[generatedTokenCount] = block.timestamp;\r\n\r\n _mint(toWallet, generatedTokenCount);\r\n\r\n setTokenMagicLetter(generatedTokenCount);\r\n }\r\n }\r\n //---------------------------------------------------------------------------\r\n function claim(uint quantity, bytes32 proposedHash,uint8 v,bytes32 r,bytes32 s) external \r\n {\r\n //----- Signed function checker\r\n\r\n bool isProposedHashedUsed = proposedHashes[proposedHash];\r\n\r\n require(isProposedHashedUsed==false, \"Bad Hash\");\r\n\r\n proposedHashes[proposedHash] = true;\r\n\r\n bytes32 messageDigest = keccak256(abi.encodePacked(signHeader, proposedHash));\r\n bool isFromAdmin = (ecrecover(messageDigest, v, r, s)==admin());\r\n\r\n require(isFromAdmin==true, \"Bad call\");\r\n\r\n //-----\r\n \r\n require(getGenesisPassMode()>1, \"Claim is not active\");\r\n require(leftTokenCount>= quantity, \"No tokens left to be claimed\");\r\n\r\n claimedQuantities[msg.sender] += quantity;\r\n\r\n for (uint i=0; i < quantity; i++)\r\n {\r\n generatedTokenCount++;\r\n leftTokenCount--;\r\n\r\n mintedTokenTimestamps[generatedTokenCount] = block.timestamp;\r\n\r\n _mint(msg.sender, generatedTokenCount);\r\n\r\n setTokenMagicLetter(generatedTokenCount);\r\n }\r\n }\r\n //---------------------------------------------------------------------------\r\n function hasClaimed(address wallet) external view returns(bool)\r\n {\r\n return claimedQuantities[wallet]!=0;\r\n }\r\n //---------------------------------------------------------------------------\r\n //---------------------------------------------------------------------------\r\n function getWalletQuantities(address wallet) external view returns(TQuantities memory)\r\n {\r\n TQuantities memory QTY = TQuantities\r\n (\r\n mintedQuantities[wallet],\r\n vipQuantities[wallet],\r\n whitelistedQuantities[wallet],\r\n claimedQuantities[wallet]\r\n );\r\n\r\n return QTY;\r\n }\r\n //---------------------------------------------------------------------------\r\n function getGenesisPassMode() public view returns(uint currentSellMode) // MODE => 0:OFF 1:RAFFLE 2:PRESALE 3:PUBLICSALE\r\n {\r\n uint mode = 0; // OFF\r\n\r\n if (block.timestamp>=salesDate) mode = 3; // PUBLIC SALE\r\n else if (block.timestamp>=presalesDate) mode = 2; // PRE-SALE\r\n else if (block.timestamp>=raffleStartDate && block.timestamp<=raffleEndDate)\r\n {\r\n mode = 1; // RAFFLE\r\n }\r\n return mode;\r\n }\r\n //---------------------------------------------------------------------------\r\n function getCurrentPrice() public view returns(uint currentPrice) // MODE => 0:OFF 1:RAFFLE 2:PRESALE 3:PUBLICSALE\r\n {\r\n uint mode = getGenesisPassMode();\r\n\r\n uint price = salesPrice;\r\n if (mode==2) price = whitelistPrice;\r\n else if (mode==1) price = vipPrice;\r\n\r\n return price;\r\n }\r\n //---------------------------------------------------------------------------\r\n function getMintedCount() public view returns(uint leftCount)\r\n {\r\n return mintedTokenCount;\r\n }\r\n //---------------------------------------------------------------------------\r\n function getMintLeft() public view returns(uint leftCount)\r\n {\r\n return maxMintable - mintedTokenCount;\r\n }\r\n //---------------------------------------------------------------------------\r\n function getMaxMintableCount() public view returns(uint leftCount)\r\n {\r\n return maxMintable;\r\n }\r\n //---------------------------------------------------------------------------\r\n //---------------------------------------------------------------------------\r\n //---------------------------------------------------------------------------\r\n function getDates() external view returns(TDates memory)\r\n {\r\n TDates memory datesInfo = TDates\r\n (\r\n raffleStartDate,\r\n raffleEndDate,\r\n presalesDate,\r\n salesDate\r\n );\r\n\r\n return datesInfo;\r\n }\r\n //---------------------------------------------------------------------------\r\n function setRaffleDates(uint startDate, uint endDate) external onlyOwner\r\n {\r\n require(startDate < presalesDate, \"Cannot start during presales or sale period\");\r\n require(endDate < presalesDate, \"Cannot end during presales or sale period\");\r\n require(startDate < endDate, \"Invalid date\");\r\n\r\n raffleStartDate = startDate;\r\n raffleEndDate = endDate;\r\n\r\n emit SetRaffleDates(startDate, endDate);\r\n }\r\n //---------------------------------------------------------------------------\r\n function setPresalesDate(uint newDate) external onlyOwner\r\n {\r\n require(newDate < salesDate, \"Presales should start before public sale\");\r\n\r\n uint oldDate = presalesDate;\r\n presalesDate = newDate;\r\n\r\n emit SetPresalesDate(newDate, oldDate);\r\n }\r\n //---------------------------------------------------------------------------\r\n function setSalesDate(uint newDate) external onlyOwner\r\n {\r\n require(newDate > presalesDate, \"Presales should start before public sale\");\r\n\r\n uint oldDate = salesDate;\r\n salesDate = newDate;\r\n\r\n emit SetSalesDate(newDate, oldDate);\r\n }\r\n //---------------------------------------------------------------------------\r\n //---------------------------------------------------------------------------\r\n //---------------------------------------------------------------------------\r\n function withdraw() external onlyOwner\r\n {\r\n uint balance = address(this).balance;\r\n\r\n payable(ownerWallet).transfer(balance);\r\n\r\n emit onWidthdrawal(address(this), ownerWallet, balance);\r\n }\r\n //---------------------------------------------------------------------------\r\n //---------------------------------------------------------------------------\r\n //---------------------------------------------------------------------------\r\n function getStringChar(string memory str, uint index) public pure returns (string memory ) \r\n {\r\n bytes memory strBytes = bytes(str);\r\n bytes memory result = new bytes(1);\r\n\r\n result[0] = strBytes[index];\r\n \r\n return string(result);\r\n }\r\n //---------------------------------------------------------------------------\r\n function getMagicLettersByTokenIds(uint[] memory tokenIds) external view returns(string[] memory magicLetters)\r\n {\r\n string[] memory result = new string[](tokenIds.length);\r\n \r\n for (uint i=0; i<tokenIds.length; i++)\r\n {\r\n result[i] = tokenMagicLetters[ tokenIds[i] ];\r\n }\r\n \r\n return result;\r\n }\r\n //---------------------------------------------------------------------------\r\n function setTokenMagicLetter(uint tokenId) internal\r\n {\r\n string memory letter = getStringChar(magicLettersCode, tokenId % 100);\r\n\r\n tokenMagicLetters[tokenId] = letter;\r\n }\r\n //---------------------------------------------------------------------------\r\n function setTokenMagicLetters(string memory hashCode) external onlyOwner\r\n {\r\n magicLettersCode = hashCode;\r\n }\r\n //---------------------------------------------------------------------------\r\n //---------------------------------------------------------------------------\r\n //---------------------------------------------------------------------------\r\n //---------------------------------------------------------------------------\r\n //---------------------------------------------------------------------------\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reserved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDate\",\"type\":\"uint256\"}],\"name\":\"SetPresalesDate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"}],\"name\":\"SetRaffleDates\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDate\",\"type\":\"uint256\"}],\"name\":\"SetSalesDate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"SetSalesPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"SetVIPPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"SetWhitelistPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onWidthdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"proposedHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDates\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"raffleStartDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"raffleEndDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"presalesDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salesDate\",\"type\":\"uint256\"}],\"internalType\":\"struct TDates\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGenesisPassMode\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentSellMode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getMagicLettersByTokenIds\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"magicLetters\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxMintableCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"leftCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"leftCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintedCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"leftCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getStringChar\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"}],\"name\":\"getTokenIdsByWallet\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVIPPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getWalletQuantities\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vip\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"whitelist\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claim\",\"type\":\"uint256\"}],\"internalType\":\"struct TQuantities\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presalesDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raffleEndDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raffleStartDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"salesDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"salesPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newUri\",\"type\":\"string\"}],\"name\":\"setBaseTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDate\",\"type\":\"uint256\"}],\"name\":\"setPresalesDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"}],\"name\":\"setRaffleDates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDate\",\"type\":\"uint256\"}],\"name\":\"setSalesDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setSalesPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"hashCode\",\"type\":\"string\"}],\"name\":\"setTokenMagicLetters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setVIPPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setWhitelistPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"proposedHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"vipMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vipPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"proposedHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"whitelistMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NtfULoanGenesis", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://47c53eacf427404a31b8ad0e8db3fcd7765009e3b57af8542d1eb62be1571370"}]}