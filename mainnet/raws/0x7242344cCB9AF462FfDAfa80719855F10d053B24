{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/resolvers/mainnet/v1/main.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces.sol\\\";\\n\\ncontract VaultResolver {\\n    VaultInterface public immutable vault;\\n\\n    struct Withdraw {\\n        uint128 amount;\\n        uint128 time;\\n    }\\n\\n    function getUserInfo(address user_)\\n        public\\n        view\\n        returns (\\n            uint256 vtokenBal_,\\n            uint256 amount_,\\n            uint256 exchangePrice_\\n        )\\n    {\\n        vtokenBal_ = vault.balanceOf(user_);\\n        (exchangePrice_,) = vault.getCurrentExchangePrice();\\n        amount_ = (vtokenBal_ * exchangePrice_) / 1e18;\\n    }\\n\\n    function getVaultInfo()\\n        public\\n        view\\n        returns (\\n            address vaultDsa_,\\n            uint256 revenue,\\n            uint256 revenueFee_,\\n            uint256 lastRevenueExchangePrice_,\\n            VaultInterface.Ratios memory ratios_\\n        )\\n    {\\n        vaultDsa_ = vault.vaultDsa();\\n        revenue = vault.revenue();\\n        revenueFee_ = vault.revenueFee();\\n        lastRevenueExchangePrice_ = vault.lastRevenueExchangePrice();\\n        ratios_ = vault.ratios();\\n    }\\n\\n    struct RefinanceOneVariables {\\n        uint netCollateral;\\n        uint netBorrow;\\n        VaultInterface.BalVariables balances;\\n        uint netBal;\\n        uint netStEth;\\n        int netWeth;\\n        uint ratio;\\n        uint targetRatioDif;\\n    }\\n\\n    // This function gives data around leverage position\\n    function refinanceOneData() public view returns (\\n        uint finalCol_,\\n        uint finalDebt_,\\n        uint excessDebt_,\\n        uint paybackDebt_,\\n        uint totalAmountToSwap_,\\n        uint extraWithdraw_,\\n        bool isRisky_\\n    ) {\\n        RefinanceOneVariables memory v_;\\n        (v_.netCollateral, v_.netBorrow, v_.balances, , v_.netBal) = vault.netAssets();\\n        VaultInterface.Ratios memory ratios_ = vault.ratios();\\n        v_.netStEth = v_.netCollateral + v_.balances.stethVaultBal + v_.balances.stethDsaBal;\\n        v_.netWeth = int(v_.balances.wethVaultBal + v_.balances.wethDsaBal) - int(v_.netBorrow);\\n        v_.ratio = v_.netWeth < 0 ? (uint(-v_.netWeth) * 1e4) / v_.netStEth : 0;\\n        v_.targetRatioDif = 10000 - (ratios_.minLimit - 10); // taking 0.1% more dif for margin\\n        if (v_.ratio < ratios_.minLimitGap) {\\n            // leverage till minLimit <> minLimitGap\\n            // final difference between collateral & debt in percent\\n            finalCol_ = (v_.netBal * 1e4) / v_.targetRatioDif;\\n            finalDebt_ = finalCol_ - v_.netBal;\\n            excessDebt_ = finalDebt_ - v_.netBorrow;\\n            totalAmountToSwap_ = v_.netWeth > 0 ? uint(excessDebt_) + uint(v_.netWeth) : uint(excessDebt_);\\n            // keeping as non collateral for easier withdrawals\\n            extraWithdraw_ = finalCol_ - ((finalDebt_ * 1e4) / (ratios_.maxLimit - 10));\\n        } else {\\n            finalCol_ = v_.netStEth;\\n            finalDebt_ = uint(-v_.netWeth);\\n            paybackDebt_ = v_.balances.wethVaultBal + v_.balances.wethDsaBal;\\n            if (v_.ratio < (ratios_.maxLimit - 10)) {\\n                extraWithdraw_ = finalCol_ - ((finalDebt_ * 1e4) / (ratios_.maxLimit - 10));\\n            }\\n        }\\n        if (v_.ratio > ratios_.maxLimit) {\\n            isRisky_ = true;\\n        }\\n        if (excessDebt_ < 1e14) excessDebt_ = 0;\\n        if (paybackDebt_ < 1e14) paybackDebt_ = 0;\\n        if (totalAmountToSwap_ < 1e14) totalAmountToSwap_ = 0;\\n        if (extraWithdraw_ < 1e14) extraWithdraw_ = 0;\\n    }\\n\\n    constructor(address vaultAddr_) {\\n        vault = VaultInterface(vaultAddr_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/resolvers/mainnet/v1/interfaces.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface VaultInterface {\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function getCurrentExchangePrice()\\n        external\\n        view\\n        returns (\\n            uint256 exchangePrice_,\\n            uint256 newRevenue_\\n        );\\n    \\n    struct BalVariables {\\n        uint wethVaultBal;\\n        uint wethDsaBal;\\n        uint stethVaultBal;\\n        uint stethDsaBal;\\n        uint totalBal;\\n    }\\n\\n    function netAssets() external view returns (\\n        uint netCollateral_,\\n        uint netBorrow_,\\n        BalVariables memory balances_,\\n        uint netSupply_,\\n        uint netBal_\\n    );\\n\\n    struct Ratios {\\n        uint16 maxLimit; // Above this withdrawals are not allowed\\n        uint16 minLimit; // After leverage the ratio should be below minLimit & above minLimitGap\\n        uint16 minLimitGap;\\n        // send borrow rate in 4 decimals from UI. In the smart contract it'll convert to 27 decimals which where is 100%\\n        uint128 maxBorrowRate; // maximum borrow rate above this leveraging should not happen\\n    }\\n\\n    // maximum borrow rate. If above this limit then leverage won't happen\\n    function ratios() external view returns (Ratios memory);\\n\\n    function vaultDsa() external view returns (address);\\n\\n    function lastRevenueExchangePrice() external view returns (uint256);\\n\\n    function revenueFee() external view returns (uint256);\\n\\n    function revenue() external view returns (uint256);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddr_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vtokenBal_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangePrice_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vaultDsa_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"revenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revenueFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRevenueExchangePrice_\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"maxLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minLimitGap\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"maxBorrowRate\",\"type\":\"uint128\"}],\"internalType\":\"struct VaultInterface.Ratios\",\"name\":\"ratios_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refinanceOneData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"finalCol_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalDebt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"excessDebt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paybackDebt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountToSwap_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraWithdraw_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isRisky_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract VaultInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VaultResolver", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c383a3833a87009fd9597f8184979af5edfad019", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}