{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/old.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport \\\"./ProxyERC20.sol\\\";\\nimport \\\"./interfaces/IElysian.sol\\\";\\n\\ncontract ProxyERC20Mintable is ProxyERC20 {\\n    \\n    constructor(address _owner) public ProxyERC20(_owner) {}\\n\\n    function mint(uint amount, address dst, bool isEscrowed) external returns (bool) {\\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\\n        target.setMessageSender(msg.sender);\\n\\n        // Forward the ERC20 call to the target contract\\n        IElysian(address(target)).mint(amount, dst, isEscrowed);\\n\\n        // Event emitting will occur via Proxy._emit()\\n        return true;\\n    }\\n\\n}\"\r\n    },\r\n    \"/contracts/interfaces/ISynth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n\\ninterface ISynth {\\n    // Views\\n    function currencyKey() external view returns (bytes32);\\n\\n    function transferableSynths(address account) external view returns (uint);\\n\\n    // Mutative functions\\n    function transferAndSettle(address to, uint value) external returns (bool);\\n\\n    function transferFromAndSettle(\\n        address from,\\n        address to,\\n        uint value\\n    ) external returns (bool);\\n\\n    // Restricted: used internally to Elysian\\n    function burn(address account, uint amount) external;\\n\\n    function issue(address account, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IElysian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport \\\"../interfaces/ISynth.sol\\\";\\n\\ninterface IElysian {\\n    // Views\\n    function anySynthOrOKSRateIsStale() external view returns (bool anyRateStale);\\n\\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\\n\\n    function availableSynthCount() external view returns (uint);\\n\\n    function availableSynths(uint index) external view returns (ISynth);\\n\\n    function collateral(address account) external view returns (uint);\\n\\n    function collateralisationRatio(address issuer) external view returns (uint);\\n\\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\\n\\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\\n\\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\\n\\n    function remainingIssuableSynths(address issuer)\\n        external\\n        view\\n        returns (\\n            uint maxIssuable,\\n            uint alreadyIssued,\\n            uint totalSystemDebt\\n        );\\n\\n    function synths(bytes32 currencyKey) external view returns (ISynth);\\n\\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\\n\\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);\\n\\n    function totalSupply() external view returns (uint);\\n    \\n    function totalIssuedSynthsExcludeEtherCollateral(bytes32 currencyKey) external view returns (uint);\\n\\n    function transferableElysian(address account) external view returns (uint transferable);\\n\\n    // Mutative Functions\\n    function burnSynths(uint amount) external;\\n\\n    function burnSynthsOnBehalf(address burnForAddress, uint amount) external;\\n\\n    function burnSynthsToTarget() external;\\n\\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\\n\\n    function exchange(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeOnBehalf(\\n        address exchangeForAddress,\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external returns (uint amountReceived);\\n\\n    function issueMaxSynths() external;\\n\\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\\n\\n    function issueSynths(uint amount) external;\\n\\n    function issueSynthsOnBehalf(address issueForAddress, uint amount) external;\\n\\n    function mint(uint _amount, address _recipient, bool _isEscrowed) external returns (bool);\\n\\n    function burn(uint _amount, address _account) external  returns (bool);\\n\\n    function settle(bytes32 currencyKey)\\n        external\\n        returns (\\n            uint reclaimed,\\n            uint refunded,\\n            uint numEntries\\n        );\\n\\n    function liquidateDelinquentAccount(address account, uint susdAmount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the token name.\\n  */\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n  \\n  /** \\n   * @dev Returns the token decimals.\\n  */\\n  function decimals() external view returns (uint8);\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/contracts/Proxyable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// Inheritance\\nimport \\\"./OwnedwManager.sol\\\";\\n\\n// Internal references\\nimport \\\"./Proxy.sol\\\";\\n\\n// https://docs.synthetix.io/contracts/source/contracts/proxyable\\nabstract contract Proxyable is OwnedwManager {\\n    // This contract should be treated like an abstract contract\\n\\n    /* The proxy this contract exists behind. */\\n    Proxy public proxy;\\n\\n    /* The caller of the proxy, passed through to this contract.\\n     * Note that every function using this member must apply the onlyProxy or\\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\\n    address public messageSender;\\n\\n    constructor(address payable _proxy) {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), \\\"Owner must be set\\\");\\n\\n        proxy = Proxy(_proxy);\\n        emit ProxyUpdated(_proxy);\\n    } \\n\\n    function setProxy(address payable _proxy) external onlyOwner {\\n        proxy = Proxy(_proxy);\\n        emit ProxyUpdated(_proxy);\\n    }\\n\\n    function setMessageSender(address sender) external onlyProxy {\\n        messageSender = sender;\\n    }\\n\\n    modifier onlyProxy {\\n        _onlyProxy();\\n        _;  \\n    }\\n\\n    function _onlyProxy() private view {\\n        require(Proxy(msg.sender) == proxy, \\\"Only the proxy can call\\\");\\n    }\\n\\n    modifier optionalProxy {\\n        _optionalProxy();\\n        _;\\n    }\\n\\n    function _optionalProxy() private {\\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\\n            messageSender = msg.sender;\\n        }\\n    }\\n\\n    modifier optionalProxy_onlyOwner {\\n        _optionalProxy_onlyOwner();\\n        _;\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _optionalProxy_onlyOwner() private {\\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\\n            messageSender = msg.sender;\\n        }\\n        require(messageSender == owner, \\\"Owner only function\\\");\\n    }\\n\\n    event ProxyUpdated(address proxyAddress);\\n}\\n\"\r\n    },\r\n    \"/contracts/ProxyERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n// Inheritance\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\n\\ncontract ProxyERC20 is Proxy, IERC20 {\\n    constructor(address _owner) public Proxy(_owner) {}\\n\\n    // ------------- ERC20 Details ------------- //\\n\\n    function name() public override view returns (string memory) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).name();\\n    }\\n\\n    function symbol() public override view returns (string memory) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).symbol();\\n    }\\n\\n    function decimals() public override view returns (uint8) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).decimals();\\n    }\\n\\n    // ------------- ERC20 Interface ------------- //\\n\\n    /**\\n     * @dev Total number of tokens in existence\\n     */\\n    function totalSupply() public override view returns (uint256) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).totalSupply();\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param account The address to query the balance of.\\n     * @return An uint256 representing the amount owned by the passed address.\\n     */\\n    function balanceOf(address account) public override view returns (uint256) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).balanceOf(account);\\n    }\\n\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param owner address The address which owns the funds.\\n     * @param spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(address owner, address spender) public  override view returns (uint256) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).allowance(owner, spender);\\n    }\\n\\n    /**\\n     * @dev Transfer token for a specified address\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function transfer(address to, uint256 value) public  override returns (bool) {\\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\\n        target.setMessageSender(msg.sender);\\n\\n        // Forward the ERC20 call to the target contract\\n        IERC20(address(target)).transfer(to, value);\\n\\n        // Event emitting will occur via Proxy._emit()\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function approve(address spender, uint256 value) public override returns (bool) {\\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\\n        target.setMessageSender(msg.sender);\\n\\n        // Forward the ERC20 call to the target contract\\n        IERC20(address(target)).approve(spender, value);\\n\\n        // Event emitting will occur via Proxy._emit()\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one address to another\\n     * @param from address The address which you want to send tokens from\\n     * @param to address The address which you want to transfer to\\n     * @param value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) public override returns (bool) {\\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\\n        target.setMessageSender(msg.sender);\\n\\n        // Forward the ERC20 call to the target contract\\n        IERC20(address(target)).transferFrom(from, to, value);\\n\\n        // Event emitting will occur via Proxy._emit()\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// Inheritance\\nimport \\\"./OwnedwManager.sol\\\";\\n\\n// Internal references\\nimport \\\"./Proxyable.sol\\\";\\n\\ncontract Proxy is OwnedwManager {\\n    Proxyable public target;\\n\\n    constructor(address _owner) OwnedwManager(_owner, _owner) {}\\n\\n    function setTarget(Proxyable _target) external onlyOwner {\\n        target = _target;\\n        emit TargetUpdated(_target);\\n    }\\n\\n    function _emit(\\n        bytes calldata callData,\\n        uint numTopics,\\n        bytes32 topic1,\\n        bytes32 topic2,\\n        bytes32 topic3,\\n        bytes32 topic4\\n    ) external onlyTarget {\\n        uint size = callData.length;\\n        bytes memory _callData = callData;\\n\\n        assembly {\\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\\n             * This means moving call_data across 32 bytes guarantees we correctly access\\n             * the data itself. */\\n            switch numTopics\\n                case 0 {\\n                    log0(add(_callData, 32), size)\\n                }\\n                case 1 {\\n                    log1(add(_callData, 32), size, topic1)\\n                }\\n                case 2 {\\n                    log2(add(_callData, 32), size, topic1, topic2)\\n                }\\n                case 3 {\\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\\n                }\\n                case 4 {\\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\\n                }\\n        }\\n    }\\n\\n    // solhint-disable no-complex-fallback\\n    fallback() external payable {\\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\\n        target.setMessageSender(msg.sender);\\n\\n        assembly {\\n            let free_ptr := mload(0x40)\\n            calldatacopy(free_ptr, 0, calldatasize())\\n\\n            /* We must explicitly forward ether to the underlying contract as well. */\\n            let result := call(gas(), sload(target.slot), callvalue(), free_ptr, calldatasize(), 0, 0)\\n            let size := returndatasize()\\n\\n            returndatacopy(free_ptr, 0, size)\\n\\n            if iszero(result) {\\n                revert(free_ptr, size)\\n            }\\n            return(free_ptr, size)\\n        }\\n    }\\n\\n    modifier onlyTarget {\\n        require(Proxyable(msg.sender) == target, \\\"Must be proxy target\\\");\\n        _;\\n    }\\n\\n    event TargetUpdated(Proxyable newTarget);\\n}\\n\"\r\n    },\r\n    \"/contracts/OwnedwManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\ncontract OwnedwManager {\\n    address public owner;\\n    address public manager;\\n\\n    address public nominatedOwner;\\n\\n    constructor(address _owner, address _manager) {\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\n        owner = _owner;\\n        manager = _manager;\\n        emit OwnerChanged(address(0), _owner);\\n        emit ManagerChanged(_manager);\\n    }\\n\\n    function nominateNewOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner, \\\"You must be nominated before you can accept ownership\\\");\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    modifier onlyManager {\\n        _onlyManager();\\n        _;\\n    }\\n    \\n    function _onlyOwner() private view {\\n        require(msg.sender == owner, \\\"Only the contract owner may perform this action\\\");\\n    }\\n\\n    function _onlyManager() private view {\\n        require(msg.sender == manager, \\\"Only the contract owner may perform this action\\\");\\n    }\\n\\n    function setManager(address _manager) external onlyOwner {\\n        manager = _manager;\\n        emit ManagerChanged(_manager);\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n    event ManagerChanged(address newManager);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract Proxyable\",\"name\":\"newTarget\",\"type\":\"address\"}],\"name\":\"TargetUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"numTopics\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"topic1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"topic2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"topic3\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"topic4\",\"type\":\"bytes32\"}],\"name\":\"_emit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEscrowed\",\"type\":\"bool\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Proxyable\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"setTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"internalType\":\"contract Proxyable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ProxyERC20Mintable", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000d02522de79947c76add6d324f27f816b70230e85", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}