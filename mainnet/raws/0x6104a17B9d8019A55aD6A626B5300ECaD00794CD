{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.14;\n\n\n\n// Part: IPhutureIndex\n\ninterface IPhutureIndex{\n    function anatomy() external view returns (address[] memory _assets, uint8[] memory _weights);\n    function vTokenFactory() external view returns(address);\n    function inactiveAnatomy() external view returns (address[] memory);\n    }\n\n// Part: IVToken\n\ninterface IVToken {\n    function virtualTotalAssetSupply() external view returns (uint);\n\n\n}\n\n// Part: IVTokenFactory\n\ninterface IVTokenFactory{\n    function vTokenOf(address) external view returns(address);\n}\n\n// File: indexComponents.sol\n\ncontract IndexComponents {\n\n    struct componentStruct {\n        address assetAddress;\n        uint256 balance;\n    }\n\n\n    function callActiveAndInactiveAnatomy(address index) internal view returns(address[] memory){\n        IPhutureIndex indexContract = IPhutureIndex(index);\n        (address[] memory allAssets,) = indexContract.anatomy();\n        address[] memory inactiveAssets = indexContract.inactiveAnatomy();\n        if (inactiveAssets.length == 0){\n            return allAssets;\n        }\n        else {\n        for(uint i = 0; i < inactiveAssets.length;i++){\n            allAssets[i+allAssets.length] = inactiveAssets[i];\n        }\n            return allAssets;\n        }\n        \n    }\n\n    function getVTokenFactory(address index) internal view returns (address){\n        IPhutureIndex indexContract = IPhutureIndex(index);\n        return indexContract.vTokenFactory();\n    }\n\n    function getVTokenOf(address index, address asset) internal view returns(address){\n        IVTokenFactory vTokenFactory = IVTokenFactory(getVTokenFactory(index));\n        return vTokenFactory.vTokenOf(asset);\n    }\n\n    function getComponents(address index) public view returns(componentStruct[] memory){\n        address[] memory underlyingAssetAddresses = callActiveAndInactiveAnatomy(index);\n        componentStruct[] memory components = new componentStruct[](underlyingAssetAddresses.length);\n        \n        for (uint i=0;i<underlyingAssetAddresses.length;i++){\n            address _vTokenasset = getVTokenOf(index, underlyingAssetAddresses[i]);\n            IVToken _vToken = IVToken(_vTokenasset);\n            uint256 _vTokenBalance = _vToken.virtualTotalAssetSupply();\n            components[i] =  componentStruct({\n                assetAddress:underlyingAssetAddresses[i],\n                balance:_vTokenBalance});  \n        }\n        return components;\n    }\n    }\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"index\",\"type\":\"address\"}],\"name\":\"getComponents\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IndexComponents.componentStruct[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "IndexComponents", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}