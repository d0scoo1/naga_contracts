{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": false\r\n      },\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/persistent/dispatcher/IDispatcher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IDispatcher Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IDispatcher {\\n    function cancelMigration(address _vaultProxy, bool _bypassFailure) external;\\n\\n    function claimOwnership() external;\\n\\n    function deployVaultProxy(\\n        address _vaultLib,\\n        address _owner,\\n        address _vaultAccessor,\\n        string calldata _fundName\\n    ) external returns (address vaultProxy_);\\n\\n    function executeMigration(address _vaultProxy, bool _bypassFailure) external;\\n\\n    function getCurrentFundDeployer() external view returns (address currentFundDeployer_);\\n\\n    function getFundDeployerForVaultProxy(address _vaultProxy)\\n        external\\n        view\\n        returns (address fundDeployer_);\\n\\n    function getMigrationRequestDetailsForVaultProxy(address _vaultProxy)\\n        external\\n        view\\n        returns (\\n            address nextFundDeployer_,\\n            address nextVaultAccessor_,\\n            address nextVaultLib_,\\n            uint256 executableTimestamp_\\n        );\\n\\n    function getMigrationTimelock() external view returns (uint256 migrationTimelock_);\\n\\n    function getNominatedOwner() external view returns (address nominatedOwner_);\\n\\n    function getOwner() external view returns (address owner_);\\n\\n    function getSharesTokenSymbol() external view returns (string memory sharesTokenSymbol_);\\n\\n    function getTimelockRemainingForMigrationRequest(address _vaultProxy)\\n        external\\n        view\\n        returns (uint256 secondsRemaining_);\\n\\n    function hasExecutableMigrationRequest(address _vaultProxy)\\n        external\\n        view\\n        returns (bool hasExecutableRequest_);\\n\\n    function hasMigrationRequest(address _vaultProxy)\\n        external\\n        view\\n        returns (bool hasMigrationRequest_);\\n\\n    function removeNominatedOwner() external;\\n\\n    function setCurrentFundDeployer(address _nextFundDeployer) external;\\n\\n    function setMigrationTimelock(uint256 _nextTimelock) external;\\n\\n    function setNominatedOwner(address _nextNominatedOwner) external;\\n\\n    function setSharesTokenSymbol(string calldata _nextSymbol) external;\\n\\n    function signalMigration(\\n        address _vaultProxy,\\n        address _nextVaultAccessor,\\n        address _nextVaultLib,\\n        bool _bypassFailure\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/external-positions/ExternalPositionFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n    (c) Enzyme Council <council@enzyme.finance>\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../dispatcher/IDispatcher.sol\\\";\\nimport \\\"./ExternalPositionProxy.sol\\\";\\n\\n/// @title ExternalPositionFactory Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A contract factory for External Positions\\ncontract ExternalPositionFactory {\\n    event PositionDeployed(\\n        address indexed vaultProxy,\\n        uint256 indexed typeId,\\n        address indexed constructLib,\\n        bytes constructData\\n    );\\n\\n    event PositionDeployerAdded(address positionDeployer);\\n\\n    event PositionDeployerRemoved(address positionDeployer);\\n\\n    event PositionTypeAdded(uint256 typeId, string label);\\n\\n    event PositionTypeLabelUpdated(uint256 indexed typeId, string label);\\n\\n    address private immutable DISPATCHER;\\n\\n    uint256 private positionTypeCounter;\\n    mapping(uint256 => string) private positionTypeIdToLabel;\\n    mapping(address => bool) private accountToIsExternalPositionProxy;\\n    mapping(address => bool) private accountToIsPositionDeployer;\\n\\n    modifier onlyDispatcherOwner {\\n        require(\\n            msg.sender == IDispatcher(getDispatcher()).getOwner(),\\n            \\\"Only the Dispatcher owner can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(address _dispatcher) public {\\n        DISPATCHER = _dispatcher;\\n    }\\n\\n    /// @notice Creates a new external position proxy and adds it to the list of supported external positions\\n    /// @param _constructData Encoded data to be used on the ExternalPositionProxy constructor\\n    /// @param _vaultProxy The _vaultProxy owner of the external position\\n    /// @param _typeId The type of external position to be created\\n    /// @param _constructLib The external position lib contract that will be used on the constructor\\n    function deploy(\\n        address _vaultProxy,\\n        uint256 _typeId,\\n        address _constructLib,\\n        bytes memory _constructData\\n    ) external returns (address externalPositionProxy_) {\\n        require(\\n            isPositionDeployer(msg.sender),\\n            \\\"deploy: Only a position deployer can call this function\\\"\\n        );\\n\\n        externalPositionProxy_ = address(\\n            new ExternalPositionProxy(_vaultProxy, _typeId, _constructLib, _constructData)\\n        );\\n\\n        accountToIsExternalPositionProxy[externalPositionProxy_] = true;\\n\\n        emit PositionDeployed(_vaultProxy, _typeId, _constructLib, _constructData);\\n\\n        return externalPositionProxy_;\\n    }\\n\\n    ////////////////////\\n    // TYPES REGISTRY //\\n    ////////////////////\\n\\n    /// @notice Adds a set of new position types\\n    /// @param _labels Labels for each new position type\\n    function addNewPositionTypes(string[] calldata _labels) external onlyDispatcherOwner {\\n        for (uint256 i; i < _labels.length; i++) {\\n            uint256 typeId = getPositionTypeCounter();\\n            positionTypeCounter++;\\n\\n            positionTypeIdToLabel[typeId] = _labels[i];\\n\\n            emit PositionTypeAdded(typeId, _labels[i]);\\n        }\\n    }\\n\\n    /// @notice Updates a set of position type labels\\n    /// @param _typeIds The position type ids\\n    /// @param _labels The updated labels\\n    function updatePositionTypeLabels(uint256[] calldata _typeIds, string[] calldata _labels)\\n        external\\n        onlyDispatcherOwner\\n    {\\n        require(_typeIds.length == _labels.length, \\\"updatePositionTypeLabels: Unequal arrays\\\");\\n        for (uint256 i; i < _typeIds.length; i++) {\\n            positionTypeIdToLabel[_typeIds[i]] = _labels[i];\\n\\n            emit PositionTypeLabelUpdated(_typeIds[i], _labels[i]);\\n        }\\n    }\\n\\n    /////////////////////////////////\\n    // POSITION DEPLOYERS REGISTRY //\\n    /////////////////////////////////\\n\\n    /// @notice Adds a set of new position deployers\\n    /// @param _accounts Accounts to be added as position deployers\\n    function addPositionDeployers(address[] memory _accounts) external onlyDispatcherOwner {\\n        for (uint256 i; i < _accounts.length; i++) {\\n            require(\\n                !isPositionDeployer(_accounts[i]),\\n                \\\"addPositionDeployers: Account is already a position deployer\\\"\\n            );\\n\\n            accountToIsPositionDeployer[_accounts[i]] = true;\\n\\n            emit PositionDeployerAdded(_accounts[i]);\\n        }\\n    }\\n\\n    /// @notice Removes a set of existing position deployers\\n    /// @param _accounts Existing position deployers to be removed from their role\\n    function removePositionDeployers(address[] memory _accounts) external onlyDispatcherOwner {\\n        for (uint256 i; i < _accounts.length; i++) {\\n            require(\\n                isPositionDeployer(_accounts[i]),\\n                \\\"removePositionDeployers: Account is not a position deployer\\\"\\n            );\\n\\n            accountToIsPositionDeployer[_accounts[i]] = false;\\n\\n            emit PositionDeployerRemoved(_accounts[i]);\\n        }\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    // EXTERNAL FUNCTIONS\\n\\n    /// @notice Gets the label for a position type\\n    /// @param _typeId The position type id\\n    /// @return label_ The label\\n    function getLabelForPositionType(uint256 _typeId)\\n        external\\n        view\\n        returns (string memory label_)\\n    {\\n        return positionTypeIdToLabel[_typeId];\\n    }\\n\\n    /// @notice Checks if an account is an external position proxy\\n    /// @param _account The account to check\\n    /// @return isExternalPositionProxy_ True if the account is an externalPositionProxy\\n    function isExternalPositionProxy(address _account)\\n        external\\n        view\\n        returns (bool isExternalPositionProxy_)\\n    {\\n        return accountToIsExternalPositionProxy[_account];\\n    }\\n\\n    // PUBLIC FUNCTIONS\\n\\n    /// @notice Gets the `DISPATCHER` variable\\n    /// @return dispatcher_ The `DISPATCHER` variable value\\n    function getDispatcher() public view returns (address dispatcher_) {\\n        return DISPATCHER;\\n    }\\n\\n    /// @notice Gets the `positionTypeCounter` variable\\n    /// @return positionTypeCounter_ The `positionTypeCounter` variable value\\n    function getPositionTypeCounter() public view returns (uint256 positionTypeCounter_) {\\n        return positionTypeCounter;\\n    }\\n\\n    /// @notice Checks if an account is a position deployer\\n    /// @param _account The account to check\\n    /// @return isPositionDeployer_ True if the account is a position deployer\\n    function isPositionDeployer(address _account) public view returns (bool isPositionDeployer_) {\\n        return accountToIsPositionDeployer[_account];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/external-positions/ExternalPositionProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n    (c) Enzyme Council <council@enzyme.finance>\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../vault/interfaces/IExternalPositionVault.sol\\\";\\nimport \\\"./IExternalPosition.sol\\\";\\nimport \\\"./IExternalPositionProxy.sol\\\";\\n\\n/// @title ExternalPositionProxy Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A proxy for all external positions, modified from EIP-1822\\ncontract ExternalPositionProxy is IExternalPositionProxy {\\n    uint256 private immutable EXTERNAL_POSITION_TYPE;\\n    address private immutable VAULT_PROXY;\\n\\n    /// @dev Needed to receive ETH on external positions\\n    receive() external payable {}\\n\\n    constructor(\\n        address _vaultProxy,\\n        uint256 _typeId,\\n        address _constructLib,\\n        bytes memory _constructData\\n    ) public {\\n        VAULT_PROXY = _vaultProxy;\\n        EXTERNAL_POSITION_TYPE = _typeId;\\n\\n        (bool success, bytes memory returnData) = _constructLib.delegatecall(_constructData);\\n\\n        require(success, string(returnData));\\n    }\\n\\n    // solhint-disable-next-line no-complex-fallback\\n    fallback() external payable {\\n        address contractLogic = IExternalPositionVault(getVaultProxy())\\n            .getExternalPositionLibForType(getExternalPositionType());\\n        assembly {\\n            calldatacopy(0x0, 0x0, calldatasize())\\n            let success := delegatecall(\\n                sub(gas(), 10000),\\n                contractLogic,\\n                0x0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            let retSz := returndatasize()\\n            returndatacopy(0, 0, retSz)\\n            switch success\\n                case 0 {\\n                    revert(0, retSz)\\n                }\\n                default {\\n                    return(0, retSz)\\n                }\\n        }\\n    }\\n\\n    /// @notice Delegates call to IExternalPosition.receiveCallFromVault\\n    /// @param _data The bytes data variable to be decoded at the External Position\\n    function receiveCallFromVault(bytes calldata _data) external {\\n        require(\\n            msg.sender == getVaultProxy(),\\n            \\\"receiveCallFromVault: Only the vault can make this call\\\"\\n        );\\n        address contractLogic = IExternalPositionVault(getVaultProxy())\\n            .getExternalPositionLibForType(getExternalPositionType());\\n        (bool success, bytes memory returnData) = contractLogic.delegatecall(\\n            abi.encodeWithSelector(IExternalPosition.receiveCallFromVault.selector, _data)\\n        );\\n\\n        require(success, string(returnData));\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the `EXTERNAL_POSITION_TYPE` variable\\n    /// @return externalPositionType_ The `EXTERNAL_POSITION_TYPE` variable value\\n    function getExternalPositionType()\\n        public\\n        view\\n        override\\n        returns (uint256 externalPositionType_)\\n    {\\n        return EXTERNAL_POSITION_TYPE;\\n    }\\n\\n    /// @notice Gets the `VAULT_PROXY` variable\\n    /// @return vaultProxy_ The `VAULT_PROXY` variable value\\n    function getVaultProxy() public view override returns (address vaultProxy_) {\\n        return VAULT_PROXY;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/external-positions/IExternalPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n    (c) Enzyme Council <council@enzyme.finance>\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IExternalPosition Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IExternalPosition {\\n    function getDebtAssets() external returns (address[] memory, uint256[] memory);\\n\\n    function getManagedAssets() external returns (address[] memory, uint256[] memory);\\n\\n    function init(bytes memory) external;\\n\\n    function receiveCallFromVault(bytes memory) external;\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/external-positions/IExternalPositionProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n    (c) Enzyme Council <council@enzyme.finance>\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IExternalPositionProxy interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice An interface for publicly accessible functions on the ExternalPositionProxy\\ninterface IExternalPositionProxy {\\n    function getExternalPositionType() external view returns (uint256);\\n\\n    function getVaultProxy() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/vault/interfaces/IExternalPositionVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IExternalPositionVault interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// Provides an interface to get the externalPositionLib for a given type from the Vault\\ninterface IExternalPositionVault {\\n    function getExternalPositionLibForType(uint256) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/vault/interfaces/IFreelyTransferableSharesVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IFreelyTransferableSharesVault Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Provides the interface for determining whether a vault's shares\\n/// are guaranteed to be freely transferable.\\n/// @dev DO NOT EDIT CONTRACT\\ninterface IFreelyTransferableSharesVault {\\n    function sharesAreFreelyTransferable()\\n        external\\n        view\\n        returns (bool sharesAreFreelyTransferable_);\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/vault/interfaces/IMigratableVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IMigratableVault Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @dev DO NOT EDIT CONTRACT\\ninterface IMigratableVault {\\n    function canMigrate(address _who) external view returns (bool canMigrate_);\\n\\n    function init(\\n        address _owner,\\n        address _accessor,\\n        string calldata _fundName\\n    ) external;\\n\\n    function setAccessor(address _nextAccessor) external;\\n\\n    function setVaultLib(address _nextVaultLib) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/core/fund-deployer/IFundDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IFundDeployer Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IFundDeployer {\\n    function getOwner() external view returns (address);\\n\\n    function hasReconfigurationRequest(address) external view returns (bool);\\n\\n    function isAllowedBuySharesOnBehalfCaller(address) external view returns (bool);\\n\\n    function isAllowedVaultCall(\\n        address,\\n        bytes4,\\n        bytes32\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/release/core/fund/comptroller/IComptroller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../vault/IVault.sol\\\";\\n\\n/// @title IComptroller Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IComptroller {\\n    function activate(bool) external;\\n\\n    function calcGav() external returns (uint256);\\n\\n    function calcGrossShareValue() external returns (uint256);\\n\\n    function callOnExtension(\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external;\\n\\n    function destructActivated(uint256, uint256) external;\\n\\n    function destructUnactivated() external;\\n\\n    function getDenominationAsset() external view returns (address);\\n\\n    function getExternalPositionManager() external view returns (address);\\n\\n    function getFeeManager() external view returns (address);\\n\\n    function getFundDeployer() external view returns (address);\\n\\n    function getGasRelayPaymaster() external view returns (address);\\n\\n    function getIntegrationManager() external view returns (address);\\n\\n    function getPolicyManager() external view returns (address);\\n\\n    function getVaultProxy() external view returns (address);\\n\\n    function init(address, uint256) external;\\n\\n    function permissionedVaultAction(IVault.VaultAction, bytes calldata) external;\\n\\n    function preTransferSharesHook(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function preTransferSharesHookFreelyTransferable(address) external view;\\n\\n    function setGasRelayPaymaster(address) external;\\n\\n    function setVaultProxy(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/core/fund/vault/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../../../persistent/vault/interfaces/IExternalPositionVault.sol\\\";\\nimport \\\"../../../../persistent/vault/interfaces/IFreelyTransferableSharesVault.sol\\\";\\nimport \\\"../../../../persistent/vault/interfaces/IMigratableVault.sol\\\";\\n\\n/// @title IVault Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IVault is IMigratableVault, IFreelyTransferableSharesVault, IExternalPositionVault {\\n    enum VaultAction {\\n        None,\\n        // Shares management\\n        BurnShares,\\n        MintShares,\\n        TransferShares,\\n        // Asset management\\n        AddTrackedAsset,\\n        ApproveAssetSpender,\\n        RemoveTrackedAsset,\\n        WithdrawAssetTo,\\n        // External position management\\n        AddExternalPosition,\\n        CallOnExternalPosition,\\n        RemoveExternalPosition\\n    }\\n\\n    function addTrackedAsset(address) external;\\n\\n    function burnShares(address, uint256) external;\\n\\n    function buyBackProtocolFeeShares(\\n        uint256,\\n        uint256,\\n        uint256\\n    ) external;\\n\\n    function callOnContract(address, bytes calldata) external returns (bytes memory);\\n\\n    function canManageAssets(address) external view returns (bool);\\n\\n    function canRelayCalls(address) external view returns (bool);\\n\\n    function getAccessor() external view returns (address);\\n\\n    function getOwner() external view returns (address);\\n\\n    function getActiveExternalPositions() external view returns (address[] memory);\\n\\n    function getTrackedAssets() external view returns (address[] memory);\\n\\n    function isActiveExternalPosition(address) external view returns (bool);\\n\\n    function isTrackedAsset(address) external view returns (bool);\\n\\n    function mintShares(address, uint256) external;\\n\\n    function payProtocolFee() external;\\n\\n    function receiveValidatedVaultAction(VaultAction, bytes calldata) external;\\n\\n    function setAccessorForFundReconfiguration(address) external;\\n\\n    function setSymbol(string calldata) external;\\n\\n    function transferShares(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function withdrawAssetTo(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/IExtension.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IExtension Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for all extensions\\ninterface IExtension {\\n    function activateForFund(bool _isMigration) external;\\n\\n    function deactivateForFund() external;\\n\\n    function receiveCallFromComptroller(\\n        address _caller,\\n        uint256 _actionId,\\n        bytes calldata _callArgs\\n    ) external;\\n\\n    function setConfigForFund(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        bytes calldata _configData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/external-position-manager/ExternalPositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n    \\n    (c) Enzyme Council <council@enzyme.finance>\\n    \\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../../persistent/external-positions/ExternalPositionFactory.sol\\\";\\nimport \\\"../../../persistent/external-positions/IExternalPosition.sol\\\";\\nimport \\\"../../../persistent/external-positions/IExternalPositionProxy.sol\\\";\\nimport \\\"../policy-manager/IPolicyManager.sol\\\";\\nimport \\\"../utils/ExtensionBase.sol\\\";\\nimport \\\"../utils/PermissionedVaultActionMixin.sol\\\";\\nimport \\\"./external-positions/IExternalPositionParser.sol\\\";\\nimport \\\"./IExternalPositionManager.sol\\\";\\n\\n/// @title ExternalPositionManager\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Extension to handle external position actions for funds\\ncontract ExternalPositionManager is\\n    IExternalPositionManager,\\n    ExtensionBase,\\n    PermissionedVaultActionMixin\\n{\\n    event CallOnExternalPositionExecutedForFund(\\n        address indexed caller,\\n        address indexed comptrollerProxy,\\n        address indexed externalPosition,\\n        uint256 actionId,\\n        bytes actionArgs,\\n        address[] assetsToTransfer,\\n        uint256[] amountsToTransfer,\\n        address[] assetsToReceive\\n    );\\n\\n    event ExternalPositionDeployedForFund(\\n        address indexed comptrollerProxy,\\n        address indexed vaultProxy,\\n        address externalPosition,\\n        uint256 indexed externalPositionTypeId,\\n        bytes data\\n    );\\n\\n    event ExternalPositionTypeInfoUpdated(uint256 indexed typeId, address lib, address parser);\\n\\n    address private immutable EXTERNAL_POSITION_FACTORY;\\n    address private immutable POLICY_MANAGER;\\n\\n    mapping(uint256 => ExternalPositionTypeInfo) private typeIdToTypeInfo;\\n\\n    constructor(\\n        address _fundDeployer,\\n        address _externalPositionFactory,\\n        address _policyManager\\n    ) public ExtensionBase(_fundDeployer) {\\n        EXTERNAL_POSITION_FACTORY = _externalPositionFactory;\\n        POLICY_MANAGER = _policyManager;\\n    }\\n\\n    /////////////\\n    // GENERAL //\\n    /////////////\\n\\n    /// @notice Enables the ExternalPositionManager to be used by a fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _vaultProxy The VaultProxy of the fund\\n    function setConfigForFund(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        bytes calldata\\n    ) external override onlyFundDeployer {\\n        __setValidatedVaultProxy(_comptrollerProxy, _vaultProxy);\\n    }\\n\\n    ///////////////////////////////\\n    // CALL-ON-EXTENSION ACTIONS //\\n    ///////////////////////////////\\n\\n    /// @notice Receives a dispatched `callOnExtension` from a fund's ComptrollerProxy\\n    /// @param _caller The user who called for this action\\n    /// @param _actionId An ID representing the desired action\\n    /// @param _callArgs The encoded args for the action\\n    function receiveCallFromComptroller(\\n        address _caller,\\n        uint256 _actionId,\\n        bytes calldata _callArgs\\n    ) external override {\\n        address comptrollerProxy = msg.sender;\\n\\n        // This validation comes at negligible cost but is not strictly necessary,\\n        // as all actions below call permissioned actions on the VaultProxy,\\n        // which will fail for an invalid ComptrollerProxy\\n        address vaultProxy = getVaultProxyForFund(comptrollerProxy);\\n        require(vaultProxy != address(0), \\\"receiveCallFromComptroller: Fund is not valid\\\");\\n\\n        require(\\n            IVault(vaultProxy).canManageAssets(_caller),\\n            \\\"receiveCallFromComptroller: Unauthorized\\\"\\n        );\\n\\n        // Dispatch the action\\n        if (_actionId == uint256(ExternalPositionManagerActions.CreateExternalPosition)) {\\n            __createExternalPosition(_caller, comptrollerProxy, vaultProxy, _callArgs);\\n        } else if (_actionId == uint256(ExternalPositionManagerActions.CallOnExternalPosition)) {\\n            (\\n                address externalPosition,\\n                uint256 actionId,\\n                bytes memory actionArgs\\n            ) = __decodeCallOnExternalPositionCallArgs(_callArgs);\\n            __executeCallOnExternalPosition(\\n                _caller,\\n                comptrollerProxy,\\n                externalPosition,\\n                actionId,\\n                actionArgs\\n            );\\n        } else if (_actionId == uint256(ExternalPositionManagerActions.RemoveExternalPosition)) {\\n            __executeRemoveExternalPosition(_caller, comptrollerProxy, _callArgs);\\n        } else if (\\n            _actionId == uint256(ExternalPositionManagerActions.ReactivateExternalPosition)\\n        ) {\\n            __reactivateExternalPosition(_caller, comptrollerProxy, vaultProxy, _callArgs);\\n        } else {\\n            revert(\\\"receiveCallFromComptroller: Invalid _actionId\\\");\\n        }\\n    }\\n\\n    // PRIVATE FUNCTIONS\\n\\n    /// @dev Creates a new external position and links it to the _vaultProxy\\n    function __createExternalPosition(\\n        address _caller,\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        bytes memory _callArgs\\n    ) private {\\n        (\\n            uint256 typeId,\\n            bytes memory initializationData,\\n            bytes memory callOnExternalPositionCallArgs\\n        ) = abi.decode(_callArgs, (uint256, bytes, bytes));\\n\\n        address parser = getExternalPositionParserForType(typeId);\\n        require(parser != address(0), \\\"__createExternalPosition: Invalid typeId\\\");\\n\\n        IPolicyManager(getPolicyManager()).validatePolicies(\\n            _comptrollerProxy,\\n            IPolicyManager.PolicyHook.CreateExternalPosition,\\n            abi.encode(_caller, typeId, initializationData)\\n        );\\n\\n        // Pass in _vaultProxy in case the external position requires it during init() or further operations\\n        bytes memory initArgs = IExternalPositionParser(parser).parseInitArgs(\\n            _vaultProxy,\\n            initializationData\\n        );\\n\\n        bytes memory constructData = abi.encodeWithSelector(\\n            IExternalPosition.init.selector,\\n            initArgs\\n        );\\n\\n        address externalPosition = ExternalPositionFactory(EXTERNAL_POSITION_FACTORY).deploy(\\n            _vaultProxy,\\n            typeId,\\n            getExternalPositionLibForType(typeId),\\n            constructData\\n        );\\n\\n        emit ExternalPositionDeployedForFund(\\n            _comptrollerProxy,\\n            _vaultProxy,\\n            externalPosition,\\n            typeId,\\n            initArgs\\n        );\\n\\n        __addExternalPosition(_comptrollerProxy, externalPosition);\\n\\n        // Execute a first action on the external position\\n        if (callOnExternalPositionCallArgs.length != 0) {\\n            // Ignores user-input externalPosition value\\n            (, uint256 actionId, bytes memory actionArgs) = __decodeCallOnExternalPositionCallArgs(\\n                callOnExternalPositionCallArgs\\n            );\\n            __executeCallOnExternalPosition(\\n                _caller,\\n                _comptrollerProxy,\\n                externalPosition,\\n                actionId,\\n                actionArgs\\n            );\\n        }\\n    }\\n\\n    /// @dev Helper to decode callOnExternalPosition args\\n    function __decodeCallOnExternalPositionCallArgs(bytes memory _callArgs)\\n        private\\n        pure\\n        returns (\\n            address externalPosition_,\\n            uint256 actionId_,\\n            bytes memory actionArgs_\\n        )\\n    {\\n        return abi.decode(_callArgs, (address, uint256, bytes));\\n    }\\n\\n    /// @dev Performs an action on a specific external position\\n    function __executeCallOnExternalPosition(\\n        address _caller,\\n        address _comptrollerProxy,\\n        address _externalPosition,\\n        uint256 _actionId,\\n        bytes memory _actionArgs\\n    ) private {\\n        address parser = getExternalPositionParserForType(\\n            IExternalPositionProxy(_externalPosition).getExternalPositionType()\\n        );\\n\\n        (\\n            address[] memory assetsToTransfer,\\n            uint256[] memory amountsToTransfer,\\n            address[] memory assetsToReceive\\n        ) = IExternalPositionParser(parser).parseAssetsForAction(\\n            _externalPosition,\\n            _actionId,\\n            _actionArgs\\n        );\\n\\n        bytes memory encodedActionData = abi.encode(_actionId, _actionArgs);\\n\\n        __callOnExternalPosition(\\n            _comptrollerProxy,\\n            abi.encode(\\n                _externalPosition,\\n                encodedActionData,\\n                assetsToTransfer,\\n                amountsToTransfer,\\n                assetsToReceive\\n            )\\n        );\\n\\n        IPolicyManager(getPolicyManager()).validatePolicies(\\n            _comptrollerProxy,\\n            IPolicyManager.PolicyHook.PostCallOnExternalPosition,\\n            abi.encode(\\n                _caller,\\n                _externalPosition,\\n                assetsToTransfer,\\n                amountsToTransfer,\\n                assetsToReceive,\\n                encodedActionData\\n            )\\n        );\\n\\n        emit CallOnExternalPositionExecutedForFund(\\n            _caller,\\n            _comptrollerProxy,\\n            _externalPosition,\\n            _actionId,\\n            _actionArgs,\\n            assetsToTransfer,\\n            amountsToTransfer,\\n            assetsToReceive\\n        );\\n    }\\n\\n    /// @dev Removes an external position from the VaultProxy\\n    function __executeRemoveExternalPosition(\\n        address _caller,\\n        address _comptrollerProxy,\\n        bytes memory _callArgs\\n    ) private {\\n        address externalPosition = abi.decode(_callArgs, (address));\\n\\n        IPolicyManager(getPolicyManager()).validatePolicies(\\n            _comptrollerProxy,\\n            IPolicyManager.PolicyHook.RemoveExternalPosition,\\n            abi.encode(_caller, externalPosition)\\n        );\\n\\n        __removeExternalPosition(_comptrollerProxy, externalPosition);\\n    }\\n\\n    ///@dev Reactivates an existing externalPosition\\n    function __reactivateExternalPosition(\\n        address _caller,\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        bytes memory _callArgs\\n    ) private {\\n        address externalPosition = abi.decode(_callArgs, (address));\\n\\n        require(\\n            ExternalPositionFactory(getExternalPositionFactory()).isExternalPositionProxy(\\n                externalPosition\\n            ),\\n            \\\"__reactivateExternalPosition: Account provided is not a valid external position\\\"\\n        );\\n\\n        require(\\n            IExternalPositionProxy(externalPosition).getVaultProxy() == _vaultProxy,\\n            \\\"__reactivateExternalPosition: External position belongs to a different vault\\\"\\n        );\\n\\n        IPolicyManager(getPolicyManager()).validatePolicies(\\n            _comptrollerProxy,\\n            IPolicyManager.PolicyHook.ReactivateExternalPosition,\\n            abi.encode(_caller, externalPosition)\\n        );\\n\\n        __addExternalPosition(_comptrollerProxy, externalPosition);\\n    }\\n\\n    ///////////////////////////////////////////\\n    // EXTERNAL POSITION TYPES INFO REGISTRY //\\n    ///////////////////////////////////////////\\n\\n    /// @notice Updates the libs and parsers for a set of external position type ids\\n    /// @param _typeIds The external position type ids for which to set the libs and parsers\\n    /// @param _libs The libs\\n    /// @param _parsers The parsers\\n    function updateExternalPositionTypesInfo(\\n        uint256[] memory _typeIds,\\n        address[] memory _libs,\\n        address[] memory _parsers\\n    ) external onlyFundDeployerOwner {\\n        require(\\n            _typeIds.length == _parsers.length && _libs.length == _parsers.length,\\n            \\\"updateExternalPositionTypesInfo: Unequal arrays\\\"\\n        );\\n\\n        for (uint256 i; i < _typeIds.length; i++) {\\n            require(\\n                _typeIds[i] <\\n                    ExternalPositionFactory(getExternalPositionFactory()).getPositionTypeCounter(),\\n                \\\"updateExternalPositionTypesInfo: Type does not exist\\\"\\n            );\\n\\n            typeIdToTypeInfo[_typeIds[i]] = ExternalPositionTypeInfo({\\n                lib: _libs[i],\\n                parser: _parsers[i]\\n            });\\n\\n            emit ExternalPositionTypeInfoUpdated(_typeIds[i], _libs[i], _parsers[i]);\\n        }\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the `EXTERNAL_POSITION_FACTORY` variable\\n    /// @return externalPositionFactory_ The `EXTERNAL_POSITION_FACTORY` variable value\\n    function getExternalPositionFactory() public view returns (address externalPositionFactory_) {\\n        return EXTERNAL_POSITION_FACTORY;\\n    }\\n\\n    /// @notice Gets the external position library contract for a given type\\n    /// @param _typeId The type for which to get the external position library\\n    /// @return lib_ The external position library\\n    function getExternalPositionLibForType(uint256 _typeId)\\n        public\\n        view\\n        override\\n        returns (address lib_)\\n    {\\n        return typeIdToTypeInfo[_typeId].lib;\\n    }\\n\\n    /// @notice Gets the external position parser contract for a given type\\n    /// @param _typeId The type for which to get the external position's parser\\n    /// @return parser_ The external position parser\\n    function getExternalPositionParserForType(uint256 _typeId)\\n        public\\n        view\\n        returns (address parser_)\\n    {\\n        return typeIdToTypeInfo[_typeId].parser;\\n    }\\n\\n    /// @notice Gets the `POLICY_MANAGER` variable\\n    /// @return policyManager_ The `POLICY_MANAGER` variable value\\n    function getPolicyManager() public view returns (address policyManager_) {\\n        return POLICY_MANAGER;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/external-position-manager/IExternalPositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IExternalPositionManager interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for the ExternalPositionManager\\ninterface IExternalPositionManager {\\n    struct ExternalPositionTypeInfo {\\n        address parser;\\n        address lib;\\n    }\\n    enum ExternalPositionManagerActions {\\n        CreateExternalPosition,\\n        CallOnExternalPosition,\\n        RemoveExternalPosition,\\n        ReactivateExternalPosition\\n    }\\n\\n    function getExternalPositionLibForType(uint256) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/external-position-manager/external-positions/IExternalPositionParser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IExternalPositionParser Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for all external position parsers\\ninterface IExternalPositionParser {\\n    function parseAssetsForAction(\\n        address _externalPosition,\\n        uint256 _actionId,\\n        bytes memory _encodedActionArgs\\n    )\\n        external\\n        returns (\\n            address[] memory assetsToTransfer_,\\n            uint256[] memory amountsToTransfer_,\\n            address[] memory assetsToReceive_\\n        );\\n\\n    function parseInitArgs(address _vaultProxy, bytes memory _initializationData)\\n        external\\n        returns (bytes memory initArgs_);\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/policy-manager/IPolicyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/// @title PolicyManager Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for the PolicyManager\\ninterface IPolicyManager {\\n    // When updating PolicyHook, also update these functions in PolicyManager:\\n    // 1. __getAllPolicyHooks()\\n    // 2. __policyHookRestrictsCurrentInvestorActions()\\n    enum PolicyHook {\\n        PostBuyShares,\\n        PostCallOnIntegration,\\n        PreTransferShares,\\n        RedeemSharesForSpecificAssets,\\n        AddTrackedAssets,\\n        RemoveTrackedAssets,\\n        CreateExternalPosition,\\n        PostCallOnExternalPosition,\\n        RemoveExternalPosition,\\n        ReactivateExternalPosition\\n    }\\n\\n    function validatePolicies(\\n        address,\\n        PolicyHook,\\n        bytes calldata\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/utils/ExtensionBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../utils/FundDeployerOwnerMixin.sol\\\";\\nimport \\\"../IExtension.sol\\\";\\n\\n/// @title ExtensionBase Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Base class for an extension\\nabstract contract ExtensionBase is IExtension, FundDeployerOwnerMixin {\\n    event ValidatedVaultProxySetForFund(\\n        address indexed comptrollerProxy,\\n        address indexed vaultProxy\\n    );\\n\\n    mapping(address => address) internal comptrollerProxyToVaultProxy;\\n\\n    modifier onlyFundDeployer() {\\n        require(msg.sender == getFundDeployer(), \\\"Only the FundDeployer can make this call\\\");\\n        _;\\n    }\\n\\n    constructor(address _fundDeployer) public FundDeployerOwnerMixin(_fundDeployer) {}\\n\\n    /// @notice Allows extension to run logic during fund activation\\n    /// @dev Unimplemented by default, may be overridden.\\n    function activateForFund(bool) external virtual override {\\n        return;\\n    }\\n\\n    /// @notice Allows extension to run logic during fund deactivation (destruct)\\n    /// @dev Unimplemented by default, may be overridden.\\n    function deactivateForFund() external virtual override {\\n        return;\\n    }\\n\\n    /// @notice Receives calls from ComptrollerLib.callOnExtension()\\n    /// and dispatches the appropriate action\\n    /// @dev Unimplemented by default, may be overridden.\\n    function receiveCallFromComptroller(\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual override {\\n        revert(\\\"receiveCallFromComptroller: Unimplemented for Extension\\\");\\n    }\\n\\n    /// @notice Allows extension to run logic during fund configuration\\n    /// @dev Unimplemented by default, may be overridden.\\n    function setConfigForFund(\\n        address,\\n        address,\\n        bytes calldata\\n    ) external virtual override {\\n        return;\\n    }\\n\\n    /// @dev Helper to store the validated ComptrollerProxy-VaultProxy relation\\n    function __setValidatedVaultProxy(address _comptrollerProxy, address _vaultProxy) internal {\\n        comptrollerProxyToVaultProxy[_comptrollerProxy] = _vaultProxy;\\n\\n        emit ValidatedVaultProxySetForFund(_comptrollerProxy, _vaultProxy);\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the verified VaultProxy for a given ComptrollerProxy\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @return vaultProxy_ The VaultProxy of the fund\\n    function getVaultProxyForFund(address _comptrollerProxy)\\n        public\\n        view\\n        returns (address vaultProxy_)\\n    {\\n        return comptrollerProxyToVaultProxy[_comptrollerProxy];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/utils/PermissionedVaultActionMixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../core/fund/comptroller/IComptroller.sol\\\";\\nimport \\\"../../core/fund/vault/IVault.sol\\\";\\n\\n/// @title PermissionedVaultActionMixin Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A mixin contract for extensions that can make permissioned vault calls\\nabstract contract PermissionedVaultActionMixin {\\n    /// @notice Adds an external position to active external positions\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _externalPosition The external position to be added\\n    function __addExternalPosition(address _comptrollerProxy, address _externalPosition) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.AddExternalPosition,\\n            abi.encode(_externalPosition)\\n        );\\n    }\\n\\n    /// @notice Adds a tracked asset\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _asset The asset to add\\n    function __addTrackedAsset(address _comptrollerProxy, address _asset) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.AddTrackedAsset,\\n            abi.encode(_asset)\\n        );\\n    }\\n\\n    /// @notice Grants an allowance to a spender to use a fund's asset\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _asset The asset for which to grant an allowance\\n    /// @param _target The spender of the allowance\\n    /// @param _amount The amount of the allowance\\n    function __approveAssetSpender(\\n        address _comptrollerProxy,\\n        address _asset,\\n        address _target,\\n        uint256 _amount\\n    ) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.ApproveAssetSpender,\\n            abi.encode(_asset, _target, _amount)\\n        );\\n    }\\n\\n    /// @notice Burns fund shares for a particular account\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _target The account for which to burn shares\\n    /// @param _amount The amount of shares to burn\\n    function __burnShares(\\n        address _comptrollerProxy,\\n        address _target,\\n        uint256 _amount\\n    ) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.BurnShares,\\n            abi.encode(_target, _amount)\\n        );\\n    }\\n\\n    /// @notice Executes a callOnExternalPosition\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _data The encoded data for the call\\n    function __callOnExternalPosition(address _comptrollerProxy, bytes memory _data) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.CallOnExternalPosition,\\n            _data\\n        );\\n    }\\n\\n    /// @notice Mints fund shares to a particular account\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _target The account to which to mint shares\\n    /// @param _amount The amount of shares to mint\\n    function __mintShares(\\n        address _comptrollerProxy,\\n        address _target,\\n        uint256 _amount\\n    ) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.MintShares,\\n            abi.encode(_target, _amount)\\n        );\\n    }\\n\\n    /// @notice Removes an external position from the vaultProxy\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _externalPosition The ExternalPosition to remove\\n    function __removeExternalPosition(address _comptrollerProxy, address _externalPosition)\\n        internal\\n    {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.RemoveExternalPosition,\\n            abi.encode(_externalPosition)\\n        );\\n    }\\n\\n    /// @notice Removes a tracked asset\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _asset The asset to remove\\n    function __removeTrackedAsset(address _comptrollerProxy, address _asset) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.RemoveTrackedAsset,\\n            abi.encode(_asset)\\n        );\\n    }\\n\\n    /// @notice Transfers fund shares from one account to another\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _from The account from which to transfer shares\\n    /// @param _to The account to which to transfer shares\\n    /// @param _amount The amount of shares to transfer\\n    function __transferShares(\\n        address _comptrollerProxy,\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.TransferShares,\\n            abi.encode(_from, _to, _amount)\\n        );\\n    }\\n\\n    /// @notice Withdraws an asset from the VaultProxy to a given account\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _asset The asset to withdraw\\n    /// @param _target The account to which to withdraw the asset\\n    /// @param _amount The amount of asset to withdraw\\n    function __withdrawAssetTo(\\n        address _comptrollerProxy,\\n        address _asset,\\n        address _target,\\n        uint256 _amount\\n    ) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.WithdrawAssetTo,\\n            abi.encode(_asset, _target, _amount)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/utils/FundDeployerOwnerMixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../core/fund-deployer/IFundDeployer.sol\\\";\\n\\n/// @title FundDeployerOwnerMixin Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A mixin contract that defers ownership to the owner of FundDeployer\\nabstract contract FundDeployerOwnerMixin {\\n    address internal immutable FUND_DEPLOYER;\\n\\n    modifier onlyFundDeployerOwner() {\\n        require(\\n            msg.sender == getOwner(),\\n            \\\"onlyFundDeployerOwner: Only the FundDeployer owner can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(address _fundDeployer) public {\\n        FUND_DEPLOYER = _fundDeployer;\\n    }\\n\\n    /// @notice Gets the owner of this contract\\n    /// @return owner_ The owner\\n    /// @dev Ownership is deferred to the owner of the FundDeployer contract\\n    function getOwner() public view returns (address owner_) {\\n        return IFundDeployer(FUND_DEPLOYER).getOwner();\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the `FUND_DEPLOYER` variable\\n    /// @return fundDeployer_ The `FUND_DEPLOYER` variable value\\n    function getFundDeployer() public view returns (address fundDeployer_) {\\n        return FUND_DEPLOYER;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fundDeployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_externalPositionFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_policyManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"externalPosition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"actionArgs\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"assetsToTransfer\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amountsToTransfer\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"assetsToReceive\",\"type\":\"address[]\"}],\"name\":\"CallOnExternalPositionExecutedForFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vaultProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"externalPosition\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"externalPositionTypeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ExternalPositionDeployedForFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"typeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lib\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parser\",\"type\":\"address\"}],\"name\":\"ExternalPositionTypeInfoUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vaultProxy\",\"type\":\"address\"}],\"name\":\"ValidatedVaultProxySetForFund\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"activateForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deactivateForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExternalPositionFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"externalPositionFactory_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_typeId\",\"type\":\"uint256\"}],\"name\":\"getExternalPositionLibForType\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"lib_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_typeId\",\"type\":\"uint256\"}],\"name\":\"getExternalPositionParserForType\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"parser_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFundDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fundDeployer_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPolicyManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"policyManager_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"}],\"name\":\"getVaultProxyForFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vaultProxy_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_actionId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_callArgs\",\"type\":\"bytes\"}],\"name\":\"receiveCallFromComptroller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"setConfigForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_typeIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_libs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_parsers\",\"type\":\"address[]\"}],\"name\":\"updateExternalPositionTypesInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ExternalPositionManager", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000004f1c53f096533c04d8157efb6bca3eb22ddc63600000000000000000000000000aacb782205dde9eff4862ace9849dce1ca3409f000000000000000000000000adf5a8db090627b153ef0c5726ccfdc1c7aed7bd", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}