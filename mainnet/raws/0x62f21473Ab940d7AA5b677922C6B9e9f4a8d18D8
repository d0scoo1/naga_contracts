{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"AdditionalMath.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n\\nimport \\\"SafeMath.sol\\\";\\n\\n\\n/**\\n* @notice Additional math operations\\n*/\\nlibrary AdditionalMath {\\n    using SafeMath for uint256;\\n\\n    function max16(uint16 a, uint16 b) internal pure returns (uint16) {\\n        return a \\u003e= b ? a : b;\\n    }\\n\\n    function min16(uint16 a, uint16 b) internal pure returns (uint16) {\\n        return a \\u003c b ? a : b;\\n    }\\n\\n    /**\\n    * @notice Division and ceil\\n    */\\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return (a.add(b) - 1) / b;\\n    }\\n\\n    /**\\n    * @dev Adds signed value to unsigned value, throws on overflow.\\n    */\\n    function addSigned(uint256 a, int256 b) internal pure returns (uint256) {\\n        if (b \\u003e= 0) {\\n            return a.add(uint256(b));\\n        } else {\\n            return a.sub(uint256(-b));\\n        }\\n    }\\n\\n    /**\\n    * @dev Subtracts signed value from unsigned value, throws on overflow.\\n    */\\n    function subSigned(uint256 a, int256 b) internal pure returns (uint256) {\\n        if (b \\u003e= 0) {\\n            return a.sub(uint256(b));\\n        } else {\\n            return a.add(uint256(-b));\\n        }\\n    }\\n\\n    /**\\n    * @dev Multiplies two numbers, throws on overflow.\\n    */\\n    function mul32(uint32 a, uint32 b) internal pure returns (uint32) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint32 c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, throws on overflow.\\n    */\\n    function add16(uint16 a, uint16 b) internal pure returns (uint16) {\\n        uint16 c = a + b;\\n        assert(c \\u003e= a);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub16(uint16 a, uint16 b) internal pure returns (uint16) {\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n\\n    /**\\n    * @dev Adds signed value to unsigned value, throws on overflow.\\n    */\\n    function addSigned16(uint16 a, int16 b) internal pure returns (uint16) {\\n        if (b \\u003e= 0) {\\n            return add16(a, uint16(b));\\n        } else {\\n            return sub16(a, uint16(-b));\\n        }\\n    }\\n\\n    /**\\n    * @dev Subtracts signed value from unsigned value, throws on overflow.\\n    */\\n    function subSigned16(uint16 a, int16 b) internal pure returns (uint16) {\\n        if (b \\u003e= 0) {\\n            return sub16(a, uint16(b));\\n        } else {\\n            return add16(a, uint16(-b));\\n        }\\n    }\\n}\\n\"},\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn\\u0027t, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"Adjudicator.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"ReEncryptionValidator.sol\\\";\\nimport \\\"SignatureVerifier.sol\\\";\\nimport \\\"IStakingEscrow.sol\\\";\\nimport \\\"Upgradeable.sol\\\";\\nimport \\\"SafeMath.sol\\\";\\nimport \\\"Math.sol\\\";\\n\\n\\n/**\\n* @title Adjudicator\\n* @notice Supervises stakers\\u0027 behavior and punishes when something\\u0027s wrong.\\n* @dev |v2.1.2|\\n*/\\ncontract Adjudicator is Upgradeable {\\n\\n    using SafeMath for uint256;\\n    using UmbralDeserializer for bytes;\\n\\n    event CFragEvaluated(\\n        bytes32 indexed evaluationHash,\\n        address indexed investigator,\\n        bool correctness\\n    );\\n    event IncorrectCFragVerdict(\\n        bytes32 indexed evaluationHash,\\n        address indexed worker,\\n        address indexed staker\\n    );\\n\\n    // used only for upgrading\\n    bytes32 constant RESERVED_CAPSULE_AND_CFRAG_BYTES = bytes32(0);\\n    address constant RESERVED_ADDRESS = address(0);\\n\\n    IStakingEscrow public immutable escrow;\\n    SignatureVerifier.HashAlgorithm public immutable hashAlgorithm;\\n    uint256 public immutable basePenalty;\\n    uint256 public immutable penaltyHistoryCoefficient;\\n    uint256 public immutable percentagePenaltyCoefficient;\\n    uint256 public immutable rewardCoefficient;\\n\\n    mapping (address =\\u003e uint256) public penaltyHistory;\\n    mapping (bytes32 =\\u003e bool) public evaluatedCFrags;\\n\\n    /**\\n    * @param _escrow Escrow contract\\n    * @param _hashAlgorithm Hashing algorithm\\n    * @param _basePenalty Base for the penalty calculation\\n    * @param _penaltyHistoryCoefficient Coefficient for calculating the penalty depending on the history\\n    * @param _percentagePenaltyCoefficient Coefficient for calculating the percentage penalty\\n    * @param _rewardCoefficient Coefficient for calculating the reward\\n    */\\n    constructor(\\n        IStakingEscrow _escrow,\\n        SignatureVerifier.HashAlgorithm _hashAlgorithm,\\n        uint256 _basePenalty,\\n        uint256 _penaltyHistoryCoefficient,\\n        uint256 _percentagePenaltyCoefficient,\\n        uint256 _rewardCoefficient\\n    ) {\\n        // Sanity checks.\\n        require(_escrow.secondsPerPeriod() \\u003e 0 \\u0026\\u0026  // This contract has an escrow, and it\\u0027s not the null address.\\n            // The reward and penalty coefficients are set.\\n            _percentagePenaltyCoefficient != 0 \\u0026\\u0026\\n            _rewardCoefficient != 0);\\n        escrow = _escrow;\\n        hashAlgorithm = _hashAlgorithm;\\n        basePenalty = _basePenalty;\\n        percentagePenaltyCoefficient = _percentagePenaltyCoefficient;\\n        penaltyHistoryCoefficient = _penaltyHistoryCoefficient;\\n        rewardCoefficient = _rewardCoefficient;\\n    }\\n\\n    /**\\n    * @notice Submit proof that a worker created wrong CFrag\\n    * @param _capsuleBytes Serialized capsule\\n    * @param _cFragBytes Serialized CFrag\\n    * @param _cFragSignature Signature of CFrag by worker\\n    * @param _taskSignature Signature of task specification by Bob\\n    * @param _requesterPublicKey Bob\\u0027s signing public key, also known as \\\"stamp\\\"\\n    * @param _workerPublicKey Worker\\u0027s signing public key, also known as \\\"stamp\\\"\\n    * @param _workerIdentityEvidence Signature of worker\\u0027s public key by worker\\u0027s eth-key\\n    * @param _preComputedData Additional pre-computed data for CFrag correctness verification\\n    */\\n    function evaluateCFrag(\\n        bytes memory _capsuleBytes,\\n        bytes memory _cFragBytes,\\n        bytes memory _cFragSignature,\\n        bytes memory _taskSignature,\\n        bytes memory _requesterPublicKey,\\n        bytes memory _workerPublicKey,\\n        bytes memory _workerIdentityEvidence,\\n        bytes memory _preComputedData\\n    )\\n        public\\n    {\\n        // 1. Check that CFrag is not evaluated yet\\n        bytes32 evaluationHash = SignatureVerifier.hash(\\n            abi.encodePacked(_capsuleBytes, _cFragBytes), hashAlgorithm);\\n        require(!evaluatedCFrags[evaluationHash], \\\"This CFrag has already been evaluated.\\\");\\n        evaluatedCFrags[evaluationHash] = true;\\n\\n        // 2. Verify correctness of re-encryption\\n        bool cFragIsCorrect = ReEncryptionValidator.validateCFrag(_capsuleBytes, _cFragBytes, _preComputedData);\\n        emit CFragEvaluated(evaluationHash, msg.sender, cFragIsCorrect);\\n\\n        // 3. Verify associated public keys and signatures\\n        require(ReEncryptionValidator.checkSerializedCoordinates(_workerPublicKey),\\n                \\\"Staker\\u0027s public key is invalid\\\");\\n        require(ReEncryptionValidator.checkSerializedCoordinates(_requesterPublicKey),\\n                \\\"Requester\\u0027s public key is invalid\\\");\\n\\n        UmbralDeserializer.PreComputedData memory precomp = _preComputedData.toPreComputedData();\\n\\n        // Verify worker\\u0027s signature of CFrag\\n        require(SignatureVerifier.verify(\\n                _cFragBytes,\\n                abi.encodePacked(_cFragSignature, precomp.lostBytes[1]),\\n                _workerPublicKey,\\n                hashAlgorithm),\\n                \\\"CFrag signature is invalid\\\"\\n        );\\n\\n        // Verify worker\\u0027s signature of taskSignature and that it corresponds to cfrag.proof.metadata\\n        UmbralDeserializer.CapsuleFrag memory cFrag = _cFragBytes.toCapsuleFrag();\\n        require(SignatureVerifier.verify(\\n                _taskSignature,\\n                abi.encodePacked(cFrag.proof.metadata, precomp.lostBytes[2]),\\n                _workerPublicKey,\\n                hashAlgorithm),\\n                \\\"Task signature is invalid\\\"\\n        );\\n\\n        // Verify that _taskSignature is bob\\u0027s signature of the task specification.\\n        // A task specification is: capsule + ursula pubkey + alice address + blockhash\\n        bytes32 stampXCoord;\\n        assembly {\\n            stampXCoord := mload(add(_workerPublicKey, 32))\\n        }\\n        bytes memory stamp = abi.encodePacked(precomp.lostBytes[4], stampXCoord);\\n\\n        require(SignatureVerifier.verify(\\n                abi.encodePacked(_capsuleBytes,\\n                                 stamp,\\n                                 _workerIdentityEvidence,\\n                                 precomp.alicesKeyAsAddress,\\n                                 bytes32(0)),\\n                abi.encodePacked(_taskSignature, precomp.lostBytes[3]),\\n                _requesterPublicKey,\\n                hashAlgorithm),\\n                \\\"Specification signature is invalid\\\"\\n        );\\n\\n        // 4. Extract worker address from stamp signature.\\n        address worker = SignatureVerifier.recover(\\n            SignatureVerifier.hashEIP191(stamp, bytes1(0x45)), // Currently, we use version E (0x45) of EIP191 signatures\\n            _workerIdentityEvidence);\\n        address staker = escrow.stakerFromWorker(worker);\\n        require(staker != address(0), \\\"Worker must be related to a staker\\\");\\n\\n        // 5. Check that staker can be slashed\\n        uint256 stakerValue = escrow.getAllTokens(staker);\\n        require(stakerValue \\u003e 0, \\\"Staker has no tokens\\\");\\n\\n        // 6. If CFrag was incorrect, slash staker\\n        if (!cFragIsCorrect) {\\n            (uint256 penalty, uint256 reward) = calculatePenaltyAndReward(staker, stakerValue);\\n            escrow.slashStaker(staker, penalty, msg.sender, reward);\\n            emit IncorrectCFragVerdict(evaluationHash, worker, staker);\\n        }\\n    }\\n\\n    /**\\n    * @notice Calculate penalty to the staker and reward to the investigator\\n    * @param _staker Staker\\u0027s address\\n    * @param _stakerValue Amount of tokens that belong to the staker\\n    */\\n    function calculatePenaltyAndReward(address _staker, uint256 _stakerValue)\\n        internal returns (uint256 penalty, uint256 reward)\\n    {\\n        penalty = basePenalty.add(penaltyHistoryCoefficient.mul(penaltyHistory[_staker]));\\n        penalty = Math.min(penalty, _stakerValue.div(percentagePenaltyCoefficient));\\n        reward = penalty.div(rewardCoefficient);\\n        // TODO add maximum condition or other overflow protection or other penalty condition (#305?)\\n        penaltyHistory[_staker] = penaltyHistory[_staker].add(1);\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`\\n    function verifyState(address _testTarget) public override virtual {\\n        super.verifyState(_testTarget);\\n        bytes32 evaluationCFragHash = SignatureVerifier.hash(\\n            abi.encodePacked(RESERVED_CAPSULE_AND_CFRAG_BYTES), SignatureVerifier.HashAlgorithm.SHA256);\\n        require(delegateGet(_testTarget, this.evaluatedCFrags.selector, evaluationCFragHash) ==\\n            (evaluatedCFrags[evaluationCFragHash] ? 1 : 0));\\n        require(delegateGet(_testTarget, this.penaltyHistory.selector, bytes32(bytes20(RESERVED_ADDRESS))) ==\\n            penaltyHistory[RESERVED_ADDRESS]);\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `finishUpgrade`\\n    function finishUpgrade(address _target) public override virtual {\\n        super.finishUpgrade(_target);\\n        // preparation for the verifyState method\\n        bytes32 evaluationCFragHash = SignatureVerifier.hash(\\n            abi.encodePacked(RESERVED_CAPSULE_AND_CFRAG_BYTES), SignatureVerifier.HashAlgorithm.SHA256);\\n        evaluatedCFrags[evaluationCFragHash] = true;\\n        penaltyHistory[RESERVED_ADDRESS] = 123;\\n    }\\n}\\n\"},\"Bits.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n* @dev Taken from https://github.com/ethereum/solidity-examples/blob/master/src/bits/Bits.sol\\n*/\\nlibrary Bits {\\n\\n    uint256 internal constant ONE = uint256(1);\\n\\n    /**\\n    * @notice Sets the bit at the given \\u0027index\\u0027 in \\u0027self\\u0027 to:\\n    *  \\u00271\\u0027 - if the bit is \\u00270\\u0027\\n    *  \\u00270\\u0027 - if the bit is \\u00271\\u0027\\n    * @return The modified value\\n    */\\n    function toggleBit(uint256 self, uint8 index) internal pure returns (uint256) {\\n        return self ^ ONE \\u003c\\u003c index;\\n    }\\n\\n    /**\\n    * @notice Get the value of the bit at the given \\u0027index\\u0027 in \\u0027self\\u0027.\\n    */\\n    function bit(uint256 self, uint8 index) internal pure returns (uint8) {\\n        return uint8(self \\u003e\\u003e index \\u0026 1);\\n    }\\n\\n    /**\\n    * @notice Check if the bit at the given \\u0027index\\u0027 in \\u0027self\\u0027 is set.\\n    * @return  \\u0027true\\u0027 - if the value of the bit is \\u00271\\u0027,\\n    *          \\u0027false\\u0027 - if the value of the bit is \\u00270\\u0027\\n    */\\n    function bitSet(uint256 self, uint8 index) internal pure returns (bool) {\\n        return self \\u003e\\u003e index \\u0026 1 == 1;\\n    }\\n\\n}\\n\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n\\nimport \\\"IERC20.sol\\\";\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\n * Originally based on code by FirstBlood:\\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n *\\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\\n * all accounts just by listening to said events. Note that this isn\\u0027t required by the specification, and other\\n * compliant implementations may not do it.\\n */\\ncontract ERC20 is IERC20 {\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev Total number of tokens in existence\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param owner The address to query the balance of.\\n     * @return An uint256 representing the amount owned by the passed address.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param owner address The address which owns the funds.\\n     * @param spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    /**\\n     * @dev Transfer token for a specified address\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function transfer(address to, uint256 value) public override returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function approve(address spender, uint256 value) public override returns (bool) {\\n\\n        // To change the approve amount you first have to reduce the addresses`\\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\\n        //  already 0 to mitigate the race condition described here:\\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n        require(value == 0 || _allowed[msg.sender][spender] == 0);\\n\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one address to another.\\n     * Note that while this function emits an Approval event, this is not required as per the specification,\\n     * and other compliant implementations may not emit the event.\\n     * @param from address The address which you want to send tokens from\\n     * @param to address The address which you want to transfer to\\n     * @param value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(address from, address to, uint256 value) public override returns (bool) {\\n        _transfer(from, to, value);\\n        _approve(from, msg.sender, _allowed[from][msg.sender] - value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed_[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed_[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender] - subtractedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer token for a specified addresses\\n     * @param from The address to transfer from.\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(to != address(0));\\n\\n        _balances[from] -= value;\\n        _balances[to] += value;\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that mints an amount of the token and assigns it to\\n     * an account. This encapsulates the modification of balances such that the\\n     * proper events are emitted.\\n     * @param account The account that will receive the created tokens.\\n     * @param value The amount that will be created.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply += value;\\n        _balances[account] += value;\\n        emit Transfer(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account.\\n     * @param account The account whose tokens will be burnt.\\n     * @param value The amount that will be burnt.\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply -= value;\\n        _balances[account] -= value;\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Approve an address to spend another addresses\\u0027 tokens.\\n     * @param owner The address that owns the tokens.\\n     * @param spender The address that will spend the tokens.\\n     * @param value The number of tokens that can be spent.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(spender != address(0));\\n        require(owner != address(0));\\n\\n        _allowed[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account, deducting from the sender\\u0027s allowance for said account. Uses the\\n     * internal burn function.\\n     * Emits an Approval event (reflecting the reduced allowance).\\n     * @param account The account whose tokens will be burnt.\\n     * @param value The amount that will be burnt.\\n     */\\n    function _burnFrom(address account, uint256 value) internal {\\n        _burn(account, value);\\n        _approve(account, msg.sender, _allowed[account][msg.sender] - value);\\n    }\\n\\n}\\n\"},\"ERC20Detailed.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n\\nimport \\\"IERC20.sol\\\";\\n\\n\\n/**\\n * @title ERC20Detailed token\\n * @dev The decimals are only for visualization purposes.\\n * All the operations are done using the smallest and indivisible token unit,\\n * just as on Ethereum all the operations are done in wei.\\n */\\nabstract contract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    constructor (string memory name, string memory symbol, uint8 decimals) {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @return the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @return the symbol of the token.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @return the number of decimals of the token.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IERC900History.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n\\n// Minimum interface to interact with Aragon\\u0027s Aggregator\\ninterface IERC900History {\\n    function totalStakedForAt(address addr, uint256 blockNumber) external view returns (uint256);\\n    function totalStakedAt(uint256 blockNumber) external view returns (uint256);\\n    function supportsHistory() external pure returns (bool);\\n}\\n\"},\"IStaking.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588     \u2590\u2588\u2588\u2588\u2588\u258c     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588     \u2590\u2588\u2588\u2588\u2588\u258c     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588     \u2590\u2588\u2588\u2588\u2588\u258c     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588     \u2590\u2588\u2588\u2588\u2588\u258c     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Interface of Threshold Network staking contract\\n/// @notice The staking contract enables T owners to have their wallets offline\\n///         and their stake managed by providers on their behalf. All off-chain\\n///         client software should be able to run without exposing provider\u2019s\\n///         private key and should not require any owner\u2019s keys at all.\\n///         The stake delegation optimizes the network throughput without\\n///         compromising the security of the owners\u2019 stake.\\ninterface IStaking {\\n    enum StakeType {\\n        NU,\\n        KEEP,\\n        T\\n    }\\n\\n    //\\n    //\\n    // Delegating a stake\\n    //\\n    //\\n\\n    /// @notice Creates a delegation with `msg.sender` owner with the given\\n    ///         provider, beneficiary, and authorizer. Transfers the given\\n    ///         amount of T to the staking contract.\\n    /// @dev The owner of the delegation needs to have the amount approved to\\n    ///      transfer to the staking contract.\\n    function stake(\\n        address stakingProvider,\\n        address payable beneficiary,\\n        address authorizer,\\n        uint96 amount\\n    ) external;\\n\\n    /// @notice Copies delegation from the legacy KEEP staking contract to T\\n    ///         staking contract. No tokens are transferred. Caches the active\\n    ///         stake amount from KEEP staking contract. Can be called by\\n    ///         anyone.\\n    function stakeKeep(address stakingProvider) external;\\n\\n    /// @notice Copies delegation from the legacy NU staking contract to T\\n    ///         staking contract, additionally appointing beneficiary and\\n    ///         authorizer roles. Caches the amount staked in NU staking\\n    ///         contract. Can be called only by the original delegation owner.\\n    function stakeNu(\\n        address stakingProvider,\\n        address payable beneficiary,\\n        address authorizer\\n    ) external;\\n\\n    /// @notice Refresh Keep stake owner. Can be called only by the old owner.\\n    function refreshKeepStakeOwner(address stakingProvider) external;\\n\\n    /// @notice Allows the Governance to set the minimum required stake amount.\\n    ///         This amount is required to protect against griefing the staking\\n    ///         contract and individual applications are allowed to require\\n    ///         higher minimum stakes if necessary.\\n    function setMinimumStakeAmount(uint96 amount) external;\\n\\n    //\\n    //\\n    // Authorizing an application\\n    //\\n    //\\n\\n    /// @notice Allows the Governance to approve the particular application\\n    ///         before individual stake authorizers are able to authorize it.\\n    function approveApplication(address application) external;\\n\\n    /// @notice Increases the authorization of the given provider for the given\\n    ///         application by the given amount. Can only be called by the given\\n    ///         provider\u2019s authorizer.\\n    /// @dev Calls `authorizationIncreased(address stakingProvider, uint256 amount)`\\n    ///      on the given application to notify the application about\\n    ///      authorization change. See `IApplication`.\\n    function increaseAuthorization(\\n        address stakingProvider,\\n        address application,\\n        uint96 amount\\n    ) external;\\n\\n    /// @notice Requests decrease of the authorization for the given provider on\\n    ///         the given application by the provided amount.\\n    ///         It may not change the authorized amount immediatelly. When\\n    ///         it happens depends on the application. Can only be called by the\\n    ///         given provider\u2019s authorizer. Overwrites pending authorization\\n    ///         decrease for the given provider and application.\\n    /// @dev Calls `authorizationDecreaseRequested(address stakingProvider, uint256 amount)`\\n    ///      on the given application. See `IApplication`.\\n    function requestAuthorizationDecrease(\\n        address stakingProvider,\\n        address application,\\n        uint96 amount\\n    ) external;\\n\\n    /// @notice Requests decrease of all authorizations for the given provider on\\n    ///         the applications by all authorized amount.\\n    ///         It may not change the authorized amount immediatelly. When\\n    ///         it happens depends on the application. Can only be called by the\\n    ///         given provider\u2019s authorizer. Overwrites pending authorization\\n    ///         decrease for the given provider and application.\\n    /// @dev Calls `authorizationDecreaseRequested(address stakingProvider, uint256 amount)`\\n    ///      for each authorized application. See `IApplication`.\\n    function requestAuthorizationDecrease(address stakingProvider) external;\\n\\n    /// @notice Called by the application at its discretion to approve the\\n    ///         previously requested authorization decrease request. Can only be\\n    ///         called by the application that was previously requested to\\n    ///         decrease the authorization for that provider.\\n    ///         Returns resulting authorized amount for the application.\\n    function approveAuthorizationDecrease(address stakingProvider)\\n        external\\n        returns (uint96);\\n\\n    /// @notice Decreases the authorization for the given `stakingProvider` on\\n    ///         the given disabled `application`, for all authorized amount.\\n    ///         Can be called by anyone.\\n    function forceDecreaseAuthorization(\\n        address stakingProvider,\\n        address application\\n    ) external;\\n\\n    /// @notice Pauses the given application\u2019s eligibility to slash stakes.\\n    ///         Besides that stakers can\\u0027t change authorization to the application.\\n    ///         Can be called only by the Panic Button of the particular\\n    ///         application. The paused application can not slash stakes until\\n    ///         it is approved again by the Governance using `approveApplication`\\n    ///         function. Should be used only in case of an emergency.\\n    function pauseApplication(address application) external;\\n\\n    /// @notice Disables the given application. The disabled application can\\u0027t\\n    ///         slash stakers. Also stakers can\\u0027t increase authorization to that\\n    ///         application but can decrease without waiting by calling\\n    ///         `requestAuthorizationDecrease` at any moment. Can be called only\\n    ///         by the governance. The disabled application can\\u0027t be approved\\n    ///         again. Should be used only in case of an emergency.\\n    function disableApplication(address application) external;\\n\\n    /// @notice Sets the Panic Button role for the given application to the\\n    ///         provided address. Can only be called by the Governance. If the\\n    ///         Panic Button for the given application should be disabled, the\\n    ///         role address should be set to 0x0 address.\\n    function setPanicButton(address application, address panicButton) external;\\n\\n    /// @notice Sets the maximum number of applications one provider can\\n    ///         authorize. Used to protect against DoSing slashing queue.\\n    ///         Can only be called by the Governance.\\n    function setAuthorizationCeiling(uint256 ceiling) external;\\n\\n    //\\n    //\\n    // Stake top-up\\n    //\\n    //\\n\\n    /// @notice Increases the amount of the stake for the given provider.\\n    ///         Can be called only by the owner or provider.\\n    /// @dev The sender of this transaction needs to have the amount approved to\\n    ///      transfer to the staking contract.\\n    function topUp(address stakingProvider, uint96 amount) external;\\n\\n    /// @notice Propagates information about stake top-up from the legacy KEEP\\n    ///         staking contract to T staking contract. Can be called only by\\n    ///         the owner or provider.\\n    function topUpKeep(address stakingProvider) external;\\n\\n    /// @notice Propagates information about stake top-up from the legacy NU\\n    ///         staking contract to T staking contract. Can be called only by\\n    ///         the owner or provider.\\n    function topUpNu(address stakingProvider) external;\\n\\n    //\\n    //\\n    // Undelegating a stake (unstaking)\\n    //\\n    //\\n\\n    /// @notice Reduces the liquid T stake amount by the provided amount and\\n    ///         withdraws T to the owner. Reverts if there is at least one\\n    ///         authorization higher than the sum of the legacy stake and\\n    ///         remaining liquid T stake or if the unstake amount is higher than\\n    ///         the liquid T stake amount. Can be called only by the owner or\\n    ///         provider.\\n    function unstakeT(address stakingProvider, uint96 amount) external;\\n\\n    /// @notice Sets the legacy KEEP staking contract active stake amount cached\\n    ///         in T staking contract to 0. Reverts if the amount of liquid T\\n    ///         staked in T staking contract is lower than the highest\\n    ///         application authorization. This function allows to unstake from\\n    ///         KEEP staking contract and still being able to operate in T\\n    ///         network and earning rewards based on the liquid T staked. Can be\\n    ///         called only by the delegation owner and provider.\\n    function unstakeKeep(address stakingProvider) external;\\n\\n    /// @notice Reduces cached legacy NU stake amount by the provided amount.\\n    ///         Reverts if there is at least one authorization higher than the\\n    ///         sum of remaining legacy NU stake and liquid T stake for that\\n    ///         provider or if the untaked amount is higher than the cached\\n    ///         legacy stake amount. If succeeded, the legacy NU stake can be\\n    ///         partially or fully undelegated on the legacy staking contract.\\n    ///         This function allows to unstake from NU staking contract and\\n    ///         still being able to operate in T network and earning rewards\\n    ///         based on the liquid T staked. Can be called only by the\\n    ///         delegation owner and provider.\\n    function unstakeNu(address stakingProvider, uint96 amount) external;\\n\\n    /// @notice Sets cached legacy stake amount to 0, sets the liquid T stake\\n    ///         amount to 0 and withdraws all liquid T from the stake to the\\n    ///         owner. Reverts if there is at least one non-zero authorization.\\n    ///         Can be called only by the delegation owner and provider.\\n    function unstakeAll(address stakingProvider) external;\\n\\n    //\\n    //\\n    // Keeping information in sync\\n    //\\n    //\\n\\n    /// @notice Notifies about the discrepancy between legacy KEEP active stake\\n    ///         and the amount cached in T staking contract. Slashes the provider\\n    ///         in case the amount cached is higher than the actual active stake\\n    ///         amount in KEEP staking contract. Needs to update authorizations\\n    ///         of all affected applications and execute an involuntary\\n    ///         allocation decrease on all affected applications. Can be called\\n    ///         by anyone, notifier receives a reward.\\n    function notifyKeepStakeDiscrepancy(address stakingProvider) external;\\n\\n    /// @notice Notifies about the discrepancy between legacy NU active stake\\n    ///         and the amount cached in T staking contract. Slashes the\\n    ///         provider in case the amount cached is higher than the actual\\n    ///         active stake amount in NU staking contract. Needs to update\\n    ///         authorizations of all affected applications and execute an\\n    ///         involuntary allocation decrease on all affected applications.\\n    ///         Can be called by anyone, notifier receives a reward.\\n    function notifyNuStakeDiscrepancy(address stakingProvider) external;\\n\\n    /// @notice Sets the penalty amount for stake discrepancy and reward\\n    ///         multiplier for reporting it. The penalty is seized from the\\n    ///         provider account, and 5% of the penalty, scaled by the\\n    ///         multiplier, is given to the notifier. The rest of the tokens are\\n    ///         burned. Can only be called by the Governance. See `seize` function.\\n    function setStakeDiscrepancyPenalty(\\n        uint96 penalty,\\n        uint256 rewardMultiplier\\n    ) external;\\n\\n    /// @notice Sets reward in T tokens for notification of misbehaviour\\n    ///         of one provider. Can only be called by the governance.\\n    function setNotificationReward(uint96 reward) external;\\n\\n    /// @notice Transfer some amount of T tokens as reward for notifications\\n    ///         of misbehaviour\\n    function pushNotificationReward(uint96 reward) external;\\n\\n    /// @notice Withdraw some amount of T tokens from notifiers treasury.\\n    ///         Can only be called by the governance.\\n    function withdrawNotificationReward(address recipient, uint96 amount)\\n        external;\\n\\n    /// @notice Adds providers to the slashing queue along with the amount that\\n    ///         should be slashed from each one of them. Can only be called by\\n    ///         application authorized for all providers in the array.\\n    function slash(uint96 amount, address[] memory stakingProviders) external;\\n\\n    /// @notice Adds providers to the slashing queue along with the amount.\\n    ///         The notifier will receive reward per each provider from\\n    ///         notifiers treasury. Can only be called by application\\n    ///         authorized for all providers in the array.\\n    function seize(\\n        uint96 amount,\\n        uint256 rewardMultipier,\\n        address notifier,\\n        address[] memory stakingProviders\\n    ) external;\\n\\n    /// @notice Takes the given number of queued slashing operations and\\n    ///         processes them. Receives 5% of the slashed amount.\\n    ///         Executes `involuntaryAllocationDecrease` function on each\\n    ///         affected application.\\n    function processSlashing(uint256 count) external;\\n\\n    //\\n    //\\n    // Auxiliary functions\\n    //\\n    //\\n\\n    /// @notice Returns the authorized stake amount of the provider for the\\n    ///         application.\\n    function authorizedStake(address stakingProvider, address application)\\n        external\\n        view\\n        returns (uint96);\\n\\n    /// @notice Returns staked amount of T, Keep and Nu for the specified\\n    ///         staking provider.\\n    /// @dev    All values are in T denomination\\n    function stakes(address stakingProvider)\\n        external\\n        view\\n        returns (\\n            uint96 tStake,\\n            uint96 keepInTStake,\\n            uint96 nuInTStake\\n        );\\n\\n    /// @notice Returns start staking timestamp for T/NU stake.\\n    /// @dev    This value is set at most once, and only when a stake is created\\n    ///         with T or NU tokens. If a stake is created from a legacy KEEP\\n    ///         stake, this value will remain as zero\\n    function getStartStakingTimestamp(address stakingProvider)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Returns staked amount of NU for the specified provider\\n    function stakedNu(address stakingProvider) external view returns (uint256);\\n\\n    /// @notice Gets the stake owner, the beneficiary and the authorizer\\n    ///         for the specified provider address.\\n    /// @return owner Stake owner address.\\n    /// @return beneficiary Beneficiary address.\\n    /// @return authorizer Authorizer address.\\n    function rolesOf(address stakingProvider)\\n        external\\n        view\\n        returns (\\n            address owner,\\n            address payable beneficiary,\\n            address authorizer\\n        );\\n\\n    /// @notice Returns length of application array\\n    function getApplicationsLength() external view returns (uint256);\\n\\n    /// @notice Returns length of slashing queue\\n    function getSlashingQueueLength() external view returns (uint256);\\n\\n    /// @notice Returns minimum possible stake for T, KEEP or NU in T denomination\\n    /// @dev For example, suppose the given provider has 10 T, 20 T worth\\n    ///      of KEEP, and 30 T worth of NU all staked, and the maximum\\n    ///      application authorization is 40 T, then `getMinStaked` for\\n    ///      that provider returns:\\n    ///          * 0 T if KEEP stake type specified i.e.\\n    ///            min = 40 T max - (10 T + 30 T worth of NU) = 0 T\\n    ///          * 10 T if NU stake type specified i.e.\\n    ///            min = 40 T max - (10 T + 20 T worth of KEEP) = 10 T\\n    ///          * 0 T if T stake type specified i.e.\\n    ///            min = 40 T max - (20 T worth of KEEP + 30 T worth of NU) \\u003c 0 T\\n    ///      In other words, the minimum stake amount for the specified\\n    ///      stake type is the minimum amount of stake of the given type\\n    ///      needed to satisfy the maximum application authorization given\\n    ///      the staked amounts of the other stake types for that provider.\\n    function getMinStaked(address stakingProvider, StakeType stakeTypes)\\n        external\\n        view\\n        returns (uint96);\\n\\n    /// @notice Returns available amount to authorize for the specified application\\n    function getAvailableToAuthorize(\\n        address stakingProvider,\\n        address application\\n    ) external view returns (uint96);\\n}\\n\"},\"IStakingEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"NuCypherToken.sol\\\";\\n\\ninterface IStakingEscrow {\\n    function token() external view returns (NuCypherToken);\\n    function secondsPerPeriod() external view returns (uint32);\\n    function stakerFromWorker(address) external view returns (address);\\n    function getAllTokens(address) external view returns (uint256);\\n    function slashStaker(address, uint256, address, uint256) external;\\n    function genesisSecondsPerPeriod() external view returns (uint32);\\n    function getPastDowntimeLength(address) external view returns (uint256);\\n    function findIndexOfPastDowntime(address, uint16) external view returns (uint256);\\n    function getPastDowntime(address, uint256) external view returns (uint16, uint16);\\n    function getLastCommittedPeriod(address) external view returns (uint16);\\n    function minLockedPeriods() external view returns (uint16);\\n    function maxAllowableLockedTokens() external view returns (uint256);\\n    function minAllowableLockedTokens() external view returns (uint256);\\n    function getCompletedWork(address) external view returns (uint256);\\n    function depositFromWorkLock(address, uint256, uint16) external;\\n    function setWorkMeasurement(address, bool) external returns (uint256);\\n    function setSnapshots(bool _enableSnapshots) external;\\n    function withdraw(uint256 _value) external;\\n}\\n\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003e= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003c b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a \\u0026 b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"},\"NuCypherToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n\\nimport \\\"ERC20.sol\\\";\\nimport \\\"ERC20Detailed.sol\\\";\\n\\n\\n/**\\n* @title NuCypherToken\\n* @notice ERC20 token\\n* @dev Optional approveAndCall() functionality to notify a contract if an approve() has occurred.\\n*/\\ncontract NuCypherToken is ERC20, ERC20Detailed(\\u0027NuCypher\\u0027, \\u0027NU\\u0027, 18) {\\n\\n    /**\\n    * @notice Set amount of tokens\\n    * @param _totalSupplyOfTokens Total number of tokens\\n    */\\n    constructor (uint256 _totalSupplyOfTokens) {\\n        _mint(msg.sender, _totalSupplyOfTokens);\\n    }\\n\\n    /**\\n    * @notice Approves and then calls the receiving contract\\n    *\\n    * @dev call the receiveApproval function on the contract you want to be notified.\\n    * receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\\n    */\\n    function approveAndCall(address _spender, uint256 _value, bytes calldata _extraData)\\n        external returns (bool success)\\n    {\\n        approve(_spender, _value);\\n        TokenRecipient(_spender).receiveApproval(msg.sender, _value, address(this), _extraData);\\n        return true;\\n    }\\n\\n}\\n\\n\\n/**\\n* @dev Interface to use the receiveApproval method\\n*/\\ninterface TokenRecipient {\\n\\n    /**\\n    * @notice Receives a notification of approval of the transfer\\n    * @param _from Sender of approval\\n    * @param _value  The amount of tokens to be spent\\n    * @param _tokenContract Address of the token contract\\n    * @param _extraData Extra data\\n    */\\n    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes calldata _extraData) external;\\n\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\nabstract contract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"PolicyManager.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n\\nimport \\\"SafeERC20.sol\\\";\\nimport \\\"SafeMath.sol\\\";\\nimport \\\"Math.sol\\\";\\nimport \\\"Address.sol\\\";\\nimport \\\"AdditionalMath.sol\\\";\\nimport \\\"SignatureVerifier.sol\\\";\\nimport \\\"NuCypherToken.sol\\\";\\nimport \\\"Upgradeable.sol\\\";\\nimport \\\"IStakingEscrow.sol\\\";\\n\\n\\n/**\\n* @title PolicyManager\\n* @notice Contract holds policy data and locks accrued policy fees\\n* @dev |v6.3.1|\\n*/\\ncontract PolicyManager is Upgradeable {\\n    using SafeERC20 for NuCypherToken;\\n    using SafeMath for uint256;\\n    using AdditionalMath for uint256;\\n    using AdditionalMath for int256;\\n    using AdditionalMath for uint16;\\n    using Address for address payable;\\n\\n    event PolicyCreated(\\n        bytes16 indexed policyId,\\n        address indexed sponsor,\\n        address indexed owner,\\n        uint256 feeRate,\\n        uint64 startTimestamp,\\n        uint64 endTimestamp,\\n        uint256 numberOfNodes\\n    );\\n    event ArrangementRevoked(\\n        bytes16 indexed policyId,\\n        address indexed sender,\\n        address indexed node,\\n        uint256 value\\n    );\\n    event RefundForArrangement(\\n        bytes16 indexed policyId,\\n        address indexed sender,\\n        address indexed node,\\n        uint256 value\\n    );\\n    event PolicyRevoked(bytes16 indexed policyId, address indexed sender, uint256 value);\\n    event RefundForPolicy(bytes16 indexed policyId, address indexed sender, uint256 value);\\n    event MinFeeRateSet(address indexed node, uint256 value);\\n    // TODO #1501\\n    // Range range\\n    event FeeRateRangeSet(address indexed sender, uint256 min, uint256 defaultValue, uint256 max);\\n    event Withdrawn(address indexed node, address indexed recipient, uint256 value);\\n\\n    struct ArrangementInfo {\\n        address node;\\n        uint256 indexOfDowntimePeriods;\\n        uint16 lastRefundedPeriod;\\n    }\\n\\n    struct Policy {\\n        bool disabled;\\n        address payable sponsor;\\n        address owner;\\n\\n        uint128 feeRate;\\n        uint64 startTimestamp;\\n        uint64 endTimestamp;\\n\\n        uint256 reservedSlot1;\\n        uint256 reservedSlot2;\\n        uint256 reservedSlot3;\\n        uint256 reservedSlot4;\\n        uint256 reservedSlot5;\\n\\n        ArrangementInfo[] arrangements;\\n    }\\n\\n    struct NodeInfo {\\n        uint128 fee;\\n        uint16 previousFeePeriod;\\n        uint256 feeRate;\\n        uint256 minFeeRate;\\n        mapping (uint16 =\\u003e int256) stub; // former slot for feeDelta\\n        mapping (uint16 =\\u003e int256) feeDelta;\\n    }\\n\\n    // TODO used only for `delegateGetNodeInfo`, probably will be removed after #1512\\n    struct MemoryNodeInfo {\\n        uint128 fee;\\n        uint16 previousFeePeriod;\\n        uint256 feeRate;\\n        uint256 minFeeRate;\\n    }\\n\\n    struct Range {\\n        uint128 min;\\n        uint128 defaultValue;\\n        uint128 max;\\n    }\\n\\n    bytes16 internal constant RESERVED_POLICY_ID = bytes16(0);\\n    address internal constant RESERVED_NODE = address(0);\\n    uint256 internal constant MAX_BALANCE = uint256(type(uint128).max);\\n    // controlled overflow to get max int256\\n    int256 public constant DEFAULT_FEE_DELTA = int256((type(uint256).max) \\u003e\\u003e 1);\\n\\n    IStakingEscrow public immutable escrow;\\n    uint32 public immutable genesisSecondsPerPeriod;\\n    uint32 public immutable secondsPerPeriod;\\n\\n    mapping (bytes16 =\\u003e Policy) public policies;\\n    mapping (address =\\u003e NodeInfo) public nodes;\\n    Range public feeRateRange;\\n    uint64 public resetTimestamp;\\n\\n    /**\\n    * @notice Constructor sets address of the escrow contract\\n    * @dev Put same address in both inputs variables except when migration is happening\\n    * @param _escrowDispatcher Address of escrow dispatcher\\n    * @param _escrowImplementation Address of escrow implementation\\n    */\\n    constructor(IStakingEscrow _escrowDispatcher, IStakingEscrow _escrowImplementation) {\\n        escrow = _escrowDispatcher;\\n        // if the input address is not the StakingEscrow then calling `secondsPerPeriod` will throw error\\n        uint32 localSecondsPerPeriod = _escrowImplementation.secondsPerPeriod();\\n        require(localSecondsPerPeriod \\u003e 0);\\n        secondsPerPeriod = localSecondsPerPeriod;\\n        uint32 localgenesisSecondsPerPeriod = _escrowImplementation.genesisSecondsPerPeriod();\\n        require(localgenesisSecondsPerPeriod \\u003e 0);\\n        genesisSecondsPerPeriod = localgenesisSecondsPerPeriod;\\n        // handle case when we deployed new StakingEscrow but not yet upgraded\\n        if (_escrowDispatcher != _escrowImplementation) {\\n            require(_escrowDispatcher.secondsPerPeriod() == localSecondsPerPeriod ||\\n                _escrowDispatcher.secondsPerPeriod() == localgenesisSecondsPerPeriod);\\n        }\\n    }\\n\\n    /**\\n    * @dev Checks that sender is the StakingEscrow contract\\n    */\\n    modifier onlyEscrowContract()\\n    {\\n        require(msg.sender == address(escrow));\\n        _;\\n    }\\n\\n    /**\\n    * @return Number of current period\\n    */\\n    function getCurrentPeriod() public view returns (uint16) {\\n        return uint16(block.timestamp / secondsPerPeriod);\\n    }\\n\\n    /**\\n    * @return Recalculate period value using new basis\\n    */\\n    function recalculatePeriod(uint16 _period) internal view returns (uint16) {\\n        return uint16(uint256(_period) * genesisSecondsPerPeriod / secondsPerPeriod);\\n    }\\n\\n    /**\\n    * @notice Register a node\\n    * @param _node Node address\\n    * @param _period Initial period\\n    */\\n    function register(address _node, uint16 _period) external onlyEscrowContract {\\n        NodeInfo storage nodeInfo = nodes[_node];\\n        require(nodeInfo.previousFeePeriod == 0 \\u0026\\u0026 _period \\u003c getCurrentPeriod());\\n        nodeInfo.previousFeePeriod = _period;\\n    }\\n\\n    /**\\n    * @notice Migrate from the old period length to the new one\\n    * @param _node Node address\\n    */\\n    function migrate(address _node) external onlyEscrowContract {\\n        NodeInfo storage nodeInfo = nodes[_node];\\n        // with previous period length any previousFeePeriod will be greater than current period\\n        // this is a sign of not migrated node\\n        require(nodeInfo.previousFeePeriod \\u003e= getCurrentPeriod());\\n        nodeInfo.previousFeePeriod = recalculatePeriod(nodeInfo.previousFeePeriod);\\n        nodeInfo.feeRate = 0;\\n    }\\n\\n    /**\\n    * @notice Set minimum, default \\u0026 maximum fee rate for all stakers and all policies (\\u0027global fee range\\u0027)\\n    */\\n    // TODO # 1501\\n    // function setFeeRateRange(Range calldata _range) external onlyOwner {\\n    function setFeeRateRange(uint128 _min, uint128 _default, uint128 _max) external onlyOwner {\\n        require(_min \\u003c= _default \\u0026\\u0026 _default \\u003c= _max);\\n        feeRateRange = Range(_min, _default, _max);\\n        emit FeeRateRangeSet(msg.sender, _min, _default, _max);\\n    }\\n\\n    /**\\n    * @notice Set the minimum acceptable fee rate (set by staker for their associated worker)\\n    * @dev Input value must fall within `feeRateRange` (global fee range)\\n    */\\n    function setMinFeeRate(uint256 _minFeeRate) external {\\n        require(_minFeeRate \\u003e= feeRateRange.min \\u0026\\u0026\\n            _minFeeRate \\u003c= feeRateRange.max,\\n            \\\"The staker\\u0027s min fee rate must fall within the global fee range\\\");\\n        NodeInfo storage nodeInfo = nodes[msg.sender];\\n        if (nodeInfo.minFeeRate == _minFeeRate) {\\n            return;\\n        }\\n        nodeInfo.minFeeRate = _minFeeRate;\\n        emit MinFeeRateSet(msg.sender, _minFeeRate);\\n    }\\n\\n    /**\\n    * @notice Get the minimum acceptable fee rate (set by staker for their associated worker)\\n    */\\n    function getMinFeeRate(NodeInfo storage _nodeInfo) internal view returns (uint256) {\\n        // if minFeeRate has not been set or chosen value falls outside the global fee range\\n        // a default value is returned instead\\n        if (_nodeInfo.minFeeRate == 0 ||\\n            _nodeInfo.minFeeRate \\u003c feeRateRange.min ||\\n            _nodeInfo.minFeeRate \\u003e feeRateRange.max) {\\n            return feeRateRange.defaultValue;\\n        } else {\\n            return _nodeInfo.minFeeRate;\\n        }\\n    }\\n\\n    /**\\n    * @notice Get the minimum acceptable fee rate (set by staker for their associated worker)\\n    */\\n    function getMinFeeRate(address _node) public view returns (uint256) {\\n        NodeInfo storage nodeInfo = nodes[_node];\\n        return getMinFeeRate(nodeInfo);\\n    }\\n\\n    /**\\n    * @notice Create policy\\n    * @dev Generate policy id before creation\\n    * @param _policyId Policy id\\n    * @param _policyOwner Policy owner. Zero address means sender is owner\\n    * @param _endTimestamp End timestamp of the policy in seconds\\n    * @param _nodes Nodes that will handle policy\\n    */\\n    function createPolicy(\\n        bytes16 _policyId,\\n        address _policyOwner,\\n        uint64 _endTimestamp,\\n        address[] calldata _nodes\\n    )\\n        external payable\\n    {\\n        require(\\n            _endTimestamp \\u003e block.timestamp \\u0026\\u0026\\n            msg.value \\u003e 0\\n        );\\n\\n        require(address(this).balance \\u003c= MAX_BALANCE);\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 endPeriod = uint16(_endTimestamp / secondsPerPeriod) + 1;\\n        uint256 numberOfPeriods = endPeriod - currentPeriod;\\n\\n        uint128 feeRate = uint128(msg.value.div(_nodes.length) / numberOfPeriods);\\n        require(feeRate \\u003e 0 \\u0026\\u0026 feeRate * numberOfPeriods * _nodes.length  == msg.value);\\n\\n        Policy storage policy = createPolicy(_policyId, _policyOwner, _endTimestamp, feeRate, _nodes.length);\\n\\n        for (uint256 i = 0; i \\u003c _nodes.length; i++) {\\n            address node = _nodes[i];\\n            addFeeToNode(currentPeriod, endPeriod, node, feeRate, int256(uint256(feeRate)));\\n            policy.arrangements.push(ArrangementInfo(node, 0, 0));\\n        }\\n    }\\n\\n    /**\\n    * @notice Create multiple policies with the same owner, nodes and length\\n    * @dev Generate policy ids before creation\\n    * @param _policyIds Policy ids\\n    * @param _policyOwner Policy owner. Zero address means sender is owner\\n    * @param _endTimestamp End timestamp of all policies in seconds\\n    * @param _nodes Nodes that will handle all policies\\n    */\\n    function createPolicies(\\n        bytes16[] calldata _policyIds,\\n        address _policyOwner,\\n        uint64 _endTimestamp,\\n        address[] calldata _nodes\\n    )\\n        external payable\\n    {\\n        require(\\n            _endTimestamp \\u003e block.timestamp \\u0026\\u0026\\n            msg.value \\u003e 0 \\u0026\\u0026\\n            _policyIds.length \\u003e 1\\n        );\\n\\n        require(address(this).balance \\u003c= MAX_BALANCE);\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 endPeriod = uint16(_endTimestamp / secondsPerPeriod) + 1;\\n        uint256 numberOfPeriods = endPeriod - currentPeriod;\\n\\n        uint128 feeRate = uint128(msg.value.div(_nodes.length) / numberOfPeriods / _policyIds.length);\\n        require(feeRate \\u003e 0 \\u0026\\u0026 feeRate * numberOfPeriods * _nodes.length * _policyIds.length == msg.value);\\n\\n        for (uint256 i = 0; i \\u003c _policyIds.length; i++) {\\n            Policy storage policy = createPolicy(_policyIds[i], _policyOwner, _endTimestamp, feeRate, _nodes.length);\\n\\n            for (uint256 j = 0; j \\u003c _nodes.length; j++) {\\n                policy.arrangements.push(ArrangementInfo(_nodes[j], 0, 0));\\n            }\\n        }\\n\\n        int256 fee = int256(_policyIds.length * feeRate);\\n\\n        for (uint256 i = 0; i \\u003c _nodes.length; i++) {\\n            address node = _nodes[i];\\n            addFeeToNode(currentPeriod, endPeriod, node, feeRate, fee);\\n        }\\n    }\\n\\n    /**\\n    * @notice Create policy\\n    * @param _policyId Policy id\\n    * @param _policyOwner Policy owner. Zero address means sender is owner\\n    * @param _endTimestamp End timestamp of the policy in seconds\\n    * @param _feeRate Fee rate for policy\\n    * @param _nodesLength Number of nodes that will handle policy\\n    */\\n    function createPolicy(\\n        bytes16 _policyId,\\n        address _policyOwner,\\n        uint64 _endTimestamp,\\n        uint128 _feeRate,\\n        uint256 _nodesLength\\n    )\\n        internal returns (Policy storage policy)\\n    {\\n        policy = policies[_policyId];\\n        require(\\n            _policyId != RESERVED_POLICY_ID \\u0026\\u0026\\n            policy.feeRate == 0 \\u0026\\u0026\\n            !policy.disabled\\n        );\\n\\n        policy.sponsor = payable(msg.sender);\\n        policy.startTimestamp = uint64(block.timestamp);\\n        policy.endTimestamp = _endTimestamp;\\n        policy.feeRate = _feeRate;\\n\\n        if (_policyOwner != msg.sender \\u0026\\u0026 _policyOwner != address(0)) {\\n            policy.owner = _policyOwner;\\n        }\\n\\n        emit PolicyCreated(\\n            _policyId,\\n            msg.sender,\\n            _policyOwner == address(0) ? msg.sender : _policyOwner,\\n            _feeRate,\\n            policy.startTimestamp,\\n            policy.endTimestamp,\\n            _nodesLength\\n        );\\n    }\\n\\n    /**\\n    * @notice Increase fee rate for specified node\\n    * @param _currentPeriod Current period\\n    * @param _endPeriod End period of policy\\n    * @param _node Node that will handle policy\\n    * @param _feeRate Fee rate for one policy\\n    * @param _overallFeeRate Fee rate for all policies\\n    */\\n    function addFeeToNode(\\n        uint16 _currentPeriod,\\n        uint16 _endPeriod,\\n        address _node,\\n        uint128 _feeRate,\\n        int256 _overallFeeRate\\n    )\\n        internal\\n    {\\n        require(_node != RESERVED_NODE);\\n        NodeInfo storage nodeInfo = nodes[_node];\\n        require(nodeInfo.previousFeePeriod != 0 \\u0026\\u0026\\n            nodeInfo.previousFeePeriod \\u003c _currentPeriod \\u0026\\u0026\\n            _feeRate \\u003e= getMinFeeRate(nodeInfo));\\n        // Check default value for feeDelta\\n        if (nodeInfo.feeDelta[_currentPeriod] == DEFAULT_FEE_DELTA) {\\n            nodeInfo.feeDelta[_currentPeriod] = _overallFeeRate;\\n        } else {\\n            // Overflow protection removed, because ETH total supply less than uint255/int256\\n            nodeInfo.feeDelta[_currentPeriod] += _overallFeeRate;\\n        }\\n        if (nodeInfo.feeDelta[_endPeriod] == DEFAULT_FEE_DELTA) {\\n            nodeInfo.feeDelta[_endPeriod] = -_overallFeeRate;\\n        } else {\\n            nodeInfo.feeDelta[_endPeriod] -= _overallFeeRate;\\n        }\\n        // Reset to default value if needed\\n        if (nodeInfo.feeDelta[_currentPeriod] == 0) {\\n            nodeInfo.feeDelta[_currentPeriod] = DEFAULT_FEE_DELTA;\\n        }\\n        if (nodeInfo.feeDelta[_endPeriod] == 0) {\\n            nodeInfo.feeDelta[_endPeriod] = DEFAULT_FEE_DELTA;\\n        }\\n    }\\n\\n    /**\\n    * @notice Get policy owner\\n    */\\n    function getPolicyOwner(bytes16 _policyId) public view returns (address) {\\n        Policy storage policy = policies[_policyId];\\n        return policy.owner == address(0) ? policy.sponsor : policy.owner;\\n    }\\n\\n    /**\\n    * @notice Call from StakingEscrow to update node info once per period.\\n    * Set default `feeDelta` value for specified period and update node fee\\n    * @param _node Node address\\n    * @param _processedPeriod1 Processed period\\n    * @param _processedPeriod2 Processed period\\n    * @param _periodToSetDefault Period to set\\n    */\\n    function ping(\\n        address _node,\\n        uint16 _processedPeriod1,\\n        uint16 _processedPeriod2,\\n        uint16 _periodToSetDefault\\n    )\\n        external onlyEscrowContract\\n    {\\n        NodeInfo storage node = nodes[_node];\\n        // protection from calling not migrated node, see migrate()\\n        require(node.previousFeePeriod \\u003c= getCurrentPeriod());\\n        if (_processedPeriod1 != 0) {\\n            updateFee(node, _processedPeriod1);\\n        }\\n        if (_processedPeriod2 != 0) {\\n            updateFee(node, _processedPeriod2);\\n        }\\n        // This code increases gas cost for node in trade of decreasing cost for policy sponsor\\n        if (_periodToSetDefault != 0 \\u0026\\u0026 node.feeDelta[_periodToSetDefault] == 0) {\\n            node.feeDelta[_periodToSetDefault] = DEFAULT_FEE_DELTA;\\n        }\\n    }\\n\\n    /**\\n    * @notice Update node fee\\n    * @param _info Node info structure\\n    * @param _period Processed period\\n    */\\n    function updateFee(NodeInfo storage _info, uint16 _period) internal {\\n        if (_info.previousFeePeriod == 0 || _period \\u003c= _info.previousFeePeriod) {\\n            return;\\n        }\\n        for (uint16 i = _info.previousFeePeriod + 1; i \\u003c= _period; i++) {\\n            int256 delta = _info.feeDelta[i];\\n            if (delta == DEFAULT_FEE_DELTA) {\\n                // gas refund\\n                _info.feeDelta[i] = 0;\\n                continue;\\n            }\\n\\n            _info.feeRate = _info.feeRate.addSigned(delta);\\n            // gas refund\\n            _info.feeDelta[i] = 0;\\n        }\\n        _info.previousFeePeriod = _period;\\n        _info.fee += uint128(_info.feeRate);\\n    }\\n\\n    /**\\n    * @notice Withdraw fee by node\\n    */\\n    function withdraw() external returns (uint256) {\\n        return withdraw(payable(msg.sender));\\n    }\\n\\n    /**\\n    * @notice Withdraw fee by node\\n    * @param _recipient Recipient of the fee\\n    */\\n    function withdraw(address payable _recipient) public returns (uint256) {\\n        NodeInfo storage node = nodes[msg.sender];\\n        uint256 fee = node.fee;\\n        require(fee != 0);\\n        node.fee = 0;\\n        _recipient.sendValue(fee);\\n        emit Withdrawn(msg.sender, _recipient, fee);\\n        return fee;\\n    }\\n\\n    /**\\n    * @notice Calculate amount of refund\\n    * @param _policy Policy\\n    * @param _arrangement Arrangement\\n    */\\n    function calculateRefundValue(Policy storage _policy, ArrangementInfo storage _arrangement)\\n        internal view returns (uint256 refundValue, uint256 indexOfDowntimePeriods, uint16 lastRefundedPeriod)\\n    {\\n        uint16 policyStartPeriod = uint16(_policy.startTimestamp / secondsPerPeriod);\\n        uint16 maxPeriod = AdditionalMath.min16(getCurrentPeriod(), uint16(_policy.endTimestamp / secondsPerPeriod));\\n        uint16 minPeriod = AdditionalMath.max16(policyStartPeriod, _arrangement.lastRefundedPeriod);\\n        uint16 downtimePeriods = 0;\\n        uint256 length = escrow.getPastDowntimeLength(_arrangement.node);\\n        uint256 initialIndexOfDowntimePeriods;\\n        if (_arrangement.lastRefundedPeriod == 0) {\\n            initialIndexOfDowntimePeriods = escrow.findIndexOfPastDowntime(_arrangement.node, policyStartPeriod);\\n        } else {\\n            initialIndexOfDowntimePeriods = _arrangement.indexOfDowntimePeriods;\\n        }\\n\\n        for (indexOfDowntimePeriods = initialIndexOfDowntimePeriods;\\n             indexOfDowntimePeriods \\u003c length;\\n             indexOfDowntimePeriods++)\\n        {\\n            (uint16 startPeriod, uint16 endPeriod) =\\n                escrow.getPastDowntime(_arrangement.node, indexOfDowntimePeriods);\\n            if (startPeriod \\u003e maxPeriod) {\\n                break;\\n            } else if (endPeriod \\u003c minPeriod) {\\n                continue;\\n            }\\n            downtimePeriods += AdditionalMath.min16(maxPeriod, endPeriod)\\n                .sub16(AdditionalMath.max16(minPeriod, startPeriod)) + 1;\\n            if (maxPeriod \\u003c= endPeriod) {\\n                break;\\n            }\\n        }\\n\\n        uint16 lastCommittedPeriod = escrow.getLastCommittedPeriod(_arrangement.node);\\n        if (indexOfDowntimePeriods == length \\u0026\\u0026 lastCommittedPeriod \\u003c maxPeriod) {\\n            // Overflow protection removed:\\n            // lastCommittedPeriod \\u003c maxPeriod and minPeriod \\u003c= maxPeriod + 1\\n            downtimePeriods += maxPeriod - AdditionalMath.max16(minPeriod - 1, lastCommittedPeriod);\\n        }\\n\\n        refundValue = _policy.feeRate * downtimePeriods;\\n        lastRefundedPeriod = maxPeriod + 1;\\n    }\\n\\n    /**\\n    * @notice Revoke/refund arrangement/policy by the sponsor\\n    * @param _policyId Policy id\\n    * @param _node Node that will be excluded or RESERVED_NODE if full policy should be used\\n    ( @param _forceRevoke Force revoke arrangement/policy\\n    */\\n    function refundInternal(bytes16 _policyId, address _node, bool _forceRevoke)\\n        internal returns (uint256 refundValue)\\n    {\\n        refundValue = 0;\\n        Policy storage policy = policies[_policyId];\\n        require(!policy.disabled \\u0026\\u0026 policy.startTimestamp \\u003e= resetTimestamp);\\n        uint16 endPeriod = uint16(policy.endTimestamp / secondsPerPeriod) + 1;\\n        uint256 numberOfActive = policy.arrangements.length;\\n        uint256 i = 0;\\n        for (; i \\u003c policy.arrangements.length; i++) {\\n            ArrangementInfo storage arrangement = policy.arrangements[i];\\n            address node = arrangement.node;\\n            if (node == RESERVED_NODE || _node != RESERVED_NODE \\u0026\\u0026 _node != node) {\\n                numberOfActive--;\\n                continue;\\n            }\\n            uint256 nodeRefundValue;\\n            (nodeRefundValue, arrangement.indexOfDowntimePeriods, arrangement.lastRefundedPeriod) =\\n                calculateRefundValue(policy, arrangement);\\n            if (_forceRevoke) {\\n                NodeInfo storage nodeInfo = nodes[node];\\n\\n                // Check default value for feeDelta\\n                uint16 lastRefundedPeriod = arrangement.lastRefundedPeriod;\\n                if (nodeInfo.feeDelta[lastRefundedPeriod] == DEFAULT_FEE_DELTA) {\\n                    nodeInfo.feeDelta[lastRefundedPeriod] = -int256(uint256(policy.feeRate));\\n                } else {\\n                    nodeInfo.feeDelta[lastRefundedPeriod] -= int256(uint256(policy.feeRate));\\n                }\\n                if (nodeInfo.feeDelta[endPeriod] == DEFAULT_FEE_DELTA) {\\n                    nodeInfo.feeDelta[endPeriod] = int256(uint256(policy.feeRate));\\n                } else {\\n                    nodeInfo.feeDelta[endPeriod] += int256(uint256(policy.feeRate));\\n                }\\n\\n                // Reset to default value if needed\\n                if (nodeInfo.feeDelta[lastRefundedPeriod] == 0) {\\n                    nodeInfo.feeDelta[lastRefundedPeriod] = DEFAULT_FEE_DELTA;\\n                }\\n                if (nodeInfo.feeDelta[endPeriod] == 0) {\\n                    nodeInfo.feeDelta[endPeriod] = DEFAULT_FEE_DELTA;\\n                }\\n                nodeRefundValue += uint256(endPeriod - lastRefundedPeriod) * policy.feeRate;\\n            }\\n            if (_forceRevoke || arrangement.lastRefundedPeriod \\u003e= endPeriod) {\\n                arrangement.node = RESERVED_NODE;\\n                arrangement.indexOfDowntimePeriods = 0;\\n                arrangement.lastRefundedPeriod = 0;\\n                numberOfActive--;\\n                emit ArrangementRevoked(_policyId, msg.sender, node, nodeRefundValue);\\n            } else {\\n                emit RefundForArrangement(_policyId, msg.sender, node, nodeRefundValue);\\n            }\\n\\n            refundValue += nodeRefundValue;\\n            if (_node != RESERVED_NODE) {\\n               break;\\n            }\\n        }\\n        address payable policySponsor = policy.sponsor;\\n        if (_node == RESERVED_NODE) {\\n            if (numberOfActive == 0) {\\n                policy.disabled = true;\\n                // gas refund\\n                policy.sponsor = payable(address(0));\\n                policy.owner = address(0);\\n                policy.feeRate = 0;\\n                policy.startTimestamp = 0;\\n                policy.endTimestamp = 0;\\n                emit PolicyRevoked(_policyId, msg.sender, refundValue);\\n            } else {\\n                emit RefundForPolicy(_policyId, msg.sender, refundValue);\\n            }\\n        } else {\\n            // arrangement not found\\n            require(i \\u003c policy.arrangements.length);\\n        }\\n        if (refundValue \\u003e 0) {\\n            policySponsor.sendValue(refundValue);\\n        }\\n    }\\n\\n    /**\\n    * @notice Calculate amount of refund\\n    * @param _policyId Policy id\\n    * @param _node Node or RESERVED_NODE if all nodes should be used\\n    */\\n    function calculateRefundValueInternal(bytes16 _policyId, address _node)\\n        internal view returns (uint256 refundValue)\\n    {\\n        refundValue = 0;\\n        Policy storage policy = policies[_policyId];\\n        require((policy.owner == msg.sender || policy.sponsor == msg.sender) \\u0026\\u0026 !policy.disabled);\\n        uint256 i = 0;\\n        for (; i \\u003c policy.arrangements.length; i++) {\\n            ArrangementInfo storage arrangement = policy.arrangements[i];\\n            if (arrangement.node == RESERVED_NODE || _node != RESERVED_NODE \\u0026\\u0026 _node != arrangement.node) {\\n                continue;\\n            }\\n            (uint256 nodeRefundValue,,) = calculateRefundValue(policy, arrangement);\\n            refundValue += nodeRefundValue;\\n            if (_node != RESERVED_NODE) {\\n               break;\\n            }\\n        }\\n        if (_node != RESERVED_NODE) {\\n            // arrangement not found\\n            require(i \\u003c policy.arrangements.length);\\n        }\\n    }\\n\\n    /**\\n    * @notice Revoke policy by the sponsor\\n    * @param _policyId Policy id\\n    */\\n    function revokePolicy(bytes16 _policyId) external returns (uint256 refundValue) {\\n        require(getPolicyOwner(_policyId) == msg.sender);\\n        return refundInternal(_policyId, RESERVED_NODE, true);\\n    }\\n\\n    /**\\n    * @notice Revoke arrangement by the sponsor\\n    * @param _policyId Policy id\\n    * @param _node Node that will be excluded\\n    */\\n    function revokeArrangement(bytes16 _policyId, address _node)\\n        external returns (uint256 refundValue)\\n    {\\n        require(_node != RESERVED_NODE);\\n        require(getPolicyOwner(_policyId) == msg.sender);\\n        return refundInternal(_policyId, _node, true);\\n    }\\n\\n    /**\\n    * @notice Get unsigned hash for revocation\\n    * @param _policyId Policy id\\n    * @param _node Node that will be excluded\\n    * @return Revocation hash, EIP191 version 0x45 (\\u0027E\\u0027)\\n    */\\n    function getRevocationHash(bytes16 _policyId, address _node) public view returns (bytes32) {\\n        return SignatureVerifier.hashEIP191(abi.encodePacked(_policyId, _node), bytes1(0x45));\\n    }\\n\\n    /**\\n    * @notice Check correctness of signature\\n    * @param _policyId Policy id\\n    * @param _node Node that will be excluded, zero address if whole policy will be revoked\\n    * @param _signature Signature of owner\\n    */\\n    function checkOwnerSignature(bytes16 _policyId, address _node, bytes memory _signature) internal view {\\n        bytes32 hash = getRevocationHash(_policyId, _node);\\n        address recovered = SignatureVerifier.recover(hash, _signature);\\n        require(getPolicyOwner(_policyId) == recovered);\\n    }\\n\\n    /**\\n    * @notice Revoke policy or arrangement using owner\\u0027s signature\\n    * @param _policyId Policy id\\n    * @param _node Node that will be excluded, zero address if whole policy will be revoked\\n    * @param _signature Signature of owner, EIP191 version 0x45 (\\u0027E\\u0027)\\n    */\\n    function revoke(bytes16 _policyId, address _node, bytes calldata _signature)\\n        external returns (uint256 refundValue)\\n    {\\n        checkOwnerSignature(_policyId, _node, _signature);\\n        return refundInternal(_policyId, _node, true);\\n    }\\n\\n    /**\\n    * @notice Refund part of fee by the sponsor\\n    * @param _policyId Policy id\\n    */\\n    function refund(bytes16 _policyId) external {\\n        Policy storage policy = policies[_policyId];\\n        require(policy.owner == msg.sender || policy.sponsor == msg.sender);\\n        refundInternal(_policyId, RESERVED_NODE, false);\\n    }\\n\\n    /**\\n    * @notice Refund part of one node\\u0027s fee by the sponsor\\n    * @param _policyId Policy id\\n    * @param _node Node address\\n    */\\n    function refund(bytes16 _policyId, address _node)\\n        external returns (uint256 refundValue)\\n    {\\n        require(_node != RESERVED_NODE);\\n        Policy storage policy = policies[_policyId];\\n        require(policy.owner == msg.sender || policy.sponsor == msg.sender);\\n        return refundInternal(_policyId, _node, false);\\n    }\\n\\n    /**\\n    * @notice Calculate amount of refund\\n    * @param _policyId Policy id\\n    */\\n    function calculateRefundValue(bytes16 _policyId)\\n        external view returns (uint256 refundValue)\\n    {\\n        return calculateRefundValueInternal(_policyId, RESERVED_NODE);\\n    }\\n\\n    /**\\n    * @notice Calculate amount of refund\\n    * @param _policyId Policy id\\n    * @param _node Node\\n    */\\n    function calculateRefundValue(bytes16 _policyId, address _node)\\n        external view returns (uint256 refundValue)\\n    {\\n        require(_node != RESERVED_NODE);\\n        return calculateRefundValueInternal(_policyId, _node);\\n    }\\n\\n    /**\\n    * @notice Get number of arrangements in the policy\\n    * @param _policyId Policy id\\n    */\\n    function getArrangementsLength(bytes16 _policyId) external view returns (uint256) {\\n        return policies[_policyId].arrangements.length;\\n    }\\n\\n    /**\\n    * @notice Get information about staker\\u0027s fee rate\\n    * @param _node Address of staker\\n    * @param _period Period to get fee delta\\n    */\\n    function getNodeFeeDelta(address _node, uint16 _period)\\n        // TODO \\\"virtual\\\" only for tests, probably will be removed after #1512\\n        public view virtual returns (int256)\\n    {\\n        // TODO remove after upgrade #2579\\n        if (_node == RESERVED_NODE \\u0026\\u0026 _period == 11) {\\n            return 55;\\n        }\\n        return nodes[_node].feeDelta[_period];\\n    }\\n\\n    /**\\n    * @notice Return the information about arrangement\\n    */\\n    function getArrangementInfo(bytes16 _policyId, uint256 _index)\\n    // TODO change to structure when ABIEncoderV2 is released (#1501)\\n//        public view returns (ArrangementInfo)\\n        external view returns (address node, uint256 indexOfDowntimePeriods, uint16 lastRefundedPeriod)\\n    {\\n        ArrangementInfo storage info = policies[_policyId].arrangements[_index];\\n        node = info.node;\\n        indexOfDowntimePeriods = info.indexOfDowntimePeriods;\\n        lastRefundedPeriod = info.lastRefundedPeriod;\\n    }\\n\\n\\n    /**\\n    * @dev Get Policy structure by delegatecall\\n    */\\n    function delegateGetPolicy(address _target, bytes16 _policyId)\\n        internal returns (Policy memory result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, this.policies.selector, 1, bytes32(_policyId), 0);\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /**\\n    * @dev Get ArrangementInfo structure by delegatecall\\n    */\\n    function delegateGetArrangementInfo(address _target, bytes16 _policyId, uint256 _index)\\n        internal returns (ArrangementInfo memory result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(\\n            _target, this.getArrangementInfo.selector, 2, bytes32(_policyId), bytes32(_index));\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /**\\n    * @dev Get NodeInfo structure by delegatecall\\n    */\\n    function delegateGetNodeInfo(address _target, address _node)\\n        internal returns (MemoryNodeInfo memory result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, this.nodes.selector, 1, bytes32(uint256(uint160(_node))), 0);\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /**\\n    * @dev Get feeRateRange structure by delegatecall\\n    */\\n    function delegateGetFeeRateRange(address _target) internal returns (Range memory result) {\\n        bytes32 memoryAddress = delegateGetData(_target, this.feeRateRange.selector, 0, 0, 0);\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`\\n    function verifyState(address _testTarget) public override virtual {\\n        super.verifyState(_testTarget);\\n        require(uint64(delegateGet(_testTarget, this.resetTimestamp.selector)) == resetTimestamp);\\n\\n        Range memory rangeToCheck = delegateGetFeeRateRange(_testTarget);\\n        require(feeRateRange.min == rangeToCheck.min \\u0026\\u0026\\n            feeRateRange.defaultValue == rangeToCheck.defaultValue \\u0026\\u0026\\n            feeRateRange.max == rangeToCheck.max);\\n\\n        Policy storage policy = policies[RESERVED_POLICY_ID];\\n        Policy memory policyToCheck = delegateGetPolicy(_testTarget, RESERVED_POLICY_ID);\\n        require(policyToCheck.sponsor == policy.sponsor \\u0026\\u0026\\n            policyToCheck.owner == policy.owner \\u0026\\u0026\\n            policyToCheck.feeRate == policy.feeRate \\u0026\\u0026\\n            policyToCheck.startTimestamp == policy.startTimestamp \\u0026\\u0026\\n            policyToCheck.endTimestamp == policy.endTimestamp \\u0026\\u0026\\n            policyToCheck.disabled == policy.disabled);\\n\\n        require(delegateGet(_testTarget, this.getArrangementsLength.selector, RESERVED_POLICY_ID) ==\\n            policy.arrangements.length);\\n        if (policy.arrangements.length \\u003e 0) {\\n            ArrangementInfo storage arrangement = policy.arrangements[0];\\n            ArrangementInfo memory arrangementToCheck = delegateGetArrangementInfo(\\n                _testTarget, RESERVED_POLICY_ID, 0);\\n            require(arrangementToCheck.node == arrangement.node \\u0026\\u0026\\n                arrangementToCheck.indexOfDowntimePeriods == arrangement.indexOfDowntimePeriods \\u0026\\u0026\\n                arrangementToCheck.lastRefundedPeriod == arrangement.lastRefundedPeriod);\\n        }\\n\\n        NodeInfo storage nodeInfo = nodes[RESERVED_NODE];\\n        MemoryNodeInfo memory nodeInfoToCheck = delegateGetNodeInfo(_testTarget, RESERVED_NODE);\\n        require(nodeInfoToCheck.fee == nodeInfo.fee \\u0026\\u0026\\n            nodeInfoToCheck.feeRate == nodeInfo.feeRate \\u0026\\u0026\\n            nodeInfoToCheck.previousFeePeriod == nodeInfo.previousFeePeriod \\u0026\\u0026\\n            nodeInfoToCheck.minFeeRate == nodeInfo.minFeeRate);\\n\\n        require(int256(delegateGet(_testTarget, this.getNodeFeeDelta.selector,\\n            bytes32(bytes20(RESERVED_NODE)), bytes32(uint256(11)))) == getNodeFeeDelta(RESERVED_NODE, 11));\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `finishUpgrade`\\n    function finishUpgrade(address _target) public override virtual {\\n        super.finishUpgrade(_target);\\n\\n        if (resetTimestamp == 0) {\\n            resetTimestamp = uint64(block.timestamp);\\n        }\\n\\n        // Create fake Policy and NodeInfo to use them in verifyState(address)\\n        Policy storage policy = policies[RESERVED_POLICY_ID];\\n        policy.sponsor = payable(msg.sender);\\n        policy.owner = address(this);\\n        policy.startTimestamp = 1;\\n        policy.endTimestamp = 2;\\n        policy.feeRate = 3;\\n        policy.disabled = true;\\n        policy.arrangements.push(ArrangementInfo(RESERVED_NODE, 11, 22));\\n        NodeInfo storage nodeInfo = nodes[RESERVED_NODE];\\n        nodeInfo.fee = 100;\\n        nodeInfo.feeRate = 33;\\n        nodeInfo.previousFeePeriod = 44;\\n        nodeInfo.feeDelta[11] = 55;\\n        nodeInfo.minFeeRate = 777;\\n    }\\n}\\n\"},\"ReEncryptionValidator.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"UmbralDeserializer.sol\\\";\\nimport \\\"SignatureVerifier.sol\\\";\\n\\n/**\\n* @notice Validates re-encryption correctness.\\n*/\\nlibrary ReEncryptionValidator {\\n\\n    using UmbralDeserializer for bytes;\\n\\n\\n    //------------------------------//\\n    //   Umbral-specific constants  //\\n    //------------------------------//\\n\\n    // See parameter `u` of `UmbralParameters` class in pyUmbral\\n    // https://github.com/nucypher/pyUmbral/blob/master/umbral/params.py\\n    uint8 public constant UMBRAL_PARAMETER_U_SIGN = 0x02;\\n    uint256 public constant UMBRAL_PARAMETER_U_XCOORD = 0x03c98795773ff1c241fc0b1cced85e80f8366581dda5c9452175ebd41385fa1f;\\n    uint256 public constant UMBRAL_PARAMETER_U_YCOORD = 0x7880ed56962d7c0ae44d6f14bb53b5fe64b31ea44a41d0316f3a598778f0f936;\\n\\n\\n    //------------------------------//\\n    // SECP256K1-specific constants //\\n    //------------------------------//\\n\\n    // Base field order\\n    uint256 constant FIELD_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\\n\\n    // -2 mod FIELD_ORDER\\n    uint256 constant MINUS_2 = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2d;\\n\\n    // (-1/2) mod FIELD_ORDER\\n    uint256 constant MINUS_ONE_HALF = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff7ffffe17;\\n\\n\\n    //\\n\\n    /**\\n    * @notice Check correctness of re-encryption\\n    * @param _capsuleBytes Capsule\\n    * @param _cFragBytes Capsule frag\\n    * @param _precomputedBytes Additional precomputed data\\n    */\\n    function validateCFrag(\\n        bytes memory _capsuleBytes,\\n        bytes memory _cFragBytes,\\n        bytes memory _precomputedBytes\\n    )\\n        internal pure returns (bool)\\n    {\\n        UmbralDeserializer.Capsule memory _capsule = _capsuleBytes.toCapsule();\\n        UmbralDeserializer.CapsuleFrag memory _cFrag = _cFragBytes.toCapsuleFrag();\\n        UmbralDeserializer.PreComputedData memory _precomputed = _precomputedBytes.toPreComputedData();\\n\\n        // Extract Alice\\u0027s address and check that it corresponds to the one provided\\n        address alicesAddress = SignatureVerifier.recover(\\n            _precomputed.hashedKFragValidityMessage,\\n            abi.encodePacked(_cFrag.proof.kFragSignature, _precomputed.lostBytes[0])\\n        );\\n        require(alicesAddress == _precomputed.alicesKeyAsAddress, \\\"Bad KFrag signature\\\");\\n\\n        // Compute proof\\u0027s challenge scalar h, used in all ZKP verification equations\\n        uint256 h = computeProofChallengeScalar(_capsule, _cFrag);\\n\\n        //////\\n        // Verifying 1st equation: z*E == h*E_1 + E_2\\n        //////\\n\\n        // Input validation: E\\n        require(checkCompressedPoint(\\n            _capsule.pointE.sign,\\n            _capsule.pointE.xCoord,\\n            _precomputed.pointEyCoord),\\n            \\\"Precomputed Y coordinate of E doesn\\u0027t correspond to compressed E point\\\"\\n        );\\n\\n        // Input validation: z*E\\n        require(isOnCurve(_precomputed.pointEZxCoord, _precomputed.pointEZyCoord),\\n                \\\"Point zE is not a valid EC point\\\"\\n        );\\n        require(ecmulVerify(\\n            _capsule.pointE.xCoord,         // E_x\\n            _precomputed.pointEyCoord,      // E_y\\n            _cFrag.proof.bnSig,             // z\\n            _precomputed.pointEZxCoord,     // zE_x\\n            _precomputed.pointEZyCoord),    // zE_y\\n            \\\"Precomputed z*E value is incorrect\\\"\\n        );\\n\\n        // Input validation: E1\\n        require(checkCompressedPoint(\\n            _cFrag.pointE1.sign,          // E1_sign\\n            _cFrag.pointE1.xCoord,        // E1_x\\n            _precomputed.pointE1yCoord),  // E1_y\\n            \\\"Precomputed Y coordinate of E1 doesn\\u0027t correspond to compressed E1 point\\\"\\n        );\\n\\n        // Input validation: h*E1\\n        require(isOnCurve(_precomputed.pointE1HxCoord, _precomputed.pointE1HyCoord),\\n                \\\"Point h*E1 is not a valid EC point\\\"\\n        );\\n        require(ecmulVerify(\\n            _cFrag.pointE1.xCoord,          // E1_x\\n            _precomputed.pointE1yCoord,     // E1_y\\n            h,\\n            _precomputed.pointE1HxCoord,    // hE1_x\\n            _precomputed.pointE1HyCoord),   // hE1_y\\n            \\\"Precomputed h*E1 value is incorrect\\\"\\n        );\\n\\n        // Input validation: E2\\n        require(checkCompressedPoint(\\n            _cFrag.proof.pointE2.sign,        // E2_sign\\n            _cFrag.proof.pointE2.xCoord,      // E2_x\\n            _precomputed.pointE2yCoord),      // E2_y\\n            \\\"Precomputed Y coordinate of E2 doesn\\u0027t correspond to compressed E2 point\\\"\\n        );\\n\\n        bool equation_holds = eqAffineJacobian(\\n            [_precomputed.pointEZxCoord,  _precomputed.pointEZyCoord],\\n            addAffineJacobian(\\n                [_cFrag.proof.pointE2.xCoord, _precomputed.pointE2yCoord],\\n                [_precomputed.pointE1HxCoord, _precomputed.pointE1HyCoord]\\n            )\\n        );\\n\\n        if (!equation_holds){\\n            return false;\\n        }\\n\\n        //////\\n        // Verifying 2nd equation: z*V == h*V_1 + V_2\\n        //////\\n\\n        // Input validation: V\\n        require(checkCompressedPoint(\\n            _capsule.pointV.sign,\\n            _capsule.pointV.xCoord,\\n            _precomputed.pointVyCoord),\\n            \\\"Precomputed Y coordinate of V doesn\\u0027t correspond to compressed V point\\\"\\n        );\\n\\n        // Input validation: z*V\\n        require(isOnCurve(_precomputed.pointVZxCoord, _precomputed.pointVZyCoord),\\n                \\\"Point zV is not a valid EC point\\\"\\n        );\\n        require(ecmulVerify(\\n            _capsule.pointV.xCoord,         // V_x\\n            _precomputed.pointVyCoord,      // V_y\\n            _cFrag.proof.bnSig,             // z\\n            _precomputed.pointVZxCoord,     // zV_x\\n            _precomputed.pointVZyCoord),    // zV_y\\n            \\\"Precomputed z*V value is incorrect\\\"\\n        );\\n\\n        // Input validation: V1\\n        require(checkCompressedPoint(\\n            _cFrag.pointV1.sign,         // V1_sign\\n            _cFrag.pointV1.xCoord,       // V1_x\\n            _precomputed.pointV1yCoord), // V1_y\\n            \\\"Precomputed Y coordinate of V1 doesn\\u0027t correspond to compressed V1 point\\\"\\n        );\\n\\n        // Input validation: h*V1\\n        require(isOnCurve(_precomputed.pointV1HxCoord, _precomputed.pointV1HyCoord),\\n            \\\"Point h*V1 is not a valid EC point\\\"\\n        );\\n        require(ecmulVerify(\\n            _cFrag.pointV1.xCoord,          // V1_x\\n            _precomputed.pointV1yCoord,     // V1_y\\n            h,\\n            _precomputed.pointV1HxCoord,    // h*V1_x\\n            _precomputed.pointV1HyCoord),   // h*V1_y\\n            \\\"Precomputed h*V1 value is incorrect\\\"\\n        );\\n\\n        // Input validation: V2\\n        require(checkCompressedPoint(\\n            _cFrag.proof.pointV2.sign,        // V2_sign\\n            _cFrag.proof.pointV2.xCoord,      // V2_x\\n            _precomputed.pointV2yCoord),      // V2_y\\n            \\\"Precomputed Y coordinate of V2 doesn\\u0027t correspond to compressed V2 point\\\"\\n        );\\n\\n        equation_holds = eqAffineJacobian(\\n            [_precomputed.pointVZxCoord,  _precomputed.pointVZyCoord],\\n            addAffineJacobian(\\n                [_cFrag.proof.pointV2.xCoord, _precomputed.pointV2yCoord],\\n                [_precomputed.pointV1HxCoord, _precomputed.pointV1HyCoord]\\n            )\\n        );\\n\\n        if (!equation_holds){\\n            return false;\\n        }\\n\\n        //////\\n        // Verifying 3rd equation: z*U == h*U_1 + U_2\\n        //////\\n\\n        // We don\\u0027t have to validate U since it\\u0027s fixed and hard-coded\\n\\n        // Input validation: z*U\\n        require(isOnCurve(_precomputed.pointUZxCoord, _precomputed.pointUZyCoord),\\n                \\\"Point z*U is not a valid EC point\\\"\\n        );\\n        require(ecmulVerify(\\n            UMBRAL_PARAMETER_U_XCOORD,      // U_x\\n            UMBRAL_PARAMETER_U_YCOORD,      // U_y\\n            _cFrag.proof.bnSig,             // z\\n            _precomputed.pointUZxCoord,     // zU_x\\n            _precomputed.pointUZyCoord),    // zU_y\\n            \\\"Precomputed z*U value is incorrect\\\"\\n        );\\n\\n        // Input validation: U1  (a.k.a. KFragCommitment)\\n        require(checkCompressedPoint(\\n            _cFrag.proof.pointKFragCommitment.sign,     // U1_sign\\n            _cFrag.proof.pointKFragCommitment.xCoord,   // U1_x\\n            _precomputed.pointU1yCoord),                // U1_y\\n            \\\"Precomputed Y coordinate of U1 doesn\\u0027t correspond to compressed U1 point\\\"\\n        );\\n\\n        // Input validation: h*U1\\n        require(isOnCurve(_precomputed.pointU1HxCoord, _precomputed.pointU1HyCoord),\\n                \\\"Point h*U1 is not a valid EC point\\\"\\n        );\\n        require(ecmulVerify(\\n            _cFrag.proof.pointKFragCommitment.xCoord,   // U1_x\\n            _precomputed.pointU1yCoord,                 // U1_y\\n            h,\\n            _precomputed.pointU1HxCoord,    // h*V1_x\\n            _precomputed.pointU1HyCoord),   // h*V1_y\\n            \\\"Precomputed h*V1 value is incorrect\\\"\\n        );\\n\\n        // Input validation: U2  (a.k.a. KFragPok (\\\"proof of knowledge\\\"))\\n        require(checkCompressedPoint(\\n            _cFrag.proof.pointKFragPok.sign,    // U2_sign\\n            _cFrag.proof.pointKFragPok.xCoord,  // U2_x\\n            _precomputed.pointU2yCoord),        // U2_y\\n            \\\"Precomputed Y coordinate of U2 doesn\\u0027t correspond to compressed U2 point\\\"\\n        );\\n\\n        equation_holds = eqAffineJacobian(\\n            [_precomputed.pointUZxCoord,  _precomputed.pointUZyCoord],\\n            addAffineJacobian(\\n                [_cFrag.proof.pointKFragPok.xCoord, _precomputed.pointU2yCoord],\\n                [_precomputed.pointU1HxCoord, _precomputed.pointU1HyCoord]\\n            )\\n        );\\n\\n        return equation_holds;\\n    }\\n\\n    function computeProofChallengeScalar(\\n        UmbralDeserializer.Capsule memory _capsule,\\n        UmbralDeserializer.CapsuleFrag memory _cFrag\\n    ) internal pure returns (uint256) {\\n\\n        // Compute h = hash_to_bignum(e, e1, e2, v, v1, v2, u, u1, u2, metadata)\\n        bytes memory hashInput = abi.encodePacked(\\n            // Point E\\n            _capsule.pointE.sign,\\n            _capsule.pointE.xCoord,\\n            // Point E1\\n            _cFrag.pointE1.sign,\\n            _cFrag.pointE1.xCoord,\\n            // Point E2\\n            _cFrag.proof.pointE2.sign,\\n            _cFrag.proof.pointE2.xCoord\\n        );\\n\\n        hashInput = abi.encodePacked(\\n            hashInput,\\n            // Point V\\n            _capsule.pointV.sign,\\n            _capsule.pointV.xCoord,\\n            // Point V1\\n            _cFrag.pointV1.sign,\\n            _cFrag.pointV1.xCoord,\\n            // Point V2\\n            _cFrag.proof.pointV2.sign,\\n            _cFrag.proof.pointV2.xCoord\\n        );\\n\\n        hashInput = abi.encodePacked(\\n            hashInput,\\n            // Point U\\n            bytes1(UMBRAL_PARAMETER_U_SIGN),\\n            bytes32(UMBRAL_PARAMETER_U_XCOORD),\\n            // Point U1\\n            _cFrag.proof.pointKFragCommitment.sign,\\n            _cFrag.proof.pointKFragCommitment.xCoord,\\n            // Point U2\\n            _cFrag.proof.pointKFragPok.sign,\\n            _cFrag.proof.pointKFragPok.xCoord,\\n            // Re-encryption metadata\\n            _cFrag.proof.metadata\\n        );\\n\\n        uint256 h = extendedKeccakToBN(hashInput);\\n        return h;\\n\\n    }\\n\\n    function extendedKeccakToBN (bytes memory _data) internal pure returns (uint256) {\\n\\n        bytes32 upper;\\n        bytes32 lower;\\n\\n        // Umbral prepends to the data a customization string of 64-bytes.\\n        // In the case of hash_to_curvebn is \\u0027hash_to_curvebn\\u0027, padded with zeroes.\\n        bytes memory input = abi.encodePacked(bytes32(\\\"hash_to_curvebn\\\"), bytes32(0x00), _data);\\n\\n        (upper, lower) = (keccak256(abi.encodePacked(uint8(0x00), input)),\\n                          keccak256(abi.encodePacked(uint8(0x01), input)));\\n\\n        // Let n be the order of secp256k1\\u0027s group (n = 2^256 - 0x1000003D1)\\n        // n_minus_1 = n - 1\\n        // delta = 2^256 mod n_minus_1\\n        uint256 delta = 0x14551231950b75fc4402da1732fc9bec0;\\n        uint256 n_minus_1 = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140;\\n\\n        uint256 upper_half = mulmod(uint256(upper), delta, n_minus_1);\\n        return 1 + addmod(upper_half, uint256(lower), n_minus_1);\\n    }\\n\\n    /// @notice Tests if a compressed point is valid, wrt to its corresponding Y coordinate\\n    /// @param _pointSign The sign byte from the compressed notation: 0x02 if the Y coord is even; 0x03 otherwise\\n    /// @param _pointX The X coordinate of an EC point in affine representation\\n    /// @param _pointY The Y coordinate of an EC point in affine representation\\n    /// @return true iff _pointSign and _pointX are the compressed representation of (_pointX, _pointY)\\n\\tfunction checkCompressedPoint(\\n\\t\\tuint8 _pointSign,\\n\\t\\tuint256 _pointX,\\n\\t\\tuint256 _pointY\\n\\t) internal pure returns(bool) {\\n\\t\\tbool correct_sign = _pointY % 2 == _pointSign - 2;\\n\\t\\treturn correct_sign \\u0026\\u0026 isOnCurve(_pointX, _pointY);\\n\\t}\\n\\n    /// @notice Tests if the given serialized coordinates represent a valid EC point\\n    /// @param _coords The concatenation of serialized X and Y coordinates\\n    /// @return true iff coordinates X and Y are a valid point\\n    function checkSerializedCoordinates(bytes memory _coords) internal pure returns(bool) {\\n        require(_coords.length == 64, \\\"Serialized coordinates should be 64 B\\\");\\n        uint256 coordX;\\n        uint256 coordY;\\n        assembly {\\n            coordX := mload(add(_coords, 32))\\n            coordY := mload(add(_coords, 64))\\n        }\\n\\t\\treturn isOnCurve(coordX, coordY);\\n\\t}\\n\\n    /// @notice Tests if a point is on the secp256k1 curve\\n    /// @param Px The X coordinate of an EC point in affine representation\\n    /// @param Py The Y coordinate of an EC point in affine representation\\n    /// @return true if (Px, Py) is a valid secp256k1 point; false otherwise\\n    function isOnCurve(uint256 Px, uint256 Py) internal pure returns (bool) {\\n        uint256 p = FIELD_ORDER;\\n\\n        if (Px \\u003e= p || Py \\u003e= p){\\n            return false;\\n        }\\n\\n        uint256 y2 = mulmod(Py, Py, p);\\n        uint256 x3_plus_7 = addmod(mulmod(mulmod(Px, Px, p), Px, p), 7, p);\\n        return y2 == x3_plus_7;\\n    }\\n\\n    // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/4\\n    function ecmulVerify(\\n    \\tuint256 x1,\\n    \\tuint256 y1,\\n    \\tuint256 scalar,\\n    \\tuint256 qx,\\n    \\tuint256 qy\\n    ) internal pure returns(bool) {\\n\\t    uint256 curve_order = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\\n\\t    address signer = ecrecover(0, uint8(27 + (y1 % 2)), bytes32(x1), bytes32(mulmod(scalar, x1, curve_order)));\\n\\t    address xyAddress = address(uint160(uint256(keccak256(abi.encodePacked(qx, qy))) \\u0026 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n\\t    return xyAddress == signer;\\n\\t}\\n\\n    /// @notice Equality test of two points, in affine and Jacobian coordinates respectively\\n    /// @param P An EC point in affine coordinates\\n    /// @param Q An EC point in Jacobian coordinates\\n    /// @return true if P and Q represent the same point in affine coordinates; false otherwise\\n    function eqAffineJacobian(\\n    \\tuint256[2] memory P,\\n    \\tuint256[3] memory Q\\n    ) internal pure returns(bool){\\n        uint256 Qz = Q[2];\\n        if(Qz == 0){\\n            return false;       // Q is zero but P isn\\u0027t.\\n        }\\n\\n        uint256 p = FIELD_ORDER;\\n        uint256 Q_z_squared = mulmod(Qz, Qz, p);\\n        return mulmod(P[0], Q_z_squared, p) == Q[0] \\u0026\\u0026 mulmod(P[1], mulmod(Q_z_squared, Qz, p), p) == Q[1];\\n\\n    }\\n\\n    /// @notice Adds two points in affine coordinates, with the result in Jacobian\\n    /// @dev Based on the addition formulas from http://www.hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/addition/add-2001-b.op3\\n    /// @param P An EC point in affine coordinates\\n    /// @param Q An EC point in affine coordinates\\n    /// @return R An EC point in Jacobian coordinates with the sum, represented by an array of 3 uint256\\n    function addAffineJacobian(\\n    \\tuint[2] memory P,\\n    \\tuint[2] memory Q\\n    ) internal pure returns (uint[3] memory R) {\\n\\n        uint256 p = FIELD_ORDER;\\n        uint256 a   = P[0];\\n        uint256 c   = P[1];\\n        uint256 t0  = Q[0];\\n        uint256 t1  = Q[1];\\n\\n        if ((a == t0) \\u0026\\u0026 (c == t1)){\\n            return doubleJacobian([a, c, 1]);\\n        }\\n        uint256 d = addmod(t1, p-c, p); // d = t1 - c\\n        uint256 b = addmod(t0, p-a, p); // b = t0 - a\\n        uint256 e = mulmod(b, b, p); // e = b^2\\n        uint256 f = mulmod(e, b, p);  // f = b^3\\n        uint256 g = mulmod(a, e, p);\\n        R[0] = addmod(mulmod(d, d, p), p-addmod(mulmod(2, g, p), f, p), p);\\n        R[1] = addmod(mulmod(d, addmod(g, p-R[0], p), p), p-mulmod(c, f, p), p);\\n        R[2] = b;\\n    }\\n\\n    /// @notice Point doubling in Jacobian coordinates\\n    /// @param P An EC point in Jacobian coordinates.\\n    /// @return Q An EC point in Jacobian coordinates\\n    function doubleJacobian(uint[3] memory P) internal pure returns (uint[3] memory Q) {\\n        uint256 z = P[2];\\n        if (z == 0)\\n            return Q;\\n        uint256 p = FIELD_ORDER;\\n        uint256 x = P[0];\\n        uint256 _2y = mulmod(2, P[1], p);\\n        uint256 _4yy = mulmod(_2y, _2y, p);\\n        uint256 s = mulmod(_4yy, x, p);\\n        uint256 m = mulmod(3, mulmod(x, x, p), p);\\n        uint256 t = addmod(mulmod(m, m, p), mulmod(MINUS_2, s, p),p);\\n        Q[0] = t;\\n        Q[1] = addmod(mulmod(m, addmod(s, p - t, p), p), mulmod(MINUS_ONE_HALF, mulmod(_4yy, _4yy, p), p), p);\\n        Q[2] = mulmod(_2y, z, p);\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance \\u003e= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n        // we\\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length \\u003e 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler\\u0027s built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c \\u003c a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b \\u003e a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003c= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"},\"SignatureVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n\\n/**\\n* @notice Library to recover address and verify signatures\\n* @dev Simple wrapper for `ecrecover`\\n*/\\nlibrary SignatureVerifier {\\n\\n    enum HashAlgorithm {KECCAK256, SHA256, RIPEMD160}\\n\\n    // Header for Version E as defined by EIP191. First byte (\\u0027E\\u0027) is also the version\\n    bytes25 constant EIP191_VERSION_E_HEADER = \\\"Ethereum Signed Message:\\\\n\\\";\\n\\n    /**\\n    * @notice Recover signer address from hash and signature\\n    * @param _hash 32 bytes message hash\\n    * @param _signature Signature of hash - 32 bytes r + 32 bytes s + 1 byte v (could be 0, 1, 27, 28)\\n    */\\n    function recover(bytes32 _hash, bytes memory _signature)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        require(_signature.length == 65);\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            r := mload(add(_signature, 32))\\n            s := mload(add(_signature, 64))\\n            v := byte(0, mload(add(_signature, 96)))\\n        }\\n\\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\\n        if (v \\u003c 27) {\\n            v += 27;\\n        }\\n        require(v == 27 || v == 28);\\n        return ecrecover(_hash, v, r, s);\\n    }\\n\\n    /**\\n    * @notice Transform public key to address\\n    * @param _publicKey secp256k1 public key\\n    */\\n    function toAddress(bytes memory _publicKey) internal pure returns (address) {\\n        return address(uint160(uint256(keccak256(_publicKey))));\\n    }\\n\\n    /**\\n    * @notice Hash using one of pre built hashing algorithm\\n    * @param _message Signed message\\n    * @param _algorithm Hashing algorithm\\n    */\\n    function hash(bytes memory _message, HashAlgorithm _algorithm)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        if (_algorithm == HashAlgorithm.KECCAK256) {\\n            result = keccak256(_message);\\n        } else if (_algorithm == HashAlgorithm.SHA256) {\\n            result = sha256(_message);\\n        } else {\\n            result = ripemd160(_message);\\n        }\\n    }\\n\\n    /**\\n    * @notice Verify ECDSA signature\\n    * @dev Uses one of pre built hashing algorithm\\n    * @param _message Signed message\\n    * @param _signature Signature of message hash\\n    * @param _publicKey secp256k1 public key in uncompressed format without prefix byte (64 bytes)\\n    * @param _algorithm Hashing algorithm\\n    */\\n    function verify(\\n        bytes memory _message,\\n        bytes memory _signature,\\n        bytes memory _publicKey,\\n        HashAlgorithm _algorithm\\n    )\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        require(_publicKey.length == 64);\\n        return toAddress(_publicKey) == recover(hash(_message, _algorithm), _signature);\\n    }\\n\\n    /**\\n    * @notice Hash message according to EIP191 signature specification\\n    * @dev It always assumes Keccak256 is used as hashing algorithm\\n    * @dev Only supports version 0 and version E (0x45)\\n    * @param _message Message to sign\\n    * @param _version EIP191 version to use\\n    */\\n    function hashEIP191(\\n        bytes memory _message,\\n        bytes1 _version\\n    )\\n        internal\\n        view\\n        returns (bytes32 result)\\n    {\\n        if(_version == bytes1(0x00)){  // Version 0: Data with intended validator\\n            address validator = address(this);\\n            return keccak256(abi.encodePacked(bytes1(0x19), bytes1(0x00), validator, _message));\\n        } else if (_version == bytes1(0x45)){  // Version E: personal_sign messages\\n            uint256 length = _message.length;\\n            require(length \\u003e 0, \\\"Empty message not allowed for version E\\\");\\n\\n            // Compute text-encoded length of message\\n            uint256 digits = 0;\\n            while (length != 0) {\\n                digits++;\\n                length /= 10;\\n            }\\n            bytes memory lengthAsText = new bytes(digits);\\n            length = _message.length;\\n            uint256 index = digits;\\n            while (length != 0) {\\n                lengthAsText[--index] = bytes1(uint8(48 + length % 10));\\n                length /= 10;\\n            }\\n\\n            return keccak256(abi.encodePacked(bytes1(0x19), EIP191_VERSION_E_HEADER, lengthAsText, _message));\\n        } else {\\n            revert(\\\"Unsupported EIP191 version\\\");\\n        }\\n    }\\n\\n    /**\\n    * @notice Verify EIP191 signature\\n    * @dev It always assumes Keccak256 is used as hashing algorithm\\n    * @dev Only supports version 0 and version E (0x45)\\n    * @param _message Signed message\\n    * @param _signature Signature of message hash\\n    * @param _publicKey secp256k1 public key in uncompressed format without prefix byte (64 bytes)\\n    * @param _version EIP191 version to use\\n    */\\n    function verifyEIP191(\\n        bytes memory _message,\\n        bytes memory _signature,\\n        bytes memory _publicKey,\\n        bytes1 _version\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(_publicKey.length == 64);\\n        return toAddress(_publicKey) == recover(hashEIP191(_message, _version), _signature);\\n    }\\n\\n}\\n\"},\"SimplePREApplication.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n\\nimport \\\"IStaking.sol\\\";\\n\\n\\n/**\\n* @title PRE Application\\n* @notice Contract handles PRE configuration\\n*/\\ncontract SimplePREApplication {\\n\\n    /**\\n    * @notice Signals that an operator was bonded to the staking provider\\n    * @param stakingProvider Staking provider address\\n    * @param operator Operator address\\n    * @param startTimestamp Timestamp bonding occurred\\n    */\\n    event OperatorBonded(address indexed stakingProvider, address indexed operator, uint256 startTimestamp);\\n\\n    /**\\n    * @notice Signals that an operator address is confirmed\\n    * @param stakingProvider Staking provider address\\n    * @param operator Operator address\\n    */\\n    event OperatorConfirmed(address indexed stakingProvider, address indexed operator);\\n\\n    struct StakingProviderInfo {\\n        address operator;\\n        bool operatorConfirmed;\\n        uint256 operatorStartTimestamp;\\n    }\\n\\n    uint256 public immutable minAuthorization;\\n    uint256 public immutable minOperatorSeconds;\\n\\n    IStaking public immutable tStaking;\\n\\n    mapping (address =\\u003e StakingProviderInfo) public stakingProviderInfo;\\n    address[] public stakingProviders;\\n    mapping(address =\\u003e address) internal _stakingProviderFromOperator;\\n\\n\\n    /**\\n    * @notice Constructor sets address of token contract and parameters for staking\\n    * @param _tStaking T token staking contract\\n    * @param _minAuthorization Amount of minimum allowable authorization\\n    * @param _minOperatorSeconds Min amount of seconds while an operator can\\u0027t be changed\\n    */\\n    constructor(\\n        IStaking _tStaking,\\n        uint256 _minAuthorization,\\n        uint256 _minOperatorSeconds\\n    ) {\\n        require(\\n            _tStaking.authorizedStake(address(this), address(this)) == 0,\\n            \\\"Wrong input parameters\\\"\\n        );\\n        minAuthorization = _minAuthorization;\\n        tStaking = _tStaking;\\n        minOperatorSeconds = _minOperatorSeconds;\\n    }\\n\\n    /**\\n    * @dev Checks caller is a staking provider or stake owner\\n    */\\n    modifier onlyOwnerOrStakingProvider(address _stakingProvider)\\n    {\\n        require(isAuthorized(_stakingProvider), \\\"Not owner or provider\\\");\\n        if (_stakingProvider != msg.sender) {\\n            (address owner,,) = tStaking.rolesOf(_stakingProvider);\\n            require(owner == msg.sender, \\\"Not owner or provider\\\");\\n        }\\n        _;\\n    }\\n\\n\\n    //-------------------------Main-------------------------\\n    /**\\n    * @notice Returns staking provider for specified operator\\n    */\\n    function stakingProviderFromOperator(address _operator) public view returns (address) {\\n        return _stakingProviderFromOperator[_operator];\\n    }\\n\\n    /**\\n    * @notice Returns operator for specified staking provider\\n    */\\n    function getOperatorFromStakingProvider(address _stakingProvider) public view returns (address) {\\n        return stakingProviderInfo[_stakingProvider].operator;\\n    }\\n\\n    /**\\n    * @notice Get all tokens delegated to the staking provider\\n    */\\n    function authorizedStake(address _stakingProvider) public view returns (uint96) {\\n        (uint96 tStake, uint96 keepInTStake, uint96 nuInTStake) = tStaking.stakes(_stakingProvider);\\n        return tStake + keepInTStake + nuInTStake;\\n    }\\n\\n    /**\\n    * @notice Get the value of authorized tokens for active providers as well as providers and their authorized tokens\\n    * @param _startIndex Start index for looking in providers array\\n    * @param _maxStakingProviders Max providers for looking, if set 0 then all will be used\\n    * @return allAuthorizedTokens Sum of authorized tokens for active providers\\n    * @return activeStakingProviders Array of providers and their authorized tokens.\\n    * Providers addresses stored as uint256\\n    * @dev Note that activeStakingProviders[0] is an array of uint256, but you want addresses.\\n    * Careful when used directly!\\n    */\\n    function getActiveStakingProviders(uint256 _startIndex, uint256 _maxStakingProviders)\\n        external view returns (uint256 allAuthorizedTokens, uint256[2][] memory activeStakingProviders)\\n    {\\n        uint256 endIndex = stakingProviders.length;\\n        require(_startIndex \\u003c endIndex, \\\"Wrong start index\\\");\\n        if (_maxStakingProviders != 0 \\u0026\\u0026 _startIndex + _maxStakingProviders \\u003c endIndex) {\\n            endIndex = _startIndex + _maxStakingProviders;\\n        }\\n        activeStakingProviders = new uint256[2][](endIndex - _startIndex);\\n        allAuthorizedTokens = 0;\\n\\n        uint256 resultIndex = 0;\\n        for (uint256 i = _startIndex; i \\u003c endIndex; i++) {\\n            address stakingProvider = stakingProviders[i];\\n            StakingProviderInfo storage info = stakingProviderInfo[stakingProvider];\\n            uint256 eligibleAmount = authorizedStake(stakingProvider);\\n            if (eligibleAmount \\u003c minAuthorization || !info.operatorConfirmed) {\\n                continue;\\n            }\\n            activeStakingProviders[resultIndex][0] = uint256(uint160(stakingProvider));\\n            activeStakingProviders[resultIndex++][1] = eligibleAmount;\\n            allAuthorizedTokens += eligibleAmount;\\n        }\\n        assembly {\\n            mstore(activeStakingProviders, resultIndex)\\n        }\\n    }\\n\\n    /**\\n    * @notice Returns beneficiary related to the staking provider\\n    */\\n    function getBeneficiary(address _stakingProvider) public view returns (address payable beneficiary) {\\n        (, beneficiary,) = tStaking.rolesOf(_stakingProvider);\\n    }\\n\\n    /**\\n    * @notice Returns true if staking provider has authorized stake to this application\\n    */\\n    function isAuthorized(address _stakingProvider) public view returns (bool) {\\n        return authorizedStake(_stakingProvider) \\u003e= minAuthorization;\\n    }\\n\\n    /**\\n    * @notice Returns true if operator has confirmed address\\n    */\\n    // TODO maybe _stakingProvider instead of _operator as input?\\n    function isOperatorConfirmed(address _operator) public view returns (bool) {\\n        address stakingProvider = _stakingProviderFromOperator[_operator];\\n        StakingProviderInfo storage info = stakingProviderInfo[stakingProvider];\\n        return info.operatorConfirmed;\\n    }\\n\\n    /**\\n    * @notice Return the length of the array of staking providers\\n    */\\n    function getStakingProvidersLength() external view returns (uint256) {\\n        return stakingProviders.length;\\n    }\\n\\n    /**\\n    * @notice Bond operator\\n    * @param _stakingProvider Staking provider address\\n    * @param _operator Operator address. Must be a real address, not a contract\\n    */\\n    function bondOperator(address _stakingProvider, address _operator)\\n        external onlyOwnerOrStakingProvider(_stakingProvider)\\n    {\\n        StakingProviderInfo storage info = stakingProviderInfo[_stakingProvider];\\n        require(_operator != info.operator, \\\"Specified operator is already bonded with this provider\\\");\\n        // If this staker had an operator ...\\n        if (info.operator != address(0)) {\\n            require(\\n                block.timestamp \\u003e= info.operatorStartTimestamp + minOperatorSeconds,\\n                \\\"Not enough time passed to change operator\\\"\\n            );\\n            // Remove the old relation \\\"operator-\\u003estakingProvider\\\"\\n            _stakingProviderFromOperator[info.operator] = address(0);\\n        }\\n\\n        if (_operator != address(0)) {\\n            require(_stakingProviderFromOperator[_operator] == address(0), \\\"Specified operator is already in use\\\");\\n            require(\\n                _operator == _stakingProvider || getBeneficiary(_operator) == address(0),\\n                \\\"Specified operator is a provider\\\"\\n            );\\n            // Set new operator-\\u003estakingProvider relation\\n            _stakingProviderFromOperator[_operator] = _stakingProvider;\\n        }\\n\\n        if (info.operatorStartTimestamp == 0) {\\n            stakingProviders.push(_stakingProvider);\\n        }\\n\\n        // Bond new operator (or unbond if _operator == address(0))\\n        info.operator = _operator;\\n        info.operatorStartTimestamp = block.timestamp;\\n        info.operatorConfirmed = false;\\n        emit OperatorBonded(_stakingProvider, _operator, block.timestamp);\\n    }\\n\\n    /**\\n    * @notice Make a confirmation by operator\\n    */\\n    function confirmOperatorAddress() external {\\n        address stakingProvider = _stakingProviderFromOperator[msg.sender];\\n        require(isAuthorized(stakingProvider), \\\"No stake associated with the operator\\\");\\n        StakingProviderInfo storage info = stakingProviderInfo[stakingProvider];\\n        require(!info.operatorConfirmed, \\\"Operator address is already confirmed\\\");\\n        require(msg.sender == tx.origin, \\\"Only operator with real address can make a confirmation\\\");\\n        info.operatorConfirmed = true;\\n        emit OperatorConfirmed(stakingProvider, msg.sender);\\n    }\\n\\n}\\n\"},\"StakingEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n\\nimport \\\"IERC900History.sol\\\";\\nimport \\\"NuCypherToken.sol\\\";\\nimport \\\"Bits.sol\\\";\\nimport \\\"Upgradeable.sol\\\";\\nimport \\\"Math.sol\\\";\\nimport \\\"SafeERC20.sol\\\";\\nimport \\\"IStaking.sol\\\";\\n\\n\\n/**\\n* @notice WorkLock interface\\n*/\\ninterface WorkLockInterface {\\n    function token() external view returns (NuCypherToken);\\n}\\n\\n\\n/**\\n* @title StakingEscrowStub\\n* @notice Stub is used to deploy main StakingEscrow after all other contract and make some variables immutable\\n* @dev |v1.1.0|\\n*/\\ncontract StakingEscrowStub is Upgradeable {\\n    NuCypherToken public immutable token;\\n    // only to deploy WorkLock\\n    uint32 public immutable secondsPerPeriod = 1;\\n    uint16 public immutable minLockedPeriods = 0;\\n    uint256 public immutable minAllowableLockedTokens;\\n    uint256 public immutable maxAllowableLockedTokens;\\n\\n    /**\\n    * @notice Predefines some variables for use when deploying other contracts\\n    * @param _token Token contract\\n    * @param _minAllowableLockedTokens Min amount of tokens that can be locked\\n    * @param _maxAllowableLockedTokens Max amount of tokens that can be locked\\n    */\\n    constructor(\\n        NuCypherToken _token,\\n        uint256 _minAllowableLockedTokens,\\n        uint256 _maxAllowableLockedTokens\\n    ) {\\n        require(_token.totalSupply() \\u003e 0 \\u0026\\u0026\\n            _maxAllowableLockedTokens != 0);\\n\\n        token = _token;\\n        minAllowableLockedTokens = _minAllowableLockedTokens;\\n        maxAllowableLockedTokens = _maxAllowableLockedTokens;\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`\\n    function verifyState(address _testTarget) public override virtual {\\n        super.verifyState(_testTarget);\\n\\n        // we have to use real values even though this is a stub\\n        require(address(uint160(delegateGet(_testTarget, this.token.selector))) == address(token));\\n    }\\n}\\n\\n\\n/**\\n* @title StakingEscrow\\n* @notice Contract holds and locks stakers tokens.\\n* Each staker that locks their tokens will receive some compensation\\n* @dev |v6.2.2|\\n*/\\ncontract StakingEscrow is Upgradeable, IERC900History {\\n\\n    using Bits for uint256;\\n    using SafeERC20 for NuCypherToken;\\n\\n    /**\\n    * @notice Signals that tokens were deposited\\n    * @param staker Staker address\\n    * @param value Amount deposited (in NuNits)\\n    */\\n    event Deposited(address indexed staker, uint256 value);\\n\\n    /**\\n    * @notice Signals that NU tokens were withdrawn to the staker\\n    * @param staker Staker address\\n    * @param value Amount withdraws (in NuNits)\\n    */\\n    event Withdrawn(address indexed staker, uint256 value);\\n\\n    /**\\n    * @notice Signals that the staker was slashed\\n    * @param staker Staker address\\n    * @param penalty Slashing penalty\\n    * @param investigator Investigator address\\n    * @param reward Value of reward provided to investigator (in NuNits)\\n    */\\n    event Slashed(address indexed staker, uint256 penalty, address indexed investigator, uint256 reward);\\n\\n    /**\\n    * @notice Signals that vesting parameters were set for the staker\\n    * @param staker Staker address\\n    * @param releaseTimestamp Release timestamp\\n    * @param releaseRate Release rate\\n    */\\n    event VestingSet(address indexed staker, uint256 releaseTimestamp, uint256 releaseRate);\\n\\n    /**\\n    * @notice Signals that the staker requested merge with T staking contract\\n    * @param staker Staker address\\n    * @param stakingProvider Staking provider address\\n    */\\n    event MergeRequested(address indexed staker, address indexed stakingProvider);\\n\\n    struct StakerInfo {\\n        uint256 value;\\n\\n        uint16 stub1; // former slot for currentCommittedPeriod // TODO combine slots?\\n        uint16 stub2; // former slot for nextCommittedPeriod\\n        uint16 lastCommittedPeriod; // used only in depositFromWorkLock\\n        uint16 stub4; // former slot for lockReStakeUntilPeriod\\n        uint256 stub5; // former slot for completedWork\\n        uint16 stub6; // former slot for workerStartPeriod\\n        address stub7; // former slot for worker\\n\\n        uint256 flags; // uint256 to acquire whole slot and minimize operations on it\\n\\n        uint256 vestingReleaseTimestamp;\\n        uint256 vestingReleaseRate;\\n        address stakingProvider;\\n\\n        uint256 reservedSlot4;\\n        uint256 reservedSlot5;\\n\\n        uint256[] stub8; // former slot for pastDowntime\\n        uint256[] stub9; // former slot for subStakes\\n        uint128[] stub10; // former slot for history\\n\\n    }\\n\\n    // indices for flags (0-4 were in use, skip it in future)\\n//    uint8 internal constant SOME_FLAG_INDEX = 5;\\n\\n    NuCypherToken public immutable token;\\n    WorkLockInterface public immutable workLock;\\n    IStaking public immutable tStaking;\\n\\n    uint128 private stub1; // former slot for previousPeriodSupply\\n    uint128 public currentPeriodSupply; // resulting token supply\\n    uint16 private stub2; // former slot for currentMintingPeriod\\n\\n    mapping (address =\\u003e StakerInfo) public stakerInfo;\\n    address[] public stakers;\\n    mapping (address =\\u003e address) private stub3; // former slot for stakerFromWorker\\n\\n    mapping (uint16 =\\u003e uint256) private stub4; // former slot for lockedPerPeriod\\n    uint128[] private stub5;  // former slot for balanceHistory\\n\\n    address private stub6; // former slot for PolicyManager\\n    address private stub7; // former slot for Adjudicator\\n    address private stub8; // former slot for WorkLock\\n\\n    mapping (uint16 =\\u003e uint256) private stub9; // last former slot for lockedPerPeriod\\n\\n    /**\\n    * @notice Constructor sets address of token contract and parameters for staking\\n    * @param _token NuCypher token contract\\n    * @param _workLock WorkLock contract. Zero address if there is no WorkLock\\n    * @param _tStaking T token staking contract\\n    */\\n    constructor(\\n        NuCypherToken _token,\\n        WorkLockInterface _workLock,\\n        IStaking _tStaking\\n    ) {\\n        require(_token.totalSupply() \\u003e 0 \\u0026\\u0026\\n            _tStaking.stakedNu(address(0)) == 0 \\u0026\\u0026\\n            (address(_workLock) == address(0) || _workLock.token() == _token),\\n            \\\"Input addresses must be deployed contracts\\\"\\n        );\\n\\n        token = _token;\\n        workLock = _workLock;\\n        tStaking = _tStaking;\\n    }\\n\\n    /**\\n    * @dev Checks the existence of a staker in the contract\\n    */\\n    modifier onlyStaker()\\n    {\\n        require(stakerInfo[msg.sender].value \\u003e 0, \\\"Caller must be a staker\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev Checks caller is T staking contract\\n    */\\n    modifier onlyTStakingContract()\\n    {\\n        require(msg.sender == address(tStaking), \\\"Caller must be the T staking contract\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev Checks caller is WorkLock contract\\n    */\\n    modifier onlyWorkLock()\\n    {\\n        require(msg.sender == address(workLock), \\\"Caller must be the WorkLock contract\\\");\\n        _;\\n    }\\n\\n    //------------------------Main getters------------------------\\n    /**\\n    * @notice Get all tokens belonging to the staker\\n    */\\n    function getAllTokens(address _staker) external view returns (uint256) {\\n        return stakerInfo[_staker].value;\\n    }\\n\\n    /**\\n    * @notice Get work that completed by the staker\\n    */\\n    function getCompletedWork(address _staker) external view returns (uint256) {\\n        return token.totalSupply();\\n    }\\n\\n\\n    //------------------------Main methods------------------------\\n    /**\\n    * @notice Stub for WorkLock\\n    * @param _staker Staker\\n    * @param _measureWork Value for `measureWork` parameter\\n    * @return Work that was previously done\\n    */\\n    function setWorkMeasurement(address _staker, bool _measureWork)\\n        external onlyWorkLock returns (uint256)\\n    {\\n        return 0;\\n    }\\n\\n    /**\\n    * @notice Deposit tokens from WorkLock contract\\n    * @param _staker Staker address\\n    * @param _value Amount of tokens to deposit\\n    * @param _unlockingDuration Amount of periods during which tokens will be unlocked when wind down is enabled\\n    */\\n    function depositFromWorkLock(\\n        address _staker,\\n        uint256 _value,\\n        uint16 _unlockingDuration\\n    )\\n        external onlyWorkLock\\n    {\\n        require(_value != 0, \\\"Amount of tokens to deposit must be specified\\\");\\n        StakerInfo storage info = stakerInfo[_staker];\\n        // initial stake of the staker\\n        if (info.value == 0 \\u0026\\u0026 info.lastCommittedPeriod == 0) {\\n            stakers.push(_staker);\\n        }\\n        token.safeTransferFrom(msg.sender, address(this), _value);\\n        info.value += _value;\\n\\n        emit Deposited(_staker, _value);\\n    }\\n\\n    /**\\n    * @notice Withdraw available amount of NU tokens to staker\\n    * @param _value Amount of tokens to withdraw\\n    */\\n    function withdraw(uint256 _value) external onlyStaker {\\n        require(_value \\u003e 0, \\\"Value must be specified\\\");\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        require(\\n            _value + tStaking.stakedNu(info.stakingProvider) \\u003c= info.value,\\n            \\\"Not enough tokens unstaked in T staking contract\\\"\\n        );\\n        require(\\n            _value + getUnvestedTokens(msg.sender) \\u003c= info.value,\\n            \\\"Not enough tokens released during vesting\\\"\\n        );\\n        info.value -= _value;\\n\\n        token.safeTransfer(msg.sender, _value);\\n        emit Withdrawn(msg.sender, _value);\\n    }\\n\\n    /**\\n    * @notice Returns amount of not released yet tokens for staker\\n    */\\n    function getUnvestedTokens(address _staker) public view returns (uint256) {\\n        StakerInfo storage info = stakerInfo[_staker];\\n        if (info.vestingReleaseTimestamp \\u003c= block.timestamp) {\\n            return 0;\\n        }\\n        if (info.vestingReleaseRate == 0) {\\n            // this value includes all not withdrawn reward\\n            return info.value;\\n        }\\n        uint256 unvestedTokens = (info.vestingReleaseTimestamp - block.timestamp) * info.vestingReleaseRate;\\n        return info.value \\u003c unvestedTokens ? info.value : unvestedTokens;\\n    }\\n\\n    /**\\n    * @notice Setup vesting parameters\\n    * @param _stakers Array of stakers\\n    * @param _releaseTimestamp Array of timestamps when stake will be released\\n    * @param _releaseRate Array of release rates\\n    * @dev If release rate is 0 then all value will be locked before release timestamp\\n    */\\n    function setupVesting(\\n        address[] calldata _stakers,\\n        uint256[] calldata _releaseTimestamp,\\n        uint256[] calldata _releaseRate\\n    ) external onlyOwner {\\n        require(_stakers.length == _releaseTimestamp.length \\u0026\\u0026\\n            _releaseTimestamp.length == _releaseRate.length,\\n            \\\"Input arrays must have same number of elements\\\"\\n        );\\n        for (uint256 i = 0; i \\u003c _stakers.length; i++) {\\n            address staker = _stakers[i];\\n            StakerInfo storage info = stakerInfo[staker];\\n            require(info.vestingReleaseTimestamp == 0, \\\"Vesting parameters can be set only once\\\");\\n            info.vestingReleaseTimestamp = _releaseTimestamp[i];\\n            info.vestingReleaseRate = _releaseRate[i];\\n            require(getUnvestedTokens(staker) \\u003e 0, \\\"Vesting parameters must be set properly\\\");\\n            emit VestingSet(staker, info.vestingReleaseTimestamp, info.vestingReleaseRate);\\n        }\\n    }\\n\\n    /**\\n    * @notice Request migration to threshold network\\n    * @param _staker Staker address\\n    * @param _stakingProvider Staking provider address\\n    * @return Amount of tokens\\n    */\\n    function requestMerge(address _staker, address _stakingProvider)\\n        external onlyTStakingContract returns (uint256)\\n    {\\n        StakerInfo storage info = stakerInfo[_staker];\\n        require(\\n            info.stakingProvider == address(0) ||\\n            info.stakingProvider == _stakingProvider ||\\n            tStaking.stakedNu(info.stakingProvider) == 0,\\n            \\\"Staking provider already set for the staker\\\"\\n        );\\n        if (info.stakingProvider != _stakingProvider) {\\n            info.stakingProvider = _stakingProvider;\\n            emit MergeRequested(_staker, _stakingProvider);\\n        }\\n        return info.value;\\n    }\\n\\n    //-------------------------Slashing-------------------------\\n    /**\\n    * @notice Slash the staker\\u0027s stake and reward the investigator\\n    * @param _staker Staker\\u0027s address\\n    * @param _penalty Penalty\\n    * @param _investigator Investigator\\n    * @param _reward Reward for the investigator\\n    */\\n    function slashStaker(\\n        address _staker,\\n        uint256 _penalty,\\n        address _investigator,\\n        uint256 _reward\\n    )\\n        external onlyTStakingContract\\n    {\\n        require(_penalty \\u003e 0, \\\"Penalty must be specified\\\");\\n        StakerInfo storage info = stakerInfo[_staker];\\n        if (info.value \\u003c= _penalty) {\\n            _penalty = info.value;\\n        }\\n        info.value -= _penalty;\\n        if (_reward \\u003e _penalty) {\\n            _reward = _penalty;\\n        }\\n\\n        emit Slashed(_staker, _penalty, _investigator, _reward);\\n        if (_reward \\u003e 0) {\\n            token.safeTransfer(_investigator, _reward);\\n        }\\n    }\\n\\n    //-------------Additional getters for stakers info-------------\\n    /**\\n    * @notice Return the length of the array of stakers\\n    */\\n    function getStakersLength() external view virtual returns (uint256) {\\n        return stakers.length;\\n    }\\n\\n    //------------------ ERC900 connectors ----------------------\\n\\n    function totalStakedForAt(address _owner, uint256 _blockNumber) public view override returns (uint256) {\\n        return 0;\\n    }\\n\\n    function totalStakedAt(uint256 _blockNumber) public view override returns (uint256) {\\n        return token.totalSupply();\\n    }\\n\\n    function supportsHistory() external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    //------------------------Upgradeable------------------------\\n    /**\\n    * @dev Get StakerInfo structure by delegatecall\\n    */\\n    function delegateGetStakerInfo(address _target, bytes32 _staker)\\n        internal returns (StakerInfo memory result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, this.stakerInfo.selector, 1, _staker, 0);\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`\\n    function verifyState(address _testTarget) public override virtual {\\n        super.verifyState(_testTarget);\\n\\n        require(delegateGet(_testTarget, this.getStakersLength.selector) == stakers.length);\\n        if (stakers.length == 0) {\\n            return;\\n        }\\n        address stakerAddress = stakers[0];\\n        require(address(uint160(delegateGet(_testTarget, this.stakers.selector, 0))) == stakerAddress);\\n        StakerInfo storage info = stakerInfo[stakerAddress];\\n        bytes32 staker = bytes32(uint256(uint160(stakerAddress)));\\n        StakerInfo memory infoToCheck = delegateGetStakerInfo(_testTarget, staker);\\n        require(infoToCheck.value == info.value \\u0026\\u0026\\n            infoToCheck.vestingReleaseTimestamp == info.vestingReleaseTimestamp \\u0026\\u0026\\n            infoToCheck.vestingReleaseRate == info.vestingReleaseRate \\u0026\\u0026\\n            infoToCheck.stakingProvider == info.stakingProvider \\u0026\\u0026\\n            infoToCheck.flags == info.flags\\n        );\\n    }\\n\\n}\\n\"},\"UmbralDeserializer.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n\\n/**\\n* @notice Deserialization library for Umbral objects\\n*/\\nlibrary UmbralDeserializer {\\n\\n    struct Point {\\n        uint8 sign;\\n        uint256 xCoord;\\n    }\\n\\n    struct Capsule {\\n        Point pointE;\\n        Point pointV;\\n        uint256 bnSig;\\n    }\\n\\n    struct CorrectnessProof {\\n        Point pointE2;\\n        Point pointV2;\\n        Point pointKFragCommitment;\\n        Point pointKFragPok;\\n        uint256 bnSig;\\n        bytes kFragSignature; // 64 bytes\\n        bytes metadata; // any length\\n    }\\n\\n    struct CapsuleFrag {\\n        Point pointE1;\\n        Point pointV1;\\n        bytes32 kFragId;\\n        Point pointPrecursor;\\n        CorrectnessProof proof;\\n    }\\n\\n    struct PreComputedData {\\n        uint256 pointEyCoord;\\n        uint256 pointEZxCoord;\\n        uint256 pointEZyCoord;\\n        uint256 pointE1yCoord;\\n        uint256 pointE1HxCoord;\\n        uint256 pointE1HyCoord;\\n        uint256 pointE2yCoord;\\n        uint256 pointVyCoord;\\n        uint256 pointVZxCoord;\\n        uint256 pointVZyCoord;\\n        uint256 pointV1yCoord;\\n        uint256 pointV1HxCoord;\\n        uint256 pointV1HyCoord;\\n        uint256 pointV2yCoord;\\n        uint256 pointUZxCoord;\\n        uint256 pointUZyCoord;\\n        uint256 pointU1yCoord;\\n        uint256 pointU1HxCoord;\\n        uint256 pointU1HyCoord;\\n        uint256 pointU2yCoord;\\n        bytes32 hashedKFragValidityMessage;\\n        address alicesKeyAsAddress;\\n        bytes5  lostBytes;\\n    }\\n\\n    uint256 constant BIGNUM_SIZE = 32;\\n    uint256 constant POINT_SIZE = 33;\\n    uint256 constant SIGNATURE_SIZE = 64;\\n    uint256 constant CAPSULE_SIZE = 2 * POINT_SIZE + BIGNUM_SIZE;\\n    uint256 constant CORRECTNESS_PROOF_SIZE = 4 * POINT_SIZE + BIGNUM_SIZE + SIGNATURE_SIZE;\\n    uint256 constant CAPSULE_FRAG_SIZE = 3 * POINT_SIZE + BIGNUM_SIZE;\\n    uint256 constant FULL_CAPSULE_FRAG_SIZE = CAPSULE_FRAG_SIZE + CORRECTNESS_PROOF_SIZE;\\n    uint256 constant PRECOMPUTED_DATA_SIZE = (20 * BIGNUM_SIZE) + 32 + 20 + 5;\\n\\n    /**\\n    * @notice Deserialize to capsule (not activated)\\n    */\\n    function toCapsule(bytes memory _capsuleBytes)\\n        internal pure returns (Capsule memory capsule)\\n    {\\n        require(_capsuleBytes.length == CAPSULE_SIZE);\\n        uint256 pointer = getPointer(_capsuleBytes);\\n        pointer = copyPoint(pointer, capsule.pointE);\\n        pointer = copyPoint(pointer, capsule.pointV);\\n        capsule.bnSig = uint256(getBytes32(pointer));\\n    }\\n\\n    /**\\n    * @notice Deserialize to correctness proof\\n    * @param _pointer Proof bytes memory pointer\\n    * @param _proofBytesLength Proof bytes length\\n    */\\n    function toCorrectnessProof(uint256 _pointer, uint256 _proofBytesLength)\\n        internal pure returns (CorrectnessProof memory proof)\\n    {\\n        require(_proofBytesLength \\u003e= CORRECTNESS_PROOF_SIZE);\\n\\n        _pointer = copyPoint(_pointer, proof.pointE2);\\n        _pointer = copyPoint(_pointer, proof.pointV2);\\n        _pointer = copyPoint(_pointer, proof.pointKFragCommitment);\\n        _pointer = copyPoint(_pointer, proof.pointKFragPok);\\n        proof.bnSig = uint256(getBytes32(_pointer));\\n        _pointer += BIGNUM_SIZE;\\n\\n        proof.kFragSignature = new bytes(SIGNATURE_SIZE);\\n        // TODO optimize, just two mload-\\u003emstore (#1500)\\n        _pointer = copyBytes(_pointer, proof.kFragSignature, SIGNATURE_SIZE);\\n        if (_proofBytesLength \\u003e CORRECTNESS_PROOF_SIZE) {\\n            proof.metadata = new bytes(_proofBytesLength - CORRECTNESS_PROOF_SIZE);\\n            copyBytes(_pointer, proof.metadata, proof.metadata.length);\\n        }\\n    }\\n\\n    /**\\n    * @notice Deserialize to correctness proof\\n    */\\n    function toCorrectnessProof(bytes memory _proofBytes)\\n        internal pure returns (CorrectnessProof memory proof)\\n    {\\n        uint256 pointer = getPointer(_proofBytes);\\n        return toCorrectnessProof(pointer, _proofBytes.length);\\n    }\\n\\n    /**\\n    * @notice Deserialize to CapsuleFrag\\n    */\\n    function toCapsuleFrag(bytes memory _cFragBytes)\\n        internal pure returns (CapsuleFrag memory cFrag)\\n    {\\n        uint256 cFragBytesLength = _cFragBytes.length;\\n        require(cFragBytesLength \\u003e= FULL_CAPSULE_FRAG_SIZE);\\n\\n        uint256 pointer = getPointer(_cFragBytes);\\n        pointer = copyPoint(pointer, cFrag.pointE1);\\n        pointer = copyPoint(pointer, cFrag.pointV1);\\n        cFrag.kFragId = getBytes32(pointer);\\n        pointer += BIGNUM_SIZE;\\n        pointer = copyPoint(pointer, cFrag.pointPrecursor);\\n\\n        cFrag.proof = toCorrectnessProof(pointer, cFragBytesLength - CAPSULE_FRAG_SIZE);\\n    }\\n\\n    /**\\n    * @notice Deserialize to precomputed data\\n    */\\n    function toPreComputedData(bytes memory _preComputedData)\\n        internal pure returns (PreComputedData memory data)\\n    {\\n        require(_preComputedData.length == PRECOMPUTED_DATA_SIZE);\\n        uint256 initial_pointer = getPointer(_preComputedData);\\n        uint256 pointer = initial_pointer;\\n\\n        data.pointEyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointEZxCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointEZyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointE1yCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointE1HxCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointE1HyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointE2yCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointVyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointVZxCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointVZyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointV1yCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointV1HxCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointV1HyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointV2yCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointUZxCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointUZyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointU1yCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointU1HxCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointU1HyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointU2yCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.hashedKFragValidityMessage = getBytes32(pointer);\\n        pointer += 32;\\n\\n        data.alicesKeyAsAddress = address(bytes20(getBytes32(pointer)));\\n        pointer += 20;\\n\\n        // Lost bytes: a bytes5 variable holding the following byte values:\\n        //     0: kfrag signature recovery value v\\n        //     1: cfrag signature recovery value v\\n        //     2: metadata signature recovery value v\\n        //     3: specification signature recovery value v\\n        //     4: ursula pubkey sign byte\\n        data.lostBytes = bytes5(getBytes32(pointer));\\n        pointer += 5;\\n\\n        require(pointer == initial_pointer + PRECOMPUTED_DATA_SIZE);\\n    }\\n\\n    // TODO extract to external library if needed (#1500)\\n    /**\\n    * @notice Get the memory pointer for start of array\\n    */\\n    function getPointer(bytes memory _bytes) internal pure returns (uint256 pointer) {\\n        assembly {\\n            pointer := add(_bytes, 32) // skip array length\\n        }\\n    }\\n\\n    /**\\n    * @notice Copy point data from memory in the pointer position\\n    */\\n    function copyPoint(uint256 _pointer, Point memory _point)\\n        internal pure returns (uint256 resultPointer)\\n    {\\n        // TODO optimize, copy to point memory directly (#1500)\\n        uint8 temp;\\n        uint256 xCoord;\\n        assembly {\\n            temp := byte(0, mload(_pointer))\\n            xCoord := mload(add(_pointer, 1))\\n        }\\n        _point.sign = temp;\\n        _point.xCoord = xCoord;\\n        resultPointer = _pointer + POINT_SIZE;\\n    }\\n\\n    /**\\n    * @notice Read 1 byte from memory in the pointer position\\n    */\\n    function getByte(uint256 _pointer) internal pure returns (bytes1 result) {\\n        bytes32 word;\\n        assembly {\\n            word := mload(_pointer)\\n        }\\n        result = word[0];\\n        return result;\\n    }\\n\\n    /**\\n    * @notice Read 32 bytes from memory in the pointer position\\n    */\\n    function getBytes32(uint256 _pointer) internal pure returns (bytes32 result) {\\n        assembly {\\n            result := mload(_pointer)\\n        }\\n    }\\n\\n    /**\\n    * @notice Copy bytes from the source pointer to the target array\\n    * @dev Assumes that enough memory has been allocated to store in target.\\n    * Also assumes that \\u0027_target\\u0027 was the last thing that was allocated\\n    * @param _bytesPointer Source memory pointer\\n    * @param _target Target array\\n    * @param _bytesLength Number of bytes to copy\\n    */\\n    function copyBytes(uint256 _bytesPointer, bytes memory _target, uint256 _bytesLength)\\n        internal\\n        pure\\n        returns (uint256 resultPointer)\\n    {\\n        // Exploiting the fact that \\u0027_target\\u0027 was the last thing to be allocated,\\n        // we can write entire words, and just overwrite any excess.\\n        assembly {\\n            // evm operations on words\\n            let words := div(add(_bytesLength, 31), 32)\\n            let source := _bytesPointer\\n            let destination := add(_target, 32)\\n            for\\n                { let i := 0 } // start at arr + 32 -\\u003e first byte corresponds to length\\n                lt(i, words)\\n                { i := add(i, 1) }\\n            {\\n                let offset := mul(i, 32)\\n                mstore(add(destination, offset), mload(add(source, offset)))\\n            }\\n            mstore(add(_target, add(32, mload(_target))), 0)\\n        }\\n        resultPointer = _bytesPointer + _bytesLength;\\n    }\\n\\n}\\n\"},\"Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n\\nimport \\\"Ownable.sol\\\";\\n\\n\\n/**\\n* @notice Base contract for upgradeable contract\\n* @dev Inherited contract should implement verifyState(address) method by checking storage variables\\n* (see verifyState(address) in Dispatcher). Also contract should implement finishUpgrade(address)\\n* if it is using constructor parameters by coping this parameters to the dispatcher storage\\n*/\\nabstract contract Upgradeable is Ownable {\\n\\n    event StateVerified(address indexed testTarget, address sender);\\n    event UpgradeFinished(address indexed target, address sender);\\n\\n    /**\\n    * @dev Contracts at the target must reserve the same location in storage for this address as in Dispatcher\\n    * Stored data actually lives in the Dispatcher\\n    * However the storage layout is specified here in the implementing contracts\\n    */\\n    address public target;\\n\\n    /**\\n    * @dev Previous contract address (if available). Used for rollback\\n    */\\n    address public previousTarget;\\n\\n    /**\\n    * @dev Upgrade status. Explicit `uint8` type is used instead of `bool` to save gas by excluding 0 value\\n    */\\n    uint8 public isUpgrade;\\n\\n    /**\\n    * @dev Guarantees that next slot will be separated from the previous\\n    */\\n    uint256 stubSlot;\\n\\n    /**\\n    * @dev Constants for `isUpgrade` field\\n    */\\n    uint8 constant UPGRADE_FALSE = 1;\\n    uint8 constant UPGRADE_TRUE = 2;\\n\\n    /**\\n    * @dev Checks that function executed while upgrading\\n    * Recommended to add to `verifyState` and `finishUpgrade` methods\\n    */\\n    modifier onlyWhileUpgrading()\\n    {\\n        require(isUpgrade == UPGRADE_TRUE);\\n        _;\\n    }\\n\\n    /**\\n    * @dev Method for verifying storage state.\\n    * Should check that new target contract returns right storage value\\n    */\\n    function verifyState(address _testTarget) public virtual onlyWhileUpgrading {\\n        emit StateVerified(_testTarget, msg.sender);\\n    }\\n\\n    /**\\n    * @dev Copy values from the new target to the current storage\\n    * @param _target New target contract address\\n    */\\n    function finishUpgrade(address _target) public virtual onlyWhileUpgrading {\\n        emit UpgradeFinished(_target, msg.sender);\\n    }\\n\\n    /**\\n    * @dev Base method to get data\\n    * @param _target Target to call\\n    * @param _selector Method selector\\n    * @param _numberOfArguments Number of used arguments\\n    * @param _argument1 First method argument\\n    * @param _argument2 Second method argument\\n    * @return memoryAddress Address in memory where the data is located\\n    */\\n    function delegateGetData(\\n        address _target,\\n        bytes4 _selector,\\n        uint8 _numberOfArguments,\\n        bytes32 _argument1,\\n        bytes32 _argument2\\n    )\\n        internal returns (bytes32 memoryAddress)\\n    {\\n        assembly {\\n            memoryAddress := mload(0x40)\\n            mstore(memoryAddress, _selector)\\n            if gt(_numberOfArguments, 0) {\\n                mstore(add(memoryAddress, 0x04), _argument1)\\n            }\\n            if gt(_numberOfArguments, 1) {\\n                mstore(add(memoryAddress, 0x24), _argument2)\\n            }\\n            switch delegatecall(gas(), _target, memoryAddress, add(0x04, mul(0x20, _numberOfArguments)), 0, 0)\\n                case 0 {\\n                    revert(memoryAddress, 0)\\n                }\\n                default {\\n                    returndatacopy(memoryAddress, 0x0, returndatasize())\\n                }\\n        }\\n    }\\n\\n    /**\\n    * @dev Call \\\"getter\\\" without parameters.\\n    * Result should not exceed 32 bytes\\n    */\\n    function delegateGet(address _target, bytes4 _selector)\\n        internal returns (uint256 result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, _selector, 0, 0, 0);\\n        assembly {\\n            result := mload(memoryAddress)\\n        }\\n    }\\n\\n    /**\\n    * @dev Call \\\"getter\\\" with one parameter.\\n    * Result should not exceed 32 bytes\\n    */\\n    function delegateGet(address _target, bytes4 _selector, bytes32 _argument)\\n        internal returns (uint256 result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, _selector, 1, _argument, 0);\\n        assembly {\\n            result := mload(memoryAddress)\\n        }\\n    }\\n\\n    /**\\n    * @dev Call \\\"getter\\\" with two parameters.\\n    * Result should not exceed 32 bytes\\n    */\\n    function delegateGet(\\n        address _target,\\n        bytes4 _selector,\\n        bytes32 _argument1,\\n        bytes32 _argument2\\n    )\\n        internal returns (uint256 result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, _selector, 2, _argument1, _argument2);\\n        assembly {\\n            result := mload(memoryAddress)\\n        }\\n    }\\n}\\n\"},\"WorkLock.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0; // TODO use 0.7.x version and revert changes ?\\n\\n\\nimport \\\"SafeMath.sol\\\";\\nimport \\\"SafeERC20.sol\\\";\\nimport \\\"Address.sol\\\";\\nimport \\\"Ownable.sol\\\";\\nimport \\\"NuCypherToken.sol\\\";\\nimport \\\"IStakingEscrow.sol\\\";\\nimport \\\"AdditionalMath.sol\\\";\\n\\n\\n/**\\n* @notice The WorkLock distribution contract\\n*/\\ncontract WorkLock is Ownable {\\n    using SafeERC20 for NuCypherToken;\\n    using SafeMath for uint256;\\n    using AdditionalMath for uint256;\\n    using Address for address payable;\\n    using Address for address;\\n\\n    event Deposited(address indexed sender, uint256 value);\\n    event Bid(address indexed sender, uint256 depositedETH);\\n    event Claimed(address indexed sender, uint256 claimedTokens);\\n    event Refund(address indexed sender, uint256 refundETH, uint256 completedWork);\\n    event Canceled(address indexed sender, uint256 value);\\n    event BiddersChecked(address indexed sender, uint256 startIndex, uint256 endIndex);\\n    event ForceRefund(address indexed sender, address indexed bidder, uint256 refundETH);\\n    event CompensationWithdrawn(address indexed sender, uint256 value);\\n    event Shutdown(address indexed sender);\\n\\n    struct WorkInfo {\\n        uint256 depositedETH;\\n        uint256 completedWork;\\n        bool claimed;\\n        uint128 index;\\n    }\\n\\n    uint16 public constant SLOWING_REFUND = 100;\\n    uint256 private constant MAX_ETH_SUPPLY = 2e10 ether;\\n\\n    NuCypherToken public immutable token;\\n    IStakingEscrow public immutable escrow;\\n\\n    /*\\n    * @dev WorkLock calculations:\\n    * bid = minBid + bonusETHPart\\n    * bonusTokenSupply = tokenSupply - bidders.length * minAllowableLockedTokens\\n    * bonusDepositRate = bonusTokenSupply / bonusETHSupply\\n    * claimedTokens = minAllowableLockedTokens + bonusETHPart * bonusDepositRate\\n    * bonusRefundRate = bonusDepositRate * SLOWING_REFUND / boostingRefund\\n    * refundETH = completedWork / refundRate\\n    */\\n    uint256 public immutable boostingRefund;\\n    uint256 public immutable minAllowedBid;\\n    uint16 public immutable stakingPeriods;\\n    // copy from the escrow contract\\n    uint256 public immutable maxAllowableLockedTokens;\\n    uint256 public immutable minAllowableLockedTokens;\\n\\n    uint256 public tokenSupply;\\n    uint256 public startBidDate;\\n    uint256 public endBidDate;\\n    uint256 public endCancellationDate;\\n\\n    uint256 public bonusETHSupply;\\n    mapping(address =\\u003e WorkInfo) public workInfo;\\n    mapping(address =\\u003e uint256) public compensation;\\n\\n    address[] public bidders;\\n    // if value == bidders.length then WorkLock is fully checked\\n    uint256 public nextBidderToCheck;\\n\\n    /**\\n    * @dev Checks timestamp regarding cancellation window\\n    */\\n    modifier afterCancellationWindow()\\n    {\\n        require(block.timestamp \\u003e= endCancellationDate,\\n            \\\"Operation is allowed when cancellation phase is over\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @param _token Token contract\\n    * @param _escrow Escrow contract\\n    * @param _startBidDate Timestamp when bidding starts\\n    * @param _endBidDate Timestamp when bidding will end\\n    * @param _endCancellationDate Timestamp when cancellation will ends\\n    * @param _boostingRefund Coefficient to boost refund ETH\\n    * @param _stakingPeriods Amount of periods during which tokens will be locked after claiming\\n    * @param _minAllowedBid Minimum allowed ETH amount for bidding\\n    */\\n    constructor(\\n        NuCypherToken _token,\\n        IStakingEscrow _escrow,\\n        uint256 _startBidDate,\\n        uint256 _endBidDate,\\n        uint256 _endCancellationDate,\\n        uint256 _boostingRefund,\\n        uint16 _stakingPeriods,\\n        uint256 _minAllowedBid\\n    ) {\\n        uint256 totalSupply = _token.totalSupply();\\n        require(totalSupply \\u003e 0 \\u0026\\u0026                              // token contract is deployed and accessible\\n            _escrow.secondsPerPeriod() \\u003e 0 \\u0026\\u0026                   // escrow contract is deployed and accessible\\n            _escrow.token() == _token \\u0026\\u0026                        // same token address for worklock and escrow\\n            _endBidDate \\u003e _startBidDate \\u0026\\u0026                      // bidding period lasts some time\\n            _endBidDate \\u003e block.timestamp \\u0026\\u0026                    // there is time to make a bid\\n            _endCancellationDate \\u003e= _endBidDate \\u0026\\u0026              // cancellation window includes bidding\\n            _minAllowedBid \\u003e 0 \\u0026\\u0026                               // min allowed bid was set\\n            _boostingRefund \\u003e 0 \\u0026\\u0026                              // boosting coefficient was set\\n            _stakingPeriods \\u003e= _escrow.minLockedPeriods());     // staking duration is consistent with escrow contract\\n        // worst case for `ethToWork()` and `workToETH()`,\\n        // when ethSupply == MAX_ETH_SUPPLY and tokenSupply == totalSupply\\n        require(MAX_ETH_SUPPLY * totalSupply * SLOWING_REFUND / MAX_ETH_SUPPLY / totalSupply == SLOWING_REFUND \\u0026\\u0026\\n            MAX_ETH_SUPPLY * totalSupply * _boostingRefund / MAX_ETH_SUPPLY / totalSupply == _boostingRefund);\\n\\n        token = _token;\\n        escrow = _escrow;\\n        startBidDate = _startBidDate;\\n        endBidDate = _endBidDate;\\n        endCancellationDate = _endCancellationDate;\\n        boostingRefund = _boostingRefund;\\n        stakingPeriods = _stakingPeriods;\\n        minAllowedBid = _minAllowedBid;\\n        maxAllowableLockedTokens = _escrow.maxAllowableLockedTokens();\\n        minAllowableLockedTokens = _escrow.minAllowableLockedTokens();\\n    }\\n\\n    /**\\n    * @notice Deposit tokens to contract\\n    * @param _value Amount of tokens to transfer\\n    */\\n    function tokenDeposit(uint256 _value) external {\\n        require(block.timestamp \\u003c endBidDate, \\\"Can\\u0027t deposit more tokens after end of bidding\\\");\\n        token.safeTransferFrom(msg.sender, address(this), _value);\\n        tokenSupply += _value;\\n        emit Deposited(msg.sender, _value);\\n    }\\n\\n    /**\\n    * @notice Calculate amount of tokens that will be get for specified amount of ETH\\n    * @dev This value will be fixed only after end of bidding\\n    */\\n    function ethToTokens(uint256 _ethAmount) public view returns (uint256) {\\n        if (_ethAmount \\u003c minAllowedBid) {\\n            return 0;\\n        }\\n\\n        // when all participants bid with the same minimum amount of eth\\n        if (bonusETHSupply == 0) {\\n            return tokenSupply / bidders.length;\\n        }\\n\\n        uint256 bonusETH = _ethAmount - minAllowedBid;\\n        uint256 bonusTokenSupply = tokenSupply - bidders.length * minAllowableLockedTokens;\\n        return minAllowableLockedTokens + bonusETH.mul(bonusTokenSupply).div(bonusETHSupply);\\n    }\\n\\n    /**\\n    * @notice Calculate amount of work that need to be done to refund specified amount of ETH\\n    */\\n    function ethToWork(uint256 _ethAmount, uint256 _tokenSupply, uint256 _ethSupply)\\n        internal view returns (uint256)\\n    {\\n        return _ethAmount.mul(_tokenSupply).mul(SLOWING_REFUND).divCeil(_ethSupply.mul(boostingRefund));\\n    }\\n\\n    /**\\n    * @notice Calculate amount of work that need to be done to refund specified amount of ETH\\n    * @dev This value will be fixed only after end of bidding\\n    * @param _ethToReclaim Specified sum of ETH staker wishes to reclaim following completion of work\\n    * @param _restOfDepositedETH Remaining ETH in staker\\u0027s deposit once ethToReclaim sum has been subtracted\\n    * @dev _ethToReclaim + _restOfDepositedETH = depositedETH\\n    */\\n    function ethToWork(uint256 _ethToReclaim, uint256 _restOfDepositedETH) internal view returns (uint256) {\\n\\n        uint256 baseETHSupply = bidders.length * minAllowedBid;\\n        // when all participants bid with the same minimum amount of eth\\n        if (bonusETHSupply == 0) {\\n            return ethToWork(_ethToReclaim, tokenSupply, baseETHSupply);\\n        }\\n\\n        uint256 baseETH = 0;\\n        uint256 bonusETH = 0;\\n\\n        // If the staker\\u0027s total remaining deposit (including the specified sum of ETH to reclaim)\\n        // is lower than the minimum bid size,\\n        // then only the base part is used to calculate the work required to reclaim ETH\\n        if (_ethToReclaim + _restOfDepositedETH \\u003c= minAllowedBid) {\\n            baseETH = _ethToReclaim;\\n\\n        // If the staker\\u0027s remaining deposit (not including the specified sum of ETH to reclaim)\\n        // is still greater than the minimum bid size,\\n        // then only the bonus part is used to calculate the work required to reclaim ETH\\n        } else if (_restOfDepositedETH \\u003e= minAllowedBid) {\\n            bonusETH = _ethToReclaim;\\n\\n        // If the staker\\u0027s remaining deposit (not including the specified sum of ETH to reclaim)\\n        // is lower than the minimum bid size,\\n        // then both the base and bonus parts must be used to calculate the work required to reclaim ETH\\n        } else {\\n            bonusETH = _ethToReclaim + _restOfDepositedETH - minAllowedBid;\\n            baseETH = _ethToReclaim - bonusETH;\\n        }\\n\\n        uint256 baseTokenSupply = bidders.length * minAllowableLockedTokens;\\n        uint256 work = 0;\\n        if (baseETH \\u003e 0) {\\n            work = ethToWork(baseETH, baseTokenSupply, baseETHSupply);\\n        }\\n\\n        if (bonusETH \\u003e 0) {\\n            uint256 bonusTokenSupply = tokenSupply - baseTokenSupply;\\n            work += ethToWork(bonusETH, bonusTokenSupply, bonusETHSupply);\\n        }\\n\\n        return work;\\n    }\\n\\n    /**\\n    * @notice Calculate amount of work that need to be done to refund specified amount of ETH\\n    * @dev This value will be fixed only after end of bidding\\n    */\\n    function ethToWork(uint256 _ethAmount) public view returns (uint256) {\\n        return ethToWork(_ethAmount, 0);\\n    }\\n\\n    /**\\n    * @notice Calculate amount of ETH that will be refund for completing specified amount of work\\n    */\\n    function workToETH(uint256 _completedWork, uint256 _ethSupply, uint256 _tokenSupply)\\n        internal view returns (uint256)\\n    {\\n        return _completedWork.mul(_ethSupply).mul(boostingRefund).div(_tokenSupply.mul(SLOWING_REFUND));\\n    }\\n\\n    /**\\n    * @notice Calculate amount of ETH that will be refund for completing specified amount of work\\n    * @dev This value will be fixed only after end of bidding\\n    */\\n    function workToETH(uint256 _completedWork, uint256 _depositedETH) public view returns (uint256) {\\n        uint256 baseETHSupply = bidders.length * minAllowedBid;\\n        // when all participants bid with the same minimum amount of eth\\n        if (bonusETHSupply == 0) {\\n            return workToETH(_completedWork, baseETHSupply, tokenSupply);\\n        }\\n\\n        uint256 bonusWork = 0;\\n        uint256 bonusETH = 0;\\n        uint256 baseTokenSupply = bidders.length * minAllowableLockedTokens;\\n\\n        if (_depositedETH \\u003e minAllowedBid) {\\n            bonusETH = _depositedETH - minAllowedBid;\\n            uint256 bonusTokenSupply = tokenSupply - baseTokenSupply;\\n            bonusWork = ethToWork(bonusETH, bonusTokenSupply, bonusETHSupply);\\n\\n            if (_completedWork \\u003c= bonusWork) {\\n                return workToETH(_completedWork, bonusETHSupply, bonusTokenSupply);\\n            }\\n        }\\n\\n        _completedWork -= bonusWork;\\n        return bonusETH + workToETH(_completedWork, baseETHSupply, baseTokenSupply);\\n    }\\n\\n    /**\\n    * @notice Get remaining work to full refund\\n    */\\n    function getRemainingWork(address _bidder) external view returns (uint256) {\\n        WorkInfo storage info = workInfo[_bidder];\\n        uint256 completedWork = escrow.getCompletedWork(_bidder).sub(info.completedWork);\\n        uint256 remainingWork = ethToWork(info.depositedETH);\\n        if (remainingWork \\u003c= completedWork) {\\n            return 0;\\n        }\\n        return remainingWork - completedWork;\\n    }\\n\\n    /**\\n    * @notice Get length of bidders array\\n    */\\n    function getBiddersLength() external view returns (uint256) {\\n        return bidders.length;\\n    }\\n\\n    /**\\n    * @notice Bid for tokens by transferring ETH\\n    */\\n    function bid() external payable {\\n        require(block.timestamp \\u003e= startBidDate, \\\"Bidding is not open yet\\\");\\n        require(block.timestamp \\u003c endBidDate, \\\"Bidding is already finished\\\");\\n        WorkInfo storage info = workInfo[msg.sender];\\n\\n        // first bid\\n        if (info.depositedETH == 0) {\\n            require(msg.value \\u003e= minAllowedBid, \\\"Bid must be at least minimum\\\");\\n            require(bidders.length \\u003c tokenSupply / minAllowableLockedTokens, \\\"Not enough tokens for more bidders\\\");\\n            info.index = uint128(bidders.length);\\n            bidders.push(msg.sender);\\n            bonusETHSupply = bonusETHSupply.add(msg.value - minAllowedBid);\\n        } else {\\n            bonusETHSupply = bonusETHSupply.add(msg.value);\\n        }\\n\\n        info.depositedETH = info.depositedETH.add(msg.value);\\n        emit Bid(msg.sender, msg.value);\\n    }\\n\\n    /**\\n    * @notice Cancel bid and refund deposited ETH\\n    */\\n    function cancelBid() external {\\n        require(block.timestamp \\u003c endCancellationDate,\\n            \\\"Cancellation allowed only during cancellation window\\\");\\n        WorkInfo storage info = workInfo[msg.sender];\\n        require(info.depositedETH \\u003e 0, \\\"No bid to cancel\\\");\\n        require(!info.claimed, \\\"Tokens are already claimed\\\");\\n        uint256 refundETH = info.depositedETH;\\n        info.depositedETH = 0;\\n\\n        // remove from bidders array, move last bidder to the empty place\\n        uint256 lastIndex = bidders.length - 1;\\n        if (info.index != lastIndex) {\\n            address lastBidder = bidders[lastIndex];\\n            bidders[info.index] = lastBidder;\\n            workInfo[lastBidder].index = info.index;\\n        }\\n        bidders.pop();\\n\\n        if (refundETH \\u003e minAllowedBid) {\\n            bonusETHSupply = bonusETHSupply.sub(refundETH - minAllowedBid);\\n        }\\n        payable(msg.sender).sendValue(refundETH);\\n        emit Canceled(msg.sender, refundETH);\\n    }\\n\\n    /**\\n    * @notice Cancels distribution, makes possible to retrieve all bids and owner gets all tokens\\n    */\\n    function shutdown() external onlyOwner {\\n        require(!isClaimingAvailable(), \\\"Claiming has already been enabled\\\");\\n        internalShutdown();\\n    }\\n\\n    /**\\n    * @notice Cancels distribution, makes possible to retrieve all bids and owner gets all tokens\\n    */\\n    function internalShutdown() internal {\\n        startBidDate = 0;\\n        endBidDate = 0;\\n        endCancellationDate = type(uint256).max; // \\\"infinite\\\" cancellation window\\n        token.safeTransfer(owner(), tokenSupply);\\n        emit Shutdown(msg.sender);\\n    }\\n\\n    /**\\n    * @notice Make force refund to bidders who can get tokens more than maximum allowed\\n    * @param _biddersForRefund Sorted list of unique bidders. Only bidders who must receive a refund\\n    */\\n    function forceRefund(address payable[] calldata _biddersForRefund) external afterCancellationWindow {\\n        require(nextBidderToCheck != bidders.length, \\\"Bidders have already been checked\\\");\\n\\n        uint256 length = _biddersForRefund.length;\\n        require(length \\u003e 0, \\\"Must be at least one bidder for a refund\\\");\\n\\n        uint256 minNumberOfBidders = tokenSupply.divCeil(maxAllowableLockedTokens);\\n        if (bidders.length \\u003c minNumberOfBidders) {\\n            internalShutdown();\\n            return;\\n        }\\n\\n        address previousBidder = _biddersForRefund[0];\\n        uint256 minBid = workInfo[previousBidder].depositedETH;\\n        uint256 maxBid = minBid;\\n\\n        // get minimum and maximum bids\\n        for (uint256 i = 1; i \\u003c length; i++) {\\n            address bidder = _biddersForRefund[i];\\n            uint256 depositedETH = workInfo[bidder].depositedETH;\\n            require(bidder \\u003e previousBidder \\u0026\\u0026 depositedETH \\u003e 0, \\\"Addresses must be an array of unique bidders\\\");\\n            if (minBid \\u003e depositedETH) {\\n                minBid = depositedETH;\\n            } else if (maxBid \\u003c depositedETH) {\\n                maxBid = depositedETH;\\n            }\\n            previousBidder = bidder;\\n        }\\n\\n        uint256[] memory refunds = new uint256[](length);\\n        // first step - align at a minimum bid\\n        if (minBid != maxBid) {\\n            for (uint256 i = 0; i \\u003c length; i++) {\\n                address bidder = _biddersForRefund[i];\\n                WorkInfo storage info = workInfo[bidder];\\n                if (info.depositedETH \\u003e minBid) {\\n                    refunds[i] = info.depositedETH - minBid;\\n                    info.depositedETH = minBid;\\n                    bonusETHSupply -= refunds[i];\\n                }\\n            }\\n        }\\n\\n        require(ethToTokens(minBid) \\u003e maxAllowableLockedTokens,\\n            \\\"At least one of bidders has allowable bid\\\");\\n\\n        // final bids adjustment (only for bonus part)\\n        // (min_whale_bid * token_supply - max_stake * eth_supply) / (token_supply - max_stake * n_whales)\\n        uint256 maxBonusTokens = maxAllowableLockedTokens - minAllowableLockedTokens;\\n        uint256 minBonusETH = minBid - minAllowedBid;\\n        uint256 bonusTokenSupply = tokenSupply - bidders.length * minAllowableLockedTokens;\\n        uint256 refundETH = minBonusETH.mul(bonusTokenSupply)\\n                                .sub(maxBonusTokens.mul(bonusETHSupply))\\n                                .divCeil(bonusTokenSupply - maxBonusTokens.mul(length));\\n        uint256 resultBid = minBid.sub(refundETH);\\n        bonusETHSupply -= length * refundETH;\\n        for (uint256 i = 0; i \\u003c length; i++) {\\n            address bidder = _biddersForRefund[i];\\n            WorkInfo storage info = workInfo[bidder];\\n            refunds[i] += refundETH;\\n            info.depositedETH = resultBid;\\n        }\\n\\n        // reset verification\\n        nextBidderToCheck = 0;\\n\\n        // save a refund\\n        for (uint256 i = 0; i \\u003c length; i++) {\\n            address bidder = _biddersForRefund[i];\\n            compensation[bidder] += refunds[i];\\n            emit ForceRefund(msg.sender, bidder, refunds[i]);\\n        }\\n\\n    }\\n\\n    /**\\n    * @notice Withdraw compensation after force refund\\n    */\\n    function withdrawCompensation() external {\\n        uint256 refund = compensation[msg.sender];\\n        require(refund \\u003e 0, \\\"There is no compensation\\\");\\n        compensation[msg.sender] = 0;\\n        payable(msg.sender).sendValue(refund);\\n        emit CompensationWithdrawn(msg.sender, refund);\\n    }\\n\\n    /**\\n    * @notice Check that the claimed tokens are within `maxAllowableLockedTokens` for all participants,\\n    * starting from the last point `nextBidderToCheck`\\n    * @dev Method stops working when the remaining gas is less than `_gasToSaveState`\\n    * and saves the state in `nextBidderToCheck`.\\n    * If all bidders have been checked then `nextBidderToCheck` will be equal to the length of the bidders array\\n    */\\n    function verifyBiddingCorrectness(uint256 _gasToSaveState) external afterCancellationWindow returns (uint256) {\\n        require(nextBidderToCheck != bidders.length, \\\"Bidders have already been checked\\\");\\n\\n        // all participants bid with the same minimum amount of eth\\n        uint256 index = nextBidderToCheck;\\n        if (bonusETHSupply == 0) {\\n            require(tokenSupply / bidders.length \\u003c= maxAllowableLockedTokens, \\\"Not enough bidders\\\");\\n            index = bidders.length;\\n        }\\n\\n        uint256 maxBonusTokens = maxAllowableLockedTokens - minAllowableLockedTokens;\\n        uint256 bonusTokenSupply = tokenSupply - bidders.length * minAllowableLockedTokens;\\n        uint256 maxBidFromMaxStake = minAllowedBid + maxBonusTokens.mul(bonusETHSupply).div(bonusTokenSupply);\\n\\n\\n        while (index \\u003c bidders.length \\u0026\\u0026 gasleft() \\u003e _gasToSaveState) {\\n            address bidder = bidders[index];\\n            require(workInfo[bidder].depositedETH \\u003c= maxBidFromMaxStake, \\\"Bid is greater than max allowable bid\\\");\\n            index++;\\n        }\\n\\n        if (index != nextBidderToCheck) {\\n            emit BiddersChecked(msg.sender, nextBidderToCheck, index);\\n            nextBidderToCheck = index;\\n        }\\n        return nextBidderToCheck;\\n    }\\n\\n    /**\\n    * @notice Checks if claiming available\\n    */\\n    function isClaimingAvailable() public view returns (bool) {\\n        return block.timestamp \\u003e= endCancellationDate \\u0026\\u0026\\n            nextBidderToCheck == bidders.length;\\n    }\\n\\n    /**\\n    * @notice Claimed tokens will be deposited and locked as stake in the StakingEscrow contract.\\n    */\\n    function claim() external returns (uint256 claimedTokens) {\\n        require(isClaimingAvailable(), \\\"Claiming has not been enabled yet\\\");\\n        WorkInfo storage info = workInfo[msg.sender];\\n        require(!info.claimed, \\\"Tokens are already claimed\\\");\\n        claimedTokens = ethToTokens(info.depositedETH);\\n        require(claimedTokens \\u003e 0, \\\"Nothing to claim\\\");\\n\\n        info.claimed = true;\\n        token.approve(address(escrow), claimedTokens);\\n        escrow.depositFromWorkLock(msg.sender, claimedTokens, stakingPeriods);\\n        info.completedWork = escrow.setWorkMeasurement(msg.sender, true);\\n        emit Claimed(msg.sender, claimedTokens);\\n    }\\n\\n    /**\\n    * @notice Get available refund for bidder\\n    */\\n    function getAvailableRefund(address _bidder) public view returns (uint256) {\\n        WorkInfo storage info = workInfo[_bidder];\\n        // nothing to refund\\n        if (info.depositedETH == 0) {\\n            return 0;\\n        }\\n\\n        uint256 currentWork = escrow.getCompletedWork(_bidder);\\n        uint256 completedWork = currentWork.sub(info.completedWork);\\n        // no work that has been completed since last refund\\n        if (completedWork == 0) {\\n            return 0;\\n        }\\n\\n        uint256 refundETH = workToETH(completedWork, info.depositedETH);\\n        if (refundETH \\u003e info.depositedETH) {\\n            refundETH = info.depositedETH;\\n        }\\n        return refundETH;\\n    }\\n\\n    /**\\n    * @notice Refund ETH for the completed work\\n    */\\n    function refund() external returns (uint256 refundETH) {\\n        WorkInfo storage info = workInfo[msg.sender];\\n        require(info.claimed, \\\"Tokens must be claimed before refund\\\");\\n        refundETH = getAvailableRefund(msg.sender);\\n        require(refundETH \\u003e 0, \\\"Nothing to refund: there is no ETH to refund or no completed work\\\");\\n\\n        if (refundETH == info.depositedETH) {\\n            escrow.setWorkMeasurement(msg.sender, false);\\n        }\\n        info.depositedETH = info.depositedETH.sub(refundETH);\\n        // convert refund back to work to eliminate potential rounding errors\\n        uint256 completedWork = ethToWork(refundETH, info.depositedETH);\\n\\n        info.completedWork = info.completedWork.add(completedWork);\\n        emit Refund(msg.sender, refundETH, completedWork);\\n        payable(msg.sender).sendValue(refundETH);\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract NuCypherToken\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract WorkLockInterface\",\"name\":\"_workLock\",\"type\":\"address\"},{\"internalType\":\"contract IStaking\",\"name\":\"_tStaking\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakingProvider\",\"type\":\"address\"}],\"name\":\"MergeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investigator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Slashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"testTarget\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"StateVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"UpgradeFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"releaseTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"releaseRate\",\"type\":\"uint256\"}],\"name\":\"VestingSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"currentPeriodSupply\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_unlockingDuration\",\"type\":\"uint16\"}],\"name\":\"depositFromWorkLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"finishUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getAllTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getCompletedWork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getUnvestedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isUpgrade\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousTarget\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingProvider\",\"type\":\"address\"}],\"name\":\"requestMerge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_measureWork\",\"type\":\"bool\"}],\"name\":\"setWorkMeasurement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_stakers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_releaseTimestamp\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_releaseRate\",\"type\":\"uint256[]\"}],\"name\":\"setupVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_penalty\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_investigator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"slashStaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"stub1\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"stub2\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"lastCommittedPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"stub4\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"stub5\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"stub6\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"stub7\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingReleaseTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingReleaseRate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stakingProvider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reservedSlot4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedSlot5\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supportsHistory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tStaking\",\"outputs\":[{\"internalType\":\"contract IStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract NuCypherToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"totalStakedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"totalStakedForAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_testTarget\",\"type\":\"address\"}],\"name\":\"verifyState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"workLock\",\"outputs\":[{\"internalType\":\"contract WorkLockInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StakingEscrow", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004fe83213d56308330ec302a8bd641f1d0113a4cc000000000000000000000000e9778e69a961e64d3cdbb34cf6778281d34667c200000000000000000000000001b67b1194c75264d06f808a921228a95c765dd7", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://42442db273f6803e150cce268dee8abcbec97463768b899459abaefde046e339"}]}