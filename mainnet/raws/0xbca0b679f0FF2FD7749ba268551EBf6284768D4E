{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/JaduStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"./interfaces/IERC721Custom.sol\\\";\\n\\ncontract JaduStaking is Context {\\n    //uint256 private tokenId;\\n\\n    using Counters for Counters.Counter;\\n    Counters.Counter private _itemIds;\\n    Counters.Counter private _itemsUnstaked;\\n\\n    address payable owner;\\n\\n    constructor() {\\n        owner = payable(_msgSender());\\n    }\\n\\n    struct StakeItem {\\n        uint256 itemId;\\n        address nftContract;\\n        uint256[] tokenId;\\n        address owner;\\n        uint256 time;\\n    }\\n\\n    mapping(address => mapping(uint256 => bool)) private NFTexist;\\n    mapping(uint256 => StakeItem) private idToStakeItem;\\n    mapping(address => mapping(uint256 => bool)) public revealedIDs;\\n\\n    function stake(address nftContract, uint256[] memory tokenId)\\n        public\\n        payable\\n        returns (uint256)\\n    {\\n        require(tokenId.length <= 2, \\\"Cannot stake more than 2 NFTs in combo.\\\");\\n\\n        for (uint256 i = 0; i < tokenId.length; i++) {\\n            require(\\n                NFTexist[nftContract][tokenId[i]] == false,\\n                \\\"NFT already staked.\\\"\\n            );\\n\\n            require(\\n                revealedIDs[nftContract][tokenId[i]] == false,\\n                \\\"NFT was staked for 30 days either in single staking or combination staking.\\\"\\n            );\\n\\n            NFTexist[nftContract][tokenId[i]] = true;\\n        }\\n\\n        _itemIds.increment();\\n        uint256 itemId = _itemIds.current();\\n\\n        idToStakeItem[itemId] = StakeItem(\\n            itemId,\\n            nftContract,\\n            tokenId,\\n            _msgSender(),\\n            block.timestamp\\n        );\\n\\n        for (uint256 i = 0; i < tokenId.length; i++) {\\n            IERC721Custom(nftContract).transferFrom(\\n                _msgSender(),\\n                address(this),\\n                tokenId[i]\\n            );\\n        }\\n\\n        return itemId;\\n    }\\n\\n    function unStake(address nftContract, uint256 itemId)\\n        public\\n        payable\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory tokenId = idToStakeItem[itemId].tokenId;\\n        require(\\n            idToStakeItem[itemId].owner == _msgSender(),\\n            \\\"You are not the owner of staked NFT.\\\"\\n        );\\n\\n        if (block.timestamp > idToStakeItem[itemId].time + 30 days) {\\n            for (uint256 i = 0; i < tokenId.length; i++) {\\n                doReveal(nftContract, tokenId[i]);\\n            }\\n        }\\n        for (uint256 i = 0; i < tokenId.length; i++) {\\n            uint256 id = tokenId[i];\\n            IERC721Custom(nftContract).transferFrom(\\n                address(this),\\n                idToStakeItem[itemId].owner,\\n                id\\n            );\\n            NFTexist[nftContract][id] = false;\\n        }\\n        delete idToStakeItem[itemId];\\n        _itemsUnstaked.increment();\\n        return tokenId;\\n    }\\n\\n    function doReveal(address nftContract, uint256 tokenId) private {\\n        revealedIDs[nftContract][tokenId] = true;\\n    }\\n\\n    function multiUnStake(address nftContract, uint256[] calldata itemIds)\\n        public\\n        payable\\n        returns (bool)\\n    {\\n        for (uint256 i = 0; i < itemIds.length; i++) {\\n            unStake(nftContract, itemIds[i]);\\n        }\\n        return true;\\n    }\\n\\n    function fetchMyNFTs(address account)\\n        public\\n        view\\n        returns (StakeItem[] memory)\\n    {\\n        uint256 totalItemCount = _itemIds.current();\\n        uint256 itemCount = 0;\\n        uint256 currentIndex = 0;\\n\\n        for (uint256 i = 0; i < totalItemCount; i++) {\\n            if (idToStakeItem[i + 1].owner == account) {\\n                itemCount += 1;\\n            }\\n        }\\n\\n        StakeItem[] memory items = new StakeItem[](itemCount);\\n        for (uint256 i = 0; i < totalItemCount; i++) {\\n            if (idToStakeItem[i + 1].owner == account) {\\n                uint256 currentId = i + 1;\\n                StakeItem storage currentItem = idToStakeItem[currentId];\\n                items[currentIndex] = currentItem;\\n                currentIndex += 1;\\n            }\\n        }\\n        return items;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721Custom.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface IERC721Custom is IERC165 {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    function revealTokenURI(uint256 id) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"fetchMyNFTs\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct JaduStaking.StakeItem[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"}],\"name\":\"multiUnStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"revealedIDs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"unStake\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "JaduStaking", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}