{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity 0.6.7;\r\n\r\nabstract contract StructLike {\r\n    function val(uint256 _id) virtual public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title LinkedList (Structured Link List)\r\n * @author Vittorio Minacori (https://github.com/vittominacori)\r\n * @dev A utility library for using sorted linked list data structures in your Solidity project.\r\n */\r\nlibrary LinkedList {\r\n\r\n    uint256 private constant NULL = 0;\r\n    uint256 private constant HEAD = 0;\r\n\r\n    bool private constant PREV = false;\r\n    bool private constant NEXT = true;\r\n\r\n    struct List {\r\n        mapping(uint256 => mapping(bool => uint256)) list;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the list exists\r\n     * @param self stored linked list from contract\r\n     * @return bool true if list exists, false otherwise\r\n     */\r\n    function isList(List storage self) internal view returns (bool) {\r\n        // if the head nodes previous or next pointers both point to itself, then there are no items in the list\r\n        if (self.list[HEAD][PREV] != HEAD || self.list[HEAD][NEXT] != HEAD) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the node exists\r\n     * @param self stored linked list from contract\r\n     * @param _node a node to search for\r\n     * @return bool true if node exists, false otherwise\r\n     */\r\n    function isNode(List storage self, uint256 _node) internal view returns (bool) {\r\n        if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) {\r\n            if (self.list[HEAD][NEXT] == _node) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements in the list\r\n     * @param self stored linked list from contract\r\n     * @return uint256\r\n     */\r\n    function range(List storage self) internal view returns (uint256) {\r\n        uint256 i;\r\n        uint256 num;\r\n        (, i) = adj(self, HEAD, NEXT);\r\n        while (i != HEAD) {\r\n            (, i) = adj(self, i, NEXT);\r\n            num++;\r\n        }\r\n        return num;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the links of a node as a tuple\r\n     * @param self stored linked list from contract\r\n     * @param _node id of the node to get\r\n     * @return bool, uint256, uint256 true if node exists or false otherwise, previous node, next node\r\n     */\r\n    function node(List storage self, uint256 _node) internal view returns (bool, uint256, uint256) {\r\n        if (!isNode(self, _node)) {\r\n            return (false, 0, 0);\r\n        } else {\r\n            return (true, self.list[_node][PREV], self.list[_node][NEXT]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the link of a node `_node` in direction `_direction`.\r\n     * @param self stored linked list from contract\r\n     * @param _node id of the node to step from\r\n     * @param _direction direction to step in\r\n     * @return bool, uint256 true if node exists or false otherwise, node in _direction\r\n     */\r\n    function adj(List storage self, uint256 _node, bool _direction) internal view returns (bool, uint256) {\r\n        if (!isNode(self, _node)) {\r\n            return (false, 0);\r\n        } else {\r\n            return (true, self.list[_node][_direction]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the link of a node `_node` in direction `NEXT`.\r\n     * @param self stored linked list from contract\r\n     * @param _node id of the node to step from\r\n     * @return bool, uint256 true if node exists or false otherwise, next node\r\n     */\r\n    function next(List storage self, uint256 _node) internal view returns (bool, uint256) {\r\n        return adj(self, _node, NEXT);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the link of a node `_node` in direction `PREV`.\r\n     * @param self stored linked list from contract\r\n     * @param _node id of the node to step from\r\n     * @return bool, uint256 true if node exists or false otherwise, previous node\r\n     */\r\n    function prev(List storage self, uint256 _node) internal view returns (bool, uint256) {\r\n        return adj(self, _node, PREV);\r\n    }\r\n\r\n    /**\r\n     * @dev Can be used before `insert` to build an ordered list.\r\n     * @dev Get the node and then `back` or `face` basing on your list order.\r\n     * @dev If you want to order basing on other than `structure.val()` override this function\r\n     * @param self stored linked list from contract\r\n     * @param _struct the structure instance\r\n     * @param _val value to seek\r\n     * @return uint256 next node with a value less than StructLike(_struct).val(next_)\r\n     */\r\n    function sort(List storage self, address _struct, uint256 _val) internal view returns (uint256) {\r\n        if (range(self) == 0) {\r\n            return 0;\r\n        }\r\n        bool exists;\r\n        uint256 next_;\r\n        (exists, next_) = adj(self, HEAD, NEXT);\r\n        while ((next_ != 0) && ((_val < StructLike(_struct).val(next_)) != NEXT)) {\r\n            next_ = self.list[next_][NEXT];\r\n        }\r\n        return next_;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a bidirectional link between two nodes on direction `_direction`\r\n     * @param self stored linked list from contract\r\n     * @param _node first node for linking\r\n     * @param _link  node to link to in the _direction\r\n     */\r\n    function form(List storage self, uint256 _node, uint256 _link, bool _dir) internal {\r\n        self.list[_link][!_dir] = _node;\r\n        self.list[_node][_dir] = _link;\r\n    }\r\n\r\n    /**\r\n     * @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\r\n     * @param self stored linked list from contract\r\n     * @param _node existing node\r\n     * @param _new  new node to insert\r\n     * @param _direction direction to insert node in\r\n     * @return bool true if success, false otherwise\r\n     */\r\n    function insert(List storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) {\r\n        if (!isNode(self, _new) && isNode(self, _node)) {\r\n            uint256 c = self.list[_node][_direction];\r\n            form(self, _node, _new, _direction);\r\n            form(self, _new, c, _direction);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Insert node `_new` beside existing node `_node` in direction `NEXT`.\r\n     * @param self stored linked list from contract\r\n     * @param _node existing node\r\n     * @param _new  new node to insert\r\n     * @return bool true if success, false otherwise\r\n     */\r\n    function face(List storage self, uint256 _node, uint256 _new) internal returns (bool) {\r\n        return insert(self, _node, _new, NEXT);\r\n    }\r\n\r\n    /**\r\n     * @dev Insert node `_new` beside existing node `_node` in direction `PREV`.\r\n     * @param self stored linked list from contract\r\n     * @param _node existing node\r\n     * @param _new  new node to insert\r\n     * @return bool true if success, false otherwise\r\n     */\r\n    function back(List storage self, uint256 _node, uint256 _new) internal returns (bool) {\r\n        return insert(self, _node, _new, PREV);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes an entry from the linked list\r\n     * @param self stored linked list from contract\r\n     * @param _node node to remove from the list\r\n     * @return uint256 the removed node\r\n     */\r\n    function del(List storage self, uint256 _node) internal returns (uint256) {\r\n        if ((_node == NULL) || (!isNode(self, _node))) {\r\n            return 0;\r\n        }\r\n        form(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT);\r\n        delete self.list[_node][PREV];\r\n        delete self.list[_node][NEXT];\r\n        return _node;\r\n    }\r\n\r\n    /**\r\n     * @dev Pushes an entry to the head or tail of the linked list\r\n     * @param self stored linked list from contract\r\n     * @param _node new entry to push to the head\r\n     * @param _direction push to the head (NEXT) or tail (PREV)\r\n     * @return bool true if success, false otherwise\r\n     */\r\n    function push(List storage self, uint256 _node, bool _direction) internal returns (bool) {\r\n        return insert(self, HEAD, _node, _direction);\r\n    }\r\n\r\n    /**\r\n     * @dev Pops the first entry from the linked list\r\n     * @param self stored linked list from contract\r\n     * @param _direction pop from the head (NEXT) or the tail (PREV)\r\n     * @return uint256 the removed node\r\n     */\r\n    function pop(List storage self, bool _direction) internal returns (uint256) {\r\n        bool exists;\r\n        uint256 adj_;\r\n        (exists, adj_) = adj(self, HEAD, _direction);\r\n        return del(self, adj_);\r\n    }\r\n}\r\n\r\nabstract contract RewardAdjusterLike {\r\n    function recomputeRewards(address, bytes4) external virtual;\r\n}\r\n\r\ncontract RewardAdjusterBundler {\r\n    using LinkedList for LinkedList.List;\r\n\r\n    // --- Auth ---\r\n    mapping (address => uint256) public authorizedAccounts;\r\n    /**\r\n     * @notice Add auth to an account\r\n     * @param account Account to add auth to\r\n     */\r\n    function addAuthorization(address account) external isAuthorized {\r\n        authorizedAccounts[account] = 1;\r\n        emit AddAuthorization(account);\r\n    }\r\n    /**\r\n     * @notice Remove auth from an account\r\n     * @param account Account to remove auth from\r\n     */\r\n    function removeAuthorization(address account) external isAuthorized {\r\n        authorizedAccounts[account] = 0;\r\n        emit RemoveAuthorization(account);\r\n    }\r\n    /**\r\n    * @notice Checks whether msg.sender can call an authed function\r\n    **/\r\n    modifier isAuthorized {\r\n        require(authorizedAccounts[msg.sender] == 1, \"RewardAdjusterBundler/account-not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Variables ---\r\n    // Number of funded functions ever added\r\n    uint256            public fundedFunctionNonce;\r\n    // Max number of functions that can be in the list\r\n    uint256            public maxFunctions;\r\n    // Latest funded function index in the list\r\n    uint256            public latestFundedFunction;\r\n\r\n    // Mapping with functions that were already added\r\n    mapping(address => mapping(bytes4 => uint256)) public addedFunction;\r\n    // Data about each funded function\r\n    mapping(uint256 => FundedFunction)             public fundedFunctions;\r\n\r\n    // Linked list with functions offering rewards to be called\r\n    LinkedList.List    internal fundedFunctionsList;\r\n\r\n    // The fixed reward adjuster\r\n    RewardAdjusterLike public fixedRewardAdjuster;\r\n    // The min + max reward adjuster\r\n    RewardAdjusterLike public minMaxRewardAdjuster;\r\n\r\n    // --- Structs ---\r\n    struct FundedFunction {\r\n        uint256 adjusterType;\r\n        bytes4  functionName;\r\n        address receiverContract;\r\n    }\r\n\r\n    // --- Events ---\r\n    event AddAuthorization(address account);\r\n    event RemoveAuthorization(address account);\r\n    event FailedRecomputeReward(uint256 adjusterType, address receiverContract, bytes4 functionName);\r\n    event AddFundedFunction(\r\n      uint256 latestFundedFunction,\r\n      uint256 adjusterType,\r\n      bytes4 functionName,\r\n      address receiverContract\r\n    );\r\n    event RemoveFundedFunction(uint256 functionPosition);\r\n    event ModifyParameters(bytes32 parameter, address val);\r\n    event ModifyParameters(bytes32 actionType, uint256 functionPosition, uint256 adjusterType, bytes4 functionName, address receiverContract);\r\n\r\n    constructor(address _fixedRewardAdjuster, address _minMaxRewardAdjuster, uint256 _maxFunctions) public {\r\n        require(_maxFunctions > 0, \"RewardAdjusterBundler/null-max-functions\");\r\n        require(_fixedRewardAdjuster != address(0), \"RewardAdjusterBundler/null-fixed-reward-adjuster\");\r\n        require(_minMaxRewardAdjuster != address(0), \"RewardAdjusterBundler/null-minmax-reward-adjuster\");\r\n\r\n        authorizedAccounts[msg.sender] = 1;\r\n        maxFunctions                   = _maxFunctions;\r\n\r\n        fixedRewardAdjuster            = RewardAdjusterLike(_fixedRewardAdjuster);\r\n        minMaxRewardAdjuster           = RewardAdjusterLike(_minMaxRewardAdjuster);\r\n\r\n        emit AddAuthorization(msg.sender);\r\n    }\r\n\r\n    // --- Boolean Logic ---\r\n    function both(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := and(x, y)}\r\n    }\r\n\r\n    // --- Math ---\r\n    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x + y;\r\n        require(z >= x, \"RewardAdjusterBundler/add-uint-uint-overflow\");\r\n    }\r\n    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"RewardAdjusterBundler/sub-uint-uint-underflow\");\r\n    }\r\n\r\n    // --- Administration ---\r\n    /*\r\n     * @notice Modify address params\r\n     * @param parameter The name of the parameter to update\r\n     * @param val The new address for the parameter\r\n     */\r\n    function modifyParameters(bytes32 parameter, address val) external isAuthorized {\r\n        require(val != address(0), \"RewardAdjusterBundler/null-val\");\r\n\r\n        if (parameter == \"fixedRewardAdjuster\") {\r\n          fixedRewardAdjuster = RewardAdjusterLike(val);\r\n        } else if (parameter == \"minMaxRewardAdjuster\") {\r\n          minMaxRewardAdjuster = RewardAdjusterLike(val);\r\n        } else revert(\"RewardAdjusterBundler/modify-unrecognized-param\");\r\n\r\n        emit ModifyParameters(parameter, val);\r\n    }\r\n    /*\r\n     * @notice Add or remove a funded function\r\n     * @param actionType The type of action to execute\r\n     * @param functionPosition The position of the funded function in fundedFunctions\r\n     * @param adjusterType The adjuster contract to include for the funded function\r\n     * @param functionName The signature of the function that gets funded\r\n     * @param receiverContract The contract hosting the funded function\r\n     */\r\n    function modifyParameters(bytes32 actionType, uint256 functionPosition, uint256 adjusterType, bytes4 functionName, address receiverContract)\r\n      external isAuthorized {\r\n        if (actionType == \"addFunction\") {\r\n          addFundedFunction(adjusterType, functionName, receiverContract);\r\n        } else if (actionType == \"removeFunction\") {\r\n          removeFundedFunction(functionPosition);\r\n        }\r\n        else revert(\"RewardAdjusterBundler/modify-unrecognized-param\");\r\n\r\n        emit ModifyParameters(actionType, functionPosition, adjusterType, functionName, receiverContract);\r\n    }\r\n\r\n    // --- Internal Logic ---\r\n    /*\r\n     * @notice Add a funded function\r\n     * @param adjusterType The type of adjuster that recomputes the rewards offered by this function\r\n     * @param functionName The name of the function offering rewards\r\n     * @param receiverContract Contract that has the funded function\r\n     */\r\n    function addFundedFunction(uint256 adjusterType, bytes4 functionName, address receiverContract) internal {\r\n        require(receiverContract != address(0), \"RewardAdjusterBundler/null-receiver-contract\");\r\n        require(adjusterType <= 1, \"RewardAdjusterBundler/invalid-adjuster-type\");\r\n        require(addedFunction[receiverContract][functionName] == 0, \"RewardAdjusterBundler/function-already-added\");\r\n        require(fundedFunctionsAmount() < maxFunctions, \"RewardAdjusterBundler/function-limit-reached\");\r\n\r\n        addedFunction[receiverContract][functionName] = 1;\r\n        fundedFunctionNonce                           = addition(fundedFunctionNonce, 1);\r\n        latestFundedFunction                          = fundedFunctionNonce;\r\n        fundedFunctions[fundedFunctionNonce]          = FundedFunction(adjusterType, functionName, receiverContract);\r\n\r\n        fundedFunctionsList.push(latestFundedFunction, false);\r\n\r\n        emit AddFundedFunction(\r\n          latestFundedFunction,\r\n          adjusterType,\r\n          functionName,\r\n          receiverContract\r\n        );\r\n    }\r\n    /*\r\n     * @notice Remove a funded function\r\n     * @param functionPosition The position of the funded function in fundedFunctions\r\n     */\r\n    function removeFundedFunction(uint256 functionPosition) internal {\r\n        require(both(functionPosition <= latestFundedFunction, functionPosition > 0), \"RewardAdjusterBundler/invalid-position\");\r\n        FundedFunction memory fundedFunction = fundedFunctions[functionPosition];\r\n\r\n        require(addedFunction[fundedFunction.receiverContract][fundedFunction.functionName] == 1, \"RewardAdjusterBundler/function-not-added\");\r\n        delete(addedFunction[fundedFunction.receiverContract][fundedFunction.functionName]);\r\n\r\n        if (functionPosition == latestFundedFunction) {\r\n          (, uint256 prevReceiver) = fundedFunctionsList.prev(latestFundedFunction);\r\n          latestFundedFunction     = prevReceiver;\r\n        }\r\n\r\n        fundedFunctionsList.del(functionPosition);\r\n        delete(fundedFunctions[functionPosition]);\r\n\r\n        emit RemoveFundedFunction(functionPosition);\r\n    }\r\n\r\n    // --- Core Logic ---\r\n    /*\r\n     * @param Recopute all system coin rewards for all funded functions included in this contract\r\n     */\r\n    function recomputeAllRewards() external {\r\n        // Start looping from the latest funded function\r\n        uint256 currentFundedFunction = latestFundedFunction;\r\n\r\n        FundedFunction memory fundedFunction;\r\n\r\n        // While we still haven't gone through the entire list\r\n        while (currentFundedFunction > 0) {\r\n          fundedFunction = fundedFunctions[currentFundedFunction];\r\n          if (fundedFunction.adjusterType == 0) {\r\n            try fixedRewardAdjuster.recomputeRewards(fundedFunction.receiverContract, fundedFunction.functionName) {}\r\n            catch(bytes memory /* revertReason */) {\r\n              emit FailedRecomputeReward(fundedFunction.adjusterType, fundedFunction.receiverContract, fundedFunction.functionName);\r\n            }\r\n          } else {\r\n            try minMaxRewardAdjuster.recomputeRewards(fundedFunction.receiverContract, fundedFunction.functionName) {}\r\n            catch(bytes memory /* revertReason */) {\r\n              emit FailedRecomputeReward(fundedFunction.adjusterType, fundedFunction.receiverContract, fundedFunction.functionName);\r\n            }\r\n          }\r\n          // Continue looping\r\n          (, currentFundedFunction) = fundedFunctionsList.prev(currentFundedFunction);\r\n        }\r\n    }\r\n\r\n    // --- Getters ---\r\n    /**\r\n     * @notice Get the secondary tax receiver list length\r\n     */\r\n    function fundedFunctionsAmount() public view returns (uint256) {\r\n        return fundedFunctionsList.range();\r\n    }\r\n    /**\r\n     * @notice Check if a funded function index is in the list\r\n     */\r\n    function isFundedFunction(uint256 _fundedFunction) public view returns (bool) {\r\n        if (_fundedFunction == 0) return false;\r\n        return fundedFunctionsList.isNode(_fundedFunction);\r\n    }\r\n}\r\n\r\n// deploy/setup the rewards bundler\r\ncontract BundlerDeployer {\r\n    constructor() public {\r\n        // deploy\r\n        RewardAdjusterBundler bundler = new RewardAdjusterBundler(\r\n            0xfF5126b97f37DdB4743858b7e0d6c5aE8E5Db2ab, // GEB_FIXED_REWARDS_ADJUSTER\r\n            0xbe0D9016714c64a877ed28fd3F3C7c8fF513d807, // GEB_MINMAX_REWARDS_ADJUSTER\r\n            15 // maxFunctions\r\n            );\r\n            \r\n        // add authorization to GEB_PAUSE_PROXY\r\n        bundler.addAuthorization(0xa57A4e6170930ac547C147CdF26aE4682FA8262E);\r\n        \r\n        // add functions\r\n        bundler.modifyParameters(\r\n            \"addFunction\",\r\n            0,                                                  // position, irrelevant when adding\r\n            0,                                                  // type, fixed\r\n            bytes4(0xf00df8b8),                                 // getRewardForPop(uint256,address)\r\n            address(0xe1d5181F0DD039aA4f695d4939d682C4cF874086) // DEBT_POPPER_REWARDS\r\n        );\r\n        \r\n        bundler.modifyParameters(\r\n            \"addFunction\",\r\n            0, \r\n            1,                                                  // type, minMax\r\n            bytes4(0x59426fad),                                 // relayRate(uint256,address)\r\n            address(0xD52Da90c20c4610fEf8faade2a1281FFa54eB6fB) // GEB_RRFM_SETTER_RELAYER\r\n        );\r\n        bundler.modifyParameters(\r\n            \"addFunction\",\r\n            0, \r\n            1,                                                  // type, minMax\r\n            bytes4(0x8d7fb67a),                                 // reimburseCaller(address)\r\n            address(0xE8063b122Bef35d6723E33DBb3446092877C6855) // MEDIANIZER_RAI_REWARDS_RELAYER\r\n        );\r\n        bundler.modifyParameters(\r\n            \"addFunction\",\r\n            0, \r\n            1,                                                  // type, minMax\r\n            bytes4(0x8d7fb67a),                                 // reimburseCaller(address)\r\n            address(0xdD2e7750ebF07BB8Be147e712D5f8deDEE052fde) // MEDIANIZER_ETH_REWARDS_RELAYER\r\n        );\r\n        bundler.modifyParameters(\r\n            \"addFunction\",\r\n            0, \r\n            1,                                                  // type, minMax\r\n            bytes4(0x2761f27b),                                 // renumerateCaller(address)\r\n            address(0x105b857583346E250FBD04a57ce0E491EB204BA3) // FSM_WRAPPER_ETH\r\n        );\r\n        bundler.modifyParameters(\r\n            \"addFunction\",\r\n            0, \r\n            1,                                                  // type, minMax\r\n            bytes4(0xcb5ec87a),                                 // autoUpdateCeiling(address)\r\n            address(0x54999Ee378b339f405a4a8a1c2f7722CD25960fa) // GEB_SINGLE_CEILING_SETTER\r\n        );\r\n        bundler.modifyParameters(\r\n            \"addFunction\",\r\n            0, \r\n            1,                                                  // type, minMax\r\n            bytes4(0x36b8b425),                                 // recomputeOnAuctionSystemCoinLimit(address)\r\n            address(0x59536C9Ad1a390fA0F60813b2a4e8B957903Efc7) // COLLATERAL_AUCTION_THROTTLER\r\n        );\r\n        bundler.modifyParameters(\r\n            \"addFunction\",\r\n            0, \r\n            1,                                                  // type, minMax\r\n            bytes4(0x341369c1),                                 // recomputeCollateralDebtFloor(address)\r\n            address(0x0262Bd031B99c5fb99B47Dc4bEa691052f671447) // GEB_DEBT_FLOOR_ADJUSTER\r\n        );\r\n        bundler.modifyParameters(\r\n            \"addFunction\",\r\n            0, \r\n            1,                                                  // type, minMax\r\n            bytes4(0xbf1ad0db),                                 // adjustSurplusBuffer(address)\r\n            address(0x1450f40E741F2450A95F9579Be93DD63b8407a25) // GEB_AUTO_SURPLUS_BUFFER\r\n        );\r\n        bundler.modifyParameters(\r\n            \"addFunction\",\r\n            0, \r\n            1,                                                  // type, minMax\r\n            bytes4(0xbbaf0133),                                 // setDebtAuctionInitialParameters(address)\r\n            address(0x7df2d51e69aA58B69C3dF18D75b8e9ACc3C1B04E) // GEB_DEBT_AUCTION_INITIAL_PARAM_SETTER\r\n        );\r\n        bundler.modifyParameters(\r\n            \"addFunction\",\r\n            0, \r\n            1,                                                  // type, minMax\r\n            bytes4(0xa8e2044e),                                 // recomputeSurplusAmountAuctioned(address)\r\n            address(0xa43BFA2a04c355128F3f10788232feeB2f42FE98) // GEB_AUTO_SURPLUS_AUCTIONED\r\n        );       \r\n    \r\n        // remove deployer auth\r\n        bundler.removeAuthorization(address(this));\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]", "ContractName": "BundlerDeployer", "CompilerVersion": "v0.6.7+commit.b8d736ae", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3e1878df53a5b42b8aefaf6fdeb3cd3a50bced783124f5986ffef0c608cb846d"}]}