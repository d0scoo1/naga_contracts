{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: utils/CloneFactory.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/*\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2018 Murray Software, LLC.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n//solhint-disable max-line-length\r\n//solhint-disable no-inline-assembly\r\n\r\ncontract CloneFactory {\r\n    function createClone(address target) internal returns (address result) {\r\n        bytes20 targetBytes = bytes20(target);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(\r\n                clone,\r\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\r\n            )\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(\r\n                add(clone, 0x28),\r\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\r\n            )\r\n            result := create(0, clone, 0x37)\r\n        }\r\n    }\r\n\r\n    function isClone(address target, address query)\r\n        internal\r\n        view\r\n        returns (bool result)\r\n    {\r\n        bytes20 targetBytes = bytes20(target);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(\r\n                clone,\r\n                0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000\r\n            )\r\n            mstore(add(clone, 0xa), targetBytes)\r\n            mstore(\r\n                add(clone, 0x1e),\r\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\r\n            )\r\n\r\n            let other := add(clone, 0x40)\r\n            extcodecopy(query, other, 0, 0x2d)\r\n            result := and(\r\n                eq(mload(clone), mload(other)),\r\n                eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\n// File: interfaces/IRicardianLLC.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Ricardian LLC formation interface.\r\ninterface IRicardianLLC {\r\n    function mintLLC(address to) external payable;\r\n}\r\n\r\n// File: tokens/erc1155/ERC1155.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\r\nabstract contract ERC1155 {\r\n    /*///////////////////////////////////////////////////////////////\r\n                                EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event TransferSingle(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 id,\r\n        uint256 amount\r\n    );\r\n\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] amounts\r\n    );\r\n\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERC1155 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\r\n\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             METADATA LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function uri(uint256 id) public view virtual returns (string memory);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             ERC1155 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual {\r\n        require(\r\n            msg.sender == from || isApprovedForAll[from][msg.sender],\r\n            \"NOT_AUTHORIZED\"\r\n        );\r\n\r\n        balanceOf[from][id] -= amount;\r\n        balanceOf[to][id] += amount;\r\n\r\n        emit TransferSingle(msg.sender, from, to, id, amount);\r\n\r\n        require(\r\n            to.code.length == 0\r\n                ? to != address(0)\r\n                : ERC1155TokenReceiver(to).onERC1155Received(\r\n                    msg.sender,\r\n                    from,\r\n                    id,\r\n                    amount,\r\n                    data\r\n                ) == ERC1155TokenReceiver.onERC1155Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual {\r\n        uint256 idsLength = ids.length; // Saves MLOADs.\r\n\r\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\r\n\r\n        require(\r\n            msg.sender == from || isApprovedForAll[from][msg.sender],\r\n            \"NOT_AUTHORIZED\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < idsLength; ) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            balanceOf[from][id] -= amount;\r\n            balanceOf[to][id] += amount;\r\n\r\n            // An array can't have a total length\r\n            // larger than the max uint256 value.\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\r\n\r\n        require(\r\n            to.code.length == 0\r\n                ? to != address(0)\r\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(\r\n                    msg.sender,\r\n                    from,\r\n                    ids,\r\n                    amounts,\r\n                    data\r\n                ) == ERC1155TokenReceiver.onERC1155BatchReceived.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256[] memory balances)\r\n    {\r\n        uint256 ownersLength = owners.length; // Saves MLOADs.\r\n\r\n        require(ownersLength == ids.length, \"LENGTH_MISMATCH\");\r\n\r\n        balances = new uint256[](owners.length);\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the array index counter which cannot possibly overflow.\r\n        unchecked {\r\n            for (uint256 i = 0; i < ownersLength; i++) {\r\n                balances[i] = balanceOf[owners[i]][ids[i]];\r\n            }\r\n        }\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC165 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        pure\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\r\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\r\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                        INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal {\r\n        balanceOf[to][id] += amount;\r\n\r\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\r\n\r\n        require(\r\n            to.code.length == 0\r\n                ? to != address(0)\r\n                : ERC1155TokenReceiver(to).onERC1155Received(\r\n                    msg.sender,\r\n                    address(0),\r\n                    id,\r\n                    amount,\r\n                    data\r\n                ) == ERC1155TokenReceiver.onERC1155Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function _batchMint(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal {\r\n        uint256 idsLength = ids.length; // Saves MLOADs.\r\n\r\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\r\n\r\n        for (uint256 i = 0; i < idsLength; ) {\r\n            balanceOf[to][ids[i]] += amounts[i];\r\n\r\n            // An array can't have a total length\r\n            // larger than the max uint256 value.\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\r\n\r\n        require(\r\n            to.code.length == 0\r\n                ? to != address(0)\r\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(\r\n                    msg.sender,\r\n                    address(0),\r\n                    ids,\r\n                    amounts,\r\n                    data\r\n                ) == ERC1155TokenReceiver.onERC1155BatchReceived.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function _batchBurn(\r\n        address from,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts\r\n    ) internal {\r\n        uint256 idsLength = ids.length; // Saves MLOADs.\r\n\r\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\r\n\r\n        for (uint256 i = 0; i < idsLength; ) {\r\n            balanceOf[from][ids[i]] -= amounts[i];\r\n\r\n            // An array can't have a total length\r\n            // larger than the max uint256 value.\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\r\n    }\r\n\r\n    function _burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal {\r\n        balanceOf[from][id] -= amount;\r\n\r\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\r\n    }\r\n}\r\n\r\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\r\ninterface ERC1155TokenReceiver {\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/math/SafeMath.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Counters.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n// File: Club.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\ncontract Club is ERC1155 {\r\n    using Counters for Counters.Counter;\r\n    using SafeMath for uint256;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    string public docs;\r\n    address public safeAddress;\r\n    address public referralAddress;\r\n    address internal coterieAddress;\r\n    uint256 public maxMembers;\r\n\r\n    Counters.Counter public memberCounter;\r\n    Counters.Counter public tokenCounter;\r\n\r\n    mapping(address => bool) public members;\r\n    mapping(uint256 => Token) public tokens;\r\n\r\n    bool internal locked;\r\n\r\n    struct Token {\r\n        uint256 mintPrice;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        string ipfsCID;\r\n        uint256 maximum;\r\n        uint256 minted;\r\n        uint256 maxAmount;\r\n        bool exists;\r\n    }\r\n\r\n    event Minted(address who, uint256 tokenIndex, uint256 amount);\r\n    event Withdrew(uint256 amountSentToSafe, uint256 percentageFee);\r\n    event Kicked(address who);\r\n    event Joined(address who);\r\n\r\n    error UnknownToken();\r\n    error AlreadyInitialized();\r\n    error NotEnoughFunds();\r\n    error NotMember();\r\n\r\n    modifier onlySafe() {\r\n        require(\r\n            msg.sender == safeAddress,\r\n            \"Only the safe can call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyCoterie() {\r\n        require(\r\n            msg.sender == coterieAddress,\r\n            \"Only coterie can call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onTime(uint256 startTime, uint256 endTime) {\r\n        require(startTime < endTime, \"Start time must be before end time\");\r\n        require(startTime > 0 && endTime > 0, \"Time window cannot be 0\");\r\n        _;\r\n    }\r\n\r\n    modifier inMemberLimits(uint256 _maxMembers, string memory _docs) {\r\n        if (bytes(_docs).length == 0) {\r\n            require(_maxMembers > 0, \"Max members must be greater than 0\");\r\n            require(_maxMembers <= 100, \"Max members must be less than 100\");\r\n        } else {\r\n            require(_maxMembers > 0, \"Max members must be greater than 0\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    function _kick(address to) internal {\r\n        if (!members[to]) revert NotMember();\r\n\r\n        for (uint256 i = 0; i < tokenCounter.current(); i++) {\r\n            if (balanceOf[to][i] > 0) {\r\n                balanceOf[to][i] = 0;\r\n            }\r\n        }\r\n\r\n        memberCounter.decrement();\r\n        members[to] = false;\r\n\r\n        emit Kicked(to);\r\n    }\r\n\r\n    function _getTokenValues(address to) internal view returns (uint256) {\r\n        if (!members[to]) revert NotMember();\r\n\r\n        uint256 total = 0;\r\n\r\n        for (uint256 i = 0; i < tokenCounter.current(); i++) {\r\n            if (balanceOf[to][i] > 0) {\r\n                total = total.add(balanceOf[to][i].mul(tokens[i].mintPrice));\r\n            }\r\n        }\r\n\r\n        return total;\r\n    }\r\n\r\n    function _addMember(address to) internal {\r\n        require(!members[to], \"Member already exists\");\r\n\r\n        members[to] = true;\r\n        memberCounter.increment();\r\n\r\n        emit Joined(to);\r\n    }\r\n\r\n    function setCoterieAddress(address _coterieAddress) external onlyCoterie {\r\n        coterieAddress = _coterieAddress;\r\n    }\r\n\r\n    function init(\r\n        string memory _clubName,\r\n        string memory _tokenSymbol,\r\n        string memory _docs,\r\n        uint256 _maxMembers,\r\n        address _safeAddress,\r\n        address _referralAddress\r\n    ) external inMemberLimits(_maxMembers, _docs) {\r\n        if (safeAddress != address(0)) revert AlreadyInitialized();\r\n        require(\r\n            _safeAddress != _referralAddress,\r\n            \"Safe address cannot be the same as referral address\"\r\n        );\r\n\r\n        name = _clubName;\r\n        symbol = _tokenSymbol;\r\n        docs = _docs;\r\n        safeAddress = _safeAddress;\r\n        referralAddress = _referralAddress;\r\n        maxMembers = _maxMembers;\r\n        coterieAddress = 0x7c5252031d236d5A17db832Fc8367e6850a3b4FB;\r\n    }\r\n\r\n    function createFundingRound(\r\n        uint256 mintPrice,\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        uint256 maximum,\r\n        uint256 maxAmount,\r\n        string memory ipfsCID\r\n    ) external onlySafe onTime(startTime, endTime) {\r\n        Token storage token = tokens[tokenCounter.current()];\r\n        token.mintPrice = mintPrice;\r\n        token.startTime = startTime;\r\n        token.endTime = endTime;\r\n        token.ipfsCID = ipfsCID;\r\n        token.maximum = maximum;\r\n        token.minted = 0;\r\n        token.maxAmount = maxAmount;\r\n        token.exists = true;\r\n\r\n        tokenCounter.increment();\r\n    }\r\n\r\n    function editFundingRound(\r\n        uint256 id,\r\n        uint256 mintPrice,\r\n        uint256 startTime,\r\n        uint256 endTime\r\n    ) external onlySafe onTime(startTime, endTime) {\r\n        if (!tokens[id].exists) revert UnknownToken();\r\n\r\n        tokens[id].mintPrice = mintPrice;\r\n        tokens[id].startTime = startTime;\r\n        tokens[id].endTime = endTime;\r\n    }\r\n\r\n    function editTokenMintMaximum(uint256 id, uint256 maximum)\r\n        external\r\n        onlySafe\r\n    {\r\n        if (!tokens[id].exists) revert UnknownToken();\r\n\r\n        tokens[id].maximum = maximum;\r\n    }\r\n\r\n    function editTokenMaxAmount(uint256 id, uint256 maxAmount)\r\n        external\r\n        onlySafe\r\n    {\r\n        if (!tokens[id].exists) revert UnknownToken();\r\n\r\n        tokens[id].maxAmount = maxAmount;\r\n    }\r\n\r\n    function editTokenIPFS(uint256 id, string memory ipfsCID)\r\n        external\r\n        onlySafe\r\n    {\r\n        if (!tokens[id].exists) revert UnknownToken();\r\n\r\n        tokens[id].ipfsCID = ipfsCID;\r\n    }\r\n\r\n    function editMaximumMembers(uint256 _maxMembers)\r\n        external\r\n        onlySafe\r\n        inMemberLimits(_maxMembers, docs)\r\n    {\r\n        maxMembers = _maxMembers;\r\n    }\r\n\r\n    function mint(uint256 tokenIndex, uint256 amount) external payable {\r\n        if (!tokens[tokenIndex].exists) revert UnknownToken();\r\n        if (tokens[tokenIndex].maxAmount > 0) {\r\n            require(\r\n                amount <=\r\n                    tokens[tokenIndex].maxAmount.sub(\r\n                        balanceOf[msg.sender][tokenIndex]\r\n                    ),\r\n                \"Cannot mint over max amount\"\r\n            );\r\n        }\r\n        require(amount > 0, \"Amount must be greater than 0\");\r\n        require(\r\n            block.timestamp > tokens[tokenIndex].startTime &&\r\n                block.timestamp < tokens[tokenIndex].endTime,\r\n            \"time window closed\"\r\n        );\r\n        if (msg.value < amount.mul(tokens[tokenIndex].mintPrice))\r\n            revert NotEnoughFunds();\r\n        if (tokens[tokenIndex].maximum > 0) {\r\n            require(\r\n                tokens[tokenIndex].minted.add(amount) <=\r\n                    tokens[tokenIndex].maximum,\r\n                \"Maximum amount of tokens minted\"\r\n            );\r\n        }\r\n\r\n        if (!members[msg.sender]) {\r\n            if (memberCounter.current() >= maxMembers) revert(\"Club is full\");\r\n            members[msg.sender] = true;\r\n            memberCounter.increment();\r\n\r\n            emit Joined(msg.sender);\r\n        }\r\n\r\n        _mint(msg.sender, tokenIndex, amount, \"\");\r\n        tokens[tokenIndex].minted = tokens[tokenIndex].minted.add(amount);\r\n\r\n        emit Minted(msg.sender, tokenIndex, amount);\r\n    }\r\n\r\n    function withdraw() external onlySafe {\r\n        require(safeAddress != address(0), \"Club not initialized\");\r\n        require(address(this).balance > 0, \"No funds to withdraw\");\r\n\r\n        uint256 balance = address(this).balance;\r\n        uint256 rate = 500;\r\n\r\n        if (balance >= 50 ether && balance < 85 ether) {\r\n            rate = 425;\r\n        } else if (balance >= 85 ether && balance < 100 ether) {\r\n            rate = 385;\r\n        } else if (balance >= 100 ether && balance < 250 ether) {\r\n            rate = 325;\r\n        } else if (balance >= 250 ether && balance < 500 ether) {\r\n            rate = 250;\r\n        } else if (balance >= 500 ether) {\r\n            rate = 200;\r\n        }\r\n\r\n        uint256 coterieFee = address(this).balance.mul(rate).div(10000);\r\n        uint256 referralFee = 0;\r\n\r\n        if (referralAddress != address(0)) {\r\n            referralFee = coterieFee.div(10);\r\n            (bool referralSuccess, ) = referralAddress.call{value: referralFee}(\r\n                \"\"\r\n            );\r\n            if (!referralSuccess) {\r\n                revert(\"referral address failed to receive funds\");\r\n            }\r\n        }\r\n\r\n        (bool coterieSuccess, ) = coterieAddress.call{\r\n            value: coterieFee.sub(referralFee)\r\n        }(\"\");\r\n        if (!coterieSuccess) {\r\n            revert(\"Coterie address failed to receive funds\");\r\n        }\r\n\r\n        uint256 amountSentToSafe = address(this).balance;\r\n\r\n        (bool safeSuccess, ) = safeAddress.call{value: amountSentToSafe}(\"\");\r\n        if (!safeSuccess) {\r\n            revert(\"Safe address failed to receive funds\");\r\n        }\r\n\r\n        emit Withdrew(amountSentToSafe, rate);\r\n    }\r\n\r\n    function kick(address to) external payable onlySafe {\r\n        uint256 totalEtherToReturn = _getTokenValues(to);\r\n\r\n        if (msg.value < totalEtherToReturn) revert NotEnoughFunds();\r\n\r\n        _kick(to);\r\n\r\n        (bool success, ) = to.call{value: totalEtherToReturn}(\"\");\r\n        if (!success) {\r\n            revert(\"Failed to send funds to kicked member\");\r\n        }\r\n    }\r\n\r\n    function kickMultiple(address[] calldata to) external payable onlySafe {\r\n        require(to.length > 0, \"No members to kick\");\r\n        require(\r\n            to.length <= memberCounter.current(),\r\n            \"Too many addresses provided\"\r\n        );\r\n        require(msg.value > 0, \"No ether was sent\");\r\n\r\n        int256 balance = int256(msg.value);\r\n\r\n        for (uint256 i = 0; i < to.length; i++) {\r\n            uint256 etherToReturn = _getTokenValues(to[i]);\r\n            balance = balance - int256(etherToReturn);\r\n\r\n            if (balance < 0) revert NotEnoughFunds();\r\n\r\n            _kick(to[i]);\r\n\r\n            (bool success, ) = to[i].call{value: etherToReturn}(\"\");\r\n            if (!success) {\r\n                revert(\"Failed to send funds to kicked member\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function addMember(address to) public onlySafe {\r\n        require(memberCounter.current() < maxMembers, \"Club is full\");\r\n\r\n        _addMember(to);\r\n    }\r\n\r\n    function addMembers(address[] calldata to) external onlySafe {\r\n        require(to.length > 0, \"No members to add\");\r\n        require(\r\n            to.length.add(memberCounter.current()) <= maxMembers,\r\n            \"Too many addresses provided\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < to.length; i++) {\r\n            _addMember(to[i]);\r\n        }\r\n    }\r\n\r\n    function uri(uint256 id) public view override returns (string memory) {\r\n        if (!tokens[id].exists) revert UnknownToken();\r\n\r\n        return string(abi.encodePacked(\"ipfs://\", tokens[id].ipfsCID));\r\n    }\r\n}\r\n\r\n// File: ClubCreator.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\ncontract ClubCreator is CloneFactory {\r\n    address immutable masterClub;\r\n    IRicardianLLC immutable ricardianLLC;\r\n\r\n    mapping(address => Club) public clubs;\r\n\r\n    event ClubCreated(\r\n        address clubAddress,\r\n        string clubName,\r\n        string tokenSymbol,\r\n        string docs,\r\n        uint256 maxMembers,\r\n        address safeAddress,\r\n        address referalAddress\r\n    );\r\n\r\n    constructor(address _masterClub, IRicardianLLC _ricardianLLC) {\r\n        masterClub = _masterClub;\r\n        ricardianLLC = _ricardianLLC;\r\n    }\r\n\r\n    function createClub(\r\n        string memory _clubName,\r\n        string memory _tokenSymbol,\r\n        string memory _docs,\r\n        uint256 _maxMembers,\r\n        address _safeAddress,\r\n        address _referalAddress\r\n    ) external {\r\n        require(clubs[_safeAddress] == Club(address(0)), \"Club already exists\");\r\n\r\n        Club club = Club(createClone(masterClub));\r\n        club.init(\r\n            _clubName,\r\n            _tokenSymbol,\r\n            _docs,\r\n            _maxMembers,\r\n            _safeAddress,\r\n            _referalAddress\r\n        );\r\n\r\n        if (bytes(_docs).length == 0) {\r\n            ricardianLLC.mintLLC(_safeAddress);\r\n        }\r\n\r\n        clubs[_safeAddress] = club;\r\n\r\n        emit ClubCreated(\r\n            address(club),\r\n            _clubName,\r\n            _tokenSymbol,\r\n            _docs,\r\n            _maxMembers,\r\n            _safeAddress,\r\n            _referalAddress\r\n        );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterClub\",\"type\":\"address\"},{\"internalType\":\"contract IRicardianLLC\",\"name\":\"_ricardianLLC\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"clubAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"clubName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"docs\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxMembers\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"safeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referalAddress\",\"type\":\"address\"}],\"name\":\"ClubCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"clubs\",\"outputs\":[{\"internalType\":\"contract Club\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_clubName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_docs\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_maxMembers\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_safeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referalAddress\",\"type\":\"address\"}],\"name\":\"createClub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ClubCreator", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007546923ddb50b284c09a936e0f8ecd36c52bf4d200000000000000000000000043b644a01d87025c9046f12ee4cdec7e04258ebf", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://77d1a90c23227ad3c1279eed444f877f2e2f76f3e1835865117aa76931f23f8c"}]}