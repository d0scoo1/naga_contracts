{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"xWALLET.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\ninterface ISupplyController {\\n\\tfunction mintableVesting(address addr, uint end, uint amountPerSecond) external view returns (uint);\\n\\tfunction mintVesting(address recipient, uint end, uint amountPerSecond) external;\\n}\\n\\ninterface IWALLETToken {\\n\\tfunction transfer(address to, uint256 amount) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\tfunction balanceOf(address spender) external view returns (uint);\\n\\tfunction allowance(address owner, address spender) external view returns (uint);\\n\\tfunction totalSupply() external returns (uint);\\n\\tfunction supplyController() external view returns (ISupplyController);\\n\\t// function changeSupplyController(address newSupplyController) external;\\n}\\n\\ncontract StakingPool {\\n\\t// ERC20 stuff\\n\\t// Constants\\n\\tstring public constant name = \\\"Ambire Wallet Staking Token\\\";\\n\\tuint8 public constant decimals = 18;\\n\\tstring public constant symbol = \\\"xWALLET\\\";\\n\\n\\t// Mutable variables\\n\\tuint public totalSupply;\\n\\tmapping(address =\\u003e uint) private balances;\\n\\tmapping(address =\\u003e mapping(address =\\u003e uint)) private allowed;\\n\\n\\t// EIP 2612\\n\\tbytes32 public DOMAIN_SEPARATOR;\\n\\t// keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\tmapping(address =\\u003e uint) public nonces;\\n\\n\\t// ERC20 events\\n\\tevent Approval(address indexed owner, address indexed spender, uint amount);\\n\\tevent Transfer(address indexed from, address indexed to, uint amount);\\n\\n\\t// ERC20 methods\\n\\tfunction balanceOf(address owner) external view returns (uint balance) {\\n\\t\\treturn balances[owner];\\n\\t}\\n\\n\\tfunction transfer(address to, uint amount) external returns (bool success) {\\n\\t\\trequire(to != address(this), \\\"BAD_ADDRESS\\\");\\n\\t\\tbalances[msg.sender] = balances[msg.sender] - amount;\\n\\t\\tbalances[to] = balances[to] + amount;\\n\\t\\temit Transfer(msg.sender, to, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction transferFrom(address from, address to, uint amount) external returns (bool success) {\\n\\t\\tbalances[from] = balances[from] - amount;\\n\\t\\tallowed[from][msg.sender] = allowed[from][msg.sender] - amount;\\n\\t\\tbalances[to] = balances[to] + amount;\\n\\t\\temit Transfer(from, to, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction approve(address spender, uint amount) external returns (bool success) {\\n\\t\\tallowed[msg.sender][spender] = amount;\\n\\t\\temit Approval(msg.sender, spender, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction allowance(address owner, address spender) external view returns (uint remaining) {\\n\\t\\treturn allowed[owner][spender];\\n\\t}\\n\\n\\t// EIP 2612\\n\\tfunction permit(address owner, address spender, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\\n\\t\\trequire(deadline \\u003e= block.timestamp, \\\"DEADLINE_EXPIRED\\\");\\n\\t\\tbytes32 digest = keccak256(abi.encodePacked(\\n\\t\\t\\t\\\"\\\\x19\\\\x01\\\",\\n\\t\\t\\tDOMAIN_SEPARATOR,\\n\\t\\t\\tkeccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline))\\n\\t\\t));\\n\\t\\taddress recoveredAddress = ecrecover(digest, v, r, s);\\n\\t\\trequire(recoveredAddress != address(0) \\u0026\\u0026 recoveredAddress == owner, \\\"INVALID_SIGNATURE\\\");\\n\\t\\tallowed[owner][spender] = amount;\\n\\t\\temit Approval(owner, spender, amount);\\n\\t}\\n\\n\\t// Inner\\n\\tfunction innerMint(address owner, uint amount) internal {\\n\\t\\ttotalSupply = totalSupply + amount;\\n\\t\\tbalances[owner] = balances[owner] + amount;\\n\\t\\t// Because of https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transfer-1\\n\\t\\temit Transfer(address(0), owner, amount);\\n\\t}\\n\\tfunction innerBurn(address owner, uint amount) internal {\\n\\t\\ttotalSupply = totalSupply - amount;\\n\\t\\tbalances[owner] = balances[owner] - amount;\\n\\t\\temit Transfer(owner, address(0), amount);\\n\\t}\\n\\n\\t// Pool functionality\\n\\tuint public timeToUnbond = 20 days;\\n\\tuint public rageReceivedPromilles = 700;\\n\\t// Vesting parameters\\n\\t// we call .mintVesting to get the additional incentive tokens for this pool\\n\\tuint public vestingEnd = 1675576800;\\n\\tuint public vestingAmountPerSec = 1268391679350580000;\\n\\n\\tIWALLETToken public immutable WALLET;\\n\\taddress public governance;\\n\\n\\t// Commitment ID against the max amount of tokens it will pay out\\n\\tmapping (bytes32 =\\u003e uint) public commitments;\\n\\t// How many of a user\\u0027s shares are locked\\n\\tmapping (address =\\u003e uint) public lockedShares;\\n\\t// Unbonding commitment from a staker\\n\\tstruct UnbondCommitment {\\n\\t\\taddress owner;\\n\\t\\tuint shares;\\n\\t\\tuint unlocksAt;\\n\\t}\\n\\n\\t// Staking pool events\\n\\t// LogLeave/LogWithdraw must begin with the UnbondCommitment struct\\n\\tevent LogLeave(address indexed owner, uint shares, uint unlocksAt, uint maxTokens);\\n\\tevent LogWithdraw(address indexed owner, uint shares, uint unlocksAt, uint maxTokens, uint receivedTokens);\\n\\tevent LogRageLeave(address indexed owner, uint shares, uint maxTokens, uint receivedTokens);\\n\\n\\tconstructor(IWALLETToken token, address governanceAddr) {\\n\\t\\tWALLET = token;\\n\\t\\tgovernance = governanceAddr;\\n\\n\\t\\t// EIP 2612\\n\\t\\tuint chainId;\\n\\t\\tassembly {\\n\\t\\t\\tchainId := chainid()\\n\\t\\t}\\n\\t\\tDOMAIN_SEPARATOR = keccak256(\\n\\t\\t\\tabi.encode(\\n\\t\\t\\t\\tkeccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n\\t\\t\\t\\tkeccak256(bytes(name)),\\n\\t\\t\\t\\tkeccak256(bytes(\\\"1\\\")),\\n\\t\\t\\t\\tchainId,\\n\\t\\t\\t\\taddress(this)\\n\\t\\t\\t)\\n\\t\\t);\\n\\t}\\n\\n\\t// Governance functions\\n\\tfunction setGovernance(address addr) external {\\n\\t\\trequire(governance == msg.sender, \\\"NOT_GOVERNANCE\\\");\\n\\t\\tgovernance = addr;\\n\\t}\\n\\tfunction setRageReceived(uint rageReceived) external {\\n\\t\\trequire(governance == msg.sender, \\\"NOT_GOVERNANCE\\\");\\n\\t\\t// AUDIT: should there be a minimum here?\\n\\t\\trequire(rageReceived \\u003c= 1000, \\\"TOO_LARGE\\\");\\n\\t\\trageReceivedPromilles = rageReceived;\\n\\t}\\n\\tfunction setTimeToUnbond(uint time) external {\\n\\t\\trequire(governance == msg.sender, \\\"NOT_GOVERNANCE\\\");\\n\\t\\trequire(time \\u003e= 1 days \\u0026\\u0026 time \\u003c= 30 days, \\\"BOUNDS\\\");\\n\\t\\ttimeToUnbond = time;\\n\\t}\\n\\tfunction setVestingParams(uint end, uint amountPerSecond) external {\\n\\t\\trequire(governance == msg.sender, \\\"NOT_GOVERNANCE\\\");\\n\\t\\tvestingEnd = end;\\n\\t\\tvestingAmountPerSec = amountPerSecond;\\n\\t}\\n\\n\\t// Pool stuff\\n\\tfunction shareValue() external view returns (uint) {\\n\\t\\tif (totalSupply == 0) return 0;\\n\\t\\treturn ((WALLET.balanceOf(address(this)) + WALLET.supplyController().mintableVesting(address(this), vestingEnd, vestingAmountPerSec))\\n\\t\\t\\t* 1e18)\\n\\t\\t\\t/ totalSupply;\\n\\t}\\n\\n\\tfunction innerEnter(address recipient, uint amount) internal {\\n\\t\\t// Please note that minting has to be in the beginning so that we take it into account\\n\\t\\t// when using IWALLETToken.balanceOf()\\n\\t\\t// Minting makes an external call but it\\\"s to a trusted contract (IIWALLETToken)\\n\\t\\tWALLET.supplyController().mintVesting(address(this), vestingEnd, vestingAmountPerSec);\\n\\n\\t\\tuint totalWALLET = WALLET.balanceOf(address(this));\\n\\n\\t\\t// The totalWALLET == 0 check here should be redudnant; the only way to get totalSupply to a nonzero val is by adding WALLET\\n\\t\\tif (totalSupply == 0 || totalWALLET == 0) {\\n\\t\\t\\tinnerMint(recipient, amount);\\n\\t\\t} else {\\n\\t\\t\\tuint256 newShares = (amount * totalSupply) / totalWALLET;\\n\\t\\t\\tinnerMint(recipient, newShares);\\n\\t\\t}\\n\\t\\t// AUDIT: no need to check return value cause WALLET throws\\n\\t\\tWALLET.transferFrom(msg.sender, address(this), amount);\\n\\t\\t// no events, as innerMint already emits enough to know the shares amount and price\\n\\t}\\n\\n\\tfunction enter(uint amount) external {\\n\\t\\tinnerEnter(msg.sender, amount);\\n\\t}\\n\\n\\tfunction enterTo(address recipient, uint amount) external {\\n\\t\\tinnerEnter(recipient, amount);\\n\\t}\\n\\n\\tfunction unbondingCommitmentWorth(address owner, uint shares, uint unlocksAt) external view returns (uint) {\\n\\t\\tif (totalSupply == 0) return 0;\\n\\t\\tbytes32 commitmentId = keccak256(abi.encode(UnbondCommitment({ owner: owner, shares: shares, unlocksAt: unlocksAt })));\\n\\t\\tuint maxTokens = commitments[commitmentId];\\n\\t\\tuint totalWALLET = WALLET.balanceOf(address(this));\\n\\t\\tuint currentTokens = (shares * totalWALLET) / totalSupply;\\n\\t\\treturn currentTokens \\u003e maxTokens ? maxTokens : currentTokens;\\n\\t}\\n\\n\\tfunction leave(uint shares, bool skipMint) external {\\n\\t\\tif (!skipMint) WALLET.supplyController().mintVesting(address(this), vestingEnd, vestingAmountPerSec);\\n\\n\\t\\trequire(shares \\u003c= balances[msg.sender] - lockedShares[msg.sender], \\\"INSUFFICIENT_SHARES\\\");\\n\\t\\tuint totalWALLET = WALLET.balanceOf(address(this));\\n\\t\\tuint maxTokens = (shares * totalWALLET) / totalSupply;\\n\\t\\tuint unlocksAt = block.timestamp + timeToUnbond;\\n\\t\\tbytes32 commitmentId = keccak256(abi.encode(UnbondCommitment({ owner: msg.sender, shares: shares, unlocksAt: unlocksAt })));\\n\\t\\trequire(commitments[commitmentId] == 0, \\\"COMMITMENT_EXISTS\\\");\\n\\n\\t\\tcommitments[commitmentId] = maxTokens;\\n\\t\\tlockedShares[msg.sender] += shares;\\n\\n\\t\\temit LogLeave(msg.sender, shares, unlocksAt, maxTokens);\\n\\t}\\n\\n\\tfunction withdraw(uint shares, uint unlocksAt, bool skipMint) external {\\n\\t\\tif (!skipMint) WALLET.supplyController().mintVesting(address(this), vestingEnd, vestingAmountPerSec);\\n\\n\\t\\trequire(block.timestamp \\u003e unlocksAt, \\\"UNLOCK_TOO_EARLY\\\");\\n\\t\\tbytes32 commitmentId = keccak256(abi.encode(UnbondCommitment({ owner: msg.sender, shares: shares, unlocksAt: unlocksAt })));\\n\\t\\tuint maxTokens = commitments[commitmentId];\\n\\t\\trequire(maxTokens \\u003e 0, \\\"NO_COMMITMENT\\\");\\n\\t\\tuint totalWALLET = WALLET.balanceOf(address(this));\\n\\t\\tuint currentTokens = (shares * totalWALLET) / totalSupply;\\n\\t\\tuint receivedTokens = currentTokens \\u003e maxTokens ? maxTokens : currentTokens;\\n\\n\\t\\tcommitments[commitmentId] = 0;\\n\\t\\tlockedShares[msg.sender] -= shares;\\n\\n\\t\\tinnerBurn(msg.sender, shares);\\n\\t\\t// AUDIT: no need to check return value cause WALLET throws\\n\\t\\tWALLET.transfer(msg.sender, receivedTokens);\\n\\n\\t\\temit LogWithdraw(msg.sender, shares, unlocksAt, maxTokens, receivedTokens);\\n\\t}\\n\\n\\tfunction rageLeave(uint shares, bool skipMint) external {\\n\\t\\tif (!skipMint) WALLET.supplyController().mintVesting(address(this), vestingEnd, vestingAmountPerSec);\\n\\n\\t\\tuint totalWALLET = WALLET.balanceOf(address(this));\\n\\t\\tuint walletAmount = (shares * totalWALLET) / totalSupply;\\n\\t\\tuint receivedTokens = (walletAmount * rageReceivedPromilles) / 1000;\\n\\t\\tinnerBurn(msg.sender, shares);\\n\\t\\t// AUDIT: no need to check return value cause WALLET throws\\n\\t\\tWALLET.transfer(msg.sender, receivedTokens);\\n\\n\\t\\temit LogRageLeave(msg.sender, shares, walletAmount, receivedTokens);\\n\\t}\\n}\\n\"},\"xWALLETSpendable.sol\":{\"content\":\"pragma solidity ^0.8.7;\\nimport \\\"./xWALLET.sol\\\";\\n\\ncontract xWALLETSpendable {\\n\\tfunction balanceOf(address who) external view returns (uint256 balance) {\\n\\t\\tStakingPool xWALLET = StakingPool(0x47Cd7E91C3CBaAF266369fe8518345fc4FC12935);\\n\\t\\treturn xWALLET.balanceOf(who) - xWALLET.lockedShares(who);\\n\\t}\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "xWALLETSpendable", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://076078db328dcac34ec9466154535406a6b23f88adae61613cdeafa312f65952"}]}