{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/compiled/MerkVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n/*\\n    Copyright 2021 0KIMS association.\\n\\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\\n\\n    snarkJS is a free software: you can redistribute it and/or modify it\\n    under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\\n    License for more details.\\n\\n    You should have received a copy of the GNU General Public License\\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\\n*/\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\ncontract PlonkVerifier {\\n    uint32 constant n = 32768;\\n    uint16 constant nPublic = 3;\\n    uint16 constant nLagrange = 3;\\n\\n    uint256 constant Qmx =\\n        7633701027557894812437384272860262977745641767064941353755666083723179169146;\\n    uint256 constant Qmy =\\n        11835299870584659087959133320928706039877868692304967454772301345988814739079;\\n    uint256 constant Qlx =\\n        11420585269866551882877042058303547982363041392313108966781137406018780309322;\\n    uint256 constant Qly =\\n        21380283591675498479445345609945652531253120448721421979938036399273996036111;\\n    uint256 constant Qrx =\\n        4809420704576901308839751600989360384125792904874919296441027845980039290741;\\n    uint256 constant Qry =\\n        19284716813409203142285153696710604118156666084418620472704522819775870485467;\\n    uint256 constant Qox =\\n        7354395353433268943428790164066389519053364282224049938777557163917816561333;\\n    uint256 constant Qoy =\\n        3197178150768092496939867834990864752943290988624902108845391543439097460127;\\n    uint256 constant Qcx =\\n        20453733050114230625399123136091278156621805079941898312893642527288424635431;\\n    uint256 constant Qcy =\\n        6460147133415283217689075630647292377563584683926884462761429058317378903143;\\n    uint256 constant S1x =\\n        12247062580429515566888855420833928250392409006427380222281107658275298259107;\\n    uint256 constant S1y =\\n        17568478942328471181412772245576466621416447814789251891543511372271039919672;\\n    uint256 constant S2x =\\n        2926456940342502101978661494324194273729933224695120755144414243966593069338;\\n    uint256 constant S2y =\\n        295875426846452251119676247468910269498210174703117467941177268479317198112;\\n    uint256 constant S3x =\\n        13184055717670166728175293592226058550054178364602505947351183279374839098420;\\n    uint256 constant S3y =\\n        16890644142429390636754057842341093045238797087400837928614252626385548086554;\\n    uint256 constant k1 = 2;\\n    uint256 constant k2 = 3;\\n    uint256 constant X2x1 =\\n        21831381940315734285607113342023901060522397560371972897001948545212302161822;\\n    uint256 constant X2x2 =\\n        17231025384763736816414546592865244497437017442647097510447326538965263639101;\\n    uint256 constant X2y1 =\\n        2388026358213174446665280700919698872609886601280537296205114254867301080648;\\n    uint256 constant X2y2 =\\n        11507326595632554467052522095592665270651932854513688777769618397986436103170;\\n\\n    uint256 constant q =\\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n    uint256 constant qf =\\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 constant w1 =\\n        20402931748843538985151001264530049874871572933694634836567070693966133783803;\\n\\n    uint256 constant G1x = 1;\\n    uint256 constant G1y = 2;\\n    uint256 constant G2x1 =\\n        10857046999023057135944570762232829481370756359578518086990519993285655852781;\\n    uint256 constant G2x2 =\\n        11559732032986387107991004021392285783925812861821192530917403151452391805634;\\n    uint256 constant G2y1 =\\n        8495653923123431417604973247489272438418190587263600148770280649306958101930;\\n    uint256 constant G2y2 =\\n        4082367875863433681332203403145435568316851327593401208105741076214120093531;\\n    uint16 constant pA = 32;\\n    uint16 constant pB = 96;\\n    uint16 constant pC = 160;\\n    uint16 constant pZ = 224;\\n    uint16 constant pT1 = 288;\\n    uint16 constant pT2 = 352;\\n    uint16 constant pT3 = 416;\\n    uint16 constant pWxi = 480;\\n    uint16 constant pWxiw = 544;\\n    uint16 constant pEval_a = 608;\\n    uint16 constant pEval_b = 640;\\n    uint16 constant pEval_c = 672;\\n    uint16 constant pEval_s1 = 704;\\n    uint16 constant pEval_s2 = 736;\\n    uint16 constant pEval_zw = 768;\\n    uint16 constant pEval_r = 800;\\n\\n    uint16 constant pAlpha = 0;\\n    uint16 constant pBeta = 32;\\n    uint16 constant pGamma = 64;\\n    uint16 constant pXi = 96;\\n    uint16 constant pXin = 128;\\n    uint16 constant pBetaXi = 160;\\n    uint16 constant pV1 = 192;\\n    uint16 constant pV2 = 224;\\n    uint16 constant pV3 = 256;\\n    uint16 constant pV4 = 288;\\n    uint16 constant pV5 = 320;\\n    uint16 constant pV6 = 352;\\n    uint16 constant pU = 384;\\n    uint16 constant pPl = 416;\\n    uint16 constant pEval_t = 448;\\n    uint16 constant pA1 = 480;\\n    uint16 constant pB1 = 544;\\n    uint16 constant pZh = 608;\\n    uint16 constant pZhInv = 640;\\n\\n    uint16 constant pEval_l1 = 672;\\n\\n    uint16 constant pEval_l2 = 704;\\n\\n    uint16 constant pEval_l3 = 736;\\n\\n    uint16 constant lastMem = 768;\\n\\n    function verifyProof(bytes memory proof, uint256[] memory pubSignals)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        assembly {\\n            /////////\\n            // Computes the inverse using the extended euclidean algorithm\\n            /////////\\n            function inverse(a, q) -> inv {\\n                let t := 0\\n                let newt := 1\\n                let r := q\\n                let newr := a\\n                let quotient\\n                let aux\\n\\n                for {\\n\\n                } newr {\\n\\n                } {\\n                    quotient := sdiv(r, newr)\\n                    aux := sub(t, mul(quotient, newt))\\n                    t := newt\\n                    newt := aux\\n\\n                    aux := sub(r, mul(quotient, newr))\\n                    r := newr\\n                    newr := aux\\n                }\\n\\n                if gt(r, 1) {\\n                    revert(0, 0)\\n                }\\n                if slt(t, 0) {\\n                    t := add(t, q)\\n                }\\n\\n                inv := t\\n            }\\n\\n            ///////\\n            // Computes the inverse of an array of values\\n            // See https://vitalik.ca/general/2018/07/21/starks_part_3.html in section where explain fields operations\\n            //////\\n            function inverseArray(pVals, n) {\\n                let pAux := mload(0x40) // Point to the next free position\\n                let pIn := pVals\\n                let lastPIn := add(pVals, mul(n, 32)) // Read n elemnts\\n                let acc := mload(pIn) // Read the first element\\n                pIn := add(pIn, 32) // Point to the second element\\n                let inv\\n\\n                for {\\n\\n                } lt(pIn, lastPIn) {\\n                    pAux := add(pAux, 32)\\n                    pIn := add(pIn, 32)\\n                } {\\n                    mstore(pAux, acc)\\n                    acc := mulmod(acc, mload(pIn), q)\\n                }\\n                acc := inverse(acc, q)\\n\\n                // At this point pAux pint to the next free position we substract 1 to point to the last used\\n                pAux := sub(pAux, 32)\\n                // pIn points to the n+1 element, we substract to point to n\\n                pIn := sub(pIn, 32)\\n                lastPIn := pVals // We don't process the first element\\n                for {\\n\\n                } gt(pIn, lastPIn) {\\n                    pAux := sub(pAux, 32)\\n                    pIn := sub(pIn, 32)\\n                } {\\n                    inv := mulmod(acc, mload(pAux), q)\\n                    acc := mulmod(acc, mload(pIn), q)\\n                    mstore(pIn, inv)\\n                }\\n                // pIn points to first element, we just set it.\\n                mstore(pIn, acc)\\n            }\\n\\n            function checkField(v) {\\n                if iszero(lt(v, q)) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n            }\\n\\n            function checkInput(pProof) {\\n                if iszero(eq(mload(pProof), 800)) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n                checkField(mload(add(pProof, pEval_a)))\\n                checkField(mload(add(pProof, pEval_b)))\\n                checkField(mload(add(pProof, pEval_c)))\\n                checkField(mload(add(pProof, pEval_s1)))\\n                checkField(mload(add(pProof, pEval_s2)))\\n                checkField(mload(add(pProof, pEval_zw)))\\n                checkField(mload(add(pProof, pEval_r)))\\n\\n                // Points are checked in the point operations precompiled smart contracts\\n            }\\n\\n            function calculateChallanges(pProof, pMem) {\\n                let a\\n                let b\\n\\n                b := mod(keccak256(add(pProof, pA), 192), q)\\n                mstore(add(pMem, pBeta), b)\\n                mstore(\\n                    add(pMem, pGamma),\\n                    mod(keccak256(add(pMem, pBeta), 32), q)\\n                )\\n                mstore(\\n                    add(pMem, pAlpha),\\n                    mod(keccak256(add(pProof, pZ), 64), q)\\n                )\\n\\n                a := mod(keccak256(add(pProof, pT1), 192), q)\\n                mstore(add(pMem, pXi), a)\\n                mstore(add(pMem, pBetaXi), mulmod(b, a, q))\\n\\n                a := mulmod(a, a, q)\\n\\n                a := mulmod(a, a, q)\\n\\n                a := mulmod(a, a, q)\\n\\n                a := mulmod(a, a, q)\\n\\n                a := mulmod(a, a, q)\\n\\n                a := mulmod(a, a, q)\\n\\n                a := mulmod(a, a, q)\\n\\n                a := mulmod(a, a, q)\\n\\n                a := mulmod(a, a, q)\\n\\n                a := mulmod(a, a, q)\\n\\n                a := mulmod(a, a, q)\\n\\n                a := mulmod(a, a, q)\\n\\n                a := mulmod(a, a, q)\\n\\n                a := mulmod(a, a, q)\\n\\n                a := mulmod(a, a, q)\\n\\n                mstore(add(pMem, pXin), a)\\n                a := mod(add(sub(a, 1), q), q)\\n                mstore(add(pMem, pZh), a)\\n                mstore(add(pMem, pZhInv), a) // We will invert later together with lagrange pols\\n\\n                let v1 := mod(keccak256(add(pProof, pEval_a), 224), q)\\n                mstore(add(pMem, pV1), v1)\\n                a := mulmod(v1, v1, q)\\n                mstore(add(pMem, pV2), a)\\n                a := mulmod(a, v1, q)\\n                mstore(add(pMem, pV3), a)\\n                a := mulmod(a, v1, q)\\n                mstore(add(pMem, pV4), a)\\n                a := mulmod(a, v1, q)\\n                mstore(add(pMem, pV5), a)\\n                a := mulmod(a, v1, q)\\n                mstore(add(pMem, pV6), a)\\n\\n                mstore(add(pMem, pU), mod(keccak256(add(pProof, pWxi), 128), q))\\n            }\\n\\n            function calculateLagrange(pMem) {\\n                let w := 1\\n\\n                mstore(\\n                    add(pMem, pEval_l1),\\n                    mulmod(n, mod(add(sub(mload(add(pMem, pXi)), w), q), q), q)\\n                )\\n\\n                w := mulmod(w, w1, q)\\n\\n                mstore(\\n                    add(pMem, pEval_l2),\\n                    mulmod(n, mod(add(sub(mload(add(pMem, pXi)), w), q), q), q)\\n                )\\n\\n                w := mulmod(w, w1, q)\\n\\n                mstore(\\n                    add(pMem, pEval_l3),\\n                    mulmod(n, mod(add(sub(mload(add(pMem, pXi)), w), q), q), q)\\n                )\\n\\n                inverseArray(add(pMem, pZhInv), 4)\\n\\n                let zh := mload(add(pMem, pZh))\\n                w := 1\\n\\n                mstore(\\n                    add(pMem, pEval_l1),\\n                    mulmod(mload(add(pMem, pEval_l1)), zh, q)\\n                )\\n\\n                w := mulmod(w, w1, q)\\n\\n                mstore(\\n                    add(pMem, pEval_l2),\\n                    mulmod(w, mulmod(mload(add(pMem, pEval_l2)), zh, q), q)\\n                )\\n\\n                w := mulmod(w, w1, q)\\n\\n                mstore(\\n                    add(pMem, pEval_l3),\\n                    mulmod(w, mulmod(mload(add(pMem, pEval_l3)), zh, q), q)\\n                )\\n            }\\n\\n            function calculatePl(pMem, pPub) {\\n                let pl := 0\\n\\n                pl := mod(\\n                    add(\\n                        sub(\\n                            pl,\\n                            mulmod(\\n                                mload(add(pMem, pEval_l1)),\\n                                mload(add(pPub, 32)),\\n                                q\\n                            )\\n                        ),\\n                        q\\n                    ),\\n                    q\\n                )\\n\\n                pl := mod(\\n                    add(\\n                        sub(\\n                            pl,\\n                            mulmod(\\n                                mload(add(pMem, pEval_l2)),\\n                                mload(add(pPub, 64)),\\n                                q\\n                            )\\n                        ),\\n                        q\\n                    ),\\n                    q\\n                )\\n\\n                pl := mod(\\n                    add(\\n                        sub(\\n                            pl,\\n                            mulmod(\\n                                mload(add(pMem, pEval_l3)),\\n                                mload(add(pPub, 96)),\\n                                q\\n                            )\\n                        ),\\n                        q\\n                    ),\\n                    q\\n                )\\n\\n                mstore(add(pMem, pPl), pl)\\n            }\\n\\n            function calculateT(pProof, pMem) {\\n                let t\\n                let t1\\n                let t2\\n                t := addmod(\\n                    mload(add(pProof, pEval_r)),\\n                    mload(add(pMem, pPl)),\\n                    q\\n                )\\n\\n                t1 := mulmod(\\n                    mload(add(pProof, pEval_s1)),\\n                    mload(add(pMem, pBeta)),\\n                    q\\n                )\\n\\n                t1 := addmod(t1, mload(add(pProof, pEval_a)), q)\\n\\n                t1 := addmod(t1, mload(add(pMem, pGamma)), q)\\n\\n                t2 := mulmod(\\n                    mload(add(pProof, pEval_s2)),\\n                    mload(add(pMem, pBeta)),\\n                    q\\n                )\\n\\n                t2 := addmod(t2, mload(add(pProof, pEval_b)), q)\\n\\n                t2 := addmod(t2, mload(add(pMem, pGamma)), q)\\n\\n                t1 := mulmod(t1, t2, q)\\n\\n                t2 := addmod(\\n                    mload(add(pProof, pEval_c)),\\n                    mload(add(pMem, pGamma)),\\n                    q\\n                )\\n\\n                t1 := mulmod(t1, t2, q)\\n                t1 := mulmod(t1, mload(add(pProof, pEval_zw)), q)\\n                t1 := mulmod(t1, mload(add(pMem, pAlpha)), q)\\n\\n                t2 := mulmod(\\n                    mload(add(pMem, pEval_l1)),\\n                    mload(add(pMem, pAlpha)),\\n                    q\\n                )\\n\\n                t2 := mulmod(t2, mload(add(pMem, pAlpha)), q)\\n\\n                t1 := addmod(t1, t2, q)\\n\\n                t := mod(sub(add(t, q), t1), q)\\n                t := mulmod(t, mload(add(pMem, pZhInv)), q)\\n\\n                mstore(add(pMem, pEval_t), t)\\n            }\\n\\n            function g1_set(pR, pP) {\\n                mstore(pR, mload(pP))\\n                mstore(add(pR, 32), mload(add(pP, 32)))\\n            }\\n\\n            function g1_acc(pR, pP) {\\n                let mIn := mload(0x40)\\n                mstore(mIn, mload(pR))\\n                mstore(add(mIn, 32), mload(add(pR, 32)))\\n                mstore(add(mIn, 64), mload(pP))\\n                mstore(add(mIn, 96), mload(add(pP, 32)))\\n\\n                let success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\\n\\n                if iszero(success) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n            }\\n\\n            function g1_mulAcc(pR, pP, s) {\\n                let success\\n                let mIn := mload(0x40)\\n                mstore(mIn, mload(pP))\\n                mstore(add(mIn, 32), mload(add(pP, 32)))\\n                mstore(add(mIn, 64), s)\\n\\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\\n\\n                if iszero(success) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n\\n                mstore(add(mIn, 64), mload(pR))\\n                mstore(add(mIn, 96), mload(add(pR, 32)))\\n\\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\\n\\n                if iszero(success) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n            }\\n\\n            function g1_mulAccC(pR, x, y, s) {\\n                let success\\n                let mIn := mload(0x40)\\n                mstore(mIn, x)\\n                mstore(add(mIn, 32), y)\\n                mstore(add(mIn, 64), s)\\n\\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\\n\\n                if iszero(success) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n\\n                mstore(add(mIn, 64), mload(pR))\\n                mstore(add(mIn, 96), mload(add(pR, 32)))\\n\\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\\n\\n                if iszero(success) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n            }\\n\\n            function g1_mulSetC(pR, x, y, s) {\\n                let success\\n                let mIn := mload(0x40)\\n                mstore(mIn, x)\\n                mstore(add(mIn, 32), y)\\n                mstore(add(mIn, 64), s)\\n\\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, pR, 64)\\n\\n                if iszero(success) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n            }\\n\\n            function calculateA1(pProof, pMem) {\\n                let p := add(pMem, pA1)\\n                g1_set(p, add(pProof, pWxi))\\n                g1_mulAcc(p, add(pProof, pWxiw), mload(add(pMem, pU)))\\n            }\\n\\n            function calculateB1(pProof, pMem) {\\n                let s\\n                let s1\\n                let p := add(pMem, pB1)\\n\\n                // Calculate D\\n                s := mulmod(\\n                    mload(add(pProof, pEval_a)),\\n                    mload(add(pMem, pV1)),\\n                    q\\n                )\\n                g1_mulSetC(p, Qlx, Qly, s)\\n\\n                s := mulmod(s, mload(add(pProof, pEval_b)), q)\\n                g1_mulAccC(p, Qmx, Qmy, s)\\n\\n                s := mulmod(\\n                    mload(add(pProof, pEval_b)),\\n                    mload(add(pMem, pV1)),\\n                    q\\n                )\\n                g1_mulAccC(p, Qrx, Qry, s)\\n\\n                s := mulmod(\\n                    mload(add(pProof, pEval_c)),\\n                    mload(add(pMem, pV1)),\\n                    q\\n                )\\n                g1_mulAccC(p, Qox, Qoy, s)\\n\\n                s := mload(add(pMem, pV1))\\n                g1_mulAccC(p, Qcx, Qcy, s)\\n\\n                s := addmod(\\n                    mload(add(pProof, pEval_a)),\\n                    mload(add(pMem, pBetaXi)),\\n                    q\\n                )\\n                s := addmod(s, mload(add(pMem, pGamma)), q)\\n                s1 := mulmod(k1, mload(add(pMem, pBetaXi)), q)\\n                s1 := addmod(s1, mload(add(pProof, pEval_b)), q)\\n                s1 := addmod(s1, mload(add(pMem, pGamma)), q)\\n                s := mulmod(s, s1, q)\\n                s1 := mulmod(k2, mload(add(pMem, pBetaXi)), q)\\n                s1 := addmod(s1, mload(add(pProof, pEval_c)), q)\\n                s1 := addmod(s1, mload(add(pMem, pGamma)), q)\\n                s := mulmod(s, s1, q)\\n                s := mulmod(s, mload(add(pMem, pAlpha)), q)\\n                s := mulmod(s, mload(add(pMem, pV1)), q)\\n                s1 := mulmod(\\n                    mload(add(pMem, pEval_l1)),\\n                    mload(add(pMem, pAlpha)),\\n                    q\\n                )\\n                s1 := mulmod(s1, mload(add(pMem, pAlpha)), q)\\n                s1 := mulmod(s1, mload(add(pMem, pV1)), q)\\n                s := addmod(s, s1, q)\\n                s := addmod(s, mload(add(pMem, pU)), q)\\n                g1_mulAcc(p, add(pProof, pZ), s)\\n\\n                s := mulmod(\\n                    mload(add(pMem, pBeta)),\\n                    mload(add(pProof, pEval_s1)),\\n                    q\\n                )\\n                s := addmod(s, mload(add(pProof, pEval_a)), q)\\n                s := addmod(s, mload(add(pMem, pGamma)), q)\\n                s1 := mulmod(\\n                    mload(add(pMem, pBeta)),\\n                    mload(add(pProof, pEval_s2)),\\n                    q\\n                )\\n                s1 := addmod(s1, mload(add(pProof, pEval_b)), q)\\n                s1 := addmod(s1, mload(add(pMem, pGamma)), q)\\n                s := mulmod(s, s1, q)\\n                s := mulmod(s, mload(add(pMem, pAlpha)), q)\\n                s := mulmod(s, mload(add(pMem, pV1)), q)\\n                s := mulmod(s, mload(add(pMem, pBeta)), q)\\n                s := mulmod(s, mload(add(pProof, pEval_zw)), q)\\n                s := mod(sub(q, s), q)\\n                g1_mulAccC(p, S3x, S3y, s)\\n\\n                // calculate F\\n                g1_acc(p, add(pProof, pT1))\\n\\n                s := mload(add(pMem, pXin))\\n                g1_mulAcc(p, add(pProof, pT2), s)\\n\\n                s := mulmod(s, s, q)\\n                g1_mulAcc(p, add(pProof, pT3), s)\\n\\n                g1_mulAcc(p, add(pProof, pA), mload(add(pMem, pV2)))\\n                g1_mulAcc(p, add(pProof, pB), mload(add(pMem, pV3)))\\n                g1_mulAcc(p, add(pProof, pC), mload(add(pMem, pV4)))\\n                g1_mulAccC(p, S1x, S1y, mload(add(pMem, pV5)))\\n                g1_mulAccC(p, S2x, S2y, mload(add(pMem, pV6)))\\n\\n                // calculate E\\n                s := mload(add(pMem, pEval_t))\\n                s := addmod(\\n                    s,\\n                    mulmod(\\n                        mload(add(pProof, pEval_r)),\\n                        mload(add(pMem, pV1)),\\n                        q\\n                    ),\\n                    q\\n                )\\n                s := addmod(\\n                    s,\\n                    mulmod(\\n                        mload(add(pProof, pEval_a)),\\n                        mload(add(pMem, pV2)),\\n                        q\\n                    ),\\n                    q\\n                )\\n                s := addmod(\\n                    s,\\n                    mulmod(\\n                        mload(add(pProof, pEval_b)),\\n                        mload(add(pMem, pV3)),\\n                        q\\n                    ),\\n                    q\\n                )\\n                s := addmod(\\n                    s,\\n                    mulmod(\\n                        mload(add(pProof, pEval_c)),\\n                        mload(add(pMem, pV4)),\\n                        q\\n                    ),\\n                    q\\n                )\\n                s := addmod(\\n                    s,\\n                    mulmod(\\n                        mload(add(pProof, pEval_s1)),\\n                        mload(add(pMem, pV5)),\\n                        q\\n                    ),\\n                    q\\n                )\\n                s := addmod(\\n                    s,\\n                    mulmod(\\n                        mload(add(pProof, pEval_s2)),\\n                        mload(add(pMem, pV6)),\\n                        q\\n                    ),\\n                    q\\n                )\\n                s := addmod(\\n                    s,\\n                    mulmod(\\n                        mload(add(pProof, pEval_zw)),\\n                        mload(add(pMem, pU)),\\n                        q\\n                    ),\\n                    q\\n                )\\n                s := mod(sub(q, s), q)\\n                g1_mulAccC(p, G1x, G1y, s)\\n\\n                // Last part of B\\n                s := mload(add(pMem, pXi))\\n                g1_mulAcc(p, add(pProof, pWxi), s)\\n\\n                s := mulmod(mload(add(pMem, pU)), mload(add(pMem, pXi)), q)\\n                s := mulmod(s, w1, q)\\n                g1_mulAcc(p, add(pProof, pWxiw), s)\\n            }\\n\\n            function checkPairing(pMem) -> isOk {\\n                let mIn := mload(0x40)\\n                mstore(mIn, mload(add(pMem, pA1)))\\n                mstore(add(mIn, 32), mload(add(add(pMem, pA1), 32)))\\n                mstore(add(mIn, 64), X2x2)\\n                mstore(add(mIn, 96), X2x1)\\n                mstore(add(mIn, 128), X2y2)\\n                mstore(add(mIn, 160), X2y1)\\n                mstore(add(mIn, 192), mload(add(pMem, pB1)))\\n                let s := mload(add(add(pMem, pB1), 32))\\n                s := mod(sub(qf, s), qf)\\n                mstore(add(mIn, 224), s)\\n                mstore(add(mIn, 256), G2x2)\\n                mstore(add(mIn, 288), G2x1)\\n                mstore(add(mIn, 320), G2y2)\\n                mstore(add(mIn, 352), G2y1)\\n\\n                let success := staticcall(\\n                    sub(gas(), 2000),\\n                    8,\\n                    mIn,\\n                    384,\\n                    mIn,\\n                    0x20\\n                )\\n\\n                isOk := and(success, mload(mIn))\\n            }\\n\\n            let pMem := mload(0x40)\\n            mstore(0x40, add(pMem, lastMem))\\n\\n            checkInput(proof)\\n            calculateChallanges(proof, pMem)\\n            calculateLagrange(pMem)\\n            calculatePl(pMem, pubSignals)\\n            calculateT(proof, pMem)\\n            calculateA1(proof, pMem)\\n            calculateB1(proof, pMem)\\n            let isValid := checkPairing(pMem)\\n\\n            mstore(0x40, sub(pMem, lastMem))\\n            mstore(0, isValid)\\n            return(0, 0x20)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 7500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"pubSignals\",\"type\":\"uint256[]\"}],\"name\":\"verifyProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PlonkVerifier", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "7500", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}