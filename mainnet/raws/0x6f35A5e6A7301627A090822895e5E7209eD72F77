{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/yam.sol\": {\r\n      \"content\": \"pragma solidity >= 0.5.0 < 0.6.0;\\r\\n\\r\\nimport \\\"./TokenInfoLib.sol\\\";\\r\\nimport \\\"./SymbolsLib.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./SignedSafeMath.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./SavingAccountParameters.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./ABDK.sol\\\";\\r\\nimport \\\"./tokenbasic.sol\\\";\\r\\nimport \\\"./bkk.sol\\\";\\r\\n\\r\\npragma solidity ^0.5.5;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following \\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256('')`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash && codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` into `address payable`. Note that this is\\r\\n     * simply a type cast: the actual underlying value is not changed.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function toPayable(address account) internal pure returns (address payable) {\\r\\n        return address(uint160(account));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-call-value\\r\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves.\\r\\n\\r\\n        // A Solidity high level call has three parts:\\r\\n        //  1. The target address is checked to verify it contains contract code\\r\\n        //  2. The call itself is made, and success asserted\\r\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\r\\n\\r\\n        if (returndata.length > 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a >= b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\ninterface AllPool{\\r\\n    function is_Re(address user) view external  returns(bool);\\r\\n    // function set_user_isRe(address user,address pool,string calldata name) external;\\r\\n    function get_Address_pool(address user) view external  returns(address);\\r\\n}\\r\\n\\r\\ninterface IPlayerBook {\\r\\n    function settleReward( address from,uint256 amount ) external returns (uint256);\\r\\n}\\r\\ncontract SavingAccount is Ownable{\\r\\n\\tusing TokenInfoLib for TokenInfoLib.TokenInfo;\\r\\n\\tusing SymbolsLib for SymbolsLib.Symbols;\\r\\n\\tusing SafeMath for uint256;\\r\\n\\tusing SignedSafeMath for int256;\\r\\n\\tusing SafeERC20 for IERC20;\\r\\n\\r\\n\\t\\r\\n\\tevent depositTokened(address onwer,uint256 amount,address tokenaddress);\\r\\n\\tevent withdrawed(address onwer,uint256 amount,address tokenaddress);\\r\\n\\tevent RewardAdded(uint256 reward);\\r\\n    event RewardPaid(address indexed user, uint256 reward);\\r\\n    \\r\\n    \\r\\n\\tbool _hasStart = false;\\r\\n\\tuint256 public _initReward = 0;\\r\\n\\t\\r\\n\\tIERC20 public _pros = IERC20(0x306Dd7CD66d964f598B4D2ec92b5a9B275D7fEb3);\\r\\n    address public _teamWallet = 0x89941E92E414c88179a830af5c10bde0E9245158;\\r\\n\\taddress public _playbook = 0x21A4086a6Cdb332c851B76cccD21aCAB6428D9E4;\\r\\n\\taddress public _allpool = 0xC682bD99eE552B6f7d931aFee2A9425806e155E9;\\r\\n\\t\\r\\n\\r\\n\\taddress public _ETH = 0x000000000000000000000000000000000000000E;\\r\\n\\taddress public _USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\r\\n\\taddress public _PROS = 0x306Dd7CD66d964f598B4D2ec92b5a9B275D7fEb3;\\r\\n\\tuint256 DURATION = 1 days;\\r\\n\\t\\r\\n    int128 dayNums = 0;\\r\\n\\r\\n    int128 baseReward = 80000;\\r\\n    \\r\\n    uint256 public base_ = 20*10e3;\\r\\n    uint256 public rate_forReward = 1;\\r\\n    uint256 public base_Rate_Reward = 100;\\r\\n\\r\\n\\tstruct Account {\\r\\n\\t\\tmapping(address => TokenInfoLib.TokenInfo) tokenInfos;\\r\\n\\t\\tbool active;\\r\\n\\t}\\r\\n// \\tint256 public totalReward;\\r\\n\\tmapping(address => Account) accounts;\\r\\n\\tmapping(address => int256) totalDeposits;\\r\\n\\tmapping(address => int256) totalLoans;\\r\\n\\tmapping(address => int256) totalCollateral;\\r\\n    mapping(address => bool) loansAccount;\\r\\n\\taddress[] activeAccounts;\\r\\n\\taddress[] activeLoansAccount;\\r\\n\\r\\n    mapping(address => uint256)_initTokenReward;\\r\\n    uint256 public _startTime =  now + 365 days;\\r\\n    uint256 public _periodFinish = 0;\\r\\n    uint256 public _rewardRate = 0;\\r\\n    \\r\\n    mapping(address =>uint256) public _rewardRateList;\\r\\n    // uint256 public _lastUpdateTime;\\r\\n    mapping(address=>uint256) public _lastUpdateTime;\\r\\n    // uint256 public _rewardPerTokenStored;\\r\\n    mapping(address=>uint256) public _rewardPerTokenStored;\\r\\n    uint256 public _teamRewardRate = 0;\\r\\n    uint256 public _poolRewardRate = 0;\\r\\n    uint256 public _baseRate = 10000;\\r\\n    uint256 public _punishTime = 10 days;\\r\\n    \\r\\n    uint256 public one_Rate = 90;\\r\\n    uint256 public sec_Rate = 5;\\r\\n    uint256 public thr_Rate = 5;\\r\\n    uint256 public BASE_RATE_FORREWARD = 100;\\r\\n    \\r\\n    \\r\\n    mapping(address => mapping(address=>uint256)) public _userRewardPerTokenPaid;\\r\\n    mapping(address => mapping(address=>uint256)) public _rewards;\\r\\n    mapping(address => mapping(address=>uint256)) public _lastStakedTime;\\r\\n\\tSymbolsLib.Symbols symbols;\\r\\n\\tint256 constant BASE = 10**6;\\r\\n\\tint BORROW_LTV = 66; //TODO check is this 60%?\\r\\n\\tint LIQUIDATE_THREADHOLD = 85;\\r\\n\\r\\n\\tconstructor() public {\\r\\n\\t\\tSavingAccountParameters params = new SavingAccountParameters();\\r\\n\\t\\taddress[] memory tokenAddresses = params.getTokenAddresses();\\r\\n\\t\\t//TODO This needs improvement as it could go out of gas\\r\\n\\t\\tsymbols.initialize(params.ratesURL(), params.tokenNames(), tokenAddresses);\\r\\n\\t\\t\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tfunction setprosToken(IERC20 token) public onlyOwner{\\r\\n\\t    _pros = token;\\r\\n\\t} \\r\\n\\tfunction setAllpool(address pool)public onlyOwner {\\r\\n\\t    _allpool = pool;\\r\\n\\t}\\r\\n\\t \\r\\n\\tfunction setTeamToken(address tokenaddress) public onlyOwner{\\r\\n\\t    _teamWallet = tokenaddress;\\r\\n\\t}\\r\\n\\t \\r\\n\\tfunction set_tokens(address eth,address usdt,address pros) public onlyOwner{\\r\\n\\t    _ETH = eth;\\r\\n\\t    _USDT = usdt;\\r\\n\\t    _PROS = pros;\\r\\n\\t}\\r\\n\\t \\r\\n\\tfunction setPlaybook(address playbook) public onlyOwner{\\r\\n\\t    _playbook = playbook;\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction setRate_Reward(uint256 one,uint256 sec,uint256 thr,uint256 total)public onlyOwner{\\r\\n\\t    one_Rate = one;\\r\\n\\t    sec_Rate = sec;\\r\\n\\t    thr_Rate = thr;\\r\\n\\t    BASE_RATE_FORREWARD = total;\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction() external payable {}\\r\\n\\t\\r\\n\\tfunction getAccountTotalUsdValue(address accountAddr) public view returns (int256 usdValue) {\\r\\n\\t\\treturn getAccountTotalUsdValue(accountAddr, true).add(getAccountTotalUsdValue(accountAddr, false));\\r\\n\\t}\\r\\n\\r\\n\\tfunction getAccountTotalUsdValue(address accountAddr, bool isPositive) private view returns (int256 usdValue){\\r\\n\\t\\tint256 totalUsdValue = 0;\\r\\n\\t\\tfor(uint i = 0; i < getCoinLength(); i++) {\\r\\n\\t\\t\\tif (isPositive && accounts[accountAddr].tokenInfos[symbols.addressFromIndex(i)].totalAmount(block.timestamp) >= 0) {\\r\\n\\t\\t\\t\\ttotalUsdValue = totalUsdValue.add(\\r\\n\\t\\t\\t\\t\\taccounts[accountAddr].tokenInfos[symbols.addressFromIndex(i)].totalAmount(block.timestamp)\\r\\n\\t\\t\\t\\t\\t.mul(int256(symbols.priceFromIndex(i)))\\r\\n\\t\\t\\t\\t\\t.div(BASE)\\r\\n\\t\\t\\t\\t);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (!isPositive && accounts[accountAddr].tokenInfos[symbols.addressFromIndex(i)].totalAmount(block.timestamp) < 0) {\\r\\n\\t\\t\\t\\ttotalUsdValue = totalUsdValue.add(\\r\\n\\t\\t\\t\\t\\taccounts[accountAddr].tokenInfos[symbols.addressFromIndex(i)].totalAmount(block.timestamp)\\r\\n\\t\\t\\t\\t\\t.mul(int256(symbols.priceFromIndex(i)))\\r\\n\\t\\t\\t\\t\\t.div(BASE)\\r\\n\\t\\t\\t\\t);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn totalUsdValue;\\r\\n\\t}\\r\\n\\t\\r\\n\\t\\r\\n\\t\\t\\r\\n\\tfunction rewardPerToken(address tokenID) public view returns (uint256) { //to change to the address thing for dip problem \\r\\n        if (totalDeposits[tokenID] == 0) { //totalPower change ----- totaldipost[token] \\r\\n            return _rewardPerTokenStored[tokenID];\\r\\n        }\\r\\n        return\\r\\n            _rewardPerTokenStored[tokenID].add(\\r\\n                lastTimeRewardApplicable() \\r\\n                    .sub(_lastUpdateTime[tokenID])\\r\\n                    .mul(_rewardRateList[tokenID]) //change for the _rewardRate[token]\\r\\n                    .mul(1e18)\\r\\n                    .div(uint256(totalDeposits[tokenID])) //change for the totalPower[token] ---- \\r\\n            );\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\r\\n        return Math.min(block.timestamp, _periodFinish);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function earned(address account,address tokenID) public view returns (uint256) {\\r\\n        return\\r\\n            uint256(tokenBalanceOf(tokenID,account))\\r\\n                .mul(rewardPerToken(tokenID).sub(_userRewardPerTokenPaid[tokenID][account]))\\r\\n                .div(1e18)\\r\\n                .add(_rewards[tokenID][account]); //one token\\r\\n    }\\r\\n\\t\\r\\n\\t\\r\\n\\tfunction earned(address account) public view returns (uint256) {\\r\\n        uint coinsLen = getCoinLength();\\r\\n        uint256 Total;\\r\\n        for (uint i = 0; i < coinsLen; i++) {\\r\\n\\t\\t\\taddress tokenAddress = symbols.addressFromIndex(i);\\r\\n\\t\\t\\tTotal = Total.add(earned(account,tokenAddress));\\r\\n\\t\\t}\\r\\n\\t\\treturn Total;\\r\\n    }\\r\\n\\t\\r\\n\\t\\r\\n    modifier checkHalve() {\\r\\n        if (block.timestamp >= _periodFinish) {\\r\\n            update_initreward();\\r\\n            _pros.mint(address(this), _initReward);\\r\\n            _rewardRate = _initReward.div(DURATION*3);\\r\\n            _rewardRateList[address(_PROS)] = _initReward.mul(one_Rate).div(DURATION*BASE_RATE_FORREWARD);\\r\\n            _rewardRateList[address(_USDT)] = _initReward.mul(sec_Rate).div(DURATION*BASE_RATE_FORREWARD);\\r\\n            _rewardRateList[address(_ETH)] = _initReward.mul(thr_Rate).div(DURATION*BASE_RATE_FORREWARD);\\r\\n            _periodFinish = block.timestamp.add(DURATION);\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    modifier checkStart() {\\r\\n        require(block.timestamp > _startTime, \\\"not start\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n\\tmodifier updateReward(address account,address tokenID) {\\r\\n        _rewardPerTokenStored[tokenID] = rewardPerToken(tokenID);\\r\\n        _lastUpdateTime[tokenID] = lastTimeRewardApplicable();\\r\\n        if (account != address(0)) {\\r\\n            _rewards[tokenID][account] = earned(account,tokenID);\\r\\n            _userRewardPerTokenPaid[tokenID][account] = _rewardPerTokenStored[tokenID];\\r\\n        }\\r\\n        _;\\r\\n    } \\r\\n    \\r\\n    modifier isRegister(){\\r\\n        require(AllPool(_allpool).is_Re(msg.sender)==true,\\\"address not register or name already register\\\");\\r\\n        _;\\r\\n    }\\r\\n   \\r\\n    \\r\\n    modifier updateRewardAll(address account) {\\r\\n        uint coinsLen = getCoinLength();\\r\\n        address[] memory tokens = new address[](coinsLen);\\r\\n        \\r\\n        for (uint i = 0; i < coinsLen; i++) {\\r\\n\\t\\t\\taddress tokenAddress = symbols.addressFromIndex(i);\\r\\n\\t\\t\\ttokens[i] = tokenAddress;\\r\\n\\t\\t}\\r\\n        for(uint i=0;i<3;i++){\\r\\n            address tokenID = tokens[i];\\r\\n            _rewardPerTokenStored[tokenID] = rewardPerToken(tokenID);\\r\\n            _lastUpdateTime[tokenID] = lastTimeRewardApplicable();\\r\\n            if (account != address(0)) {\\r\\n            _rewards[tokenID][account] = earned(account,tokenID);\\r\\n            _userRewardPerTokenPaid[tokenID][account] = _rewardPerTokenStored[tokenID];\\r\\n        }\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\t\\r\\n\\t\\r\\n\\t/** \\r\\n\\t * Get the overall state of the saving pool\\r\\n\\t */\\r\\n\\tfunction getMarketState() public view returns (address[] memory addresses,\\r\\n\\t\\tint256[] memory deposits\\r\\n\\t\\t)\\r\\n\\t{\\r\\n\\t\\tuint coinsLen = getCoinLength();\\r\\n\\r\\n\\t\\taddresses = new address[](coinsLen);\\r\\n\\t\\tdeposits = new int256[](coinsLen);\\r\\n\\r\\n\\r\\n\\t\\tfor (uint i = 0; i < coinsLen; i++) {\\r\\n\\t\\t\\taddress tokenAddress = symbols.addressFromIndex(i);\\r\\n\\t\\t\\taddresses[i] = tokenAddress;\\r\\n\\t\\t\\tdeposits[i] = totalDeposits[tokenAddress];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn (addresses, deposits);\\r\\n\\t}\\r\\n\\r\\n\\t/*\\r\\n\\t * Get the state of the given token\\r\\n\\t */\\r\\n\\tfunction getTokenState(address tokenAddress) public view returns (int256 deposits, int256 loans, int256 collateral)\\r\\n\\t{\\r\\n\\t\\treturn (totalDeposits[tokenAddress], totalLoans[tokenAddress], totalCollateral[tokenAddress]);\\r\\n\\t}\\r\\n\\r\\n\\t/** \\r\\n\\t * Get all balances for the sender's account\\r\\n\\t */\\r\\n\\t\\r\\n\\tfunction getBalances() public view returns (address[] memory addresses, int256[] memory balances)\\r\\n\\t{\\r\\n\\t\\tuint coinsLen = getCoinLength();\\r\\n\\r\\n\\t\\taddresses = new address[](coinsLen);\\r\\n\\t\\tbalances = new int256[](coinsLen);\\r\\n\\r\\n\\t\\tfor (uint i = 0; i < coinsLen; i++) {\\r\\n\\t\\t\\taddress tokenAddress = symbols.addressFromIndex(i);\\r\\n\\t\\t\\taddresses[i] = tokenAddress;\\r\\n\\t\\t\\tbalances[i] = tokenBalanceOf(tokenAddress);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn (addresses, balances);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getActiveAccounts() public view returns (address[] memory) {\\r\\n\\t\\treturn activeAccounts;\\r\\n\\t}\\r\\n    \\r\\n    function tokenBalanceOf(address tokenAddress,address account) public view returns (int256 amount) {\\r\\n\\t\\treturn accounts[account].tokenInfos[tokenAddress].totalAmount(block.timestamp);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getCoinLength() public view returns (uint256 length){\\r\\n\\t\\treturn symbols.getCoinLength();\\r\\n\\t}\\r\\n\\r\\n\\tfunction tokenBalanceOf(address tokenAddress) public view returns (int256 amount) {\\r\\n\\t\\treturn accounts[msg.sender].tokenInfos[tokenAddress].totalAmount(block.timestamp);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getCoinAddress(uint256 coinIndex) public view returns (address) {\\r\\n\\t\\treturn symbols.addressFromIndex(coinIndex);\\r\\n\\t}\\r\\n\\r\\n\\t/** \\r\\n\\t * Deposit the amount of tokenAddress to the saving pool. \\r\\n\\t */\\r\\n\\t\\r\\n\\tfunction depositToken(address tokenAddress, uint256 amount) updateReward(msg.sender,tokenAddress) checkHalve checkStart isRegister public payable {\\r\\n\\t\\tTokenInfoLib.TokenInfo storage tokenInfo = accounts[msg.sender].tokenInfos[tokenAddress];\\r\\n\\t\\tif (!accounts[msg.sender].active) {\\r\\n\\t\\t\\taccounts[msg.sender].active = true;\\r\\n\\t\\t\\tactiveAccounts.push(msg.sender);\\r\\n\\t\\t}\\r\\n        \\r\\n\\t\\tint256 currentBalance = tokenInfo.getCurrentTotalAmount();\\r\\n\\r\\n\\t\\trequire(currentBalance >= 0,\\r\\n\\t\\t\\t\\\"Balance of the token must be zero or positive. To pay negative balance, please use repay button.\\\");\\r\\n        uint256 LastRatio = 0;\\r\\n        \\r\\n\\t\\t// deposited amount is new balance after addAmount minus previous balance\\r\\n\\t\\tint256 depositedAmount = tokenInfo.addAmount(amount, LastRatio, block.timestamp) - currentBalance;\\r\\n\\t\\ttotalDeposits[tokenAddress] = totalDeposits[tokenAddress].add(depositedAmount);\\r\\n        emit depositTokened(msg.sender,amount,tokenAddress);\\r\\n\\t\\treceive(msg.sender, amount, amount,tokenAddress);\\r\\n\\t}\\r\\n\\t\\r\\n\\t\\r\\n\\r\\n\\t/**\\r\\n\\t * Withdraw tokens from saving pool. If the interest is not empty, the interest\\r\\n\\t * will be deducted first.\\r\\n\\t */\\r\\n\\t \\r\\n\\tfunction withdrawToken(address tokenAddress, uint256 amount) updateReward(msg.sender,tokenAddress) checkStart checkHalve public payable {\\r\\n\\t\\trequire(accounts[msg.sender].active, \\\"Account not active, please deposit first.\\\");\\r\\n\\t\\tTokenInfoLib.TokenInfo storage tokenInfo = accounts[msg.sender].tokenInfos[tokenAddress];\\r\\n\\r\\n\\t\\trequire(tokenInfo.totalAmount(block.timestamp) >= int256(amount), \\\"Insufficient balance.\\\");\\r\\n  \\t\\trequire(int256(getAccountTotalUsdValue(msg.sender, false).mul(-1)).mul(100) <= (getAccountTotalUsdValue(msg.sender, true) - int256(amount.mul(symbols.priceFromAddress(tokenAddress)).div(uint256(BASE)))).mul(BORROW_LTV));\\r\\n        \\r\\n        emit withdrawed(msg.sender,amount,tokenAddress);\\r\\n\\t\\ttokenInfo.minusAmount(amount, 0, block.timestamp);\\r\\n\\t\\ttotalDeposits[tokenAddress] = totalDeposits[tokenAddress].sub(int256(amount));\\r\\n\\t\\ttotalCollateral[tokenAddress] = totalCollateral[tokenAddress].sub(int256(amount));\\r\\n\\r\\n\\t\\tsend(msg.sender, amount, tokenAddress);\\t\\t\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\r\\n\\tfunction receive(address from, uint256 amount, uint256 amounttwo,address tokenAddress) private {\\r\\n\\t\\tif (symbols.isEth(tokenAddress)) {\\r\\n            require(msg.value >= amounttwo, \\\"The amount is not sent from address.\\\");\\r\\n            msg.sender.transfer(msg.value-amounttwo);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\trequire(msg.value >= 0, \\\"msg.value must be 0 when receiving tokens\\\");\\r\\n\\t\\t\\tif(tokenAddress!=_USDT ){\\r\\n\\t\\t\\t    require(IERC20(tokenAddress).transferFrom(from, address(this), amount));\\r\\n\\t\\t\\t}else{\\r\\n\\t\\t\\t    basic(tokenAddress).transferFrom(from,address(this),amount);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\r\\n\\r\\n\\tfunction send(address to, uint256 amount, address tokenAddress) private {\\r\\n\\t\\tif (symbols.isEth(tokenAddress)) {\\r\\n\\t\\t\\tmsg.sender.transfer(amount);\\r\\n\\t\\t} else {\\r\\n\\t\\t    if(tokenAddress!=_USDT){\\r\\n\\t\\t\\t    require(IERC20(tokenAddress).transfer(to, amount));\\r\\n\\t\\t\\t}else{\\r\\n\\t\\t\\t    basic(tokenAddress).transfer(to, amount);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\r\\n    function getReward() public updateRewardAll(msg.sender) checkHalve checkStart {\\r\\n        \\r\\n        uint256 reward;\\r\\n        uint coinsLen = getCoinLength();\\r\\n        address[] memory tokens = new address[](coinsLen);\\r\\n        \\r\\n        for (uint i = 0; i < coinsLen; i++) {\\r\\n\\t\\t\\taddress tokenAddress = symbols.addressFromIndex(i);\\r\\n\\t\\t\\ttokens[i] = tokenAddress;\\r\\n\\t\\t\\treward = reward.add(earned(msg.sender,tokens[i]));\\r\\n\\t\\t}\\r\\n        if (reward > 0) {\\r\\n            _rewards[tokens[0]][msg.sender] = 0;\\r\\n            _rewards[tokens[1]][msg.sender] = 0;\\r\\n            _rewards[tokens[2]][msg.sender] = 0;\\r\\n            \\r\\n            address set_play = AllPool(_allpool).get_Address_pool(msg.sender)==0x0000000000000000000000000000000000000000?_playbook:AllPool(_allpool).get_Address_pool(msg.sender);\\r\\n            uint256 fee = IPlayerBook(set_play).settleReward(msg.sender,reward);\\r\\n            if(fee>0){\\r\\n                _pros.safeTransfer(set_play,fee);\\r\\n            }\\r\\n            \\r\\n            uint256 teamReward = reward.mul(_teamRewardRate).div(_baseRate);\\r\\n            if(teamReward>0){\\r\\n                _pros.safeTransfer(_teamWallet, teamReward);\\r\\n            }\\r\\n            uint256 leftReward = reward.sub(fee).sub(teamReward);\\r\\n            uint256 poolReward = 0;\\r\\n            if(leftReward>0){\\r\\n                _pros.safeTransfer(msg.sender, leftReward);\\r\\n            }\\r\\n            emit RewardPaid(msg.sender,reward);\\r\\n        }\\r\\n        \\r\\n        \\r\\n    }\\r\\n \\r\\n   \\r\\n\\t\\r\\n\\r\\n\\t\\r\\n\\tfunction update_initreward() private {\\r\\n\\t    dayNums = dayNums + 1;\\r\\n        uint256 thisreward = base_.mul(rate_forReward).mul(10**18).mul((base_Rate_Reward.sub(rate_forReward))**(uint256(dayNums-1))).div(base_Rate_Reward**(uint256(dayNums)));\\r\\n\\t    _initReward = uint256(thisreward);\\r\\n\\t}\\r\\n\\t\\r\\n\\t\\r\\n\\r\\n    // set fix time to start reward\\r\\n    function startReward(uint256 startTime)\\r\\n        external\\r\\n        onlyOwner\\r\\n        updateReward(address(0),address(_ETH))\\r\\n    {\\r\\n        require(_hasStart == false, \\\"has started\\\");\\r\\n        _hasStart = true;\\r\\n        _startTime = startTime;\\r\\n        update_initreward();\\r\\n        _rewardRate = _initReward.div(DURATION*3); \\r\\n        _rewardRateList[address(_PROS)] = _initReward.mul(one_Rate).div(DURATION*BASE_RATE_FORREWARD);\\r\\n        _rewardRateList[address(_USDT)] = _initReward.mul(sec_Rate).div(DURATION*BASE_RATE_FORREWARD);\\r\\n        _rewardRateList[address(_ETH)] = _initReward.mul(thr_Rate).div(DURATION*BASE_RATE_FORREWARD);\\r\\n        _pros.mint(address(this), _initReward);\\r\\n        _lastUpdateTime[address(_ETH)] = _startTime;\\r\\n        _lastUpdateTime[address(_USDT)] = _startTime;\\r\\n        _lastUpdateTime[address(_PROS)] = _startTime; //for get the chushihua state\\r\\n        _periodFinish = _startTime.add(DURATION);\\r\\n\\r\\n        emit RewardAdded(_initReward);\\r\\n    }    \\r\\n}\"\r\n    },\r\n    \"contracts/TokenInfoLib.sol\": {\r\n      \"content\": \"pragma solidity >= 0.5.0 < 0.6.0;\\r\\n\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./SignedSafeMath.sol\\\";\\r\\nlibrary TokenInfoLib {\\r\\n    using SafeMath for uint256;\\r\\n\\tusing SignedSafeMath for int256;\\r\\n    struct TokenInfo {\\r\\n\\t\\tint256 balance;\\r\\n\\t\\tint256 interest;\\r\\n\\t\\tuint256 rate;\\r\\n\\t\\tuint256 lastModification;\\r\\n\\t}\\r\\n\\tuint256 constant BASE = 10**12; // TODO: 12 vs 18?\\r\\n\\tint256 constant POSITIVE = 1;\\r\\n\\tint256 constant NEGATIVE = -1;\\r\\n\\r\\n\\t// returns the sum of balance, interest posted to the account, and any additional intereset accrued up to the given timestamp\\r\\n\\tfunction totalAmount(TokenInfo storage self, uint256 currentTimestamp) public view returns(int256) {\\r\\n\\t\\treturn self.balance.add(viewInterest(self, currentTimestamp));\\r\\n\\t\\t//\u7528\u6237\u603b\u4f59\u989d\u4e0d\u518d\u53d6\u51b3\u4e8e\u51fa\u5757\u65f6\u95f4\u5dee \\r\\n\\t\\t//return self.balance;\\r\\n\\t}\\r\\n\\tfunction totalnumber(TokenInfo storage self)public view returns(int256){\\r\\n\\t    return self.balance;\\r\\n\\t}\\r\\n\\r\\n\\t// returns the sum of balance and interest posted to the account\\r\\n\\tfunction getCurrentTotalAmount(TokenInfo storage self) public view returns(int256) {\\r\\n\\t\\treturn self.balance.add(self.interest);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction getInterest(TokenInfo storage self,uint256 currentTimestamp)public view returns(int256){\\r\\n\\t    return viewInterest(self, currentTimestamp);\\r\\n\\t}\\r\\n\\r\\n\\tfunction minusAmount(TokenInfo storage self, uint256 amount, uint256 rate, uint256 currentTimestamp) public {\\r\\n\\t\\tresetInterest(self, currentTimestamp);\\r\\n        int256 _amount = int256(amount);\\r\\n\\t\\tif (self.balance + self.interest > 0) {\\r\\n\\t\\t\\tif (self.interest >= _amount) {\\r\\n\\t\\t\\t\\tself.interest = self.interest.sub(_amount);\\r\\n\\t\\t\\t\\t_amount = 0;\\r\\n\\t\\t\\t} else if (self.balance.add(self.interest) >= _amount){\\r\\n\\t\\t\\t\\tself.balance = self.balance.sub(_amount.sub(self.interest));\\r\\n\\t\\t\\t\\tself.interest = 0;\\r\\n\\t\\t\\t\\t_amount = 0;\\r\\n\\t\\t\\t} else {\\r\\n                _amount = _amount.sub(self.balance.add(self.interest));\\r\\n\\t\\t\\t\\tself.balance = 0;\\r\\n\\t\\t\\t\\tself.interest = 0;\\r\\n\\t\\t\\t\\tself.rate = 0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n        if (_amount > 0) {\\r\\n\\t\\t\\trequire(self.balance.add(self.interest) <= 0, \\\"To minus amount, the total balance must be smaller than 0.\\\");\\r\\n\\t\\t\\tself.rate = mixRate(self, _amount, rate);\\r\\n\\t\\t\\tself.balance = self.balance.sub(_amount);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction addAmount(TokenInfo storage self, uint256 amount, uint256 rate, uint256 currentTimestamp) public returns(int256) {\\r\\n\\t\\tresetInterest(self, currentTimestamp);\\r\\n\\t\\tint256 _amount = int256(amount);\\r\\n\\t\\tif (self.balance.add(self.interest) < 0) {\\r\\n            if (self.interest.add(_amount) <= 0) {\\r\\n                self.interest = self.interest.add(_amount);\\r\\n\\t\\t\\t\\t_amount = 0;\\r\\n\\t\\t\\t} else if (self.balance.add(self.interest).add(_amount) <= 0) {\\r\\n\\t\\t\\t\\tself.balance = self.balance.add(_amount.add(self.interest));\\r\\n\\t\\t\\t\\tself.interest = 0;\\r\\n\\t\\t\\t\\t_amount = 0;\\r\\n\\t\\t\\t} else {\\r\\n                _amount = _amount.add(self.balance.add(self.interest));\\r\\n\\t\\t\\t\\tself.balance = 0;\\r\\n                self.interest = 0;\\r\\n                self.rate = 0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n        if (_amount > 0) {\\r\\n\\t\\t\\trequire(self.balance.add(self.interest) >= 0, \\\"To add amount, the total balance must be larger than 0.\\\");\\r\\n\\t\\t\\tself.rate = mixRate(self, _amount, rate);\\r\\n\\t\\t\\tself.balance = self.balance.add(_amount);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn totalAmount(self, currentTimestamp);\\r\\n\\t}\\r\\n\\r\\n\\tfunction mixRate(TokenInfo storage self, int256 amount, uint256 rate) private view returns (uint256){\\r\\n\\t\\t//TODO uint256(-self.balance) this will integer underflow - Critical Security risk\\r\\n\\t\\t//TODO Why do we need this???\\r\\n        uint256 _balance = self.balance >= 0 ? uint256(self.balance) : uint256(-self.balance);\\r\\n\\t\\tuint256 _amount = amount >= 0 ? uint256(amount) : uint256(-amount);\\r\\n\\t\\treturn _balance.mul(self.rate).add(_amount.mul(rate)).div(_balance + _amount);\\r\\n\\t}\\r\\n\\r\\n\\tfunction resetInterest(TokenInfo storage self, uint256 currentTimestamp) public {\\r\\n\\t\\tself.interest = viewInterest(self, currentTimestamp);\\r\\n\\t\\tself.lastModification = currentTimestamp;\\r\\n\\t}\\r\\n\\r\\n\\tfunction viewInterest(TokenInfo storage self, uint256 currentTimestamp) public view returns(int256) {\\r\\n        int256 _sign = self.balance < 0 ? NEGATIVE : POSITIVE;\\r\\n\\t\\t//TODO uint256(-amount) ???\\r\\n\\t\\tuint256 _balance = self.balance >= 0 ? uint256(self.balance) : uint256(-self.balance);\\r\\n\\t\\tuint256 _difference = currentTimestamp.sub(self.lastModification);\\r\\n\\r\\n\\t\\treturn self.interest\\r\\n\\t\\t\\t.add(int256(_balance.mul(self.rate).mul(_difference).div(BASE)))\\r\\n\\t\\t\\t.mul(_sign);\\r\\n\\t}\\r\\n}\"\r\n    },\r\n    \"contracts/SymbolsLib.sol\": {\r\n      \"content\": \"pragma solidity >= 0.5.0 < 0.6.0;\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./strings.sol\\\";\\r\\nlibrary SymbolsLib {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n\\tstruct Symbols {\\r\\n\\t\\tuint count;\\r\\n\\t\\tmapping(uint => string) indexToSymbol;\\r\\n\\t\\tmapping(string => uint256) symbolToPrices; \\r\\n\\t\\tmapping(address => string) addressToSymbol; \\r\\n\\t\\tmapping(string => address) symbolToAddress;\\r\\n\\t\\tstring ratesURL;\\r\\n\\t}\\r\\n\\r\\n\\t/** \\r\\n\\t *  initializes the symbols structure\\r\\n\\t */\\r\\n\\tfunction initialize(Symbols storage self, string memory ratesURL, string memory tokenNames, address[] memory tokenAddresses) public {\\r\\n\\t\\tstrings.slice memory delim = strings.toSlice(\\\",\\\");\\r\\n\\t\\tstrings.slice memory tokensList = strings.toSlice(tokenNames);\\r\\n\\r\\n\\t\\tself.count = strings.count(tokensList, delim) + 1;\\r\\n\\t\\trequire(self.count == tokenAddresses.length);\\r\\n\\r\\n\\t\\tself.ratesURL = ratesURL;\\r\\n\\r\\n\\t\\tfor(uint i = 0; i < self.count; i++) {\\r\\n\\t\\t\\tstrings.slice memory token;\\r\\n\\t\\t\\tstrings.split(tokensList, delim, token);\\r\\n\\r\\n\\t\\t \\taddress tokenAddress = tokenAddresses[i];\\r\\n\\t\\t \\tstring memory tokenName = strings.toString(token);\\r\\n\\r\\n\\t\\t \\tself.indexToSymbol[i] = tokenName;\\r\\n\\t\\t \\tself.addressToSymbol[tokenAddress] = tokenName;\\r\\n\\t\\t \\tself.symbolToAddress[tokenName]  = tokenAddress;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction getCoinLength(Symbols storage self) public view returns (uint length){ \\r\\n\\t\\treturn self.count; \\r\\n\\t} \\r\\n\\r\\n\\tfunction addressFromIndex(Symbols storage self, uint index) public view returns(address) {\\r\\n\\t\\trequire(index < self.count, \\\"coinIndex must be smaller than the coins length.\\\");\\r\\n\\t\\treturn self.symbolToAddress[self.indexToSymbol[index]];\\r\\n\\t} \\r\\n\\r\\n\\tfunction priceFromIndex(Symbols storage self, uint index) public view returns(uint256) {\\r\\n\\t\\trequire(index < self.count, \\\"coinIndex must be smaller than the coins length.\\\");\\r\\n\\t\\treturn self.symbolToPrices[self.indexToSymbol[index]];\\r\\n\\t} \\r\\n\\r\\n\\tfunction priceFromAddress(Symbols storage self, address tokenAddress) public view returns(uint256) {\\r\\n\\t\\treturn self.symbolToPrices[self.addressToSymbol[tokenAddress]];\\r\\n\\t} \\r\\n\\r\\n\\tfunction setPrice(Symbols storage self, uint index, uint256 price) public { \\r\\n\\t\\trequire(index < self.count, \\\"coinIndex must be smaller than the coins length.\\\");\\r\\n\\t\\tself.symbolToPrices[self.indexToSymbol[index]] = price;\\r\\n\\t}\\r\\n\\r\\n\\tfunction isEth(Symbols storage self, address tokenAddress) public view returns(bool) {\\r\\n\\t\\treturn self.symbolToAddress[\\\"ETH\\\"] == tokenAddress;\\r\\n\\t}\\r\\n\\r\\n\\t/** \\r\\n\\t * Parse result from oracle, e.g. an example is [8110.44, 0.2189, 445.05, 1]. \\r\\n\\t * The function will remove the '[' and ']' and split the string by ','. \\r\\n\\t */\\r\\n\\tfunction parseRates(Symbols storage self, string memory result,uint256 who) internal {\\r\\n\\t\\tstrings.slice memory delim = strings.toSlice(\\\",\\\");\\r\\n\\t\\tstrings.slice memory startChar = strings.toSlice(\\\"[\\\");\\r\\n\\t\\tstrings.slice memory endChar = strings.toSlice(\\\"]\\\");\\r\\n\\t\\tstrings.slice memory substring = strings.until(strings.beyond(strings.toSlice(result), startChar), endChar);\\r\\n\\t\\tuint count = strings.count(substring, delim) + 1;\\r\\n\\t\\t//ok \\r\\n\\t\\t\\r\\n\\t\\tfor(uint i = (who-1)*3; i < (who-1)*3+3; i++) {\\r\\n\\t\\t\\tstrings.slice memory token;\\r\\n\\t\\t\\tstrings.split(substring, delim, token);\\r\\n\\t\\t\\tsetPrice(self, i, stringToUint(strings.toString(token)));\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tfunction parseRatesbyself(Symbols storage self, string memory result) internal {\\r\\n\\t\\tstrings.slice memory delim = strings.toSlice(\\\",\\\");\\r\\n\\t\\tstrings.slice memory startChar = strings.toSlice(\\\"[\\\");\\r\\n\\t\\tstrings.slice memory endChar = strings.toSlice(\\\"]\\\");\\r\\n\\t\\tstrings.slice memory substring = strings.until(strings.beyond(strings.toSlice(result), startChar), endChar);\\r\\n\\t\\tuint count = strings.count(substring, delim) + 1;\\r\\n\\t\\t//ok \\r\\n\\t\\t\\r\\n\\t\\tfor(uint i = 0; i < count; i++) {\\r\\n\\t\\t\\tstrings.slice memory token;\\r\\n\\t\\t\\tstrings.split(substring, delim, token);\\r\\n\\t\\t\\tsetPrice(self, i, stringToUint(strings.toString(token)));\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/** \\r\\n\\t *  Helper function to convert string to number\\r\\n\\t */\\r\\n\\tfunction stringToUint(string memory numString) private pure returns(uint256 number) {\\r\\n\\t\\tbytes memory numBytes = bytes(numString);\\r\\n\\t\\tbool isFloat = false;\\r\\n\\t\\tuint times = 6;\\r\\n\\t\\tnumber = 0;\\r\\n\\t\\tfor(uint256 i = 0; i < numBytes.length; i ++) {\\r\\n\\t\\t\\tif (numBytes[i] >= '0' && numBytes[i] <= '9' && times > 0) {\\r\\n\\t\\t\\t\\tnumber *= 10;\\r\\n\\t\\t\\t\\tnumber = number + uint8(numBytes[i]) - 48;\\r\\n\\t\\t\\t\\tif (isFloat) {\\r\\n\\t\\t\\t\\t\\ttimes --;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else if (numBytes[i] == '.') {\\r\\n\\t\\t\\t\\tisFloat = true;\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\twhile (times > 0) {\\r\\n\\t\\t\\tnumber *= 10;\\r\\n\\t\\t\\ttimes --;\\r\\n\\t\\t}\\r\\n\\t\\treturn number;\\r\\n\\t}\\r\\n}\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"// pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/SignedSafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @title SignedSafeMath\\r\\n * @dev Signed math operations with safety checks that revert on error.\\r\\n */\\r\\nlibrary SignedSafeMath {\\r\\n    int256 constant private INT256_MIN = -2**255;\\r\\n\\r\\n    /**\\r\\n     * @dev Multiplies two signed integers, reverts on overflow.\\r\\n     */\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        require(!(a == -1 && b == INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\r\\n\\r\\n        int256 c = a * b;\\r\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\\r\\n     */\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\r\\n        require(!(b == -1 && a == INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\r\\n\\r\\n        int256 c = a / b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Subtracts two signed integers, reverts on overflow.\\r\\n     */\\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a - b;\\r\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds two signed integers, reverts on overflow.\\r\\n     */\\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a + b;\\r\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\n import \\\"./Context.sol\\\";\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the caller is the current owner.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return _msgSender() == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/SavingAccountParameters.sol\": {\r\n      \"content\": \"pragma solidity >= 0.5.0 < 0.6.0;\\r\\n\\r\\ncontract SavingAccountParameters {\\r\\n    string public ratesURL;\\r\\n\\tstring public tokenNames;\\r\\n    address[] public tokenAddresses;\\r\\n\\r\\n    constructor() public payable{\\r\\n      tokenNames = \\\"ETH,USDT,PROS\\\";\\r\\n\\t  tokenAddresses = new address[](3);\\r\\n\\t  tokenAddresses[0] = 0x000000000000000000000000000000000000000E; \\r\\n      tokenAddresses[1] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; \\r\\n      tokenAddresses[2] = 0x306Dd7CD66d964f598B4D2ec92b5a9B275D7fEb3;//usdt //change address for test\\r\\n\\t}\\r\\n\\r\\n\\tfunction getTokenAddresses() public view returns(address[] memory){\\r\\n        return tokenAddresses;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see {ERC20Detailed}.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function mint(address account, uint amount) external;\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"\r\n    },\r\n    \"contracts/ABDK.sol\": {\r\n      \"content\": \"/*\\r\\n * ABDK Math 64.64 Smart Contract Library.  Copyright \u00a9 2019 by ABDK Consulting.\\r\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\r\\n */\\r\\npragma solidity ^0.5.0 || ^0.6.0;\\r\\n\\r\\n/**\\r\\n * Smart contract library of mathematical functions operating with signed\\r\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\r\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\r\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\r\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\r\\n * represented by int128 type holding only the numerator.\\r\\n */\\r\\nlibrary ABDKMath64x64 {\\r\\n  /**\\r\\n   * Minimum value signed 64.64-bit fixed point number may have. \\r\\n   */\\r\\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\r\\n\\r\\n  /**\\r\\n   * Maximum value signed 64.64-bit fixed point number may have. \\r\\n   */\\r\\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n  /**\\r\\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\r\\n   * number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n//   function fromInt (int256 x) internal pure returns (int128) {\\r\\n//     require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\r\\n//     return int128 (x << 64);\\r\\n//   }\\r\\n\\r\\n  /**\\r\\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\\r\\n   * rounding down.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64-bit integer number\\r\\n   */\\r\\n  function toInt (int128 x) internal pure returns (int64) {\\r\\n    return int64 (x >> 64);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\r\\n   * number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n//   function fromUInt (uint256 x) internal pure returns (int128) {\\r\\n//     require (x <= 0x7FFFFFFFFFFFFFFF);\\r\\n//     return int128 (x << 64);\\r\\n//   }\\r\\n\\r\\n  /**\\r\\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\r\\n   * number rounding down.  Revert on underflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return unsigned 64-bit integer number\\r\\n   */\\r\\n//   function toUInt (int128 x) internal pure returns (uint64) {\\r\\n//     require (x >= 0);\\r\\n//     return uint64 (x >> 64);\\r\\n//   }\\r\\n\\r\\n//   /**\\r\\n//   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\r\\n//   * number rounding down.  Revert on overflow.\\r\\n//   *\\r\\n//   * @param x signed 128.128-bin fixed point number\\r\\n//   * @return signed 64.64-bit fixed point number\\r\\n//   */\\r\\n//   function from128x128 (int256 x) internal pure returns (int128) {\\r\\n//     int256 result = x >> 64;\\r\\n//     require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n//     return int128 (result);\\r\\n//   }\\r\\n\\r\\n  /**\\r\\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\r\\n   * number.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 128.128 fixed point number\\r\\n   */\\r\\n  function to128x128 (int128 x) internal pure returns (int256) {\\r\\n    return int256 (x) << 64;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x + y.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function add (int128 x, int128 y) internal pure returns (int128) {\\r\\n    int256 result = int256(x) + y;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x - y.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function sub (int128 x, int128 y) internal pure returns (int128) {\\r\\n    int256 result = int256(x) - y;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x * y rounding down.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function mul (int128 x, int128 y) internal pure returns (int128) {\\r\\n    int256 result = int256(x) * y >> 64;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\r\\n   * number and y is signed 256-bit integer number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64 fixed point number\\r\\n   * @param y signed 256-bit integer number\\r\\n   * @return signed 256-bit integer number\\r\\n   */\\r\\n  function muli (int128 x, int256 y) internal pure returns (int256) {\\r\\n    if (x == MIN_64x64) {\\r\\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\r\\n        y <= 0x1000000000000000000000000000000000000000000000000);\\r\\n      return -y << 63;\\r\\n    } else {\\r\\n      bool negativeResult = false;\\r\\n      if (x < 0) {\\r\\n        x = -x;\\r\\n        negativeResult = true;\\r\\n      }\\r\\n      if (y < 0) {\\r\\n        y = -y; // We rely on overflow behavior here\\r\\n        negativeResult = !negativeResult;\\r\\n      }\\r\\n      uint256 absoluteResult = mulu (x, uint256 (y));\\r\\n      if (negativeResult) {\\r\\n        require (absoluteResult <=\\r\\n          0x8000000000000000000000000000000000000000000000000000000000000000);\\r\\n        return -int256 (absoluteResult); // We rely on overflow behavior here\\r\\n      } else {\\r\\n        require (absoluteResult <=\\r\\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n        return int256 (absoluteResult);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\r\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64 fixed point number\\r\\n   * @param y unsigned 256-bit integer number\\r\\n   * @return unsigned 256-bit integer number\\r\\n   */\\r\\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\\r\\n    if (y == 0) return 0;\\r\\n\\r\\n    require (x >= 0);\\r\\n\\r\\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\r\\n    uint256 hi = uint256 (x) * (y >> 128);\\r\\n\\r\\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n    hi <<= 64;\\r\\n\\r\\n    require (hi <=\\r\\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\r\\n    return hi + lo;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\r\\n   * zero.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function div (int128 x, int128 y) internal pure returns (int128) {\\r\\n    require (y != 0);\\r\\n    int256 result = (int256 (x) << 64) / y;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\r\\n   * integer numbers.  Revert on overflow or when y is zero.\\r\\n   *\\r\\n   * @param x signed 256-bit integer number\\r\\n   * @param y signed 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function divi (int256 x, int256 y) internal pure returns (int128) {\\r\\n    require (y != 0);\\r\\n\\r\\n    bool negativeResult = false;\\r\\n    if (x < 0) {\\r\\n      x = -x; // We rely on overflow behavior here\\r\\n      negativeResult = true;\\r\\n    }\\r\\n    if (y < 0) {\\r\\n      y = -y; // We rely on overflow behavior here\\r\\n      negativeResult = !negativeResult;\\r\\n    }\\r\\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\\r\\n    if (negativeResult) {\\r\\n      require (absoluteResult <= 0x80000000000000000000000000000000);\\r\\n      return -int128 (absoluteResult); // We rely on overflow behavior here\\r\\n    } else {\\r\\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n      return int128 (absoluteResult); // We rely on overflow behavior here\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\r\\n   * integer numbers.  Revert on overflow or when y is zero.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @param y unsigned 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\\r\\n    require (y != 0);\\r\\n    uint128 result = divuu (x, y);\\r\\n    require (result <= uint128 (MAX_64x64));\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate -x.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function neg (int128 x) internal pure returns (int128) {\\r\\n    require (x != MIN_64x64);\\r\\n    return -x;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate |x|.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function abs (int128 x) internal pure returns (int128) {\\r\\n    require (x != MIN_64x64);\\r\\n    return x < 0 ? -x : x;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\r\\n   * zero.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n//   function inv (int128 x) internal pure returns (int128) {\\r\\n//     require (x != 0);\\r\\n//     int256 result = int256 (0x100000000000000000000000000000000) / x;\\r\\n//     require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n//     return int128 (result);\\r\\n//   }\\r\\n\\r\\n//   /**\\r\\n//   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\r\\n//   *\\r\\n//   * @param x signed 64.64-bit fixed point number\\r\\n//   * @param y signed 64.64-bit fixed point number\\r\\n//   * @return signed 64.64-bit fixed point number\\r\\n//   */\\r\\n//   function avg (int128 x, int128 y) internal pure returns (int128) {\\r\\n//     return int128 ((int256 (x) + int256 (y)) >> 1);\\r\\n//   }\\r\\n\\r\\n//   /**\\r\\n//   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\r\\n//   * Revert on overflow or in case x * y is negative.\\r\\n//   *\\r\\n//   * @param x signed 64.64-bit fixed point number\\r\\n//   * @param y signed 64.64-bit fixed point number\\r\\n//   * @return signed 64.64-bit fixed point number\\r\\n//   */\\r\\n//   function gavg (int128 x, int128 y) internal pure returns (int128) {\\r\\n//     int256 m = int256 (x) * int256 (y);\\r\\n//     require (m >= 0);\\r\\n//     require (m <\\r\\n//         0x4000000000000000000000000000000000000000000000000000000000000000);\\r\\n//     return int128 (sqrtu (uint256 (m), uint256 (x) + uint256 (y) >> 1));\\r\\n//   }\\r\\n\\r\\n//   /**\\r\\n//   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\r\\n//   * and y is unsigned 256-bit integer number.  Revert on overflow.\\r\\n//   *\\r\\n//   * @param x signed 64.64-bit fixed point number\\r\\n//   * @param y uint256 value\\r\\n//   * @return signed 64.64-bit fixed point number\\r\\n//   */\\r\\n//   function pow (int128 x, uint256 y) internal pure returns (int128) {\\r\\n//     uint256 absoluteResult;\\r\\n//     bool negativeResult = false;\\r\\n//     if (x >= 0) {\\r\\n//       absoluteResult = powu (uint256 (x) << 63, y);\\r\\n//     } else {\\r\\n//       // We rely on overflow behavior here\\r\\n//       absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\\r\\n//       negativeResult = y & 1 > 0;\\r\\n//     }\\r\\n\\r\\n//     absoluteResult >>= 63;\\r\\n\\r\\n//     if (negativeResult) {\\r\\n//       require (absoluteResult <= 0x80000000000000000000000000000000);\\r\\n//       return -int128 (absoluteResult); // We rely on overflow behavior here\\r\\n//     } else {\\r\\n//       require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n//       return int128 (absoluteResult); // We rely on overflow behavior here\\r\\n//     }\\r\\n//   }\\r\\n\\r\\n//   /**\\r\\n//   * Calculate sqrt (x) rounding down.  Revert if x < 0.\\r\\n//   *\\r\\n//   * @param x signed 64.64-bit fixed point number\\r\\n//   * @return signed 64.64-bit fixed point number\\r\\n//   */\\r\\n//   function sqrt (int128 x) internal pure returns (int128) {\\r\\n//     require (x >= 0);\\r\\n//     return int128 (sqrtu (uint256 (x) << 64, 0x10000000000000000));\\r\\n//   }\\r\\n\\r\\n//   /**\\r\\n//   * Calculate binary logarithm of x.  Revert if x <= 0.\\r\\n//   *\\r\\n//   * @param x signed 64.64-bit fixed point number\\r\\n//   * @return signed 64.64-bit fixed point number\\r\\n//   */\\r\\n//   function log_2 (int128 x) internal pure returns (int128) {\\r\\n//     require (x > 0);\\r\\n\\r\\n//     int256 msb = 0;\\r\\n//     int256 xc = x;\\r\\n//     if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\r\\n//     if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\r\\n//     if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\r\\n//     if (xc >= 0x100) { xc >>= 8; msb += 8; }\\r\\n//     if (xc >= 0x10) { xc >>= 4; msb += 4; }\\r\\n//     if (xc >= 0x4) { xc >>= 2; msb += 2; }\\r\\n//     if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\r\\n\\r\\n//     int256 result = msb - 64 << 64;\\r\\n//     uint256 ux = uint256 (x) << 127 - msb;\\r\\n//     for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\r\\n//       ux *= ux;\\r\\n//       uint256 b = ux >> 255;\\r\\n//       ux >>= 127 + b;\\r\\n//       result += bit * int256 (b);\\r\\n//     }\\r\\n\\r\\n//     return int128 (result);\\r\\n//   }\\r\\n\\r\\n//   /**\\r\\n//   * Calculate natural logarithm of x.  Revert if x <= 0.\\r\\n//   *\\r\\n//   * @param x signed 64.64-bit fixed point number\\r\\n//   * @return signed 64.64-bit fixed point number\\r\\n//   */\\r\\n//   function ln (int128 x) internal pure returns (int128) {\\r\\n//     require (x > 0);\\r\\n\\r\\n//     return int128 (\\r\\n//         uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\\r\\n//   }\\r\\n\\r\\n  /**\\r\\n   * Calculate binary exponent of x.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function exp_2 (int128 x) internal pure returns (int128) {\\r\\n    require (x < 0x400000000000000000); // Overflow\\r\\n\\r\\n    if (x < -0x400000000000000000) return 0; // Underflow\\r\\n\\r\\n    uint256 result = 0x80000000000000000000000000000000;\\r\\n\\r\\n    if (x & 0x8000000000000000 > 0)\\r\\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\r\\n    if (x & 0x4000000000000000 > 0)\\r\\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\r\\n    if (x & 0x2000000000000000 > 0)\\r\\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\r\\n    if (x & 0x1000000000000000 > 0)\\r\\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\r\\n    if (x & 0x800000000000000 > 0)\\r\\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\r\\n    if (x & 0x400000000000000 > 0)\\r\\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\r\\n    if (x & 0x200000000000000 > 0)\\r\\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\r\\n    if (x & 0x100000000000000 > 0)\\r\\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\r\\n    if (x & 0x80000000000000 > 0)\\r\\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\r\\n    if (x & 0x40000000000000 > 0)\\r\\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\r\\n    if (x & 0x20000000000000 > 0)\\r\\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\r\\n    if (x & 0x10000000000000 > 0)\\r\\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\r\\n    if (x & 0x8000000000000 > 0)\\r\\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\r\\n    if (x & 0x4000000000000 > 0)\\r\\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\r\\n    if (x & 0x2000000000000 > 0)\\r\\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\\r\\n    if (x & 0x1000000000000 > 0)\\r\\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\r\\n    if (x & 0x800000000000 > 0)\\r\\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\r\\n    if (x & 0x400000000000 > 0)\\r\\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\r\\n    if (x & 0x200000000000 > 0)\\r\\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\r\\n    if (x & 0x100000000000 > 0)\\r\\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\r\\n    if (x & 0x80000000000 > 0)\\r\\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\r\\n    if (x & 0x40000000000 > 0)\\r\\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\r\\n    if (x & 0x20000000000 > 0)\\r\\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\r\\n    if (x & 0x10000000000 > 0)\\r\\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\r\\n    if (x & 0x8000000000 > 0)\\r\\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\r\\n    if (x & 0x4000000000 > 0)\\r\\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\r\\n    if (x & 0x2000000000 > 0)\\r\\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\r\\n    if (x & 0x1000000000 > 0)\\r\\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\r\\n    if (x & 0x800000000 > 0)\\r\\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\r\\n    if (x & 0x400000000 > 0)\\r\\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\r\\n    if (x & 0x200000000 > 0)\\r\\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\r\\n    if (x & 0x100000000 > 0)\\r\\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\r\\n    if (x & 0x80000000 > 0)\\r\\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\r\\n    if (x & 0x40000000 > 0)\\r\\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\r\\n    if (x & 0x20000000 > 0)\\r\\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\r\\n    if (x & 0x10000000 > 0)\\r\\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\r\\n    if (x & 0x8000000 > 0)\\r\\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\r\\n    if (x & 0x4000000 > 0)\\r\\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\r\\n    if (x & 0x2000000 > 0)\\r\\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\r\\n    if (x & 0x1000000 > 0)\\r\\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\r\\n    if (x & 0x800000 > 0)\\r\\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\r\\n    if (x & 0x400000 > 0)\\r\\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\\r\\n    if (x & 0x200000 > 0)\\r\\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\\r\\n    if (x & 0x100000 > 0)\\r\\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\\r\\n    if (x & 0x80000 > 0)\\r\\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\r\\n    if (x & 0x40000 > 0)\\r\\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\r\\n    if (x & 0x20000 > 0)\\r\\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\r\\n    if (x & 0x10000 > 0)\\r\\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\r\\n    if (x & 0x8000 > 0)\\r\\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\r\\n    if (x & 0x4000 > 0)\\r\\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\r\\n    if (x & 0x2000 > 0)\\r\\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\\r\\n    if (x & 0x1000 > 0)\\r\\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\r\\n    if (x & 0x800 > 0)\\r\\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\r\\n    if (x & 0x400 > 0)\\r\\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\\r\\n    if (x & 0x200 > 0)\\r\\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\r\\n    if (x & 0x100 > 0)\\r\\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\\r\\n    if (x & 0x80 > 0)\\r\\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\r\\n    if (x & 0x40 > 0)\\r\\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\r\\n    if (x & 0x20 > 0)\\r\\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\\r\\n    if (x & 0x10 > 0)\\r\\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\r\\n    if (x & 0x8 > 0)\\r\\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\r\\n    if (x & 0x4 > 0)\\r\\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\r\\n    if (x & 0x2 > 0)\\r\\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\\r\\n    if (x & 0x1 > 0)\\r\\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\\r\\n\\r\\n    result >>= 63 - (x >> 64);\\r\\n    require (result <= uint256 (MAX_64x64));\\r\\n\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate natural exponent of x.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function exp (int128 x) internal pure returns (int128) {\\r\\n    require (x < 0x400000000000000000); // Overflow\\r\\n\\r\\n    if (x < -0x400000000000000000) return 0; // Underflow\\r\\n\\r\\n    return exp_2 (\\r\\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\r\\n   * integer numbers.  Revert on overflow or when y is zero.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @param y unsigned 256-bit integer number\\r\\n   * @return unsigned 64.64-bit fixed point number\\r\\n   */\\r\\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\\r\\n    require (y != 0);\\r\\n\\r\\n    uint256 result;\\r\\n\\r\\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\r\\n      result = (x << 64) / y;\\r\\n    else {\\r\\n      uint256 msb = 192;\\r\\n      uint256 xc = x >> 192;\\r\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\r\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\r\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\r\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\r\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\r\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\r\\n\\r\\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\\r\\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n\\r\\n      uint256 hi = result * (y >> 128);\\r\\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n\\r\\n      uint256 xh = x >> 192;\\r\\n      uint256 xl = x << 64;\\r\\n\\r\\n      if (xl < lo) xh -= 1;\\r\\n      xl -= lo; // We rely on overflow behavior here\\r\\n      lo = hi << 128;\\r\\n      if (xl < lo) xh -= 1;\\r\\n      xl -= lo; // We rely on overflow behavior here\\r\\n\\r\\n      assert (xh == hi >> 128);\\r\\n\\r\\n      result += xl / y;\\r\\n    }\\r\\n\\r\\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n    return uint128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\\r\\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x unsigned 129.127-bit fixed point number\\r\\n   * @param y uint256 value\\r\\n   * @return unsigned 129.127-bit fixed point number\\r\\n   */\\r\\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\\r\\n    if (y == 0) return 0x80000000000000000000000000000000;\\r\\n    else if (x == 0) return 0;\\r\\n    else {\\r\\n      int256 msb = 0;\\r\\n      uint256 xc = x;\\r\\n      if (xc >= 0x100000000000000000000000000000000) { xc >>= 128; msb += 128; }\\r\\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\r\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\r\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\r\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\r\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\r\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\r\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\r\\n\\r\\n      int256 xe = msb - 127;\\r\\n      if (xe > 0) x >>= xe;\\r\\n      else x <<= -xe;\\r\\n\\r\\n      uint256 result = 0x80000000000000000000000000000000;\\r\\n      int256 re = 0;\\r\\n\\r\\n      while (y > 0) {\\r\\n        if (y & 1 > 0) {\\r\\n          result = result * x;\\r\\n          y -= 1;\\r\\n          re += xe;\\r\\n          if (result >=\\r\\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\\r\\n            result >>= 128;\\r\\n            re += 1;\\r\\n          } else result >>= 127;\\r\\n          if (re < -127) return 0; // Underflow\\r\\n          require (re < 128); // Overflow\\r\\n        } else {\\r\\n          x = x * x;\\r\\n          y >>= 1;\\r\\n          xe <<= 1;\\r\\n          if (x >=\\r\\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\\r\\n            x >>= 128;\\r\\n            xe += 1;\\r\\n          } else x >>= 127;\\r\\n          if (xe < -127) return 0; // Underflow\\r\\n          require (xe < 128); // Overflow\\r\\n        }\\r\\n      }\\r\\n\\r\\n      if (re > 0) result <<= re;\\r\\n      else if (re < 0) result >>= -re;\\r\\n\\r\\n      return result;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\r\\n   * number.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @return unsigned 128-bit integer number\\r\\n   */\\r\\n  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\\r\\n    if (x == 0) return 0;\\r\\n    else {\\r\\n      require (r > 0);\\r\\n      while (true) {\\r\\n        uint256 rr = x / r;\\r\\n        if (r == rr || r + 1 == rr) return uint128 (r);\\r\\n        else if (r == rr + 1) return uint128 (rr);\\r\\n        r = r + rr + 1 >> 1;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"contracts/tokenbasic.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\r\\n\\r\\ninterface basic{\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n    function transferFrom(address from, address to, uint value) external;\\r\\n    function approve(address spender, uint value) external;\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address who) external view returns (uint);\\r\\n    function transfer(address to, uint value) external;\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n}\"\r\n    },\r\n    \"contracts/bkk.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see {ERC20Detailed}.\\r\\n */\\r\\ninterface bkk {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external ;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"\r\n    },\r\n    \"contracts/strings.sol\": {\r\n      \"content\": \"pragma solidity >= 0.5.0 < 0.6.0;  \\r\\n \\r\\nlibrary strings {  \\r\\n    struct slice {  \\r\\n        uint _len;  \\r\\n        uint _ptr;  \\r\\n    }  \\r\\n \\r\\n    function memcpy(uint dest, uint src, uint len) private pure {  \\r\\n        // Copy word-length chunks while possible  \\r\\n        for(; len >= 32; len -= 32) {  \\r\\n            assembly {  \\r\\n                mstore(dest, mload(src))  \\r\\n            }  \\r\\n            dest += 32;  \\r\\n            src += 32;  \\r\\n        }  \\r\\n \\r\\n        // Copy remaining bytes  \\r\\n        uint mask = 256 ** (32 - len) - 1;  \\r\\n        assembly {  \\r\\n            let srcpart := and(mload(src), not(mask))  \\r\\n                let destpart := and(mload(dest), mask)  \\r\\n                mstore(dest, or(destpart, srcpart))  \\r\\n        }  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Returns a slice containing the entire string.  \\r\\n     * @param self The string to make a slice from.  \\r\\n     * @return A newly allocated slice containing the entire string.  \\r\\n     */  \\r\\n    function toSlice(string memory self) internal pure returns (slice memory) {  \\r\\n        uint ptr;  \\r\\n        assembly {  \\r\\nptr := add(self, 0x20)  \\r\\n        }  \\r\\n        return slice(bytes(self).length, ptr);  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Returns the length of a null-terminated bytes32 string.  \\r\\n     * @param self The value to find the length of.  \\r\\n     * @return The length of the string, from 0 to 32.  \\r\\n     */  \\r\\n    function len(bytes32 self) internal pure returns (uint) {  \\r\\n        uint ret;  \\r\\n        if (self == 0)  \\r\\n            return 0;  \\r\\n        if (uint(self) & 0xffffffffffffffffffffffffffffffff == 0) {  \\r\\n            ret += 16;  \\r\\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);  \\r\\n        }  \\r\\n        if (uint(self) & 0xffffffffffffffff == 0) {  \\r\\n            ret += 8;  \\r\\n            self = bytes32(uint(self) / 0x10000000000000000);  \\r\\n        }  \\r\\n        if (uint(self) & 0xffffffff == 0) {  \\r\\n            ret += 4;  \\r\\n            self = bytes32(uint(self) / 0x100000000);  \\r\\n        }  \\r\\n        if (uint(self) & 0xffff == 0) {  \\r\\n            ret += 2;  \\r\\n            self = bytes32(uint(self) / 0x10000);  \\r\\n        }  \\r\\n        if (uint(self) & 0xff == 0) {  \\r\\n            ret += 1;  \\r\\n        }  \\r\\n        return 32 - ret;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Returns a slice containing the entire bytes32, interpreted as a  \\r\\n     *      null-terminated utf-8 string.  \\r\\n     * @param self The bytes32 value to convert to a slice.  \\r\\n     * @return A new slice containing the value of the input argument up to the  \\r\\n     *         first null.  \\r\\n     */  \\r\\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {  \\r\\n        // Allocate space for `self` in memory, copy it there, and point ret at it  \\r\\n        assembly {  \\r\\n            let ptr := mload(0x40)  \\r\\n                mstore(0x40, add(ptr, 0x20))  \\r\\n                mstore(ptr, self)  \\r\\n                mstore(add(ret, 0x20), ptr)  \\r\\n        }  \\r\\n        ret._len = len(self);  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Returns a new slice containing the same data as the current slice.  \\r\\n     * @param self The slice to copy.  \\r\\n     * @return A new slice containing the same data as `self`.  \\r\\n     */  \\r\\n    function copy(slice memory self) internal pure returns (slice memory) {  \\r\\n        return slice(self._len, self._ptr);  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Copies a slice to a new string.  \\r\\n     * @param self The slice to copy.  \\r\\n     * @return A newly allocated string containing the slice's text.  \\r\\n     */  \\r\\n    function toString(slice memory self) internal pure returns (string memory) {  \\r\\n        string memory ret = new string(self._len);  \\r\\n        uint retptr;  \\r\\n        assembly { retptr := add(ret, 32) }  \\r\\n \\r\\n        memcpy(retptr, self._ptr, self._len);  \\r\\n        return ret;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Returns the length in runes of the slice. Note that this operation  \\r\\n     *      takes time proportional to the length of the slice; avoid using it  \\r\\n     *      in loops, and call `slice.empty()` if you only need to know whether  \\r\\n     *      the slice is empty or not.  \\r\\n     * @param self The slice to operate on.  \\r\\n     * @return The length of the slice in runes.  \\r\\n     */  \\r\\n    function len(slice memory self) internal pure returns (uint l) {  \\r\\n        // Starting at ptr-31 means the LSB will be the byte we care about  \\r\\n        uint ptr = self._ptr - 31;  \\r\\n        uint end = ptr + self._len;  \\r\\n        for (l = 0; ptr < end; l++) {  \\r\\n            uint8 b;  \\r\\n            assembly { b := and(mload(ptr), 0xFF) }  \\r\\n            if (b < 0x80) {  \\r\\n                ptr += 1;  \\r\\n            } else if(b < 0xE0) {  \\r\\n                ptr += 2;  \\r\\n            } else if(b < 0xF0) {  \\r\\n                ptr += 3;  \\r\\n            } else if(b < 0xF8) {  \\r\\n                ptr += 4;  \\r\\n            } else if(b < 0xFC) {  \\r\\n                ptr += 5;  \\r\\n            } else {  \\r\\n                ptr += 6;  \\r\\n            }  \\r\\n        }  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Returns true if the slice is empty (has a length of 0).  \\r\\n     * @param self The slice to operate on.  \\r\\n     * @return True if the slice is empty, False otherwise.  \\r\\n     */  \\r\\n    function empty(slice memory self) internal pure returns (bool) {  \\r\\n        return self._len == 0;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Returns a positive number if `other` comes lexicographically after  \\r\\n     *      `self`, a negative number if it comes before, or zero if the  \\r\\n     *      contents of the two slices are equal. Comparison is done per-rune,  \\r\\n     *      on unicode codepoints.  \\r\\n     * @param self The first slice to compare.  \\r\\n     * @param other The second slice to compare.  \\r\\n     * @return The result of the comparison.  \\r\\n     */  \\r\\n    function compare(slice memory self, slice memory other) internal pure returns (int) {  \\r\\n        uint shortest = self._len;  \\r\\n        if (other._len < self._len)  \\r\\n            shortest = other._len;  \\r\\n \\r\\n        uint selfptr = self._ptr;  \\r\\n        uint otherptr = other._ptr;  \\r\\n        for (uint idx = 0; idx < shortest; idx += 32) {  \\r\\n            uint a;  \\r\\n            uint b;  \\r\\n            assembly {  \\r\\na := mload(selfptr)  \\r\\n       b := mload(otherptr)  \\r\\n            }  \\r\\n            if (a != b) {  \\r\\n                // Mask out irrelevant bytes and check again  \\r\\n                uint256 mask = uint256(-1); // 0xffff...  \\r\\n                if(shortest < 32) {  \\r\\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);  \\r\\n                }  \\r\\n                uint256 diff = (a & mask) - (b & mask);  \\r\\n                if (diff != 0)  \\r\\n                    return int(diff);  \\r\\n            }  \\r\\n            selfptr += 32;  \\r\\n            otherptr += 32;  \\r\\n        }  \\r\\n        return int(self._len) - int(other._len);  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Returns true if the two slices contain the same text.  \\r\\n     * @param self The first slice to compare.  \\r\\n     * @param self The second slice to compare.  \\r\\n     * @return True if the slices are equal, false otherwise.  \\r\\n     */  \\r\\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {  \\r\\n        return compare(self, other) == 0;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Extracts the first rune in the slice into `rune`, advancing the  \\r\\n     *      slice to point to the next rune and returning `self`.  \\r\\n     * @param self The slice to operate on.  \\r\\n     * @param rune The slice that will contain the first rune.  \\r\\n     * @return `rune`.  \\r\\n     */  \\r\\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {  \\r\\n        rune._ptr = self._ptr;  \\r\\n \\r\\n        if (self._len == 0) {  \\r\\n            rune._len = 0;  \\r\\n            return rune;  \\r\\n        }  \\r\\n \\r\\n        uint l;  \\r\\n        uint b;  \\r\\n        // Load the first byte of the rune into the LSBs of b  \\r\\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }  \\r\\n        if (b < 0x80) {  \\r\\n            l = 1;  \\r\\n        } else if(b < 0xE0) {  \\r\\n            l = 2;  \\r\\n        } else if(b < 0xF0) {  \\r\\n            l = 3;  \\r\\n        } else {  \\r\\n            l = 4;  \\r\\n        }  \\r\\n \\r\\n        // Check for truncated codepoints  \\r\\n        if (l > self._len) {  \\r\\n            rune._len = self._len;  \\r\\n            self._ptr += self._len;  \\r\\n            self._len = 0;  \\r\\n            return rune;  \\r\\n        }  \\r\\n \\r\\n        self._ptr += l;  \\r\\n        self._len -= l;  \\r\\n        rune._len = l;  \\r\\n        return rune;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Returns the first rune in the slice, advancing the slice to point  \\r\\n     *      to the next rune.  \\r\\n     * @param self The slice to operate on.  \\r\\n     * @return A slice containing only the first rune from `self`.  \\r\\n     */  \\r\\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {  \\r\\n        nextRune(self, ret);  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Returns the number of the first codepoint in the slice.  \\r\\n     * @param self The slice to operate on.  \\r\\n     * @return The number of the first codepoint in the slice.  \\r\\n     */  \\r\\n    function ord(slice memory self) internal pure returns (uint ret) {  \\r\\n        if (self._len == 0) {  \\r\\n            return 0;  \\r\\n        }  \\r\\n \\r\\n        uint word;  \\r\\n        uint length;  \\r\\n        uint divisor = 2 ** 248;  \\r\\n \\r\\n        // Load the rune into the MSBs of b  \\r\\n        assembly { word:= mload(mload(add(self, 32))) }  \\r\\n        uint b = word / divisor;  \\r\\n        if (b < 0x80) {  \\r\\n            ret = b;  \\r\\n            length = 1;  \\r\\n        } else if(b < 0xE0) {  \\r\\n            ret = b & 0x1F;  \\r\\n            length = 2;  \\r\\n        } else if(b < 0xF0) {  \\r\\n            ret = b & 0x0F;  \\r\\n            length = 3;  \\r\\n        } else {  \\r\\n            ret = b & 0x07;  \\r\\n            length = 4;  \\r\\n        }  \\r\\n \\r\\n        // Check for truncated codepoints  \\r\\n        if (length > self._len) {  \\r\\n            return 0;  \\r\\n        }  \\r\\n \\r\\n        for (uint i = 1; i < length; i++) {  \\r\\n            divisor = divisor / 256;  \\r\\n            b = (word / divisor) & 0xFF;  \\r\\n            if (b & 0xC0 != 0x80) {  \\r\\n                // Invalid UTF-8 sequence  \\r\\n                return 0;  \\r\\n            }  \\r\\n            ret = (ret * 64) | (b & 0x3F);  \\r\\n        }  \\r\\n \\r\\n        return ret;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Returns the keccak-256 hash of the slice.  \\r\\n     * @param self The slice to hash.  \\r\\n     * @return The hash of the slice.  \\r\\n     */  \\r\\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {  \\r\\n        assembly {  \\r\\nret := keccak256(mload(add(self, 32)), mload(self))  \\r\\n        }  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Returns true if `self` starts with `needle`.  \\r\\n     * @param self The slice to operate on.  \\r\\n     * @param needle The slice to search for.  \\r\\n     * @return True if the slice starts with the provided text, false otherwise.  \\r\\n     */  \\r\\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {  \\r\\n        if (self._len < needle._len) {  \\r\\n            return false;  \\r\\n        }  \\r\\n \\r\\n        if (self._ptr == needle._ptr) {  \\r\\n            return true;  \\r\\n        }  \\r\\n \\r\\n        bool equal;  \\r\\n        assembly {  \\r\\n            let length := mload(needle)  \\r\\n                let selfptr := mload(add(self, 0x20))  \\r\\n                let needleptr := mload(add(needle, 0x20))  \\r\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))  \\r\\n        }  \\r\\n        return equal;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev If `self` starts with `needle`, `needle` is removed from the  \\r\\n     *      beginning of `self`. Otherwise, `self` is unmodified.  \\r\\n     * @param self The slice to operate on.  \\r\\n     * @param needle The slice to search for.  \\r\\n     * @return `self`  \\r\\n     */  \\r\\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {  \\r\\n        if (self._len < needle._len) {  \\r\\n            return self;  \\r\\n        }  \\r\\n \\r\\n        bool equal = true;  \\r\\n        if (self._ptr != needle._ptr) {  \\r\\n            assembly {  \\r\\n                let length := mload(needle)  \\r\\n                    let selfptr := mload(add(self, 0x20))  \\r\\n                    let needleptr := mload(add(needle, 0x20))  \\r\\n                    equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))  \\r\\n            }  \\r\\n        }  \\r\\n \\r\\n        if (equal) {  \\r\\n            self._len -= needle._len;  \\r\\n            self._ptr += needle._len;  \\r\\n        }  \\r\\n \\r\\n        return self;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Returns true if the slice ends with `needle`.  \\r\\n     * @param self The slice to operate on.  \\r\\n     * @param needle The slice to search for.  \\r\\n     * @return True if the slice starts with the provided text, false otherwise.  \\r\\n     */  \\r\\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {  \\r\\n        if (self._len < needle._len) {  \\r\\n            return false;  \\r\\n        }  \\r\\n \\r\\n        uint selfptr = self._ptr + self._len - needle._len;  \\r\\n \\r\\n        if (selfptr == needle._ptr) {  \\r\\n            return true;  \\r\\n        }  \\r\\n \\r\\n        bool equal;  \\r\\n        assembly {  \\r\\n            let length := mload(needle)  \\r\\n                let needleptr := mload(add(needle, 0x20))  \\r\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))  \\r\\n        }  \\r\\n \\r\\n        return equal;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev If `self` ends with `needle`, `needle` is removed from the  \\r\\n     *      end of `self`. Otherwise, `self` is unmodified.  \\r\\n     * @param self The slice to operate on.  \\r\\n     * @param needle The slice to search for.  \\r\\n     * @return `self`  \\r\\n     */  \\r\\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {  \\r\\n        if (self._len < needle._len) {  \\r\\n            return self;  \\r\\n        }  \\r\\n \\r\\n        uint selfptr = self._ptr + self._len - needle._len;  \\r\\n        bool equal = true;  \\r\\n        if (selfptr != needle._ptr) {  \\r\\n            assembly {  \\r\\n                let length := mload(needle)  \\r\\n                    let needleptr := mload(add(needle, 0x20))  \\r\\n                    equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))  \\r\\n            }  \\r\\n        }  \\r\\n \\r\\n        if (equal) {  \\r\\n            self._len -= needle._len;  \\r\\n        }  \\r\\n \\r\\n        return self;  \\r\\n    }  \\r\\n \\r\\n    // Returns the memory address of the first byte of the first occurrence of  \\r\\n    // `needle` in `self`, or the first byte after `self` if not found.  \\r\\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {  \\r\\n        uint ptr = selfptr;  \\r\\n        uint idx;  \\r\\n \\r\\n        if (needlelen <= selflen) {  \\r\\n            if (needlelen <= 32) {  \\r\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));  \\r\\n \\r\\n                bytes32 needledata;  \\r\\n                assembly { needledata := and(mload(needleptr), mask) }  \\r\\n \\r\\n                uint end = selfptr + selflen - needlelen;  \\r\\n                bytes32 ptrdata;  \\r\\n                assembly { ptrdata := and(mload(ptr), mask) }  \\r\\n \\r\\n                while (ptrdata != needledata) {  \\r\\n                    if (ptr >= end)  \\r\\n                        return selfptr + selflen;  \\r\\n                    ptr++;  \\r\\n                    assembly { ptrdata := and(mload(ptr), mask) }  \\r\\n                }  \\r\\n                return ptr;  \\r\\n            } else {  \\r\\n                // For long needles, use hashing  \\r\\n                bytes32 hash;  \\r\\n                assembly { hash := keccak256(needleptr, needlelen) }  \\r\\n \\r\\n                for (idx = 0; idx <= selflen - needlelen; idx++) {  \\r\\n                    bytes32 testHash;  \\r\\n                    assembly { testHash := keccak256(ptr, needlelen) }  \\r\\n                    if (hash == testHash)  \\r\\n                        return ptr;  \\r\\n                    ptr += 1;  \\r\\n                }  \\r\\n            }  \\r\\n        }  \\r\\n        return selfptr + selflen;  \\r\\n    }  \\r\\n \\r\\n    // Returns the memory address of the first byte after the last occurrence of  \\r\\n    // `needle` in `self`, or the address of `self` if not found.  \\r\\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {  \\r\\n        uint ptr;  \\r\\n \\r\\n        if (needlelen <= selflen) {  \\r\\n            if (needlelen <= 32) {  \\r\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));  \\r\\n \\r\\n                bytes32 needledata;  \\r\\n                assembly { needledata := and(mload(needleptr), mask) }  \\r\\n \\r\\n                ptr = selfptr + selflen - needlelen;  \\r\\n                bytes32 ptrdata;  \\r\\n                assembly { ptrdata := and(mload(ptr), mask) }  \\r\\n \\r\\n                while (ptrdata != needledata) {  \\r\\n                    if (ptr <= selfptr)  \\r\\n                        return selfptr;  \\r\\n                    ptr--;  \\r\\n                    assembly { ptrdata := and(mload(ptr), mask) }  \\r\\n                }  \\r\\n                return ptr + needlelen;  \\r\\n            } else {  \\r\\n                // For long needles, use hashing  \\r\\n                bytes32 hash;  \\r\\n                assembly { hash := keccak256(needleptr, needlelen) }  \\r\\n                ptr = selfptr + (selflen - needlelen);  \\r\\n                while (ptr >= selfptr) {  \\r\\n                    bytes32 testHash;  \\r\\n                    assembly { testHash := keccak256(ptr, needlelen) }  \\r\\n                    if (hash == testHash)  \\r\\n                        return ptr + needlelen;  \\r\\n                    ptr -= 1;  \\r\\n                }  \\r\\n            }  \\r\\n        }  \\r\\n        return selfptr;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Modifies `self` to contain everything from the first occurrence of  \\r\\n     *      `needle` to the end of the slice. `self` is set to the empty slice  \\r\\n     *      if `needle` is not found.  \\r\\n     * @param self The slice to search and modify.  \\r\\n     * @param needle The text to search for.  \\r\\n     * @return `self`.  \\r\\n     */  \\r\\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {  \\r\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);  \\r\\n        self._len -= ptr - self._ptr;  \\r\\n        self._ptr = ptr;  \\r\\n        return self;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Modifies `self` to contain the part of the string from the start of  \\r\\n     *      `self` to the end of the first occurrence of `needle`. If `needle`  \\r\\n     *      is not found, `self` is set to the empty slice.  \\r\\n     * @param self The slice to search and modify.  \\r\\n     * @param needle The text to search for.  \\r\\n     * @return `self`.  \\r\\n     */  \\r\\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {  \\r\\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);  \\r\\n        self._len = ptr - self._ptr;  \\r\\n        return self;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Splits the slice, setting `self` to everything after the first  \\r\\n     *      occurrence of `needle`, and `token` to everything before it. If  \\r\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,  \\r\\n     *      and `token` is set to the entirety of `self`.  \\r\\n     * @param self The slice to split.  \\r\\n     * @param needle The text to search for in `self`.  \\r\\n     * @param token An output parameter to which the first token is written.  \\r\\n     * @return `token`.  \\r\\n     */  \\r\\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {  \\r\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);  \\r\\n        token._ptr = self._ptr;  \\r\\n        token._len = ptr - self._ptr;  \\r\\n        if (ptr == self._ptr + self._len) {  \\r\\n            // Not found  \\r\\n            self._len = 0;  \\r\\n        } else {  \\r\\n            self._len -= token._len + needle._len;  \\r\\n            self._ptr = ptr + needle._len;  \\r\\n        }  \\r\\n        return token;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Splits the slice, setting `self` to everything after the first  \\r\\n     *      occurrence of `needle`, and returning everything before it. If  \\r\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,  \\r\\n     *      and the entirety of `self` is returned.  \\r\\n     * @param self The slice to split.  \\r\\n     * @param needle The text to search for in `self`.  \\r\\n     * @return The part of `self` up to the first occurrence of `delim`.  \\r\\n     */  \\r\\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {  \\r\\n        split(self, needle, token);  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Splits the slice, setting `self` to everything before the last  \\r\\n     *      occurrence of `needle`, and `token` to everything after it. If  \\r\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,  \\r\\n     *      and `token` is set to the entirety of `self`.  \\r\\n     * @param self The slice to split.  \\r\\n     * @param needle The text to search for in `self`.  \\r\\n     * @param token An output parameter to which the first token is written.  \\r\\n     * @return `token`.  \\r\\n     */  \\r\\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {  \\r\\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);  \\r\\n        token._ptr = ptr;  \\r\\n        token._len = self._len - (ptr - self._ptr);  \\r\\n        if (ptr == self._ptr) {  \\r\\n            // Not found  \\r\\n            self._len = 0;  \\r\\n        } else {  \\r\\n            self._len -= token._len + needle._len;  \\r\\n        }  \\r\\n        return token;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Splits the slice, setting `self` to everything before the last  \\r\\n     *      occurrence of `needle`, and returning everything after it. If  \\r\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,  \\r\\n     *      and the entirety of `self` is returned.  \\r\\n     * @param self The slice to split.  \\r\\n     * @param needle The text to search for in `self`.  \\r\\n     * @return The part of `self` after the last occurrence of `delim`.  \\r\\n     */  \\r\\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {  \\r\\n        rsplit(self, needle, token);  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.  \\r\\n     * @param self The slice to search.  \\r\\n     * @param needle The text to search for in `self`.  \\r\\n     * @return The number of occurrences of `needle` found in `self`.  \\r\\n     */  \\r\\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {  \\r\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;  \\r\\n        while (ptr <= self._ptr + self._len) {  \\r\\n            cnt++;  \\r\\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;  \\r\\n        }  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Returns True if `self` contains `needle`.  \\r\\n     * @param self The slice to search.  \\r\\n     * @param needle The text to search for in `self`.  \\r\\n     * @return True if `needle` is found in `self`, false otherwise.  \\r\\n     */  \\r\\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {  \\r\\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Returns a newly allocated string containing the concatenation of  \\r\\n     *      `self` and `other`.  \\r\\n     * @param self The first slice to concatenate.  \\r\\n     * @param other The second slice to concatenate.  \\r\\n     * @return The concatenation of the two strings.  \\r\\n     */  \\r\\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {  \\r\\n        string memory ret = new string(self._len + other._len);  \\r\\n        uint retptr;  \\r\\n        assembly { retptr := add(ret, 32) }  \\r\\n        memcpy(retptr, self._ptr, self._len);  \\r\\n        memcpy(retptr + self._len, other._ptr, other._len);  \\r\\n        return ret;  \\r\\n    }  \\r\\n \\r\\n    /*  \\r\\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a  \\r\\n     *      newly allocated string.  \\r\\n     * @param self The delimiter to use.  \\r\\n     * @param parts A list of slices to join.  \\r\\n     * @return A newly allocated string containing all the slices in `parts`,  \\r\\n     *         joined with `self`.  \\r\\n     */  \\r\\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {  \\r\\n        if (parts.length == 0)  \\r\\n            return \\\"\\\";  \\r\\n \\r\\n        uint length = self._len * (parts.length - 1);  \\r\\n        for(uint i = 0; i < parts.length; i++)  \\r\\n            length += parts[i]._len;  \\r\\n \\r\\n        string memory ret = new string(length);  \\r\\n        uint retptr;  \\r\\n        assembly { retptr := add(ret, 32) }  \\r\\n \\r\\n        for(uint i = 0; i < parts.length; i++) {  \\r\\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);  \\r\\n            retptr += parts[i]._len;  \\r\\n            if (i < parts.length - 1) {  \\r\\n                memcpy(retptr, self._ptr, self._len);  \\r\\n                retptr += self._len;  \\r\\n            }  \\r\\n        }  \\r\\n \\r\\n        return ret;  \\r\\n    }  \\r\\n}\"\r\n    },\r\n    \"contracts/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\r\\ncontract Context {\\r\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n    // an instance of this contract, which should be used via inheritance.\\r\\n    constructor () internal { }\\r\\n    // solhint-disable-previous-line no-empty-blocks\\r\\n\\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/SymbolsLib.sol\": {\r\n        \"SymbolsLib\": \"0x3414b7e8332b4da3e268ca7aa5bee6b9a25787f7\"\r\n      },\r\n      \"contracts/TokenInfoLib.sol\": {\r\n        \"TokenInfoLib\": \"0xab2ea31dba6270584486b6d7657fbfcd10f8bfae\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"onwer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenaddress\",\"type\":\"address\"}],\"name\":\"depositTokened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"onwer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenaddress\",\"type\":\"address\"}],\"name\":\"withdrawed\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"BASE_RATE_FORREWARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_ETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_PROS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_USDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_allpool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_baseRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_initReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_lastStakedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_periodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_playbook\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_poolRewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_pros\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_punishTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_rewardRateList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_teamRewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_teamWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"base_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"base_Rate_Reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenID\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddr\",\"type\":\"address\"}],\"name\":\"getAccountTotalUsdValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"usdValue\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getActiveAccounts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalances\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"int256[]\",\"name\":\"balances\",\"type\":\"int256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coinIndex\",\"type\":\"uint256\"}],\"name\":\"getCoinAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCoinLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMarketState\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"int256[]\",\"name\":\"deposits\",\"type\":\"int256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokenState\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"deposits\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"loans\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"collateral\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"one_Rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate_forReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenID\",\"type\":\"address\"}],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sec_Rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"setAllpool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"playbook\",\"type\":\"address\"}],\"name\":\"setPlaybook\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"one\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sec\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"thr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"setRate_Reward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenaddress\",\"type\":\"address\"}],\"name\":\"setTeamToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"eth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pros\",\"type\":\"address\"}],\"name\":\"set_tokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setprosToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"startReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thr_Rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"tokenBalanceOf\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"tokenBalanceOf\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "SavingAccount", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}