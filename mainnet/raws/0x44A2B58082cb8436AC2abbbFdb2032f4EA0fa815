{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/PolyRenderer.sol\": {\r\n      \"content\": \"//\\\"SPDX-License-Identifier: GPL-3.0\\n\\n/*******************************************\\n              _                       _\\n             | |                     | |\\n  _ __   ___ | |_   _ ___   __ _ _ __| |_\\n | '_ \\\\ / _ \\\\| | | | / __| / _` | '__| __|\\n | |_) | (_) | | |_| \\\\__ \\\\| (_| | |  | |_\\n | .__/ \\\\___/|_|\\\\__, |___(_)__,_|_|   \\\\__|\\n | |             __/ |\\n |_|            |___/\\n a homage to math, geometry and cryptography.\\n********************************************/\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./Trigonometry.sol\\\";\\nimport \\\"./Fixed.sol\\\";\\n\\n\\nlibrary PolyRenderer {\\n    using Trigonometry for uint16;\\n    using Fixed for int64;\\n\\n    struct Polygon {\\n        uint8 sides;\\n        uint8 color;\\n        uint64 size;\\n        uint16 rotation;\\n        uint64 top;\\n        uint64 left;\\n        uint64 opacity;\\n    }\\n\\n    struct Circle {\\n        uint8 color;\\n        uint64 radius;\\n        uint64 c_y;\\n        uint64 c_x;\\n        uint64 opacity;\\n    }\\n\\n    function svgOf(bytes calldata data, bool isCircle) external pure returns (string memory){\\n        // initialise svg\\n        string memory svg = '<svg width=\\\"256\\\" height=\\\"256\\\" viewBox=\\\"0 0 256 256\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">';\\n\\n        // fill it with the background colour\\n        string memory bgColor = string(abi.encodePacked(\\\"rgb(\\\", uint2str(uint8(data[0]), 0, 1), \\\",\\\", uint2str(uint8(data[1]), 0, 1), \\\",\\\", uint2str(uint8(data[2]), 0, 1), \\\")\\\"));\\n        svg = string(abi.encodePacked(svg, '<rect width=\\\"256\\\" height=\\\"256\\\" fill=\\\"', bgColor, '\\\"/>'));\\n\\n        // load Palette\\n        string[4] memory colors;\\n        for (uint8 i = 0; i < 4; i++) {\\n            colors[i] = string(abi.encodePacked(uint2str(uint8(data[3 + i * 3]), 0, 1), \\\",\\\", uint2str(uint8(data[4 + i * 3]), 0, 1), \\\",\\\", uint2str(uint8(data[5 + i * 3]), 0, 1), \\\",\\\"));\\n        }\\n\\n        // Fill it with Polygons or Circles\\n        uint polygons = (data.length - 15) / 5;\\n        string memory poly = '';\\n        Polygon memory polygon;\\n        for (uint i = 0; i < polygons; i++) {\\n            polygon = polygonFromBytes(data[15 + i * 5 : 15 + (i + 1) * 5]);\\n            poly = string(abi.encodePacked(poly,\\n                isCircle\\n                ? renderCircle(polygon, colors)\\n                : renderPolygon(polygon, colors))\\n            );\\n        }\\n        return string(abi.encodePacked(svg, poly, '</svg>'));\\n    }\\n\\n    function attributesOf(bytes calldata data, bool isCircle) external pure returns (string memory){\\n        uint elements = (data.length - 15) / 5;\\n        if (isCircle) {\\n            return string(abi.encodePacked('[{\\\"trait_type\\\":\\\"Circles\\\",\\\"value\\\":', uint2str(elements, 0, 1), '}]'));\\n        }\\n        string[4] memory types = [\\\"Triangles\\\", \\\"Squares\\\", \\\"Pentagons\\\", \\\"Hexagons\\\"];\\n        uint256[4] memory sides_count;\\n        for (uint i = 0; i < elements; i++) {\\n            sides_count[uint8(data[15 + i * 5] >> 6)]++;\\n        }\\n        string memory result = '[';\\n        string memory last;\\n        for (uint i = 0; i < 4; i++) {\\n            last = i == 3 ? '}' : '},';\\n            result = string(abi.encodePacked(result, '{\\\"trait_type\\\":\\\"', types[i], '\\\",\\\"value\\\":',\\n                uint2str(sides_count[i], 0, 1), last));\\n        }\\n        return string(abi.encodePacked(result, ']'));\\n    }\\n\\n    function renderCircle(Polygon memory polygon, string[4] memory colors) internal pure returns (string memory){\\n        int64 radius = getRadius(polygon.sides, polygon.size);\\n        return string(abi.encodePacked('<circle cx=\\\"', fixedToString(int64(polygon.left).toFixed(), 1), '\\\" cy=\\\"',\\n            fixedToString(int64(polygon.top).toFixed(), 1), '\\\" r=\\\"', fixedToString(radius, 1), '\\\" style=\\\"fill:rgba(',\\n            colors[polygon.color], opacityToString(polygon.opacity), ')\\\"/>'));\\n    }\\n\\n    function opacityToString(uint64 opacity) internal pure returns (string memory) {\\n        return opacity == 31\\n        ? '1'\\n        : string(abi.encodePacked('0.', uint2str(uint64(int64(opacity).div(31).fractionPart()), 5, 1)));\\n    }\\n\\n    function polygonFromBytes(bytes calldata data) internal pure returns (Polygon memory) {\\n        Polygon memory polygon;\\n        // read first two bits from the left and add 3\\n        polygon.sides = (uint8(data[0]) >> 6) + 3;\\n        // read the next two bits\\n        polygon.color = (uint8(data[0]) >> 4) & 3;\\n        // read the next 5 bits\\n        polygon.opacity = ((uint8(data[0]) % 16) << 1) + (uint8(data[1]) >> 7);\\n        // read the last 7 bits.\\n        polygon.rotation = uint8(data[1]) % 128;\\n        polygon.top = uint8(data[2]);\\n        polygon.left = uint8(data[3]);\\n        polygon.size = uint64(uint8(data[4])) + 1;\\n        return polygon;\\n    }\\n\\n    function renderPolygon(Polygon memory polygon, string[4] memory colors) internal pure returns (string memory){\\n        int64[] memory points = getVertices(polygon);\\n\\n        int64 v;\\n        int8 sign;\\n        string memory last;\\n        string memory result = '<polygon points=\\\"';\\n        for (uint j = 0; j < points.length; j++) {\\n            v = points[j];\\n            sign = v < 0 ? - 1 : int8(1);\\n            last = j == points.length - 1 ? '\\\" style=\\\"fill:rgba(' : \\\",\\\";\\n            result = string(abi.encodePacked(result, fixedToString(v, sign), last));\\n        }\\n        return string(abi.encodePacked(result, colors[polygon.color], opacityToString(polygon.opacity), ')\\\"/>'));\\n    }\\n\\n    function fixedToString(int64 fPoint, int8 sign) internal pure returns (bytes memory){\\n        return abi.encodePacked(uint2str(uint64(sign * fPoint.wholePart()), 0, sign), \\\".\\\",\\n            uint2str(uint64(fPoint.fractionPart()), 5, 1));\\n    }\\n\\n    function getRotationVector(uint16 angle) internal pure returns (int64[2] memory){\\n        // returns [cos(angle), -sin(angle)]\\n        return [\\n            int64(angle.cos()).div(32767), //-32767 to 32767.\\n            int64(-angle.sin()).div(32767)\\n        ];\\n    }\\n\\n    function rotate(int64[2] memory R, int64[2] memory pos) internal pure returns (int64[2] memory){\\n        // R = [cos(angle), -sin(angle)]\\n        // rotation_matrix = [[cos(angle), -sin(angle)], [sin(angle), cos(angle)]]\\n        // this function returns rotation_matrix.dot(pos)\\n        int64[2] memory result;\\n        result[0] = R[0].mul(pos[0]) + R[1].mul(pos[1]);\\n        result[1] = - R[1].mul(pos[0]) + R[0].mul(pos[1]);\\n        return result;\\n    }\\n\\n    function vectorSum(int64[2] memory a, int64[2] memory b) internal pure returns (int64[2] memory){\\n        return [a[0] + b[0], a[1] + b[1]];\\n    }\\n\\n    function getRadius(uint8 sides, uint64 size) internal pure returns (int64){\\n        // the radius of the circumscribed circle is equal to the length of the regular poly edge divided by\\n        // cos(internal_angle/2).\\n        int64 cos_ang_2 = int64(uint64([7439101574, 6074001000, 5049036871, 4294967296][sides - 3]));\\n        return int64(size).toFixed().div(cos_ang_2);\\n    }\\n\\n    function getVertices(Polygon memory polygon) internal pure returns (int64[] memory) {\\n        int64[] memory result = new int64[](2 * polygon.sides);\\n        uint16 internalAngle = [1365, 2048, 2458, 2731][polygon.sides - 3]; // Note: 16384 is 2pi\\n        uint16 angle = [5461, 4096, 3277, 2731][polygon.sides - 3]; // 16384/sides\\n        int64 radius = getRadius(polygon.sides, polygon.size);\\n\\n        // We map our rotation that goes from [0, 128[, to [0, 16384/sides[. 16384 is 2pi on the Trigonometry package.\\n        // We say 128 = 16384/sides because if you rotate a regular polygon by 2pi/number_of_sides it will be exactly the\\n        // same as rotating it by 2pi (due to the symmetries of regular polys).\\n        // We gain more precision by taking advantage of these symmetries.\\n\\n        uint16 rotation = uint16((polygon.rotation << 7) / polygon.sides + internalAngle);\\n\\n        int64[2] memory R = getRotationVector(rotation);\\n        int64[2] memory vector = rotate(R, [radius, 0]);\\n        int64[2] memory center = [int64(polygon.left).toFixed(), int64(polygon.top).toFixed()];\\n        int64[2] memory pos = vectorSum(center, vector);\\n        result[0] = pos[0];\\n        result[1] = pos[1];\\n        R = getRotationVector(angle);\\n        for (uint8 i = 0; i < polygon.sides - 1; i++) {\\n            vector = rotate(R, vector);\\n            pos = vectorSum(center, vector);\\n            result[(i + 1) * 2] = pos[0];\\n            result[(i + 1) * 2 + 1] = pos[1];\\n        }\\n        return result;\\n    }\\n\\n    function uint2str(uint _i, uint8 zero_padding, int8 sign) internal pure returns (string memory str) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint j = _i;\\n        uint length;\\n        while (j != 0) {\\n            length++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(length);\\n        uint k = length;\\n        j = _i;\\n        while (j != 0) {\\n            bstr[--k] = bytes1(uint8(48 + j % 10));\\n            j /= 10;\\n        }\\n        if ((zero_padding > 0) && (zero_padding > length)) {\\n            uint pad_length = zero_padding - length;\\n            bytes memory pad = new bytes(pad_length);\\n            k = 0;\\n            while (k < pad_length) {\\n                pad[k++] = bytes1(uint8(48));\\n            }\\n            bstr = abi.encodePacked(pad, bstr);\\n        }\\n        if (sign < 0) {\\n            return string(abi.encodePacked(\\\"-\\\", bstr));\\n        } else {\\n            return string(bstr);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/contracts/Trigonometry.sol\": {\r\n      \"content\": \"//\\\"SPDX-License-Identifier: BSD3\\n/**\\n * Basic trigonometry functions\\n *\\n * Solidity library offering the functionality of basic trigonometry functions\\n * with both input and output being integer approximated.\\n *\\n * This is useful since:\\n * - At the moment no floating/fixed point math can happen in solidity\\n * - Should be (?) cheaper than the actual operations using floating point\\n *   if and when they are implemented.\\n *\\n * The implementation is based off Dave Dribin's trigint C library\\n * http://www.dribin.org/dave/trigint/\\n * Which in turn is based from a now deleted article which can be found in\\n * the internet wayback machine:\\n * http://web.archive.org/web/20120301144605/http://www.dattalo.com/technical/software/pic/picsine.html\\n *\\n * @author Lefteris Karapetsas\\n * @license BSD3\\n */\\npragma solidity ^0.8.4;\\n\\nlibrary Trigonometry {\\n\\n    // Table index into the trigonometric table\\n    uint constant INDEX_WIDTH = 4;\\n    // Interpolation between successive entries in the tables\\n    uint constant INTERP_WIDTH = 8;\\n    uint constant INDEX_OFFSET = 12 - INDEX_WIDTH;\\n    uint constant INTERP_OFFSET = INDEX_OFFSET - INTERP_WIDTH;\\n    uint16 constant ANGLES_IN_CYCLE = 16384;\\n    uint16 constant QUADRANT_HIGH_MASK = 8192;\\n    uint16 constant QUADRANT_LOW_MASK = 4096;\\n    uint constant SINE_TABLE_SIZE = 16;\\n\\n    // constant sine lookup table generated by gen_tables.py\\n    // We have no other choice but this since constant arrays don't yet exist\\n    uint8 constant entry_bytes = 2;\\n    bytes constant sin_table = \\\"\\\\x00\\\\x00\\\\x0c\\\\x8c\\\\x18\\\\xf9\\\\x25\\\\x28\\\\x30\\\\xfb\\\\x3c\\\\x56\\\\x47\\\\x1c\\\\x51\\\\x33\\\\x5a\\\\x82\\\\x62\\\\xf1\\\\x6a\\\\x6d\\\\x70\\\\xe2\\\\x76\\\\x41\\\\x7a\\\\x7c\\\\x7d\\\\x89\\\\x7f\\\\x61\\\\x7f\\\\xff\\\";\\n\\n    /**\\n     * Convenience function to apply a mask on an integer to extract a certain\\n     * number of bits. Using exponents since solidity still does not support\\n     * shifting.\\n     *\\n     * @param _value The integer whose bits we want to get\\n     * @param _width The width of the bits (in bits) we want to extract\\n     * @param _offset The offset of the bits (in bits) we want to extract\\n     * @return An integer containing _width bits of _value starting at the\\n     *         _offset bit\\n     */\\n    function bits(uint _value, uint _width, uint _offset) pure internal returns (uint) {\\n        return (_value / (2 ** _offset)) & (((2 ** _width)) - 1);\\n    }\\n\\n    function sin_table_lookup(uint index) pure internal returns (uint16) {\\n        bytes memory table = sin_table;\\n        uint offset = (index + 1) * entry_bytes;\\n        uint16 trigint_value;\\n        assembly {\\n            trigint_value := mload(add(table, offset))\\n        }\\n\\n        return trigint_value;\\n    }\\n\\n    /**\\n     * Return the sine of an integer approximated angle as a signed 16-bit\\n     * integer.\\n     *\\n     * @param _angle A 14-bit angle. This divides the circle into 16384\\n     *               angle units, instead of the standard 360 degrees.\\n     * @return The sine result as a number in the range -32767 to 32767.\\n     */\\n    function sin(uint16 _angle) internal pure returns (int) {\\n        uint interp = bits(_angle, INTERP_WIDTH, INTERP_OFFSET);\\n        uint index = bits(_angle, INDEX_WIDTH, INDEX_OFFSET);\\n\\n        bool is_odd_quadrant = (_angle & QUADRANT_LOW_MASK) == 0;\\n        bool is_negative_quadrant = (_angle & QUADRANT_HIGH_MASK) != 0;\\n\\n        if (!is_odd_quadrant) {\\n            index = SINE_TABLE_SIZE - 1 - index;\\n        }\\n\\n        uint x1 = sin_table_lookup(index);\\n        uint x2 = sin_table_lookup(index + 1);\\n        uint approximation = ((x2 - x1) * interp) / (2 ** INTERP_WIDTH);\\n\\n        int sine;\\n        if (is_odd_quadrant) {\\n            sine = int(x1) + int(approximation);\\n        } else {\\n            sine = int(x2) - int(approximation);\\n        }\\n\\n        if (is_negative_quadrant) {\\n            sine *= -1;\\n        }\\n\\n        return sine;\\n    }\\n\\n    /**\\n     * Return the cos of an integer approximated angle.\\n     * It functions just like the sin() method but uses the trigonometric\\n     * identity sin(x + pi/2) = cos(x) to quickly calculate the cos.\\n     */\\n    function cos(uint16 _angle) internal pure returns (int) {\\n        _angle = (_angle + QUADRANT_LOW_MASK) % ANGLES_IN_CYCLE;\\n\\n        return sin(_angle);\\n    }\\n}\"\r\n    },\r\n    \"/contracts/Fixed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*******************************************\\n              _                       _\\n             | |                     | |\\n  _ __   ___ | |_   _ ___   __ _ _ __| |_\\n | '_ \\\\ / _ \\\\| | | | / __| / _` | '__| __|\\n | |_) | (_) | | |_| \\\\__ \\\\| (_| | |  | |_\\n | .__/ \\\\___/|_|\\\\__, |___(_)__,_|_|   \\\\__|\\n | |             __/ |\\n |_|            |___/\\n\\n a homage to math, geometry and cryptography.\\n********************************************/\\npragma solidity ^0.8.4;\\n\\n\\nlibrary Fixed {\\n    uint8 constant scale = 32;\\n\\n    function toFixed(int64 i) internal pure returns (int64){\\n        return i << scale;\\n    }\\n\\n    function toInt(int64 f) internal pure returns (int64){\\n        return f >> scale;\\n    }\\n\\n    /// @notice outputs the first 5 decimal places\\n    function fractionPart(int64 f) internal pure returns (int64){\\n        int8 sign = f < 0 ? - 1 : int8(1);\\n        // zero out the digits before the comma\\n        int64 fraction = (sign * f) & 2 ** 32 - 1;\\n        // Get the first 5 decimals\\n        return int64(int128(fraction) * 1e5 >> scale);\\n    }\\n\\n    function wholePart(int64 f) internal pure returns (int64){\\n        return f >> scale;\\n    }\\n\\n    function mul(int64 a, int64 b) internal pure returns (int64) {\\n        return int64(int128(a) * int128(b) >> scale);\\n    }\\n\\n    function div(int64 a, int64 b) internal pure returns (int64){\\n        return int64((int128(a) << scale) / b);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"isCircle\",\"type\":\"bool\"}],\"name\":\"attributesOf\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"isCircle\",\"type\":\"bool\"}],\"name\":\"svgOf\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "PolyRenderer", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}