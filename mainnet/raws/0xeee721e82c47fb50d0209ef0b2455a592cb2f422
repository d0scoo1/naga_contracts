{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/ERC721PermitEverywhere.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.15;\\n\\n/// @title ERC721PermitEverywhere\\n/// @notice Enables permit-style approvals for all ERC721 tokens.\\ncontract ERC721PermitEverywhere {\\n    bytes32 public immutable DOMAIN_SEPARATOR;\\n    bytes32 public immutable TRANSFER_PERMIT_TYPEHASH;\\n\\n    // Permit message to be consumed by executePermitTransferFrom() or\\n    // executePermitSafeTransferFrom().\\n    struct PermitTransferFrom {\\n        // The token being spent.\\n        IERC721 token;\\n        // Who is allowed to execute/burn the permit message.\\n        address spender;\\n        // The token ID of `token` `spender` can transfer.\\n        uint256 tokenId;\\n        // If true, `spender` may transfer any token ID and `tokenId` is ignored.\\n        bool allowAnyTokenId;\\n        // The timestamp beyond which this permit is no longer valid.\\n        uint256 deadline;\\n    }\\n\\n    struct Signature {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n    }\\n\\n    /// @notice The current nonce for a signer. This value will be incremented\\n    ///         for each executed permit message.\\n    /// @dev Owner -> current nonce.\\n    mapping(address => uint256) public currentNonce;\\n\\n    constructor() {\\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\\n            keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n            keccak256(bytes('ERC721PermitEverywhere')),\\n            keccak256('1.0.0'),\\n            block.chainid,\\n            address(this)\\n        ));\\n        TRANSFER_PERMIT_TYPEHASH =\\n            keccak256('PermitTransferFrom(address token,address spender,uint256 tokenId,bool allowAnyTokenId,uint256 deadline,uint256 nonce)');\\n    }\\n\\n    /// @notice Increase sender's nonce by `increaseAmount`. This will effectively\\n    ///         cancel any outstanding permits signed with a nonce lower than the\\n    ///         final value.\\n    function increaseNonce(uint256 increaseAmount) external {\\n        currentNonce[msg.sender] += increaseAmount;\\n    }\\n\\n    /// @notice Execute a signed permit message to transfer ERC721 tokens\\n    ///         on behalf of the signer using IERC721.transferFrom().\\n    ///         The signer's nonce will be incremented during execution,\\n    ///         preventing the message from being used again.\\n    /// @param from Permit signer.\\n    /// @param to Recipient of the token.\\n    /// @param tokenId ID of the token to transfer.\\n    /// @param permit Permit message.\\n    /// @param sig Signature for permit message, signed by `from`.\\n    function executePermitTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        PermitTransferFrom calldata permit,\\n        Signature calldata sig\\n    )\\n        external\\n    {\\n        _consumePermit(from, tokenId, permit, sig);\\n        permit.token.transferFrom(from, to, tokenId);\\n    }\\n\\n    /// @notice Execute a signed permit message to transfer ERC721 tokens\\n    ///         on behalf of the signer using IERC721.safeTransferFrom().\\n    ///         The signer's nonce will be incremented during execution,\\n    ///         preventing the message from being used again.\\n    /// @param from Permit signer.\\n    /// @param to Recipient of the token.\\n    /// @param tokenId ID of the token to transfer.\\n    /// @param permit Permit message.\\n    /// @param sig Signature for permit message, signed by `from`.\\n    function executePermitSafeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data,\\n        PermitTransferFrom calldata permit,\\n        Signature calldata sig\\n    )\\n        external\\n    {\\n        _consumePermit(from, tokenId, permit, sig);\\n        permit.token.safeTransferFrom(from, to, tokenId, data);\\n    }\\n\\n    /// @notice Compute the EIP712 hash of a permit message.\\n    function hashPermit(PermitTransferFrom memory permit, uint256 nonce)\\n        public\\n        view\\n        returns (bytes32 hash)\\n    {\\n        bytes32 domainSeparator = DOMAIN_SEPARATOR;\\n        bytes32 typeHash = TRANSFER_PERMIT_TYPEHASH;\\n        assembly {\\n            // Hash the permit message in-place to compute the struct hash.\\n            if lt(permit, 0x20)  {\\n                invalid()\\n            }\\n            // Overwrite the words above and below the permit object temporarily.\\n            let wordAbove := mload(sub(permit, 0x20))\\n            let wordBelow := mload(add(permit, 0xA0))\\n            mstore(sub(permit, 0x20), typeHash)\\n            mstore(add(permit, 0xA0), nonce)\\n            let structHash := keccak256(sub(permit, 0x20), 0xE0)\\n            // Restore overwritten words.\\n            mstore(sub(permit, 0x20), wordAbove)\\n            mstore(add(permit, 0xA0), wordBelow)\\n\\n            // 0x40 will be overwritten temporarily.\\n            let memPointer := mload(0x40)\\n            // Hash the domain separator and struct hash to compute the final EIP712 hash.\\n            mstore(0x00, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n            mstore(0x02, domainSeparator)\\n            mstore(0x22, structHash)\\n            hash := keccak256(0x00, 0x42)\\n            // Restore 0x40.\\n            mstore(0x40, memPointer)\\n        }\\n    }\\n\\n    // Validate and burn a permit message.\\n    function _consumePermit(\\n        address from,\\n        uint256 tokenId,\\n        PermitTransferFrom calldata permit,\\n        Signature calldata sig\\n    )\\n        private\\n    {\\n        require(msg.sender == permit.spender, 'SPENDER_NOT_PERMITTED');\\n        require(permit.allowAnyTokenId || permit.tokenId == tokenId, 'TOKEN_ID_NOT_PERMITTED');\\n        require(permit.deadline >= block.timestamp, 'PERMIT_EXPIRED');\\n\\n        // Unchecked because the only math done is incrementing\\n        // the nonce which cannot realistically overflow.\\n        unchecked {\\n            require(\\n                from == _getSigner(hashPermit(permit, currentNonce[from]++), sig),\\n                'INVALID_SIGNER'\\n            );\\n        }\\n    }\\n\\n    function _getSigner(bytes32 hash, Signature memory sig) private pure returns (address signer) {\\n        signer = ecrecover(hash, sig.v, sig.r, sig.s);\\n        require(signer != address(0), 'INVALID_SIGNATURE');\\n    }\\n}\\n\\ninterface IERC721 {\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"script/=script/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\",\r\n      \"script/=script/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"currentNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"contract IERC721\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowAnyTokenId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC721PermitEverywhere.PermitTransferFrom\",\"name\":\"permit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct ERC721PermitEverywhere.Signature\",\"name\":\"sig\",\"type\":\"tuple\"}],\"name\":\"executePermitSafeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract IERC721\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowAnyTokenId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC721PermitEverywhere.PermitTransferFrom\",\"name\":\"permit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct ERC721PermitEverywhere.Signature\",\"name\":\"sig\",\"type\":\"tuple\"}],\"name\":\"executePermitTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC721\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowAnyTokenId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC721PermitEverywhere.PermitTransferFrom\",\"name\":\"permit\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"hashPermit\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"increaseAmount\",\"type\":\"uint256\"}],\"name\":\"increaseNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC721PermitEverywhere", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}