{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ShackledIcons.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ShackledStructs.sol\\\";\\nimport \\\"./ShackledRenderer.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\\";\\n\\ncontract ShackledIcons is ERC721Enumerable, Ownable {\\n    string public currentBaseURI;\\n\\n    mapping(uint256 => bytes32) public tokenHashes;\\n\\n    constructor() ERC721(\\\"ShackledIcons\\\", \\\"ICON\\\") {}\\n\\n    /**\\n     * @dev Mint token ids to a particular address\\n     */\\n    function mint(address to, uint256 tokenId) public onlyOwner {\\n        require(\\n            tokenHashes[tokenId] != 0x0,\\n            \\\"Cannot mint a token that doesn't exist\\\"\\n        );\\n        _safeMint(to, tokenId);\\n    }\\n\\n    function storeTokenHash(uint256 tokenId, bytes32 tokenHash)\\n        public\\n        onlyOwner\\n    {\\n        tokenHashes[tokenId] = tokenHash;\\n    }\\n\\n    function getRenderParamsHash(\\n        ShackledStructs.RenderParams calldata renderParams\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    abi.encodePacked(\\n                        renderParams.faces,\\n                        renderParams.verts,\\n                        renderParams.cols\\n                    ),\\n                    abi.encodePacked(\\n                        renderParams.objPosition,\\n                        renderParams.objScale,\\n                        renderParams.backgroundColor,\\n                        renderParams.perspCamera,\\n                        renderParams.backfaceCulling,\\n                        renderParams.invert,\\n                        renderParams.wireframe\\n                    ),\\n                    _getLightingParamsHash(renderParams.lightingParams)\\n                )\\n            );\\n    }\\n\\n    function _getLightingParamsHash(\\n        ShackledStructs.LightingParams calldata lightingParams\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    lightingParams.applyLighting,\\n                    lightingParams.lightAmbiPower,\\n                    lightingParams.lightDiffPower,\\n                    lightingParams.lightSpecPower,\\n                    lightingParams.inverseShininess,\\n                    lightingParams.lightPos,\\n                    lightingParams.lightColSpec,\\n                    lightingParams.lightColDiff,\\n                    lightingParams.lightColAmbi\\n                )\\n            );\\n    }\\n\\n    function render(\\n        uint256 tokenId,\\n        int256 canvasDim_,\\n        ShackledStructs.RenderParams calldata renderParams\\n    ) public view returns (string memory) {\\n        bytes32 tokenHash = getRenderParamsHash(renderParams);\\n        require(tokenHash == tokenHashes[tokenId], \\\"Token hash mismatch\\\");\\n        return ShackledRenderer.render(renderParams, canvasDim_, true);\\n    }\\n\\n    function setBaseURI(string memory baseURI_) public onlyOwner {\\n        currentBaseURI = baseURI_;\\n    }\\n\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return currentBaseURI;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ShackledStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ShackledStructs {\\n    struct Metadata {\\n        string colorScheme; /// name of the color scheme\\n        string geomSpec; /// name of the geometry specification\\n        uint256 nPrisms; /// number of prisms made\\n        string pseudoSymmetry; /// horizontal, vertical, diagonal\\n        string wireframe; /// enabled or disabled\\n        string inversion; /// enabled or disabled\\n    }\\n\\n    struct RenderParams {\\n        uint256[3][] faces; /// index of verts and colorss used for each face (triangle)\\n        int256[3][] verts; /// x, y, z coordinates used in the geometry\\n        int256[3][] cols; /// colors of each vert\\n        int256[3] objPosition; /// position to place the object\\n        int256 objScale; /// scalar for the object\\n        int256[3][2] backgroundColor; /// color of the background (gradient)\\n        LightingParams lightingParams; /// parameters for the lighting\\n        bool perspCamera; /// true = perspective camera, false = orthographic\\n        bool backfaceCulling; /// whether to implement backface culling (saves gas!)\\n        bool invert; /// whether to invert colors in the final encoding stage\\n        bool wireframe; /// whether to only render edges\\n    }\\n\\n    /// struct for testing lighting\\n    struct LightingParams {\\n        bool applyLighting; /// true = apply lighting, false = don't apply lighting\\n        int256 lightAmbiPower; /// power of the ambient light\\n        int256 lightDiffPower; /// power of the diffuse light\\n        int256 lightSpecPower; /// power of the specular light\\n        uint256 inverseShininess; /// shininess of the material\\n        int256[3] lightPos; /// position of the light\\n        int256[3] lightColSpec; /// color of the specular light\\n        int256[3] lightColDiff; /// color of the diffuse light\\n        int256[3] lightColAmbi; /// color of the ambient light\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ShackledRenderer.sol\": {\r\n      \"content\": \"// // SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ShackledCoords.sol\\\";\\nimport \\\"./ShackledRasteriser.sol\\\";\\nimport \\\"./ShackledUtils.sol\\\";\\nimport \\\"./ShackledStructs.sol\\\";\\n\\nlibrary ShackledRenderer {\\n    uint256 constant outputHeight = 512;\\n    uint256 constant outputWidth = 512;\\n\\n    /** @dev take any geometry, render it, and return a bitmap image inside an SVG \\n    this can be called to render the Shackled art collection (the output of ShackledGenesis.sol)\\n    or any other custom made geometry\\n\\n    */\\n    function render(\\n        ShackledStructs.RenderParams memory renderParams,\\n        int256 canvasDim,\\n        bool returnSVG\\n    ) public view returns (string memory) {\\n        /// prepare the fragments\\n        int256[12][3][] memory trisFragments = prepareGeometryForRender(\\n            renderParams,\\n            canvasDim\\n        );\\n\\n        /// run Bresenham's line algorithm to rasterize the fragments\\n        int256[12][] memory fragments = ShackledRasteriser.rasterise(\\n            trisFragments,\\n            canvasDim,\\n            renderParams.wireframe\\n        );\\n\\n        fragments = ShackledRasteriser.depthTesting(fragments, canvasDim);\\n\\n        if (renderParams.lightingParams.applyLighting) {\\n            /// apply lighting (Blinn phong)\\n            fragments = ShackledRasteriser.lightScene(\\n                fragments,\\n                renderParams.lightingParams\\n            );\\n        }\\n\\n        /// get the background\\n        int256[5][] memory background = ShackledRasteriser.getBackground(\\n            canvasDim,\\n            renderParams.backgroundColor\\n        );\\n\\n        /// place each fragment in an encoded bitmap\\n        string memory encodedBitmap = ShackledUtils.getEncodedBitmap(\\n            fragments,\\n            background,\\n            canvasDim,\\n            renderParams.invert\\n        );\\n\\n        if (returnSVG) {\\n            /// insert the bitmap into an encoded svg (to be accepted by OpenSea)\\n            return\\n                ShackledUtils.getSVGContainer(\\n                    encodedBitmap,\\n                    canvasDim,\\n                    outputHeight,\\n                    outputWidth\\n                );\\n        } else {\\n            return encodedBitmap;\\n        }\\n    }\\n\\n    /** @dev prepare the triangles and colors for rasterization\\n     */\\n    function prepareGeometryForRender(\\n        ShackledStructs.RenderParams memory renderParams,\\n        int256 canvasDim\\n    ) internal view returns (int256[12][3][] memory) {\\n        /// convert geometry and colors from PLY standard into Shackled format\\n        /// create the final triangles and colors that will be rendered\\n        /// by pulling the numbers out of the faces array\\n        /// and using them to index into the verts and colors arrays\\n        /// make copies of each coordinate and color\\n        int256[3][3][] memory tris = new int256[3][3][](\\n            renderParams.faces.length\\n        );\\n        int256[3][3][] memory trisCols = new int256[3][3][](\\n            renderParams.faces.length\\n        );\\n\\n        for (uint256 i = 0; i < renderParams.faces.length; i++) {\\n            for (uint256 j = 0; j < 3; j++) {\\n                for (uint256 k = 0; k < 3; k++) {\\n                    /// copy the values from verts and cols arrays\\n                    /// using the faces lookup array to index into them\\n                    tris[i][j][k] = renderParams.verts[\\n                        renderParams.faces[i][j]\\n                    ][k];\\n                    trisCols[i][j][k] = renderParams.cols[\\n                        renderParams.faces[i][j]\\n                    ][k];\\n                }\\n            }\\n        }\\n\\n        /// convert the fragments from model to world space\\n        int256[3][] memory vertsWorldSpace = ShackledCoords\\n            .convertToWorldSpaceWithModelTransform(\\n                tris,\\n                renderParams.objScale,\\n                renderParams.objPosition\\n            );\\n\\n        /// convert the vertices back to triangles in world space\\n        int256[3][3][] memory trisWorldSpace = ShackledUtils\\n            .unflattenVertsToTris(vertsWorldSpace);\\n\\n        /// implement backface culling\\n        if (renderParams.backfaceCulling) {\\n            (trisWorldSpace, trisCols) = ShackledCoords.backfaceCulling(\\n                trisWorldSpace,\\n                trisCols\\n            );\\n        }\\n\\n        /// update vertsWorldSpace\\n        vertsWorldSpace = ShackledUtils.flattenTris(trisWorldSpace);\\n\\n        /// convert the fragments from world to camera space\\n        int256[3][] memory vertsCameraSpace = ShackledCoords\\n            .convertToCameraSpaceViaVertexShader(\\n                vertsWorldSpace,\\n                canvasDim,\\n                renderParams.perspCamera\\n            );\\n\\n        /// convert the vertices back to triangles in camera space\\n        int256[3][3][] memory trisCameraSpace = ShackledUtils\\n            .unflattenVertsToTris(vertsCameraSpace);\\n\\n        int256[12][3][] memory trisFragments = ShackledRasteriser\\n            .initialiseFragments(\\n                trisCameraSpace,\\n                trisWorldSpace,\\n                trisCols,\\n                canvasDim\\n            );\\n\\n        return trisFragments;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n */\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 => uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721Enumerable.totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        if (from == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = ERC721.balanceOf(to);\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ShackledCoords.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ShackledUtils.sol\\\";\\nimport \\\"./ShackledMath.sol\\\";\\n\\nlibrary ShackledCoords {\\n    /** @dev scale and translate the verts\\n    this can be effectively disabled with a scale of 1 and translate of [0, 0, 0]\\n     */\\n    function convertToWorldSpaceWithModelTransform(\\n        int256[3][3][] memory tris,\\n        int256 scale,\\n        int256[3] memory position\\n    ) external view returns (int256[3][] memory) {\\n        int256[3][] memory verts = ShackledUtils.flattenTris(tris);\\n\\n        // Scale model matrices are easy, just multiply through by the scale value\\n        int256[3][] memory scaledVerts = new int256[3][](verts.length);\\n\\n        for (uint256 i = 0; i < verts.length; i++) {\\n            scaledVerts[i][0] = verts[i][0] * scale + position[0];\\n            scaledVerts[i][1] = verts[i][1] * scale + position[1];\\n            scaledVerts[i][2] = verts[i][2] * scale + position[2];\\n        }\\n        return scaledVerts;\\n    }\\n\\n    /** @dev run backfaceCulling to save future operations on faces that aren't seen by the camera*/\\n    function backfaceCulling(\\n        int256[3][3][] memory trisWorldSpace,\\n        int256[3][3][] memory trisCols\\n    )\\n        external\\n        view\\n        returns (\\n            int256[3][3][] memory culledTrisWorldSpace,\\n            int256[3][3][] memory culledTrisCols\\n        )\\n    {\\n        culledTrisWorldSpace = new int256[3][3][](trisWorldSpace.length);\\n        culledTrisCols = new int256[3][3][](trisCols.length);\\n\\n        uint256 nextIx;\\n\\n        for (uint256 i = 0; i < trisWorldSpace.length; i++) {\\n            int256[3] memory v1 = trisWorldSpace[i][0];\\n            int256[3] memory v2 = trisWorldSpace[i][1];\\n            int256[3] memory v3 = trisWorldSpace[i][2];\\n            int256[3] memory norm = ShackledMath.crossProduct(\\n                ShackledMath.vector3Sub(v1, v2),\\n                ShackledMath.vector3Sub(v2, v3)\\n            );\\n            /// since shackled has a static positioned camera at the origin,\\n            /// the points are already in view space, relaxing the backfaceCullingCond\\n            int256 backfaceCullingCond = ShackledMath.vector3Dot(v1, norm);\\n            if (backfaceCullingCond < 0) {\\n                culledTrisWorldSpace[nextIx] = trisWorldSpace[i];\\n                culledTrisCols[nextIx] = trisCols[i];\\n                nextIx++;\\n            }\\n        }\\n        /// remove any empty slots\\n        uint256 nToCull = culledTrisWorldSpace.length - nextIx;\\n        /// cull uneeded tris\\n        assembly {\\n            mstore(\\n                culledTrisWorldSpace,\\n                sub(mload(culledTrisWorldSpace), nToCull)\\n            )\\n        }\\n        /// cull uneeded cols\\n        assembly {\\n            mstore(culledTrisCols, sub(mload(culledTrisCols), nToCull))\\n        }\\n    }\\n\\n    /**@dev calculate verts in camera space */\\n    function convertToCameraSpaceViaVertexShader(\\n        int256[3][] memory vertsWorldSpace,\\n        int256 canvasDim,\\n        bool perspCamera\\n    ) external view returns (int256[3][] memory) {\\n        // get the camera matrix as a numerator and denominator\\n        int256[4][4][2] memory cameraMatrix;\\n        if (perspCamera) {\\n            cameraMatrix = getCameraMatrixPersp();\\n        } else {\\n            cameraMatrix = getCameraMatrixOrth(canvasDim);\\n        }\\n\\n        int256[4][4] memory nM = cameraMatrix[0]; // camera matrix numerator\\n        int256[4][4] memory dM = cameraMatrix[1]; // camera matrix denominator\\n\\n        int256[3][] memory verticesCameraSpace = new int256[3][](\\n            vertsWorldSpace.length\\n        );\\n\\n        for (uint256 i = 0; i < vertsWorldSpace.length; i++) {\\n            // Convert from 3D to 4D homogenous coordinate system\\n            int256[3] memory vert = vertsWorldSpace[i];\\n\\n            // Make a copy of vert (\\\"homoVertex\\\")\\n            int256[] memory hv = new int256[](vert.length + 1);\\n\\n            for (uint256 j = 0; j < vert.length; j++) {\\n                hv[j] = vert[j];\\n            }\\n\\n            // Insert 1 at final position in copy of vert\\n            hv[hv.length - 1] = 1;\\n\\n            int256 x = ((hv[0] * nM[0][0]) / dM[0][0]) +\\n                ((hv[1] * nM[0][1]) / dM[0][1]) +\\n                ((hv[2] * nM[0][2]) / dM[0][2]) +\\n                (nM[0][3] / dM[0][3]);\\n\\n            int256 y = ((hv[0] * nM[1][0]) / dM[1][0]) +\\n                ((hv[1] * nM[1][1]) / dM[1][1]) +\\n                ((hv[2] * nM[1][2]) / dM[1][2]) +\\n                (nM[1][3] / dM[1][0]);\\n\\n            int256 z = ((hv[0] * nM[2][0]) / dM[2][0]) +\\n                ((hv[1] * nM[2][1]) / dM[2][1]) +\\n                ((hv[2] * nM[2][2]) / dM[2][2]) +\\n                (nM[2][3] / dM[2][3]);\\n\\n            int256 w = ((hv[0] * nM[3][0]) / dM[3][0]) +\\n                ((hv[1] * nM[3][1]) / dM[3][1]) +\\n                ((hv[2] * nM[3][2]) / dM[3][2]) +\\n                (nM[3][3] / dM[3][3]);\\n\\n            if (w != 1) {\\n                x = (x * 1e3) / w;\\n                y = (y * 1e3) / w;\\n                z = (z * 1e3) / w;\\n            }\\n\\n            // Turn it back into a 3-vector\\n            // Add it to the ordered list\\n            verticesCameraSpace[i] = [x, y, z];\\n        }\\n\\n        return verticesCameraSpace;\\n    }\\n\\n    /** @dev generate an orthographic camera matrix */\\n    function getCameraMatrixOrth(int256 canvasDim)\\n        internal\\n        pure\\n        returns (int256[4][4][2] memory)\\n    {\\n        int256 canvasHalf = canvasDim / 2;\\n\\n        // Left, right, top, bottom\\n        int256 r = ShackledMath.abs(canvasHalf);\\n        int256 l = -canvasHalf;\\n        int256 t = ShackledMath.abs(canvasHalf);\\n        int256 b = -canvasHalf;\\n\\n        // Z settings (near and far)\\n        /// multiplied by 1e3\\n        int256 n = 1;\\n        int256 f = 1024;\\n\\n        // Get the orthographic transform matrix\\n        // as a numerator and denominator\\n\\n        int256[4][4] memory cameraMatrixNum = [\\n            [int256(2), 0, 0, -(r + l)],\\n            [int256(0), 2, 0, -(t + b)],\\n            [int256(0), 0, -2, -(f + n)],\\n            [int256(0), 0, 0, 1]\\n        ];\\n\\n        int256[4][4] memory cameraMatrixDen = [\\n            [int256(r - l), 1, 1, (r - l)],\\n            [int256(1), (t - b), 1, (t - b)],\\n            [int256(1), 1, (f - n), (f - n)],\\n            [int256(1), 1, 1, 1]\\n        ];\\n\\n        int256[4][4][2] memory cameraMatrix = [\\n            cameraMatrixNum,\\n            cameraMatrixDen\\n        ];\\n\\n        return cameraMatrix;\\n    }\\n\\n    /** @dev generate a perspective camera matrix */\\n    function getCameraMatrixPersp()\\n        internal\\n        pure\\n        returns (int256[4][4][2] memory)\\n    {\\n        // Z settings (near and far)\\n        /// multiplied by 1e3\\n        int256 n = 500;\\n        int256 f = 501;\\n\\n        // Get the perspective transform matrix\\n        // as a numerator and denominator\\n\\n        // parameter = 1 / tan(fov in degrees / 2)\\n        // 0.1763 = 1 / tan(160 / 2)\\n        // 1.428 = 1 / tan(70 / 2)\\n        // 1.732 = 1 / tan(60 / 2)\\n        // 2.145 = 1 / tan(50 / 2)\\n\\n        int256[4][4] memory cameraMatrixNum = [\\n            [int256(2145), 0, 0, 0],\\n            [int256(0), 2145, 0, 0],\\n            [int256(0), 0, f, -f * n],\\n            [int256(0), 0, 1, 0]\\n        ];\\n\\n        int256[4][4] memory cameraMatrixDen = [\\n            [int256(1000), 1, 1, 1],\\n            [int256(1), 1000, 1, 1],\\n            [int256(1), 1, f - n, f - n],\\n            [int256(1), 1, 1, 1]\\n        ];\\n\\n        int256[4][4][2] memory cameraMatrix = [\\n            cameraMatrixNum,\\n            cameraMatrixDen\\n        ];\\n\\n        return cameraMatrix;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ShackledRasteriser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ShackledUtils.sol\\\";\\nimport \\\"./ShackledMath.sol\\\";\\nimport \\\"./ShackledStructs.sol\\\";\\n\\nlibrary ShackledRasteriser {\\n    /// define some constant lighting parameters\\n    int256 constant fidelity = int256(100); /// an extra paramater to improve numeric resolution\\n    int256 constant lightAmbiPower = int256(1); // Base light colour // was 0.5\\n    int256 constant lightDiffPower = int256(3e9); // Diffused light on surface relative strength\\n    int256 constant lightSpecPower = int256(1e7); // Specular reflection on surface relative strength\\n    uint256 constant inverseShininess = 10; // 'sharpness' of specular light on surface\\n\\n    /// define a scale factor to use in lerp to avoid rounding errors\\n    int256 constant lerpScaleFactor = 1e3;\\n\\n    /// storing variables used in the fragment lighting\\n    struct LightingVars {\\n        int256[3] fragCol;\\n        int256[3] fragNorm;\\n        int256[3] fragPos;\\n        int256[3] V;\\n        int256 vMag;\\n        int256[3] N;\\n        int256 nMag;\\n        int256[3] L;\\n        int256 lMag;\\n        int256 falloff;\\n        int256 lnDot;\\n        int256 lambertian;\\n    }\\n\\n    /// store variables used in Bresenham's line algorithm\\n    struct BresenhamsVars {\\n        int256 x;\\n        int256 y;\\n        int256 dx;\\n        int256 dy;\\n        int256 sx;\\n        int256 sy;\\n        int256 err;\\n        int256 e2;\\n    }\\n\\n    /// store variables used when running the scanline algorithm\\n    struct ScanlineVars {\\n        int256 left;\\n        int256 right;\\n        int256[12] leftFrag;\\n        int256[12] rightFrag;\\n        int256 dx;\\n        int256 ir;\\n        int256 newFragRow;\\n        int256 newFragCol;\\n    }\\n\\n    /** @dev initialise the fragments\\n        fragments are defined as:\\n        [\\n            canvas_x, canvas_y, depth,\\n            col_x, col_y, col_z,\\n            normal_x, normal_y, normal_z,\\n            world_x, world_y, world_z\\n        ]\\n        \\n     */\\n    function initialiseFragments(\\n        int256[3][3][] memory trisCameraSpace,\\n        int256[3][3][] memory trisWorldSpace,\\n        int256[3][3][] memory trisCols,\\n        int256 canvasDim\\n    ) external view returns (int256[12][3][] memory) {\\n        /// make an array containing the fragments of each triangle (groups of 3 frags)\\n        int256[12][3][] memory trisFragments = new int256[12][3][](\\n            trisCameraSpace.length\\n        );\\n\\n        // First convert from camera space to screen space within each triangle\\n        for (uint256 t = 0; t < trisCameraSpace.length; t++) {\\n            int256[3][3] memory tri = trisCameraSpace[t];\\n\\n            /// initialise an array for three fragments, each of len 9\\n            int256[12][3] memory triFragments;\\n\\n            // First calculate the fragments that belong to defined vertices\\n            for (uint256 v = 0; v < 3; v++) {\\n                int256[12] memory fragment;\\n\\n                // first convert to screen space\\n                // mapping from -1e3 -> 1e3 to account for the original geom being on order of 1e3\\n                fragment[0] = ShackledMath.mapRangeToRange(\\n                    tri[v][0],\\n                    -1e3,\\n                    1e3,\\n                    0,\\n                    canvasDim\\n                );\\n                fragment[1] = ShackledMath.mapRangeToRange(\\n                    tri[v][1],\\n                    -1e3,\\n                    1e3,\\n                    0,\\n                    canvasDim\\n                );\\n\\n                fragment[2] = tri[v][2];\\n\\n                // Now calculate the normal using the cross product of the edge vectors. This needs to be\\n                // done in world space coordinates\\n                int256[3] memory thisV = trisWorldSpace[t][(v + 0) % 3];\\n                int256[3] memory nextV = trisWorldSpace[t][(v + 1) % 3];\\n                int256[3] memory prevV = trisWorldSpace[t][(v + 2) % 3];\\n\\n                int256[3] memory norm = ShackledMath.crossProduct(\\n                    ShackledMath.vector3Sub(prevV, thisV),\\n                    ShackledMath.vector3Sub(thisV, nextV)\\n                );\\n\\n                // Now attach the colour (in 0 -> 255 space)\\n                fragment[3] = (trisCols[t][v][0]);\\n                fragment[4] = (trisCols[t][v][1]);\\n                fragment[5] = (trisCols[t][v][2]);\\n\\n                // And the normal (inverted)\\n                fragment[6] = -norm[0];\\n                fragment[7] = -norm[1];\\n                fragment[8] = -norm[2];\\n\\n                // And the world position of this vertex to the frag\\n                fragment[9] = thisV[0];\\n                fragment[10] = thisV[1];\\n                fragment[11] = thisV[2];\\n\\n                // These are just the fragments attached to\\n                // the given vertices\\n                triFragments[v] = fragment;\\n            }\\n\\n            trisFragments[t] = triFragments;\\n        }\\n\\n        return trisFragments;\\n    }\\n\\n    /** @dev rasterize fragments onto a canvas\\n     */\\n    function rasterise(\\n        int256[12][3][] memory trisFragments,\\n        int256 canvasDim,\\n        bool wireframe\\n    ) external view returns (int256[12][] memory) {\\n        /// determine the upper limits of the inner Bresenham's result\\n        uint256 canvasHypot = uint256(ShackledMath.hypot(canvasDim, canvasDim));\\n\\n        /// initialise a new array\\n        /// for each trisFragments we will get 3 results from bresenhams\\n        /// maximum of 1 per pixel (canvasDim**2)\\n        int256[12][] memory fragments = new int256[12][](\\n            3 * uint256(canvasDim)**2\\n        );\\n        uint256 nextFragmentsIx = 0;\\n\\n        for (uint256 t = 0; t < trisFragments.length; t++) {\\n            // prepare the variables required\\n            int256[12] memory fa;\\n            int256[12] memory fb;\\n            uint256 nextBresTriFragmentIx = 0;\\n\\n            /// create an array to hold the bresenham results\\n            /// this may cause an out of bounds error if there are a very large number of fragments\\n            /// (e.g. many that are 'off screen')\\n            int256[12][] memory bresTriFragments = new int256[12][](\\n                canvasHypot * 10\\n            );\\n\\n            // for each pair of fragments, run bresenhams and extend bresTriFragments with the output\\n            // this replaces the three push(...modified_bresenhams_algorhtm) statements in JS\\n            for (uint256 i = 0; i < 3; i++) {\\n                if (i == 0) {\\n                    fa = trisFragments[t][0];\\n                    fb = trisFragments[t][1];\\n                } else if (i == 1) {\\n                    fa = trisFragments[t][1];\\n                    fb = trisFragments[t][2];\\n                } else {\\n                    fa = trisFragments[t][2];\\n                    fb = trisFragments[t][0];\\n                }\\n\\n                // run the bresenhams algorithm\\n                (\\n                    bresTriFragments,\\n                    nextBresTriFragmentIx\\n                ) = runBresenhamsAlgorithm(\\n                    fa,\\n                    fb,\\n                    canvasDim,\\n                    bresTriFragments,\\n                    nextBresTriFragmentIx\\n                );\\n            }\\n\\n            bresTriFragments = ShackledUtils.clipArray12ToLength(\\n                bresTriFragments,\\n                nextBresTriFragmentIx\\n            );\\n\\n            if (wireframe) {\\n                /// only store the edges\\n                for (uint256 j = 0; j < bresTriFragments.length; j++) {\\n                    fragments[nextFragmentsIx] = bresTriFragments[j];\\n                    nextFragmentsIx++;\\n                }\\n            } else {\\n                /// fill the triangle\\n                (fragments, nextFragmentsIx) = runScanline(\\n                    bresTriFragments,\\n                    fragments,\\n                    nextFragmentsIx,\\n                    canvasDim\\n                );\\n            }\\n        }\\n\\n        fragments = ShackledUtils.clipArray12ToLength(\\n            fragments,\\n            nextFragmentsIx\\n        );\\n\\n        return fragments;\\n    }\\n\\n    /** @dev run Bresenham's line algorithm on a pair of fragments\\n     */\\n    function runBresenhamsAlgorithm(\\n        int256[12] memory f1,\\n        int256[12] memory f2,\\n        int256 canvasDim,\\n        int256[12][] memory bresTriFragments,\\n        uint256 nextBresTriFragmentIx\\n    ) internal view returns (int256[12][] memory, uint256) {\\n        /// initiate a new set of vars\\n        BresenhamsVars memory vars;\\n\\n        int256[12] memory fa;\\n        int256[12] memory fb;\\n\\n        /// determine which fragment has a greater magnitude\\n        /// and set it as the destination (always order a given pair of edges the same)\\n        if (\\n            (f1[0]**2 + f1[1]**2 + f1[2]**2) < (f2[0]**2 + f2[1]**2 + f2[2]**2)\\n        ) {\\n            fa = f1;\\n            fb = f2;\\n        } else {\\n            fa = f2;\\n            fb = f1;\\n        }\\n\\n        vars.x = fa[0];\\n        vars.y = fa[1];\\n\\n        vars.dx = ShackledMath.abs(fb[0] - fa[0]);\\n        vars.dy = -ShackledMath.abs(fb[1] - fa[1]);\\n        int256 mag = ShackledMath.hypot(vars.dx, -vars.dy);\\n\\n        if (fa[0] < fb[0]) {\\n            vars.sx = 1;\\n        } else {\\n            vars.sx = -1;\\n        }\\n\\n        if (fa[1] < fb[1]) {\\n            vars.sy = 1;\\n        } else {\\n            vars.sy = -1;\\n        }\\n\\n        vars.err = vars.dx + vars.dy;\\n        vars.e2 = 0;\\n\\n        // get the bresenhams output for this fragment pair (fa & fb)\\n\\n        if (mag == 0) {\\n            bresTriFragments[nextBresTriFragmentIx] = fa;\\n            bresTriFragments[nextBresTriFragmentIx + 1] = fb;\\n            nextBresTriFragmentIx += 2;\\n        } else {\\n            // when mag is not 0,\\n            // the length of the result will be max of upperLimitInner\\n            // but will be clipped to remove any empty slots\\n            (bresTriFragments, nextBresTriFragmentIx) = bresenhamsInner(\\n                vars,\\n                mag,\\n                fa,\\n                fb,\\n                canvasDim,\\n                bresTriFragments,\\n                nextBresTriFragmentIx\\n            );\\n        }\\n        return (bresTriFragments, nextBresTriFragmentIx);\\n    }\\n\\n    /** @dev run the inner loop of Bresenham's line algorithm on a pair of fragments\\n     * (preventing stack too deep)\\n     */\\n    function bresenhamsInner(\\n        BresenhamsVars memory vars,\\n        int256 mag,\\n        int256[12] memory fa,\\n        int256[12] memory fb,\\n        int256 canvasDim,\\n        int256[12][] memory bresTriFragments,\\n        uint256 nextBresTriFragmentIx\\n    ) internal view returns (int256[12][] memory, uint256) {\\n        // define variables to be used in the inner loop\\n        int256 ir;\\n        int256 h;\\n\\n        /// loop through all fragments\\n        while (!(vars.x == fb[0] && vars.y == fb[1])) {\\n            /// get hypotenuse length of fragment a\\n            h = ShackledMath.hypot(fa[0] - vars.x, fa[1] - vars.y);\\n            assembly {\\n                ir := div(mul(lerpScaleFactor, h), mag)\\n            }\\n\\n            // only add the fragment if it falls within the canvas\\n\\n            /// create a new fragment by linear interpolation between a and b\\n            int256[12] memory newFragment = ShackledMath.vector12Lerp(\\n                fa,\\n                fb,\\n                ir,\\n                lerpScaleFactor\\n            );\\n            newFragment[0] = vars.x;\\n            newFragment[1] = vars.y;\\n\\n            /// save this fragment\\n            bresTriFragments[nextBresTriFragmentIx] = newFragment;\\n            ++nextBresTriFragmentIx;\\n\\n            /// update variables to use in next iteration\\n            vars.e2 = 2 * vars.err;\\n            if (vars.e2 >= vars.dy) {\\n                vars.err += vars.dy;\\n                vars.x += vars.sx;\\n            }\\n            if (vars.e2 <= vars.dx) {\\n                vars.err += vars.dx;\\n                vars.y += vars.sy;\\n            }\\n        }\\n\\n        /// save fragment 2\\n        bresTriFragments[nextBresTriFragmentIx] = fb;\\n        ++nextBresTriFragmentIx;\\n\\n        return (bresTriFragments, nextBresTriFragmentIx);\\n    }\\n\\n    /** @dev run the scan line algorithm to fill the raster\\n     */\\n    function runScanline(\\n        int256[12][] memory bresTriFragments,\\n        int256[12][] memory fragments,\\n        uint256 nextFragmentsIx,\\n        int256 canvasDim\\n    ) internal view returns (int256[12][] memory, uint256) {\\n        /// make a 2d array with length = num of output rows\\n\\n        (\\n            int256[][] memory rowFragIndices,\\n            uint256[] memory nextIxFragRows\\n        ) = getRowFragIndices(bresTriFragments, canvasDim);\\n\\n        /// initialise a struct to hold the scanline vars\\n        ScanlineVars memory slVars;\\n\\n        // Now iterate through the list of fragments that live in a single row\\n        for (uint256 i = 0; i < rowFragIndices.length; i++) {\\n            /// Get the left most fragment\\n            slVars.left = 4096;\\n\\n            /// Get the right most fragment\\n            slVars.right = -4096;\\n\\n            /// loop through the fragments in this row\\n            /// and check that a fragment was written to this row\\n            for (uint256 j = 0; j < nextIxFragRows[i]; j++) {\\n                /// What's the current fragment that we're looking at\\n                int256 fragX = bresTriFragments[uint256(rowFragIndices[i][j])][\\n                    0\\n                ];\\n\\n                // if it's lefter than our current most left frag then its the new left frag\\n                if (fragX < slVars.left) {\\n                    slVars.left = fragX;\\n                    slVars.leftFrag = bresTriFragments[\\n                        uint256(rowFragIndices[i][j])\\n                    ];\\n                }\\n                // if it's righter than our current most right frag then its the new right frag\\n                if (fragX > slVars.right) {\\n                    slVars.right = fragX;\\n                    slVars.rightFrag = bresTriFragments[\\n                        uint256(rowFragIndices[i][j])\\n                    ];\\n                }\\n            }\\n\\n            /// now we need to scan from the left to the right fragment\\n            /// and interpolate as we go\\n            slVars.dx = slVars.right - slVars.left + 1;\\n\\n            /// get the row that we're on\\n            slVars.newFragRow = slVars.leftFrag[1];\\n\\n            /// check that the new frag's row will be in the canvas bounds\\n            if (slVars.newFragRow >= 0 && slVars.newFragRow < canvasDim) {\\n                if (slVars.dx > int256(0)) {\\n                    for (int256 j = 0; j < slVars.dx; j++) {\\n                        /// calculate the column of the new fragment (its position in the scan)\\n                        slVars.newFragCol = slVars.leftFrag[0] + j;\\n\\n                        /// check that the new frag's column will be in the canvas bounds\\n                        if (\\n                            slVars.newFragCol >= 0 &&\\n                            slVars.newFragCol < canvasDim\\n                        ) {\\n                            slVars.ir = (j * lerpScaleFactor) / slVars.dx;\\n\\n                            /// make a new fragment by linear interpolation between left and right frags\\n                            fragments[nextFragmentsIx] = ShackledMath\\n                                .vector12Lerp(\\n                                    slVars.leftFrag,\\n                                    slVars.rightFrag,\\n                                    slVars.ir,\\n                                    lerpScaleFactor\\n                                );\\n                            /// update its position\\n                            fragments[nextFragmentsIx][0] = slVars.newFragCol;\\n                            fragments[nextFragmentsIx][1] = slVars.newFragRow;\\n                            nextFragmentsIx++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (fragments, nextFragmentsIx);\\n    }\\n\\n    /** @dev get the row indices of each fragment in preparation for the scanline alg\\n     */\\n    function getRowFragIndices(\\n        int256[12][] memory bresTriFragments,\\n        int256 canvasDim\\n    )\\n        internal\\n        view\\n        returns (int256[][] memory, uint256[] memory nextIxFragRows)\\n    {\\n        uint256 canvasDimUnsigned = uint256(canvasDim);\\n\\n        // define the length of each outer array so we can push items into it using nextIxFragRows\\n        int256[][] memory rowFragIndices = new int256[][](canvasDimUnsigned);\\n\\n        // the inner rows can't be longer than bresTriFragments\\n        for (uint256 i = 0; i < canvasDimUnsigned; i++) {\\n            rowFragIndices[i] = new int256[](bresTriFragments.length);\\n        }\\n\\n        // make an array the tracks for each row how many items have been pushed into it\\n        uint256[] memory nextIxFragRows = new uint256[](canvasDimUnsigned);\\n\\n        for (uint256 f = 0; f < bresTriFragments.length; f++) {\\n            // get the row index\\n            uint256 rowIx = uint256(bresTriFragments[f][1]); // canvas_y\\n\\n            if (rowIx >= 0 && rowIx < canvasDimUnsigned) {\\n                // get the ix of the next item to be added to the row\\n\\n                rowFragIndices[rowIx][nextIxFragRows[rowIx]] = int256(f);\\n                ++nextIxFragRows[rowIx];\\n            }\\n        }\\n        return (rowFragIndices, nextIxFragRows);\\n    }\\n\\n    /** @dev run depth-testing on all fragments\\n     */\\n    function depthTesting(int256[12][] memory fragments, int256 canvasDim)\\n        external\\n        view\\n        returns (int256[12][] memory)\\n    {\\n        uint256 canvasDimUnsigned = uint256(canvasDim);\\n        /// create a 2d array to hold the zValues of the fragments\\n        int256[][] memory zValues = ShackledMath.get2dArray(\\n            canvasDimUnsigned,\\n            canvasDimUnsigned,\\n            0\\n        );\\n\\n        /// create a 2d array to hold the fragIndex of the fragments\\n        /// as their depth is compared\\n        int256[][] memory fragIndex = ShackledMath.get2dArray(\\n            canvasDimUnsigned,\\n            canvasDimUnsigned,\\n            -1 /// -1 so we can check if a fragment was written to this location\\n        );\\n\\n        int256[12][] memory culledFrags = new int256[12][](fragments.length);\\n        uint256 nextFragIx = 0;\\n\\n        /// iterate through all fragments\\n        /// and store the index of the fragment with the largest z value\\n        /// at each x, y coordinate\\n\\n        for (uint256 i = 0; i < fragments.length; i++) {\\n            int256[12] memory frag = fragments[i];\\n\\n            /// x and y must be uint for indexing\\n            uint256 fragX = uint256(frag[0]);\\n            uint256 fragY = uint256(frag[1]);\\n\\n            // console.log(\\\"checking frag\\\", i, \\\"z:\\\");\\n            // console.logInt(frag[2]);\\n\\n            if (\\n                (fragX < canvasDimUnsigned) &&\\n                (fragY < canvasDimUnsigned) &&\\n                fragX >= 0 &&\\n                fragY >= 0\\n            ) {\\n                // if this is the first fragment seen at (fragX, fragY), ie if fragIndex == 0, add it\\n                // or if this frag is closer (lower z value) than the current frag at (fragX, fragY), add it\\n                if (\\n                    fragIndex[fragX][fragY] == -1 ||\\n                    frag[2] >= zValues[fragX][fragY]\\n                ) {\\n                    zValues[fragX][fragY] = frag[2];\\n                    fragIndex[fragX][fragY] = int256(i);\\n                }\\n            }\\n        }\\n\\n        /// save only the fragments with prefered z values\\n        for (uint256 x = 0; x < canvasDimUnsigned; x++) {\\n            for (uint256 y = 0; y < canvasDimUnsigned; y++) {\\n                int256 fragIx = fragIndex[x][y];\\n                /// ensure we have a valid index\\n                if (fragIndex[x][y] != -1) {\\n                    culledFrags[nextFragIx] = fragments[uint256(fragIx)];\\n                    nextFragIx++;\\n                }\\n            }\\n        }\\n\\n        return ShackledUtils.clipArray12ToLength(culledFrags, nextFragIx);\\n    }\\n\\n    /** @dev apply lighting to the scene and update fragments accordingly\\n     */\\n    function lightScene(\\n        int256[12][] memory fragments,\\n        ShackledStructs.LightingParams memory lp\\n    ) external view returns (int256[12][] memory) {\\n        /// create a struct for the variables to prevent stack too deep\\n        LightingVars memory lv;\\n\\n        // calculate a constant lighting vector and its magniture\\n        lv.L = lp.lightPos;\\n        lv.lMag = ShackledMath.vector3Len(lv.L);\\n\\n        for (uint256 f = 0; f < fragments.length; f++) {\\n            /// get the fragment's color, norm and position\\n            lv.fragCol = [fragments[f][3], fragments[f][4], fragments[f][5]];\\n            lv.fragNorm = [fragments[f][6], fragments[f][7], fragments[f][8]];\\n            lv.fragPos = [fragments[f][9], fragments[f][10], fragments[f][11]];\\n\\n            /// calculate the direction to camera / viewer and its magnitude\\n            lv.V = ShackledMath.vector3MulScalar(lv.fragPos, -1);\\n            lv.vMag = ShackledMath.vector3Len(lv.V);\\n\\n            /// calculate the direction of the fragment normaland its magnitude\\n            lv.N = lv.fragNorm;\\n            lv.nMag = ShackledMath.vector3Len(lv.N);\\n\\n            /// calculate the light vector per-fragment\\n            // lv.L = ShackledMath.vector3Sub(lp.lightPos, lv.fragPos);\\n            // lv.lMag = ShackledMath.vector3Len(lv.L);\\n            lv.falloff = lv.lMag**2; /// lighting intensity fall over the scene\\n            lv.lnDot = ShackledMath.vector3Dot(lv.L, lv.N);\\n\\n            /// implement double-side rendering to account for flipped normals\\n            lv.lambertian = ShackledMath.abs(lv.lnDot);\\n\\n            int256 specular;\\n\\n            if (lv.lambertian > 0) {\\n                int256[3] memory normedL = ShackledMath.vector3NormX(\\n                    lv.L,\\n                    fidelity\\n                );\\n                int256[3] memory normedV = ShackledMath.vector3NormX(\\n                    lv.V,\\n                    fidelity\\n                );\\n\\n                int256[3] memory H = ShackledMath.vector3Add(normedL, normedV);\\n\\n                int256 hnDot = int256(\\n                    ShackledMath.vector3Dot(\\n                        ShackledMath.vector3NormX(H, fidelity),\\n                        ShackledMath.vector3NormX(lv.N, fidelity)\\n                    )\\n                );\\n\\n                specular = calculateSpecular(\\n                    lp.lightSpecPower,\\n                    hnDot,\\n                    fidelity,\\n                    lp.inverseShininess\\n                );\\n            }\\n\\n            // Calculate the colour and write it into the fragment\\n            int256[3] memory colAmbi = ShackledMath.vector3Add(\\n                lv.fragCol,\\n                ShackledMath.vector3MulScalar(\\n                    lp.lightColAmbi,\\n                    lp.lightAmbiPower\\n                )\\n            );\\n\\n            /// finalise and color the diffuse lighting\\n            int256[3] memory colDiff = ShackledMath.vector3MulScalar(\\n                lp.lightColDiff,\\n                ((lp.lightDiffPower * lv.lambertian) / (lv.lMag * lv.nMag)) /\\n                    lv.falloff\\n            );\\n\\n            /// finalise and color the specular lighting\\n            int256[3] memory colSpec = ShackledMath.vector3DivScalar(\\n                ShackledMath.vector3MulScalar(lp.lightColSpec, specular),\\n                lv.falloff\\n            );\\n\\n            // add up the colour components\\n            int256[3] memory col = ShackledMath.vector3Add(\\n                ShackledMath.vector3Add(colAmbi, colDiff),\\n                colSpec\\n            );\\n\\n            /// update the fragment's colour in place\\n            fragments[f][3] = col[0];\\n            fragments[f][4] = col[1];\\n            fragments[f][5] = col[2];\\n        }\\n        return fragments;\\n    }\\n\\n    /** @dev calculate the specular lighting parameter */\\n    function calculateSpecular(\\n        int256 lightSpecPower,\\n        int256 hnDot,\\n        int256 fidelity,\\n        uint256 inverseShininess\\n    ) internal pure returns (int256 specular) {\\n        int256 specAngle = hnDot > int256(0) ? hnDot : int256(0);\\n        assembly {\\n            specular := sdiv(\\n                mul(lightSpecPower, exp(specAngle, inverseShininess)),\\n                exp(fidelity, mul(inverseShininess, 2))\\n            )\\n        }\\n    }\\n\\n    /** @dev get background gradient that fills the canvas */\\n    function getBackground(\\n        int256 canvasDim,\\n        int256[3][2] memory backgroundColor\\n    ) external view returns (int256[5][] memory) {\\n        int256[5][] memory background = new int256[5][](uint256(canvasDim**2));\\n\\n        int256 w = canvasDim;\\n        uint256 nextIx = 0;\\n\\n        for (int256 i = 0; i < canvasDim; i++) {\\n            for (int256 j = 0; j < canvasDim; j++) {\\n                // / write coordinates of background pixel\\n                background[nextIx][0] = j; /// x\\n                background[nextIx][1] = i; /// y\\n\\n                // / write colours of background pixel\\n                // / get weighted average of top and bottom color according to row (i)\\n                background[nextIx][2] = /// r\\n                    ((backgroundColor[0][0] * i) +\\n                        (backgroundColor[1][0] * (w - i))) /\\n                    w;\\n\\n                background[nextIx][3] = /// g\\n                    ((backgroundColor[0][1] * i) +\\n                        (backgroundColor[1][1] * (w - i))) /\\n                    w;\\n\\n                background[nextIx][4] = /// b\\n                    ((backgroundColor[0][2] * i) +\\n                        (backgroundColor[1][2] * (w - i))) /\\n                    w;\\n\\n                ++nextIx;\\n            }\\n        }\\n        return background;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ShackledUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ShackledStructs.sol\\\";\\n\\nlibrary ShackledUtils {\\n    string internal constant TABLE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /** @dev Flatten 3d tris array into 2d verts */\\n    function flattenTris(int256[3][3][] memory tris)\\n        internal\\n        pure\\n        returns (int256[3][] memory)\\n    {\\n        /// initialize a dynamic in-memory array\\n        int256[3][] memory flattened = new int256[3][](3 * tris.length);\\n\\n        for (uint256 i = 0; i < tris.length; i++) {\\n            /// tris.length == N\\n            // add values to specific index, as cannot push to array in memory\\n            flattened[(i * 3) + 0] = tris[i][0];\\n            flattened[(i * 3) + 1] = tris[i][1];\\n            flattened[(i * 3) + 2] = tris[i][2];\\n        }\\n        return flattened;\\n    }\\n\\n    /** @dev Unflatten 2d verts array into 3d tries (inverse of flattenTris function) */\\n    function unflattenVertsToTris(int256[3][] memory verts)\\n        internal\\n        pure\\n        returns (int256[3][3][] memory)\\n    {\\n        /// initialize an array with length = 1/3 length of verts\\n        int256[3][3][] memory tris = new int256[3][3][](verts.length / 3);\\n\\n        for (uint256 i = 0; i < verts.length; i += 3) {\\n            tris[i / 3] = [verts[i], verts[i + 1], verts[i + 2]];\\n        }\\n        return tris;\\n    }\\n\\n    /** @dev clip an array to a certain length (to trim empty tail slots) */\\n    function clipArray12ToLength(int256[12][] memory arr, uint256 desiredLen)\\n        internal\\n        pure\\n        returns (int256[12][] memory)\\n    {\\n        uint256 nToCull = arr.length - desiredLen;\\n        assembly {\\n            mstore(arr, sub(mload(arr), nToCull))\\n        }\\n        return arr;\\n    }\\n\\n    /** @dev convert an unsigned int to a string */\\n    function uint2str(uint256 _i)\\n        internal\\n        pure\\n        returns (string memory _uintAsString)\\n    {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len;\\n        while (_i != 0) {\\n            k = k - 1;\\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    /** @dev get the hex encoding of various powers of 2 (canvas size options) */\\n    function getHex(uint256 _i) internal pure returns (bytes memory _hex) {\\n        if (_i == 8) {\\n            return hex\\\"08_00_00_00\\\";\\n        } else if (_i == 16) {\\n            return hex\\\"10_00_00_00\\\";\\n        } else if (_i == 32) {\\n            return hex\\\"20_00_00_00\\\";\\n        } else if (_i == 64) {\\n            return hex\\\"40_00_00_00\\\";\\n        } else if (_i == 128) {\\n            return hex\\\"80_00_00_00\\\";\\n        } else if (_i == 256) {\\n            return hex\\\"00_01_00_00\\\";\\n        } else if (_i == 512) {\\n            return hex\\\"00_02_00_00\\\";\\n        }\\n    }\\n\\n    /** @dev create an svg container for a bitmap (for display on svg-only platforms) */\\n    function getSVGContainer(\\n        string memory encodedBitmap,\\n        int256 canvasDim,\\n        uint256 outputHeight,\\n        uint256 outputWidth\\n    ) internal view returns (string memory) {\\n        uint256 canvasDimUnsigned = uint256(canvasDim);\\n        // construct some elements in memory prior to return string to avoid stack too deep\\n        bytes memory imgSize = abi.encodePacked(\\n            \\\"width='\\\",\\n            ShackledUtils.uint2str(canvasDimUnsigned),\\n            \\\"' height='\\\",\\n            ShackledUtils.uint2str(canvasDimUnsigned),\\n            \\\"'\\\"\\n        );\\n        bytes memory canvasSize = abi.encodePacked(\\n            \\\"width='\\\",\\n            ShackledUtils.uint2str(outputWidth),\\n            \\\"' height='\\\",\\n            ShackledUtils.uint2str(outputHeight),\\n            \\\"'\\\"\\n        );\\n        bytes memory scaleStartTag = abi.encodePacked(\\n            \\\"<g transform='scale(\\\",\\n            ShackledUtils.uint2str(outputWidth / canvasDimUnsigned),\\n            \\\")'>\\\"\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:image/svg+xml;base64,\\\",\\n                    Base64.encode(\\n                        abi.encodePacked(\\n                            \\\"<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' \\\",\\n                            \\\"shape-rendering='crispEdges' \\\",\\n                            canvasSize,\\n                            \\\">\\\",\\n                            scaleStartTag,\\n                            \\\"<image \\\",\\n                            imgSize,\\n                            \\\" style='image-rendering: pixelated; image-rendering: crisp-edges;' \\\",\\n                            \\\"href='\\\",\\n                            encodedBitmap,\\n                            \\\"'/></g></svg>\\\"\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    /** @dev converts raw metadata into */\\n    function getAttributes(ShackledStructs.Metadata memory metadata)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encodePacked(\\n                \\\"{\\\",\\n                '\\\"Structure\\\": \\\"',\\n                metadata.geomSpec,\\n                '\\\", \\\"Chroma\\\": \\\"',\\n                metadata.colorScheme,\\n                '\\\", \\\"Pseudosymmetry\\\": \\\"',\\n                metadata.pseudoSymmetry,\\n                '\\\", \\\"Wireframe\\\": \\\"',\\n                metadata.wireframe,\\n                '\\\", \\\"Inversion\\\": \\\"',\\n                metadata.inversion,\\n                '\\\", \\\"Prisms\\\": \\\"',\\n                uint2str(metadata.nPrisms),\\n                '\\\"}'\\n            );\\n    }\\n\\n    /** @dev create and encode the token's metadata */\\n    function getEncodedMetadata(\\n        string memory image,\\n        ShackledStructs.Metadata memory metadata,\\n        uint256 tokenId\\n    ) internal view returns (string memory) {\\n        /// get attributes and description here to avoid stack too deep\\n        string\\n            memory description = '\\\"description\\\": \\\"Shackled is the first general-purpose 3D renderer'\\n            \\\" running on the Ethereum blockchain.\\\"\\n            ' Each piece represents a leap forward in on-chain computer graphics, and the collection itself is an NFT first.\\\"';\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:application/json;base64,\\\",\\n                    Base64.encode(\\n                        bytes(\\n                            string(\\n                                abi.encodePacked(\\n                                    '{\\\"name\\\": \\\"Shackled Genesis #',\\n                                    uint2str(tokenId),\\n                                    '\\\", ',\\n                                    description,\\n                                    ', \\\"attributes\\\":',\\n                                    getAttributes(metadata),\\n                                    ', \\\"image\\\":\\\"',\\n                                    image,\\n                                    '\\\"}'\\n                                )\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    // fragment =\\n    // [ canvas_x, canvas_y, depth, col_x, col_y, col_z, normal_x, normal_y, normal_z, world_x, world_y, world_z ],\\n    /** @dev get an encoded 2d bitmap by combining the object and background fragments */\\n    function getEncodedBitmap(\\n        int256[12][] memory fragments,\\n        int256[5][] memory background,\\n        int256 canvasDim,\\n        bool invert\\n    ) internal view returns (string memory) {\\n        uint256 canvasDimUnsigned = uint256(canvasDim);\\n        bytes memory fileHeader = abi.encodePacked(\\n            hex\\\"42_4d\\\", // BM\\n            hex\\\"36_04_00_00\\\", // size of the bitmap file in bytes (14 (file header) + 40 (info header) + size of raw data (1024))\\n            hex\\\"00_00_00_00\\\", // 2x2 bytes reserved\\n            hex\\\"36_00_00_00\\\" // offset of pixels in bytes\\n        );\\n        bytes memory infoHeader = abi.encodePacked(\\n            hex\\\"28_00_00_00\\\", // size of the header in bytes (40)\\n            getHex(canvasDimUnsigned), // width in pixels 32\\n            getHex(canvasDimUnsigned), // height in pixels 32\\n            hex\\\"01_00\\\", // number of color plans (must be 1)\\n            hex\\\"18_00\\\", // number of bits per pixel (24)\\n            hex\\\"00_00_00_00\\\", // type of compression (none)\\n            hex\\\"00_04_00_00\\\", // size of the raw bitmap data (1024)\\n            hex\\\"C4_0E_00_00\\\", // horizontal resolution\\n            hex\\\"C4_0E_00_00\\\", // vertical resolution\\n            hex\\\"00_00_00_00\\\", // number of used colours\\n            hex\\\"05_00_00_00\\\" // number of important colours\\n        );\\n        bytes memory headers = abi.encodePacked(fileHeader, infoHeader);\\n\\n        /// create a container for the bitmap's bytes\\n        bytes memory bytesArray = new bytes(3 * canvasDimUnsigned**2);\\n\\n        /// write the background first so it is behind the fragments\\n        bytesArray = writeBackgroundToBytesArray(\\n            background,\\n            bytesArray,\\n            canvasDimUnsigned,\\n            invert\\n        );\\n        bytesArray = writeFragmentsToBytesArray(\\n            fragments,\\n            bytesArray,\\n            canvasDimUnsigned,\\n            invert\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:image/bmp;base64,\\\",\\n                    Base64.encode(BytesUtils.MergeBytes(headers, bytesArray))\\n                )\\n            );\\n    }\\n\\n    /** @dev write the fragments to the bytes array */\\n    function writeFragmentsToBytesArray(\\n        int256[12][] memory fragments,\\n        bytes memory bytesArray,\\n        uint256 canvasDimUnsigned,\\n        bool invert\\n    ) internal pure returns (bytes memory) {\\n        /// loop through each fragment\\n        /// and write it's color into bytesArray in its canvas equivelant position\\n        for (uint256 i = 0; i < fragments.length; i++) {\\n            /// check if x and y are both greater than 0\\n            if (\\n                uint256(fragments[i][0]) >= 0 && uint256(fragments[i][1]) >= 0\\n            ) {\\n                /// calculating the starting bytesArray ix for this fragment's colors\\n                uint256 flatIx = ((canvasDimUnsigned -\\n                    uint256(fragments[i][1]) -\\n                    1) *\\n                    canvasDimUnsigned +\\n                    (canvasDimUnsigned - uint256(fragments[i][0]) - 1)) * 3;\\n\\n                /// red\\n                uint256 r = fragments[i][3] > 255\\n                    ? 255\\n                    : uint256(fragments[i][3]);\\n\\n                /// green\\n                uint256 g = fragments[i][4] > 255\\n                    ? 255\\n                    : uint256(fragments[i][4]);\\n\\n                /// blue\\n                uint256 b = fragments[i][5] > 255\\n                    ? 255\\n                    : uint256(fragments[i][5]);\\n\\n                if (invert) {\\n                    r = 255 - r;\\n                    g = 255 - g;\\n                    b = 255 - b;\\n                }\\n\\n                bytesArray[flatIx + 0] = bytes1(uint8(b));\\n                bytesArray[flatIx + 1] = bytes1(uint8(g));\\n                bytesArray[flatIx + 2] = bytes1(uint8(r));\\n            }\\n        }\\n        return bytesArray;\\n    }\\n\\n    /** @dev write the fragments to the bytes array \\n    using a separate function from above to account for variable input size\\n    */\\n    function writeBackgroundToBytesArray(\\n        int256[5][] memory background,\\n        bytes memory bytesArray,\\n        uint256 canvasDimUnsigned,\\n        bool invert\\n    ) internal pure returns (bytes memory) {\\n        /// loop through each fragment\\n        /// and write it's color into bytesArray in its canvas equivelant position\\n        for (uint256 i = 0; i < background.length; i++) {\\n            /// check if x and y are both greater than 0\\n            if (\\n                uint256(background[i][0]) >= 0 && uint256(background[i][1]) >= 0\\n            ) {\\n                /// calculating the starting bytesArray ix for this fragment's colors\\n                uint256 flatIx = (uint256(background[i][1]) *\\n                    canvasDimUnsigned +\\n                    uint256(background[i][0])) * 3;\\n\\n                // red\\n                uint256 r = background[i][2] > 255\\n                    ? 255\\n                    : uint256(background[i][2]);\\n\\n                /// green\\n                uint256 g = background[i][3] > 255\\n                    ? 255\\n                    : uint256(background[i][3]);\\n\\n                // blue\\n                uint256 b = background[i][4] > 255\\n                    ? 255\\n                    : uint256(background[i][4]);\\n\\n                if (invert) {\\n                    r = 255 - r;\\n                    g = 255 - g;\\n                    b = 255 - b;\\n                }\\n\\n                bytesArray[flatIx + 0] = bytes1(uint8(b));\\n                bytesArray[flatIx + 1] = bytes1(uint8(g));\\n                bytesArray[flatIx + 2] = bytes1(uint8(r));\\n            }\\n        }\\n        return bytesArray;\\n    }\\n}\\n\\n/// [MIT License]\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\nlibrary Base64 {\\n    bytes internal constant TABLE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal view returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF)\\n                )\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF)\\n                )\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(input, 0x3F))), 0xFF)\\n                )\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\\nlibrary BytesUtils {\\n    function char(bytes1 b) internal view returns (bytes1 c) {\\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n        else return bytes1(uint8(b) + 0x57);\\n    }\\n\\n    function bytes32string(bytes32 b32)\\n        internal\\n        view\\n        returns (string memory out)\\n    {\\n        bytes memory s = new bytes(64);\\n        for (uint32 i = 0; i < 32; i++) {\\n            bytes1 b = bytes1(b32[i]);\\n            bytes1 hi = bytes1(uint8(b) / 16);\\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n            s[i * 2] = char(hi);\\n            s[i * 2 + 1] = char(lo);\\n        }\\n        out = string(s);\\n    }\\n\\n    function hach(string memory value) internal view returns (string memory) {\\n        return bytes32string(sha256(abi.encodePacked(value)));\\n    }\\n\\n    function MergeBytes(bytes memory a, bytes memory b)\\n        internal\\n        pure\\n        returns (bytes memory c)\\n    {\\n        // Store the length of the first array\\n        uint256 alen = a.length;\\n        // Store the length of BOTH arrays\\n        uint256 totallen = alen + b.length;\\n        // Count the loops required for array a (sets of 32 bytes)\\n        uint256 loopsa = (a.length + 31) / 32;\\n        // Count the loops required for array b (sets of 32 bytes)\\n        uint256 loopsb = (b.length + 31) / 32;\\n        assembly {\\n            let m := mload(0x40)\\n            // Load the length of both arrays to the head of the new bytes array\\n            mstore(m, totallen)\\n            // Add the contents of a to the array\\n            for {\\n                let i := 0\\n            } lt(i, loopsa) {\\n                i := add(1, i)\\n            } {\\n                mstore(\\n                    add(m, mul(32, add(1, i))),\\n                    mload(add(a, mul(32, add(1, i))))\\n                )\\n            }\\n            // Add the contents of b to the array\\n            for {\\n                let i := 0\\n            } lt(i, loopsb) {\\n                i := add(1, i)\\n            } {\\n                mstore(\\n                    add(m, add(mul(32, add(1, i)), alen)),\\n                    mload(add(b, mul(32, add(1, i))))\\n                )\\n            }\\n            mstore(0x40, add(m, add(32, totallen)))\\n            c := m\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ShackledMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nlibrary ShackledMath {\\n    /** @dev Get the minimum of two numbers */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /** @dev Get the maximum of two numbers */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /** @dev perform a modulo operation, with support for negative numbers */\\n    function mod(int256 n, int256 m) internal pure returns (int256) {\\n        if (n < 0) {\\n            return ((n % m) + m) % m;\\n        } else {\\n            return n % m;\\n        }\\n    }\\n\\n    /** @dev 'randomly' select n numbers between 0 and m \\n    (useful for getting a randomly sampled index)\\n    */\\n    function randomIdx(\\n        bytes32 seedModifier,\\n        uint256 n, // number of elements to select\\n        uint256 m // max value of elements\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory result = new uint256[](n);\\n        for (uint256 i = 0; i < n; i++) {\\n            result[i] =\\n                uint256(keccak256(abi.encodePacked(seedModifier, i))) %\\n                m;\\n        }\\n        return result;\\n    }\\n\\n    /** @dev create a 2d array and fill with a single value */\\n    function get2dArray(\\n        uint256 m,\\n        uint256 q,\\n        int256 value\\n    ) internal pure returns (int256[][] memory) {\\n        /// Create a matrix of values with dimensions (m, q)\\n        int256[][] memory rows = new int256[][](m);\\n        for (uint256 i = 0; i < m; i++) {\\n            int256[] memory row = new int256[](q);\\n            for (uint256 j = 0; j < q; j++) {\\n                row[j] = value;\\n            }\\n            rows[i] = row;\\n        }\\n        return rows;\\n    }\\n\\n    /** @dev get the absolute of a number\\n     */\\n    function abs(int256 x) internal pure returns (int256) {\\n        assembly {\\n            if slt(x, 0) {\\n                x := sub(0, x)\\n            }\\n        }\\n        return x;\\n    }\\n\\n    /** @dev get the square root of a number\\n     */\\n    function sqrt(int256 y) internal pure returns (int256 z) {\\n        assembly {\\n            if sgt(y, 3) {\\n                z := y\\n                let x := add(div(y, 2), 1)\\n                for {\\n\\n                } slt(x, z) {\\n\\n                } {\\n                    z := x\\n                    x := div(add(div(y, x), x), 2)\\n                }\\n            }\\n            if and(slt(y, 4), sgt(y, 0)) {\\n                z := 1\\n            }\\n        }\\n    }\\n\\n    /** @dev get the hypotenuse of a triangle given the length of 2 sides\\n     */\\n    function hypot(int256 x, int256 y) internal pure returns (int256) {\\n        int256 sumsq;\\n        assembly {\\n            let xsq := mul(x, x)\\n            let ysq := mul(y, y)\\n            sumsq := add(xsq, ysq)\\n        }\\n\\n        return sqrt(sumsq);\\n    }\\n\\n    /** @dev addition between two vectors (size 3)\\n     */\\n    function vector3Add(int256[3] memory v1, int256[3] memory v2)\\n        internal\\n        pure\\n        returns (int256[3] memory result)\\n    {\\n        assembly {\\n            mstore(result, add(mload(v1), mload(v2)))\\n            mstore(\\n                add(result, 0x20),\\n                add(mload(add(v1, 0x20)), mload(add(v2, 0x20)))\\n            )\\n            mstore(\\n                add(result, 0x40),\\n                add(mload(add(v1, 0x40)), mload(add(v2, 0x40)))\\n            )\\n        }\\n    }\\n\\n    /** @dev subtraction between two vectors (size 3)\\n     */\\n    function vector3Sub(int256[3] memory v1, int256[3] memory v2)\\n        internal\\n        pure\\n        returns (int256[3] memory result)\\n    {\\n        assembly {\\n            mstore(result, sub(mload(v1), mload(v2)))\\n            mstore(\\n                add(result, 0x20),\\n                sub(mload(add(v1, 0x20)), mload(add(v2, 0x20)))\\n            )\\n            mstore(\\n                add(result, 0x40),\\n                sub(mload(add(v1, 0x40)), mload(add(v2, 0x40)))\\n            )\\n        }\\n    }\\n\\n    /** @dev multiply a vector (size 3) by a constant\\n     */\\n    function vector3MulScalar(int256[3] memory v, int256 a)\\n        internal\\n        pure\\n        returns (int256[3] memory result)\\n    {\\n        assembly {\\n            mstore(result, mul(mload(v), a))\\n            mstore(add(result, 0x20), mul(mload(add(v, 0x20)), a))\\n            mstore(add(result, 0x40), mul(mload(add(v, 0x40)), a))\\n        }\\n    }\\n\\n    /** @dev divide a vector (size 3) by a constant\\n     */\\n    function vector3DivScalar(int256[3] memory v, int256 a)\\n        internal\\n        pure\\n        returns (int256[3] memory result)\\n    {\\n        assembly {\\n            mstore(result, sdiv(mload(v), a))\\n            mstore(add(result, 0x20), sdiv(mload(add(v, 0x20)), a))\\n            mstore(add(result, 0x40), sdiv(mload(add(v, 0x40)), a))\\n        }\\n    }\\n\\n    /** @dev get the length of a vector (size 3)\\n     */\\n    function vector3Len(int256[3] memory v) internal pure returns (int256) {\\n        int256 res;\\n        assembly {\\n            let x := mload(v)\\n            let y := mload(add(v, 0x20))\\n            let z := mload(add(v, 0x40))\\n            res := add(add(mul(x, x), mul(y, y)), mul(z, z))\\n        }\\n        return sqrt(res);\\n    }\\n\\n    /** @dev scale and then normalise a vector (size 3)\\n     */\\n    function vector3NormX(int256[3] memory v, int256 fidelity)\\n        internal\\n        pure\\n        returns (int256[3] memory result)\\n    {\\n        int256 l = vector3Len(v);\\n        assembly {\\n            mstore(result, sdiv(mul(fidelity, mload(add(v, 0x40))), l))\\n            mstore(\\n                add(result, 0x20),\\n                sdiv(mul(fidelity, mload(add(v, 0x20))), l)\\n            )\\n            mstore(add(result, 0x40), sdiv(mul(fidelity, mload(v)), l))\\n        }\\n    }\\n\\n    /** @dev get the dot-product of two vectors (size 3)\\n     */\\n    function vector3Dot(int256[3] memory v1, int256[3] memory v2)\\n        internal\\n        view\\n        returns (int256 result)\\n    {\\n        assembly {\\n            result := add(\\n                add(\\n                    mul(mload(v1), mload(v2)),\\n                    mul(mload(add(v1, 0x20)), mload(add(v2, 0x20)))\\n                ),\\n                mul(mload(add(v1, 0x40)), mload(add(v2, 0x40)))\\n            )\\n        }\\n    }\\n\\n    /** @dev get the cross product of two vectors (size 3)\\n     */\\n    function crossProduct(int256[3] memory v1, int256[3] memory v2)\\n        internal\\n        pure\\n        returns (int256[3] memory result)\\n    {\\n        assembly {\\n            mstore(\\n                result,\\n                sub(\\n                    mul(mload(add(v1, 0x20)), mload(add(v2, 0x40))),\\n                    mul(mload(add(v1, 0x40)), mload(add(v2, 0x20)))\\n                )\\n            )\\n            mstore(\\n                add(result, 0x20),\\n                sub(\\n                    mul(mload(add(v1, 0x40)), mload(v2)),\\n                    mul(mload(v1), mload(add(v2, 0x40)))\\n                )\\n            )\\n            mstore(\\n                add(result, 0x40),\\n                sub(\\n                    mul(mload(v1), mload(add(v2, 0x20))),\\n                    mul(mload(add(v1, 0x20)), mload(v2))\\n                )\\n            )\\n        }\\n    }\\n\\n    /** @dev linearly interpolate between two vectors (size 12)\\n     */\\n    function vector12Lerp(\\n        int256[12] memory v1,\\n        int256[12] memory v2,\\n        int256 ir,\\n        int256 scaleFactor\\n    ) internal view returns (int256[12] memory result) {\\n        int256[12] memory vd = vector12Sub(v2, v1);\\n        // loop through all 12 items\\n        assembly {\\n            let ix\\n            for {\\n                let i := 0\\n            } lt(i, 0xC) {\\n                // (i < 12)\\n                i := add(i, 1)\\n            } {\\n                /// get index of the next element\\n                ix := mul(i, 0x20)\\n\\n                /// store into the result array\\n                mstore(\\n                    add(result, ix),\\n                    add(\\n                        // v1[i] + (ir * vd[i]) / 1e3\\n                        mload(add(v1, ix)),\\n                        sdiv(mul(ir, mload(add(vd, ix))), 1000)\\n                    )\\n                )\\n            }\\n        }\\n    }\\n\\n    /** @dev subtraction between two vectors (size 12)\\n     */\\n    function vector12Sub(int256[12] memory v1, int256[12] memory v2)\\n        internal\\n        view\\n        returns (int256[12] memory result)\\n    {\\n        // loop through all 12 items\\n        assembly {\\n            let ix\\n            for {\\n                let i := 0\\n            } lt(i, 0xC) {\\n                // (i < 12)\\n                i := add(i, 1)\\n            } {\\n                /// get index of the next element\\n                ix := mul(i, 0x20)\\n                /// store into the result array\\n                mstore(\\n                    add(result, ix),\\n                    sub(\\n                        // v1[ix] - v2[ix]\\n                        mload(add(v1, ix)),\\n                        mload(add(v2, ix))\\n                    )\\n                )\\n            }\\n        }\\n    }\\n\\n    /** @dev map a number from one range into another\\n     */\\n    function mapRangeToRange(\\n        int256 num,\\n        int256 inMin,\\n        int256 inMax,\\n        int256 outMin,\\n        int256 outMax\\n    ) internal pure returns (int256 res) {\\n        assembly {\\n            res := add(\\n                sdiv(\\n                    mul(sub(outMax, outMin), sub(num, inMin)),\\n                    sub(inMax, inMin)\\n                ),\\n                outMin\\n            )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts-exposed/ShackledCoords.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../contracts/ShackledCoords.sol\\\";\\n\\ncontract XShackledCoords {\\n    constructor() {}\\n\\n    function xconvertToWorldSpaceWithModelTransform(int256[3][3][] calldata tris,int256 scale,int256[3] calldata position) external view returns (int256[3][] memory) {\\n        return ShackledCoords.convertToWorldSpaceWithModelTransform(tris,scale,position);\\n    }\\n\\n    function xbackfaceCulling(int256[3][3][] calldata trisWorldSpace,int256[3][3][] calldata trisCols) external view returns (int256[3][3][] memory, int256[3][3][] memory) {\\n        return ShackledCoords.backfaceCulling(trisWorldSpace,trisCols);\\n    }\\n\\n    function xconvertToCameraSpaceViaVertexShader(int256[3][] calldata vertsWorldSpace,int256 canvasDim,bool perspCamera) external view returns (int256[3][] memory) {\\n        return ShackledCoords.convertToCameraSpaceViaVertexShader(vertsWorldSpace,canvasDim,perspCamera);\\n    }\\n\\n    function xgetCameraMatrixOrth(int256 canvasDim) external pure returns (int256[4][4][2] memory) {\\n        return ShackledCoords.getCameraMatrixOrth(canvasDim);\\n    }\\n\\n    function xgetCameraMatrixPersp() external pure returns (int256[4][4][2] memory) {\\n        return ShackledCoords.getCameraMatrixPersp();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts-exposed/ShackledIcons.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../contracts/ShackledIcons.sol\\\";\\n\\ncontract XShackledIcons is ShackledIcons {\\n    constructor() {}\\n\\n    function x_getLightingParamsHash(ShackledStructs.LightingParams calldata lightingParams) external pure returns (bytes32) {\\n        return super._getLightingParamsHash(lightingParams);\\n    }\\n\\n    function x_baseURI() external view returns (string memory) {\\n        return super._baseURI();\\n    }\\n\\n    function x_transferOwnership(address newOwner) external {\\n        return super._transferOwnership(newOwner);\\n    }\\n\\n    function x_beforeTokenTransfer(address from,address to,uint256 tokenId) external {\\n        return super._beforeTokenTransfer(from,to,tokenId);\\n    }\\n\\n    function x_safeTransfer(address from,address to,uint256 tokenId,bytes calldata _data) external {\\n        return super._safeTransfer(from,to,tokenId,_data);\\n    }\\n\\n    function x_exists(uint256 tokenId) external view returns (bool) {\\n        return super._exists(tokenId);\\n    }\\n\\n    function x_isApprovedOrOwner(address spender,uint256 tokenId) external view returns (bool) {\\n        return super._isApprovedOrOwner(spender,tokenId);\\n    }\\n\\n    function x_safeMint(address to,uint256 tokenId) external {\\n        return super._safeMint(to,tokenId);\\n    }\\n\\n    function x_safeMint(address to,uint256 tokenId,bytes calldata _data) external {\\n        return super._safeMint(to,tokenId,_data);\\n    }\\n\\n    function x_mint(address to,uint256 tokenId) external {\\n        return super._mint(to,tokenId);\\n    }\\n\\n    function x_burn(uint256 tokenId) external {\\n        return super._burn(tokenId);\\n    }\\n\\n    function x_transfer(address from,address to,uint256 tokenId) external {\\n        return super._transfer(from,to,tokenId);\\n    }\\n\\n    function x_approve(address to,uint256 tokenId) external {\\n        return super._approve(to,tokenId);\\n    }\\n\\n    function x_setApprovalForAll(address owner,address operator,bool approved) external {\\n        return super._setApprovalForAll(owner,operator,approved);\\n    }\\n\\n    function x_afterTokenTransfer(address from,address to,uint256 tokenId) external {\\n        return super._afterTokenTransfer(from,to,tokenId);\\n    }\\n\\n    function x_msgSender() external view returns (address) {\\n        return super._msgSender();\\n    }\\n\\n    function x_msgData() external view returns (bytes memory) {\\n        return super._msgData();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts-exposed/ShackledMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../contracts/ShackledMath.sol\\\";\\n\\ncontract XShackledMath {\\n    constructor() {}\\n\\n    function xmin(int256 a,int256 b) external pure returns (int256) {\\n        return ShackledMath.min(a,b);\\n    }\\n\\n    function xmax(int256 a,int256 b) external pure returns (int256) {\\n        return ShackledMath.max(a,b);\\n    }\\n\\n    function xmod(int256 n,int256 m) external pure returns (int256) {\\n        return ShackledMath.mod(n,m);\\n    }\\n\\n    function xrandomIdx(bytes32 seedModifier,uint256 n,uint256 m) external pure returns (uint256[] memory) {\\n        return ShackledMath.randomIdx(seedModifier,n,m);\\n    }\\n\\n    function xget2dArray(uint256 m,uint256 q,int256 value) external pure returns (int256[][] memory) {\\n        return ShackledMath.get2dArray(m,q,value);\\n    }\\n\\n    function xabs(int256 x) external pure returns (int256) {\\n        return ShackledMath.abs(x);\\n    }\\n\\n    function xsqrt(int256 y) external pure returns (int256) {\\n        return ShackledMath.sqrt(y);\\n    }\\n\\n    function xhypot(int256 x,int256 y) external pure returns (int256) {\\n        return ShackledMath.hypot(x,y);\\n    }\\n\\n    function xvector3Add(int256[3] calldata v1,int256[3] calldata v2) external pure returns (int256[3] memory) {\\n        return ShackledMath.vector3Add(v1,v2);\\n    }\\n\\n    function xvector3Sub(int256[3] calldata v1,int256[3] calldata v2) external pure returns (int256[3] memory) {\\n        return ShackledMath.vector3Sub(v1,v2);\\n    }\\n\\n    function xvector3MulScalar(int256[3] calldata v,int256 a) external pure returns (int256[3] memory) {\\n        return ShackledMath.vector3MulScalar(v,a);\\n    }\\n\\n    function xvector3DivScalar(int256[3] calldata v,int256 a) external pure returns (int256[3] memory) {\\n        return ShackledMath.vector3DivScalar(v,a);\\n    }\\n\\n    function xvector3Len(int256[3] calldata v) external pure returns (int256) {\\n        return ShackledMath.vector3Len(v);\\n    }\\n\\n    function xvector3NormX(int256[3] calldata v,int256 fidelity) external pure returns (int256[3] memory) {\\n        return ShackledMath.vector3NormX(v,fidelity);\\n    }\\n\\n    function xvector3Dot(int256[3] calldata v1,int256[3] calldata v2) external view returns (int256) {\\n        return ShackledMath.vector3Dot(v1,v2);\\n    }\\n\\n    function xcrossProduct(int256[3] calldata v1,int256[3] calldata v2) external pure returns (int256[3] memory) {\\n        return ShackledMath.crossProduct(v1,v2);\\n    }\\n\\n    function xvector12Lerp(int256[12] calldata v1,int256[12] calldata v2,int256 ir,int256 scaleFactor) external view returns (int256[12] memory) {\\n        return ShackledMath.vector12Lerp(v1,v2,ir,scaleFactor);\\n    }\\n\\n    function xvector12Sub(int256[12] calldata v1,int256[12] calldata v2) external view returns (int256[12] memory) {\\n        return ShackledMath.vector12Sub(v1,v2);\\n    }\\n\\n    function xmapRangeToRange(int256 num,int256 inMin,int256 inMax,int256 outMin,int256 outMax) external pure returns (int256) {\\n        return ShackledMath.mapRangeToRange(num,inMin,inMax,outMin,outMax);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts-exposed/ShackledRasteriser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../contracts/ShackledRasteriser.sol\\\";\\n\\ncontract XShackledRasteriser {\\n    constructor() {}\\n\\n    function xinitialiseFragments(int256[3][3][] calldata trisCameraSpace,int256[3][3][] calldata trisWorldSpace,int256[3][3][] calldata trisCols,int256 canvasDim) external view returns (int256[12][3][] memory) {\\n        return ShackledRasteriser.initialiseFragments(trisCameraSpace,trisWorldSpace,trisCols,canvasDim);\\n    }\\n\\n    function xrasterise(int256[12][3][] calldata trisFragments,int256 canvasDim,bool wireframe) external view returns (int256[12][] memory) {\\n        return ShackledRasteriser.rasterise(trisFragments,canvasDim,wireframe);\\n    }\\n\\n    function xrunBresenhamsAlgorithm(int256[12] calldata f1,int256[12] calldata f2,int256 canvasDim,int256[12][] calldata bresTriFragments,uint256 nextBresTriFragmentIx) external view returns (int256[12][] memory, uint256) {\\n        return ShackledRasteriser.runBresenhamsAlgorithm(f1,f2,canvasDim,bresTriFragments,nextBresTriFragmentIx);\\n    }\\n\\n    function xbresenhamsInner(ShackledRasteriser.BresenhamsVars calldata vars,int256 mag,int256[12] calldata fa,int256[12] calldata fb,int256 canvasDim,int256[12][] calldata bresTriFragments,uint256 nextBresTriFragmentIx) external view returns (int256[12][] memory, uint256) {\\n        return ShackledRasteriser.bresenhamsInner(vars,mag,fa,fb,canvasDim,bresTriFragments,nextBresTriFragmentIx);\\n    }\\n\\n    function xrunScanline(int256[12][] calldata bresTriFragments,int256[12][] calldata fragments,uint256 nextFragmentsIx,int256 canvasDim) external view returns (int256[12][] memory, uint256) {\\n        return ShackledRasteriser.runScanline(bresTriFragments,fragments,nextFragmentsIx,canvasDim);\\n    }\\n\\n    function xgetRowFragIndices(int256[12][] calldata bresTriFragments,int256 canvasDim) external view returns (int256[][] memory, uint256[] memory) {\\n        return ShackledRasteriser.getRowFragIndices(bresTriFragments,canvasDim);\\n    }\\n\\n    function xdepthTesting(int256[12][] calldata fragments,int256 canvasDim) external view returns (int256[12][] memory) {\\n        return ShackledRasteriser.depthTesting(fragments,canvasDim);\\n    }\\n\\n    function xlightScene(int256[12][] calldata fragments,ShackledStructs.LightingParams calldata lp) external view returns (int256[12][] memory) {\\n        return ShackledRasteriser.lightScene(fragments,lp);\\n    }\\n\\n    function xcalculateSpecular(int256 lightSpecPower,int256 hnDot,int256 fidelity,uint256 inverseShininess) external pure returns (int256) {\\n        return ShackledRasteriser.calculateSpecular(lightSpecPower,hnDot,fidelity,inverseShininess);\\n    }\\n\\n    function xgetBackground(int256 canvasDim,int256[3][2] calldata backgroundColor) external view returns (int256[5][] memory) {\\n        return ShackledRasteriser.getBackground(canvasDim,backgroundColor);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts-exposed/ShackledRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../contracts/ShackledRenderer.sol\\\";\\n\\ncontract XShackledRenderer {\\n    constructor() {}\\n\\n    function xrender(ShackledStructs.RenderParams calldata renderParams,int256 canvasDim,bool returnSVG) external view returns (string memory) {\\n        return ShackledRenderer.render(renderParams,canvasDim,returnSVG);\\n    }\\n\\n    function xprepareGeometryForRender(ShackledStructs.RenderParams calldata renderParams,int256 canvasDim) external view returns (int256[12][3][] memory) {\\n        return ShackledRenderer.prepareGeometryForRender(renderParams,canvasDim);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts-exposed/ShackledStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../contracts/ShackledStructs.sol\\\";\\n\\ncontract XShackledStructs {\\n    constructor() {}\\n}\\n\"\r\n    },\r\n    \"contracts-exposed/ShackledUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../contracts/ShackledUtils.sol\\\";\\n\\ncontract XShackledUtils {\\n    constructor() {}\\n\\n    function xflattenTris(int256[3][3][] calldata tris) external pure returns (int256[3][] memory) {\\n        return ShackledUtils.flattenTris(tris);\\n    }\\n\\n    function xunflattenVertsToTris(int256[3][] calldata verts) external pure returns (int256[3][3][] memory) {\\n        return ShackledUtils.unflattenVertsToTris(verts);\\n    }\\n\\n    function xclipArray12ToLength(int256[12][] calldata arr,uint256 desiredLen) external pure returns (int256[12][] memory) {\\n        return ShackledUtils.clipArray12ToLength(arr,desiredLen);\\n    }\\n\\n    function xuint2str(uint256 _i) external pure returns (string memory) {\\n        return ShackledUtils.uint2str(_i);\\n    }\\n\\n    function xgetHex(uint256 _i) external pure returns (bytes memory) {\\n        return ShackledUtils.getHex(_i);\\n    }\\n\\n    function xgetSVGContainer(string calldata encodedBitmap,int256 canvasDim,uint256 outputHeight,uint256 outputWidth) external view returns (string memory) {\\n        return ShackledUtils.getSVGContainer(encodedBitmap,canvasDim,outputHeight,outputWidth);\\n    }\\n\\n    function xgetAttributes(ShackledStructs.Metadata calldata metadata) external pure returns (bytes memory) {\\n        return ShackledUtils.getAttributes(metadata);\\n    }\\n\\n    function xgetEncodedMetadata(string calldata image,ShackledStructs.Metadata calldata metadata,uint256 tokenId) external view returns (string memory) {\\n        return ShackledUtils.getEncodedMetadata(image,metadata,tokenId);\\n    }\\n\\n    function xgetEncodedBitmap(int256[12][] calldata fragments,int256[5][] calldata background,int256 canvasDim,bool invert) external view returns (string memory) {\\n        return ShackledUtils.getEncodedBitmap(fragments,background,canvasDim,invert);\\n    }\\n\\n    function xwriteFragmentsToBytesArray(int256[12][] calldata fragments,bytes calldata bytesArray,uint256 canvasDimUnsigned,bool invert) external pure returns (bytes memory) {\\n        return ShackledUtils.writeFragmentsToBytesArray(fragments,bytesArray,canvasDimUnsigned,invert);\\n    }\\n\\n    function xwriteBackgroundToBytesArray(int256[5][] calldata background,bytes calldata bytesArray,uint256 canvasDimUnsigned,bool invert) external pure returns (bytes memory) {\\n        return ShackledUtils.writeBackgroundToBytesArray(background,bytesArray,canvasDimUnsigned,invert);\\n    }\\n}\\n\\ncontract XBase64 {\\n    constructor() {}\\n\\n    function xencode(bytes calldata data) external view returns (string memory) {\\n        return Base64.encode(data);\\n    }\\n}\\n\\ncontract XBytesUtils {\\n    constructor() {}\\n\\n    function xchar(bytes1 b) external view returns (bytes1) {\\n        return BytesUtils.char(b);\\n    }\\n\\n    function xbytes32string(bytes32 b32) external view returns (string memory) {\\n        return BytesUtils.bytes32string(b32);\\n    }\\n\\n    function xhach(string calldata value) external view returns (string memory) {\\n        return BytesUtils.hach(value);\\n    }\\n\\n    function xMergeBytes(bytes calldata a,bytes calldata b) external pure returns (bytes memory) {\\n        return BytesUtils.MergeBytes(a,b);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/ShackledRenderer.sol\": {\r\n        \"ShackledRenderer\": \"0x2221aab4a036dc5605c18c9cba4b947cf01995ce\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentBaseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256[3][]\",\"name\":\"faces\",\"type\":\"uint256[3][]\"},{\"internalType\":\"int256[3][]\",\"name\":\"verts\",\"type\":\"int256[3][]\"},{\"internalType\":\"int256[3][]\",\"name\":\"cols\",\"type\":\"int256[3][]\"},{\"internalType\":\"int256[3]\",\"name\":\"objPosition\",\"type\":\"int256[3]\"},{\"internalType\":\"int256\",\"name\":\"objScale\",\"type\":\"int256\"},{\"internalType\":\"int256[3][2]\",\"name\":\"backgroundColor\",\"type\":\"int256[3][2]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"applyLighting\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"lightAmbiPower\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lightDiffPower\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lightSpecPower\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"inverseShininess\",\"type\":\"uint256\"},{\"internalType\":\"int256[3]\",\"name\":\"lightPos\",\"type\":\"int256[3]\"},{\"internalType\":\"int256[3]\",\"name\":\"lightColSpec\",\"type\":\"int256[3]\"},{\"internalType\":\"int256[3]\",\"name\":\"lightColDiff\",\"type\":\"int256[3]\"},{\"internalType\":\"int256[3]\",\"name\":\"lightColAmbi\",\"type\":\"int256[3]\"}],\"internalType\":\"struct ShackledStructs.LightingParams\",\"name\":\"lightingParams\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"perspCamera\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"backfaceCulling\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"invert\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"wireframe\",\"type\":\"bool\"}],\"internalType\":\"struct ShackledStructs.RenderParams\",\"name\":\"renderParams\",\"type\":\"tuple\"}],\"name\":\"getRenderParamsHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"canvasDim_\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"uint256[3][]\",\"name\":\"faces\",\"type\":\"uint256[3][]\"},{\"internalType\":\"int256[3][]\",\"name\":\"verts\",\"type\":\"int256[3][]\"},{\"internalType\":\"int256[3][]\",\"name\":\"cols\",\"type\":\"int256[3][]\"},{\"internalType\":\"int256[3]\",\"name\":\"objPosition\",\"type\":\"int256[3]\"},{\"internalType\":\"int256\",\"name\":\"objScale\",\"type\":\"int256\"},{\"internalType\":\"int256[3][2]\",\"name\":\"backgroundColor\",\"type\":\"int256[3][2]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"applyLighting\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"lightAmbiPower\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lightDiffPower\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lightSpecPower\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"inverseShininess\",\"type\":\"uint256\"},{\"internalType\":\"int256[3]\",\"name\":\"lightPos\",\"type\":\"int256[3]\"},{\"internalType\":\"int256[3]\",\"name\":\"lightColSpec\",\"type\":\"int256[3]\"},{\"internalType\":\"int256[3]\",\"name\":\"lightColDiff\",\"type\":\"int256[3]\"},{\"internalType\":\"int256[3]\",\"name\":\"lightColAmbi\",\"type\":\"int256[3]\"}],\"internalType\":\"struct ShackledStructs.LightingParams\",\"name\":\"lightingParams\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"perspCamera\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"backfaceCulling\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"invert\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"wireframe\",\"type\":\"bool\"}],\"internalType\":\"struct ShackledStructs.RenderParams\",\"name\":\"renderParams\",\"type\":\"tuple\"}],\"name\":\"render\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"tokenHash\",\"type\":\"bytes32\"}],\"name\":\"storeTokenHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ShackledIcons", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}