{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity 0.8.7;\r\n\r\ninterface WnsRegistryInterface {\r\n    function owner() external view returns (address);\r\n    function getWnsAddress(string memory _label) external view returns (address);\r\n    function setRecord(bytes32 _hash, uint256 _tokenId, string memory _name) external;\r\n    function setRecord(uint256 _tokenId, string memory _name) external;\r\n    function getRecord(bytes32 _hash) external view returns (uint256);\r\n    \r\n}\r\n\r\npragma solidity 0.8.7;\r\n\r\ninterface WnsErc721Interface {\r\n    function mintErc721(address to) external;\r\n    function getNextTokenId() external view returns (uint256);\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n\r\n}\r\n\r\n\r\npragma solidity 0.8.7;\r\n\r\ncontract Computation {\r\n    function computeNamehash(string memory _name) public pure returns (bytes32 namehash) {\r\n        namehash = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n        namehash = keccak256(\r\n        abi.encodePacked(namehash, keccak256(abi.encodePacked('eth')))\r\n        );\r\n        namehash = keccak256(\r\n        abi.encodePacked(namehash, keccak256(abi.encodePacked(_name)))\r\n        );\r\n    }\r\n}\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\nabstract contract Signatures {\r\n\r\n    struct Register {\r\n        string name;\r\n        string extension;\r\n        address registrant;\r\n        uint256 cost;\r\n        uint256 expiration;\r\n        address[] splitAddresses;\r\n        uint256[] splitAmounts;\r\n    }\r\n     \r\n   function verifySignature(Register memory _register, bytes memory sig) internal pure returns(address) {\r\n        bytes32 message = keccak256(abi.encode(_register.name, _register.extension, _register.registrant, _register.cost, _register.expiration, _register.splitAddresses, _register.splitAmounts));\r\n        return recoverSigner(message, sig);\r\n   }\r\n\r\n   function recoverSigner(bytes32 message, bytes memory sig)\r\n       public\r\n       pure\r\n       returns (address)\r\n     {\r\n       uint8 v;\r\n       bytes32 r;\r\n       bytes32 s;\r\n       (v, r, s) = splitSignature(sig);\r\n       return ecrecover(message, v, r, s);\r\n   }\r\n\r\n   function splitSignature(bytes memory sig)\r\n       internal\r\n       pure\r\n       returns (uint8, bytes32, bytes32)\r\n     {\r\n       require(sig.length == 65);\r\n\r\n       bytes32 r;\r\n       bytes32 s;\r\n       uint8 v;\r\n\r\n       assembly {\r\n           // first 32 bytes, after the length prefix\r\n           r := mload(add(sig, 32))\r\n           // second 32 bytes\r\n           s := mload(add(sig, 64))\r\n           // final byte (first byte of the next 32 bytes)\r\n           v := byte(0, mload(add(sig, 96)))\r\n       }\r\n \r\n       return (v, r, s);\r\n   }\r\n}\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.7;\r\n\r\ncontract WnsRegistrar is Computation, Signatures {\r\n\r\n    address private WnsRegistry;\r\n    WnsRegistryInterface wnsRegistry;\r\n\r\n    constructor(address registry_) {\r\n        WnsRegistry = registry_;\r\n        wnsRegistry = WnsRegistryInterface(WnsRegistry);\r\n    }\r\n\r\n    function setRegistry(address _registry) public {\r\n        require(msg.sender == wnsRegistry.owner(), \"Not authorized.\");\r\n        WnsRegistry = _registry;\r\n        wnsRegistry = WnsRegistryInterface(WnsRegistry);\r\n    }\r\n\r\n    bool public isActive = false;\r\n\r\n    function wnsRegister(Register[] memory register, bytes[] memory sig) public payable {\r\n        require(isActive, \"Registration must be active.\");\r\n        require(register.length == sig.length, \"Invalid parameters.\");\r\n        require(calculateCost(register) <= msg.value, \"Ether value is not correct.\");\r\n        for(uint256 i=0; i<register.length; i++) {\r\n            _register(register[i], sig[i]);\r\n        }\r\n    }\r\n\r\n    function _register(Register memory register, bytes memory sig) internal {\r\n        WnsErc721Interface wnsErc721 = WnsErc721Interface(wnsRegistry.getWnsAddress(\"_wnsErc721\"));\r\n        require(verifySignature(register,sig) == wnsRegistry.getWnsAddress(\"_wnsSigner\"), \"Not authorized.\");\r\n        require(register.expiration >= block.timestamp, \"Expired credentials.\");\r\n        bytes32 _hash = computeNamehash(register.name);\r\n        require(wnsRegistry.getRecord(_hash) == 0, \"Name already exists.\");\r\n        \r\n        wnsErc721.mintErc721(register.registrant);\r\n        wnsRegistry.setRecord(_hash, wnsErc721.getNextTokenId(), string(abi.encodePacked(register.name, register.extension)));\r\n        settleSplits(register.splitAddresses, register.splitAmounts);\r\n    }\r\n\r\n    function migrateExtension(string memory _name, string memory _extension, bytes memory sig) public {\r\n        WnsErc721Interface wnsErc721 = WnsErc721Interface(wnsRegistry.getWnsAddress(\"_wnsErc721\"));\r\n        bytes32 message = keccak256(abi.encode(_name, _extension));\r\n        require(recoverSigner(message, sig) == wnsRegistry.getWnsAddress(\"_wnsSigner\"), \"Not authorized.\");\r\n        uint256 _tokenId = wnsRegistry.getRecord(computeNamehash(_name)) - 1;\r\n        require(wnsErc721.ownerOf(_tokenId) == msg.sender, \"Not owned by caller\");\r\n        wnsRegistry.setRecord(_tokenId + 1, string(abi.encodePacked(_name, _extension)));\r\n    }\r\n\r\n    function calculateCost(Register[] memory register) internal pure returns (uint256) {\r\n        uint256 cost;\r\n        for(uint256 i=0; i<register.length; i++) {\r\n            cost = cost + register[i].cost;\r\n        }\r\n        return cost;\r\n    }\r\n\r\n    function settleSplits(address[] memory splitAddresses, uint256[] memory splitAmounts) internal {\r\n        uint256 addLength = splitAddresses.length;\r\n        uint256 amountLength = splitAmounts.length;\r\n        require(addLength == amountLength, \"Invalid parameters.\");\r\n        if(addLength > 0) {\r\n            for(uint256 i=0; i<addLength; i++) {\r\n                payable(splitAddresses[i]).transfer(splitAmounts[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdraw(address to, uint256 amount) public {\r\n        require(msg.sender == wnsRegistry.owner());\r\n        require(amount <= address(this).balance);\r\n        payable(to).transfer(amount);\r\n    }\r\n    \r\n    function flipActiveState() public {\r\n        require(msg.sender == wnsRegistry.owner());\r\n        isActive = !isActive;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"computeNamehash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"namehash\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flipActiveState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_extension\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"migrateExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"message\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"extension\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"registrant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"splitAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"splitAmounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct Signatures.Register[]\",\"name\":\"register\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"sig\",\"type\":\"bytes[]\"}],\"name\":\"wnsRegister\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "WnsRegistrar", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000082fe896e4969a3270c0bec103cf1ebdbda6e6bfc", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a6774449a269017182c68eef85025f99d1cd71d85f3c46b878a87634a8b14e16"}]}