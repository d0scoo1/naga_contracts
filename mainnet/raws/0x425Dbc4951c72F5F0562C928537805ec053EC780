{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/erc721_batchable_collection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n//                                                                                                                                                         //\\n//                                                                                                                                                         //\\n//       .;dkkkkkkkkkkkkkkkkkkd'      .:xkkkkkkkkd,           .:dk0XXXXXXXK0xdl,.    .lxkkkkkkkkkkkkkkkkkk:.,okkkkkkko.    .cxkkkkkkxc.      ;dkkkkkko.    //\\n//      ;xNMMMMMMMMMMMMMMMMMMMX:    .:kNWMMMMMMMMWx.        .l0NWWWWWMMMMMMMMMWNO;..lKWMMMMMMMMMMMMMMMMMMMKkKWMMMMMMMK,  .c0WMMMMMMMMX:   .;xXWMMMMMNo.    //\\n//    .,lddddddddddddddddxKMMMK;   .,lddddddx0WMMMX;      .;llc::;;::cox0XWMMMMMWXdcoddddddddddddddddONMW0ddddddxXMMMK, .:odddddONMMMMO' .,lddddd0WWd.     //\\n//    ..                 .dWWKl.   .         :XMMMWx.    ...            .,oKWMMMMWx.                 ,KMNc      .kMMM0, ..      .xWMMMWx'.      'kNk.      //\\n//    ..                 .dKo'    ..         .xWMMMK;  ..       .'..       ,OWWMMWx.                 ,Okc'      .kMMMK,  ..      ,0MMMMXl.     .dNO'       //\\n//    ..      .:ooo;......,'      .           :XMMMWd. .      .l0XXOc.      ;xKMWNo.      ,looc'......'...      .kMMMK,   ..      cXMMM0,     .oNK;        //\\n//    ..      '0MMMk.            ..           .kWMMMK,.'      ;KMMMWNo.     .;kNkc,.     .dWMMK:        ..      .kMMMK,    ..     .dWMXc      cXK:         //\\n//    ..      '0MMMXkxxxxxxxxd'  .     .:.     cXMMMWd,'      '0MMMMM0l;;;;;;:c;. ..     .dWMMW0xxxxxxxxx;      .kMMMK,     ..     'ONd.     :KXc          //\\n//    ..      '0MMMMMMMMMMMMMNc ..     :O:     .kMMMMK:.       'd0NWMWWWWWWWNXOl'...     .dWMMMMMMMMMMMMWl      .kMMMK,      .      :d'     ;0No.          //\\n//    ..      .lkkkkkkkkkKWMMNc .     .dNd.     cNMMMWo..        .':dOXWMMMMMMMWXk:.      :xkkkkkkkk0NMMWl      .kMMMK,       .      .     'ONd.           //\\n//    ..                .oNMXd...     '0M0'     .kMMMM0, ..           .;o0NMMMMMMWx.                ,0MN0:      .kMMMK,       ..          .kW0'            //\\n//    ..                 cKk,  .      lNMNl      cNMMMNo  .',..          .;xXWMMMWx.                'O0c'.      .kMMMK,        ..        .xWMO.            //\\n//    ..      .,ccc,.....,,.  ..     .kMMMk.     .OMMMW0;'d0XX0xc,.         :d0MMWx.      ':cc:'....';. ..      .kMMMK,         ..      .oNMMO.            //\\n//    ..      '0MMMk.         ..     ,kKKKk'      lNMMMN0KWWWMMMWNKl.         cXMWx.     .dWMMX:        ..      .kMMMK,         ..      .OMMMO.            //\\n//    ..      '0MMMk'..........       .....       'OMMKo:::::cxNMMMKl'.       .OMWx.     .dWMMXc..........      .kMMMK:.........,'      .OMMMO.            //\\n//    ..      '0MMMNXKKKKKKKKd.                    lNM0'      ;XMMMWN0c       .OMWd.     .dWMMWXKKKKKKKK0c      .kMMMWXKKKKKKKKK0:      .OMMMO.            //\\n//    ..      'OWWWWWWWWWWMMNc      'llc'   .      '0MNc      .kWMMMMX:       ,KXx:.     .oNWWWWWWWWWWMMWl      .xWWWWWWWWWWWMMMN:      .OMMMO.            //\\n//    ..       ,:::::::::cOWO.     .xWWO'   .       oNMO'      .lkOOx;.     .'cd,...      .::::::::::dXMWl       '::::::::::xWMMX:      .OMMWx.            //\\n//    ..                  dNl      ,0Xd.    ..      ,0MNo.        .        ..'.   ..                 ,0WK:                  :NWOo,      .OWKo.             //\\n//    .'                 .oO,     .co,       ..     .oOc....             ...      ..                 ,xo,..                 ckl..'.     'dd'               //\\n//     .............................         ..........       .   ..   .          .....................  .....................   .........                 //\\n//                                                                                                                                                         //\\n//                                                                                                                                                         //\\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/**\\n * The contracts below implement a lazy-minted, multi-directory metadata storage version of ERC721.\\n * It gives the creator flexibility to mint singular hashes at a time or entire batches of tokens under\\n * a single token directory -- commonly an IPFS hash. Batching tokens together saves an immense amount of gas,\\n * but the owner of this collection gives up some control over the tokenIds exact numbering.\\n *\\n * Each batch that the owner releases gets offset by the batchSize because doing so makes it possible\\n * to enable the same benefits as ERC721A across multiple different releases separately. This functionality\\n * makes it cheap for the contract creator to mint hundres of tokens and allow their full collection to\\n * be shown on places like opensea without needing to be bought out first.\\n *\\n * Note: This batch minting is reserved only for the contract creator and not for external buyers.\\n *\\n * It has two main methods to lazy-mint, one allows the owner to set a price for a singular token in an\\n * existing batch or set a price for a single new tokenURI that will get added to this collection.\\n */\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\nerror CallerNotOwner();\\nerror OwnerNotZero();\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address internal _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        if (owner() != _msgSender()) revert CallerNotOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) revert OwnerNotZero();\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance >= amount,\\n            \\\"Address: insufficient balance\\\"\\n        );\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(\\n            success,\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                \\\"Address: low-level call with value failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            \\\"Address: insufficient balance for call\\\"\\n        );\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\n            data\\n        );\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return\\n            functionStaticCall(\\n                target,\\n                data,\\n                \\\"Address: low-level static call failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionDelegateCall(\\n                target,\\n                data,\\n                \\\"Address: low-level delegate call failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\\nerror AlreadySetBatchSize();\\nerror AlreadySetSeqMintLimit();\\nerror ApprovalCallerNotOwnerNorApproved();\\nerror ApproveToCaller();\\nerror ApprovalToCurrentOwner();\\nerror BalanceQueryForZeroAddress();\\nerror InvalidBatchAmount();\\nerror MintToZeroAddress();\\nerror MintExistingToken();\\nerror NotBatchDirectory();\\nerror NotSequentiallyMintable();\\nerror OverBatchTokenLimit();\\nerror OverReleaseLimit();\\nerror TransferCallerNotOwnerNorApproved();\\nerror TransferFromIncorrectOwner();\\nerror TransferToNonERC721ReceiverImplementer();\\nerror TransferToZeroAddress();\\nerror QueryForNonexistentToken();\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n *\\n * It mainly follows the practice of ERC721A in order to better handle multi-mint transactions. \\n \\n It has two layers of optimization:\\n *\\n * First, it assumes tokens are sequentially minted within each block (defaults to 0, e.g. 0, 1, 2, 3..)\\n * which allows for up to 5 times cheaper MINT gas fees, but does increase first time TRANSFER gas fees.\\n * Because of this, methods have also been optimized to only call ownerOf() once as it is not a direct lookup.\\n *\\n * Additionally assumes the following:\\n * that no more than 2**64 - 1 (max value of uint64) tokens can be batch minted\\n * that no more than 2**64 - 1 (max value of uint64) tokens can be individually minted\\n * that no more than 2**64 - 1 (max value of uint64) tokens can be burned\\n * that no owner can have more than 2**64 - 1 (max value of uint64) of supply. \\n */\\ncontract ERC721B is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Compiler will pack this into a single 256bit word.\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n    }\\n\\n    // Compiler will pack this into a single 256bit word.\\n    struct AddressData {\\n        // Realistically, 2**64-1 is more than enough.\\n        uint64 balance;\\n        // Keeps track of mint count with minimal overhead for tokenomics.\\n        uint64 numberMinted;\\n        // Keeps track of burn count with minimal overhead for tokenomics.\\n        uint64 numberBurned;\\n        // For miscellaneous variable(s) pertaining to the address\\n        // (e.g. number of whitelist mint slots used).\\n        // If there are multiple variables, please pack them into a uint64.\\n        uint64 aux;\\n    }\\n\\n    // Compiler will pack this into a single 256bit word.\\n    struct BatchData {\\n        // Tracks if tokens can still use the savings from being sequenitally mintable\\n        bool isSequentiallyMintable;\\n        // Tracks total tokens in this batch\\n        uint64 batchSize;\\n        // Tracks total tokens minted sequentially from the start of the batch\\n        uint64 sequentialMints;\\n    }\\n\\n    // Token name\\n    string internal _name;\\n\\n    // Token symbol\\n    string internal _symbol;\\n\\n    // Token Base URI\\n    string private baseURI;\\n\\n    // Compiler will pack these units below together into a 256bit section\\n    // This returns the id header of the next batch\\n    uint64 internal _nextBatchId;\\n    // Track total minted tokens\\n    uint64 internal _batchMintedCount;\\n    // Will let us mint all individual tokens in the same batch\\n    uint64 internal _individualTokenIdBase;\\n    // Will let us know when we need to update the token base\\n    uint64 internal _individualTokensCount;\\n\\n    // Compiler will pack these units below together into a 256bit section\\n    // Tracking total burned\\n    uint64 internal _totalBurned;\\n    // This ensures that ownerOf() can still run in constant time with a max runtime\\n    // of checking X values, but is up to X times cheaper on batch mints.\\n    uint32 internal constant DEFAULT_SEQ_MINT_LIMIT = 5;\\n    uint32 internal constant MAX_SEQ_MINT_LIMIT = 10;\\n    uint32 public seqMintLimit;\\n\\n    // This is used to be able to quickly query tokenURI and other metadata of a batch\\n    uint32 internal constant DEFAULT_BATCH_SIZE = 1000;\\n    uint32 internal constant MAX_BATCH_SIZE = 100000;\\n    uint32 public batchSize;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => TokenOwnership) internal _ownerships;\\n\\n    // Mapping owner address to token count\\n    mapping(address => AddressData) internal _addressData;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Mapping from batch ID to related batch data\\n    mapping(uint256 => BatchData) private _batchIdToData;\\n\\n    // Mapping from batchId to tokenDirectory data\\n    mapping(uint256 => string) public batchDirectories;\\n\\n    // Mapping from tokenId to tokenURI for a individual token\\n    mapping(uint256 => string) private _individualTokenMetadata;\\n\\n    event NameChanged(string name);\\n    event SymbolChanged(string symbol);\\n    event BaseURIChanged(string baseURI);\\n    event TokenDirectoryReleased(string tokenDirectory, uint256 amount);\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override(ERC165, IERC165)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return _addressData[owner].balance;\\n    }\\n\\n    /**\\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setBatchSize(uint256 newBatchSize) internal {\\n        if (batchSize != 0) revert AlreadySetBatchSize();\\n        if (newBatchSize == 0) {\\n            batchSize = DEFAULT_BATCH_SIZE;\\n        } else if (newBatchSize > MAX_BATCH_SIZE) {\\n            batchSize = MAX_BATCH_SIZE;\\n        } else {\\n            batchSize = uint32(newBatchSize);\\n        }\\n    }\\n\\n    /**\\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setSeqMintLimit(uint256 newSeqMintLimit) internal {\\n        if (seqMintLimit != 0) revert AlreadySetSeqMintLimit();\\n        if (newSeqMintLimit == 0) {\\n            seqMintLimit = DEFAULT_SEQ_MINT_LIMIT;\\n        } else if (newSeqMintLimit > MAX_SEQ_MINT_LIMIT) {\\n            seqMintLimit = MAX_SEQ_MINT_LIMIT;\\n        } else {\\n            seqMintLimit = uint32(newSeqMintLimit);\\n        }\\n    }\\n\\n    // returns the batch ID for a token ID\\n    function _getBatchId(uint256 tokenId) internal view returns (uint256) {\\n        return tokenId / batchSize;\\n    }\\n\\n    // Returns the index of a token ID within a batch\\n    function _getBatchIndex(uint256 tokenId) internal view returns (uint256) {\\n        return tokenId % batchSize;\\n    }\\n\\n    // returns if this batch is reserved for individual token IDs or not\\n    function _isIndividual(BatchData memory batchData)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return batchData.batchSize == 0;\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return uint256(_addressData[owner].numberMinted);\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return uint256(_addressData[owner].numberBurned);\\n    }\\n\\n    /**\\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return _addressData[owner].aux;\\n    }\\n\\n    /**\\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal {\\n        _addressData[owner].aux = aux;\\n    }\\n\\n    /**\\n     * Updates the token name\\n     */\\n    function _setTokenName(string memory name_) internal {\\n        if (bytes(name_).length == 0) return;\\n        _name = name_;\\n        emit NameChanged(name_);\\n    }\\n\\n    /**\\n     * Updates the token symbol\\n     */\\n    function _setTokenSymbol(string memory symbol_) internal {\\n        if (bytes(symbol_).length == 0) return;\\n        _symbol = symbol_;\\n        emit SymbolChanged(symbol_);\\n    }\\n\\n    /**\\n     * Updates the base URI of the tokens\\n     */\\n    function _setBaseURI(string memory uri) internal {\\n        if (bytes(uri).length == 0) return;\\n        baseURI = uri;\\n        emit BaseURIChanged(uri);\\n    }\\n\\n    /**\\n     * @dev adds another batch of NFTs that are all defined under the same token directory\\n     */\\n    function _addTokenDirectory(string memory tokenDirectory, uint256 amount)\\n        internal\\n    {\\n        if (amount > batchSize) revert OverReleaseLimit();\\n\\n        batchDirectories[_nextBatchId] = tokenDirectory;\\n        _batchIdToData[_nextBatchId] = BatchData({\\n            isSequentiallyMintable: true,\\n            batchSize: uint64(amount),\\n            sequentialMints: 0\\n        });\\n        _nextBatchId += 1;\\n        emit TokenDirectoryReleased(tokenDirectory, amount);\\n    }\\n\\n    /**\\n     * Returns a struct with the following information about a tokenId\\n     * 1. The address of the latest owner\\n     * 2. The timestamp of the latest transfer\\n     * 3. Whether or not the token was burned\\n     */\\n    function getOwnershipData(uint256 tokenId)\\n        external\\n        view\\n        returns (TokenOwnership memory)\\n    {\\n        return _ownershipOf(tokenId);\\n    }\\n\\n    /**\\n     * Returns a struct with the following information about an address\\n     * 1. The balance of the address\\n     * 2. The number of tokens minted by the address\\n     * 3. The number of tokens burned by the address\\n     * 4. Any auxillary information stored in implementing contracts.\\n     */\\n    function getAddressData(address addr)\\n        external\\n        view\\n        returns (AddressData memory)\\n    {\\n        return _addressData[addr];\\n    }\\n\\n    /**\\n     * Returns a struct with the following information about an address\\n     * 1. Is the batch still sequentially mintable and utilize 721A gas savings\\n     * 2. How make tokens are part of the batch\\n     * 3. How many tokens have been sequentially minted from this batch\\n     */\\n    function getBatchData(uint256 batchId)\\n        external\\n        view\\n        returns (BatchData memory)\\n    {\\n        return _batchIdToData[batchId];\\n    }\\n\\n    /**\\n     * Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\\n     */\\n    function _ownershipOf(uint256 tokenId)\\n        internal\\n        view\\n        returns (TokenOwnership memory)\\n    {\\n        if (!_exists(tokenId)) revert QueryForNonexistentToken();\\n\\n        uint256 curr = tokenId;\\n        TokenOwnership memory ownership = _ownerships[curr];\\n        // Invariant:\\n        // There will always be an ownership that has an address and is not burned\\n        // before an ownership that does not have an address and is not burned.\\n        // Hence, curr will not underflow.\\n        unchecked {\\n            while (true) {\\n                // Individual tokens will also return true here on the first loop\\n                if (ownership.addr != address(0)) {\\n                    return ownership;\\n                }\\n                curr--;\\n                ownership = _ownerships[curr];\\n            }\\n        }\\n        revert QueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * Gets the URI of the token based off of if it is part of a batch Directory\\n     * or if it is party of an individual token\\n     */\\n    function _getTokenURI(uint256 tokenId)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        string memory uri = _baseURI();\\n        uint256 batchId = _getBatchId(tokenId);\\n        BatchData memory batchData = _batchIdToData[batchId];\\n\\n        if (_isIndividual(batchData)) {\\n            return\\n                string(\\n                    abi.encodePacked(uri, _individualTokenMetadata[tokenId])\\n                );\\n        } else {\\n            return\\n                string(\\n                    abi.encodePacked(\\n                        uri,\\n                        batchDirectories[batchId],\\n                        \\\"/\\\",\\n                        (_getBatchIndex(tokenId)).toString()\\n                    )\\n                );\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _ownershipOf(tokenId).addr;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (string memory)\\n    {\\n        if (!_exists(tokenId)) revert QueryForNonexistentToken();\\n        return _getTokenURI(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns the total current supply of the contract.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _batchMintedCount + _individualTokensCount - _totalBurned;\\n    }\\n\\n    /**\\n     * @dev Returns the total burned tokens from the contract.\\n     */\\n    function totalBurned() public view virtual returns (uint256) {\\n        return _totalBurned;\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return baseURI;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ownerOf(tokenId);\\n        if (to == owner) revert ApprovalToCurrentOwner();\\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\\n            revert ApprovalCallerNotOwnerNorApproved();\\n        }\\n\\n        _approve(to, tokenId, owner);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address)\\n    {\\n        if (!_exists(tokenId)) revert QueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved)\\n        public\\n        virtual\\n        override\\n    {\\n        if (operator == _msgSender()) revert ApproveToCaller();\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        if (!_checkOnERC721Received(from, to, tokenId, _data)) {\\n            revert TransferToNonERC721ReceiverImplementer();\\n        }\\n    }\\n\\n    /**\\n     * @dev This is for functions which already get the ownership of the tokenId because ownerOf() in 721A\\n     * is potentially an expensive function and should not be called twice if not needed to save gas.\\n     *\\n     * WARNING this internal method expects to get passed in the TokenOwnership of the tokenId and will not\\n     * verify if it really is. It also ignores checking the owner so tokens can be loanable\\n     */\\n    function _safeTransferWithOwnershipData(\\n        TokenOwnership memory tokenOwnership,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transferWithOwnershipData(tokenOwnership, from, to, tokenId);\\n        if (!_checkOnERC721Received(from, to, tokenId, _data)) {\\n            revert TransferToNonERC721ReceiverImplementer();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        if (_ownerships[tokenId].burned) return false;\\n        // Individual tokens will always return true here once minted\\n        if (_ownerships[tokenId].addr != address(0)) return true;\\n\\n        // to save gas on multi-mints, _ownerships is not set on every batch mint token\\n        return _withinABatch(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether a tokenId is part of a batch or has an individual URI\\n     */\\n    function _withinABatch(uint256 tokenId) internal view returns (bool) {\\n        return\\n            _batchIdToData[_getBatchId(tokenId)].sequentialMints >\\n            _getBatchIndex(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(\\n        address spender,\\n        uint256 tokenId,\\n        address owner\\n    ) internal view virtual returns (bool) {\\n        if (!_exists(tokenId)) revert QueryForNonexistentToken();\\n        return (spender == owner ||\\n            getApproved(tokenId) == spender ||\\n            isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev adds another batch of NFTs that are all defined under the same token directory\\n     */\\n    function _addTokenDirectoryRelease(\\n        string memory releaseTokenDirectory,\\n        uint256 releaseAmount\\n    ) internal {\\n        if (releaseAmount > batchSize) revert OverReleaseLimit();\\n\\n        batchDirectories[_nextBatchId] = releaseTokenDirectory;\\n        _batchIdToData[_nextBatchId] = BatchData({\\n            isSequentiallyMintable: true,\\n            batchSize: uint64(releaseAmount),\\n            sequentialMints: 0\\n        });\\n        _nextBatchId += 1;\\n        emit TokenDirectoryReleased(releaseTokenDirectory, releaseAmount);\\n    }\\n\\n    /**\\n     * @dev allows updating of the token metadata\\n     */\\n    function _updateTokenDirectory(\\n        string memory newTokenDirectory,\\n        uint256 identifier,\\n        bool isBatch\\n    ) internal {\\n        if (isBatch) {\\n            if (_batchIdToData[identifier].batchSize == 0) {\\n                revert NotBatchDirectory();\\n            }\\n            batchDirectories[identifier] = newTokenDirectory;\\n        } else {\\n            if (_ownerships[identifier].addr == address(0)) {\\n                revert QueryForNonexistentToken();\\n            }\\n            _individualTokenMetadata[identifier] = newTokenDirectory;\\n        }\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        if (!_checkOnERC721Received(address(0), to, tokenId, _data)) {\\n            revert TransferToNonERC721ReceiverImplementer();\\n        }\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     * In order to save gas, _batchMintedCount is not updated here and needs to be updated when\\n     * extending this contract.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (_exists(tokenId) || _ownerships[tokenId].burned) {\\n            revert MintExistingToken();\\n        }\\n        uint256 batchId = _getBatchId(tokenId);\\n        if (_getBatchIndex(tokenId) >= _batchIdToData[batchId].batchSize) {\\n            revert OverBatchTokenLimit();\\n        }\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        if (_batchIdToData[batchId].isSequentiallyMintable) {\\n            _batchIdToData[batchId].isSequentiallyMintable = false;\\n        }\\n\\n        // Overflows are incredibly unrealistic.\\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\\n        // _batchMintedCount overflows if _batchMintedCount + 1 > 1.2e77 (2**256) - 1\\n        unchecked {\\n            _batchMintedCount += 1;\\n            _addressData[to].balance += 1;\\n            _addressData[to].numberMinted += 1;\\n\\n            _ownerships[tokenId].addr = to;\\n            _ownerships[tokenId].startTimestamp = uint64(block.timestamp);\\n        }\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Mints from a batch's `sequentialMints` to `sequentialMints + quantity` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the amount does not mint past a batche's `batchSize`\\n     * - the amount cannot be over DEFAULT_BATCH_SIZE\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _sequentialMint(\\n        address recipient,\\n        uint256 amount,\\n        uint256 batchId\\n    ) internal {\\n        if (recipient == address(0)) revert MintToZeroAddress();\\n        BatchData storage batchData = _batchIdToData[batchId];\\n        if (amount > batchSize || amount > DEFAULT_BATCH_SIZE || amount == 0) {\\n            revert InvalidBatchAmount();\\n        }\\n        if (batchData.sequentialMints + amount > batchData.batchSize) {\\n            revert OverBatchTokenLimit();\\n        }\\n        // Batch mint only works assuming that no _owners[] have been set for\\n        // tokenIds in the batch. Which is tracked by the isBatchMintable flag\\n        if (!batchData.isSequentiallyMintable) revert NotSequentiallyMintable();\\n\\n        // Overflows are incredibly unrealistic.\\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\\n        // _batchMintedCount overflows if _batchMintedCount + amount > 1.2e77 (2**256) - 1\\n        unchecked {\\n            uint256 firstNum = batchId * batchSize + batchData.sequentialMints;\\n            uint256 lastNum = firstNum + amount;\\n            uint64 timestamp = uint64(block.timestamp);\\n            // ensures ownerOf runs quickly even if user is minting a large number like 100\\n            for (uint256 i = firstNum; i < lastNum; i += seqMintLimit) {\\n                _ownerships[i].addr = recipient;\\n                _ownerships[i].startTimestamp = timestamp;\\n            }\\n\\n            // gas is cheaper for two separate loops\\n            for (uint256 i = firstNum; i < lastNum; i++) {\\n                emit Transfer(address(0), recipient, i);\\n            }\\n            _addressData[recipient].balance += uint64(amount);\\n            _addressData[recipient].numberMinted += uint64(amount);\\n            _batchMintedCount += uint64(amount);\\n\\n            batchData.sequentialMints += uint64(amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev mints an NFT from the individual block section with a given tokenURI\\n     * If the individual batch has reached full size, it will allocate\\n     * a new batch of token IDs for individual tokens.\\n     */\\n    function _mintIndividualURI(address recipient, string memory uri)\\n        internal\\n        returns (uint256)\\n    {\\n        if (recipient == address(0)) revert MintToZeroAddress();\\n\\n        uint256 tokenBatchOffset = _individualTokensCount % batchSize;\\n        if (tokenBatchOffset == 0) {\\n            _individualTokenIdBase = _nextBatchId * batchSize;\\n            _nextBatchId += 1;\\n        }\\n\\n        // Overflows are incredibly unrealistic.\\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\\n        // tokenId overflows if _nextBatchId * batchSize + tokenBatchOffset > 1.2e77 (2**256) - 1\\n        unchecked {\\n            uint256 tokenId = tokenBatchOffset + _individualTokenIdBase;\\n            _individualTokenMetadata[tokenId] = uri;\\n\\n            _beforeTokenTransfer(address(0), recipient, tokenId);\\n            _individualTokensCount += 1;\\n            _addressData[recipient].balance += 1;\\n            _addressData[recipient].numberMinted += 1;\\n\\n            _ownerships[tokenId].addr = recipient;\\n            _ownerships[tokenId].startTimestamp = uint64(block.timestamp);\\n\\n            emit Transfer(address(0), recipient, tokenId);\\n            return tokenId;\\n        }\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burnAndMint(tokenId, tokenId);\\n    }\\n\\n    /**\\n     * Slightly modified to support the ability to burn and instantly mint a different offset tokenId.\\n     */\\n    function _burnAndMint(uint256 tokenId, uint256 mintId) internal virtual {\\n        TokenOwnership memory ownership = _ownershipOf(tokenId);\\n        address owner = ownership.addr;\\n        if (!_exists(tokenId)) revert QueryForNonexistentToken();\\n\\n        bool burnAndMint = tokenId != mintId;\\n        if (burnAndMint && _exists(mintId)) revert MintExistingToken();\\n\\n        if (!_isApprovedOrOwner(_msgSender(), tokenId, owner)) {\\n            revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId, owner);\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // _totalBurned, _batchMintedCount overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            _addressData[owner].numberBurned += 1;\\n            if (burnAndMint) {\\n                _addressData[owner].numberMinted += 1;\\n                _batchMintedCount += 1;\\n\\n                _ownerships[mintId].addr = owner;\\n                _ownerships[mintId].startTimestamp = uint64(block.timestamp);\\n                emit Transfer(address(0), owner, mintId);\\n            } else {\\n                _addressData[owner].balance -= 1;\\n            }\\n\\n            _totalBurned += 1;\\n            _updateNextOwnershipIfUnset(tokenId, ownership);\\n        }\\n        _ownerships[tokenId].startTimestamp = uint64(block.timestamp);\\n        _ownerships[tokenId].burned = true;\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        TokenOwnership memory ownership = _ownershipOf(tokenId);\\n        if (!_isApprovedOrOwner(_msgSender(), tokenId, from)) {\\n            revert TransferCallerNotOwnerNorApproved();\\n        }\\n        _transferWithOwnershipData(ownership, from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev This is for functions which already get the ownership of the tokenId because ownerOf() in 721A\\n     * is potentially an expensive function and should not be called twice if not needed to save gas.\\n     *\\n     * WARNING this internal method expects to get passed in the TokenOwnership of the tokenId and will not\\n     * verify if it really is. It also ignores checking the owner so tokens can be loanable.\\n     */\\n    function _transferWithOwnershipData(\\n        TokenOwnership memory tokenOwnership,\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        if (to == address(0)) revert TransferToZeroAddress();\\n        if (tokenOwnership.addr != from) revert TransferFromIncorrectOwner();\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId, from);\\n\\n        _ownerships[tokenId].addr = to;\\n        _ownerships[tokenId].startTimestamp = uint64(block.timestamp);\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            _addressData[from].balance -= 1;\\n            _addressData[to].balance += 1;\\n\\n            _updateNextOwnershipIfUnset(tokenId, tokenOwnership);\\n        }\\n        _ownerships[tokenId].addr = to;\\n        _ownerships[tokenId].startTimestamp = uint64(block.timestamp);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * To be called from a transfer or burn if it is within the tokens that were sequentially\\n     * minted. This is because to save initial mint gas we do not set the ownership of\\n     * all the tokenIds until it is explicitly needed.\\n     *\\n     * This will do nothing if token ID is from a batch set aside for individual tokens or if\\n     * a token was minted randomly from the middle of a batch. This is gauranted by checking the\\n     * next token ID against `sequentialMints` counter.\\n     */\\n    function _updateNextOwnershipIfUnset(\\n        uint256 tokenId,\\n        TokenOwnership memory ownership\\n    ) internal {\\n        BatchData memory batchData = _batchIdToData[_getBatchId(tokenId)];\\n        if (\\n            _getBatchIndex(tokenId) + 1 < batchData.sequentialMints &&\\n            _ownerships[tokenId + 1].addr == address(0)\\n        ) {\\n            _ownerships[tokenId + 1].addr = ownership.addr;\\n            _ownerships[tokenId + 1].startTimestamp = ownership.startTimestamp;\\n        }\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(\\n        address to,\\n        uint256 tokenId,\\n        address owner\\n    ) internal virtual {\\n        if (_tokenApprovals[tokenId] != to) {\\n            _tokenApprovals[tokenId] = to;\\n            emit Approval(owner, to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try\\n                IERC721Receiver(to).onERC721Received(\\n                    _msgSender(),\\n                    from,\\n                    tokenId,\\n                    _data\\n                )\\n            returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert TransferToNonERC721ReceiverImplementer();\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature)\\n        internal\\n        pure\\n        returns (address, RecoverError)\\n    {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(\\n                vs,\\n                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n            )\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (\\n            uint256(s) >\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\n        ) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\n            );\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\n            );\\n    }\\n}\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * ERC165 bytes to add to interface array - set in parent contract\\n     * implementing this standard\\n     *\\n     * bytes4(keccak256(\\\"royaltyInfo(uint256,uint256)\\\")) == 0x2a55205a\\n     * bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\\n     * _registerInterface(_INTERFACE_ID_ERC2981);\\n     */\\n\\n    /**\\n     * @notice Called with the sale price to determine how much royalty\\n     *          is owed and to whom.\\n     * @param _tokenId - the NFT asset queried for royalty information\\n     * @param _salePrice - the sale price of the NFT asset specified by _tokenId\\n     * @return receiver - address of who should be sent the royalty payment\\n     * @return royaltyAmount - the royalty payment amount for _salePrice\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\\n/**\\n * @dev External interface of the EaselyPayout contract\\n */\\ninterface IEaselyPayout {\\n    /**\\n     * @dev Takes in a payable amount and splits it among the given royalties.\\n     * Also takes a cut of the payable amount depending on the sender and the primaryPayout address.\\n     * Ensures that this method never splits over 100% of the payin amount.\\n     */\\n    function splitPayable(\\n        address primaryPayout,\\n        address[] memory royalties,\\n        uint256[] memory bps\\n    ) external payable;\\n}\\n\\nerror BeforeStartTime();\\nerror InsufficientValue();\\nerror InvalidStartEndPrices();\\nerror InvalidStartEndTimes();\\nerror InvalidVersion();\\nerror LoansInactive();\\nerror MustHaveDualSignature();\\nerror MustHaveOwnerSignature();\\nerror MustHaveTokenOwnerSignature();\\nerror MustHaveVerifiedSignature();\\nerror NotTokenLoaner();\\nerror OverMaxRoyalties();\\nerror SaleInactive();\\nerror SellerNotOwner();\\nerror TokenOnLoan();\\nerror WithdrawSplitsTooHigh();\\n\\n/**\\n * @dev Extension of the ERC721 contract that integrates a marketplace so that simple lazy-sales\\n * do not have to be done on another contract. This saves gas fees on secondary sales because\\n * buyers will not have to pay a gas fee to setApprovalForAll for another marketplace contract after buying.\\n *\\n * Easely will help power the lazy-selling as well as lazy minting that take place on\\n * directly on the collection, which is why we take a cut of these transactions. Our cut can\\n * be publically seen in the connected EaselyPayout contract and cannot exceed 5%.\\n *\\n * Owners also set a dual signer which they can change at any time. This dual signer helps enable\\n * sales for large batches of addresses without needing to manually sign hundreds or thousands of hashes.\\n * It also makes phishing scams harder as both signatures need to be compromised before an unwanted sale can occur.\\n *\\n * Owner also has an option to allow token owners to loan their tokens to other users which makes the token\\n * untradeable until the original owner reclaims the token.\\n */\\nabstract contract ERC721Marketplace is ERC721B, Ownable, IERC2981 {\\n    using ECDSA for bytes32;\\n    using Strings for uint256;\\n\\n    // Allows token owners to loan tokens to other addresses.\\n    bool public loaningActive;\\n\\n    /* see {IEaselyPayout} for more */\\n    address public constant PAYOUT_CONTRACT_ADDRESS =\\n        0xa95850bB73459ADB9587A97F103a4A7CCe59B56E;\\n    uint256 internal constant TIME_PER_DECREMENT = 300;\\n\\n    /* Basis points or BPS are 1/100th of a percent, so 10000 basis points accounts for 100% */\\n    uint256 internal constant BPS_TOTAL = 10000;\\n    /* Max basis points for the owner for secondary sales of this collection */\\n    uint256 internal constant MAX_SECONDARY_BPS = 1000;\\n    /* Default payout percent if there is no signature set */\\n    uint256 internal constant DEFAULT_PAYOUT_BPS = 500;\\n    /* Signer for initializing splits to ensure splits were agreed upon by both parties */\\n    address internal constant VERIFIED_CONTRACT_SIGNER =\\n        0x1BAAd9BFa20Eb279d2E3f3e859e3ae9ddE666c52;\\n\\n    /*\\n     * Optional addresses to distribute referral commission for this collection\\n     *\\n     * Referral commission is taken from easely's cut\\n     */\\n    address public referralAddress;\\n    /*\\n     * Optional addresses to distribute partnership comission for this collection\\n     *\\n     * Partnership commission is taken in addition to easely's cut\\n     */\\n    address public partnershipAddress;\\n    /* Optional addresses to distribute revenue of primary sales of this collection */\\n    address public revenueShareAddress;\\n\\n    /* Enables dual address signatures to lazy mint */\\n    address public dualSignerAddress;\\n\\n    // Compiler will pack these units below together into a 256bit section\\n    /* Optional basis points for the owner for secondary sales of this collection */\\n    uint64 public ownerRoyaltyBPS;\\n    /* Basis points for easely's payout contract */\\n    uint64 public payoutBPS;\\n    /* Optional basis points for revenue sharing the owner wants to set up */\\n    uint64 public revenueShareBPS;\\n    /*\\n     * Optional basis points for collections that have been referred.\\n     *\\n     * Contracts with this will have a reduced easely's payout cut so that\\n     * the creator's cut is unaffected\\n     */\\n    uint32 public referralBPS;\\n    /*\\n     * Optional basis points for collections that require partnerships\\n     *\\n     * Contracts with this will have this fee on top of easely's payout cut because the partnership\\n     * will offer advanced web3 integration of this contract in some form beyond what easely provides.\\n     */\\n    uint32 public partnershipBPS;\\n\\n    mapping(uint256 => address) internal _tokenOwnersOnLoan;\\n    /* Mapping to the active version for all signed transactions */\\n    mapping(address => uint256) internal _addressToActiveVersion;\\n    /* Cancelled or finalized sales by hash to determine buyabliity */\\n    mapping(bytes32 => bool) internal _cancelledOrFinalizedSales;\\n\\n    // Events related to lazy selling\\n    event SaleCancelled(address indexed seller, bytes32 hash);\\n    event SaleCompleted(\\n        address indexed seller,\\n        address indexed buyer,\\n        uint256 indexed tokenId,\\n        uint256 price,\\n        bytes32 hash\\n    );\\n\\n    // Events related to loaning\\n    event LoaningActive(bool active);\\n    event Loan(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n    event LoanRetrieved(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    // Miscellaneous events\\n    event VersionChanged(address indexed seller, uint256 version);\\n    event DualSignerChanged(address newSigner);\\n    event BalanceWithdrawn(uint256 balance);\\n    event RoyaltyUpdated(uint256 bps);\\n    event WithdrawSplitsSet(\\n        address indexed revenueShareAddress,\\n        address indexed referralAddress,\\n        address indexed partnershipAddress,\\n        uint256 payoutBPS,\\n        uint256 revenueShareBPS,\\n        uint256 referralBPS,\\n        uint256 partnershipBPS\\n    );\\n\\n    /**\\n     * @dev initializes all of the addresses and percentage of withdrawn funds that\\n     * each address will get. These addresses and BPS splits must be signed by both the\\n     * verified easely wallet and the creator of the contract. If a signature is missing\\n     * the contract has a default of 5% to the easely payout wallet.\\n     */\\n    function _initWithdrawSplits(\\n        address owner_,\\n        address revenueShareAddress_,\\n        address referralAddress_,\\n        address partnershipAddress_,\\n        uint256 payoutBPS_,\\n        uint256 ownerRoyaltyBPS_,\\n        uint256 revenueShareBPS_,\\n        uint256 referralBPS_,\\n        uint256 partnershipBPS_,\\n        bytes[2] memory signatures\\n    ) internal virtual {\\n        revenueShareAddress = revenueShareAddress_;\\n        if (ownerRoyaltyBPS_ > MAX_SECONDARY_BPS) revert OverMaxRoyalties();\\n        if (signatures[1].length == 0) {\\n            if (DEFAULT_PAYOUT_BPS + revenueShareBPS_ > BPS_TOTAL) {\\n                revert WithdrawSplitsTooHigh();\\n            }\\n            ownerRoyaltyBPS = uint64(ownerRoyaltyBPS_);\\n            payoutBPS = uint64(DEFAULT_PAYOUT_BPS);\\n            revenueShareBPS = uint64(revenueShareBPS_);\\n            emit WithdrawSplitsSet(\\n                revenueShareAddress_,\\n                address(0),\\n                address(0),\\n                DEFAULT_PAYOUT_BPS,\\n                revenueShareBPS_,\\n                0,\\n                0\\n            );\\n        } else {\\n            if (\\n                payoutBPS_ + referralBPS_ + partnershipBPS_ + revenueShareBPS_ >\\n                BPS_TOTAL\\n            ) {\\n                revert WithdrawSplitsTooHigh();\\n            }\\n            bytes memory encoded = abi.encode(\\n                \\\"InitializeSplits\\\",\\n                owner_,\\n                revenueShareAddress_,\\n                referralAddress_,\\n                partnershipAddress_,\\n                payoutBPS_,\\n                revenueShareBPS_,\\n                referralBPS_,\\n                partnershipBPS_\\n            );\\n            bytes32 hash = ECDSA.toEthSignedMessageHash(keccak256(encoded));\\n            if (hash.recover(signatures[0]) != owner_) {\\n                revert MustHaveOwnerSignature();\\n            }\\n            if (hash.recover(signatures[1]) != VERIFIED_CONTRACT_SIGNER) {\\n                revert MustHaveVerifiedSignature();\\n            }\\n            referralAddress = referralAddress_;\\n            partnershipAddress = partnershipAddress_;\\n            ownerRoyaltyBPS = uint64(ownerRoyaltyBPS_);\\n            payoutBPS = uint64(payoutBPS_);\\n            revenueShareBPS = uint64(revenueShareBPS_);\\n            referralBPS = uint32(referralBPS_);\\n            partnershipBPS = uint32(partnershipBPS_);\\n            emit WithdrawSplitsSet(\\n                revenueShareAddress_,\\n                referralAddress_,\\n                partnershipAddress_,\\n                payoutBPS_,\\n                revenueShareBPS_,\\n                referralBPS_,\\n                partnershipBPS_\\n            );\\n        }\\n        emit RoyaltyUpdated(ownerRoyaltyBPS_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override(ERC721B, IERC165)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(Ownable).interfaceId ||\\n            interfaceId == type(IERC2981).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev see {IERC2981-supportsInterface}\\n     */\\n    function royaltyInfo(uint256, uint256 _salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount)\\n    {\\n        uint256 royalty = (_salePrice * ownerRoyaltyBPS) / BPS_TOTAL;\\n        return (owner(), royalty);\\n    }\\n\\n    /**\\n     * @dev See {_currentPrice}\\n     */\\n    function getCurrentPrice(uint256[4] memory pricesAndTimestamps)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _currentPrice(pricesAndTimestamps);\\n    }\\n\\n    /**\\n     * @dev Returns the current activeVersion of an address both used to create signatures\\n     * and to verify signatures of {buyToken} and {buyNewToken}\\n     */\\n    function getActiveVersion(address address_)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _addressToActiveVersion[address_];\\n    }\\n\\n    /**\\n     * This function, while callable by anybody will always ONLY withdraw the\\n     * contract's balance to:\\n     *\\n     * the owner's account\\n     * the addresses the owner has set up for revenue share\\n     * the easely payout contract cut - capped at 5% but can be lower for some users\\n     *\\n     * This is callable by anybody so that Easely can set up automatic payouts\\n     * after a contract has reached a certain minimum to save creators the gas fees\\n     * involved in withdrawing balances.\\n     */\\n    function withdrawBalance(uint256 withdrawAmount) external {\\n        if (withdrawAmount > address(this).balance) {\\n            withdrawAmount = address(this).balance;\\n        }\\n\\n        uint256 payoutBasis = withdrawAmount / BPS_TOTAL;\\n        if (revenueShareBPS > 0) {\\n            payable(revenueShareAddress).transfer(\\n                payoutBasis * revenueShareBPS\\n            );\\n        }\\n        if (referralBPS > 0) {\\n            payable(referralAddress).transfer(payoutBasis * referralBPS);\\n        }\\n        if (partnershipBPS > 0) {\\n            payable(partnershipAddress).transfer(payoutBasis * partnershipBPS);\\n        }\\n        payable(PAYOUT_CONTRACT_ADDRESS).transfer(payoutBasis * payoutBPS);\\n\\n        uint256 remainingAmount = withdrawAmount -\\n            payoutBasis *\\n            (revenueShareBPS + partnershipBPS + referralBPS + payoutBPS);\\n        payable(owner()).transfer(remainingAmount);\\n        emit BalanceWithdrawn(withdrawAmount);\\n    }\\n\\n    /**\\n     * @dev Allows the owner to change who the dual signer is\\n     */\\n    function setDualSigner(address alt) external onlyOwner {\\n        dualSignerAddress = alt;\\n        emit DualSignerChanged(alt);\\n    }\\n\\n    /**\\n     * @dev see {_setSecondary}\\n     */\\n    function setRoyaltiesBPS(uint256 newBPS) external onlyOwner {\\n        if (newBPS > MAX_SECONDARY_BPS) revert OverMaxRoyalties();\\n        ownerRoyaltyBPS = uint64(newBPS);\\n        emit RoyaltyUpdated(newBPS);\\n    }\\n\\n    /**\\n     * @dev Usable by any user to update the version that they want their signatures to check. This is helpful if\\n     * an address wants to mass invalidate their signatures without having to call cancelSale on each one.\\n     */\\n    function updateVersion(uint256 version) external {\\n        _addressToActiveVersion[_msgSender()] = version;\\n        emit VersionChanged(_msgSender(), version);\\n    }\\n\\n    /**\\n     * @dev To be updated by contract owner to allow for the loan functionality to be toggled\\n     */\\n    function setLoaningActive(bool _loaningActive) public onlyOwner {\\n        loaningActive = _loaningActive;\\n        emit LoaningActive(_loaningActive);\\n    }\\n\\n    /**\\n     * @dev Returns who is loaning the given tokenId\\n     */\\n    function tokenOwnerOnLoan(uint256 tokenId) external view returns (address) {\\n        if (!_exists(tokenId)) revert QueryForNonexistentToken();\\n        return _tokenOwnersOnLoan[tokenId];\\n    }\\n\\n    /**\\n     * @notice Allow owner to loan their tokens to other addresses\\n     */\\n    function loan(uint256 tokenId, address receiver) external {\\n        address msgSender = _msgSender();\\n        if (!loaningActive) revert LoansInactive();\\n\\n        // Transfer the token\\n        // _safeTransfer checks that msgSender is the tokenOwner\\n        _safeTransfer(msgSender, receiver, tokenId, \\\"\\\");\\n\\n        // Add it to the mapping of originally loaned tokens\\n        _tokenOwnersOnLoan[tokenId] = msgSender;\\n\\n        emit Loan(msgSender, receiver, tokenId);\\n    }\\n\\n    /**\\n     * @notice Allow owner to loan their tokens to other addresses\\n     */\\n    function retrieveLoan(uint256 tokenId) external {\\n        TokenOwnership memory ownership = _ownershipOf(tokenId);\\n        address msgSender = _msgSender();\\n        if (_tokenOwnersOnLoan[tokenId] != msgSender) revert NotTokenLoaner();\\n\\n        // Remove it from the array of loaned out tokens\\n        delete _tokenOwnersOnLoan[tokenId];\\n\\n        // Transfer the token back\\n        _safeTransferWithOwnershipData(\\n            ownership,\\n            ownership.addr,\\n            msgSender,\\n            tokenId,\\n            \\\"\\\"\\n        );\\n\\n        emit LoanRetrieved(ownership.addr, msgSender, tokenId);\\n    }\\n\\n    /**\\n     * @dev helper method get ownerRoyalties into an array form\\n     */\\n    function _ownerRoyalties() internal view returns (address[] memory) {\\n        address[] memory ownerRoyalties = new address[](1);\\n        ownerRoyalties[0] = owner();\\n        return ownerRoyalties;\\n    }\\n\\n    /**\\n     * @dev helper method get secondary BPS into array form\\n     */\\n    function _ownerBPS() internal view returns (uint256[] memory) {\\n        uint256[] memory ownerBPS = new uint256[](1);\\n        ownerBPS[0] = ownerRoyaltyBPS;\\n        return ownerBPS;\\n    }\\n\\n    /**\\n     * @dev See {ERC721-_beforeTokenTransfer}.\\n     *\\n     * makes sure tokens on loan can't be transferred\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override(ERC721B) {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n        if (_tokenOwnersOnLoan[tokenId] != address(0)) revert TokenOnLoan();\\n    }\\n\\n    /**\\n     * @dev Checks if an address is either the owner, or the approved alternate signer.\\n     */\\n    function _checkValidSigner(address signer) internal view {\\n        if (signer == owner()) return;\\n        if (dualSignerAddress == address(0)) revert MustHaveOwnerSignature();\\n        if (signer != dualSignerAddress) revert MustHaveDualSignature();\\n    }\\n\\n    /**\\n     * @dev Hash an order, returning the hash that a client must sign, including the standard message prefix\\n     * @return Hash of message prefix and order hash per Ethereum format\\n     */\\n    function _hashForSale(\\n        address owner,\\n        uint256 version,\\n        uint256 nonce,\\n        uint256 tokenId,\\n        uint256[4] memory pricesAndTimestamps\\n    ) internal view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    address(this),\\n                    block.chainid,\\n                    owner,\\n                    version,\\n                    nonce,\\n                    tokenId,\\n                    pricesAndTimestamps\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Hash an order, returning the hash that a client must sign, including the standard message prefix\\n     * @return Hash of message prefix and order hash per Ethereum format\\n     */\\n    function _hashToCheckForSale(\\n        address owner,\\n        uint256 version,\\n        uint256 nonce,\\n        uint256 tokenId,\\n        uint256[4] memory pricesAndTimestamps\\n    ) internal view returns (bytes32) {\\n        return\\n            ECDSA.toEthSignedMessageHash(\\n                _hashForSale(\\n                    owner,\\n                    version,\\n                    nonce,\\n                    tokenId,\\n                    pricesAndTimestamps\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Current price for a sale which is calculated for the case of a descending sale. So\\n     * the ending price must be less than the starting price and the timestamp is active.\\n     * Standard single fare sales will have a matching starting and ending price.\\n     */\\n    function _currentPrice(uint256[4] memory pricesAndTimestamps)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 startingPrice = pricesAndTimestamps[0];\\n        uint256 endingPrice = pricesAndTimestamps[1];\\n        uint256 startingTimestamp = pricesAndTimestamps[2];\\n        uint256 endingTimestamp = pricesAndTimestamps[3];\\n\\n        uint256 currTime = block.timestamp;\\n        if (currTime < startingTimestamp) revert BeforeStartTime();\\n        if (startingTimestamp >= endingTimestamp) revert InvalidStartEndTimes();\\n        if (startingPrice < endingPrice) revert InvalidStartEndPrices();\\n\\n        if (startingPrice == endingPrice || currTime > endingTimestamp) {\\n            return endingPrice;\\n        }\\n\\n        uint256 diff = startingPrice - endingPrice;\\n        uint256 decrements = (currTime - startingTimestamp) /\\n            TIME_PER_DECREMENT;\\n        if (decrements == 0) {\\n            return startingPrice;\\n        }\\n\\n        // decrements will equal 0 before totalDecrements does so we will not divide by 0\\n        uint256 totalDecrements = (endingTimestamp - startingTimestamp) /\\n            TIME_PER_DECREMENT;\\n\\n        return startingPrice - (diff / totalDecrements) * decrements;\\n    }\\n\\n    /**\\n     * @dev Checks if a hash has been signed by a signer, and if this contract has a dual signer,\\n     * that the dual signer has also signed the hash\\n     */\\n    function _checkHashAndSignatures(\\n        bytes32 hash,\\n        address signer,\\n        bytes memory signature,\\n        bytes memory dualSignature\\n    ) internal view {\\n        if (_cancelledOrFinalizedSales[hash]) revert SaleInactive();\\n        if (hash.recover(signature) != signer) revert MustHaveOwnerSignature();\\n        if (\\n            dualSignerAddress != address(0) &&\\n            hash.recover(dualSignature) != dualSignerAddress\\n        ) revert MustHaveDualSignature();\\n    }\\n\\n    /**\\n     * @dev Usable by the owner of any token initiate a sale for their token. This does not\\n     * lock the tokenId and the owner can freely trade their token, but doing so will\\n     * invalidate the ability for others to buy.\\n     */\\n    function hashToSignToSellToken(\\n        uint256 version,\\n        uint256 nonce,\\n        uint256 tokenId,\\n        uint256[4] memory pricesAndTimestamps\\n    ) external view returns (bytes32) {\\n        if (_msgSender() != ownerOf(tokenId)) {\\n            revert MustHaveTokenOwnerSignature();\\n        }\\n        return\\n            _hashForSale(\\n                _msgSender(),\\n                version,\\n                nonce,\\n                tokenId,\\n                pricesAndTimestamps\\n            );\\n    }\\n\\n    /**\\n     * @dev Usable to cancel hashes generated from {hashToSignToSellToken}\\n     */\\n    function cancelSale(\\n        uint256 version,\\n        uint256 nonce,\\n        uint256 tokenId,\\n        uint256[4] memory pricesAndTimestamps\\n    ) external {\\n        bytes32 hash = _hashToCheckForSale(\\n            _msgSender(),\\n            version,\\n            nonce,\\n            tokenId,\\n            pricesAndTimestamps\\n        );\\n        _cancelledOrFinalizedSales[hash] = true;\\n        emit SaleCancelled(_msgSender(), hash);\\n    }\\n\\n    /**\\n     * @dev With a hash signed by the method {hashToSignToSellToken} any user sending enough value can buy\\n     * the token from the seller. Tokens not owned by the contract owner are all considered secondary sales and\\n     * will give a cut to the owner of the contract based on the secondaryOwnerBPS.\\n     */\\n    function buyToken(\\n        address seller,\\n        uint256 version,\\n        uint256 nonce,\\n        uint256 tokenId,\\n        uint256[4] memory pricesAndTimestamps,\\n        bytes memory signature,\\n        bytes memory dualSignature\\n    ) external payable {\\n        uint256 currentPrice = _currentPrice(pricesAndTimestamps);\\n        TokenOwnership memory ownership = _ownershipOf(tokenId);\\n        if (ownership.addr != seller) revert SellerNotOwner();\\n        if (_addressToActiveVersion[seller] != version) revert InvalidVersion();\\n        if (msg.value < currentPrice) revert InsufficientValue();\\n\\n        bytes32 hash = _hashToCheckForSale(\\n            seller,\\n            version,\\n            nonce,\\n            tokenId,\\n            pricesAndTimestamps\\n        );\\n        _checkHashAndSignatures(hash, seller, signature, dualSignature);\\n        _cancelledOrFinalizedSales[hash] = true;\\n\\n        emit SaleCompleted(seller, _msgSender(), tokenId, currentPrice, hash);\\n        _safeTransferWithOwnershipData(\\n            ownership,\\n            seller,\\n            _msgSender(),\\n            tokenId,\\n            \\\"\\\"\\n        );\\n\\n        if (seller != owner()) {\\n            IEaselyPayout(PAYOUT_CONTRACT_ADDRESS).splitPayable{\\n                value: currentPrice\\n            }(seller, _ownerRoyalties(), _ownerBPS());\\n        }\\n        payable(_msgSender()).transfer(msg.value - currentPrice);\\n    }\\n}\\n\\nerror AlreadyInitiated();\\nerror ChunkAlreadyProcessed();\\nerror InvalidBurnToken();\\nerror InvalidChunk();\\nerror InvalidIndividualToken();\\nerror NotBurnable();\\n\\n/**\\n * @dev This implements a lazy-minted, multi-directory metadata storage version of ERC721Marketplace.\\n * It gives the creator flexibility to mint singular hashes at a time or entire batches of tokens under\\n * a single token directory -- commonly an IPFS hash. Batching tokens together saves an immense amount of gas,\\n * but the owner of this collection gives up some control over the tokenIds exact numbering.\\n *\\n * Each batch that the owner releases gets offset by the batchSize because doing so makes it possible\\n * to enable the same benefits as ERC721A across multiple different releases separately. This functionality\\n * makes it cheap for the contract creator to mint hundres of tokens and allow their full collection to\\n * be shown on places like opensea without needing to be bought out first.\\n *\\n * Note: This batch minting is reserved only for the contract creator and not for external buyers.\\n *\\n * It has two main methods to lazy-mint, one allows the owner to set a price for a singular token in an\\n * existing batch or set a price for a single new tokenURI that will get added to this collection.\\n */\\ncontract ERC721BatchableCollection is ERC721Marketplace {\\n    using ECDSA for bytes32;\\n    using Strings for uint256;\\n\\n    bool private hasInit = false;\\n\\n    bool public burnable;\\n    // returns if NFTs from this collection mint an NFT post burn\\n    bool public mintPostBurn;\\n\\n    // Token IDs above this are reserved for post burn NFTs\\n    uint256 public constant MAX_TOKENS = 2**128;\\n\\n    // So the owner does not repeat airdrops\\n    mapping(uint256 => bool) processedChunksForOwnerMint;\\n\\n    event OwnerMinted(uint256 chunk);\\n    event TokenBought(\\n        address indexed buyer,\\n        uint256 indexed tokenId,\\n        uint256 price,\\n        string uri,\\n        bytes32 saleHash\\n    );\\n\\n    /**\\n     * @dev Constructor function\\n     */\\n    constructor(\\n        bool[2] memory bools,\\n        address[4] memory addresses,\\n        uint256[8] memory uints,\\n        string[4] memory strings,\\n        bytes[2] memory signatures\\n    ) ERC721B(strings[0], strings[1]) {\\n        _init(bools, addresses, uints, strings, signatures);\\n    }\\n\\n    function init(\\n        bool[2] memory bools,\\n        address[4] memory addresses,\\n        uint256[8] memory uints,\\n        string[4] memory strings,\\n        bytes[2] memory signatures\\n    ) external {\\n        _init(bools, addresses, uints, strings, signatures);\\n    }\\n\\n    function _init(\\n        bool[2] memory bools,\\n        address[4] memory addresses,\\n        uint256[8] memory uints,\\n        string[4] memory strings,\\n        bytes[2] memory signatures\\n    ) internal {\\n        if (hasInit) revert AlreadyInitiated();\\n        hasInit = true;\\n\\n        burnable = bools[0];\\n        mintPostBurn = bools[1];\\n\\n        _owner = _msgSender();\\n        _initWithdrawSplits(\\n            _owner,\\n            addresses[0], // revenue share address\\n            addresses[1], // referral address\\n            addresses[2], // partnership address\\n            uints[0], // payout BPS\\n            uints[1], // owner secondary BPS\\n            uints[2], // revenue share BPS\\n            uints[3], // referral BPS\\n            uints[4], // partnership BPS\\n            signatures\\n        );\\n        _setSeqMintLimit(uints[5]);\\n        _setBatchSize(uints[6]);\\n        dualSignerAddress = addresses[3];\\n\\n        _setBaseURI(strings[2]);\\n        if (uints[7] > 0 && bytes(strings[3]).length > 0) {\\n            _addTokenDirectoryRelease(strings[3], uints[7]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Method used if the creator wants to change their name and symbol later\\n     *\\n     * If the owner of the collection calls {lockTokenURI} the name and symbol may\\n     * no longer change.\\n     */\\n    function changeNameAndSymbol(\\n        string calldata _newName,\\n        string calldata _newSymbol\\n    ) external onlyOwner {\\n        _setTokenName(_newName);\\n        _setTokenSymbol(_newSymbol);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     *\\n     * This collection's tokenURIs can be part of a batch or individual, and can\\n     * have a post_burn minted token. This function takes tokenId and finds the right\\n     * token directory saved for that token both for batch and individual tokens.\\n     */\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (string memory)\\n    {\\n        if (!_exists(tokenId)) revert QueryForNonexistentToken();\\n        if (tokenId < MAX_TOKENS) {\\n            return _getTokenURI(tokenId);\\n        }\\n\\n        string memory preBurnURI = _getTokenURI(tokenId - MAX_TOKENS);\\n        return string(abi.encodePacked(preBurnURI, \\\"/post_burn\\\"));\\n    }\\n\\n    /**\\n     * @dev see {_addTokenDirectoryRelease}\\n     */\\n    function addTokenDirectoryRelease(\\n        string memory tokenDirectory,\\n        uint256 releaseAmount\\n    ) external onlyOwner {\\n        _addTokenDirectoryRelease(tokenDirectory, releaseAmount);\\n    }\\n\\n    /**\\n     * @dev see {_updateTokenDirectory}\\n     */\\n    function changeTokenDirectory(\\n        string memory newDirectory,\\n        uint256 identifier,\\n        bool isBatch\\n    ) external onlyOwner {\\n        _updateTokenDirectory(newDirectory, identifier, isBatch);\\n    }\\n\\n    /**\\n     * @dev Only for NFTs that are already part of a defined batch\\n     */\\n    function ownerMint(\\n        address[] calldata recipients,\\n        uint256[] calldata amounts,\\n        uint256 batchId,\\n        uint256 chunk\\n    ) external onlyOwner {\\n        if (processedChunksForOwnerMint[chunk]) revert ChunkAlreadyProcessed();\\n        if (recipients.length != amounts.length) revert InvalidChunk();\\n        for (uint256 i; i < amounts.length; i++) {\\n            _sequentialMint(recipients[i], amounts[i], batchId);\\n        }\\n        processedChunksForOwnerMint[chunk] = true;\\n        emit OwnerMinted(chunk);\\n    }\\n\\n    /**\\n     * @dev see {_createBatchNFT}\\n     */\\n    function giftBatchedNFT(address giftAddress, uint256 tokenId)\\n        external\\n        onlyOwner\\n    {\\n        _safeMint(giftAddress, tokenId);\\n    }\\n\\n    /**\\n     * @dev see {_createIndividualNFT}\\n     */\\n    function giftIndividualNFT(address giftAddress, string memory uri)\\n        external\\n        onlyOwner\\n    {\\n        _mintIndividualURI(giftAddress, uri);\\n    }\\n\\n    /**\\n     * @dev Hash an order, returning the hash that a client must sign, including the standard message prefix\\n     * @return Hash of message prefix and order hash per Ethereum format\\n     */\\n    function _hashForMintingIndividual(\\n        uint256 version,\\n        uint256 nonce,\\n        uint256[4] memory pricesAndTimestamps,\\n        string memory uri\\n    ) internal view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    address(this),\\n                    block.chainid,\\n                    owner(),\\n                    version,\\n                    nonce,\\n                    pricesAndTimestamps,\\n                    uri\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Hash an order, returning the hash that a client must sign, including the standard message prefix\\n     * @return Hash of message prefix and order hash per Ethereum format\\n     */\\n    function _hashToCheckForMintingIndividual(\\n        uint256 version,\\n        uint256 nonce,\\n        uint256[4] memory pricesAndTimestamps,\\n        string memory uri\\n    ) internal view returns (bytes32) {\\n        return\\n            ECDSA.toEthSignedMessageHash(\\n                _hashForMintingIndividual(\\n                    version,\\n                    nonce,\\n                    pricesAndTimestamps,\\n                    uri\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Usable by the owner of this collection to sell a new token. The owner can decide what\\n     * the tokenURI of it will be and if the token is claimable and what the claimable hash would be\\n     */\\n    function hashToSignToSellIndividualToken(\\n        uint256 version,\\n        uint256 nonce,\\n        uint256[4] memory pricesAndTimestamps,\\n        string memory uri\\n    ) external view returns (bytes32) {\\n        _checkValidSigner(_msgSender());\\n        if (bytes(uri).length == 0) revert InvalidIndividualToken();\\n        return\\n            _hashForMintingIndividual(version, nonce, pricesAndTimestamps, uri);\\n    }\\n\\n    /**\\n     * @dev Usable to cancel hashes generated from both {hashToSignToSellNewToken} and {hashToSignToSellToken}\\n     */\\n    function cancelIndividualTokenSale(\\n        uint256 version,\\n        uint256 nonce,\\n        uint256[4] memory pricesAndTimestamps,\\n        string memory uri\\n    ) external {\\n        _checkValidSigner(_msgSender());\\n        bytes32 hash = _hashToCheckForMintingIndividual(\\n            version,\\n            nonce,\\n            pricesAndTimestamps,\\n            uri\\n        );\\n\\n        _cancelledOrFinalizedSales[hash] = true;\\n        emit SaleCancelled(_msgSender(), hash);\\n    }\\n\\n    /**\\n     * @dev With a hash signed by the method {hashToSignToSellIndividualToken} any user sending enough value can\\n     * mint the token from the contract. These are all considered primary sales and will give a cut to the\\n     * royalties defined in the contract.\\n     */\\n    function buyIndividualToken(\\n        uint256 version,\\n        uint256 nonce,\\n        uint256[4] memory pricesAndTimestamps,\\n        string memory uri,\\n        bytes memory signature,\\n        bytes memory dualSignature\\n    ) external payable {\\n        if (version != _addressToActiveVersion[owner()]) {\\n            revert InvalidVersion();\\n        }\\n\\n        uint256 currentPrice = _currentPrice(pricesAndTimestamps);\\n        if (msg.value < currentPrice) revert InsufficientValue();\\n\\n        bytes32 hash = _hashToCheckForMintingIndividual(\\n            version,\\n            nonce,\\n            pricesAndTimestamps,\\n            uri\\n        );\\n        _checkHashAndSignatures(hash, owner(), signature, dualSignature);\\n        _cancelledOrFinalizedSales[hash] = true;\\n\\n        uint256 tokenId = _mintIndividualURI(_msgSender(), uri);\\n        emit TokenBought(_msgSender(), tokenId, currentPrice, uri, hash);\\n        payable(_msgSender()).transfer(msg.value - currentPrice);\\n    }\\n\\n    /**\\n     * @dev Hash an order, returning the hash that a client must sign, including the standard message prefix\\n     * @return Hash of message prefix and order hash per Ethereum format\\n     */\\n    function _hashForMintingFromBatch(\\n        uint256 version,\\n        uint256 nonce,\\n        uint256[4] memory pricesAndTimestamps,\\n        uint256 tokenId\\n    ) internal view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    address(this),\\n                    block.chainid,\\n                    owner(),\\n                    version,\\n                    nonce,\\n                    pricesAndTimestamps,\\n                    tokenId\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Hash an order, returning the hash that a client must sign, including the standard message prefix\\n     * @return Hash of message prefix and order hash per Ethereum format\\n     */\\n    function _hashToCheckForMintingFromBatch(\\n        uint256 version,\\n        uint256 nonce,\\n        uint256[4] memory pricesAndTimestamps,\\n        uint256 tokenId\\n    ) internal view returns (bytes32) {\\n        return\\n            ECDSA.toEthSignedMessageHash(\\n                _hashForMintingFromBatch(\\n                    version,\\n                    nonce,\\n                    pricesAndTimestamps,\\n                    tokenId\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Usable by the owner of this collection to sell a new token. The owner can decide what\\n     * the tokenURI of it will be and if the token is claimable and what the claimable hash would be\\n     */\\n    function hashToSignToSellFromBatch(\\n        uint256 version,\\n        uint256 nonce,\\n        uint256[4] memory pricesAndTimestamps,\\n        uint256 tokenId\\n    ) external view returns (bytes32) {\\n        _checkValidSigner(_msgSender());\\n        if (_exists(tokenId) || _ownerships[tokenId].burned) {\\n            revert MintExistingToken();\\n        }\\n\\n        return\\n            _hashForMintingFromBatch(\\n                version,\\n                nonce,\\n                pricesAndTimestamps,\\n                tokenId\\n            );\\n    }\\n\\n    /**\\n     * @dev Usable to cancel hashes generated from both {hashToSignToSellIndividualToken} and {hashToSignToSellFromBatch}\\n     */\\n    function cancelTokenFromBatchSale(\\n        uint256 version,\\n        uint256 nonce,\\n        uint256[4] memory pricesAndTimestamps,\\n        uint256 tokenId\\n    ) external {\\n        bytes32 hash;\\n        hash = _hashToCheckForMintingFromBatch(\\n            version,\\n            nonce,\\n            pricesAndTimestamps,\\n            tokenId\\n        );\\n        _cancelledOrFinalizedSales[hash] = true;\\n        emit SaleCancelled(_msgSender(), hash);\\n    }\\n\\n    /**\\n     * @dev With a hash signed by the method {hashToSignToSellFromBatch} any user sending enough value can\\n     * mint the token from the contract. These are all considered primary sales and will give a cut to the\\n     * royalties defined in the contract.\\n     */\\n    function buyTokenFromBatch(\\n        uint256 version,\\n        uint256 nonce,\\n        uint256[4] memory pricesAndTimestamps,\\n        uint256 tokenId,\\n        bytes memory signature,\\n        bytes memory dualSignature\\n    ) external payable {\\n        if (version != _addressToActiveVersion[owner()]) {\\n            revert InvalidVersion();\\n        }\\n\\n        uint256 currentPrice = _currentPrice(pricesAndTimestamps);\\n        if (msg.value < currentPrice) revert InsufficientValue();\\n\\n        bytes32 hash = _hashToCheckForMintingFromBatch(\\n            version,\\n            nonce,\\n            pricesAndTimestamps,\\n            tokenId\\n        );\\n        _checkHashAndSignatures(hash, owner(), signature, dualSignature);\\n        _cancelledOrFinalizedSales[hash] = true;\\n\\n        _safeMint(_msgSender(), tokenId);\\n        emit TokenBought(\\n            _msgSender(),\\n            tokenId,\\n            currentPrice,\\n            batchDirectories[_getBatchId(tokenId)],\\n            hash\\n        );\\n        payable(_msgSender()).transfer(msg.value - currentPrice);\\n    }\\n\\n    /**\\n     * @dev Callable by any user who owns a token from a buurnable collection. If the collection\\n     * gas mint on burn set, they will get a newly minted token with the burn hash metadata.\\n     *\\n     * Burned tokens may refer to off-chain benefits, but these are the responsibility\\n     * of the contract creator to deliver and not on this contract.\\n     */\\n    function burn(uint256 tokenId) external {\\n        if (!burnable) revert NotBurnable();\\n        if (tokenId >= MAX_TOKENS) revert InvalidBurnToken();\\n\\n        if (mintPostBurn) {\\n            _burnAndMint(tokenId, tokenId + MAX_TOKENS);\\n        } else {\\n            _burn(tokenId);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bool[2]\",\"name\":\"bools\",\"type\":\"bool[2]\"},{\"internalType\":\"address[4]\",\"name\":\"addresses\",\"type\":\"address[4]\"},{\"internalType\":\"uint256[8]\",\"name\":\"uints\",\"type\":\"uint256[8]\"},{\"internalType\":\"string[4]\",\"name\":\"strings\",\"type\":\"string[4]\"},{\"internalType\":\"bytes[2]\",\"name\":\"signatures\",\"type\":\"bytes[2]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitiated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadySetBatchSize\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadySetSeqMintLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalToCurrentOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveToCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BeforeStartTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ChunkAlreadyProcessed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBatchAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBurnToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidChunk\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidIndividualToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStartEndPrices\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStartEndTimes\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidVersion\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LoansInactive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintExistingToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustHaveDualSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustHaveOwnerSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustHaveTokenOwnerSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustHaveVerifiedSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotBatchDirectory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotBurnable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSequentiallyMintable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotTokenLoaner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OverBatchTokenLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OverMaxRoyalties\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OverReleaseLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerNotZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SaleInactive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SellerNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenOnLoan\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawSplitsTooHigh\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"BalanceWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"BaseURIChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"DualSignerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Loan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"LoanRetrieved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"LoaningActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chunk\",\"type\":\"uint256\"}],\"name\":\"OwnerMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bps\",\"type\":\"uint256\"}],\"name\":\"RoyaltyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"SaleCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"SaleCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"SymbolChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"saleHash\",\"type\":\"bytes32\"}],\"name\":\"TokenBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenDirectory\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenDirectoryReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"VersionChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"revenueShareAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referralAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partnershipAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payoutBPS\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"revenueShareBPS\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralBPS\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"partnershipBPS\",\"type\":\"uint256\"}],\"name\":\"WithdrawSplitsSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAYOUT_CONTRACT_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenDirectory\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"releaseAmount\",\"type\":\"uint256\"}],\"name\":\"addTokenDirectoryRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"batchDirectories\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batchSize\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256[4]\",\"name\":\"pricesAndTimestamps\",\"type\":\"uint256[4]\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dualSignature\",\"type\":\"bytes\"}],\"name\":\"buyIndividualToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[4]\",\"name\":\"pricesAndTimestamps\",\"type\":\"uint256[4]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dualSignature\",\"type\":\"bytes\"}],\"name\":\"buyToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256[4]\",\"name\":\"pricesAndTimestamps\",\"type\":\"uint256[4]\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dualSignature\",\"type\":\"bytes\"}],\"name\":\"buyTokenFromBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256[4]\",\"name\":\"pricesAndTimestamps\",\"type\":\"uint256[4]\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"cancelIndividualTokenSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[4]\",\"name\":\"pricesAndTimestamps\",\"type\":\"uint256[4]\"}],\"name\":\"cancelSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256[4]\",\"name\":\"pricesAndTimestamps\",\"type\":\"uint256[4]\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelTokenFromBatchSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_newSymbol\",\"type\":\"string\"}],\"name\":\"changeNameAndSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newDirectory\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBatch\",\"type\":\"bool\"}],\"name\":\"changeTokenDirectory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dualSignerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"getActiveVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getAddressData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"balance\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"numberMinted\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"numberBurned\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"aux\",\"type\":\"uint64\"}],\"internalType\":\"struct ERC721B.AddressData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"}],\"name\":\"getBatchData\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isSequentiallyMintable\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"batchSize\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"sequentialMints\",\"type\":\"uint64\"}],\"internalType\":\"struct ERC721B.BatchData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"pricesAndTimestamps\",\"type\":\"uint256[4]\"}],\"name\":\"getCurrentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getOwnershipData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"burned\",\"type\":\"bool\"}],\"internalType\":\"struct ERC721B.TokenOwnership\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"giftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"giftBatchedNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"giftAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"giftIndividualNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256[4]\",\"name\":\"pricesAndTimestamps\",\"type\":\"uint256[4]\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"hashToSignToSellFromBatch\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256[4]\",\"name\":\"pricesAndTimestamps\",\"type\":\"uint256[4]\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"hashToSignToSellIndividualToken\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[4]\",\"name\":\"pricesAndTimestamps\",\"type\":\"uint256[4]\"}],\"name\":\"hashToSignToSellToken\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool[2]\",\"name\":\"bools\",\"type\":\"bool[2]\"},{\"internalType\":\"address[4]\",\"name\":\"addresses\",\"type\":\"address[4]\"},{\"internalType\":\"uint256[8]\",\"name\":\"uints\",\"type\":\"uint256[8]\"},{\"internalType\":\"string[4]\",\"name\":\"strings\",\"type\":\"string[4]\"},{\"internalType\":\"bytes[2]\",\"name\":\"signatures\",\"type\":\"bytes[2]\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"loan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loaningActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPostBurn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chunk\",\"type\":\"uint256\"}],\"name\":\"ownerMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerRoyaltyBPS\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partnershipAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partnershipBPS\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payoutBPS\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralBPS\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"retrieveLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revenueShareAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revenueShareBPS\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seqMintLimit\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"alt\",\"type\":\"address\"}],\"name\":\"setDualSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_loaningActive\",\"type\":\"bool\"}],\"name\":\"setLoaningActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBPS\",\"type\":\"uint256\"}],\"name\":\"setRoyaltiesBPS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenOwnerOnLoan\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"updateVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC721BatchableCollection", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}