{"status": "1", "message": "OK", "result": [{"SourceCode": "// contracts/IPFSConvert.sol\r\n// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @title Hightable OG NFT\r\n/// @author Teahouse Finance\r\nlibrary IPFSConvert {\r\n\r\n    bytes constant private CODE_STRING = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\r\n    bytes constant private CIDV0HEAD = \"\\x00\\x04\\x28\\x0b\\x12\\x17\\x09\\x28\\x31\\x00\\x12\\x04\\x28\\x20\\x25\\x25\\x22\\x31\\x1b\\x1d\\x39\\x29\\x09\\x26\\x1b\\x29\\x0b\\x02\\x0a\\x18\\x25\\x22\\x24\\x1b\\x39\\x2c\\x1d\\x39\\x07\\x06\\x29\\x25\\x13\\x15\\x2c\\x17\";\r\n\r\n    /**\r\n     * @dev This function converts an 256 bits hash value into IPFS CIDv0 hash string.\r\n     * @param _cidv0 256 bits hash value (not including the 0x12 0x20 signature)\r\n     * @return IPFS CIDv0 hash string (Qm...)\r\n     */\r\n    function cidv0FromBytes32(bytes32 _cidv0) public pure returns (string memory) {\r\n        unchecked {\r\n            // convert to base58\r\n            bytes memory result = new bytes(46);        // 46 is the longest possible base58 result from CIDv0\r\n            uint256 resultLen = 45;\r\n            uint256 number = uint256(_cidv0);\r\n            while(number > 0) {\r\n                uint256 rem = number % 58;\r\n                result[resultLen] = bytes1(uint8(rem));\r\n                resultLen--;\r\n                number = number / 58;\r\n            }\r\n\r\n            // add 0x1220 in front of _cidv0\r\n            uint256 i;\r\n            for (i = 0; i < 46; i++) {\r\n                uint8 r = uint8(result[45 - i]) + uint8(CIDV0HEAD[i]);\r\n                if (r >= 58) {\r\n                    result[45 - i] = bytes1(r - 58);\r\n                    result[45 - i - 1] = bytes1(uint8(result[45 - i - 1]) + 1);\r\n                }\r\n                else {\r\n                    result[45 - i] = bytes1(r);\r\n                }\r\n            }\r\n\r\n            // convert to characters\r\n            for (i = 0; i < 46; i++) {\r\n                result[i] = CODE_STRING[uint8(result[i])];\r\n            }\r\n\r\n            return string(result);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cidv0\",\"type\":\"bytes32\"}],\"name\":\"cidv0FromBytes32\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "IPFSConvert", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://aa079920a6fe3bb1d45bfe263637612a146dea89a9ef610e8d8c30050aa31eea"}]}