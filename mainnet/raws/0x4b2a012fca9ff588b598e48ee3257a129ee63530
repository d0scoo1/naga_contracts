{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\n\r\npragma solidity 0.7.6;\r\n\r\nlibrary SafeMath {\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface ERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender,address recipient,uint256 amount) external returns (bool);\r\n}\r\n\r\n// this contract is used to create a lock or vesting schedule with consists of a series of token locks\r\n// owned by an address where each lock has an amount of tokens that become available to withdraw\r\n// after a specified amount of time. Each lock per address created is charged a small eth fee unless\r\n// the creator is exempt from fee or owns a token with a minimum balance that grants exemption\r\ncontract LockTokens {\r\n    using SafeMath for uint256;\r\n\r\n    struct Lock {\r\n        uint256 lockID;\r\n        address createdBy;\r\n        address tokenAddress;\r\n        address ownerAddress;\r\n        uint256 amount;\r\n        uint256 unlockedAtTime;\r\n        uint256 lockCreatedAtTime;\r\n        bool hasWithdrawn;\r\n    }\r\n\r\n    address public owner;\r\n    address payable private feeCollector; //address for fees\r\n\r\n    uint256 public ethFeePerLock; //eth fee per address that a vest is created for\r\n    mapping(address => bool) addressExemptFromFee; //addresses not charged fee\r\n    mapping(address => bool) public feeExemptToken; // map if holding a token provides fee exemption\r\n    mapping(address => uint256) public tokenBalanceThreshold; // map token to required balance for fee exemption\r\n\r\n    uint256 public lockID; //current id\r\n    mapping (uint256 => Lock) public tokenLocked; // map id to lock parameters\r\n\r\n    //maps creator, owner, and token contract to token ids\r\n    mapping (address => uint256[]) public locksCreatedByAddress;\r\n    mapping (address => uint256[]) public locksOwnedByAddress;\r\n    mapping (address => uint256[]) public locksByTokenAddress;\r\n    \r\n    //parameters for reentracy guard modifier\r\n    uint256 private constant functionCalled = 1;\r\n    uint256 private constant functionComplete = 2;\r\n    uint256 private status;\r\n\r\n    constructor(){\r\n        owner = msg.sender;\r\n        ethFeePerLock = 1e16;\r\n    }\r\n\r\n    //ensure resilience against re-entry attacks for function calls\r\n    modifier ReEntrancyGuard {\r\n        require(status != functionCalled);\r\n        status = functionCalled;\r\n        _;\r\n        status = functionComplete;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    event TokensLocked(address TokenAddress, address LockCreator, address LockOwner, uint256 Amount,uint256 UnlockedAtTime);\r\n    event TokensWithdrawn(uint256 LockID, address WithdrawnBy, uint256 Amount);\r\n    event LockExtended(uint256 LockID, uint256 PreviousUnlockTime, uint256 NewUnlockTime);\r\n    event LockOwnershipTransferred(uint256 LockID, address PreviousOwner, address NewOwner);\r\n    event LockBalanceIncreased(address Supplier,uint256 LockID,uint256 Amount);\r\n\r\n    // creates a single lock for small fee unless exempt and maps lock id to creator, owner, and token address. Msg.sender must apporve token amount priro\r\n    function lockTokens(address _tokenExemption, address _tokenAddress,address _ownerAddress,uint256 _amount,uint256 _unlockedAtTime) public payable ReEntrancyGuard{\r\n        //fee checks\r\n        bool takeFee = true;\r\n        // check if msg.sender is exempt from fee, check balances for tokens that grant fee exemption\r\n        if(addressExemptFromFee[msg.sender] || (feeExemptToken[_tokenExemption] && (ERC20(_tokenExemption).balanceOf(msg.sender) >= tokenBalanceThreshold[_tokenExemption]))){\r\n             takeFee = false;\r\n        }\r\n        if(takeFee) require(msg.value == ethFeePerLock, \"Fee amount invalid\");\r\n        //token balance and transfer checks\r\n        require(_amount > 0, \"Must be more than 0\");\r\n        require(ERC20(_tokenAddress).balanceOf(msg.sender)>= _amount, \"Insuffecient balance\");\r\n        require(ERC20(_tokenAddress).transferFrom(msg.sender, address(this), _amount), \"Transfer failed\");\r\n        //lock info recorded\r\n        uint256 _thisLockID = ++lockID;\r\n        locksCreatedByAddress[msg.sender].push(_thisLockID);\r\n        locksOwnedByAddress[_ownerAddress].push(_thisLockID);\r\n        locksByTokenAddress[_tokenAddress].push(_thisLockID);\r\n        Lock memory lock = Lock(_thisLockID, msg.sender, _tokenAddress, _ownerAddress, _amount, _unlockedAtTime, block.timestamp, false);\r\n        tokenLocked[_thisLockID] = lock;\r\n\r\n        emit TokensLocked(_tokenAddress, msg.sender, _ownerAddress, _amount, _unlockedAtTime);\r\n    }\r\n\r\n     //takes list of addresses to create a vest for which consists of locks, each with a time and amount that unlocks\r\n    function createVest(address _tokenExemption, address _tokenAddress, address[] calldata _vestOwnersAddresses, uint256 _totalAmount, uint256[] calldata _unlockTimes, uint256[] calldata _unlockAmounts) public payable ReEntrancyGuard {\r\n        //fee checks\r\n        bool takeFee = true;\r\n        // check if msg.sender is exempt from fee, check balances for tokens that grant fee exemption\r\n        if(addressExemptFromFee[msg.sender] || (feeExemptToken[_tokenExemption] && (ERC20(_tokenExemption).balanceOf(msg.sender) >= tokenBalanceThreshold[_tokenExemption]))){\r\n             takeFee = false;\r\n        }\r\n        //fee cost is ethFeePerLock multiplied by number of addresses vested for\r\n        uint256 feeCost = ethFeePerLock.mul(_vestOwnersAddresses.length);\r\n        if(takeFee) require(msg.value == feeCost, \"Fee amount invalid\");\r\n\r\n        //ensure number of locks per vest have corresponding unlock times and amounts\r\n        require(_unlockTimes.length == _unlockAmounts.length, \"Array sizes must match\");\r\n        \r\n        //sum total token amount from all vests for all addresses\r\n        uint256 _sumOfUnlockAmounts;\r\n        for(uint256 i = 0; i < _unlockAmounts.length; i++){\r\n            _sumOfUnlockAmounts += _unlockAmounts[i];\r\n        }\r\n        uint256 _totalVestAmount = _sumOfUnlockAmounts.mul(_vestOwnersAddresses.length);\r\n        require(_totalAmount > 0 && _totalAmount == _totalVestAmount, \"Invalid amount input\");\r\n\r\n        //check msg.sender for total tokens vested and approve for transfer\r\n        require(ERC20(_tokenAddress).balanceOf(msg.sender) >= _totalAmount, \"Insufficient balance\");\r\n        //transfer total amount to this address for vests\r\n        require(ERC20(_tokenAddress).transferFrom(msg.sender, address(this), _totalAmount), \"Transfer failed\");\r\n\r\n        // for each address in array, create the series of locks from array of unlock times and amounts\r\n        for(uint256 i = 0; i < _vestOwnersAddresses.length; i++){\r\n            for(uint256 j = 0; j < _unlockTimes.length; j++){\r\n                //create new lock and record details\r\n                _lockTokens(msg.sender, _tokenAddress, _vestOwnersAddresses[i], _unlockAmounts[j], _unlockTimes[j]);\r\n                emit TokensLocked(_tokenAddress, msg.sender, _vestOwnersAddresses[i], _unlockAmounts[j], _unlockTimes[j]);\r\n          }\r\n        }                \r\n    }\r\n\r\n    // used by createVest function to avoid stack too deep, creates a lock for parameters during array loop\r\n    function _lockTokens(address _createdBy, address _tokenAddress, address _ownerAddress, uint256 _amount, uint256 _unlockedAtTime) private {\r\n        //lock info recorded\r\n        uint256 _thisLockID = ++lockID;\r\n        locksCreatedByAddress[msg.sender].push(_thisLockID);\r\n        locksOwnedByAddress[_ownerAddress].push(_thisLockID);\r\n        locksByTokenAddress[_tokenAddress].push(_thisLockID);\r\n        Lock memory lock = Lock(_thisLockID, _createdBy, _tokenAddress, _ownerAddress, _amount, _unlockedAtTime, block.timestamp, false);\r\n        tokenLocked[_thisLockID] = lock;\r\n    }\r\n\r\n    // allows owner of lock to withdraw tokens if unlock time has passed and lock not already withdrawn\r\n    function withdrawAllTokens(uint256 _lockID) public ReEntrancyGuard {\r\n        require(block.timestamp >= tokenLocked[_lockID].unlockedAtTime, \"Timed lock has not expired\");\r\n        require(msg.sender == tokenLocked[_lockID].ownerAddress, \"Not authorized to withdraw\");\r\n        require(!tokenLocked[_lockID].hasWithdrawn, \"Lock already withdrawn\");        \r\n        require(ERC20(tokenLocked[_lockID].tokenAddress).transfer(msg.sender, tokenLocked[_lockID].amount), \"Tokens not withdrawn\");\r\n\r\n        tokenLocked[_lockID].hasWithdrawn = true;\r\n\r\n        emit TokensWithdrawn(_lockID, msg.sender, tokenLocked[_lockID].amount);\r\n    }\r\n\r\n    //owner can choose to extend lock period if needed\r\n    function extendLock(uint256 _lockID, uint256 _newUnlockTime) public ReEntrancyGuard{\r\n        require(msg.sender == tokenLocked[_lockID].ownerAddress);\r\n        require(_newUnlockTime > tokenLocked[_lockID].unlockedAtTime);\r\n            \r\n        uint256 previousUnlockAtTime = tokenLocked[_lockID].unlockedAtTime;\r\n        tokenLocked[_lockID].unlockedAtTime = _newUnlockTime;\r\n\r\n        emit LockExtended(_lockID, previousUnlockAtTime, _newUnlockTime);\r\n    }\r\n\r\n    //increase tokens available in a specific vested lock\r\n    function addToLock(uint256 _lockID, address _tokenAddress, uint256 _amount) public ReEntrancyGuard{\r\n        require(_amount > 0, \"Invalid amount\");\r\n        require(tokenLocked[_lockID].unlockedAtTime > block.timestamp, \"Lock has expired\");\r\n        require(tokenLocked[_lockID].tokenAddress == _tokenAddress, \"Token not held in lock\");\r\n        require(ERC20(_tokenAddress).balanceOf(msg.sender) >= _amount, \"Insuffecient balance\");\r\n        require(ERC20(_tokenAddress).approve(address(this), _amount), \"Must approve to transfer\");\r\n        require(ERC20(_tokenAddress).transferFrom(msg.sender, address(this), _amount), \"Tokens not transferred\");\r\n\r\n        tokenLocked[_lockID].amount = tokenLocked[_lockID].amount.add(_amount);\r\n\r\n        emit LockBalanceIncreased(msg.sender, _lockID, _amount);\r\n    }\r\n\r\n\r\n    function getTokenLockInformation(uint256 _lockID) view external returns(address, address, uint256, uint256, uint256, bool){\r\n        return(tokenLocked[_lockID].tokenAddress,tokenLocked[_lockID].ownerAddress,tokenLocked[_lockID].amount,tokenLocked[_lockID].unlockedAtTime,tokenLocked[_lockID].lockCreatedAtTime,tokenLocked[_lockID].hasWithdrawn);\r\n    }\r\n\r\n    function getTokenLocksCreatedByAddress(address _locksCreatedByAddress) view external returns( uint256[] memory){\r\n        return locksCreatedByAddress[_locksCreatedByAddress];\r\n    }\r\n\r\n    function getLockedTokensOwnedByAddress(address _locksOwnedByAddress) view external returns(uint256[] memory){\r\n        return locksOwnedByAddress[_locksOwnedByAddress];\r\n    }\r\n    function getLockedTokensByTokenAddress(address _tokenAddress) view external returns(uint256[] memory){\r\n        return locksByTokenAddress[_tokenAddress];\r\n    }\r\n\r\n    //transfer ownership of vest\r\n    function transferVestOwnerShip(uint256 _lockID, address _newOwner) external {\r\n        require(msg.sender == tokenLocked[_lockID].ownerAddress, \"Not owner\");\r\n        tokenLocked[_lockID].ownerAddress = _newOwner;\r\n        emit LockOwnershipTransferred(_lockID, msg.sender, _newOwner);\r\n    }\r\n\r\n    function setFeeCollectorWallet(address payable _feeCollector) external onlyOwner{\r\n        feeCollector = _feeCollector;\r\n    }\r\n\r\n    function setETHFee(uint256 _fee) external onlyOwner{\r\n        ethFeePerLock = _fee;\r\n    }\r\n\r\n    function getTime() external view returns(uint256){\r\n        return block.timestamp;\r\n    }\r\n\r\n    function transferContracOwnership(address _newOwner) external onlyOwner{\r\n        owner = _newOwner;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Supplier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"LockID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"LockBalanceIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"LockID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"PreviousUnlockTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"NewUnlockTime\",\"type\":\"uint256\"}],\"name\":\"LockExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"LockID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"PreviousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"NewOwner\",\"type\":\"address\"}],\"name\":\"LockOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"TokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"LockCreator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"LockOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"UnlockedAtTime\",\"type\":\"uint256\"}],\"name\":\"TokensLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"LockID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"WithdrawnBy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addToLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenExemption\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_vestOwnersAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_unlockTimes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_unlockAmounts\",\"type\":\"uint256[]\"}],\"name\":\"createVest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethFeePerLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newUnlockTime\",\"type\":\"uint256\"}],\"name\":\"extendLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeExemptToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"getLockedTokensByTokenAddress\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_locksOwnedByAddress\",\"type\":\"address\"}],\"name\":\"getLockedTokensOwnedByAddress\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockID\",\"type\":\"uint256\"}],\"name\":\"getTokenLockInformation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_locksCreatedByAddress\",\"type\":\"address\"}],\"name\":\"getTokenLocksCreatedByAddress\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenExemption\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unlockedAtTime\",\"type\":\"uint256\"}],\"name\":\"lockTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"locksByTokenAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"locksCreatedByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"locksOwnedByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setETHFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollectorWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalanceThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"createdBy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockedAtTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockCreatedAtTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasWithdrawn\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferContracOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferVestOwnerShip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockID\",\"type\":\"uint256\"}],\"name\":\"withdrawAllTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LockTokens", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e128937eea03ff93b192947344a3d13bad1d4791f3de831a3bd3055594d033ea"}]}