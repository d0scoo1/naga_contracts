{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/pools/FactoryRouter.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\nimport \\\"./balancer/BFactory.sol\\\";\\nimport \\\"../interfaces/IFactory.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IFixedRateExchange.sol\\\";\\nimport \\\"../interfaces/IPool.sol\\\";\\nimport \\\"../interfaces/IDispenser.sol\\\";\\nimport \\\"../utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\ncontract FactoryRouter is BFactory, IFactoryRouter {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n    address public routerOwner;\\n    address public factory;\\n    address public fixedRate;\\n    uint256 public minVestingPeriodInBlocks = 2426000;\\n\\n    uint256 public swapOceanFee = 1e15; //0.1%\\n    uint256 public swapNonOceanFee = 2e15;  // 0.2%\\n    uint256 public consumeFee = 3e16; // 0.03 DT\\n    uint256 public providerFee = 0; // 0%\\n    address[] public approvedTokens;\\n    address[] public ssContracts;\\n    address[] public fixedrates;\\n    address[] public dispensers;\\n    // mapping(address => bool) public approvedTokens;\\n    // mapping(address => bool) public ssContracts;\\n    // mapping(address => bool) public fixedPrice;\\n    // mapping(address => bool) public dispenser;\\n\\n    event NewPool(address indexed poolAddress, bool isOcean);\\n    event VestingPeriodChanges(address indexed caller, uint256 minVestingPeriodInBlocks);\\n    event RouterChanged(address indexed caller, address indexed newRouter);\\n    event FactoryContractChanged(\\n        address indexed caller,\\n        address indexed contractAddress\\n    );\\n    event TokenAdded(address indexed caller, address indexed token);\\n    event TokenRemoved(address indexed caller, address indexed token);\\n    event SSContractAdded(\\n        address indexed caller,\\n        address indexed contractAddress\\n    );\\n    event SSContractRemoved(\\n        address indexed caller,\\n        address indexed contractAddress\\n    );\\n    event FixedRateContractAdded(\\n        address indexed caller,\\n        address indexed contractAddress\\n    );\\n    event FixedRateContractRemoved(\\n        address indexed caller,\\n        address indexed contractAddress\\n    );\\n    event DispenserContractAdded(\\n        address indexed caller,\\n        address indexed contractAddress\\n    );\\n    event DispenserContractRemoved(\\n        address indexed caller,\\n        address indexed contractAddress\\n    );\\n\\n    event OPCFeeChanged(address indexed caller, uint256 newSwapOceanFee,\\n        uint256 newSwapNonOceanFee, uint256 newConsumeFee, uint256 newProviderFee);\\n\\n    modifier onlyRouterOwner() {\\n        require(routerOwner == msg.sender, \\\"OceanRouter: NOT OWNER\\\");\\n        _;\\n    }\\n\\n    event OPCCollectorChanged(address indexed caller, address indexed _newOpcCollector);\\n\\n    constructor(\\n        address _routerOwner,\\n        address _oceanToken,\\n        address _bpoolTemplate,\\n        address _opcCollector,\\n        address[] memory _preCreatedPools\\n    ) BFactory(_bpoolTemplate, _opcCollector, _preCreatedPools) {\\n        require(\\n            _routerOwner != address(0),\\n            \\\"FactoryRouter: Invalid router owner\\\"\\n        );\\n        require(\\n            _opcCollector != address(0),\\n            \\\"FactoryRouter: Invalid opcCollector\\\"\\n        );\\n        require(\\n            _oceanToken != address(0),\\n            \\\"FactoryRouter: Invalid Ocean Token address\\\"\\n        );\\n        routerOwner = _routerOwner;\\n        opcCollector = _opcCollector;\\n        _addApprovedToken(_oceanToken);\\n    }\\n\\n    function changeRouterOwner(address _routerOwner) external onlyRouterOwner {\\n        require(_routerOwner != address(0), \\\"Invalid new router owner\\\");\\n        routerOwner = _routerOwner;\\n        emit RouterChanged(msg.sender, _routerOwner);\\n    }\\n\\n    /**\\n     * @dev addApprovedToken\\n     *      Adds a token to the list of tokens with reduced fees\\n     *  @param tokenAddress address Token to be added\\n     */\\n    function addApprovedToken(address tokenAddress) external onlyRouterOwner {\\n        _addApprovedToken(tokenAddress);\\n    }\\n    \\n    function _addApprovedToken(address tokenAddress) internal {\\n        if(!isApprovedToken(tokenAddress)){\\n            approvedTokens.push(tokenAddress);\\n            emit TokenAdded(msg.sender, tokenAddress);\\n        }\\n    }\\n\\n    /**\\n     * @dev removeApprovedToken\\n     *      Removes a token if exists from the list of tokens with reduced fees\\n     *  @param tokenAddress address Token to be removed\\n     */\\n    function removeApprovedToken(address tokenAddress)\\n        external\\n        onlyRouterOwner\\n    {\\n        require(\\n            tokenAddress != address(0),\\n            \\\"FactoryRouter: Invalid Ocean Token address\\\"\\n        );\\n        uint256 i;\\n        for (i = 0; i < approvedTokens.length; i++) {\\n            if(approvedTokens[i] == tokenAddress) break;\\n        }\\n        if(i < approvedTokens.length){\\n            approvedTokens[i] = approvedTokens[approvedTokens.length -1];\\n            approvedTokens.pop();\\n            emit TokenRemoved(msg.sender, tokenAddress);\\n        }\\n    }\\n    /**\\n     * @dev isApprovedToken\\n     *      Returns true if token exists in the list of tokens with reduced fees\\n     *  @param tokenAddress address Token to be checked\\n     */\\n    function isApprovedToken(address tokenAddress) public view returns(bool) {\\n        for (uint256 i = 0; i < approvedTokens.length; i++) {\\n            if(approvedTokens[i] == tokenAddress) return true;\\n        }\\n        return false;\\n    }\\n    /**\\n     * @dev getApprovedTokens\\n     *      Returns the list of tokens with reduced fees\\n     */\\n    function getApprovedTokens() public view returns(address[] memory) {\\n        return(approvedTokens);\\n    }\\n\\n\\n     /**\\n     * @dev addSSContract\\n     *      Adds a token to the list of ssContracts\\n     *  @param _ssContract address Contract to be added\\n     */\\n\\n    function addSSContract(address _ssContract) external onlyRouterOwner {\\n        require(\\n            _ssContract != address(0),\\n            \\\"FactoryRouter: Invalid _ssContract address\\\"\\n        );\\n        if(!isSSContract(_ssContract)){\\n            ssContracts.push(_ssContract);\\n            emit SSContractAdded(msg.sender, _ssContract);\\n        }\\n    }\\n    /**\\n     * @dev removeSSContract\\n     *      Removes a token if exists from the list of ssContracts\\n     *  @param _ssContract address Contract to be removed\\n     */\\n\\n    function removeSSContract(address _ssContract) external onlyRouterOwner {\\n        require(\\n            _ssContract != address(0),\\n            \\\"FactoryRouter: Invalid _ssContract address\\\"\\n        );\\n        uint256 i;\\n        for (i = 0; i < ssContracts.length; i++) {\\n            if(ssContracts[i] == _ssContract) break;\\n        }\\n        if(i < ssContracts.length){\\n            // it's in the array\\n            ssContracts[i] = ssContracts[ssContracts.length -1];\\n            ssContracts.pop();\\n            emit SSContractRemoved(msg.sender, _ssContract);\\n        }\\n    }\\n\\n    /**\\n     * @dev isSSContract\\n     *      Returns true if token exists in the list of ssContracts\\n     *  @param _ssContract  address Contract to be checked\\n     */\\n    function isSSContract(address _ssContract) public view returns(bool) {\\n        for (uint256 i = 0; i < ssContracts.length; i++) {\\n            if(ssContracts[i] == _ssContract) return true;\\n        }\\n        return false;\\n    }\\n    /**\\n     * @dev getSSContracts\\n     *      Returns the list of ssContracts\\n     */\\n    function getSSContracts() public view returns(address[] memory) {\\n        return(ssContracts);\\n    }\\n\\n    function addFactory(address _factory) external onlyRouterOwner {\\n        require(\\n            _factory != address(0),\\n            \\\"FactoryRouter: Invalid _factory address\\\"\\n        );\\n        require(factory == address(0), \\\"FACTORY ALREADY SET\\\");\\n        factory = _factory;\\n        emit FactoryContractChanged(msg.sender, _factory);\\n    }\\n\\n\\n    /**\\n     * @dev addFixedRateContract\\n     *      Adds an address to the list of fixed rate contracts\\n     *  @param _fixedRate address Contract to be added\\n     */\\n    function addFixedRateContract(address _fixedRate) external onlyRouterOwner {\\n        require(\\n            _fixedRate != address(0),\\n            \\\"FactoryRouter: Invalid _fixedRate address\\\"\\n        );\\n        if(!isFixedRateContract(_fixedRate)){\\n            fixedrates.push(_fixedRate);\\n            emit FixedRateContractAdded(msg.sender, _fixedRate);\\n        }\\n    }\\n     /**\\n     * @dev removeFixedRateContract\\n     *      Removes an address from the list of fixed rate contracts\\n     *  @param _fixedRate address Contract to be removed\\n     */\\n    function removeFixedRateContract(address _fixedRate)\\n        external\\n        onlyRouterOwner\\n    {\\n        require(\\n            _fixedRate != address(0),\\n            \\\"FactoryRouter: Invalid _fixedRate address\\\"\\n        );\\n        uint256 i;\\n        for (i = 0; i < fixedrates.length; i++) {\\n            if(fixedrates[i] == _fixedRate) break;\\n        }\\n        if(i < fixedrates.length){\\n            // it's in the array\\n            fixedrates[i] = fixedrates[fixedrates.length -1];\\n            fixedrates.pop();\\n            emit FixedRateContractRemoved(msg.sender, _fixedRate);\\n        }\\n    }\\n    /**\\n     * @dev isFixedRateContract\\n     *      Removes true if address exists in the list of fixed rate contracts\\n     *  @param _fixedRate address Contract to be checked\\n     */\\n    function isFixedRateContract(address _fixedRate) public view returns(bool) {\\n        for (uint256 i = 0; i < fixedrates.length; i++) {\\n            if(fixedrates[i] == _fixedRate) return true;\\n        }\\n        return false;\\n    }\\n    /**\\n     * @dev getFixedRatesContracts\\n     *      Returns the list of fixed rate contracts\\n     */\\n    function getFixedRatesContracts() public view returns(address[] memory) {\\n        return(fixedrates);\\n    }\\n\\n    /**\\n     * @dev addDispenserContract\\n     *      Adds an address to the list of dispensers\\n     *  @param _dispenser address Contract to be added\\n     */\\n    function addDispenserContract(address _dispenser) external onlyRouterOwner {\\n        require(\\n            _dispenser != address(0),\\n            \\\"FactoryRouter: Invalid _dispenser address\\\"\\n        );\\n          if(!isDispenserContract(_dispenser)){\\n            dispensers.push(_dispenser);\\n            emit DispenserContractAdded(msg.sender, _dispenser);\\n        }\\n    }\\n\\n    /**\\n     * @dev removeDispenserContract\\n     *      Removes an address from the list of dispensers\\n     *  @param _dispenser address Contract to be removed\\n     */\\n    function removeDispenserContract(address _dispenser)\\n        external\\n        onlyRouterOwner\\n    {\\n        require(\\n            _dispenser != address(0),\\n            \\\"FactoryRouter: Invalid _dispenser address\\\"\\n        );\\n        uint256 i;\\n        for (i = 0; i < dispensers.length; i++) {\\n            if(dispensers[i] == _dispenser) break;\\n        }\\n        if(i < dispensers.length){\\n            // it's in the array\\n            dispensers[i] = dispensers[dispensers.length -1];\\n            dispensers.pop();\\n            emit DispenserContractRemoved(msg.sender, _dispenser);\\n        }\\n    }\\n    /**\\n     * @dev isDispenserContract\\n     *      Returns true if address exists in the list of dispensers\\n     *  @param _dispenser  address Contract to be checked\\n     */\\n    function isDispenserContract(address _dispenser) public view returns(bool) {\\n        for (uint256 i = 0; i < dispensers.length; i++) {\\n            if(dispensers[i] == _dispenser) return true;\\n        }\\n        return false;\\n    }\\n    /**\\n     * @dev getDispensersContracts\\n     *      Returns the list of fixed rate contracts\\n     */\\n    function getDispensersContracts() public view returns(address[] memory) {\\n        return(dispensers);\\n    }\\n\\n    /**\\n     * @dev getOPCFee\\n     *      Gets OP Community Fees for a particular token\\n     * @param baseToken  address token to be checked\\n     */\\n    function getOPCFee(address baseToken) public view returns (uint256) {\\n        if (isApprovedToken(baseToken)) {\\n            return swapOceanFee;\\n        } else return swapNonOceanFee;\\n    }\\n\\n    /**\\n     * @dev getOPCFees\\n     *      Gets OP Community Fees for approved tokens and non approved tokens\\n     */\\n    function getOPCFees() public view returns (uint256,uint256) {\\n        return (swapOceanFee, swapNonOceanFee);\\n    }\\n\\n    /**\\n     * @dev getConsumeFee\\n     *      Gets OP Community Fee cuts for consume fees\\n     */\\n    function getOPCConsumeFee() public view returns (uint256) {\\n        return consumeFee;\\n    }\\n\\n    /**\\n     * @dev getOPCProviderFee\\n     *      Gets OP Community Fee cuts for provider fees\\n     */\\n    function getOPCProviderFee() public view returns (uint256) {\\n        return providerFee;\\n    }\\n\\n\\n    /**\\n     * @dev updateOPCFee\\n     *      Updates OP Community Fees\\n     * @param _newSwapOceanFee Amount charged for swapping with ocean approved tokens\\n     * @param _newSwapNonOceanFee Amount charged for swapping with non ocean approved tokens\\n     * @param _newConsumeFee Amount charged from consumeFees\\n     * @param _newProviderFee Amount charged for providerFees\\n     */\\n    function updateOPCFee(uint256 _newSwapOceanFee, uint256 _newSwapNonOceanFee,\\n        uint256 _newConsumeFee, uint256 _newProviderFee) external onlyRouterOwner {\\n\\n        swapOceanFee = _newSwapOceanFee;\\n        swapNonOceanFee = _newSwapNonOceanFee;\\n        consumeFee = _newConsumeFee;\\n        providerFee = _newProviderFee;\\n        emit OPCFeeChanged(msg.sender, _newSwapOceanFee, _newSwapNonOceanFee, _newConsumeFee, _newProviderFee);\\n    }\\n\\n    /*\\n     * @dev getMinVestingPeriod\\n     *      Returns current minVestingPeriodInBlocks\\n       @return minVestingPeriodInBlocks\\n     */\\n    function getMinVestingPeriod() public view returns (uint256) {\\n        return minVestingPeriodInBlocks;\\n    }\\n    /*\\n     * @dev updateMinVestingPeriod\\n     *      Set new minVestingPeriodInBlocks\\n     * @param _newPeriod\\n     */\\n    function updateMinVestingPeriod(uint256 _newPeriod) external onlyRouterOwner {\\n        minVestingPeriodInBlocks = _newPeriod;\\n        emit VestingPeriodChanges(msg.sender, _newPeriod);\\n    }\\n    /**\\n     * @dev Deploys a new `OceanPool` on Ocean Friendly Fork modified for 1SS.\\n     This function cannot be called directly, but ONLY through the ERC20DT contract from a ERC20DEployer role\\n\\n      ssContract address\\n     tokens [datatokenAddress, baseTokenAddress]\\n     publisherAddress user which will be assigned the vested amount.\\n     * @param tokens precreated parameter\\n     * @param ssParams params for the ssContract. \\n     *                     [0]  = rate (wei)\\n     *                     [1]  = baseToken decimals\\n     *                     [2]  = vesting amount (wei)\\n     *                     [3]  = vested blocks\\n     *                     [4]  = initial liquidity in baseToken for pool creation\\n     * @param swapFees swapFees (swapFee, swapMarketFee), swapOceanFee will be set automatically later\\n     *                     [0] = swapFee for LP Providers\\n     *                     [1] = swapFee for marketplace runner\\n      \\n      .\\n     * @param addresses refers to an array of addresses passed by user\\n     *                     [0]  = side staking contract address\\n     *                     [1]  = baseToken address for pool creation(OCEAN or other)\\n     *                     [2]  = baseTokenSender user which will provide the baseToken amount for initial liquidity\\n     *                     [3]  = publisherAddress user which will be assigned the vested amount\\n     *                     [4]  = marketFeeCollector marketFeeCollector address\\n                           [5]  = poolTemplateAddress\\n       \\n        @return pool address\\n     */\\n    function deployPool(\\n        address[2] calldata tokens,\\n        // [datatokenAddress, baseTokenAddress]\\n        uint256[] calldata ssParams,\\n        uint256[] calldata swapFees,\\n        address[] calldata addresses\\n    )\\n        external\\n        returns (\\n            //[controller,baseTokenAddress,baseTokenSender,publisherAddress, marketFeeCollector,poolTemplateAddress]\\n\\n            address\\n        )\\n    {\\n        require(\\n            IFactory(factory).erc20List(msg.sender),\\n            \\\"FACTORY ROUTER: NOT ORIGINAL ERC20 TEMPLATE\\\"\\n        );\\n        require(isSSContract(addresses[0]),\\n            \\\"FACTORY ROUTER: invalid ssContract\\\"\\n        );\\n        require(ssParams[1] > 0, \\\"Wrong decimals\\\");\\n\\n        // we pull baseToken for creating initial pool and send it to the controller (ssContract)\\n        _pullUnderlying(tokens[1],addresses[2], addresses[0], ssParams[4]);\\n        \\n        address pool = newBPool(tokens, ssParams, swapFees, addresses);\\n        require(pool != address(0), \\\"FAILED TO DEPLOY POOL\\\");\\n        if (isApprovedToken(tokens[1])) emit NewPool(pool, true);\\n        else emit NewPool(pool, false);\\n        return pool;\\n    }\\n\\n    function _getLength(IERC20[] memory array) internal pure returns (uint256) {\\n        return array.length;\\n    }\\n\\n    /**\\n     * @dev deployFixedRate\\n     *      Creates a new FixedRateExchange setup.\\n     * As for deployPool, this function cannot be called directly,\\n     * but ONLY through the ERC20DT contract from a ERC20DEployer role\\n     * @param fixedPriceAddress fixedPriceAddress\\n     * @param addresses array of addresses [baseToken,owner,marketFeeCollector]\\n     * @param uints array of uints [baseTokenDecimals,datatokenDecimals, fixedRate, marketFee, withMint]\\n       @return exchangeId\\n     */\\n\\n    function deployFixedRate(\\n        address fixedPriceAddress,\\n        address[] calldata addresses,\\n        uint256[] calldata uints\\n    ) external returns (bytes32 exchangeId) {\\n        require(\\n            IFactory(factory).erc20List(msg.sender),\\n            \\\"FACTORY ROUTER: NOT ORIGINAL ERC20 TEMPLATE\\\"\\n        );\\n\\n        require(isFixedRateContract(fixedPriceAddress),\\n            \\\"FACTORY ROUTER: Invalid FixedPriceContract\\\"\\n        );\\n\\n        exchangeId = IFixedRateExchange(fixedPriceAddress).createWithDecimals(\\n            msg.sender,\\n            addresses,\\n            uints\\n        );\\n    }\\n\\n    /**\\n     * @dev deployDispenser\\n     *      Activates a new Dispenser\\n     * As for deployPool, this function cannot be called directly,\\n     * but ONLY through the ERC20DT contract from a ERC20DEployer role\\n     * @param _dispenser dispenser contract address\\n     * @param datatoken refers to datatoken address.\\n     * @param maxTokens - max tokens to dispense\\n     * @param maxBalance - max balance of requester.\\n     * @param owner - owner\\n     * @param allowedSwapper - if !=0, only this address can request DTs\\n     */\\n\\n    function deployDispenser(\\n        address _dispenser,\\n        address datatoken,\\n        uint256 maxTokens,\\n        uint256 maxBalance,\\n        address owner,\\n        address allowedSwapper\\n    ) external {\\n        require(\\n            IFactory(factory).erc20List(msg.sender),\\n            \\\"FACTORY ROUTER: NOT ORIGINAL ERC20 TEMPLATE\\\"\\n        );\\n\\n        require(isDispenserContract(_dispenser),\\n            \\\"FACTORY ROUTER: Invalid DispenserContract\\\"\\n        );\\n        IDispenser(_dispenser).create(\\n            datatoken,\\n            maxTokens,\\n            maxBalance,\\n            owner,\\n            allowedSwapper\\n        );\\n    }\\n\\n     /**\\n     * @dev addPoolTemplate\\n     *      Adds an address to the list of pools templates\\n     *  @param poolTemplate address Contract to be added\\n     */\\n    function addPoolTemplate(address poolTemplate) external onlyRouterOwner {\\n        _addPoolTemplate(poolTemplate);\\n    }\\n     /**\\n     * @dev removePoolTemplate\\n     *      Removes an address from the list of pool templates\\n     *  @param poolTemplate address Contract to be removed\\n     */\\n    function removePoolTemplate(address poolTemplate) external onlyRouterOwner {\\n        _removePoolTemplate(poolTemplate);\\n    }\\n\\n    // If you need to buy multiple DT (let's say for a compute job which has multiple datasets),\\n    // you have to send one transaction for each DT that you want to buy.\\n\\n    // Perks:\\n\\n    // one single call to buy multiple DT for multiple assets (better UX, better gas optimization)\\n\\n    // require tokenIn approvals for router from user. (except for dispenser operations)\\n    function buyDTBatch(Operations[] calldata _operations) external {\\n        // TODO: to avoid DOS attack, we set a limit to maximum orders (50?)\\n        require(_operations.length <= 50, \\\"FactoryRouter: Too Many Operations\\\");\\n        for (uint256 i = 0; i < _operations.length; i++) {\\n            // address[] memory tokenInOutMarket = new address[](3);\\n            address[3] memory tokenInOutMarket = [\\n                _operations[i].tokenIn,\\n                _operations[i].tokenOut,\\n                _operations[i].marketFeeAddress\\n            ];\\n            uint256[4] memory amountsInOutMaxFee = [\\n                _operations[i].amountsIn,\\n                _operations[i].amountsOut,\\n                _operations[i].maxPrice,\\n                _operations[i].swapMarketFee\\n            ];\\n\\n            // tokenInOutMarket[0] =\\n            if (_operations[i].operation == operationType.SwapExactIn) {\\n                // Get amountIn from user to router\\n                _pullUnderlying(_operations[i].tokenIn,msg.sender,\\n                    address(this),\\n                    _operations[i].amountsIn);\\n                // we approve pool to pull token from router\\n                IERC20(_operations[i].tokenIn).safeIncreaseAllowance(\\n                    _operations[i].source,\\n                    _operations[i].amountsIn\\n                );\\n\\n                // Perform swap\\n                (uint256 amountReceived, ) = IPool(_operations[i].source)\\n                    .swapExactAmountIn(tokenInOutMarket, amountsInOutMaxFee);\\n                // transfer token swapped to user\\n\\n                IERC20(_operations[i].tokenOut).safeTransfer(\\n                    msg.sender,\\n                    amountReceived\\n                );\\n            } else if (_operations[i].operation == operationType.SwapExactOut) {\\n                // calculate how much amount In we need for exact Out\\n                uint256 amountIn;\\n                (amountIn, , , , ) = IPool(_operations[i].source)\\n                    .getAmountInExactOut(\\n                        _operations[i].tokenIn,\\n                        _operations[i].tokenOut,\\n                        _operations[i].amountsOut,\\n                        _operations[i].swapMarketFee\\n                    );\\n                // pull amount In from user\\n                _pullUnderlying(_operations[i].tokenIn,msg.sender,\\n                    address(this),\\n                    amountIn);\\n                // we approve pool to pull token from router\\n                IERC20(_operations[i].tokenIn).safeIncreaseAllowance(\\n                    _operations[i].source,\\n                    amountIn\\n                );\\n                // perform swap\\n                (uint tokenAmountIn,) = IPool(_operations[i].source).swapExactAmountOut(\\n                    tokenInOutMarket,\\n                    amountsInOutMaxFee\\n                );\\n                require(tokenAmountIn <= amountsInOutMaxFee[0], 'TOO MANY TOKENS IN');\\n                // send amount out back to user\\n                IERC20(_operations[i].tokenOut).safeTransfer(\\n                    msg.sender,\\n                    _operations[i].amountsOut\\n                );\\n            } else if (_operations[i].operation == operationType.FixedRate) {\\n                // get datatoken address\\n                (, address datatoken, , , , , , , , , , ) = IFixedRateExchange(\\n                    _operations[i].source\\n                ).getExchange(_operations[i].exchangeIds);\\n                // get tokenIn amount required for dt out\\n                (uint256 baseTokenAmount, , , ) = IFixedRateExchange(\\n                    _operations[i].source\\n                ).calcBaseInGivenOutDT(\\n                        _operations[i].exchangeIds,\\n                        _operations[i].amountsOut,\\n                        _operations[i].swapMarketFee\\n                    );\\n\\n                // pull tokenIn amount\\n                _pullUnderlying(_operations[i].tokenIn,msg.sender,\\n                    address(this),\\n                    baseTokenAmount);\\n                // we approve pool to pull token from router\\n                IERC20(_operations[i].tokenIn).safeIncreaseAllowance(\\n                    _operations[i].source,\\n                    baseTokenAmount\\n                );\\n                // perform swap\\n                IFixedRateExchange(_operations[i].source).buyDT(\\n                    _operations[i].exchangeIds,\\n                    _operations[i].amountsOut,\\n                    _operations[i].amountsIn,\\n                    _operations[i].marketFeeAddress,\\n                    _operations[i].swapMarketFee\\n                );\\n                // send dt out to user\\n                IERC20(datatoken).safeTransfer(\\n                    msg.sender,\\n                    _operations[i].amountsOut\\n                );\\n            } else {\\n                IDispenser(_operations[i].source).dispense(\\n                    _operations[i].tokenOut,\\n                    _operations[i].amountsOut,\\n                    msg.sender\\n                );\\n            }\\n        }\\n    }\\n\\n    // require pool[].baseToken (for each pool) approvals for router from user.\\n    function stakeBatch(Stakes[] calldata _stakes) external {\\n        // TODO: to avoid DOS attack, we set a limit to maximum orders (50?)\\n        require(_stakes.length <= 50, \\\"FactoryRouter: Too Many Operations\\\");\\n        for (uint256 i = 0; i < _stakes.length; i++) {\\n            address baseToken = IPool(_stakes[i].poolAddress).getBaseTokenAddress();\\n            _pullUnderlying(baseToken,msg.sender,\\n                    address(this),\\n                    _stakes[i].tokenAmountIn);\\n            uint256 balanceBefore = IERC20(_stakes[i].poolAddress).balanceOf(address(this));\\n            // we approve pool to pull token from router\\n            IERC20(baseToken).safeIncreaseAllowance(\\n                    _stakes[i].poolAddress,\\n                    _stakes[i].tokenAmountIn);\\n            //now stake\\n            uint poolAmountOut = IPool(_stakes[i].poolAddress).joinswapExternAmountIn(\\n                _stakes[i].tokenAmountIn, _stakes[i].minPoolAmountOut\\n                );\\n            require(poolAmountOut >=  _stakes[i].minPoolAmountOut,'NOT ENOUGH LP');\\n            uint256 balanceAfter = IERC20(_stakes[i].poolAddress).balanceOf(address(this));\\n            //send LP shares to user\\n            IERC20(_stakes[i].poolAddress).safeTransfer(\\n                    msg.sender,\\n                    balanceAfter.sub(balanceBefore)\\n                );\\n        }\\n    }\\n    \\n    function _pullUnderlying(\\n        address erc20,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        uint256 balanceBefore = IERC20(erc20).balanceOf(to);\\n        IERC20(erc20).safeTransferFrom(from, to, amount);\\n        require(IERC20(erc20).balanceOf(to) >= balanceBefore.add(amount),\\n                    \\\"Transfer amount is too low\\\");\\n    }\\n\\n    function getPoolTemplates() public view override(BFactory, IFactoryRouter) returns (address[] memory) {\\n        return BFactory.getPoolTemplates();\\n    }\\n\\n    function isPoolTemplate(address poolTemplate) public view override(BFactory, IFactoryRouter)\\n        returns (bool) {\\n        return BFactory.isPoolTemplate(poolTemplate);\\n    }\\n\\n\\n    /*\\n     * @dev updateOPCCollector\\n     *      Set new opcCollector\\n     * @param opcCollector\\n     */\\n    function updateOPCCollector(address _opcCollector) external onlyRouterOwner {\\n        require(_opcCollector != address(0), \\\"New opcCollector cannot be ZERO_ADDR\\\");\\n        opcCollector = _opcCollector;\\n        emit OPCCollectorChanged(msg.sender, _opcCollector);\\n    }\\n    /*\\n      * @dev getOPCCollector\\n      * getter for opcCollector\\n    */\\n    function getOPCCollector() view public returns (address) {\\n        return opcCollector;\\n    }\\n}\"\r\n    },\r\n    \"contracts/pools/balancer/BFactory.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright Balancer, BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\nimport \\\"./BPool.sol\\\";\\nimport \\\"./BConst.sol\\\";\\nimport \\\"../../utils/Deployer.sol\\\";\\nimport \\\"../../interfaces/ISideStaking.sol\\\";\\nimport \\\"../../interfaces/IERC20.sol\\\";\\n\\n/*\\n * @title BFactory contract\\n * @author Ocean Protocol (with code from Balancer Labs)\\n *\\n * @dev Ocean implementation of Balancer BPool Factory\\n *      BFactory deploys BPool proxy contracts.\\n *      New BPool proxy contracts are links to the template contract's bytecode.\\n *      Proxy contract functionality is based on Ocean Protocol custom\\n *        implementation of ERC1167 standard.\\n */\\ncontract BFactory is BConst, Deployer {\\n    address public opcCollector;\\n\\n    // mapping(address => bool) internal poolTemplates;\\n    address[] public poolTemplates;\\n\\n    event BPoolCreated(\\n        address indexed newBPoolAddress,\\n        address indexed registeredBy,\\n        address indexed datatokenAddress,\\n        address baseTokenAddress,\\n        address bpoolTemplateAddress,\\n        address ssAddress\\n    );\\n\\n    event PoolTemplateAdded(\\n        address indexed caller,\\n        address indexed contractAddress\\n    );\\n    event PoolTemplateRemoved(\\n        address indexed caller,\\n        address indexed contractAddress\\n    );\\n\\n    /* @dev Called on contract deployment. Cannot be called with zero address.\\n       @param _bpoolTemplate -- address of a deployed BPool contract. \\n       @param _preCreatedPools list of pre-created pools. \\n                          It can be only used in case of migration from an old factory contract.\\n    */\\n    constructor(\\n        address _bpoolTemplate,\\n        address _opcCollector,\\n        address[] memory _preCreatedPools\\n    ) {\\n        require(\\n            _bpoolTemplate != address(0),\\n            \\\"BFactory: invalid bpool template zero address\\\"\\n        );\\n        require(_opcCollector != address(0), \\\"BFactory: zero address\\\");\\n\\n        opcCollector = _opcCollector;\\n        _addPoolTemplate(_bpoolTemplate);\\n\\n        if (_preCreatedPools.length > 0) {\\n            for (uint256 i = 0; i < _preCreatedPools.length; i++) {\\n                emit BPoolCreated(\\n                    _preCreatedPools[i],\\n                    msg.sender,\\n                    address(0),\\n                    address(0),\\n                    address(0),\\n                    address(0)\\n                );\\n            }\\n        }\\n    }\\n\\n    /** \\n     * @dev Deploys new BPool proxy contract. \\n       Template contract address could not be a zero address. \\n\\n     * @param tokens [datatokenAddress, baseTokenAddress]\\n     * publisherAddress user which will be assigned the vested amount.\\n     * @param ssParams params for the ssContract. \\n     * @param swapFees swapFees (swapFee, swapMarketFee), swapOceanFee will be set automatically later\\n       marketFeeCollector marketFeeCollector address\\n       @param addresses // array of addresses passed by the user\\n       [controller,baseTokenAddress,baseTokenSender,publisherAddress, marketFeeCollector,poolTemplate address]\\n      @return bpool address of a new proxy BPool contract \\n     */\\n\\n    function newBPool(\\n        address[2] memory tokens,\\n        uint256[] memory ssParams,\\n        uint256[] memory swapFees,\\n        address[] memory addresses\\n    ) internal returns (address bpool) {\\n        require(isPoolTemplate(addresses[5]), \\\"BFactory: Wrong Pool Template\\\");\\n        address[1] memory feeCollectors = [addresses[4]];\\n\\n        bpool = deploy(addresses[5]);\\n\\n        require(bpool != address(0), \\\"BFactory: invalid bpool zero address\\\");\\n        BPool bpoolInstance = BPool(bpool);\\n\\n        require(\\n            bpoolInstance.initialize(\\n                addresses[0], // ss is the pool controller\\n                address(this),\\n                swapFees,\\n                false,\\n                false,\\n                tokens,\\n                feeCollectors\\n            ),\\n            \\\"ERR_INITIALIZE_BPOOL\\\"\\n        );\\n\\n        //  emit BPoolCreated(bpool, msg.sender,datatokenAddress,baseTokenAddress,bpoolTemplate,controller);\\n\\n        // requires approval first from baseTokenSender\\n        require(\\n            ISideStaking(addresses[0]).newDatatokenCreated(\\n                tokens[0],\\n                tokens[1],\\n                bpool,\\n                addresses[3], //publisherAddress\\n                ssParams\\n            ),\\n            \\\"ERR_INITIALIZE_SIDESTAKING\\\"\\n        );\\n\\n        return bpool;\\n    }\\n\\n    /**\\n     * @dev _addPoolTemplate\\n     *      Adds an address to the list of pools templates\\n     *  @param poolTemplate address Contract to be added\\n     */\\n    function _addPoolTemplate(address poolTemplate) internal {\\n        require(\\n            poolTemplate != address(0),\\n            \\\"FactoryRouter: Invalid poolTemplate address\\\"\\n        );\\n        if (!isPoolTemplate(poolTemplate)) {\\n            poolTemplates.push(poolTemplate);\\n            emit PoolTemplateAdded(msg.sender, poolTemplate);\\n        }\\n    }\\n\\n    /**\\n     * @dev _removeFixedRateContract\\n     *      Removes an address from the list of pool templates\\n     *  @param poolTemplate address Contract to be removed\\n     */\\n    function _removePoolTemplate(address poolTemplate) internal {\\n        uint256 i;\\n        for (i = 0; i < poolTemplates.length; i++) {\\n            if (poolTemplates[i] == poolTemplate) break;\\n        }\\n        if (i < poolTemplates.length) {\\n            // it's in the array\\n            for (uint256 c = i; c < poolTemplates.length - 1; c++) {\\n                poolTemplates[c] = poolTemplates[c + 1];\\n            }\\n            poolTemplates.pop();\\n            emit PoolTemplateRemoved(msg.sender, poolTemplate);\\n        }\\n    }\\n\\n    /**\\n     * @dev isPoolTemplate\\n     *      Removes true if address exists in the list of templates\\n     *  @param poolTemplate address Contract to be checked\\n     */\\n    function isPoolTemplate(address poolTemplate) public view virtual returns (bool) {\\n        for (uint256 i = 0; i < poolTemplates.length; i++) {\\n            if (poolTemplates[i] == poolTemplate) return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @dev getPoolTemplates\\n     *      Returns the list of pool templates\\n     */\\n    function getPoolTemplates() public view virtual returns (address[] memory) {\\n        return (poolTemplates);\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IFactory.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface IFactory {\\n    function createToken(\\n        uint256 _templateIndex,\\n        string[] calldata strings,\\n        address[] calldata addresses,\\n        uint256[] calldata uints,\\n        bytes[] calldata bytess\\n    ) external returns (address token);\\n\\n    function erc721List(address ERC721address) external returns (address);\\n\\n    function erc20List(address erc20dt) external view returns(bool);\\n\\n\\n    struct NftCreateData{\\n        string name;\\n        string symbol;\\n        uint256 templateIndex;\\n        string tokenURI;\\n        bool transferable;\\n        address owner;\\n    }\\n    struct ErcCreateData{\\n        uint256 templateIndex;\\n        string[] strings;\\n        address[] addresses;\\n        uint256[] uints;\\n        bytes[] bytess;\\n    }\\n\\n    struct PoolData{\\n        uint256[] ssParams;\\n        uint256[] swapFees;\\n        address[] addresses;\\n    }\\n\\n    struct FixedData{\\n        address fixedPriceAddress;\\n        address[] addresses;\\n        uint256[] uints;\\n    }\\n\\n    struct DispenserData{\\n        address dispenserAddress;\\n        uint256 maxTokens;\\n        uint256 maxBalance;\\n        bool withMint;\\n        address allowedSwapper;\\n    }\\n    \\n    function createNftWithErc20(\\n        NftCreateData calldata _NftCreateData,\\n        ErcCreateData calldata _ErcCreateData\\n    ) external returns (address , address);\\n\\n    function createNftWithErc20WithPool(\\n        NftCreateData calldata _NftCreateData,\\n        ErcCreateData calldata _ErcCreateData,\\n        PoolData calldata _PoolData\\n    ) external returns (address, address , address);\\n\\n    \\n    function createNftWithErc20WithFixedRate(\\n         NftCreateData calldata _NftCreateData,\\n        ErcCreateData calldata _ErcCreateData,\\n        FixedData calldata _FixedData\\n    ) external returns (address, address , bytes32 );\\n\\n    \\n    function createNftWithErc20WithDispenser(\\n        NftCreateData calldata _NftCreateData,\\n        ErcCreateData calldata _ErcCreateData,\\n        DispenserData calldata _DispenserData\\n    ) external returns (address, address);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFixedRateExchange.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface IFixedRateExchange {\\n    function createWithDecimals(\\n        address datatoken,\\n        address[] calldata addresses, // [baseToken,owner,marketFeeCollector]\\n        uint256[] calldata uints // [baseTokenDecimals,datatokenDecimals, fixedRate, marketFee]\\n    ) external returns (bytes32 exchangeId);\\n\\n    function buyDT(bytes32 exchangeId, uint256 datatokenAmount,\\n        uint256 maxBaseTokenAmount, address consumeMarketAddress, uint256 consumeMarketSwapFeeAmount) external;\\n    function sellDT(bytes32 exchangeId, uint256 datatokenAmount,\\n        uint256 minBaseTokenAmount, address consumeMarketAddress, uint256 consumeMarketSwapFeeAmount) external;\\n\\n    function getAllowedSwapper(bytes32 exchangeId) external view returns (address allowedSwapper);\\n    function getExchange(bytes32 exchangeId)\\n        external\\n        view\\n        returns (\\n            address exchangeOwner,\\n            address datatoken,\\n            uint256 dtDecimals,\\n            address baseToken,\\n            uint256 btDecimals,\\n            uint256 fixedRate,\\n            bool active,\\n            uint256 dtSupply,\\n            uint256 btSupply,\\n            uint256 dtBalance,\\n            uint256 btBalance,\\n            bool withMint\\n            //address allowedSwapper\\n        );\\n\\n    function getFeesInfo(bytes32 exchangeId)\\n        external\\n        view\\n        returns (\\n            uint256 marketFee,\\n            address marketFeeCollector,\\n            uint256 opcFee,\\n            uint256 marketFeeAvailable,\\n            uint256 oceanFeeAvailable\\n        );\\n\\n    function isActive(bytes32 exchangeId) external view returns (bool);\\n\\n    function calcBaseInGivenOutDT(bytes32 exchangeId, uint256 datatokenAmount, uint256 consumeMarketSwapFeeAmount)\\n        external\\n        view\\n        returns (\\n            uint256 baseTokenAmount,\\n            uint256 oceanFeeAmount,\\n            uint256 publishMarketFeeAmount,\\n            uint256 consumeMarketFeeAmount\\n        );\\n    function calcBaseOutGivenInDT(bytes32 exchangeId, uint256 datatokenAmount, uint256 consumeMarketSwapFeeAmount)\\n        external\\n        view\\n        returns (\\n            uint256 baseTokenAmount,\\n            uint256 oceanFeeAmount,\\n            uint256 publishMarketFeeAmount,\\n            uint256 consumeMarketFeeAmount\\n        );\\n    function updateMarketFee(bytes32 exchangeId, uint256 _newMarketFee) external;\\n    function updateMarketFeeCollector(bytes32 exchangeId, address _newMarketCollector) external;\\n    function setAllowedSwapper(bytes32 exchangeId, address newAllowedSwapper) external;\\n    function getId() pure external returns (uint8);\\n    function collectBT(bytes32 exchangeId, uint256 amount) external;\\n    function collectDT(bytes32 exchangeId, uint256 amount) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.12;\\n// Copyright Balancer, BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface IPool {\\n    function getDatatokenAddress() external view returns (address);\\n\\n    function getBaseTokenAddress() external view returns (address);\\n\\n    function getController() external view returns (address);\\n\\n    function setup(\\n        address datatokenAddress,\\n        uint256 datatokenAmount,\\n        uint256 datatokennWeight,\\n        address baseTokenAddress,\\n        uint256 baseTokenAmount,\\n        uint256 baseTokenWeight\\n    ) external;\\n\\n    function swapExactAmountIn(\\n        address[3] calldata tokenInOutMarket, //[tokenIn,tokenOut,marketFeeAddress]\\n        uint256[4] calldata amountsInOutMaxFee //[tokenAmountIn,minAmountOut,maxPrice,_swapMarketFee]\\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n\\n    function swapExactAmountOut(\\n        address[3] calldata tokenInOutMarket, // [tokenIn,tokenOut,marketFeeAddress]\\n        uint256[4] calldata amountsInOutMaxFee // [maxAmountIn,tokenAmountOut,maxPrice,_swapMarketFee]\\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\\n\\n    function getAmountInExactOut(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 tokenAmountOut,\\n        uint256 _consumeMarketSwapFee\\n    ) external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n    function getAmountOutExactIn(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 tokenAmountIn,\\n        uint256 _consumeMarketSwapFee\\n    ) external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n    function setSwapFee(uint256 swapFee) external;\\n    function getId() pure external returns (uint8);\\n\\n    function exitswapPoolAmountIn(\\n        uint256 poolAmountIn,\\n        uint256 minAmountOut\\n    ) external returns (uint256 tokenAmountOut);\\n    \\n    function joinswapExternAmountIn(\\n        uint256 tokenAmountIn,\\n        uint256 minPoolAmountOut\\n    ) external returns (uint256 poolAmountOut);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDispenser.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface IDispenser {\\n    \\n    function status(address datatoken)\\n    external\\n    view\\n    returns (\\n        bool active,\\n        address owner,\\n        bool isMinter,\\n        uint256 maxTokens,\\n        uint256 maxBalance,\\n        uint256 balance,\\n        address allowedSwapper\\n    );\\n    \\n    function create(\\n        address datatoken,uint256 maxTokens, uint256 maxBalance, address owner, address allowedSwapper) external;\\n    function activate(address datatoken,uint256 maxTokens, uint256 maxBalance) external;\\n    \\n    function deactivate(address datatoken) external;\\n    \\n    function dispense(address datatoken, uint256 amount, address destination) external payable;\\n    \\n    function ownerWithdraw(address datatoken) external;\\n    function setAllowedSwapper(address datatoken, address newAllowedSwapper) external;\\n    function getId() pure external returns (uint8);\\n    \\n}\"\r\n    },\r\n    \"contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"./ERC721/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pools/balancer/BPool.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright Balancer, BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\nimport \\\"./BToken.sol\\\";\\nimport \\\"./BMath.sol\\\";\\nimport \\\"../../interfaces/IPool.sol\\\";\\nimport \\\"../../interfaces/ISideStaking.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\n\\n\\n/**\\n * @title BPool\\n *\\n * @dev Used by the (Ocean version) BFactory contract as a bytecode reference to\\n *      deploy new BPools.\\n *\\n * This contract is a friendly fork of Balancer [1]\\n *  [1] https://github.com/balancer-labs/balancer-core/contracts/.\\n\\n * All fees are expressed in wei.  Examples:\\n *  (1e17 = 10 % , 1e16 = 1% , 1e15 = 0.1%, 1e14 = 0.01%)\\n */\\ncontract BPool is BMath, BToken, IPool {\\n    using SafeERC20 for IERC20;\\n    struct Record {\\n        bool bound; // is token bound to pool\\n        uint256 index; // private\\n        uint256 denorm; // denormalized weight\\n        uint256 balance;\\n    }\\n\\n    event LOG_SWAP(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        uint256 tokenAmountIn,\\n        uint256 tokenAmountOut,\\n        uint256 timestamp,\\n        uint256 inBalance,\\n        uint256 outBalance,\\n        uint256 newSpotPrice\\n    );\\n\\n    event LOG_JOIN(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        uint256 tokenAmountIn,\\n        uint256 timestamp\\n    );\\n    event LOG_SETUP(\\n        address indexed caller,\\n        address indexed baseToken,\\n        uint256 baseTokenAmountIn,\\n        uint256 baseTokenWeight,\\n        address indexed datatoken,\\n        uint256 datatokenAmountIn,\\n        uint256 datatokenWeight\\n    );\\n\\n    event LOG_EXIT(\\n        address indexed caller,\\n        address indexed tokenOut,\\n        uint256 tokenAmountOut,\\n        uint256 timestamp\\n    );\\n\\n    event LOG_CALL(\\n        bytes4 indexed sig,\\n        address indexed caller,\\n        uint256 timestamp,\\n        bytes data\\n    );\\n\\n    event LOG_BPT(uint256 bptAmount);\\n    event LOG_BPT_SS(uint256 bptAmount); //emitted for SS contract\\n\\n    event OPCFee(\\n        address caller,\\n        address OPCWallet,\\n        address token,\\n        uint256 amount\\n    );\\n    event SwapFeeChanged(address caller, uint256 amount);\\n    event PublishMarketFee(\\n        address caller,\\n        address marketAddress,\\n        address token,\\n        uint256 amount\\n    );\\n    // emited for fees sent to consumeMarket\\n    event ConsumeMarketFee(address to, address token, uint256 amount);\\n    event SWAP_FEES(uint LPFeeAmount, uint oceanFeeAmount, uint marketFeeAmount,\\n        uint consumeMarketFeeAmount, address tokenFeeAddress);\\n    //emitted for every change done by publisherMarket\\n    event PublishMarketFeeChanged(address caller, address newMarketCollector, uint256 swapFee);\\n    event Gulped(address token, uint256 oldBalance, uint256 newBalance);\\n    modifier _lock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    modifier _viewlock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _;\\n    }\\n\\n    bool private _mutex;\\n\\n    address private _controller; // has CONTROL role\\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\\n\\n    //address public _publishMarketCollector;\\n    address public _publishMarketCollector;\\n    // `setSwapFee` and `finalize` require CONTROL\\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\\n    bool private _finalized;\\n\\n    address[] private _tokens;\\n    mapping(address => Record) private _records;\\n    uint256 private _totalWeight;\\n    ISideStaking ssContract;\\n\\n    //-----------------------------------------------------------------------\\n    //Proxy contract functionality: begin\\n    bool private initialized;\\n\\n    /**\\n     * @dev getId\\n     *      Return template id in case we need different ABIs. \\n     *      If you construct your own template, please make sure to change the hardcoded value\\n     */\\n    function getId() pure public returns (uint8) {\\n        return 1;\\n    }\\n\\n    function isInitialized() external view returns (bool) {\\n        return initialized;\\n    }\\n\\n    // Called prior to contract initialization (e.g creating new BPool instance)\\n    // Calls private _initialize function. Only if contract is not initialized.\\n    function initialize(\\n        address controller,\\n        address factory,\\n        uint256[] calldata swapFees,\\n        bool publicSwap,\\n        bool finalized,\\n        address[2] calldata tokens,\\n        address[1] calldata feeCollectors\\n    ) external returns (bool) {\\n        require(!initialized, \\\"ERR_ALREADY_INITIALIZED\\\");\\n        require(controller != address(0), \\\"ERR_INVALID_CONTROLLER_ADDRESS\\\");\\n        require(factory != address(0), \\\"ERR_INVALID_FACTORY_ADDRESS\\\");\\n        require(swapFees[0] >= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\n        require(swapFees[0] <= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n        require(swapFees[1] == 0 || swapFees[1]>= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\n        require(swapFees[1] <= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n        return\\n            _initialize(\\n                controller,\\n                factory,\\n                swapFees,\\n                publicSwap,\\n                finalized,\\n                tokens,\\n                feeCollectors\\n            );\\n    }\\n\\n    // Private function called on contract initialization.\\n    function _initialize(\\n        address controller,\\n        address factory,\\n        uint256[] memory swapFees,\\n        bool publicSwap,\\n        bool finalized,\\n        address[2] memory tokens,\\n        address[1] memory feeCollectors\\n    ) private returns (bool) {\\n        _controller = controller;\\n        router = factory;\\n        _swapFee = swapFees[0];\\n        emit SwapFeeChanged(msg.sender, _swapFee);\\n        _swapPublishMarketFee = swapFees[1];\\n        _publicSwap = publicSwap;\\n        _finalized = finalized;\\n        _datatokenAddress = tokens[0];\\n        _baseTokenAddress = tokens[1];\\n        _publishMarketCollector = feeCollectors[0];\\n        emit PublishMarketFeeChanged(msg.sender, _publishMarketCollector, _swapPublishMarketFee);\\n        initialized = true;\\n        ssContract = ISideStaking(_controller);\\n        return initialized;\\n    }\\n\\n    \\n    /**\\n     * @dev setup\\n     *      Initial setup of the pool\\n     *      Can be called only by the controller\\n     * @param datatokenAddress datatokenAddress\\n     * @param datatokenAmount how many datatokens in the initial reserve\\n     * @param datatokenWeight datatoken weight (hardcoded in deployer at 50%)\\n     * @param baseTokenAddress base token\\n     * @param baseTokenAmount how many basetokens in the initial reserve\\n     * @param baseTokenWeight base weight (hardcoded in deployer at 50%)\\n     */\\n    function setup(\\n        address datatokenAddress,\\n        uint256 datatokenAmount,\\n        uint256 datatokenWeight,\\n        address baseTokenAddress,\\n        uint256 baseTokenAmount,\\n        uint256 baseTokenWeight\\n    ) external _lock_ {\\n        require(msg.sender == _controller, \\\"ERR_INVALID_CONTROLLER\\\");\\n        require(\\n            datatokenAddress == _datatokenAddress,\\n            \\\"ERR_INVALID_DATATOKEN_ADDRESS\\\"\\n        );\\n        require(\\n            baseTokenAddress == _baseTokenAddress,\\n            \\\"ERR_INVALID_baseToken_ADDRESS\\\"\\n        );\\n        // other inputs will be validated prior\\n        // calling the below functions\\n        // bind datatoken\\n        bind(datatokenAddress, datatokenAmount, datatokenWeight);\\n        emit LOG_JOIN(\\n            msg.sender,\\n            datatokenAddress,\\n            datatokenAmount,\\n            block.timestamp\\n        );\\n\\n        // bind baseToken\\n        bind(baseTokenAddress, baseTokenAmount, baseTokenWeight);\\n        emit LOG_JOIN(\\n            msg.sender,\\n            baseTokenAddress,\\n            baseTokenAmount,\\n            block.timestamp\\n        );\\n        // finalize\\n        finalize();\\n        emit LOG_SETUP(\\n            msg.sender,\\n            baseTokenAddress,\\n            baseTokenAmount,\\n            baseTokenWeight,\\n            datatokenAddress,\\n            datatokenAmount,\\n            datatokenWeight\\n        );\\n    }\\n\\n    //Proxy contract functionality: end\\n    //-----------------------------------------------------------------------\\n    /**\\n     * @dev isPublicSwap\\n     *      Returns true if swapping is allowed\\n     */\\n    function isPublicSwap() external view returns (bool) {\\n        return _publicSwap;\\n    }\\n    /**\\n     * @dev isFinalized\\n     *      Returns true if pool is finalized\\n     */\\n    function isFinalized() external view returns (bool) {\\n        return _finalized;\\n    }\\n\\n    /**\\n     * @dev isBound\\n     *      Returns true if token is bound\\n     * @param t token to be checked\\n     */\\n    function isBound(address t) external view returns (bool) {\\n        return _records[t].bound;\\n    }\\n\\n    function _checkBound(address token) internal view {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n    }\\n\\n    /**\\n     * @dev getNumTokens\\n     *      Returns number of tokens bounded to pool\\n     */\\n    function getNumTokens() external view returns (uint256) {\\n        return _tokens.length;\\n    }\\n\\n    /**\\n     * @dev getCurrentTokens\\n     *      Returns tokens bounded to pool, before the pool is finalized\\n     */\\n    function getCurrentTokens()\\n        external\\n        view\\n        _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        return _tokens;\\n    }\\n\\n    /**\\n     * @dev getFinalTokens\\n     *      Returns tokens bounded to pool, after the pool was finalized\\n     */\\n    function getFinalTokens()\\n        public\\n        view\\n        _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        return _tokens;\\n    }\\n\\n    /**\\n     * @dev collectOPC\\n     *      Collects and send all OPC Fees to _opcCollector.\\n     *      This funtion can be called by anyone, because fees are being sent to _opcCollector\\n     */\\n    function collectOPC() external {\\n        address[] memory tokens = getFinalTokens();\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 amount = communityFees[tokens[i]];\\n            communityFees[tokens[i]] = 0;\\n            address _opcCollector = IFactoryRouter(router).getOPCCollector();\\n            emit OPCFee(msg.sender, _opcCollector, tokens[i], amount);\\n            IERC20(tokens[i]).safeTransfer(_opcCollector, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev getCurrentOPCFees\\n     *      Get the current amount of fees which can be withdrawned by OPC\\n     * @return address[] - array of tokens addresses\\n     *         uint256[] - array of amounts\\n     */\\n    function getCurrentOPCFees()\\n        public\\n        view\\n        returns (address[] memory, uint256[] memory)\\n    {\\n        address[] memory poolTokens = getFinalTokens();\\n        address[] memory tokens = new address[](poolTokens.length);\\n        uint256[] memory amounts = new uint256[](poolTokens.length);\\n        for (uint256 i = 0; i < poolTokens.length; i++) {\\n            tokens[i] = poolTokens[i];\\n            amounts[i] = communityFees[poolTokens[i]];\\n        }\\n        return (tokens, amounts);\\n    }\\n\\n    /**\\n     * @dev getCurrentMarketFees\\n     *      Get the current amount of fees which can be withdrawned by _publishMarketCollector\\n     * @return address[] - array of tokens addresses\\n     *         uint256[] - array of amounts\\n     */\\n    function getCurrentMarketFees()\\n        public\\n        view\\n        returns (address[] memory, uint256[] memory)\\n    {\\n        address[] memory poolTokens = getFinalTokens();\\n        address[] memory tokens = new address[](poolTokens.length);\\n        uint256[] memory amounts = new uint256[](poolTokens.length);\\n        for (uint256 i = 0; i < poolTokens.length; i++) {\\n            tokens[i] = poolTokens[i];\\n            amounts[i] = publishMarketFees[poolTokens[i]];\\n        }\\n        return (tokens, amounts);\\n    }\\n\\n    /**\\n     * @dev collectMarketFee\\n     *      Collects and send all Market Fees to _publishMarketCollector.\\n     *      This function can be called by anyone, because fees are being sent to _publishMarketCollector\\n     */\\n    function collectMarketFee() external {\\n        address[] memory tokens = getFinalTokens();\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 amount = publishMarketFees[tokens[i]];\\n            publishMarketFees[tokens[i]] = 0;\\n            emit PublishMarketFee(\\n                msg.sender,\\n                _publishMarketCollector,\\n                tokens[i],\\n                amount\\n            );\\n            IERC20(tokens[i]).safeTransfer(_publishMarketCollector, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev updatePublishMarketFee\\n     *      Set _newCollector as _publishMarketCollector\\n     * @param _newCollector new _publishMarketCollector\\n     * @param _newSwapFee new swapFee\\n     */\\n    function updatePublishMarketFee(address _newCollector, uint256 _newSwapFee) external {\\n        require(_publishMarketCollector == msg.sender, \\\"ONLY MARKET COLLECTOR\\\");\\n        require(_newCollector != address(0), \\\"Invalid _newCollector address\\\");\\n        require(_newSwapFee ==0 || _newSwapFee >= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\n        require(_newSwapFee <= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n        _publishMarketCollector = _newCollector;\\n        _swapPublishMarketFee = _newSwapFee;\\n        emit PublishMarketFeeChanged(msg.sender, _publishMarketCollector, _swapPublishMarketFee);\\n    }\\n\\n    /**\\n     * @dev getDenormalizedWeight\\n     *      Returns denormalized weight of a token\\n     * @param token token to be checked\\n     */\\n    function getDenormalizedWeight(address token)\\n        external\\n        view\\n        _viewlock_\\n        returns (uint256)\\n    {\\n        _checkBound(token);\\n        return _records[token].denorm;\\n    }\\n\\n     /**\\n     * @dev getTotalDenormalizedWeight\\n     *      Returns total denormalized weught of the pool\\n     */\\n    function getTotalDenormalizedWeight()\\n        external\\n        view\\n        _viewlock_\\n        returns (uint256)\\n    {\\n        return _totalWeight;\\n    }\\n\\n    /**\\n     * @dev getNormalizedWeight\\n     *      Returns normalized weight of a token\\n     * @param token token to be checked\\n     */\\n    \\n    function getNormalizedWeight(address token)\\n        external\\n        view\\n        _viewlock_\\n        returns (uint256)\\n    {\\n        _checkBound(token);\\n        uint256 denorm = _records[token].denorm;\\n        return bdiv(denorm, _totalWeight);\\n    }\\n\\n\\n    /**\\n     * @dev getBalance\\n     *      Returns the current token reserve amount\\n     * @param token token to be checked\\n     */\\n    function getBalance(address token)\\n        external\\n        view\\n        _viewlock_\\n        returns (uint256)\\n    {\\n        _checkBound(token);\\n        return _records[token].balance;\\n    }\\n\\n    /**\\n     * @dev getSwapFee\\n     *      Returns the current Liquidity Providers swap fee\\n     */\\n    function getSwapFee() external view returns (uint256) {\\n        return _swapFee;\\n    }\\n\\n    /**\\n     * @dev getMarketFee\\n     *      Returns the current fee of publishingMarket\\n     */\\n    function getMarketFee() external view returns (uint256) {\\n        return _swapPublishMarketFee;\\n    }\\n\\n    /**\\n     * @dev getController\\n     *      Returns the current controller address (ssBot)\\n     */\\n    function getController() external view returns (address) {\\n        return _controller;\\n    }\\n\\n    /**\\n     * @dev getDatatokenAddress\\n     *      Returns the current datatoken address\\n     */\\n    function getDatatokenAddress() external view returns (address) {\\n        return _datatokenAddress;\\n    }\\n\\n    /**\\n     * @dev getBaseTokenAddress\\n     *      Returns the current baseToken address\\n     */\\n    function getBaseTokenAddress() external view returns (address) {\\n        return _baseTokenAddress;\\n    }\\n\\n\\n    /**\\n     * @dev setSwapFee\\n     *      Allows controller to change the swapFee\\n     * @param swapFee new swap fee (max 1e17 = 10 % , 1e16 = 1% , 1e15 = 0.1%, 1e14 = 0.01%)\\n     */\\n    function setSwapFee(uint256 swapFee) public {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(swapFee >= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\n        require(swapFee <= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n        _swapFee = swapFee;\\n        emit SwapFeeChanged(msg.sender, swapFee);\\n    }\\n\\n    /**\\n     * @dev finalize\\n     *      Finalize pool. After this,new tokens cannot be bound\\n     */\\n    function finalize() internal {\\n        _finalized = true;\\n        _publicSwap = true;\\n\\n        _mintPoolShare(INIT_POOL_SUPPLY);\\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\\n    }\\n\\n    /**\\n     * @dev bind\\n     *      Bind a new token to the pool.\\n     * @param token token address\\n     * @param balance initial reserve\\n     * @param denorm denormalized weight\\n     */\\n    function bind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) internal {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(!_records[token].bound, \\\"ERR_IS_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        require(_tokens.length < MAX_BOUND_TOKENS, \\\"ERR_MAX_TOKENS\\\");\\n\\n        _records[token] = Record({\\n            bound: true,\\n            index: _tokens.length,\\n            denorm: 0, // balance and denorm will be validated\\n            balance: 0 // and set by `rebind`\\n        });\\n        _tokens.push(token);\\n        rebind(token, balance, denorm);\\n    }\\n\\n    /**\\n     * @dev rebind\\n     *      Update pool reserves & weight after a token bind\\n     * @param token token address\\n     * @param balance initial reserve\\n     * @param denorm denormalized weight\\n     */\\n    function rebind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) internal {\\n        require(denorm >= MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n        require(denorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n        require(balance >= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n\\n        // Adjust the denorm and totalWeight\\n        uint256 oldWeight = _records[token].denorm;\\n        if (denorm > oldWeight) {\\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\\n            require(_totalWeight <= MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n        } else if (denorm < oldWeight) {\\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\\n        }\\n        _records[token].denorm = denorm;\\n\\n        // Adjust the balance record and actual token balance\\n        uint256 oldBalance = _records[token].balance;\\n        _records[token].balance = balance;\\n        if (balance > oldBalance) {\\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\\n        } else if (balance < oldBalance) {\\n            // In this case liquidity is being withdrawn, we don't have EXIT_FEES\\n            uint256 tokenBalanceWithdrawn = bsub(oldBalance, balance);\\n            _pushUnderlying(\\n                token,\\n                msg.sender,\\n                tokenBalanceWithdrawn\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev getSpotPrice\\n     *      Return the spot price of swapping tokenIn to tokenOut\\n     * @param tokenIn in token\\n     * @param tokenOut out token\\n     * @param _consumeMarketSwapFee consume market swap fee \\n     */\\n    function getSpotPrice(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 _consumeMarketSwapFee\\n    ) external view _viewlock_ returns (uint256 spotPrice) {\\n        _checkBound(tokenIn);\\n        _checkBound(tokenOut);\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return\\n            calcSpotPrice(\\n                inRecord.balance,\\n                inRecord.denorm,\\n                outRecord.balance,\\n                outRecord.denorm,\\n                _consumeMarketSwapFee\\n            );\\n    }\\n\\n    // view function used for batch buy. useful for frontend\\n     /**\\n     * @dev getAmountInExactOut\\n     *      How many tokensIn do you need in order to get exact tokenAmountOut.\\n            Returns: tokenAmountIn, LPFee, opcFee , publishMarketSwapFee, consumeMarketSwapFee\\n     * @param tokenIn token to be swaped\\n     * @param tokenOut token to get\\n     * @param tokenAmountOut exact amount of tokenOut\\n     * @param _consumeMarketSwapFee consume market swap fee\\n     */\\n\\n    function getAmountInExactOut(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 tokenAmountOut,\\n        uint256 _consumeMarketSwapFee\\n    )\\n        external\\n        view\\n        returns (\\n            // _viewlock_\\n            uint256 tokenAmountIn, uint lpFeeAmount, \\n            uint oceanFeeAmount, \\n            uint publishMarketSwapFeeAmount,\\n            uint consumeMarketSwapFeeAmount\\n        )\\n    {\\n        _checkBound(tokenIn);\\n        _checkBound(tokenOut);\\n        uint256[4] memory data = [\\n            _records[tokenIn].balance,\\n            _records[tokenIn].denorm,\\n            _records[tokenOut].balance,\\n            _records[tokenOut].denorm\\n        ];\\n        uint tokenAmountInBalance;\\n        swapfees memory _swapfees;\\n        (tokenAmountIn, tokenAmountInBalance, _swapfees) =        \\n            calcInGivenOut(\\n                data,\\n                tokenAmountOut,\\n                // tokenIn,\\n                _consumeMarketSwapFee\\n            );\\n        return(tokenAmountIn, _swapfees.LPFee, _swapfees.oceanFeeAmount, \\n        _swapfees.publishMarketFeeAmount, _swapfees.consumeMarketFee);\\n\\n    }\\n\\n    // view function useful for frontend\\n    /**\\n     * @dev getAmountOutExactIn\\n     *      How many tokensOut you will get for a exact tokenAmountIn\\n            Returns: tokenAmountOut, LPFee, opcFee ,  publishMarketSwapFee, consumeMarketSwapFee\\n     * @param tokenIn token to be swaped\\n     * @param tokenOut token to get\\n     * @param tokenAmountOut exact amount of tokenOut\\n     * @param _consumeMarketSwapFee consume market swap fee\\n     */\\n    function getAmountOutExactIn(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 tokenAmountIn,\\n        uint256 _consumeMarketSwapFee\\n    )\\n        external\\n        view\\n        returns (\\n            //  _viewlock_\\n            uint256 tokenAmountOut,\\n            uint lpFeeAmount, \\n            uint oceanFeeAmount, \\n            uint publishMarketSwapFeeAmount,\\n            uint consumeMarketSwapFeeAmount\\n        )\\n    {\\n        _checkBound(tokenIn);\\n        _checkBound(tokenOut);\\n        uint256[4] memory data = [\\n            _records[tokenIn].balance,\\n            _records[tokenIn].denorm,\\n            _records[tokenOut].balance,\\n            _records[tokenOut].denorm\\n        ];\\n        uint balanceInToAdd;\\n        swapfees memory _swapfees;\\n         (tokenAmountOut, balanceInToAdd, _swapfees) =        \\n            calcOutGivenIn(\\n                data,\\n                tokenAmountIn,\\n               // tokenIn,\\n                _consumeMarketSwapFee\\n            );\\n        return(tokenAmountOut, _swapfees.LPFee, \\n        _swapfees.oceanFeeAmount, _swapfees.publishMarketFeeAmount, _swapfees.consumeMarketFee);\\n    }\\n\\n\\n    /**\\n     * @dev swapExactAmountIn\\n     *      Swaps an exact amount of tokensIn to get a mimum amount of tokenOut\\n     * @param tokenInOutMarket array of addreses: [tokenIn, tokenOut, consumeMarketFeeAddress]\\n     * @param amountsInOutMaxFee array of ints: [tokenAmountIn, minAmountOut, maxPrice, consumeMarketSwapFee]\\n     */\\n    function swapExactAmountIn(\\n        address[3] calldata tokenInOutMarket, \\n        uint256[4] calldata amountsInOutMaxFee\\n    ) external _lock_ returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(tokenInOutMarket[0] != tokenInOutMarket[1], 'Cannot swap same token');\\n        _checkBound(tokenInOutMarket[0]);\\n        _checkBound(tokenInOutMarket[1]);\\n        Record storage inRecord = _records[address(tokenInOutMarket[0])];\\n        Record storage outRecord = _records[address(tokenInOutMarket[1])];\\n        require(amountsInOutMaxFee[3] ==0 || amountsInOutMaxFee[3] >= MIN_FEE,'ConsumeSwapFee too low');\\n        require(amountsInOutMaxFee[3] <= MAX_FEE,'ConsumeSwapFee too high');\\n        require(\\n            amountsInOutMaxFee[0] <= bmul(inRecord.balance, MAX_IN_RATIO),\\n            \\\"ERR_MAX_IN_RATIO\\\"\\n        );\\n\\n        uint256 spotPriceBefore = calcSpotPrice(\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm,\\n            amountsInOutMaxFee[3]\\n        );\\n\\n        require(\\n            spotPriceBefore <= amountsInOutMaxFee[2],\\n            \\\"ERR_BAD_LIMIT_PRICE\\\"\\n        );\\n        uint256 balanceInToAdd;\\n        uint256[4] memory data = [\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm\\n        ];\\n        swapfees memory _swapfees;\\n        (tokenAmountOut, balanceInToAdd, _swapfees) = calcOutGivenIn(\\n            data,\\n            amountsInOutMaxFee[0],\\n           // tokenInOutMarket[0],\\n            amountsInOutMaxFee[3]\\n        );\\n        // update balances\\n        communityFees[tokenInOutMarket[0]] = badd(communityFees[tokenInOutMarket[0]],_swapfees.oceanFeeAmount);\\n        publishMarketFees[tokenInOutMarket[0]] = \\n        badd(publishMarketFees[tokenInOutMarket[0]],_swapfees.publishMarketFeeAmount);\\n        emit SWAP_FEES(_swapfees.LPFee, _swapfees.oceanFeeAmount,\\n        _swapfees.publishMarketFeeAmount,_swapfees.consumeMarketFee, tokenInOutMarket[0]);\\n        require(tokenAmountOut >= amountsInOutMaxFee[1], \\\"ERR_LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, balanceInToAdd);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm,\\n            amountsInOutMaxFee[3]\\n        );\\n\\n        require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\n        require(spotPriceAfter <= amountsInOutMaxFee[2], \\\"ERR_LIMIT_PRICE\\\");\\n\\n        require(\\n            spotPriceBefore <= bdiv(amountsInOutMaxFee[0], tokenAmountOut),\\n            \\\"ERR_MATH_APPROX\\\"\\n        );\\n\\n        emit LOG_SWAP(\\n            msg.sender,\\n            tokenInOutMarket[0],\\n            tokenInOutMarket[1],\\n            amountsInOutMaxFee[0],\\n            tokenAmountOut,\\n            block.timestamp,\\n            inRecord.balance,\\n            outRecord.balance,\\n            spotPriceAfter\\n\\n        );\\n\\n        _pullUnderlying(tokenInOutMarket[0], msg.sender, amountsInOutMaxFee[0]);\\n        uint256 consumeMarketFeeAmount = bsub(\\n            amountsInOutMaxFee[0],\\n            bmul(amountsInOutMaxFee[0], bsub(BONE, amountsInOutMaxFee[3]))\\n        );\\n        if (amountsInOutMaxFee[3] > 0) {\\n            IERC20(tokenInOutMarket[0]).safeTransfer(\\n                tokenInOutMarket[2],\\n                consumeMarketFeeAmount\\n            );\\n            emit ConsumeMarketFee(\\n                tokenInOutMarket[2],\\n                tokenInOutMarket[0],\\n                consumeMarketFeeAmount\\n            );\\n        }\\n        _pushUnderlying(tokenInOutMarket[1], msg.sender, tokenAmountOut);\\n\\n        return (tokenAmountOut, spotPriceAfter); //returning spot price 0 because there is no public spotPrice\\n    }\\n\\n\\n    /**\\n     * @dev swapExactAmountOut\\n     *      Swaps a maximum  maxAmountIn of tokensIn to get an exact amount of tokenOut\\n     * @param tokenInOutMarket array of addreses: [tokenIn, tokenOut, consumeMarketFeeAddress]\\n     * @param amountsInOutMaxFee array of ints: [maxAmountIn,tokenAmountOut,maxPrice, consumeMarketSwapFee]\\n     */\\n    function swapExactAmountOut(\\n        address[3] calldata tokenInOutMarket,\\n        uint256[4] calldata amountsInOutMaxFee\\n    ) external _lock_ returns (uint256 tokenAmountIn, uint256 spotPriceAfter) {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(tokenInOutMarket[0] != tokenInOutMarket[1], 'Cannot swap same token');\\n        require(amountsInOutMaxFee[3] ==0 || amountsInOutMaxFee[3] >= MIN_FEE,'ConsumeSwapFee too low');\\n        require(amountsInOutMaxFee[3] <= MAX_FEE,'ConsumeSwapFee too high');\\n        _checkBound(tokenInOutMarket[0]);\\n        _checkBound(tokenInOutMarket[1]);\\n        Record storage inRecord = _records[address(tokenInOutMarket[0])];\\n        Record storage outRecord = _records[address(tokenInOutMarket[1])];\\n\\n        require(\\n            amountsInOutMaxFee[1] <= bmul(outRecord.balance, MAX_OUT_RATIO),\\n            \\\"ERR_MAX_OUT_RATIO\\\"\\n        );\\n\\n        uint256 spotPriceBefore = calcSpotPrice(\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm,\\n            amountsInOutMaxFee[3]\\n        );\\n\\n        require(\\n            spotPriceBefore <= amountsInOutMaxFee[2],\\n            \\\"ERR_BAD_LIMIT_PRICE\\\"\\n        );\\n        // this is the amount we are going to register in balances\\n        // (only takes account of swapFee, not OPC and market fee,\\n        //in order to not affect price during following swaps, fee wtihdrawl etc)\\n        uint256 balanceToAdd;\\n        uint256[4] memory data = [\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm\\n        ];\\n        swapfees memory _swapfees;\\n        (tokenAmountIn, balanceToAdd,\\n        _swapfees) = calcInGivenOut(\\n            data,\\n            amountsInOutMaxFee[1],\\n            //tokenInOutMarket[0],\\n            amountsInOutMaxFee[3]\\n        );\\n        communityFees[tokenInOutMarket[0]] = badd(communityFees[tokenInOutMarket[0]],_swapfees.oceanFeeAmount);\\n        publishMarketFees[tokenInOutMarket[0]] \\n        = badd(publishMarketFees[tokenInOutMarket[0]],_swapfees.publishMarketFeeAmount);\\n        emit SWAP_FEES(_swapfees.LPFee, _swapfees.oceanFeeAmount,\\n        _swapfees.publishMarketFeeAmount,_swapfees.consumeMarketFee, tokenInOutMarket[0]);\\n        require(tokenAmountIn <= amountsInOutMaxFee[0], \\\"ERR_LIMIT_IN\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, balanceToAdd);\\n        outRecord.balance = bsub(outRecord.balance, amountsInOutMaxFee[1]);\\n\\n        spotPriceAfter = calcSpotPrice(\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm,\\n            amountsInOutMaxFee[3]\\n        );\\n\\n        require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\n        require(spotPriceAfter <= amountsInOutMaxFee[2], \\\"ERR_LIMIT_PRICE\\\");\\n        require(\\n            spotPriceBefore <= bdiv(tokenAmountIn, amountsInOutMaxFee[1]),\\n            \\\"ERR_MATH_APPROX\\\"\\n        );\\n\\n        emit LOG_SWAP(\\n            msg.sender,\\n            tokenInOutMarket[0],\\n            tokenInOutMarket[1],\\n            tokenAmountIn,\\n            amountsInOutMaxFee[1],\\n            block.timestamp,\\n            inRecord.balance,\\n            outRecord.balance,\\n            spotPriceAfter\\n        );\\n        _pullUnderlying(tokenInOutMarket[0], msg.sender, tokenAmountIn);\\n        uint256 consumeMarketFeeAmount = bsub(\\n            tokenAmountIn,\\n            bmul(tokenAmountIn, bsub(BONE, amountsInOutMaxFee[3]))\\n        );\\n        if (amountsInOutMaxFee[3] > 0) {\\n            IERC20(tokenInOutMarket[0]).safeTransfer(\\n                tokenInOutMarket[2],// market address\\n                consumeMarketFeeAmount\\n            );\\n            emit ConsumeMarketFee(\\n                tokenInOutMarket[2], // to (market address)\\n                tokenInOutMarket[0], // token\\n                consumeMarketFeeAmount\\n            );\\n        }\\n        _pushUnderlying(tokenInOutMarket[1], msg.sender, amountsInOutMaxFee[1]);\\n        return (tokenAmountIn, spotPriceAfter);\\n    }\\n\\n    /**\\n     * @dev joinswapExternAmountIn\\n     *      Single side add liquidity to the pool,\\n     *      expecting a minPoolAmountOut of shares for spending tokenAmountIn basetokens\\n     * @param tokenAmountIn exact number of base tokens to spend\\n     * @param minPoolAmountOut minimum of pool shares expectex\\n     */\\n    function joinswapExternAmountIn(\\n        uint256 tokenAmountIn,\\n        uint256 minPoolAmountOut\\n    ) external _lock_ returns (uint256 poolAmountOut) {\\n        //tokenIn = _baseTokenAddress;\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        _checkBound(_baseTokenAddress);\\n        require(\\n            tokenAmountIn <= bmul(_records[_baseTokenAddress].balance, MAX_IN_RATIO),\\n            \\\"ERR_MAX_IN_RATIO\\\"\\n        );\\n        //ask ssContract\\n        Record storage inRecord = _records[_baseTokenAddress];\\n\\n        poolAmountOut = calcPoolOutGivenSingleIn(\\n            inRecord.balance,\\n            _totalSupply,\\n            tokenAmountIn\\n        );\\n\\n        require(poolAmountOut >= minPoolAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n        emit LOG_JOIN(msg.sender, _baseTokenAddress, tokenAmountIn, block.timestamp);\\n        emit LOG_BPT(poolAmountOut);\\n\\n        \\n\\n        //ask the ssContract to stake as well\\n        //calculate how much should the 1ss stake\\n        Record storage ssInRecord = _records[_datatokenAddress];\\n        uint256 ssAmountIn = calcSingleInGivenPoolOut(\\n            ssInRecord.balance,\\n            _totalSupply,\\n            poolAmountOut\\n        );\\n        if (ssContract.canStake(_datatokenAddress, ssAmountIn)) {\\n            \\n            //call 1ss to approve\\n            ssContract.Stake(_datatokenAddress, ssAmountIn);\\n            // follow the same path\\n            ssInRecord.balance = badd(ssInRecord.balance, ssAmountIn);\\n            emit LOG_JOIN(\\n                _controller,\\n                _datatokenAddress,\\n                ssAmountIn,\\n                block.timestamp\\n            );\\n            emit LOG_BPT_SS(poolAmountOut);\\n            _mintPoolShare(poolAmountOut);\\n            _pushPoolShare(_controller, poolAmountOut);\\n            _pullUnderlying(_datatokenAddress, _controller, ssAmountIn);\\n            \\n        }\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n        _pullUnderlying(_baseTokenAddress, msg.sender, tokenAmountIn);\\n        return poolAmountOut;\\n    }\\n\\n    \\n    /**\\n     * @dev exitswapPoolAmountIn\\n     *      Single side remove liquidity from the pool,\\n     *      expecting a minAmountOut of basetokens for spending poolAmountIn pool shares\\n     * @param poolAmountIn exact number of pool shares to spend\\n     * @param minAmountOut minimum amount of basetokens expected\\n     */\\n    function exitswapPoolAmountIn(\\n        uint256 poolAmountIn,\\n        uint256 minAmountOut\\n    ) external _lock_ returns (uint256 tokenAmountOut) {\\n        //tokenOut = _baseTokenAddress;\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        _checkBound(_baseTokenAddress);\\n\\n        Record storage outRecord = _records[_baseTokenAddress];\\n\\n        tokenAmountOut = calcSingleOutGivenPoolIn(\\n            outRecord.balance,\\n            _totalSupply,\\n            poolAmountIn\\n        );\\n        require(tokenAmountOut >= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        require(\\n            tokenAmountOut <= bmul(_records[_baseTokenAddress].balance, MAX_OUT_RATIO),\\n            \\\"ERR_MAX_OUT_RATIO\\\"\\n        );\\n\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        //uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\\n        emit LOG_EXIT(msg.sender, _baseTokenAddress, tokenAmountOut, block.timestamp);\\n        emit LOG_BPT(poolAmountIn);\\n\\n        //ask the ssContract to unstake as well\\n        //calculate how much should the 1ss unstake\\n        \\n        if (\\n            ssContract.canUnStake(_datatokenAddress, poolAmountIn)\\n        ) {\\n            Record storage ssOutRecord = _records[_datatokenAddress];\\n            uint256 ssAmountOut = calcSingleOutGivenPoolIn(\\n                ssOutRecord.balance,\\n                _totalSupply,\\n                poolAmountIn\\n            );\\n\\n            ssOutRecord.balance = bsub(ssOutRecord.balance, ssAmountOut);\\n            //exitFee = bmul(poolAmountIn, EXIT_FEE);\\n            emit LOG_EXIT(\\n                _controller,\\n                _datatokenAddress,\\n                ssAmountOut,\\n                block.timestamp\\n            );\\n            _pullPoolShare(_controller, poolAmountIn);\\n            //_burnPoolShare(bsub(poolAmountIn, exitFee));\\n            _burnPoolShare(poolAmountIn);\\n            //_pushPoolShare(_factory, exitFee);\\n            _pushUnderlying(_datatokenAddress, _controller, ssAmountOut);\\n            //call unstake on 1ss to do cleanup on their side\\n            ssContract.UnStake(\\n                _datatokenAddress,\\n                ssAmountOut,\\n                poolAmountIn\\n            );\\n            emit LOG_BPT_SS(poolAmountIn);\\n        }\\n        \\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        //_burnPoolShare(bsub(poolAmountIn, exitFee));\\n        _burnPoolShare(poolAmountIn);\\n        //_pushPoolShare(_factory, exitFee);\\n        _pushUnderlying(_baseTokenAddress, msg.sender, tokenAmountOut);\\n        return tokenAmountOut;\\n    }\\n\\n    \\n\\n    /**\\n     * @dev calcSingleOutPoolIn\\n     *      Returns expected amount of tokenOut for removing exact poolAmountIn pool shares from the pool\\n     * @param tokenOut tokenOut\\n     * @param poolAmountIn amount of shares spent\\n     */\\n    function calcSingleOutPoolIn(address tokenOut, uint256 poolAmountIn)\\n        external\\n        view\\n        returns (uint256 tokenAmountOut)\\n    {\\n        Record memory outRecord = _records[tokenOut];\\n\\n        tokenAmountOut = calcSingleOutGivenPoolIn(\\n            outRecord.balance,\\n            _totalSupply,\\n            poolAmountIn\\n        );\\n\\n        return tokenAmountOut;\\n    }\\n\\n    /**\\n     * @dev calcPoolInSingleOut\\n     *      Returns number of poolshares needed to withdraw exact tokenAmountOut tokens\\n     * @param tokenOut tokenOut\\n     * @param tokenAmountOut expected amount of tokensOut\\n     */\\n    function calcPoolInSingleOut(address tokenOut, uint256 tokenAmountOut)\\n        external\\n        view\\n        returns (uint256 poolAmountIn)\\n    {\\n        Record memory outRecord = _records[tokenOut];\\n\\n        poolAmountIn = calcPoolInGivenSingleOut(\\n            outRecord.balance,\\n            _totalSupply,\\n            tokenAmountOut\\n        );\\n        return poolAmountIn;\\n    }\\n\\n    /**\\n     * @dev calcSingleInPoolOut\\n     *      Returns number of tokens to be staked to the pool in order to get an exact number of poolshares\\n     * @param tokenIn tokenIn\\n     * @param poolAmountOut expected amount of pool shares\\n     */\\n    function calcSingleInPoolOut(address tokenIn, uint256 poolAmountOut)\\n        external\\n        view\\n        returns (uint256 tokenAmountIn)\\n    {\\n        Record memory inRecord = _records[tokenIn];\\n\\n        tokenAmountIn = calcSingleInGivenPoolOut(\\n            inRecord.balance,\\n            _totalSupply,\\n            poolAmountOut\\n        );\\n\\n        return tokenAmountIn;\\n    }\\n\\n    /**\\n     * @dev calcPoolOutSingleIn\\n     *      Returns number of poolshares obtain by staking exact tokenAmountIn tokens\\n     * @param tokenIn tokenIn\\n     * @param tokenAmountIn exact number of tokens staked\\n     */\\n    function calcPoolOutSingleIn(address tokenIn, uint256 tokenAmountIn)\\n        external\\n        view\\n        returns (uint256 poolAmountOut)\\n    {\\n        Record memory inRecord = _records[tokenIn];\\n\\n        poolAmountOut = calcPoolOutGivenSingleIn(\\n            inRecord.balance,\\n            _totalSupply,\\n            tokenAmountIn\\n        );\\n\\n        return poolAmountOut;\\n    }\\n\\n\\n    // Internal functions below\\n\\n    // ==\\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\\n    // You must `_lock_` or otherwise ensure reentry-safety\\n    function _pullUnderlying(\\n        address erc20,\\n        address from,\\n        uint256 amount\\n    ) internal {\\n        uint256 balanceBefore = IERC20(erc20).balanceOf(address(this));\\n        IERC20(erc20).safeTransferFrom(from, address(this), amount);\\n        require(IERC20(erc20).balanceOf(address(this)) >= balanceBefore + amount,\\n                    \\\"Transfer amount is too low\\\");\\n        //require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    }\\n\\n    function _pushUnderlying(\\n        address erc20,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        IERC20(erc20).safeTransfer(to, amount);\\n        //require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    }\\n\\n    function _pullPoolShare(address from, uint256 amount) internal {\\n        _pull(from, amount);\\n    }\\n\\n    function _pushPoolShare(address to, uint256 amount) internal {\\n        _push(to, amount);\\n    }\\n\\n    function _mintPoolShare(uint256 amount) internal {\\n        _mint(amount);\\n    }\\n\\n    function _burnPoolShare(uint256 amount) internal {\\n        _burn(amount);\\n    }\\n\\n    // Absorb any tokens that have been sent to this contract into the pool\\n    function gulp(address token)\\n        external\\n        _lock_\\n    {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        uint256 oldBalance = _records[token].balance;\\n        _records[token].balance = IERC20(token).balanceOf(address(this));\\n        emit Gulped(token,oldBalance, _records[token].balance);\\n    }\\n}\"\r\n    },\r\n    \"contracts/pools/balancer/BConst.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.12;\\n// Copyright Balancer, BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ncontract BConst {\\n    uint public constant BONE              = 1e18;\\n\\n    uint public constant MIN_BOUND_TOKENS  = 2;\\n    uint public constant MAX_BOUND_TOKENS  = 2;\\n\\n    uint public constant MIN_FEE           = BONE / 1e4;\\n    uint public constant MAX_FEE           = BONE / 10;\\n    uint public constant EXIT_FEE          = 0;\\n\\n    uint public constant MIN_WEIGHT        = BONE;\\n    uint public constant MAX_WEIGHT        = BONE * 50;\\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\\n    uint public constant MIN_BALANCE       = BONE / 1e12;\\n\\n    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\\n\\n    uint public constant MIN_BPOW_BASE     = 1 wei;\\n    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\\n    uint public constant BPOW_PRECISION    = BONE / 1e10;\\n\\n    uint public constant MAX_IN_RATIO      = BONE / 2;\\n    uint public constant MAX_OUT_RATIO     = (BONE / 2) + 1 wei;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Deployer.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\n/**\\n * @title Deployer Contract\\n * @author Ocean Protocol Team\\n *\\n * @dev Contract Deployer\\n *      This contract allowes factory contract \\n *      to deploy new contract instances using\\n *      the same library pattern in solidity.\\n *      the logic it self is deployed only once, but\\n *      executed in the context of the new storage \\n *      contract (new contract instance)\\n */\\ncontract Deployer {\\n    event InstanceDeployed(address instance);\\n    \\n    // /**\\n    //  * @dev deploy\\n    //  *      deploy new contract instance \\n    //  * @param _logic the logic contract address\\n    //  * @return  address of the new instance\\n    //  */\\n    function deploy(\\n        address _logic\\n    ) \\n      internal \\n      returns (address instance) \\n    {\\n        bytes20 targetBytes = bytes20(_logic);\\n        // solhint-disable-next-line max-line-length\\n        // Follows OpenZeppelin Implementation https://github.com/OpenZeppelin/openzeppelin-sdk/blob/71c9ad77e0326db079e6a643eca8568ab316d4a9/packages/lib/contracts/upgradeability/ProxyFactory.sol\\n        // solhint-disable-next-line max-line-length\\n        // Adapted from https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\\n        /* solium-disable-next-line security/no-inline-assembly */\\n        assembly {\\n          let clone := mload(0x40)\\n          mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n          mstore(add(clone, 0x14), targetBytes)\\n          mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n          instance := create(0, clone, 0x37)\\n        }\\n        emit InstanceDeployed(address(instance));\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISideStaking.sol\": {\r\n      \"content\": \"// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface ISideStaking {\\n\\n\\n    function newDatatokenCreated(\\n        address datatokenAddress,\\n        address baseTokenAddress,\\n        address poolAddress,\\n        address publisherAddress,\\n        uint256[] calldata ssParams\\n    ) external returns (bool);\\n\\n    function getDatatokenCirculatingSupply(address datatokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getPublisherAddress(address datatokenAddress)\\n        external\\n        view\\n        returns (address);\\n\\n    function getBaseTokenAddress(address datatokenAddress)\\n        external\\n        view\\n        returns (address);\\n\\n    function getPoolAddress(address datatokenAddress)\\n        external\\n        view\\n        returns (address);\\n\\n    function getBaseTokenBalance(address datatokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getDatatokenBalance(address datatokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getvestingEndBlock(address datatokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getvestingAmount(address datatokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getvestingLastBlock(address datatokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getvestingAmountSoFar(address datatokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n\\n\\n    function canStake(\\n        address datatokenAddress,\\n        uint256 amount\\n    ) external view returns (bool);\\n\\n    function Stake(\\n        address datatokenAddress,\\n        uint256 amount\\n    ) external;\\n\\n    function canUnStake(\\n        address datatokenAddress,\\n        uint256 amount\\n    ) external view returns (bool);\\n\\n    function UnStake(\\n        address datatokenAddress,\\n        uint256 amount,\\n        uint256 poolAmountIn\\n    ) external;\\n\\n    function getId() pure external returns (uint8);\\n\\n  \\n}\"\r\n    },\r\n    \"contracts/pools/balancer/BToken.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.12;\\n// Copyright Balancer, BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\nimport './BNum.sol';\\n// import '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../interfaces/IERC20.sol';\\n// Highly opinionated token implementation\\n\\n// interface IERC20 {\\n//     event Approval(address indexed src, address indexed dst, uint amt);\\n//     event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n//     function totalSupply() external view returns (uint);\\n//     function balanceOf(address whom) external view returns (uint);\\n//     function allowance(address src, address dst) external view returns (uint);\\n\\n//     function approve(address dst, uint amt) external returns (bool);\\n//     function transfer(address dst, uint amt) external returns (bool);\\n//     function transferFrom(\\n//         address src, address dst, uint amt\\n//     ) external returns (bool);\\n// }\\n\\ncontract BTokenBase is BNum {\\n\\n    mapping(address => uint)                   internal _balance;\\n    mapping(address => mapping(address=>uint)) internal _allowance;\\n    uint internal _totalSupply;\\n\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function _mint(uint amt) internal {\\n        _balance[address(this)] = badd(_balance[address(this)], amt);\\n        _totalSupply = badd(_totalSupply, amt);\\n        emit Transfer(address(0), address(this), amt);\\n    }\\n\\n    function _burn(uint amt) internal {\\n        require(\\n            _balance[address(this)] >= amt, \\n            'ERR_INSUFFICIENT_BAL'\\n        );\\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\\n        _totalSupply = bsub(_totalSupply, amt);\\n        emit Transfer(address(this), address(0), amt);\\n    }\\n\\n    function _move(address src, address dst, uint amt) internal {\\n        require(_balance[src] >= amt, 'ERR_INSUFFICIENT_BAL');\\n        _balance[src] = bsub(_balance[src], amt);\\n        _balance[dst] = badd(_balance[dst], amt);\\n        emit Transfer(src, dst, amt);\\n    }\\n\\n    function _push(address to, uint amt) internal {\\n        _move(address(this), to, amt);\\n    }\\n\\n    function _pull(address from, uint amt) internal {\\n        _move(from, address(this), amt);\\n    }\\n}\\n\\ncontract BToken is BTokenBase {\\n\\n    function name() external view returns (string memory) {\\n        return 'Ocean Pool Token';\\n    }\\n\\n    function symbol() external view returns (string memory) {\\n        return 'OPT';\\n    }\\n\\n    function decimals() external view returns(uint8) {\\n        return 18;\\n    }\\n\\n    function allowance(address src, address dst) external view returns (uint256) {\\n        return _allowance[src][dst];\\n    }\\n\\n    function balanceOf(address whom) external view returns (uint) {\\n        return _balance[whom];\\n    }\\n\\n    function totalSupply() public view returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function approve(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = amt;\\n        emit Approval(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function increaseApproval(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\\n        uint oldValue = _allowance[msg.sender][dst];\\n        if (amt > oldValue) {\\n            _allowance[msg.sender][dst] = 0;\\n        } else {\\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\\n        }\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint amt) external returns (bool) {\\n        _move(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address src, \\n        address dst, \\n        uint amt\\n    ) \\n    external\\n    returns (bool) \\n    {\\n        require(\\n            msg.sender == src || amt <= _allowance[src][msg.sender], \\n            'ERR_BTOKEN_BAD_CALLER'\\n        );\\n        _move(src, dst, amt);\\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(int(-1)) ) {\\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\\n            emit Approval(src, msg.sender, _allowance[src][msg.sender]);\\n        }\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pools/balancer/BMath.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.12;\\n// Copyright Balancer, BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\nimport './BNum.sol';\\n\\n\\nimport \\\"../../interfaces/IFactoryRouter.sol\\\";\\n\\ncontract BMath is BConst, BNum {\\n\\n   // uint public _swapMarketFee;\\n    uint public _swapPublishMarketFee;\\n    uint internal _swapFee;\\n  \\n    address public router; // BFactory address to push token exitFee to\\n\\n    address internal _datatokenAddress; //datatoken address\\n    address internal _baseTokenAddress; //base token address\\n    mapping(address => uint) public communityFees;\\n\\n     mapping(address => uint) public publishMarketFees;\\n   // mapping(address => uint) public marketFees;\\n\\n\\n    function getOPCFee() public view returns (uint) {\\n        return IFactoryRouter(router).getOPCFee(_baseTokenAddress);\\n    }\\n    \\n    struct swapfees{\\n        uint256 LPFee;\\n        uint256 oceanFeeAmount;\\n        uint256 publishMarketFeeAmount;\\n        uint256 consumeMarketFee;\\n    }\\n    /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcSpotPrice(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint _swapMarketFee\\n    )\\n        internal view\\n        returns (uint spotPrice)\\n        \\n    {   \\n       \\n\\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n        uint ratio = bdiv(numer, denom);\\n        uint scale = bdiv(BONE, bsub(BONE, _swapFee+getOPCFee()+_swapPublishMarketFee+_swapMarketFee));\\n      \\n        return  (spotPrice = bmul(ratio, scale));\\n    }\\n\\n    \\n    //    data = [\\n    //         inRecord.balance,\\n    //         inRecord.denorm,\\n    //         outRecord.balance,\\n    //         outRecord.denorm\\n    //     ];\\n    function calcOutGivenIn(\\n        uint[4] memory data,\\n        uint tokenAmountIn,\\n        //address tokenInAddress,\\n        uint256 _consumeMarketSwapFee\\n\\n    )\\n        public view\\n        returns (uint tokenAmountOut, uint balanceInToAdd, swapfees memory _swapfees)\\n    {\\n        uint weightRatio = bdiv(data[1], data[3]);\\n\\n        _swapfees.oceanFeeAmount =  bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, getOPCFee())));\\n\\n        \\n        _swapfees.publishMarketFeeAmount =  bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, _swapPublishMarketFee)));\\n        \\n\\n        _swapfees.LPFee = bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, _swapFee)));\\n        _swapfees.consumeMarketFee = bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, _consumeMarketSwapFee)));\\n        uint totalFee =_swapFee+getOPCFee()+_swapPublishMarketFee+_consumeMarketSwapFee;\\n\\n        uint adjustedIn = bsub(BONE, totalFee);\\n        \\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n         \\n        uint y = bdiv(data[0], badd(data[0], adjustedIn));\\n        uint foo = bpow(y, weightRatio);\\n        uint bar = bsub(BONE, foo);\\n        \\n\\n        tokenAmountOut = bmul(data[2], bar);\\n       \\n        return (tokenAmountOut, bsub(tokenAmountIn,(_swapfees.oceanFeeAmount+_swapfees.publishMarketFeeAmount+_swapfees.consumeMarketFee)), _swapfees);\\n        \\n    }\\n\\n     \\n    function calcInGivenOut(\\n        uint[4] memory data,\\n        uint tokenAmountOut,\\n        uint _consumeMarketSwapFee\\n    )\\n        public view \\n        returns (uint tokenAmountIn, uint tokenAmountInBalance, swapfees memory _swapfees)\\n    {\\n        uint weightRatio = bdiv(data[3], data[1]);\\n        uint diff = bsub(data[2], tokenAmountOut);\\n        uint y = bdiv(data[2], diff);\\n        uint foo = bpow(y, weightRatio);\\n        foo = bsub(foo, BONE);\\n        uint totalFee =_swapFee+getOPCFee()+_consumeMarketSwapFee+_swapPublishMarketFee;\\n        \\n        \\n        tokenAmountIn = bdiv(bmul(data[0], foo), bsub(BONE, totalFee));\\n        _swapfees.oceanFeeAmount =  bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, getOPCFee())));\\n        \\n     \\n        _swapfees.publishMarketFeeAmount =  bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, _swapPublishMarketFee)));\\n\\n     \\n        _swapfees.LPFee = bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, _swapFee)));\\n        _swapfees.consumeMarketFee = bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, _consumeMarketSwapFee)));\\n        \\n      \\n        tokenAmountInBalance = bsub(tokenAmountIn,(_swapfees.oceanFeeAmount+_swapfees.publishMarketFeeAmount+_swapfees.consumeMarketFee));\\n      \\n        \\n        return (tokenAmountIn, tokenAmountInBalance,_swapfees);\\n    }\\n\\n    function calcPoolOutGivenSingleIn(\\n        uint tokenBalanceIn,\\n        uint poolSupply,\\n        uint tokenAmountIn\\n       \\n    )\\n        internal pure\\n        returns (uint poolAmountOut)\\n    {\\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, BONE);\\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\n        uint poolRatio = bsub(tokenInRatio,BONE);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        require(newPoolSupply >= 2, 'ERR_TOKEN_AMOUNT_IN_TOO_LOW'); \\n        newPoolSupply = newPoolSupply/2;\\n        return newPoolSupply;\\n    }\\n\\n    function calcSingleInGivenPoolOut(\\n        uint tokenBalanceIn,\\n        uint poolSupply,\\n        uint poolAmountOut\\n    )\\n        internal pure\\n        returns (uint tokenAmountIn)\\n    {\\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n        uint tokenInRatio = bsub(poolRatio, BONE);\\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\n        require(newTokenBalanceIn >= 1, 'ERR_POOL_AMOUNT_OUT_TOO_LOW'); \\n        newTokenBalanceIn = newTokenBalanceIn * 2;\\n        return newTokenBalanceIn;\\n    }\\n\\n    function calcSingleOutGivenPoolIn(\\n        uint tokenSupply,\\n        uint poolSupply,\\n        uint poolAmountIn\\n    )\\n        internal pure\\n        returns (uint tokenAmountOut)\\n    {\\n        require(poolAmountIn >= 1, 'ERR_POOL_AMOUNT_IN_TOO_LOW'); \\n        poolAmountIn = poolAmountIn * 2;\\n        uint newPoolSupply = bsub(poolSupply, poolAmountIn);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n        uint tokenOutRatio = bsub(BONE,poolRatio);\\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenSupply);\\n        return newTokenBalanceOut;\\n    }\\n\\n    function calcPoolInGivenSingleOut(\\n        uint tokenBalanceOut,\\n        uint poolSupply,\\n        uint tokenAmountOut\\n    )\\n        internal pure\\n        returns (uint poolAmountIn)\\n    {\\n        uint newTokenBalanceOut = bsub(\\n            tokenBalanceOut, \\n            tokenAmountOut\\n        );\\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\n        uint poolRatio = bsub(BONE,tokenOutRatio);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        require(newPoolSupply >= 2, 'ERR_TOKEN_AMOUNT_OUT_TOO_LOW'); \\n        newPoolSupply = newPoolSupply/2;\\n        return newPoolSupply;\\n    }\\n\\n\\n    \\n\\n}\\n\"\r\n    },\r\n    \"contracts/pools/balancer/BNum.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.12;\\n// Copyright Balancer, BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\nimport './BConst.sol';\\n\\ncontract BNum is BConst {\\n\\n    function btoi(uint a)\\n        internal pure \\n        returns (uint)\\n    {\\n        return a / BONE;\\n    }\\n\\n    function bfloor(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return btoi(a) * BONE;\\n    }\\n\\n    function badd(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c = a + b;\\n        require(c >= a, 'ERR_ADD_OVERFLOW');\\n        return c;\\n    }\\n\\n    function bsub(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        (uint c, bool flag) = bsubSign(a, b);\\n        require(!flag, 'ERR_SUB_UNDERFLOW');\\n        return c;\\n    }\\n\\n    function bsubSign(uint a, uint b)\\n        internal pure\\n        returns (uint, bool)\\n    {\\n        if (a >= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function bmul(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, 'ERR_MUL_OVERFLOW');\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 >= c0, 'ERR_MUL_OVERFLOW');\\n        uint c2 = c1 / BONE;\\n        return c2;\\n    }\\n\\n    function bdiv(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(b != 0, 'ERR_DIV_ZERO');\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, 'ERR_DIV_INTERNAL'); // bmul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 >= c0, 'ERR_DIV_INTERNAL'); //  badd require\\n        uint c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    // DSMath.wpow\\n    function bpowi(uint a, uint n)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint b = a;\\n        uint z = n % 2 != 0 ? b : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            b = bmul(b, b);\\n\\n            if (n % 2 != 0) {\\n                z = bmul(z, b);\\n            }\\n        }\\n        return z;\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n    // of approximation of b^0.w\\n    function bpow(uint base, uint exp)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(base >= MIN_BPOW_BASE, 'ERR_BPOW_BASE_TOO_LOW');\\n        require(base <= MAX_BPOW_BASE, 'ERR_BPOW_BASE_TOO_HIGH');\\n\\n        uint whole = bfloor(exp);\\n        uint remain = bsub(exp, whole);\\n\\n        uint wholePow = bpowi(base, btoi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n        return bmul(wholePow, partialResult);\\n    }\\n\\n    function bpowApprox(uint base, uint exp, uint precision)\\n        internal pure\\n        returns (uint)\\n    {\\n        // term 0:\\n        uint a = exp;\\n        (uint x, bool xneg) = bsubSign(base, BONE);\\n        uint term = BONE;\\n        uint sum = term;\\n        bool negative = false;\\n\\n\\n        // term(k) = numer / denom \\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term >= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n            term = bmul(term, bmul(c, x));\\n            term = bdiv(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = bsub(sum, term);\\n            } else {\\n                sum = badd(sum, term);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFactoryRouter.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface IFactoryRouter {\\n    function deployPool(\\n        address[2] calldata tokens, // [datatokenAddress, baseTokenAddress]\\n        uint256[] calldata ssParams,\\n        uint256[] calldata swapFees,\\n        address[] calldata addresses\\n    ) external returns (address);\\n\\n    function deployFixedRate(\\n        address fixedPriceAddress,\\n        address[] calldata addresses,\\n        uint256[] calldata uints\\n    ) external returns (bytes32 exchangeId);\\n\\n    function getOPCFee(address baseToken) external view returns (uint256);\\n    function getOPCFees() external view returns (uint256,uint256);\\n    function getOPCConsumeFee() external view returns (uint256);\\n    function getOPCProviderFee() external view returns (uint256);\\n\\n    function getMinVestingPeriod() external view returns (uint256);\\n    function deployDispenser(\\n        address _dispenser,\\n        address datatoken,\\n        uint256 maxTokens,\\n        uint256 maxBalance,\\n        address owner,\\n        address allowedSwapper\\n    ) external;\\n\\n    function isApprovedToken(address) external view returns(bool);\\n    function getApprovedTokens() external view returns(address[] memory);\\n    function isSSContract(address) external view returns(bool);\\n    function getSSContracts() external view returns(address[] memory);\\n    function isFixedRateContract(address) external view returns(bool);\\n    function getFixedRatesContracts() external view returns(address[] memory);\\n    function isDispenserContract(address) external view returns(bool);\\n    function getDispensersContracts() external view returns(address[] memory);\\n    function isPoolTemplate(address) external view returns(bool);\\n    function getPoolTemplates() external view returns(address[] memory);\\n\\n    struct Stakes {\\n        address poolAddress;\\n        uint256 tokenAmountIn;\\n        uint256 minPoolAmountOut;\\n    }\\n    function stakeBatch(Stakes[] calldata) external;\\n\\n    enum operationType {\\n        SwapExactIn,\\n        SwapExactOut,\\n        FixedRate,\\n        Dispenser\\n    }\\n\\n    struct Operations {\\n        bytes32 exchangeIds; // used for fixedRate or dispenser\\n        address source; // pool, dispenser or fixed rate address\\n        operationType operation; // type of operation: enum operationType\\n        address tokenIn; // token in address, only for pools\\n        uint256 amountsIn; // ExactAmount In for swapExactIn operation, maxAmount In for swapExactOut\\n        address tokenOut; // token out address, only for pools\\n        uint256 amountsOut; // minAmountOut for swapExactIn or exactAmountOut for swapExactOut\\n        uint256 maxPrice; // maxPrice, only for pools\\n        uint256 swapMarketFee;\\n        address marketFeeAddress;\\n    }\\n    function buyDTBatch(Operations[] calldata) external;\\n    function updateOPCCollector(address _opcCollector) external;\\n    function getOPCCollector() view external returns (address);\\n}\"\r\n    },\r\n    \"contracts/utils/ERC721/Address.sol\": {\r\n      \"content\": \"\\npragma solidity 0.8.12;\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n\\n}\\n\\n\\n// File @openzeppelin/contracts/utils/Context.sol@v4.0.0\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_routerOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oceanToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bpoolTemplate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_opcCollector\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_preCreatedPools\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newBPoolAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"registeredBy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"datatokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"baseTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bpoolTemplateAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ssAddress\",\"type\":\"address\"}],\"name\":\"BPoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"DispenserContractAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"DispenserContractRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"FactoryContractChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"FixedRateContractAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"FixedRateContractRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"}],\"name\":\"InstanceDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isOcean\",\"type\":\"bool\"}],\"name\":\"NewPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOpcCollector\",\"type\":\"address\"}],\"name\":\"OPCCollectorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSwapOceanFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSwapNonOceanFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newConsumeFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newProviderFee\",\"type\":\"uint256\"}],\"name\":\"OPCFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"PoolTemplateAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"PoolTemplateRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"RouterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"SSContractAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"SSContractRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minVestingPeriodInBlocks\",\"type\":\"uint256\"}],\"name\":\"VestingPeriodChanges\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BPOW_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXIT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INIT_POOL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"addApprovedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dispenser\",\"type\":\"address\"}],\"name\":\"addDispenserContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"addFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fixedRate\",\"type\":\"address\"}],\"name\":\"addFixedRateContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolTemplate\",\"type\":\"address\"}],\"name\":\"addPoolTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ssContract\",\"type\":\"address\"}],\"name\":\"addSSContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeIds\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"enum IFactoryRouter.operationType\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountsIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountsOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapMarketFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"marketFeeAddress\",\"type\":\"address\"}],\"internalType\":\"struct IFactoryRouter.Operations[]\",\"name\":\"_operations\",\"type\":\"tuple[]\"}],\"name\":\"buyDTBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_routerOwner\",\"type\":\"address\"}],\"name\":\"changeRouterOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"consumeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dispenser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"datatoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBalance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"allowedSwapper\",\"type\":\"address\"}],\"name\":\"deployDispenser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fixedPriceAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"uints\",\"type\":\"uint256[]\"}],\"name\":\"deployFixedRate\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"tokens\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[]\",\"name\":\"ssParams\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"swapFees\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"deployPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dispensers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixedRate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fixedrates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getApprovedTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDispensersContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFixedRatesContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinVestingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOPCCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOPCConsumeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"}],\"name\":\"getOPCFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOPCFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOPCProviderFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolTemplates\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSSContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"isApprovedToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dispenser\",\"type\":\"address\"}],\"name\":\"isDispenserContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fixedRate\",\"type\":\"address\"}],\"name\":\"isFixedRateContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolTemplate\",\"type\":\"address\"}],\"name\":\"isPoolTemplate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ssContract\",\"type\":\"address\"}],\"name\":\"isSSContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minVestingPeriodInBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"opcCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolTemplates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"providerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"removeApprovedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dispenser\",\"type\":\"address\"}],\"name\":\"removeDispenserContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fixedRate\",\"type\":\"address\"}],\"name\":\"removeFixedRateContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolTemplate\",\"type\":\"address\"}],\"name\":\"removePoolTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ssContract\",\"type\":\"address\"}],\"name\":\"removeSSContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ssContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPoolAmountOut\",\"type\":\"uint256\"}],\"internalType\":\"struct IFactoryRouter.Stakes[]\",\"name\":\"_stakes\",\"type\":\"tuple[]\"}],\"name\":\"stakeBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapNonOceanFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapOceanFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPeriod\",\"type\":\"uint256\"}],\"name\":\"updateMinVestingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_opcCollector\",\"type\":\"address\"}],\"name\":\"updateOPCCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newSwapOceanFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newSwapNonOceanFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newConsumeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newProviderFee\",\"type\":\"uint256\"}],\"name\":\"updateOPCFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FactoryRouter", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c7ec1970b09224b317c52d92f37f5e1e4ff6b687000000000000000000000000967da4048cd07ab37855c090aaf366e4ce1b9f480000000000000000000000008dac419d5d81af8c8e795d0d73f64d5220e28cd800000000000000000000000049e35cd2bae043abd9074b6e5a649a5adeb05c3300000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}