{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"StakingPoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.11;\\n\\nimport {ClonesWithImmutableArgs} from \\\"ClonesWithImmutableArgs.sol\\\";\\n\\nimport {ERC20} from \\\"ERC20.sol\\\";\\nimport {ERC721} from \\\"ERC721.sol\\\";\\n\\nimport {xERC20} from \\\"xERC20.sol\\\";\\nimport {ERC20StakingPool} from \\\"ERC20StakingPool.sol\\\";\\nimport {ERC721StakingPool} from \\\"ERC721StakingPool.sol\\\";\\n\\n/// @title StakingPoolFactory\\n/// @author zefram.eth\\n/// @notice Factory for deploying ERC20StakingPool and ERC721StakingPool contracts cheaply\\ncontract StakingPoolFactory {\\n    /// -----------------------------------------------------------------------\\n    /// Library usage\\n    /// -----------------------------------------------------------------------\\n\\n    using ClonesWithImmutableArgs for address;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Events\\n    /// -----------------------------------------------------------------------\\n\\n    event CreateXERC20(xERC20 stakingPool);\\n    event CreateERC20StakingPool(ERC20StakingPool stakingPool);\\n    event CreateERC721StakingPool(ERC721StakingPool stakingPool);\\n\\n    /// -----------------------------------------------------------------------\\n    /// Immutable parameters\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice The contract used as the template for all xERC20 contracts created\\n    xERC20 public immutable xERC20Implementation;\\n\\n    /// @notice The contract used as the template for all ERC20StakingPool contracts created\\n    ERC20StakingPool public immutable erc20StakingPoolImplementation;\\n\\n    /// @notice The contract used as the template for all ERC721StakingPool contracts created\\n    ERC721StakingPool public immutable erc721StakingPoolImplementation;\\n\\n    constructor(\\n        xERC20 xERC20Implementation_,\\n        ERC20StakingPool erc20StakingPoolImplementation_,\\n        ERC721StakingPool erc721StakingPoolImplementation_\\n    ) {\\n        xERC20Implementation = xERC20Implementation_;\\n        erc20StakingPoolImplementation = erc20StakingPoolImplementation_;\\n        erc721StakingPoolImplementation = erc721StakingPoolImplementation_;\\n    }\\n\\n    /// @notice Creates an xERC20 contract\\n    /// @dev Uses a modified minimal proxy contract that stores immutable parameters in code and\\n    /// passes them in through calldata. See ClonesWithImmutableArgs.\\n    /// @param name The name of the xERC20 token\\n    /// @param symbol The symbol of the xERC20 token\\n    /// @param decimals The decimals of the xERC20 token\\n    /// @param stakeToken The token being staked in the pool\\n    /// @param DURATION The length of each reward period, in seconds\\n    /// @return stakingPool The created xERC20 contract\\n    function createXERC20(\\n        bytes32 name,\\n        bytes32 symbol,\\n        uint8 decimals,\\n        ERC20 stakeToken,\\n        uint64 DURATION\\n    ) external returns (xERC20 stakingPool) {\\n        bytes memory data = abi.encodePacked(\\n            name,\\n            symbol,\\n            decimals,\\n            stakeToken,\\n            DURATION\\n        );\\n\\n        stakingPool = xERC20(address(xERC20Implementation).clone(data));\\n        stakingPool.initialize(msg.sender);\\n\\n        emit CreateXERC20(stakingPool);\\n    }\\n\\n    /// @notice Creates an ERC20StakingPool contract\\n    /// @dev Uses a modified minimal proxy contract that stores immutable parameters in code and\\n    /// passes them in through calldata. See ClonesWithImmutableArgs.\\n    /// @param rewardToken The token being rewarded to stakers\\n    /// @param stakeToken The token being staked in the pool\\n    /// @param DURATION The length of each reward period, in seconds\\n    /// @return stakingPool The created ERC20StakingPool contract\\n    function createERC20StakingPool(\\n        ERC20 rewardToken,\\n        ERC20 stakeToken,\\n        uint64 DURATION\\n    ) external returns (ERC20StakingPool stakingPool) {\\n        bytes memory data = abi.encodePacked(rewardToken, stakeToken, DURATION);\\n\\n        stakingPool = ERC20StakingPool(\\n            address(erc20StakingPoolImplementation).clone(data)\\n        );\\n        stakingPool.initialize(msg.sender);\\n\\n        emit CreateERC20StakingPool(stakingPool);\\n    }\\n\\n    /// @notice Creates an ERC721StakingPool contract\\n    /// @dev Uses a modified minimal proxy contract that stores immutable parameters in code and\\n    /// passes them in through calldata. See ClonesWithImmutableArgs.\\n    /// @param rewardToken The token being rewarded to stakers\\n    /// @param stakeToken The token being staked in the pool\\n    /// @param DURATION The length of each reward period, in seconds\\n    /// @return stakingPool The created ERC721StakingPool contract\\n    function createERC721StakingPool(\\n        ERC20 rewardToken,\\n        ERC721 stakeToken,\\n        uint64 DURATION\\n    ) external returns (ERC721StakingPool stakingPool) {\\n        bytes memory data = abi.encodePacked(rewardToken, stakeToken, DURATION);\\n\\n        stakingPool = ERC721StakingPool(\\n            address(erc721StakingPoolImplementation).clone(data)\\n        );\\n        stakingPool.initialize(msg.sender);\\n\\n        emit CreateERC721StakingPool(stakingPool);\\n    }\\n}\\n\"\r\n    },\r\n    \"ClonesWithImmutableArgs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD\\n\\npragma solidity ^0.8.4;\\n\\n/// @title ClonesWithImmutableArgs\\n/// @author wighawag, zefram.eth\\n/// @notice Enables creating clone contracts with immutable args\\nlibrary ClonesWithImmutableArgs {\\n    error CreateFail();\\n\\n    /// @notice Creates a clone proxy of the implementation contract, with immutable args\\n    /// @dev data cannot exceed 65535 bytes, since 2 bytes are used to store the data length\\n    /// @param implementation The implementation contract to clone\\n    /// @param data Encoded immutable args\\n    /// @return instance The address of the created clone\\n    function clone(address implementation, bytes memory data)\\n        internal\\n        returns (address instance)\\n    {\\n        // unrealistic for memory ptr or data length to exceed 256 bits\\n        unchecked {\\n            uint256 extraLength = data.length + 2; // +2 bytes for telling how much data there is appended to the call\\n            uint256 creationSize = 0x43 + extraLength;\\n            uint256 runSize = creationSize - 11;\\n            uint256 dataPtr;\\n            uint256 ptr;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                ptr := mload(0x40)\\n\\n                // -------------------------------------------------------------------------------------------------------------\\n                // CREATION (11 bytes)\\n                // -------------------------------------------------------------------------------------------------------------\\n\\n                // 3d          | RETURNDATASIZE        | 0                       | \u2013\\n                // 61 runtime  | PUSH2 runtime (r)     | r 0                     | \u2013\\n                mstore(\\n                    ptr,\\n                    0x3d61000000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x02), shl(240, runSize)) // size of the contract running bytecode (16 bits)\\n\\n                // creation size = 0b\\n                // 80          | DUP1                  | r r 0                   | \u2013\\n                // 60 creation | PUSH1 creation (c)    | c r r 0                 | \u2013\\n                // 3d          | RETURNDATASIZE        | 0 c r r 0               | \u2013\\n                // 39          | CODECOPY              | r 0                     | [0-2d]: runtime code\\n                // 81          | DUP2                  | 0 c  0                  | [0-2d]: runtime code\\n                // f3          | RETURN                | 0                       | [0-2d]: runtime code\\n                mstore(\\n                    add(ptr, 0x04),\\n                    0x80600b3d3981f300000000000000000000000000000000000000000000000000\\n                )\\n\\n                // -------------------------------------------------------------------------------------------------------------\\n                // RUNTIME\\n                // -------------------------------------------------------------------------------------------------------------\\n\\n                // 36          | CALLDATASIZE          | cds                     | \u2013\\n                // 3d          | RETURNDATASIZE        | 0 cds                   | \u2013\\n                // 3d          | RETURNDATASIZE        | 0 0 cds                 | \u2013\\n                // 37          | CALLDATACOPY          | \u2013                       | [0, cds] = calldata\\n                // 61          | PUSH2 extra           | extra                   | [0, cds] = calldata\\n                mstore(\\n                    add(ptr, 0x0b),\\n                    0x363d3d3761000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x10), shl(240, extraLength))\\n\\n                // 60 0x38     | PUSH1 0x38            | 0x38 extra              | [0, cds] = calldata // 0x38 (56) is runtime size - data\\n                // 36          | CALLDATASIZE          | cds 0x38 extra          | [0, cds] = calldata\\n                // 39          | CODECOPY              | _                       | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0                       | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0 0                     | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0 0 0                   | [0, cds] = calldata\\n                // 36          | CALLDATASIZE          | cds 0 0 0               | [0, cds] = calldata\\n                // 61 extra    | PUSH2 extra           | extra cds 0 0 0         | [0, cds] = calldata\\n                mstore(\\n                    add(ptr, 0x12),\\n                    0x603836393d3d3d36610000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x1b), shl(240, extraLength))\\n\\n                // 01          | ADD                   | cds+extra 0 0 0         | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0 cds 0 0 0             | [0, cds] = calldata\\n                // 73 addr     | PUSH20 0x123\u2026         | addr 0 cds 0 0 0        | [0, cds] = calldata\\n                mstore(\\n                    add(ptr, 0x1d),\\n                    0x013d730000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x20), shl(0x60, implementation))\\n\\n                // 5a          | GAS                   | gas addr 0 cds 0 0 0    | [0, cds] = calldata\\n                // f4          | DELEGATECALL          | success 0               | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | rds success 0           | [0, cds] = calldata\\n                // 82          | DUP3                  | 0 rds success 0         | [0, cds] = calldata\\n                // 80          | DUP1                  | 0 0 rds success 0       | [0, cds] = calldata\\n                // 3e          | RETURNDATACOPY        | success 0               | [0, rds] = return data (there might be some irrelevant leftovers in memory [rds, cds] when rds < cds)\\n                // 90          | SWAP1                 | 0 success               | [0, rds] = return data\\n                // 3d          | RETURNDATASIZE        | rds 0 success           | [0, rds] = return data\\n                // 91          | SWAP2                 | success 0 rds           | [0, rds] = return data\\n                // 60 0x36     | PUSH1 0x36            | 0x36 sucess 0 rds       | [0, rds] = return data\\n                // 57          | JUMPI                 | 0 rds                   | [0, rds] = return data\\n                // fd          | REVERT                | \u2013                       | [0, rds] = return data\\n                // 5b          | JUMPDEST              | 0 rds                   | [0, rds] = return data\\n                // f3          | RETURN                | \u2013                       | [0, rds] = return data\\n\\n                mstore(\\n                    add(ptr, 0x34),\\n                    0x5af43d82803e903d91603657fd5bf30000000000000000000000000000000000\\n                )\\n            }\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // APPENDED DATA (Accessible from extcodecopy)\\n            // (but also send as appended data to the delegatecall)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            extraLength -= 2;\\n            uint256 counter = extraLength;\\n            uint256 copyPtr = ptr + 0x43;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                dataPtr := add(data, 32)\\n            }\\n            for (; counter >= 32; counter -= 32) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    mstore(copyPtr, mload(dataPtr))\\n                }\\n\\n                copyPtr += 32;\\n                dataPtr += 32;\\n            }\\n            uint256 mask = ~(256**(32 - counter) - 1);\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                mstore(copyPtr, and(mload(dataPtr), mask))\\n            }\\n            copyPtr += counter;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                mstore(copyPtr, shl(240, extraLength))\\n            }\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                instance := create(0, ptr, creationSize)\\n            }\\n            if (instance == address(0)) {\\n                revert CreateFail();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {Clone} from \\\"Clone.sol\\\";\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 is Clone {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               METADATA\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function name() external pure returns (string memory) {\\n        return string(abi.encodePacked(_getArgUint256(0)));\\n    }\\n\\n    function symbol() external pure returns (string memory) {\\n        return string(abi.encodePacked(_getArgUint256(0x20)));\\n    }\\n\\n    function decimals() external pure returns (uint8) {\\n        return _getArgUint8(0x40);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max)\\n            allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n\\n    function _getImmutableVariablesOffset()\\n        internal\\n        pure\\n        returns (uint256 offset)\\n    {\\n        assembly {\\n            offset := sub(\\n                calldatasize(),\\n                add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\\n            )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"Clone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD\\npragma solidity ^0.8.4;\\n\\n/// @title Clone\\n/// @author zefram.eth\\n/// @notice Provides helper functions for reading immutable args from calldata\\ncontract Clone {\\n    /// @notice Reads an immutable arg with type address\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgAddress(uint256 argOffset)\\n        internal\\n        pure\\n        returns (address arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        assembly {\\n            arg := shr(0x60, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint256\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint256(uint256 argOffset)\\n        internal\\n        pure\\n        returns (uint256 arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := calldataload(add(offset, argOffset))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint64\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint64(uint256 argOffset)\\n        internal\\n        pure\\n        returns (uint64 arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := shr(0xc0, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint8\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := shr(0xf8, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @return offset The offset of the packed immutable args in calldata\\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            offset := sub(\\n                calldatasize(),\\n                add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\\n            )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\\nabstract contract ERC721 {\\n    /*///////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed id\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 indexed id\\n    );\\n\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC721 STORAGE                        \\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(uint256 => address) public ownerOf;\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = ownerOf[id];\\n\\n        require(\\n            msg.sender == owner || isApprovedForAll[owner][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from ||\\n                msg.sender == getApproved[id] ||\\n                isApprovedForAll[from][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            balanceOf[from]--;\\n\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    \\\"\\\"\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    data\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        pure\\n        virtual\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = ownerOf[id];\\n\\n        require(ownerOf[id] != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            balanceOf[owner]--;\\n        }\\n\\n        delete ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    address(0),\\n                    id,\\n                    \\\"\\\"\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    address(0),\\n                    id,\\n                    data\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\ninterface ERC721TokenReceiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"xERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.4;\\n\\nimport {ERC20} from \\\"ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"SafeTransferLib.sol\\\";\\n\\nimport {Ownable} from \\\"Ownable.sol\\\";\\nimport {FullMath} from \\\"FullMath.sol\\\";\\nimport {ERC20 as CloneERC20} from \\\"ERC20.sol\\\";\\n\\n/// @title xERC20\\n/// @author zefram.eth\\n/// @notice A special type of ERC20 staking pool where the reward token is the same as\\n/// the stake token. This enables stakers to receive an xERC20 token representing their\\n/// stake that can then be transferred or plugged into other things (e.g. Uniswap).\\n/// @dev xERC20 is inspired by xSUSHI, but is superior because rewards are distributed over time rather\\n/// than immediately, which prevents MEV bots from stealing the rewards or malicious users staking immediately\\n/// before the reward distribution and unstaking immediately after.\\ncontract xERC20 is CloneERC20, Ownable {\\n    /// -----------------------------------------------------------------------\\n    /// Library usage\\n    /// -----------------------------------------------------------------------\\n\\n    using SafeTransferLib for ERC20;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Errors\\n    /// -----------------------------------------------------------------------\\n\\n    error Error_ZeroOwner();\\n    error Error_AlreadyInitialized();\\n    error Error_NotRewardDistributor();\\n    error Error_ZeroSupply();\\n\\n    /// -----------------------------------------------------------------------\\n    /// Events\\n    /// -----------------------------------------------------------------------\\n\\n    event RewardAdded(uint128 reward);\\n    event Staked(\\n        address indexed user,\\n        uint256 stakeTokenAmount,\\n        uint256 xERC20Amount\\n    );\\n    event Withdrawn(\\n        address indexed user,\\n        uint256 stakeTokenAmount,\\n        uint256 xERC20Amount\\n    );\\n\\n    /// -----------------------------------------------------------------------\\n    /// Constants\\n    /// -----------------------------------------------------------------------\\n\\n    uint256 internal constant PRECISION = 1e18;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Storage variables\\n    /// -----------------------------------------------------------------------\\n\\n    uint64 public currentUnlockEndTimestamp;\\n    uint64 public lastRewardTimestamp;\\n    uint128 public lastRewardAmount;\\n\\n    /// @notice Tracks if an address can call notifyReward()\\n    mapping(address => bool) public isRewardDistributor;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Immutable parameters\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice The token being staked in the pool\\n    function stakeToken() public pure returns (ERC20) {\\n        return ERC20(_getArgAddress(0x41));\\n    }\\n\\n    /// @notice The length of each reward period, in seconds\\n    function DURATION() public pure returns (uint64) {\\n        return _getArgUint64(0x55);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Initialization\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Initializes the owner, called by StakingPoolFactory\\n    /// @param initialOwner The initial owner of the contract\\n    function initialize(address initialOwner) external {\\n        if (owner() != address(0)) {\\n            revert Error_AlreadyInitialized();\\n        }\\n        if (initialOwner == address(0)) {\\n            revert Error_ZeroOwner();\\n        }\\n\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// User actions\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Stake tokens to receive xERC20 tokens\\n    /// @param stakeTokenAmount The amount of tokens to stake\\n    /// @return xERC20Amount The amount of xERC20 tokens minted\\n    function stake(uint256 stakeTokenAmount)\\n        external\\n        virtual\\n        returns (uint256 xERC20Amount)\\n    {\\n        /// -----------------------------------------------------------------------\\n        /// Validation\\n        /// -----------------------------------------------------------------------\\n\\n        if (stakeTokenAmount == 0) {\\n            return 0;\\n        }\\n\\n        /// -----------------------------------------------------------------------\\n        /// State updates\\n        /// -----------------------------------------------------------------------\\n\\n        xERC20Amount = FullMath.mulDiv(\\n            stakeTokenAmount,\\n            PRECISION,\\n            getPricePerFullShare()\\n        );\\n        _mint(msg.sender, xERC20Amount);\\n\\n        /// -----------------------------------------------------------------------\\n        /// Effects\\n        /// -----------------------------------------------------------------------\\n\\n        stakeToken().safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            stakeTokenAmount\\n        );\\n\\n        emit Staked(msg.sender, stakeTokenAmount, xERC20Amount);\\n    }\\n\\n    /// @notice Withdraw tokens by burning xERC20 tokens\\n    /// @param xERC20Amount The amount of xERC20 to burn\\n    /// @return stakeTokenAmount The amount of staked tokens withdrawn\\n    function withdraw(uint256 xERC20Amount)\\n        external\\n        virtual\\n        returns (uint256 stakeTokenAmount)\\n    {\\n        /// -----------------------------------------------------------------------\\n        /// Validation\\n        /// -----------------------------------------------------------------------\\n\\n        if (xERC20Amount == 0) {\\n            return 0;\\n        }\\n\\n        /// -----------------------------------------------------------------------\\n        /// State updates\\n        /// -----------------------------------------------------------------------\\n        stakeTokenAmount = FullMath.mulDiv(\\n            xERC20Amount,\\n            getPricePerFullShare(),\\n            PRECISION\\n        );\\n        _burn(msg.sender, xERC20Amount);\\n\\n        /// -----------------------------------------------------------------------\\n        /// Effects\\n        /// -----------------------------------------------------------------------\\n\\n        stakeToken().safeTransfer(msg.sender, stakeTokenAmount);\\n\\n        emit Withdrawn(msg.sender, stakeTokenAmount, xERC20Amount);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Getters\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Compute the amount of staked tokens that can be withdrawn by burning\\n    ///         1 xERC20 token. Increases linearly during a reward distribution period.\\n    /// @dev Initialized to be PRECISION (representing 1:1)\\n    /// @return The amount of staked tokens that can be withdrawn by burning\\n    ///         1 xERC20 token\\n    function getPricePerFullShare() public view returns (uint256) {\\n        uint256 totalShares = totalSupply;\\n        uint256 stakeTokenBalance = stakeToken().balanceOf(address(this));\\n        if (totalShares == 0 || stakeTokenBalance == 0) {\\n            return PRECISION;\\n        }\\n        uint256 lastRewardAmount_ = lastRewardAmount;\\n        uint256 currentUnlockEndTimestamp_ = currentUnlockEndTimestamp;\\n        if (\\n            lastRewardAmount_ == 0 ||\\n            block.timestamp >= currentUnlockEndTimestamp_\\n        ) {\\n            // no rewards or rewards fully unlocked\\n            // entire balance is withdrawable\\n            return FullMath.mulDiv(stakeTokenBalance, PRECISION, totalShares);\\n        } else {\\n            // rewards not fully unlocked\\n            // deduct locked rewards from balance\\n            uint256 lastRewardTimestamp_ = lastRewardTimestamp;\\n            // can't overflow since lockedRewardAmount < lastRewardAmount\\n            uint256 lockedRewardAmount = (lastRewardAmount_ *\\n                (currentUnlockEndTimestamp_ - block.timestamp)) /\\n                (currentUnlockEndTimestamp_ - lastRewardTimestamp_);\\n            return\\n                FullMath.mulDiv(\\n                    stakeTokenBalance - lockedRewardAmount,\\n                    PRECISION,\\n                    totalShares\\n                );\\n        }\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Owner actions\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Distributes rewards to xERC20 holders\\n    /// @dev When not in a distribution period, start a new one with rewardUnlockPeriod seconds.\\n    ///      When in a distribution period, add rewards to current period.\\n    function distributeReward(uint128 rewardAmount) external {\\n        /// -----------------------------------------------------------------------\\n        /// Validation\\n        /// -----------------------------------------------------------------------\\n\\n        if (totalSupply == 0) {\\n            revert Error_ZeroSupply();\\n        }\\n        if (!isRewardDistributor[msg.sender]) {\\n            revert Error_NotRewardDistributor();\\n        }\\n\\n        /// -----------------------------------------------------------------------\\n        /// Storage loads\\n        /// -----------------------------------------------------------------------\\n\\n        uint256 currentUnlockEndTimestamp_ = currentUnlockEndTimestamp;\\n\\n        /// -----------------------------------------------------------------------\\n        /// State updates\\n        /// -----------------------------------------------------------------------\\n\\n        if (block.timestamp >= currentUnlockEndTimestamp_) {\\n            // start new reward period\\n            currentUnlockEndTimestamp = uint64(block.timestamp + DURATION());\\n            lastRewardAmount = rewardAmount;\\n        } else {\\n            // add rewards to current reward period\\n            // can't overflow since lockedRewardAmount < lastRewardAmount\\n            uint256 lockedRewardAmount = (lastRewardAmount *\\n                (currentUnlockEndTimestamp_ - block.timestamp)) /\\n                (currentUnlockEndTimestamp_ - lastRewardTimestamp);\\n            // will revert if lastRewardAmount overflows\\n            lastRewardAmount = uint128(rewardAmount + lockedRewardAmount);\\n        }\\n        lastRewardTimestamp = uint64(block.timestamp);\\n\\n        /// -----------------------------------------------------------------------\\n        /// Effects\\n        /// -----------------------------------------------------------------------\\n\\n        stakeToken().safeTransferFrom(msg.sender, address(this), rewardAmount);\\n\\n        emit RewardAdded(rewardAmount);\\n    }\\n\\n    /// @notice Lets the owner add/remove accounts from the list of reward distributors.\\n    /// Reward distributors can call notifyRewardAmount()\\n    /// @param rewardDistributor The account to add/remove\\n    /// @param isRewardDistributor_ True to add the account, false to remove the account\\n    function setRewardDistributor(\\n        address rewardDistributor,\\n        bool isRewardDistributor_\\n    ) external onlyOwner {\\n        isRewardDistributor[rewardDistributor] = isRewardDistributor_;\\n    }\\n}\\n\"\r\n    },\r\n    \"SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(\\n                freeMemoryPointer,\\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\\n            ) // Begin with the function selector.\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(from, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"from\\\" argument.\\n            mstore(\\n                add(freeMemoryPointer, 36),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(\\n            didLastOptionalReturnCallSucceed(callStatus),\\n            \\\"TRANSFER_FROM_FAILED\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(\\n                freeMemoryPointer,\\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\\n            ) // Begin with the function selector.\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(\\n            didLastOptionalReturnCallSucceed(callStatus),\\n            \\\"TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(\\n                freeMemoryPointer,\\n                0x095ea7b300000000000000000000000000000000000000000000000000000000\\n            ) // Begin with the function selector.\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus)\\n        private\\n        pure\\n        returns (bool success)\\n    {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\nabstract contract Ownable {\\n    error Ownable_NotOwner();\\n    error Ownable_NewOwnerZeroAddress();\\n\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /// @dev Returns the address of the current owner.\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /// @dev Throws if called by any account other than the owner.\\n    modifier onlyOwner() {\\n        if (owner() != msg.sender) revert Ownable_NotOwner();\\n        _;\\n    }\\n\\n    /// @dev Transfers ownership of the contract to a new account (`newOwner`).\\n    /// Can only be called by the current owner.\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) revert Ownable_NewOwnerZeroAddress();\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /// @dev Transfers ownership of the contract to a new account (`newOwner`).\\n    /// Internal function without access restriction.\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (type(uint256).max - denominator + 1) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        unchecked {\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC20StakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\nimport {Clone} from \\\"Clone.sol\\\";\\n\\nimport {ERC20} from \\\"ERC20.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"SafeTransferLib.sol\\\";\\nimport {Ownable} from \\\"Ownable.sol\\\";\\nimport {FullMath} from \\\"FullMath.sol\\\";\\n\\n/// @title ERC20StakingPool\\n/// @author zefram.eth\\n/// @notice A modern, gas optimized staking pool contract for rewarding ERC20 stakers\\n/// with ERC20 tokens periodically and continuously\\ncontract ERC20StakingPool is Ownable, Clone {\\n    /// -----------------------------------------------------------------------\\n    /// Library usage\\n    /// -----------------------------------------------------------------------\\n\\n    using SafeTransferLib for ERC20;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Errors\\n    /// -----------------------------------------------------------------------\\n\\n    error Error_ZeroOwner();\\n    error Error_AlreadyInitialized();\\n    error Error_NotRewardDistributor();\\n    error Error_AmountTooLarge();\\n\\n    /// -----------------------------------------------------------------------\\n    /// Events\\n    /// -----------------------------------------------------------------------\\n\\n    event RewardAdded(uint256 reward);\\n    event Staked(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RewardPaid(address indexed user, uint256 reward);\\n\\n    /// -----------------------------------------------------------------------\\n    /// Constants\\n    /// -----------------------------------------------------------------------\\n\\n    uint256 internal constant PRECISION = 1e30;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Storage variables\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice The last Unix timestamp (in seconds) when rewardPerTokenStored was updated\\n    uint64 public lastUpdateTime;\\n    /// @notice The Unix timestamp (in seconds) at which the current reward period ends\\n    uint64 public periodFinish;\\n\\n    /// @notice The per-second rate at which rewardPerToken increases\\n    uint256 public rewardRate;\\n    /// @notice The last stored rewardPerToken value\\n    uint256 public rewardPerTokenStored;\\n    /// @notice The total tokens staked in the pool\\n    uint256 public totalSupply;\\n\\n    /// @notice Tracks if an address can call notifyReward()\\n    mapping(address => bool) public isRewardDistributor;\\n\\n    /// @notice The amount of tokens staked by an account\\n    mapping(address => uint256) public balanceOf;\\n    /// @notice The rewardPerToken value when an account last staked/withdrew/withdrew rewards\\n    mapping(address => uint256) public userRewardPerTokenPaid;\\n    /// @notice The earned() value when an account last staked/withdrew/withdrew rewards\\n    mapping(address => uint256) public rewards;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Immutable parameters\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice The token being rewarded to stakers\\n    function rewardToken() public pure returns (ERC20 rewardToken_) {\\n        return ERC20(_getArgAddress(0));\\n    }\\n\\n    /// @notice The token being staked in the pool\\n    function stakeToken() public pure returns (ERC20 stakeToken_) {\\n        return ERC20(_getArgAddress(0x14));\\n    }\\n\\n    /// @notice The length of each reward period, in seconds\\n    function DURATION() public pure returns (uint64 DURATION_) {\\n        return _getArgUint64(0x28);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Initialization\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Initializes the owner, called by StakingPoolFactory\\n    /// @param initialOwner The initial owner of the contract\\n    function initialize(address initialOwner) external {\\n        if (owner() != address(0)) {\\n            revert Error_AlreadyInitialized();\\n        }\\n        if (initialOwner == address(0)) {\\n            revert Error_ZeroOwner();\\n        }\\n\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// User actions\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Stakes tokens in the pool to earn rewards\\n    /// @param amount The amount of tokens to stake\\n    function stake(uint256 amount) external {\\n        /// -----------------------------------------------------------------------\\n        /// Validation\\n        /// -----------------------------------------------------------------------\\n\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        /// -----------------------------------------------------------------------\\n        /// Storage loads\\n        /// -----------------------------------------------------------------------\\n\\n        uint256 accountBalance = balanceOf[msg.sender];\\n        uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable();\\n        uint256 totalSupply_ = totalSupply;\\n        uint256 rewardPerToken_ = _rewardPerToken(\\n            totalSupply_,\\n            lastTimeRewardApplicable_,\\n            rewardRate\\n        );\\n\\n        /// -----------------------------------------------------------------------\\n        /// State updates\\n        /// -----------------------------------------------------------------------\\n\\n        // accrue rewards\\n        rewardPerTokenStored = rewardPerToken_;\\n        lastUpdateTime = lastTimeRewardApplicable_;\\n        rewards[msg.sender] = _earned(\\n            msg.sender,\\n            accountBalance,\\n            rewardPerToken_,\\n            rewards[msg.sender]\\n        );\\n        userRewardPerTokenPaid[msg.sender] = rewardPerToken_;\\n\\n        // stake\\n        totalSupply = totalSupply_ + amount;\\n        balanceOf[msg.sender] = accountBalance + amount;\\n\\n        /// -----------------------------------------------------------------------\\n        /// Effects\\n        /// -----------------------------------------------------------------------\\n\\n        stakeToken().safeTransferFrom(msg.sender, address(this), amount);\\n\\n        emit Staked(msg.sender, amount);\\n    }\\n\\n    /// @notice Withdraws staked tokens from the pool\\n    /// @param amount The amount of tokens to withdraw\\n    function withdraw(uint256 amount) external {\\n        /// -----------------------------------------------------------------------\\n        /// Validation\\n        /// -----------------------------------------------------------------------\\n\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        /// -----------------------------------------------------------------------\\n        /// Storage loads\\n        /// -----------------------------------------------------------------------\\n\\n        uint256 accountBalance = balanceOf[msg.sender];\\n        uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable();\\n        uint256 totalSupply_ = totalSupply;\\n        uint256 rewardPerToken_ = _rewardPerToken(\\n            totalSupply_,\\n            lastTimeRewardApplicable_,\\n            rewardRate\\n        );\\n\\n        /// -----------------------------------------------------------------------\\n        /// State updates\\n        /// -----------------------------------------------------------------------\\n\\n        // accrue rewards\\n        rewardPerTokenStored = rewardPerToken_;\\n        lastUpdateTime = lastTimeRewardApplicable_;\\n        rewards[msg.sender] = _earned(\\n            msg.sender,\\n            accountBalance,\\n            rewardPerToken_,\\n            rewards[msg.sender]\\n        );\\n        userRewardPerTokenPaid[msg.sender] = rewardPerToken_;\\n\\n        // withdraw stake\\n        balanceOf[msg.sender] = accountBalance - amount;\\n        // total supply has 1:1 relationship with staked amounts\\n        // so can't ever underflow\\n        unchecked {\\n            totalSupply = totalSupply_ - amount;\\n        }\\n\\n        /// -----------------------------------------------------------------------\\n        /// Effects\\n        /// -----------------------------------------------------------------------\\n\\n        stakeToken().safeTransfer(msg.sender, amount);\\n\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    /// @notice Withdraws all staked tokens and earned rewards\\n    function exit() external {\\n        /// -----------------------------------------------------------------------\\n        /// Validation\\n        /// -----------------------------------------------------------------------\\n\\n        uint256 accountBalance = balanceOf[msg.sender];\\n\\n        /// -----------------------------------------------------------------------\\n        /// Storage loads\\n        /// -----------------------------------------------------------------------\\n\\n        uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable();\\n        uint256 totalSupply_ = totalSupply;\\n        uint256 rewardPerToken_ = _rewardPerToken(\\n            totalSupply_,\\n            lastTimeRewardApplicable_,\\n            rewardRate\\n        );\\n\\n        /// -----------------------------------------------------------------------\\n        /// State updates\\n        /// -----------------------------------------------------------------------\\n\\n        // give rewards\\n        uint256 reward = _earned(\\n            msg.sender,\\n            accountBalance,\\n            rewardPerToken_,\\n            rewards[msg.sender]\\n        );\\n        if (reward > 0) {\\n            rewards[msg.sender] = 0;\\n        }\\n\\n        // accrue rewards\\n        rewardPerTokenStored = rewardPerToken_;\\n        lastUpdateTime = lastTimeRewardApplicable_;\\n        userRewardPerTokenPaid[msg.sender] = rewardPerToken_;\\n\\n        // withdraw stake\\n        balanceOf[msg.sender] = 0;\\n        // total supply has 1:1 relationship with staked amounts\\n        // so can't ever underflow\\n        unchecked {\\n            totalSupply = totalSupply_ - accountBalance;\\n        }\\n\\n        /// -----------------------------------------------------------------------\\n        /// Effects\\n        /// -----------------------------------------------------------------------\\n\\n        // transfer stake\\n        stakeToken().safeTransfer(msg.sender, accountBalance);\\n        emit Withdrawn(msg.sender, accountBalance);\\n\\n        // transfer rewards\\n        if (reward > 0) {\\n            rewardToken().safeTransfer(msg.sender, reward);\\n            emit RewardPaid(msg.sender, reward);\\n        }\\n    }\\n\\n    /// @notice Withdraws all earned rewards\\n    function getReward() external {\\n        /// -----------------------------------------------------------------------\\n        /// Storage loads\\n        /// -----------------------------------------------------------------------\\n\\n        uint256 accountBalance = balanceOf[msg.sender];\\n        uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable();\\n        uint256 totalSupply_ = totalSupply;\\n        uint256 rewardPerToken_ = _rewardPerToken(\\n            totalSupply_,\\n            lastTimeRewardApplicable_,\\n            rewardRate\\n        );\\n\\n        /// -----------------------------------------------------------------------\\n        /// State updates\\n        /// -----------------------------------------------------------------------\\n\\n        uint256 reward = _earned(\\n            msg.sender,\\n            accountBalance,\\n            rewardPerToken_,\\n            rewards[msg.sender]\\n        );\\n\\n        // accrue rewards\\n        rewardPerTokenStored = rewardPerToken_;\\n        lastUpdateTime = lastTimeRewardApplicable_;\\n        userRewardPerTokenPaid[msg.sender] = rewardPerToken_;\\n\\n        // withdraw rewards\\n        if (reward > 0) {\\n            rewards[msg.sender] = 0;\\n\\n            /// -----------------------------------------------------------------------\\n            /// Effects\\n            /// -----------------------------------------------------------------------\\n\\n            rewardToken().safeTransfer(msg.sender, reward);\\n            emit RewardPaid(msg.sender, reward);\\n        }\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Getters\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice The latest time at which stakers are earning rewards.\\n    function lastTimeRewardApplicable() public view returns (uint64) {\\n        return\\n            block.timestamp < periodFinish\\n                ? uint64(block.timestamp)\\n                : periodFinish;\\n    }\\n\\n    /// @notice The amount of reward tokens each staked token has earned so far\\n    function rewardPerToken() external view returns (uint256) {\\n        return\\n            _rewardPerToken(\\n                totalSupply,\\n                lastTimeRewardApplicable(),\\n                rewardRate\\n            );\\n    }\\n\\n    /// @notice The amount of reward tokens an account has accrued so far. Does not\\n    /// include already withdrawn rewards.\\n    function earned(address account) external view returns (uint256) {\\n        return\\n            _earned(\\n                account,\\n                balanceOf[account],\\n                _rewardPerToken(\\n                    totalSupply,\\n                    lastTimeRewardApplicable(),\\n                    rewardRate\\n                ),\\n                rewards[account]\\n            );\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Owner actions\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Lets a reward distributor start a new reward period. The reward tokens must have already\\n    /// been transferred to this contract before calling this function. If it is called\\n    /// when a reward period is still active, a new reward period will begin from the time\\n    /// of calling this function, using the leftover rewards from the old reward period plus\\n    /// the newly sent rewards as the reward.\\n    /// @dev If the reward amount will cause an overflow when computing rewardPerToken, then\\n    /// this function will revert.\\n    /// @param reward The amount of reward tokens to use in the new reward period.\\n    function notifyRewardAmount(uint256 reward) external {\\n        /// -----------------------------------------------------------------------\\n        /// Validation\\n        /// -----------------------------------------------------------------------\\n\\n        if (reward == 0) {\\n            return;\\n        }\\n        if (!isRewardDistributor[msg.sender]) {\\n            revert Error_NotRewardDistributor();\\n        }\\n\\n        /// -----------------------------------------------------------------------\\n        /// Storage loads\\n        /// -----------------------------------------------------------------------\\n\\n        uint256 rewardRate_ = rewardRate;\\n        uint64 periodFinish_ = periodFinish;\\n        uint64 lastTimeRewardApplicable_ = block.timestamp < periodFinish_\\n            ? uint64(block.timestamp)\\n            : periodFinish_;\\n        uint64 DURATION_ = DURATION();\\n        uint256 totalSupply_ = totalSupply;\\n\\n        /// -----------------------------------------------------------------------\\n        /// State updates\\n        /// -----------------------------------------------------------------------\\n\\n        // accrue rewards\\n        rewardPerTokenStored = _rewardPerToken(\\n            totalSupply_,\\n            lastTimeRewardApplicable_,\\n            rewardRate_\\n        );\\n        lastUpdateTime = lastTimeRewardApplicable_;\\n\\n        // record new reward\\n        uint256 newRewardRate;\\n        if (block.timestamp >= periodFinish_) {\\n            newRewardRate = reward / DURATION_;\\n        } else {\\n            uint256 remaining = periodFinish_ - block.timestamp;\\n            uint256 leftover = remaining * rewardRate_;\\n            newRewardRate = (reward + leftover) / DURATION_;\\n        }\\n        // prevent overflow when computing rewardPerToken\\n        if (newRewardRate >= ((type(uint256).max / PRECISION) / DURATION_)) {\\n            revert Error_AmountTooLarge();\\n        }\\n        rewardRate = newRewardRate;\\n        lastUpdateTime = uint64(block.timestamp);\\n        periodFinish = uint64(block.timestamp + DURATION_);\\n\\n        emit RewardAdded(reward);\\n    }\\n\\n    /// @notice Lets the owner add/remove accounts from the list of reward distributors.\\n    /// Reward distributors can call notifyRewardAmount()\\n    /// @param rewardDistributor The account to add/remove\\n    /// @param isRewardDistributor_ True to add the account, false to remove the account\\n    function setRewardDistributor(\\n        address rewardDistributor,\\n        bool isRewardDistributor_\\n    ) external onlyOwner {\\n        isRewardDistributor[rewardDistributor] = isRewardDistributor_;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Internal functions\\n    /// -----------------------------------------------------------------------\\n\\n    function _earned(\\n        address account,\\n        uint256 accountBalance,\\n        uint256 rewardPerToken_,\\n        uint256 accountRewards\\n    ) internal view returns (uint256) {\\n        return\\n            FullMath.mulDiv(\\n                accountBalance,\\n                rewardPerToken_ - userRewardPerTokenPaid[account],\\n                PRECISION\\n            ) + accountRewards;\\n    }\\n\\n    function _rewardPerToken(\\n        uint256 totalSupply_,\\n        uint256 lastTimeRewardApplicable_,\\n        uint256 rewardRate_\\n    ) internal view returns (uint256) {\\n        if (totalSupply_ == 0) {\\n            return rewardPerTokenStored;\\n        }\\n        return\\n            rewardPerTokenStored +\\n            FullMath.mulDiv(\\n                (lastTimeRewardApplicable_ - lastUpdateTime) * PRECISION,\\n                rewardRate_,\\n                totalSupply_\\n            );\\n    }\\n\\n    function _getImmutableVariablesOffset()\\n        internal\\n        pure\\n        returns (uint256 offset)\\n    {\\n        assembly {\\n            offset := sub(\\n                calldatasize(),\\n                add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\\n            )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC721StakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\nimport {Clone} from \\\"Clone.sol\\\";\\n\\nimport {ERC20} from \\\"ERC20.sol\\\";\\nimport {ERC721, ERC721TokenReceiver} from \\\"ERC721.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"SafeTransferLib.sol\\\";\\nimport {Ownable} from \\\"Ownable.sol\\\";\\nimport {FullMath} from \\\"FullMath.sol\\\";\\n\\n/// @title ERC721StakingPool\\n/// @author zefram.eth\\n/// @notice A modern, gas optimized staking pool contract for rewarding ERC721 stakers\\n/// with ERC20 tokens periodically and continuously\\ncontract ERC721StakingPool is Ownable, Clone, ERC721TokenReceiver {\\n    /// -----------------------------------------------------------------------\\n    /// Library usage\\n    /// -----------------------------------------------------------------------\\n\\n    using SafeTransferLib for ERC20;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Errors\\n    /// -----------------------------------------------------------------------\\n\\n    error Error_ZeroOwner();\\n    error Error_AlreadyInitialized();\\n    error Error_NotRewardDistributor();\\n    error Error_AmountTooLarge();\\n    error Error_NotTokenOwner();\\n    error Error_NotStakeToken();\\n\\n    /// -----------------------------------------------------------------------\\n    /// Events\\n    /// -----------------------------------------------------------------------\\n\\n    event RewardAdded(uint256 reward);\\n    event Staked(address indexed user, uint256[] idList);\\n    event Withdrawn(address indexed user, uint256[] idList);\\n    event RewardPaid(address indexed user, uint256 reward);\\n\\n    /// -----------------------------------------------------------------------\\n    /// Constants\\n    /// -----------------------------------------------------------------------\\n\\n    uint256 internal constant PRECISION = 1e30;\\n    address internal constant BURN_ADDRESS = address(0xdead);\\n\\n    /// -----------------------------------------------------------------------\\n    /// Storage variables\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice The last Unix timestamp (in seconds) when rewardPerTokenStored was updated\\n    uint64 public lastUpdateTime;\\n    /// @notice The Unix timestamp (in seconds) at which the current reward period ends\\n    uint64 public periodFinish;\\n\\n    /// @notice The per-second rate at which rewardPerToken increases\\n    uint256 public rewardRate;\\n    /// @notice The last stored rewardPerToken value\\n    uint256 public rewardPerTokenStored;\\n    /// @notice The total tokens staked in the pool\\n    uint256 public totalSupply;\\n\\n    /// @notice Tracks if an address can call notifyReward()\\n    mapping(address => bool) public isRewardDistributor;\\n    /// @notice The owner of a staked ERC721 token\\n    mapping(uint256 => address) public ownerOf;\\n\\n    /// @notice The amount of tokens staked by an account\\n    mapping(address => uint256) public balanceOf;\\n    /// @notice The rewardPerToken value when an account last staked/withdrew/withdrew rewards\\n    mapping(address => uint256) public userRewardPerTokenPaid;\\n    /// @notice The earned() value when an account last staked/withdrew/withdrew rewards\\n    mapping(address => uint256) public rewards;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Immutable parameters\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice The token being rewarded to stakers\\n    function rewardToken() public pure returns (ERC20 rewardToken_) {\\n        return ERC20(_getArgAddress(0));\\n    }\\n\\n    /// @notice The token being staked in the pool\\n    function stakeToken() public pure returns (ERC721 stakeToken_) {\\n        return ERC721(_getArgAddress(0x14));\\n    }\\n\\n    /// @notice The length of each reward period, in seconds\\n    function DURATION() public pure returns (uint64 DURATION_) {\\n        return _getArgUint64(0x28);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Initialization\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Initializes the owner, called by StakingPoolFactory\\n    /// @param initialOwner The initial owner of the contract\\n    function initialize(address initialOwner) external {\\n        if (owner() != address(0)) {\\n            revert Error_AlreadyInitialized();\\n        }\\n        if (initialOwner == address(0)) {\\n            revert Error_ZeroOwner();\\n        }\\n\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// User actions\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Stakes a list of ERC721 tokens in the pool to earn rewards\\n    /// @param idList The list of ERC721 token IDs to stake\\n    function stake(uint256[] calldata idList) external {\\n        /// -----------------------------------------------------------------------\\n        /// Validation\\n        /// -----------------------------------------------------------------------\\n\\n        if (idList.length == 0) {\\n            return;\\n        }\\n\\n        /// -----------------------------------------------------------------------\\n        /// Storage loads\\n        /// -----------------------------------------------------------------------\\n\\n        uint256 accountBalance = balanceOf[msg.sender];\\n        uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable();\\n        uint256 totalSupply_ = totalSupply;\\n        uint256 rewardPerToken_ = _rewardPerToken(\\n            totalSupply_,\\n            lastTimeRewardApplicable_,\\n            rewardRate\\n        );\\n\\n        /// -----------------------------------------------------------------------\\n        /// State updates\\n        /// -----------------------------------------------------------------------\\n\\n        // accrue rewards\\n        rewardPerTokenStored = rewardPerToken_;\\n        lastUpdateTime = lastTimeRewardApplicable_;\\n        rewards[msg.sender] = _earned(\\n            msg.sender,\\n            accountBalance,\\n            rewardPerToken_,\\n            rewards[msg.sender]\\n        );\\n        userRewardPerTokenPaid[msg.sender] = rewardPerToken_;\\n\\n        // stake\\n        totalSupply = totalSupply_ + idList.length;\\n        balanceOf[msg.sender] = accountBalance + idList.length;\\n        unchecked {\\n            for (uint256 i = 0; i < idList.length; i++) {\\n                ownerOf[idList[i]] = msg.sender;\\n            }\\n        }\\n\\n        /// -----------------------------------------------------------------------\\n        /// Effects\\n        /// -----------------------------------------------------------------------\\n\\n        unchecked {\\n            for (uint256 i = 0; i < idList.length; i++) {\\n                stakeToken().safeTransferFrom(\\n                    msg.sender,\\n                    address(this),\\n                    idList[i]\\n                );\\n            }\\n        }\\n\\n        emit Staked(msg.sender, idList);\\n    }\\n\\n    /// @notice Withdraws staked tokens from the pool\\n    /// @param idList The list of ERC721 token IDs to stake\\n    function withdraw(uint256[] calldata idList) external {\\n        /// -----------------------------------------------------------------------\\n        /// Validation\\n        /// -----------------------------------------------------------------------\\n\\n        if (idList.length == 0) {\\n            return;\\n        }\\n\\n        /// -----------------------------------------------------------------------\\n        /// Storage loads\\n        /// -----------------------------------------------------------------------\\n\\n        uint256 accountBalance = balanceOf[msg.sender];\\n        uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable();\\n        uint256 totalSupply_ = totalSupply;\\n        uint256 rewardPerToken_ = _rewardPerToken(\\n            totalSupply_,\\n            lastTimeRewardApplicable_,\\n            rewardRate\\n        );\\n\\n        /// -----------------------------------------------------------------------\\n        /// State updates\\n        /// -----------------------------------------------------------------------\\n\\n        // accrue rewards\\n        rewardPerTokenStored = rewardPerToken_;\\n        lastUpdateTime = lastTimeRewardApplicable_;\\n        rewards[msg.sender] = _earned(\\n            msg.sender,\\n            accountBalance,\\n            rewardPerToken_,\\n            rewards[msg.sender]\\n        );\\n        userRewardPerTokenPaid[msg.sender] = rewardPerToken_;\\n\\n        // withdraw stake\\n        balanceOf[msg.sender] = accountBalance - idList.length;\\n        // total supply has 1:1 relationship with staked amounts\\n        // so can't ever underflow\\n        unchecked {\\n            totalSupply = totalSupply_ - idList.length;\\n            for (uint256 i = 0; i < idList.length; i++) {\\n                // verify ownership\\n                address tokenOwner = ownerOf[idList[i]];\\n                if (tokenOwner != msg.sender || tokenOwner == BURN_ADDRESS) {\\n                    revert Error_NotTokenOwner();\\n                }\\n\\n                // keep the storage slot dirty to save gas\\n                // if someone else stakes the same token again\\n                ownerOf[idList[i]] = BURN_ADDRESS;\\n            }\\n        }\\n\\n        /// -----------------------------------------------------------------------\\n        /// Effects\\n        /// -----------------------------------------------------------------------\\n\\n        unchecked {\\n            for (uint256 i = 0; i < idList.length; i++) {\\n                stakeToken().safeTransferFrom(\\n                    address(this),\\n                    msg.sender,\\n                    idList[i]\\n                );\\n            }\\n        }\\n\\n        emit Withdrawn(msg.sender, idList);\\n    }\\n\\n    /// @notice Withdraws specified staked tokens and earned rewards\\n    function exit(uint256[] calldata idList) external {\\n        /// -----------------------------------------------------------------------\\n        /// Validation\\n        /// -----------------------------------------------------------------------\\n\\n        if (idList.length == 0) {\\n            return;\\n        }\\n\\n        /// -----------------------------------------------------------------------\\n        /// Storage loads\\n        /// -----------------------------------------------------------------------\\n\\n        uint256 accountBalance = balanceOf[msg.sender];\\n        uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable();\\n        uint256 totalSupply_ = totalSupply;\\n        uint256 rewardPerToken_ = _rewardPerToken(\\n            totalSupply_,\\n            lastTimeRewardApplicable_,\\n            rewardRate\\n        );\\n\\n        /// -----------------------------------------------------------------------\\n        /// State updates\\n        /// -----------------------------------------------------------------------\\n\\n        // give rewards\\n        uint256 reward = _earned(\\n            msg.sender,\\n            accountBalance,\\n            rewardPerToken_,\\n            rewards[msg.sender]\\n        );\\n        if (reward > 0) {\\n            rewards[msg.sender] = 0;\\n        }\\n\\n        // accrue rewards\\n        rewardPerTokenStored = rewardPerToken_;\\n        lastUpdateTime = lastTimeRewardApplicable_;\\n        userRewardPerTokenPaid[msg.sender] = rewardPerToken_;\\n\\n        // withdraw stake\\n        balanceOf[msg.sender] = accountBalance - idList.length;\\n        // total supply has 1:1 relationship with staked amounts\\n        // so can't ever underflow\\n        unchecked {\\n            totalSupply = totalSupply_ - idList.length;\\n            for (uint256 i = 0; i < idList.length; i++) {\\n                // verify ownership\\n                address tokenOwner = ownerOf[idList[i]];\\n                if (tokenOwner != msg.sender || tokenOwner == BURN_ADDRESS) {\\n                    revert Error_NotTokenOwner();\\n                }\\n\\n                // keep the storage slot dirty to save gas\\n                // if someone else stakes the same token again\\n                ownerOf[idList[i]] = BURN_ADDRESS;\\n            }\\n        }\\n\\n        /// -----------------------------------------------------------------------\\n        /// Effects\\n        /// -----------------------------------------------------------------------\\n\\n        // transfer stake\\n        unchecked {\\n            for (uint256 i = 0; i < idList.length; i++) {\\n                stakeToken().safeTransferFrom(\\n                    address(this),\\n                    msg.sender,\\n                    idList[i]\\n                );\\n            }\\n        }\\n        emit Withdrawn(msg.sender, idList);\\n\\n        // transfer rewards\\n        if (reward > 0) {\\n            rewardToken().safeTransfer(msg.sender, reward);\\n            emit RewardPaid(msg.sender, reward);\\n        }\\n    }\\n\\n    /// @notice Withdraws all earned rewards\\n    function getReward() external {\\n        /// -----------------------------------------------------------------------\\n        /// Storage loads\\n        /// -----------------------------------------------------------------------\\n\\n        uint256 accountBalance = balanceOf[msg.sender];\\n        uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable();\\n        uint256 totalSupply_ = totalSupply;\\n        uint256 rewardPerToken_ = _rewardPerToken(\\n            totalSupply_,\\n            lastTimeRewardApplicable_,\\n            rewardRate\\n        );\\n\\n        /// -----------------------------------------------------------------------\\n        /// State updates\\n        /// -----------------------------------------------------------------------\\n\\n        uint256 reward = _earned(\\n            msg.sender,\\n            accountBalance,\\n            rewardPerToken_,\\n            rewards[msg.sender]\\n        );\\n\\n        // accrue rewards\\n        rewardPerTokenStored = rewardPerToken_;\\n        lastUpdateTime = lastTimeRewardApplicable_;\\n        userRewardPerTokenPaid[msg.sender] = rewardPerToken_;\\n\\n        // withdraw rewards\\n        if (reward > 0) {\\n            rewards[msg.sender] = 0;\\n\\n            /// -----------------------------------------------------------------------\\n            /// Effects\\n            /// -----------------------------------------------------------------------\\n\\n            rewardToken().safeTransfer(msg.sender, reward);\\n            emit RewardPaid(msg.sender, reward);\\n        }\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Getters\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice The latest time at which stakers are earning rewards.\\n    function lastTimeRewardApplicable() public view returns (uint64) {\\n        return\\n            block.timestamp < periodFinish\\n                ? uint64(block.timestamp)\\n                : periodFinish;\\n    }\\n\\n    /// @notice The amount of reward tokens each staked token has earned so far\\n    function rewardPerToken() external view returns (uint256) {\\n        return\\n            _rewardPerToken(\\n                totalSupply,\\n                lastTimeRewardApplicable(),\\n                rewardRate\\n            );\\n    }\\n\\n    /// @notice The amount of reward tokens an account has accrued so far. Does not\\n    /// include already withdrawn rewards.\\n    function earned(address account) external view returns (uint256) {\\n        return\\n            _earned(\\n                account,\\n                balanceOf[account],\\n                _rewardPerToken(\\n                    totalSupply,\\n                    lastTimeRewardApplicable(),\\n                    rewardRate\\n                ),\\n                rewards[account]\\n            );\\n    }\\n\\n    /// @dev ERC721 compliance\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external view override returns (bytes4) {\\n        if (msg.sender != address(stakeToken())) {\\n            revert Error_NotStakeToken();\\n        }\\n        return this.onERC721Received.selector;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Owner actions\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Lets a reward distributor start a new reward period. The reward tokens must have already\\n    /// been transferred to this contract before calling this function. If it is called\\n    /// when a reward period is still active, a new reward period will begin from the time\\n    /// of calling this function, using the leftover rewards from the old reward period plus\\n    /// the newly sent rewards as the reward.\\n    /// @dev If the reward amount will cause an overflow when computing rewardPerToken, then\\n    /// this function will revert.\\n    /// @param reward The amount of reward tokens to use in the new reward period.\\n    function notifyRewardAmount(uint256 reward) external {\\n        /// -----------------------------------------------------------------------\\n        /// Validation\\n        /// -----------------------------------------------------------------------\\n\\n        if (reward == 0) {\\n            return;\\n        }\\n        if (!isRewardDistributor[msg.sender]) {\\n            revert Error_NotRewardDistributor();\\n        }\\n\\n        /// -----------------------------------------------------------------------\\n        /// Storage loads\\n        /// -----------------------------------------------------------------------\\n\\n        uint256 rewardRate_ = rewardRate;\\n        uint64 periodFinish_ = periodFinish;\\n        uint64 lastTimeRewardApplicable_ = block.timestamp < periodFinish_\\n            ? uint64(block.timestamp)\\n            : periodFinish_;\\n        uint64 DURATION_ = DURATION();\\n        uint256 totalSupply_ = totalSupply;\\n\\n        /// -----------------------------------------------------------------------\\n        /// State updates\\n        /// -----------------------------------------------------------------------\\n\\n        // accrue rewards\\n        rewardPerTokenStored = _rewardPerToken(\\n            totalSupply_,\\n            lastTimeRewardApplicable_,\\n            rewardRate_\\n        );\\n        lastUpdateTime = lastTimeRewardApplicable_;\\n\\n        // record new reward\\n        uint256 newRewardRate;\\n        if (block.timestamp >= periodFinish_) {\\n            newRewardRate = reward / DURATION_;\\n        } else {\\n            uint256 remaining = periodFinish_ - block.timestamp;\\n            uint256 leftover = remaining * rewardRate_;\\n            newRewardRate = (reward + leftover) / DURATION_;\\n        }\\n        // prevent overflow when computing rewardPerToken\\n        if (newRewardRate >= ((type(uint256).max / PRECISION) / DURATION_)) {\\n            revert Error_AmountTooLarge();\\n        }\\n        rewardRate = newRewardRate;\\n        lastUpdateTime = uint64(block.timestamp);\\n        periodFinish = uint64(block.timestamp + DURATION_);\\n\\n        emit RewardAdded(reward);\\n    }\\n\\n    /// @notice Lets the owner add/remove accounts from the list of reward distributors.\\n    /// Reward distributors can call notifyRewardAmount()\\n    /// @param rewardDistributor The account to add/remove\\n    /// @param isRewardDistributor_ True to add the account, false to remove the account\\n    function setRewardDistributor(\\n        address rewardDistributor,\\n        bool isRewardDistributor_\\n    ) external onlyOwner {\\n        isRewardDistributor[rewardDistributor] = isRewardDistributor_;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Internal functions\\n    /// -----------------------------------------------------------------------\\n\\n    function _earned(\\n        address account,\\n        uint256 accountBalance,\\n        uint256 rewardPerToken_,\\n        uint256 accountRewards\\n    ) internal view returns (uint256) {\\n        return\\n            FullMath.mulDiv(\\n                accountBalance,\\n                rewardPerToken_ - userRewardPerTokenPaid[account],\\n                PRECISION\\n            ) + accountRewards;\\n    }\\n\\n    function _rewardPerToken(\\n        uint256 totalSupply_,\\n        uint256 lastTimeRewardApplicable_,\\n        uint256 rewardRate_\\n    ) internal view returns (uint256) {\\n        if (totalSupply_ == 0) {\\n            return rewardPerTokenStored;\\n        }\\n        return\\n            rewardPerTokenStored +\\n            FullMath.mulDiv(\\n                (lastTimeRewardApplicable_ - lastUpdateTime) * PRECISION,\\n                rewardRate_,\\n                totalSupply_\\n            );\\n    }\\n\\n    function _getImmutableVariablesOffset()\\n        internal\\n        pure\\n        returns (uint256 offset)\\n    {\\n        assembly {\\n            offset := sub(\\n                calldatasize(),\\n                add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\\n            )\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract xERC20\",\"name\":\"xERC20Implementation_\",\"type\":\"address\"},{\"internalType\":\"contract ERC20StakingPool\",\"name\":\"erc20StakingPoolImplementation_\",\"type\":\"address\"},{\"internalType\":\"contract ERC721StakingPool\",\"name\":\"erc721StakingPoolImplementation_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CreateFail\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ERC20StakingPool\",\"name\":\"stakingPool\",\"type\":\"address\"}],\"name\":\"CreateERC20StakingPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ERC721StakingPool\",\"name\":\"stakingPool\",\"type\":\"address\"}],\"name\":\"CreateERC721StakingPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract xERC20\",\"name\":\"stakingPool\",\"type\":\"address\"}],\"name\":\"CreateXERC20\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"DURATION\",\"type\":\"uint64\"}],\"name\":\"createERC20StakingPool\",\"outputs\":[{\"internalType\":\"contract ERC20StakingPool\",\"name\":\"stakingPool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"contract ERC721\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"DURATION\",\"type\":\"uint64\"}],\"name\":\"createERC721StakingPool\",\"outputs\":[{\"internalType\":\"contract ERC721StakingPool\",\"name\":\"stakingPool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"symbol\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"contract ERC20\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"DURATION\",\"type\":\"uint64\"}],\"name\":\"createXERC20\",\"outputs\":[{\"internalType\":\"contract xERC20\",\"name\":\"stakingPool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20StakingPoolImplementation\",\"outputs\":[{\"internalType\":\"contract ERC20StakingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc721StakingPoolImplementation\",\"outputs\":[{\"internalType\":\"contract ERC721StakingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xERC20Implementation\",\"outputs\":[{\"internalType\":\"contract xERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StakingPoolFactory", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000097a9ebd15ec0c8528616e38ea14ff14ae57ae6510000000000000000000000007eb0ec6237a941c097506f70be340d268b7826f400000000000000000000000082239f14d4afe635c911cd725a3bbc3702e658f4", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}