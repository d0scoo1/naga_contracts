{"status": "1", "message": "OK", "result": [{"SourceCode": "// Winding Tree\r\n// Web:     https://windingtree.com/\r\n// Discord: https://discord.gg/5Q3qde6Gr9\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/upgrades/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/ERC165/ERC165.sol\r\n\r\n// SPDX-License-Identifier: MIT;\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @dev Custom implementation of the {IERC165} interface.\r\n * This is contract implemented by OpenZeppelin but extended with\r\n * _removeInterface function\r\n */\r\ncontract ERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev Interface of the ERC165 standard, as defined in the\r\n     * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n     * @param interfaceId Interface Id\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     * @param interfaceId Interface Id\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Removes support of the interface\r\n     * @param interfaceId Interface Id\r\n     */\r\n    function _removeInterface(bytes4 interfaceId) internal {\r\n        require(_supportedInterfaces[interfaceId], \"ERC165: unknown interface id\");\r\n        _supportedInterfaces[interfaceId] = false;\r\n    }\r\n}\r\n\r\n// File: contracts/OwnablePatch.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only;\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @title Ownable smart contract replacement.\r\n * Required for the saving of the order and composition of variables\r\n * in the OrgId storage due to upgrade to version 1.1.0\r\n */\r\ncontract OwnablePatch {\r\n    address private _owner;\r\n}\r\n\r\n// File: contracts/OrgIdInterface.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only;\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @title ORGiD Registry Smart Contract Interface\r\n */\r\ncontract OrgIdInterface {\r\n\r\n    /**\r\n     * @dev Create organization\r\n     * @param salt Unique hash required for identifier creation\r\n     * @param orgJsonHash ORG.JSON's keccak256 hash\r\n     * @param orgJsonUri ORG.JSON URI (stored off-chain)\r\n     * @param orgJsonUriBackup1 ORG.JSON URI backup (stored off-chain)\r\n     * @param orgJsonUriBackup2 ORG.JSON URI backup (stored off-chain)\r\n     * @return {\r\n         \"id\": \"ORGiD byte32 hash\"\r\n     }\r\n     */\r\n    function createOrganization(\r\n        bytes32 salt,\r\n        bytes32 orgJsonHash,\r\n        string calldata orgJsonUri,\r\n        string calldata orgJsonUriBackup1,\r\n        string calldata orgJsonUriBackup2\r\n    ) external returns (bytes32 id);\r\n\r\n    /**\r\n     * @dev Create organizational unit\r\n     * @param salt Unique hash required for identifier creation\r\n     * @param parentOrgId Parent ORGiD hash\r\n     * @param director Unit director address\r\n     * @param orgJsonHash ORG.JSON keccak256 hash\r\n     * @param orgJsonUri Unit ORG.JSON URI\r\n     * @param orgJsonUriBackup1 Unit ORG.JSON URI backup\r\n     * @param orgJsonUriBackup2 Unit ORG.JSON URI backup\r\n     */\r\n    function createUnit(\r\n        bytes32 salt,\r\n        bytes32 parentOrgId,\r\n        address director,\r\n        bytes32 orgJsonHash,\r\n        string calldata orgJsonUri,\r\n        string calldata orgJsonUriBackup1,\r\n        string calldata orgJsonUriBackup2\r\n    )\r\n        external\r\n        returns (bytes32 newUnitOrgId);\r\n\r\n    /**\r\n     * @dev Toggle ORGiD's active/inactive state\r\n     * @param orgId ORGiD hash\r\n     */\r\n    function toggleActiveState(bytes32 orgId) external;\r\n\r\n    /**\r\n     * @dev Accept director role\r\n     * @param orgId Unit's ORGiD hash\r\n     */\r\n    function acceptDirectorship(bytes32 orgId) external;\r\n\r\n    /**\r\n     * @dev Transfer director role\r\n     * @param orgId Unit's ORGiD hash\r\n     * @param newDirector New director's address\r\n     */\r\n    function transferDirectorship(\r\n        bytes32 orgId,\r\n        address newDirector\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Unit directorship renounce\r\n     * @param orgId Unit's ORGiD hash\r\n     */\r\n    function renounceDirectorship(bytes32 orgId)\r\n        external;\r\n\r\n    /**\r\n     * @dev Ownership transfer\r\n     * @param orgId ORGiD hash\r\n     * @param newOwner New owner's address\r\n     */\r\n    function transferOrganizationOwnership(\r\n        bytes32 orgId,\r\n        address newOwner\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Shorthand method to change ORG.JSON URI and hash at once\r\n     * @param orgId ORGiD hash\r\n     * @param orgJsonHash New ORG.JSON's keccak256 hash\r\n     * @param orgJsonUri New ORG.JSON URI\r\n     * @param orgJsonUriBackup1 New ORG.JSON URI backup\r\n     * @param orgJsonUriBackup2 New ORG.JSON URI backup\r\n     */\r\n    function setOrgJson(\r\n        bytes32 orgId,\r\n        bytes32 orgJsonHash,\r\n        string calldata orgJsonUri,\r\n        string calldata orgJsonUriBackup1,\r\n        string calldata orgJsonUriBackup2\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Get all active organizations' ORGiD hashes\r\n     * @param includeInactive Includes not active units into response\r\n     * @return {\r\n         \"organizationsList\": \"Array of all active organizations' ORGiD hashes\"\r\n     }\r\n     */\r\n    function getOrganizations(bool includeInactive)\r\n        external\r\n        view\r\n        returns (bytes32[] memory organizationsList);\r\n\r\n    /**\r\n     * @dev Get organization or unit's info by ORGiD hash\r\n     * @param _orgId ORGiD hash\r\n     * @dev Return parameters marked by (*) are only applicable to units\r\n     * @return {\r\n         \"exists\": \"Returns `false` if ORGiD doesn't exist\",\r\n         \"orgId\": \"ORGiD hash\",\r\n         \"orgJsonHash\": \"ORG.JSON keccak256 hash\",\r\n         \"orgJsonUri\": \"ORG.JSON URI\",\r\n         \"orgJsonUriBackup1\": \"ORG.JSON URI backup\",\r\n         \"orgJsonUriBackup2\": \"ORG.JSON URI backup\",\r\n         \"parentOrgId\": \"Parent ORGiD (*)\",\r\n         \"owner\": \"Owner's address\",\r\n         \"director\": \"Unit director's address (*)\",\r\n         \"isActive\": \"Indicates whether ORGiD is active\",\r\n         \"isDirectorshipAccepted\": \"Indicates whether director accepted the role (*)\"\r\n     }\r\n     */\r\n    function getOrganization(bytes32 _orgId)\r\n        external\r\n        view\r\n        returns (\r\n            bool exists,\r\n            bytes32 orgId,\r\n            bytes32 orgJsonHash,\r\n            string memory orgJsonUri,\r\n            string memory orgJsonUriBackup1,\r\n            string memory orgJsonUriBackup2,\r\n            bytes32 parentOrgId,\r\n            address owner,\r\n            address director,\r\n            bool isActive,\r\n            bool isDirectorshipAccepted\r\n        );\r\n\r\n    /**\r\n     * @dev Get all active organizational units of a particular ORGiD\r\n     * @param parentOrgId Parent ORGiD hash\r\n     * @param includeInactive Includes not active units into response\r\n     * @return {\r\n         \"organizationsList\": \"Array of ORGiD hashes of active organizational units\"\r\n     }\r\n     */\r\n    function getUnits(bytes32 parentOrgId, bool includeInactive)\r\n        external\r\n        view\r\n        returns (bytes32[] memory);\r\n}\r\n\r\n// File: contracts/OrgId.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only;\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ORGiD Registry Smart Contract\r\n */\r\ncontract OrgId is OrgIdInterface, OwnablePatch, ERC165, Initializable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /// @dev Organization structure\r\n    struct Organization {\r\n        bytes32 orgId;\r\n        bytes32 orgJsonHash;\r\n        string orgJsonUri;\r\n        string orgJsonUriBackup1;\r\n        string orgJsonUriBackup2;\r\n        bytes32 parentOrgId;\r\n        address owner;\r\n        address director;\r\n        bool isActive;\r\n        bool isDirectorshipAccepted;\r\n        bytes32[] units;\r\n    }\r\n\r\n    /// @dev Mapped list of Organizations\r\n    mapping (bytes32 => Organization) internal organizations;\r\n\r\n    /// @dev List of ORGiD hashes\r\n    bytes32[] internal orgIds;\r\n\r\n    /**\r\n     * @dev Emits when new organization created\r\n     */\r\n    event OrganizationCreated(\r\n        bytes32 indexed orgId,\r\n        address indexed owner\r\n    );\r\n\r\n    /**\r\n     * @dev Emits when new organizational unit created\r\n     */\r\n    event UnitCreated(\r\n        bytes32 indexed parentOrgId,\r\n        bytes32 indexed unitOrgId,\r\n        address indexed director\r\n    );\r\n\r\n    /**\r\n     * @dev Emits when organization active/inactive state changes\r\n     */\r\n    event OrganizationActiveStateChanged(\r\n        bytes32 indexed orgId,\r\n        bool previousState,\r\n        bool newState\r\n    );\r\n\r\n    /**\r\n     * @dev Emits when unit's directorship is accepted\r\n     */\r\n    event DirectorshipAccepted(\r\n        bytes32 indexed orgId,\r\n        address indexed director\r\n    );\r\n\r\n    /**\r\n     * @dev Emits when unit's director changes\r\n     */\r\n    event DirectorshipTransferred(\r\n        bytes32 indexed orgId,\r\n        address indexed previousDirector,\r\n        address indexed newDirector\r\n    );\r\n\r\n    /**\r\n     * @dev Emits when ORGiD owner changes\r\n     */\r\n    event OrganizationOwnershipTransferred(\r\n        bytes32 indexed orgId,\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Emits when ORG.JSON changes\r\n     */\r\n    event OrgJsonChanged(\r\n        bytes32 indexed orgId,\r\n        bytes32 indexed previousOrgJsonHash,\r\n        string previousOrgJsonUri,\r\n        string previousOrgJsonUriBackup1,\r\n        string previousOrgJsonUriBackup2,\r\n        bytes32 indexed newOrgJsonHash,\r\n        string newOrgJsonUri,\r\n        string newOrgJsonUriBackup1,\r\n        string newOrgJsonUriBackup2\r\n    );\r\n\r\n    /**\r\n     * @dev Throws if ORGiD does not exist\r\n     */\r\n    modifier orgIdMustExist(bytes32 orgId) {\r\n        require(\r\n            orgId != bytes32(0) &&\r\n            organizations[orgId].orgId == orgId,\r\n            \"OrgId: Organization not found\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by non-owner\r\n     */\r\n    modifier mustBeCalledByOwner(bytes32 orgId) {\r\n        require(\r\n            organizations[orgId].owner == msg.sender,\r\n            \"OrgId: action not authorized (must be owner)\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by non-director\r\n     */\r\n    modifier mustBeCalledByOwnerOrDirector(bytes32 orgId) {\r\n        require(\r\n            organizations[orgId].owner == msg.sender ||\r\n            organizations[orgId].director == msg.sender,\r\n            \"OrgId: action not authorized (must be owner or director)\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Initializer for upgradeable contracts\r\n     */\r\n    function initialize() public initializer {\r\n        _setInterfaces();\r\n    }\r\n\r\n    /**\r\n     * @dev Initializer for the version 1.1.0\r\n     */\r\n    function initializeUpgrade110() public {\r\n        // ownable interface has been removed in version 1.1.0\r\n        _removeInterface(0x7f5828d0);\r\n    }\r\n\r\n    /**\r\n     * @dev Create organization\r\n     * @param salt Unique hash required for identifier creation\r\n     * @param orgJsonHash ORG.JSON's keccak256 hash\r\n     * @param orgJsonUri ORG.JSON URI (stored off-chain)\r\n     * @param orgJsonUriBackup1 ORG.JSON URI backup (stored off-chain)\r\n     * @param orgJsonUriBackup2 ORG.JSON URI backup (stored off-chain)\r\n     * @return {\r\n         \"id\": \"ORGiD byte32 hash\"\r\n     }\r\n     */\r\n    function createOrganization(\r\n        bytes32 salt,\r\n        bytes32 orgJsonHash,\r\n        string calldata orgJsonUri,\r\n        string calldata orgJsonUriBackup1,\r\n        string calldata orgJsonUriBackup2\r\n    ) external returns (bytes32 id) {\r\n        id = _createOrganization(\r\n            salt,\r\n            bytes32(0),\r\n            address(0),\r\n            orgJsonHash,\r\n            orgJsonUri,\r\n            orgJsonUriBackup1,\r\n            orgJsonUriBackup2\r\n        );\r\n        emit OrganizationCreated(id, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Create organizational unit\r\n     * @param salt Unique hash required for identifier creation\r\n     * @param parentOrgId Parent ORGiD hash\r\n     * @param director Unit director address\r\n     * @param orgJsonHash ORG.JSON keccak256 hash\r\n     * @param orgJsonUri Unit ORG.JSON URI\r\n     * @param orgJsonUriBackup1 Unit ORG.JSON URI backup\r\n     * @param orgJsonUriBackup2 Unit ORG.JSON URI backup\r\n     */\r\n    function createUnit(\r\n        bytes32 salt,\r\n        bytes32 parentOrgId,\r\n        address director,\r\n        bytes32 orgJsonHash,\r\n        string calldata orgJsonUri,\r\n        string calldata orgJsonUriBackup1,\r\n        string calldata orgJsonUriBackup2\r\n    )\r\n        external\r\n        orgIdMustExist(parentOrgId)\r\n        mustBeCalledByOwner(parentOrgId)\r\n        returns (bytes32 newUnitOrgId)\r\n    {\r\n        newUnitOrgId = _createOrganization(\r\n            salt,\r\n            parentOrgId,\r\n            director,\r\n            orgJsonHash,\r\n            orgJsonUri,\r\n            orgJsonUriBackup1,\r\n            orgJsonUriBackup2\r\n        );\r\n        emit UnitCreated(parentOrgId, newUnitOrgId, director);\r\n\r\n        // If parent ORGiD owner indicates their address as director,\r\n        // their directorship is automatically accepted\r\n        if (director == msg.sender) {\r\n            emit DirectorshipAccepted(newUnitOrgId, msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Toggle ORGiD's active/inactive state\r\n     * @param orgId ORGiD hash\r\n     */\r\n    function toggleActiveState(bytes32 orgId)\r\n        external\r\n        orgIdMustExist(orgId)\r\n        mustBeCalledByOwner(orgId)\r\n    {\r\n        emit OrganizationActiveStateChanged(\r\n            orgId,\r\n            organizations[orgId].isActive,\r\n            !organizations[orgId].isActive\r\n        );\r\n        organizations[orgId].isActive = !organizations[orgId].isActive;\r\n    }\r\n\r\n    /**\r\n     * @dev Accept director role\r\n     * @param orgId Unit's ORGiD hash\r\n     */\r\n    function acceptDirectorship(bytes32 orgId)\r\n        external\r\n        orgIdMustExist(orgId)\r\n    {\r\n        require(\r\n            organizations[orgId].director == msg.sender,\r\n            \"OrgId: action not authorized (must be director)\"\r\n        );\r\n\r\n        _acceptDirectorship(orgId);\r\n    }\r\n\r\n    /**\r\n     * @dev Unit directorship transfer\r\n     * @param orgId Unit's ORGiD hash\r\n     * @param newDirector New director's address\r\n     */\r\n    function transferDirectorship(\r\n        bytes32 orgId,\r\n        address newDirector\r\n    )\r\n        external\r\n        orgIdMustExist(orgId)\r\n        mustBeCalledByOwner(orgId)\r\n    {\r\n        emit DirectorshipTransferred(\r\n            orgId,\r\n            organizations[orgId].director,\r\n            newDirector\r\n        );\r\n        organizations[orgId].director = newDirector;\r\n\r\n        if (newDirector == msg.sender) {\r\n            organizations[orgId].isDirectorshipAccepted = true;\r\n            emit DirectorshipAccepted(orgId, newDirector);\r\n        } else {\r\n            organizations[orgId].isDirectorshipAccepted = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Unit directorship renounce\r\n     * @param orgId Unit's ORGiD hash\r\n     */\r\n    function renounceDirectorship(bytes32 orgId)\r\n        external\r\n        orgIdMustExist(orgId)\r\n        mustBeCalledByOwnerOrDirector(orgId)\r\n    {\r\n        emit DirectorshipTransferred(\r\n            orgId,\r\n            organizations[orgId].director,\r\n            address(0)\r\n        );\r\n\r\n        organizations[orgId].director = address(0);\r\n        organizations[orgId].isDirectorshipAccepted = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Ownership transfer\r\n     * @param orgId ORGiD hash\r\n     * @param newOwner New owner's address\r\n     */\r\n    function transferOrganizationOwnership(\r\n        bytes32 orgId,\r\n        address newOwner\r\n    )\r\n        external\r\n        orgIdMustExist(orgId)\r\n        mustBeCalledByOwner(orgId)\r\n    {\r\n        require(\r\n            newOwner != address(0),\r\n            \"OrgId: Invalid owner address\"\r\n        );\r\n\r\n        emit OrganizationOwnershipTransferred(\r\n            orgId,\r\n            organizations[orgId].owner,\r\n            newOwner\r\n        );\r\n        organizations[orgId].owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Shorthand method to change ORG.JSON URI and hash at once\r\n     * @param orgId ORGiD hash\r\n     * @param orgJsonHash New ORG.JSON's keccak256 hash\r\n     * @param orgJsonUri New ORG.JSON URI\r\n     * @param orgJsonUriBackup1 New ORG.JSON URI backup\r\n     * @param orgJsonUriBackup2 New ORG.JSON URI backup\r\n     */\r\n    function setOrgJson(\r\n        bytes32 orgId,\r\n        bytes32 orgJsonHash,\r\n        string calldata orgJsonUri,\r\n        string calldata orgJsonUriBackup1,\r\n        string calldata orgJsonUriBackup2\r\n    )\r\n        external\r\n        orgIdMustExist(orgId)\r\n        mustBeCalledByOwnerOrDirector(orgId)\r\n    {\r\n        require(\r\n            orgJsonHash != bytes32(0),\r\n            \"OrgId: ORG.JSON hash cannot be zero\"\r\n        );\r\n        require(\r\n            bytes(orgJsonUri).length != 0,\r\n            \"OrgId: ORG.JSON URI cannot be empty\"\r\n        );\r\n\r\n        if (msg.sender == organizations[orgId].director &&\r\n            organizations[orgId].isDirectorshipAccepted == false) {\r\n            _acceptDirectorship(orgId);\r\n        }\r\n\r\n        _updateOrgJson(\r\n            orgId,\r\n            orgJsonHash,\r\n            orgJsonUri,\r\n            orgJsonUriBackup1,\r\n            orgJsonUriBackup2\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Get all active organizations' ORGiD hashes\r\n     * @param includeInactive Includes not active organizations into response\r\n     * @return {\r\n         \"organizationsList\": \"Array of all active organizations' ORGiD hashes\"\r\n     }\r\n     */\r\n    function getOrganizations(bool includeInactive)\r\n        external\r\n        view\r\n        returns (bytes32[] memory)\r\n    {\r\n        return _getOrganizations(bytes32(0), includeInactive);\r\n    }\r\n\r\n    /**\r\n     * @dev Get organization or unit's info by ORGiD hash\r\n     * @param _orgId ORGiD hash\r\n     * @dev Return parameters marked by (*) are only applicable to units\r\n     * @return {\r\n         \"exists\": \"Returns `false` if ORGiD doesn't exist\",\r\n         \"orgId\": \"ORGiD hash\",\r\n         \"orgJsonHash\": \"ORG.JSON keccak256 hash\",\r\n         \"orgJsonUri\": \"ORG.JSON URI\",\r\n         \"orgJsonUriBackup1\": \"ORG.JSON URI backup\",\r\n         \"orgJsonUriBackup2\": \"ORG.JSON URI backup\",\r\n         \"parentOrgId\": \"Parent ORGiD (*)\",\r\n         \"owner\": \"Owner's address\",\r\n         \"director\": \"Unit director's address (*)\",\r\n         \"isActive\": \"Indicates whether ORGiD is active\",\r\n         \"isDirectorshipAccepted\": \"Indicates whether director accepted the role (*)\"\r\n     }\r\n     */\r\n    function getOrganization(bytes32 _orgId)\r\n        external\r\n        view\r\n        returns (\r\n            bool exists,\r\n            bytes32 orgId,\r\n            bytes32 orgJsonHash,\r\n            string memory orgJsonUri,\r\n            string memory orgJsonUriBackup1,\r\n            string memory orgJsonUriBackup2,\r\n            bytes32 parentOrgId,\r\n            address owner,\r\n            address director,\r\n            bool isActive,\r\n            bool isDirectorshipAccepted\r\n        )\r\n    {\r\n        exists = _orgId != bytes32(0) && organizations[_orgId].orgId == _orgId;\r\n        orgId = organizations[_orgId].orgId;\r\n        orgJsonHash = organizations[_orgId].orgJsonHash;\r\n        orgJsonUri = organizations[_orgId].orgJsonUri;\r\n        orgJsonUriBackup1 = organizations[_orgId].orgJsonUriBackup1;\r\n        orgJsonUriBackup2 = organizations[_orgId].orgJsonUriBackup2;\r\n        parentOrgId = organizations[_orgId].parentOrgId;\r\n        owner = organizations[_orgId].owner;\r\n        director = organizations[_orgId].director;\r\n        isActive = organizations[_orgId].isActive;\r\n        isDirectorshipAccepted = organizations[_orgId].isDirectorshipAccepted;\r\n    }\r\n\r\n    /**\r\n     * @dev Get all active organizational units of a particular ORGiD\r\n     * @param parentOrgId Parent ORGiD hash\r\n     * @param includeInactive Includes not active units into response\r\n     * @return {\r\n         \"organizationsList\": \"Array of ORGiD hashes of active organizational units\"\r\n     }\r\n     */\r\n    function getUnits(bytes32 parentOrgId, bool includeInactive)\r\n        external\r\n        view\r\n        orgIdMustExist(parentOrgId)\r\n        returns (bytes32[] memory)\r\n    {\r\n        return _getOrganizations(parentOrgId, includeInactive);\r\n    }\r\n\r\n    /**\r\n     * @dev Set supported contract interfaces\r\n     */\r\n    function _setInterfaces() internal {\r\n        OrgIdInterface org;\r\n        bytes4[3] memory interfaceIds = [\r\n            // ERC165 interface: 0x01ffc9a7\r\n            bytes4(0x01ffc9a7),\r\n\r\n            // ORGiD interface: 0x0f4893ef\r\n            org.createOrganization.selector ^\r\n            org.toggleActiveState.selector ^\r\n            org.transferOrganizationOwnership.selector ^\r\n            org.setOrgJson.selector ^\r\n            org.getOrganizations.selector ^\r\n            org.getOrganization.selector,\r\n\r\n            // hierarchy interface: 0x6af2fb27\r\n            org.createUnit.selector ^\r\n            org.acceptDirectorship.selector ^\r\n            org.transferDirectorship.selector ^\r\n            org.renounceDirectorship.selector ^\r\n            org.getUnits.selector\r\n        ];\r\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\r\n            _registerInterface(interfaceIds[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Create new organization and add it to storage\r\n     * @param salt Unique hash required for identifier creation\r\n     * @param parentOrgId Parent ORGiD hash (if applicable)\r\n     * @param director Unit director address (if applicable)\r\n     * @param orgJsonHash ORG.JSON keccak256 hash\r\n     * @param orgJsonUri ORG.JSON URI\r\n     * @param orgJsonUriBackup1 ORG.JSON URI backup\r\n     * @param orgJsonUriBackup2 ORG.JSON URI backup\r\n     * @return {\r\n         \"ORGiD\": \"New ORGiD hash\"\r\n     }\r\n     */\r\n    function _createOrganization(\r\n        bytes32 salt,\r\n        bytes32 parentOrgId,\r\n        address director,\r\n        bytes32 orgJsonHash,\r\n        string memory orgJsonUri,\r\n        string memory orgJsonUriBackup1,\r\n        string memory orgJsonUriBackup2\r\n    ) internal returns (bytes32) {\r\n        require(\r\n            parentOrgId == bytes32(0) ||\r\n            (\r\n                // If this is a unit...\r\n                parentOrgId != bytes32(0) &&\r\n                organizations[parentOrgId].orgId == parentOrgId\r\n            ),\r\n            \"OrgId: Parent ORGiD not found\"\r\n        );\r\n\r\n        // Organization unique Id creation\r\n        bytes32 orgId = keccak256(\r\n            abi.encodePacked(\r\n                msg.sender,\r\n                salt\r\n            )\r\n        );\r\n\r\n        require(\r\n            organizations[orgId].orgId == bytes32(0),\r\n            \"OrgId: Organizarion already exists\"\r\n        );\r\n\r\n        organizations[orgId] = Organization(\r\n            orgId,\r\n            orgJsonHash,\r\n            orgJsonUri,\r\n            orgJsonUriBackup1,\r\n            orgJsonUriBackup2,\r\n            parentOrgId,\r\n            msg.sender,\r\n            director,\r\n            true,\r\n            director == msg.sender ||\r\n                (parentOrgId != bytes32(0) && director == address(0)),\r\n            new bytes32[](0)\r\n        );\r\n        orgIds.push(orgId);\r\n\r\n        if (parentOrgId != bytes32(0)) {\r\n            organizations[parentOrgId].units.push(orgId);\r\n        }\r\n\r\n        return orgId;\r\n    }\r\n\r\n    /**\r\n     * @dev Get all active organizations' ORGiD hashes in the registry (if no input provided)\r\n     * @dev OR, if input is a valid ORGiD, get all active units' ORGiD hashes\r\n     * @param orgId ORGiD hash or zero bytes\r\n     * @param includeInactive Includes not active organizations into response\r\n     * @return {\r\n         \"organizationsList\": \"Array of ORGiD hashes\"\r\n     }\r\n     */\r\n    function _getOrganizations(bytes32 orgId, bool includeInactive)\r\n        internal\r\n        view\r\n        returns (bytes32[] memory organizationsList)\r\n    {\r\n        bytes32[] memory source =\r\n            orgId == bytes32(0)\r\n            ? orgIds\r\n            : organizations[orgId].units;\r\n        organizationsList = new bytes32[](_getOrganizationsCount(orgId, includeInactive));\r\n        uint256 index;\r\n\r\n        for (uint256 i = 0; i < source.length; i++) {\r\n            // If organization is active (OR  not active) AND\r\n            // organization is top level (not unit) OR\r\n            // organization is a unit AND directorship is accepted\r\n            if ((\r\n                    (!includeInactive && organizations[source[i]].isActive) ||\r\n                    includeInactive\r\n                ) &&\r\n                (\r\n                    (orgId == bytes32(0) && organizations[source[i]].parentOrgId == bytes32(0)) ||\r\n                    orgId != bytes32(0)\r\n                )) {\r\n\r\n                organizationsList[index] = source[i];\r\n                index += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get a number of active organizations in the registry (if input is zero bytes)\r\n     * @dev OR, if input is a valid ORGiD, get a number of active organizational units\r\n     * @param orgId ORGiD hash or zero bytes\r\n     * @param includeInactive Includes not active organizations into response\r\n     * @return {\r\n         \"count\": \"ORGiD count\"\r\n     }\r\n     */\r\n    function _getOrganizationsCount(bytes32 orgId, bool includeInactive)\r\n        internal\r\n        view\r\n        returns (uint256 count)\r\n    {\r\n        bytes32[] memory source =\r\n            orgId == bytes32(0)\r\n            ? orgIds\r\n            : organizations[orgId].units;\r\n\r\n        for (uint256 i = 0; i < source.length; i++) {\r\n            if ((\r\n                    (!includeInactive && organizations[source[i]].isActive) ||\r\n                    includeInactive\r\n                ) &&\r\n                (\r\n                    (orgId == bytes32(0) && organizations[source[i]].parentOrgId == bytes32(0)) ||\r\n                    orgId != bytes32(0)\r\n                )) {\r\n\r\n                count += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Unit directorship acceptance\r\n     * @param orgId ORGiD hash\r\n     */\r\n    function _acceptDirectorship(bytes32 orgId) internal {\r\n        organizations[orgId].isDirectorshipAccepted = true;\r\n        emit DirectorshipAccepted(orgId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev ORG.JSON storage update\r\n     * @param orgId ORGiD hash\r\n     * @param orgJsonHash ORG.JSON keccak256 hash\r\n     * @param orgJsonUri ORG.JSON URI\r\n     * @param orgJsonUriBackup1 ORG.JSON URI backup\r\n     * @param orgJsonUriBackup2 ORG.JSON URI backup\r\n     */\r\n    function _updateOrgJson(\r\n        bytes32 orgId,\r\n        bytes32 orgJsonHash,\r\n        string memory orgJsonUri,\r\n        string memory orgJsonUriBackup1,\r\n        string memory orgJsonUriBackup2\r\n    ) internal {\r\n        emit OrgJsonChanged(\r\n            orgId,\r\n            organizations[orgId].orgJsonHash,\r\n            organizations[orgId].orgJsonUri,\r\n            organizations[orgId].orgJsonUriBackup1,\r\n            organizations[orgId].orgJsonUriBackup2,\r\n            orgJsonHash,\r\n            orgJsonUri,\r\n            orgJsonUriBackup1,\r\n            orgJsonUriBackup2\r\n        );\r\n\r\n        organizations[orgId].orgJsonHash = orgJsonHash;\r\n        organizations[orgId].orgJsonUri = orgJsonUri;\r\n        organizations[orgId].orgJsonUriBackup1 = orgJsonUriBackup1;\r\n        organizations[orgId].orgJsonUriBackup2 = orgJsonUriBackup2;\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"director\",\"type\":\"address\"}],\"name\":\"DirectorshipAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousDirector\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDirector\",\"type\":\"address\"}],\"name\":\"DirectorshipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousOrgJsonHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"previousOrgJsonUri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"previousOrgJsonUriBackup1\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"previousOrgJsonUriBackup2\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newOrgJsonHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newOrgJsonUri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newOrgJsonUriBackup1\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newOrgJsonUriBackup2\",\"type\":\"string\"}],\"name\":\"OrgJsonChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"previousState\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"}],\"name\":\"OrganizationActiveStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OrganizationCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OrganizationOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"parentOrgId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"unitOrgId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"director\",\"type\":\"address\"}],\"name\":\"UnitCreated\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"}],\"name\":\"acceptDirectorship\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"orgJsonHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"orgJsonUri\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"orgJsonUriBackup1\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"orgJsonUriBackup2\",\"type\":\"string\"}],\"name\":\"createOrganization\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"parentOrgId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"director\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"orgJsonHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"orgJsonUri\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"orgJsonUriBackup1\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"orgJsonUriBackup2\",\"type\":\"string\"}],\"name\":\"createUnit\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"newUnitOrgId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_orgId\",\"type\":\"bytes32\"}],\"name\":\"getOrganization\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"orgJsonHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"orgJsonUri\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"orgJsonUriBackup1\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"orgJsonUriBackup2\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"parentOrgId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"director\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDirectorshipAccepted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"includeInactive\",\"type\":\"bool\"}],\"name\":\"getOrganizations\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parentOrgId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"includeInactive\",\"type\":\"bool\"}],\"name\":\"getUnits\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initializeUpgrade110\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"}],\"name\":\"renounceDirectorship\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"orgJsonHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"orgJsonUri\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"orgJsonUriBackup1\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"orgJsonUriBackup2\",\"type\":\"string\"}],\"name\":\"setOrgJson\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"}],\"name\":\"toggleActiveState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"newDirector\",\"type\":\"address\"}],\"name\":\"transferDirectorship\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOrganizationOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OrgId", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "constantinople", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://e116b8a9235bd02ce0e5b2d73efe4bde758d84e47026c6b3920adced8d5f71e2"}]}