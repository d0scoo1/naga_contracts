{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"Buffer.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-2-Clause\\n// https://github.com/ensdomains/buffer\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev A library for working with mutable byte buffers in Solidity.\\n *\\n * Byte buffers are mutable and expandable, and provide a variety of primitives\\n * for writing to them. At any time you can fetch a bytes object containing the\\n * current contents of the buffer. The bytes object should not be stored between\\n * operations, as it may change due to resizing of the buffer.\\n */\\nlibrary Buffer {\\n    /**\\n     * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n     *      a capacity. The capacity may be longer than the current value, in\\n     *      which case it can be extended without the need to allocate more memory.\\n     */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n     * @dev Initializes a buffer with an initial capacity.a co\\n     * @param buf The buffer to initialize.\\n     * @param capacity The number of bytes of space to allocate the buffer.\\n     * @return The buffer, for chaining.\\n     */\\n    function init(buffer memory buf, uint capacity) internal pure returns (buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            mstore(0x40, add(32, add(ptr, capacity)))\\n        }\\n        return buf;\\n    }\\n\\n\\n    /**\\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n     *      the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param off The start offset to write to.\\n     * @param rawData The data to append.\\n     * @param len The number of bytes to copy.\\n     * @return The original buffer, for chaining.\\n     */\\n    function writeRawBytes(\\n        buffer memory buf,\\n        uint off,\\n        bytes memory rawData,\\n        uint offData,\\n        uint len\\n    ) internal pure returns (buffer memory) {\\n        if (off + len \\u003e buf.capacity) {\\n            resize(buf, max(buf.capacity, len + off) * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we\\u0027re extending it\\n            if gt(add(len, off), buflen) {\\n                mstore(bufptr, add(len, off))\\n            }\\n            src := add(rawData, offData)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len \\u003e= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = 256**(32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n     *      the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param off The start offset to write to.\\n     * @param data The data to append.\\n     * @param len The number of bytes to copy.\\n     * @return The original buffer, for chaining.\\n     */\\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns (buffer memory) {\\n        require(len \\u003c= data.length);\\n\\n        if (off + len \\u003e buf.capacity) {\\n            resize(buf, max(buf.capacity, len + off) * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n        // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n        // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n        // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n        // Update buffer length if we\\u0027re extending it\\n            if gt(add(len, off), buflen) {\\n                mstore(bufptr, add(len, off))\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len \\u003e= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = 256**(32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n\\n        return buf;\\n    }\\n\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, data.length);\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    function max(uint a, uint b) private pure returns (uint) {\\n        if (a \\u003e b) {\\n            return a;\\n        }\\n        return b;\\n    }\\n}\\n\"},\"ILayerZeroValidationLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity \\u003e=0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"./LayerZeroPacket.sol\\\";\\n\\ninterface ILayerZeroValidationLibrary {\\n    function validateProof(bytes32 blockData, bytes calldata _data, uint _remoteAddressSize) external returns (LayerZeroPacket.Packet memory packet);\\n}\\n\"},\"LayerZeroPacket.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary LayerZeroPacket {\\n    struct Packet {\\n        uint16 srcChainId;\\n        uint16 dstChainId;\\n        uint64 nonce;\\n        address dstAddress;\\n        bytes srcAddress;\\n        bytes32 ulnAddress;\\n        bytes payload;\\n    }\\n}\\n\"},\"MPTValidatorV2.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./LayerZeroPacket.sol\\\";\\nimport \\\"./Buffer.sol\\\";\\nimport \\\"./ILayerZeroValidationLibrary.sol\\\";\\nimport \\\"./UltraLightNodeEVMDecoder.sol\\\";\\n\\ncontract MPTValidatorV2 is ILayerZeroValidationLibrary {\\n    using RLPDecode for RLPDecode.RLPItem;\\n    using RLPDecode for RLPDecode.Iterator;\\n    using Buffer for Buffer.buffer;\\n    using SafeMath for uint;\\n\\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\\n\\n    struct ULNLog{\\n        bytes32 contractAddress;\\n        bytes32 topicZeroSig;\\n        bytes data;\\n    }\\n\\n    function validateProof(bytes32 _receiptsRoot, bytes calldata _transactionProof, uint _remoteAddressSize) external pure override returns (LayerZeroPacket.Packet memory packet) {\\n        (uint16 remoteChainId, bytes[] memory proof, uint[] memory receiptSlotIndex, uint logIndex) = abi.decode(_transactionProof, (uint16, bytes[], uint[], uint));\\n\\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\\n        require(log.topicZeroSig == PACKET_SIGNATURE, \\\"ProofLib: packet not recognized\\\"); //data\\n\\n        return _getPacket(log.data, remoteChainId, _remoteAddressSize, log.contractAddress);\\n    }\\n\\n    function _getVerifiedLog(bytes32 hashRoot, uint[] memory paths, uint logIndex, bytes[] memory proof) internal pure returns(ULNLog memory) {\\n        require(paths.length == proof.length, \\\"ProofLib: invalid proof size\\\");\\n\\n        RLPDecode.RLPItem memory item;\\n        bytes memory proofBytes;\\n\\n        for (uint i = 0; i \\u003c proof.length; i++) {\\n            proofBytes = proof[i];\\n            require(hashRoot == keccak256(proofBytes), \\\"ProofLib: invalid hashlink\\\");\\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\\n            if (i \\u003c proof.length - 1) hashRoot = bytes32(item.toUint());\\n        }\\n\\n        // burning status + gasUsed + logBloom\\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\\n        RLPDecode.Iterator memory it =  logItem.safeGetItemByIndex(logIndex).iterator();\\n        ULNLog memory log;\\n        log.contractAddress = bytes32(it.next().toUint());\\n        log.topicZeroSig = bytes32(it.next().getItemByIndex(0).toUint());\\n        log.data = it.next().toBytes();\\n\\n        return log;\\n    }\\n\\n    // profiling and test\\n    function getVerifyLog(bytes32 hashRoot, uint[] memory receiptSlotIndex, uint logIndex, bytes[] memory proof) external pure returns(ULNLog memory){\\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\\n    }\\n\\n    function getPacket(bytes memory data, uint16 srcChain, uint sizeOfSrcAddress, bytes32 ulnAddress) external pure returns(LayerZeroPacket.Packet memory) {\\n        return _getPacket(data, srcChain, sizeOfSrcAddress, ulnAddress);\\n    }\\n\\n    function _getPacket(\\n        bytes memory data,\\n        uint16 srcChain,\\n        uint sizeOfSrcAddress,\\n        bytes32 ulnAddress\\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\\n        uint16 dstChainId;\\n        address dstAddress;\\n        uint size;\\n        uint64 nonce;\\n\\n        // The log consists of the destination chain id and then a bytes payload\\n        //      0--------------------------------------------31\\n        // 0   |  destination chain id\\n        // 32  |  defines bytes array\\n        // 64  |\\n        // 96  |  bytes array size\\n        // 128 |  payload\\n        assembly {\\n            dstChainId := mload(add(data, 32))\\n            size := mload(add(data, 96)) /// size of the byte array\\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\\n        }\\n\\n        Buffer.buffer memory srcAddressBuffer;\\n        srcAddressBuffer.init(sizeOfSrcAddress);\\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\\n\\n        uint payloadSize = size.sub(20).sub(sizeOfSrcAddress);\\n        Buffer.buffer memory payloadBuffer;\\n        payloadBuffer.init(payloadSize);\\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\\n        return LayerZeroPacket.Packet(srcChain, dstChainId, nonce, dstAddress, srcAddressBuffer.buf, ulnAddress, payloadBuffer.buf);\\n    }\\n}\\n\"},\"RLPDecode.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// https://github.com/hamdiallam/solidity-rlp\\n\\npragma solidity ^0.7.0;\\n\\nlibrary RLPDecode {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint len;\\n        uint memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that\\u0027s being iterated over.\\n        uint nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self), \\\"RLPDecoder iterator has no next\\\");\\n\\n        uint ptr = self.nextPtr;\\n        uint itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr \\u003c item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n        // offset the pointer if the first byte\\n\\n        uint8 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n        uint len = item.length;\\n        if (byte0 \\u003c LIST_SHORT_START) {\\n            assembly {\\n                memPtr := add(memPtr, 0x01)\\n            }\\n            len -= 1;\\n        }\\n        return RLPItem(len, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An \\u0027Iterator\\u0027 over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self), \\\"RLPDecoder iterator is not list\\\");\\n\\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\\n        return item.len - _payloadOffset(item.memPtr);\\n    }\\n\\n    /*\\n     * @param item RLP encoded list in bytes\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item), \\\"RLPDecoder iterator is not a list\\\");\\n\\n        uint items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint dataLen;\\n        for (uint i = 0; i \\u003c items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    /*\\n     * @param get the RLP item by index. save gas.\\n     */\\n    function getItemByIndex(RLPItem memory item, uint idx) internal pure returns (RLPItem memory) {\\n        require(isList(item), \\\"RLPDecoder iterator is not a list\\\");\\n\\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint dataLen;\\n        for (uint i = 0; i \\u003c idx; i++) {\\n            dataLen = _itemLength(memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n        dataLen = _itemLength(memPtr);\\n        return RLPItem(dataLen, memPtr);\\n    }\\n\\n\\n    /*\\n     * @param get the RLP item by index. save gas.\\n     */\\n    function safeGetItemByIndex(RLPItem memory item, uint idx) internal pure returns (RLPItem memory) {\\n        require(isList(item), \\\"RLPDecoder iterator is not a list\\\");\\n\\n        uint endPtr = item.memPtr + item.len;\\n\\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint dataLen;\\n        for (uint i = 0; i \\u003c idx; i++) {\\n            dataLen = _itemLength(memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n        dataLen = _itemLength(memPtr);\\n\\n        require(memPtr + dataLen \\u003c= endPtr, \\\"RLP item overflow\\\");\\n        return RLPItem(dataLen, memPtr);\\n    }\\n\\n    /*\\n     * @param offset the receipt bytes item\\n     */\\n    function typeOffset(RLPItem memory item) internal pure returns (RLPItem memory) {\\n        uint offset = _payloadOffset(item.memPtr);\\n        uint8 byte0;\\n        uint memPtr = item.memPtr;\\n        uint len = item.len;\\n        assembly {\\n            memPtr := add(memPtr, offset)\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n        if (byte0 \\u003c LIST_SHORT_START) {\\n            assembly {\\n                memPtr := add(memPtr, 0x01)\\n            }\\n            len -= 1;\\n        }\\n        return RLPItem(len, memPtr);\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 \\u003c LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1, \\\"RLPDecoder toBoolean invalid length\\\");\\n        uint result;\\n        uint memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21, \\\"RLPDecoder toAddress invalid length\\\");\\n\\n        return address(toUint(item));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint) {\\n        require(item.len \\u003e 0 \\u0026\\u0026 item.len \\u003c= 33, \\\"RLPDecoder toUint invalid length\\\");\\n\\n        uint offset = _payloadOffset(item.memPtr);\\n        uint len = item.len - offset;\\n\\n        uint result;\\n        uint memPtr = item.memPtr + offset;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shift to the correct location if necessary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\\n        // one byte prefix\\n        require(item.len == 33, \\\"RLPDecoder toUintStrict invalid length\\\");\\n\\n        uint result;\\n        uint memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len \\u003e 0, \\\"RLPDecoder toBytes invalid length\\\");\\n\\n        uint offset = _payloadOffset(item.memPtr);\\n        uint len = item.len - offset; // data length\\n        bytes memory result = new bytes(len);\\n\\n        uint destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr + offset, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) internal pure returns (uint) {\\n        if (item.len == 0) return 0;\\n\\n        uint count = 0;\\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint endPtr = item.memPtr + item.len;\\n        while (currPtr \\u003c endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint memPtr) private pure returns (uint) {\\n        uint itemLen;\\n        uint byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 \\u003c STRING_SHORT_START) itemLen = 1;\\n        else if (byte0 \\u003c STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\\n        else if (byte0 \\u003c LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 \\u003c LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\\n        uint byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 \\u003c STRING_SHORT_START) return 0;\\n        else if (byte0 \\u003c STRING_LONG_START || (byte0 \\u003e= LIST_SHORT_START \\u0026\\u0026 byte0 \\u003c LIST_LONG_START)) return 1;\\n        else if (byte0 \\u003c LIST_SHORT_START)\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        else return byte0 - (LIST_LONG_START - 1) + 1;\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(\\n        uint src,\\n        uint dest,\\n        uint len\\n    ) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len \\u003e= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        // left over bytes. Mask is used to remove unwanted bytes from the word\\n        uint mask = 256**(WORD_SIZE - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask)) // zero out src\\n            let destpart := and(mload(dest), mask) // retrieve the bytes\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c \\u003c a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b \\u003e a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"UltraLightNodeEVMDecoder.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"./RLPDecode.sol\\\";\\n\\nlibrary UltraLightNodeEVMDecoder {\\n    using RLPDecode for RLPDecode.RLPItem;\\n    using RLPDecode for RLPDecode.Iterator;\\n\\n    struct Log {\\n        address contractAddress;\\n        bytes32 topicZero;\\n        bytes data;\\n    }\\n\\n    function getReceiptLog(bytes memory data, uint logIndex) internal pure returns (Log memory) {\\n        RLPDecode.Iterator memory it = RLPDecode.toRlpItem(data).iterator();\\n        uint idx;\\n        while (it.hasNext()) {\\n            if (idx == 3) {\\n                return toReceiptLog(it.next().getItemByIndex(logIndex).toRlpBytes());\\n            } else it.next();\\n            idx++;\\n        }\\n        revert(\\\"no log index in receipt\\\");\\n    }\\n\\n    function toReceiptLog(bytes memory data) internal pure returns (Log memory) {\\n        RLPDecode.Iterator memory it = RLPDecode.toRlpItem(data).iterator();\\n        Log memory log;\\n\\n        uint idx;\\n        while (it.hasNext()) {\\n            if (idx == 0) {\\n                log.contractAddress = it.next().toAddress();\\n            } else if (idx == 1) {\\n                RLPDecode.RLPItem memory item = it.next().getItemByIndex(0);\\n                log.topicZero = bytes32(item.toUint());\\n            } else if (idx == 2) log.data = it.next().toBytes();\\n            else it.next();\\n            idx++;\\n        }\\n        return log;\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"name\":\"PACKET_SIGNATURE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"srcChain\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"sizeOfSrcAddress\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ulnAddress\",\"type\":\"bytes32\"}],\"name\":\"getPacket\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"ulnAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct LayerZeroPacket.Packet\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hashRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"receiptSlotIndex\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"logIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"proof\",\"type\":\"bytes[]\"}],\"name\":\"getVerifyLog\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"contractAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"topicZeroSig\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct MPTValidatorV2.ULNLog\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_receiptsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_transactionProof\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_remoteAddressSize\",\"type\":\"uint256\"}],\"name\":\"validateProof\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"ulnAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct LayerZeroPacket.Packet\",\"name\":\"packet\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "MPTValidatorV2", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "30000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5a2d9ad413ddabd7a04d1e66ebddc529e103615f58a5661d5ec4172f439a7f9e"}]}