{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"Address.sol\":{\"content\":\"// File: openzeppelin-solidity/contracts/utils/Address.sol\\n\\npragma solidity ^0.5.0;\\n\\n/**\\n * @dev Collection of functions related to the address type,\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * \\u003e It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size \\u003e 0;\\n    }\\n}\\n\"},\"Context.sol\":{\"content\":\"// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.4.0/contracts/GSN/Context.sol\\n\\npragma solidity ^0.5.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor() internal {}\\n\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"Counters.sol\":{\"content\":\"// File: openzeppelin-solidity/contracts/drafts/Counters.sol\\n\\npragma solidity ^0.5.0;\\n\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\\n * directly accessed.\\n */\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library\\u0027s function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\"},\"CustomERC721Metadata.sol\":{\"content\":\"// File: contracts/CustomERC721Metadata.sol\\n\\npragma solidity ^0.5.0;\\n\\nimport \\u0027./ERC165.sol\\u0027;\\nimport \\u0027./ERC721.sol\\u0027;\\nimport \\u0027./ERC721Enumerable.sol\\u0027;\\n\\n/**\\n * ERC721 base contract without the concept of tokenUri as this is managed by the parent\\n */\\ncontract CustomERC721Metadata is ERC165, ERC721, ERC721Enumerable {\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /**\\n     * @dev Constructor function\\n     */\\n    constructor(string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n    }\\n\\n    /**\\n     * @dev Gets the token name\\n     * @return string representing the token name\\n     */\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Gets the token symbol\\n     * @return string representing the token symbol\\n     */\\n    function symbol() external view returns (string memory) {\\n        return _symbol;\\n    }\\n}\\n\"},\"ERC165.sol\":{\"content\":\"// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\\n\\npragma solidity ^0.5.0;\\n\\nimport \\u0027./IERC165.sol\\u0027;\\n\\n/**\\n * @dev Implementation of the `IERC165` interface.\\n *\\n * Contracts may inherit from this and call `_registerInterface` to declare\\n * their support of an interface.\\n */\\ncontract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027)) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it\\u0027s supported.\\n     */\\n    mapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\n\\n    constructor() internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See `IERC165.supportsInterface`.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See `IERC165.supportsInterface`.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal {\\n        require(interfaceId != 0xffffffff, \\u0027ERC165: invalid interface id\\u0027);\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"},\"ERC20.sol\":{\"content\":\"// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.4.0/contracts/token/ERC20/ERC20.sol\\npragma solidity ^0.5.0;\\n\\nimport \\u0027./Context.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping(address =\\u003e uint256) private _balances;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()].sub(\\n                amount,\\n                \\u0027ERC20: transfer amount exceeds allowance\\u0027\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].sub(\\n                subtractedValue,\\n                \\u0027ERC20: decreased allowance below zero\\u0027\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        require(sender != address(0), \\u0027ERC20: transfer from the zero address\\u0027);\\n        require(recipient != address(0), \\u0027ERC20: transfer to the zero address\\u0027);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\u0027ERC20: transfer amount exceeds balance\\u0027);\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\u0027ERC20: mint to the zero address\\u0027);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\u0027ERC20: burn from the zero address\\u0027);\\n\\n        _balances[account] = _balances[account].sub(amount, \\u0027ERC20: burn amount exceeds balance\\u0027);\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        require(owner != address(0), \\u0027ERC20: approve from the zero address\\u0027);\\n        require(spender != address(0), \\u0027ERC20: approve to the zero address\\u0027);\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller\\u0027s allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(\\n            account,\\n            _msgSender(),\\n            _allowances[account][_msgSender()].sub(amount, \\u0027ERC20: burn amount exceeds allowance\\u0027)\\n        );\\n    }\\n}\\n\"},\"ERC721.sol\":{\"content\":\"// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\\n\\npragma solidity ^0.5.0;\\n\\nimport \\u0027./ERC165.sol\\u0027;\\nimport \\u0027./IERC721.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./Address.sol\\u0027;\\nimport \\u0027./Counters.sol\\u0027;\\nimport \\u0027./IERC721Receiver.sol\\u0027;\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721 is ERC165, IERC721 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using Counters for Counters.Counter;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from token ID to owner\\n    mapping(uint256 =\\u003e address) private _tokenOwner;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 =\\u003e address) private _tokenApprovals;\\n\\n    // Mapping from owner to number of owned token\\n    mapping(address =\\u003e Counters.Counter) private _ownedTokensCount;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) private _operatorApprovals;\\n\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    constructor() public {\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n    }\\n\\n    function balanceOf(address owner) public view returns (uint256) {\\n        require(owner != address(0), \\u0027ERC721: balance query for the zero address\\u0027);\\n\\n        return _ownedTokensCount[owner].current();\\n    }\\n\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\n        address owner = _tokenOwner[tokenId];\\n        require(owner != address(0), \\u0027ERC721: owner query for nonexistent token\\u0027);\\n\\n        return owner;\\n    }\\n\\n    function approve(address to, uint256 tokenId) public {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\u0027ERC721: approval to current owner\\u0027);\\n\\n        require(\\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\\n            \\u0027ERC721: approve caller is not owner nor approved for all\\u0027\\n        );\\n\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    function getApproved(uint256 tokenId) public view returns (address) {\\n        require(_exists(tokenId), \\u0027ERC721: approved query for nonexistent token\\u0027);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    function setApprovalForAll(address to, bool approved) public {\\n        require(to != msg.sender, \\u0027ERC721: approve to caller\\u0027);\\n\\n        _operatorApprovals[msg.sender][to] = approved;\\n        emit ApprovalForAll(msg.sender, to, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public {\\n        //solhint-disable-next-line max-line-length\\n        require(\\n            _isApprovedOrOwner(msg.sender, tokenId),\\n            \\u0027ERC721: transfer caller is not owner nor approved\\u0027\\n        );\\n\\n        _transferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public {\\n        safeTransferFrom(from, to, tokenId, \\u0027\\u0027);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public {\\n        transferFrom(from, to, tokenId);\\n        require(\\n            _checkOnERC721Received(from, to, tokenId, _data),\\n            \\u0027ERC721: transfer to non ERC721Receiver implementer\\u0027\\n        );\\n    }\\n\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        address owner = _tokenOwner[tokenId];\\n        return owner != address(0);\\n    }\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(_exists(tokenId), \\u0027ERC721: operator query for nonexistent token\\u0027);\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner ||\\n            getApproved(tokenId) == spender ||\\n            isApprovedForAll(owner, spender));\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal {\\n        require(to != address(0), \\u0027ERC721: mint to the zero address\\u0027);\\n        require(!_exists(tokenId), \\u0027ERC721: token already minted\\u0027);\\n\\n        _tokenOwner[tokenId] = to;\\n        _ownedTokensCount[to].increment();\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    function _burn(address owner, uint256 tokenId) internal {\\n        require(ownerOf(tokenId) == owner, \\u0027ERC721: burn of token that is not own\\u0027);\\n\\n        _clearApproval(tokenId);\\n\\n        _ownedTokensCount[owner].decrement();\\n        _tokenOwner[tokenId] = address(0);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    function _burn(uint256 tokenId) internal {\\n        _burn(ownerOf(tokenId), tokenId);\\n    }\\n\\n    function _transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal {\\n        require(ownerOf(tokenId) == from, \\u0027ERC721: transfer of token that is not own\\u0027);\\n        require(to != address(0), \\u0027ERC721: transfer to the zero address\\u0027);\\n\\n        _clearApproval(tokenId);\\n\\n        _ownedTokensCount[from].decrement();\\n        _ownedTokensCount[to].increment();\\n\\n        _tokenOwner[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal returns (bool) {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n\\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    function _clearApproval(uint256 tokenId) private {\\n        if (_tokenApprovals[tokenId] != address(0)) {\\n            _tokenApprovals[tokenId] = address(0);\\n        }\\n    }\\n}\\n\"},\"ERC721Enumerable.sol\":{\"content\":\"// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Enumerable.sol\\n\\npragma solidity ^0.5.0;\\n\\nimport \\u0027./ERC165.sol\\u0027;\\nimport \\u0027./ERC721.sol\\u0027;\\nimport \\u0027./IERC721Enumerable.sol\\u0027;\\n\\n/**\\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address =\\u003e uint256[]) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 =\\u003e uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 =\\u003e uint256) private _allTokensIndex;\\n\\n    /*\\n     *     bytes4(keccak256(\\u0027totalSupply()\\u0027)) == 0x18160ddd\\n     *     bytes4(keccak256(\\u0027tokenOfOwnerByIndex(address,uint256)\\u0027)) == 0x2f745c59\\n     *     bytes4(keccak256(\\u0027tokenByIndex(uint256)\\u0027)) == 0x4f6ccce7\\n     *\\n     *     =\\u003e 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    /**\\n     * @dev Constructor function.\\n     */\\n    constructor() public {\\n        // register the supported interface to conform to ERC721Enumerable via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    /**\\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\\n     * @param owner address owning the tokens list to be accessed\\n     * @param index uint256 representing the index to be accessed of the requested tokens list\\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\\n        require(index \\u003c balanceOf(owner), \\u0027ERC721Enumerable: owner index out of bounds\\u0027);\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev Gets the total amount of tokens stored by the contract.\\n     * @return uint256 representing the total amount of tokens\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev Gets the token ID at a given index of all the tokens in this contract\\n     * Reverts if the index is greater or equal to the total number of tokens.\\n     * @param index uint256 representing the index to be accessed of the tokens list\\n     * @return uint256 token ID at the given index of the tokens list\\n     */\\n    function tokenByIndex(uint256 index) public view returns (uint256) {\\n        require(index \\u003c totalSupply(), \\u0027ERC721Enumerable: global index out of bounds\\u0027);\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ownership of a given token ID to another address.\\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function _transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal {\\n        super._transferFrom(from, to, tokenId);\\n\\n        _removeTokenFromOwnerEnumeration(from, tokenId);\\n\\n        _addTokenToOwnerEnumeration(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to mint a new token.\\n     * Reverts if the given token ID already exists.\\n     * @param to address the beneficiary that will own the minted token\\n     * @param tokenId uint256 ID of the token to be minted\\n     */\\n    function _mint(address to, uint256 tokenId) internal {\\n        super._mint(to, tokenId);\\n\\n        _addTokenToOwnerEnumeration(to, tokenId);\\n\\n        _addTokenToAllTokensEnumeration(tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn a specific token.\\n     * Reverts if the token does not exist.\\n     * Deprecated, use _burn(uint256) instead.\\n     * @param owner owner of the token to burn\\n     * @param tokenId uint256 ID of the token being burned\\n     */\\n    function _burn(address owner, uint256 tokenId) internal {\\n        super._burn(owner, tokenId);\\n\\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\\n        _ownedTokensIndex[tokenId] = 0;\\n\\n        _removeTokenFromAllTokensEnumeration(tokenId);\\n    }\\n\\n    /**\\n     * @dev Gets the list of token IDs of the requested owner.\\n     * @param owner address owning the tokens\\n     * @return uint256[] List of token IDs owned by the requested address\\n     */\\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\\n        return _ownedTokens[owner];\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension\\u0027s ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\\n        _ownedTokens[to].push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension\\u0027s token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension\\u0027s ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from\\u0027s tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\\u0027s index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        _ownedTokens[from].length--;\\n\\n        // Note that _ownedTokensIndex[tokenId] hasn\\u0027t been cleared: it still points to the old slot (now occupied by\\n        // lastTokenId, or just over the end of the array if the token was the last one).\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension\\u0027s token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an \\u0027if\\u0027 statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\\u0027s index\\n\\n        // This also deletes the contents at the last position of the array\\n        _allTokens.length--;\\n        _allTokensIndex[tokenId] = 0;\\n    }\\n}\\n\"},\"GenArt721Minter_DoodleLabs_Custom_Sale.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\u0027./GenArt721Minter_DoodleLabs_MultiMinter.sol\\u0027;\\nimport \\u0027./Strings.sol\\u0027;\\nimport \\u0027./MerkleProof.sol\\u0027;\\n\\ninterface IGenArt721Minter_DoodleLabs_Config {\\n    function getPurchaseManyLimit(uint256 projectId) external view returns (uint256 limit);\\n\\n    function getState(uint256 projectId) external view returns (uint256 _state);\\n\\n    function setStateFamilyCollectors(uint256 projectId) external;\\n\\n    function setStateRedemption(uint256 projectId) external;\\n\\n    function setStatePublic(uint256 projectId) external;\\n}\\n\\ninterface IGenArt721Minter_DoodleLabs_WhiteList {\\n    function getMerkleRoot(uint256 projectId) external view returns (bytes32 merkleRoot);\\n\\n    function getWhitelisted(uint256 projectId, address user) external view returns (uint256 amount);\\n\\n    function addWhitelist(\\n        uint256 projectId,\\n        address[] calldata users,\\n        uint256[] calldata amounts\\n    ) external;\\n\\n    function increaseAmount(\\n        uint256 projectId,\\n        address to,\\n        uint256 quantity\\n    ) external;\\n}\\n\\ncontract GenArt721Minter_DoodleLabs_Custom_Sale is GenArt721Minter_DoodleLabs_MultiMinter {\\n    using SafeMath for uint256;\\n\\n    event Redeem(uint256 projectId);\\n\\n    // Must match what is on the GenArtMinterV2_State contract\\n    enum SaleState {\\n        FAMILY_COLLECTORS,\\n        REDEMPTION,\\n        PUBLIC\\n    }\\n\\n    IGenArt721Minter_DoodleLabs_WhiteList public activeWhitelist;\\n    IGenArt721Minter_DoodleLabs_Config public minterState;\\n\\n    modifier onlyWhitelisted() {\\n        require(genArtCoreContract.isWhitelisted(msg.sender), \\u0027can only be set by admin\\u0027);\\n        _;\\n    }\\n\\n    modifier notRedemptionState(uint256 projectId) {\\n        require(\\n            uint256(minterState.getState(projectId)) != uint256(SaleState.REDEMPTION),\\n            \\u0027can not purchase in redemption phase\\u0027\\n        );\\n        _;\\n    }\\n\\n    modifier onlyRedemptionState(uint256 projectId) {\\n        require(\\n            uint256(minterState.getState(projectId)) == uint256(SaleState.REDEMPTION),\\n            \\u0027not in redemption phase\\u0027\\n        );\\n        _;\\n    }\\n\\n    constructor(address _genArtCore, address _minterStateAddress)\\n        public\\n        GenArt721Minter_DoodleLabs_MultiMinter(_genArtCore)\\n    {\\n        minterState = IGenArt721Minter_DoodleLabs_Config(_minterStateAddress);\\n    }\\n\\n    function getMerkleRoot(uint256 projectId) public view returns (bytes32 merkleRoot) {\\n        require(address(activeWhitelist) != address(0), \\u0027Active whitelist not set\\u0027);\\n        return activeWhitelist.getMerkleRoot(projectId);\\n    }\\n\\n    function getWhitelisted(uint256 projectId, address user)\\n        external\\n        view\\n        returns (uint256 amount)\\n    {\\n        require(address(activeWhitelist) != address(0), \\u0027Active whitelist not set\\u0027);\\n        return activeWhitelist.getWhitelisted(projectId, user);\\n    }\\n\\n    function setActiveWhitelist(address whitelist) public onlyWhitelisted {\\n        activeWhitelist = IGenArt721Minter_DoodleLabs_WhiteList(whitelist);\\n    }\\n\\n    function purchase(uint256 projectId, uint256 quantity)\\n        public\\n        payable\\n        notRedemptionState(projectId)\\n        returns (uint256[] memory _tokenIds)\\n    {\\n        return purchaseTo(msg.sender, projectId, quantity);\\n    }\\n\\n    function purchaseTo(\\n        address to,\\n        uint256 projectId,\\n        uint256 quantity\\n    ) public payable notRedemptionState(projectId) returns (uint256[] memory _tokenIds) {\\n        require(\\n            quantity \\u003c= minterState.getPurchaseManyLimit(projectId),\\n            \\u0027Max purchase many limit reached\\u0027\\n        );\\n        if (\\n            uint256(minterState.getState(projectId)) == uint256(SaleState.FAMILY_COLLECTORS) \\u0026\\u0026\\n            msg.value \\u003e 0\\n        ) {\\n            require(false, \\u0027ETH not accepted at this time\\u0027);\\n        }\\n        return _purchaseManyTo(to, projectId, quantity);\\n    }\\n\\n    function redeem(\\n        uint256 projectId,\\n        uint256 quantity,\\n        uint256 allottedAmount,\\n        bytes32[] memory proof\\n    ) public payable onlyRedemptionState(projectId) returns (uint256[] memory _tokenIds) {\\n        return redeemTo(msg.sender, projectId, quantity, allottedAmount, proof);\\n    }\\n\\n    function redeemTo(\\n        address to,\\n        uint256 projectId,\\n        uint256 quantity,\\n        uint256 allottedAmount,\\n        bytes32[] memory proof\\n    ) public payable onlyRedemptionState(projectId) returns (uint256[] memory _tokenIds) {\\n        require(address(activeWhitelist) != address(0), \\u0027Active whitelist not set\\u0027);\\n        require(\\n            activeWhitelist.getWhitelisted(projectId, to).add(quantity) \\u003c= allottedAmount,\\n            \\u0027Address has already claimed\\u0027\\n        );\\n\\n        string memory key = _addressToString(to);\\n        key = _appendStrings(key, Strings.toString(allottedAmount), Strings.toString(projectId));\\n\\n        bytes32 leaf = keccak256(abi.encodePacked(key));\\n        require(MerkleProof.verify(proof, getMerkleRoot(projectId), leaf), \\u0027Invalid proof\\u0027);\\n\\n        uint256[] memory createdTokens = _purchaseManyTo(to, projectId, quantity);\\n\\n        activeWhitelist.increaseAmount(projectId, to, quantity);\\n\\n        emit Redeem(projectId);\\n        return createdTokens;\\n    }\\n\\n    function _appendStrings(\\n        string memory a,\\n        string memory b,\\n        string memory c\\n    ) internal pure returns (string memory) {\\n        return string(abi.encodePacked(a, \\u0027::\\u0027, b, \\u0027::\\u0027, c));\\n    }\\n\\n    function _addressToString(address addr) private pure returns (string memory) {\\n        // From: https://www.reddit.com/r/ethdev/comments/qga46a/i_created_a_function_to_convert_address_to_string/\\n        // Cast address to byte array\\n        bytes memory addressBytes = abi.encodePacked(addr);\\n\\n        // Byte array for the new string\\n        bytes memory stringBytes = new bytes(42);\\n\\n        // Assign first two bytes to \\u00270x\\u0027\\n        stringBytes[0] = \\u00270\\u0027;\\n        stringBytes[1] = \\u0027x\\u0027;\\n\\n        // Iterate over every byte in the array\\n        // Each byte contains two hex digits that gets individually converted\\n        // into their ASCII representation and added to the string\\n        for (uint256 i = 0; i \\u003c 20; i++) {\\n            // Convert hex to decimal values\\n            uint8 leftValue = uint8(addressBytes[i]) / 16;\\n            uint8 rightValue = uint8(addressBytes[i]) - 16 * leftValue;\\n\\n            // Convert decimals to ASCII values\\n            bytes1 leftChar = leftValue \\u003c 10 ? bytes1(leftValue + 48) : bytes1(leftValue + 87);\\n            bytes1 rightChar = rightValue \\u003c 10 ? bytes1(rightValue + 48) : bytes1(rightValue + 87);\\n\\n            // Add ASCII values to the string byte array\\n            stringBytes[2 * i + 3] = rightChar;\\n            stringBytes[2 * i + 2] = leftChar;\\n\\n            // console.log(string(stringBytes));\\n        }\\n\\n        // Cast byte array to string and return\\n        return string(stringBytes);\\n    }\\n}\\n\"},\"GenArt721Minter_DoodleLabs_MultiMinter.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\u0027./GenArtMinterV2_DoodleLabs.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\ncontract GenArt721Minter_DoodleLabs_MultiMinter is GenArt721Minter_DoodleLabs {\\n    using SafeMath for uint256;\\n\\n    event PurchaseMany(uint256 projectId, uint256 amount);\\n    event Purchase(uint256 _projectId);\\n\\n    constructor(address _genArtCore) internal GenArt721Minter_DoodleLabs(_genArtCore) {}\\n\\n    function _purchaseManyTo(\\n        address to,\\n        uint256 projectId,\\n        uint256 amount\\n    ) internal returns (uint256[] memory _tokenIds) {\\n        uint256[] memory tokenIds = new uint256[](amount);\\n        bool isDeferredRefund = false;\\n\\n        // Refund ETH if user accidentially overpays\\n        // This is not needed for ERC20 tokens\\n        if (msg.value \\u003e 0) {\\n            uint256 pricePerTokenInWei = genArtCoreContract.projectIdToPricePerTokenInWei(\\n                projectId\\n            );\\n            require(msg.value \\u003e= pricePerTokenInWei.mul(amount), \\u0027not enough funds transferred\\u0027);\\n            uint256 refund = msg.value.sub(pricePerTokenInWei.mul(amount));\\n            isDeferredRefund = true;\\n\\n            if (refund \\u003e 0) {\\n                // address payable _to = payable(to);\\n                address payable _to = address(uint160(to));\\n                _to.transfer(refund);\\n            }\\n        }\\n\\n        for (uint256 i = 0; i \\u003c amount; i++) {\\n            tokenIds[i] = purchaseTo(to, projectId, isDeferredRefund);\\n            emit Purchase(projectId);\\n        }\\n\\n        return tokenIds;\\n    }\\n\\n    function _purchase(uint256 _projectId) internal returns (uint256 _tokenId) {\\n        emit Purchase(_projectId);\\n        return purchaseTo(msg.sender, _projectId, false);\\n    }\\n}\\n\"},\"GenArtMinterV2_DoodleLabs.sol\":{\"content\":\"/**\\n *Submitted for verification at Etherscan.io on 2021-10-21\\n */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./Strings.sol\\u0027;\\nimport \\u0027./ERC20.sol\\u0027;\\nimport \\u0027./IGenArt721CoreV2.sol\\u0027;\\n\\ninterface BonusContract {\\n    function triggerBonus(address _to) external returns (bool);\\n\\n    function bonusIsActive() external view returns (bool);\\n}\\n\\ncontract GenArt721Minter_DoodleLabs {\\n    using SafeMath for uint256;\\n\\n    IGenArt721CoreV2 public genArtCoreContract;\\n\\n    uint256 constant ONE_MILLION = 1_000_000;\\n\\n    address payable public ownerAddress;\\n    uint256 public ownerPercentage;\\n\\n    mapping(uint256 =\\u003e bool) public projectIdToBonus;\\n    mapping(uint256 =\\u003e address) public projectIdToBonusContractAddress;\\n    mapping(uint256 =\\u003e bool) public contractFilterProject;\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public projectMintCounter;\\n    mapping(uint256 =\\u003e uint256) public projectMintLimit;\\n    mapping(uint256 =\\u003e bool) public projectMaxHasBeenInvoked;\\n    mapping(uint256 =\\u003e uint256) public projectMaxInvocations;\\n\\n    constructor(address _genArt721Address) public {\\n        genArtCoreContract = IGenArt721CoreV2(_genArt721Address);\\n    }\\n\\n    function getYourBalanceOfProjectERC20(uint256 _projectId) public view returns (uint256) {\\n        uint256 balance = ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId))\\n            .balanceOf(msg.sender);\\n        return balance;\\n    }\\n\\n    function checkYourAllowanceOfProjectERC20(uint256 _projectId) public view returns (uint256) {\\n        uint256 remaining = ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId))\\n            .allowance(msg.sender, address(this));\\n        return remaining;\\n    }\\n\\n    function setProjectMintLimit(uint256 _projectId, uint8 _limit) public {\\n        require(genArtCoreContract.isWhitelisted(msg.sender), \\u0027can only be set by admin\\u0027);\\n        projectMintLimit[_projectId] = _limit;\\n    }\\n\\n    function setProjectMaxInvocations(uint256 _projectId) public {\\n        require(genArtCoreContract.isWhitelisted(msg.sender), \\u0027can only be set by admin\\u0027);\\n        uint256 maxInvocations;\\n        uint256 invocations;\\n        (, , invocations, maxInvocations, , , , , ) = genArtCoreContract.projectTokenInfo(\\n            _projectId\\n        );\\n        projectMaxInvocations[_projectId] = maxInvocations;\\n        if (invocations \\u003c maxInvocations) {\\n            projectMaxHasBeenInvoked[_projectId] = false;\\n        }\\n    }\\n\\n    function setOwnerAddress(address payable _ownerAddress) public {\\n        require(genArtCoreContract.isWhitelisted(msg.sender), \\u0027can only be set by admin\\u0027);\\n        ownerAddress = _ownerAddress;\\n    }\\n\\n    function setOwnerPercentage(uint256 _ownerPercentage) public {\\n        require(genArtCoreContract.isWhitelisted(msg.sender), \\u0027can only be set by admin\\u0027);\\n        ownerPercentage = _ownerPercentage;\\n    }\\n\\n    function toggleContractFilter(uint256 _projectId) public {\\n        require(genArtCoreContract.isWhitelisted(msg.sender), \\u0027can only be set by admin\\u0027);\\n        contractFilterProject[_projectId] = !contractFilterProject[_projectId];\\n    }\\n\\n    function artistToggleBonus(uint256 _projectId) public {\\n        require(\\n            msg.sender == genArtCoreContract.projectIdToArtistAddress(_projectId),\\n            \\u0027can only be set by artist\\u0027\\n        );\\n        projectIdToBonus[_projectId] = !projectIdToBonus[_projectId];\\n    }\\n\\n    function artistSetBonusContractAddress(uint256 _projectId, address _bonusContractAddress)\\n        public\\n    {\\n        require(\\n            msg.sender == genArtCoreContract.projectIdToArtistAddress(_projectId),\\n            \\u0027can only be set by artist\\u0027\\n        );\\n        projectIdToBonusContractAddress[_projectId] = _bonusContractAddress;\\n    }\\n\\n    function purchase(uint256 _projectId) internal returns (uint256 _tokenId) {\\n        return purchaseTo(msg.sender, _projectId, false);\\n    }\\n\\n    // Remove `public`` and `payable`` to prevent public use\\n    // of the `purchaseTo`` function.\\n    function purchaseTo(\\n        address _to,\\n        uint256 _projectId,\\n        bool _isDeferredRefund\\n    ) internal returns (uint256 _tokenId) {\\n        require(!projectMaxHasBeenInvoked[_projectId], \\u0027Maximum number of invocations reached\\u0027);\\n        if (\\n            keccak256(abi.encodePacked(genArtCoreContract.projectIdToCurrencySymbol(_projectId))) !=\\n            keccak256(abi.encodePacked(\\u0027ETH\\u0027))\\n        ) {\\n            require(\\n                msg.value == 0,\\n                \\u0027this project accepts a different currency and cannot accept ETH\\u0027\\n            );\\n            require(\\n                ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).allowance(\\n                    msg.sender,\\n                    address(this)\\n                ) \\u003e= genArtCoreContract.projectIdToPricePerTokenInWei(_projectId),\\n                \\u0027Insufficient Funds Approved for TX\\u0027\\n            );\\n            require(\\n                ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).balanceOf(\\n                    msg.sender\\n                ) \\u003e= genArtCoreContract.projectIdToPricePerTokenInWei(_projectId),\\n                \\u0027Insufficient balance.\\u0027\\n            );\\n            _splitFundsERC20(_projectId);\\n        } else {\\n            require(\\n                msg.value \\u003e= genArtCoreContract.projectIdToPricePerTokenInWei(_projectId),\\n                \\u0027Must send minimum value to mint!\\u0027\\n            );\\n            _splitFundsETH(_projectId, _isDeferredRefund);\\n        }\\n\\n        // if contract filter is active prevent calls from another contract\\n        if (contractFilterProject[_projectId]) require(msg.sender == tx.origin, \\u0027No Contract Buys\\u0027);\\n\\n        // limit mints per address by project\\n        if (projectMintLimit[_projectId] \\u003e 0) {\\n            require(\\n                projectMintCounter[msg.sender][_projectId] \\u003c projectMintLimit[_projectId],\\n                \\u0027Reached minting limit\\u0027\\n            );\\n            projectMintCounter[msg.sender][_projectId]++;\\n        }\\n\\n        uint256 tokenId = genArtCoreContract.mint(_to, _projectId, msg.sender);\\n\\n        // What if this overflows, since default value of uint256 is 0?\\n        // That is intended, so that by default the minter allows infinite\\n        // transactions, allowing the `genArtCoreContract` to stop minting\\n        // `uint256 tokenInvocation = tokenId % ONE_MILLION;`\\n        if (tokenId % ONE_MILLION == projectMaxInvocations[_projectId] - 1) {\\n            projectMaxHasBeenInvoked[_projectId] = true;\\n        }\\n\\n        if (projectIdToBonus[_projectId]) {\\n            require(\\n                BonusContract(projectIdToBonusContractAddress[_projectId]).bonusIsActive(),\\n                \\u0027bonus must be active\\u0027\\n            );\\n            BonusContract(projectIdToBonusContractAddress[_projectId]).triggerBonus(msg.sender);\\n        }\\n\\n        return tokenId;\\n    }\\n\\n    function _splitFundsETH(uint256 _projectId, bool _isDeferredRefund) internal {\\n        if (msg.value \\u003e 0) {\\n            uint256 pricePerTokenInWei = genArtCoreContract.projectIdToPricePerTokenInWei(\\n                _projectId\\n            );\\n            uint256 refund = msg.value.sub(\\n                genArtCoreContract.projectIdToPricePerTokenInWei(_projectId)\\n            );\\n            if (!_isDeferredRefund \\u0026\\u0026 refund \\u003e 0) {\\n                msg.sender.transfer(refund);\\n            }\\n            uint256 renderProviderAmount = pricePerTokenInWei.div(100).mul(\\n                genArtCoreContract.renderProviderPercentage()\\n            );\\n            if (renderProviderAmount \\u003e 0) {\\n                genArtCoreContract.renderProviderAddress().transfer(renderProviderAmount);\\n            }\\n\\n            uint256 remainingFunds = pricePerTokenInWei.sub(renderProviderAmount);\\n\\n            uint256 ownerFunds = remainingFunds.div(100).mul(ownerPercentage);\\n            if (ownerFunds \\u003e 0) {\\n                ownerAddress.transfer(ownerFunds);\\n            }\\n\\n            uint256 projectFunds = pricePerTokenInWei.sub(renderProviderAmount).sub(ownerFunds);\\n            uint256 additionalPayeeAmount;\\n            if (genArtCoreContract.projectIdToAdditionalPayeePercentage(_projectId) \\u003e 0) {\\n                additionalPayeeAmount = projectFunds.div(100).mul(\\n                    genArtCoreContract.projectIdToAdditionalPayeePercentage(_projectId)\\n                );\\n                if (additionalPayeeAmount \\u003e 0) {\\n                    genArtCoreContract.projectIdToAdditionalPayee(_projectId).transfer(\\n                        additionalPayeeAmount\\n                    );\\n                }\\n            }\\n            uint256 creatorFunds = projectFunds.sub(additionalPayeeAmount);\\n            if (creatorFunds \\u003e 0) {\\n                genArtCoreContract.projectIdToArtistAddress(_projectId).transfer(creatorFunds);\\n            }\\n        }\\n    }\\n\\n    function _splitFundsERC20(uint256 _projectId) internal {\\n        uint256 pricePerTokenInWei = genArtCoreContract.projectIdToPricePerTokenInWei(_projectId);\\n        uint256 renderProviderAmount = pricePerTokenInWei.div(100).mul(\\n            genArtCoreContract.renderProviderPercentage()\\n        );\\n        if (renderProviderAmount \\u003e 0) {\\n            ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).transferFrom(\\n                msg.sender,\\n                genArtCoreContract.renderProviderAddress(),\\n                renderProviderAmount\\n            );\\n        }\\n        uint256 remainingFunds = pricePerTokenInWei.sub(renderProviderAmount);\\n\\n        uint256 ownerFunds = remainingFunds.div(100).mul(ownerPercentage);\\n        if (ownerFunds \\u003e 0) {\\n            ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).transferFrom(\\n                msg.sender,\\n                ownerAddress,\\n                ownerFunds\\n            );\\n        }\\n\\n        uint256 projectFunds = pricePerTokenInWei.sub(renderProviderAmount).sub(ownerFunds);\\n        uint256 additionalPayeeAmount;\\n        if (genArtCoreContract.projectIdToAdditionalPayeePercentage(_projectId) \\u003e 0) {\\n            additionalPayeeAmount = projectFunds.div(100).mul(\\n                genArtCoreContract.projectIdToAdditionalPayeePercentage(_projectId)\\n            );\\n            if (additionalPayeeAmount \\u003e 0) {\\n                ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).transferFrom(\\n                    msg.sender,\\n                    genArtCoreContract.projectIdToAdditionalPayee(_projectId),\\n                    additionalPayeeAmount\\n                );\\n            }\\n        }\\n        uint256 creatorFunds = projectFunds.sub(additionalPayeeAmount);\\n        if (creatorFunds \\u003e 0) {\\n            ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).transferFrom(\\n                msg.sender,\\n                genArtCoreContract.projectIdToArtistAddress(_projectId),\\n                creatorFunds\\n            );\\n        }\\n    }\\n}\\n\"},\"IERC165.sol\":{\"content\":\"// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\\npragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others (`ERC165Checker`).\\n *\\n * For an implementation, see `ERC165`.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\\npragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IERC721.sol\":{\"content\":\"// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\\n\\npragma solidity ^0.5.0;\\n\\nimport \\u0027./IERC165.sol\\u0027;\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ncontract IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of NFTs in `owner`\\u0027s account.\\n     */\\n    function balanceOf(address owner) public view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the NFT specified by `tokenId`.\\n     */\\n    function ownerOf(uint256 tokenId) public view returns (address owner);\\n\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     *\\n     *\\n     * Requirements:\\n     * - `from`, `to` cannot be zero.\\n     * - `tokenId` must be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this\\n     * NFT by either `approve` or `setApproveForAll`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public;\\n\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Requirements:\\n     * - If the caller is not `from`, it must be approved to move this NFT by\\n     * either `approve` or `setApproveForAll`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public;\\n\\n    function approve(address to, uint256 tokenId) public;\\n\\n    function getApproved(uint256 tokenId) public view returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) public;\\n\\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public;\\n}\\n\"},\"IERC721Enumerable.sol\":{\"content\":\"// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol\\n\\npragma solidity ^0.5.0;\\n\\nimport \\u0027./IERC721.sol\\u0027;\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract IERC721Enumerable is IERC721 {\\n    function totalSupply() public view returns (uint256);\\n\\n    function tokenOfOwnerByIndex(address owner, uint256 index)\\n        public\\n        view\\n        returns (uint256 tokenId);\\n\\n    function tokenByIndex(uint256 index) public view returns (uint256);\\n}\\n\"},\"IERC721Receiver.sol\":{\"content\":\"// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\\n\\npragma solidity ^0.5.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ncontract IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public returns (bytes4);\\n}\\n\"},\"IGenArt721CoreV2.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\ninterface IGenArt721CoreV2 {\\n    function isWhitelisted(address sender) external view returns (bool);\\n\\n    function admin() external view returns (address);\\n\\n    function projectIdToCurrencySymbol(uint256 _projectId) external view returns (string memory);\\n\\n    function projectIdToCurrencyAddress(uint256 _projectId) external view returns (address);\\n\\n    function projectIdToArtistAddress(uint256 _projectId) external view returns (address payable);\\n\\n    function projectIdToPricePerTokenInWei(uint256 _projectId) external view returns (uint256);\\n\\n    function projectIdToAdditionalPayee(uint256 _projectId) external view returns (address payable);\\n\\n    function projectIdToAdditionalPayeePercentage(uint256 _projectId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function projectTokenInfo(uint256 _projectId)\\n        external\\n        view\\n        returns (\\n            address,\\n            uint256,\\n            uint256,\\n            uint256,\\n            bool,\\n            address,\\n            uint256,\\n            string memory,\\n            address\\n        );\\n\\n    function renderProviderAddress() external view returns (address payable);\\n\\n    function renderProviderPercentage() external view returns (uint256);\\n\\n    function mint(\\n        address _to,\\n        uint256 _projectId,\\n        address _by\\n    ) external returns (uint256 tokenId);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    function tokenIdToProjectId(uint256 tokenId) external view returns (uint256);\\n}\\n\"},\"MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.5.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs \\u0026 pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i \\u003c proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash \\u003c= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = _efficientHash(computedHash, proofElement);\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = _efficientHash(proofElement, computedHash);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\"},\"Randomizer.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\ncontract Randomizer {\\n    function returnValue() public view returns (bytes32) {\\n        uint256 time = block.timestamp;\\n        uint256 extra = (time % 200) + 1;\\n\\n        return keccak256(abi.encodePacked(block.number, blockhash(block.number - 2), time, extra));\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.4.0/contracts/math/SafeMath.sol\\npragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\u0027SafeMath: addition overflow\\u0027);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\u0027SafeMath: subtraction overflow\\u0027);\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\u0027SafeMath: multiplication overflow\\u0027);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\u0027SafeMath: division by zero\\u0027);\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\u0027SafeMath: modulo by zero\\u0027);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"Strings.sol\":{\"content\":\"// File: contracts/Strings.sol\\n\\npragma solidity ^0.5.0;\\n\\n//https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\\nlibrary Strings {\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function strConcat(string memory _a, string memory _b)\\n        internal\\n        pure\\n        returns (string memory _concatenatedString)\\n    {\\n        return strConcat(_a, _b, \\u0027\\u0027, \\u0027\\u0027, \\u0027\\u0027);\\n    }\\n\\n    function strConcat(\\n        string memory _a,\\n        string memory _b,\\n        string memory _c\\n    ) internal pure returns (string memory _concatenatedString) {\\n        return strConcat(_a, _b, _c, \\u0027\\u0027, \\u0027\\u0027);\\n    }\\n\\n    function strConcat(\\n        string memory _a,\\n        string memory _b,\\n        string memory _c,\\n        string memory _d\\n    ) internal pure returns (string memory _concatenatedString) {\\n        return strConcat(_a, _b, _c, _d, \\u0027\\u0027);\\n    }\\n\\n    function strConcat(\\n        string memory _a,\\n        string memory _b,\\n        string memory _c,\\n        string memory _d,\\n        string memory _e\\n    ) internal pure returns (string memory _concatenatedString) {\\n        bytes memory _ba = bytes(_a);\\n        bytes memory _bb = bytes(_b);\\n        bytes memory _bc = bytes(_c);\\n        bytes memory _bd = bytes(_d);\\n        bytes memory _be = bytes(_e);\\n        string memory abcde = new string(\\n            _ba.length + _bb.length + _bc.length + _bd.length + _be.length\\n        );\\n        bytes memory babcde = bytes(abcde);\\n        uint256 k = 0;\\n        uint256 i = 0;\\n        for (i = 0; i \\u003c _ba.length; i++) {\\n            babcde[k++] = _ba[i];\\n        }\\n        for (i = 0; i \\u003c _bb.length; i++) {\\n            babcde[k++] = _bb[i];\\n        }\\n        for (i = 0; i \\u003c _bc.length; i++) {\\n            babcde[k++] = _bc[i];\\n        }\\n        for (i = 0; i \\u003c _bd.length; i++) {\\n            babcde[k++] = _bd[i];\\n        }\\n        for (i = 0; i \\u003c _be.length; i++) {\\n            babcde[k++] = _be[i];\\n        }\\n        return string(babcde);\\n    }\\n\\n    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\\n        if (_i == 0) {\\n            return \\u00270\\u0027;\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len - 1;\\n        while (_i != 0) {\\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n}\\n\"}}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"getMerkleRoot\",\"outputs\":[{\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"whitelist\",\"type\":\"address\"}],\"name\":\"setActiveWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"projectId\",\"type\":\"uint256\"},{\"name\":\"quantity\",\"type\":\"uint256\"},{\"name\":\"allottedAmount\",\"type\":\"uint256\"},{\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"redeem\",\"outputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"projectId\",\"type\":\"uint256\"},{\"name\":\"quantity\",\"type\":\"uint256\"},{\"name\":\"allottedAmount\",\"type\":\"uint256\"},{\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"redeemTo\",\"outputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_projectId\",\"type\":\"uint256\"},{\"name\":\"_limit\",\"type\":\"uint8\"}],\"name\":\"setProjectMintLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"projectId\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getWhitelisted\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"name\":\"setOwnerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ownerPercentage\",\"type\":\"uint256\"}],\"name\":\"setOwnerPercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"projectMintCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_projectId\",\"type\":\"uint256\"},{\"name\":\"_bonusContractAddress\",\"type\":\"address\"}],\"name\":\"artistSetBonusContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"projectMaxHasBeenInvoked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"projectMaxInvocations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"toggleContractFilter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"projectMintLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"projectId\",\"type\":\"uint256\"},{\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"projectIdToBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"projectIdToBonusContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"genArtCoreContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activeWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"artistToggleBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"projectId\",\"type\":\"uint256\"},{\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"purchaseTo\",\"outputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"getYourBalanceOfProjectERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minterState\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"checkYourAllowanceOfProjectERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"setProjectMaxInvocations\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contractFilterProject\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_genArtCore\",\"type\":\"address\"},{\"name\":\"_minterStateAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PurchaseMany\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"type\":\"event\"}]", "ContractName": "GenArt721Minter_DoodleLabs_Custom_Sale", "CompilerVersion": "v0.5.0+commit.1d4f565a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000028f2d3805652fb5d359486dffb7d08320d4032400000000000000000000000005292970db5d37ca4d269ae1c12953b266aa97381", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://120f13757f5b94fb335dcec02f41b30a06789404d87422fb2cc33eadb2e3da91"}]}