{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/OlympusPro.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"./types/Pro/MarketCreator.sol\\\";\\nimport \\\"./types/Pro/NoteKeeper.sol\\\";\\nimport \\\"./types/Pro/Rewarder.sol\\\";\\nimport \\\"./types/Pro/Viewer.sol\\\";\\n\\nimport \\\"./libraries/SafeERC20.sol\\\";\\n\\nimport \\\"./interfaces/IERC20Metadata.sol\\\";\\nimport \\\"./interfaces/IOlympusPro.sol\\\";\\nimport \\\"./interfaces/IProCall.sol\\\";\\n\\n/// @title Olympus Pro Depository V2\\n/// @author Zeus, Indigo\\n/// Review by: JeffX\\n\\ncontract OlympusProV2 is ProMarketCreator, ProViewer, ProNoteKeeper, ProRewarder {\\n\\n  using SafeERC20 for IERC20;\\n\\n  event Bond(uint256 indexed id, uint256 amount, uint256 price);\\n  event Tuned(uint256 indexed id, uint256 oldControlVariable, uint256 newControlVariable);\\n\\n  constructor(address _authority) \\n    ProMarketCreator()\\n    ProViewer()\\n    ProNoteKeeper() \\n    ProRewarder(IOlympusAuthority(_authority))\\n  {}  \\n\\n/* ========== EXTERNAL ========== */\\n\\n  /**\\n   * @notice             deposit quote tokens in exchange for a bond in a specified market\\n   * @param _amounts     [amount in, min amount out]\\n   * @param _addresses   [recipient, referrer]\\n   */\\n  function deposit(\\n    uint48 _id,\\n    uint256[2] memory _amounts,\\n    address[2] memory _addresses\\n  ) external returns (\\n    uint256 payout_,\\n    uint256 expiry_,\\n    uint256 index_\\n  ) {\\n    Market storage market = markets[_id];\\n    Terms memory term = terms[_id];\\n    uint48 currentTime = uint48(block.timestamp);\\n    address sendTo; // receives base tokens at time of deposit\\n    uint256 price = _decayAndGetPrice(_id, currentTime); // Debt and the control variable decay over time\\n\\n    // Markets end at a defined timestamp\\n    require(currentTime < term.conclusion, \\\"Depository: market concluded\\\");\\n\\n    /**\\n     * payout for the deposit = amount / price\\n     *\\n     * where\\n     * payout = base tokens out\\n     * amount = quote tokens in\\n     * price = quote tokens : base token (i.e. 200 QUOTE : BASE)\\n     */\\n    payout_ = _amounts[0]\\n      * (10 ** (2 * metadata[_id].baseDecimals))\\n      / price\\n      / (10 ** metadata[_id].quoteDecimals);\\n\\n    // markets have a max payout amount, capping size because deposits\\n    // do not experience slippage. max payout is recalculated upon tuning\\n    require(payout_ <= market.maxPayout, \\\"Depository: max size exceeded\\\");\\n\\n    // payout must be greater than user inputted minimum\\n    require(payout_ >= _amounts[1], \\\"Depository: Less than min out\\\");\\n\\n    // if there is no vesting time, the deposit is treated as an instant swap.\\n    // in this case, the recipient (_address[0]) receives the payout immediately.\\n    // otherwise, deposit info is stored and payout is available at a future timestamp.\\n    if ((term.fixedTerm && term.vesting == 0) || (!term.fixedTerm && term.vesting <= block.timestamp)) {\\n      // instant swap case\\n      sendTo = _addresses[0];\\n\\n      // Note zero expiry denotes an instant swap in return values\\n      expiry_ = 0;\\n\\n    } else {\\n      // vested swap case\\n      sendTo = address(vestingContract);\\n\\n      // we have to store info about their deposit\\n\\n      /**\\n       * bonds mature with a cliff at a set timestamp\\n       * prior to the expiry timestamp, no payout tokens are accessible to the user\\n       * after the expiry timestamp, the entire payout can be redeemed\\n       *\\n       * there are two types of bonds: fixed-term and fixed-expiration\\n       *\\n       * fixed-term bonds mature in a set amount of time from deposit\\n       * i.e. term = 1 week. when alice deposits on day 1, her bond\\n       * expires on day 8. when bob deposits on day 2, his bond expires day 9.\\n       *\\n       * fixed-expiration bonds mature at a set timestamp\\n       * i.e. expiration = day 10. when alice deposits on day 1, her term\\n       * is 9 days. when bob deposits on day 2, his term is 8 days.\\n       */\\n      expiry_ = term.fixedTerm\\n        ? term.vesting + currentTime\\n        : term.vesting;\\n\\n      // the index of the note is the next in the user's array\\n      index_ = notes[_addresses[0]].length;\\n\\n      /**\\n       * user data is stored as Notes. these are isolated array entries\\n       * storing the amount due, the time created, the time when payout\\n       * is redeemable, the time when payout was redeemed, the ID\\n       * of the market deposited into, and the payout (quote) token.\\n       */\\n      notes[_addresses[0]].push(\\n        Note({\\n          payout: payout_,\\n          created: uint48(block.timestamp),\\n          matured: uint48(expiry_),\\n          redeemed: 0,\\n          marketID: uint48(_id),\\n          token: address(market.baseToken)\\n        })\\n      );\\n    }\\n\\n    /*\\n     * capacity is either the number of base tokens that the market can sell\\n     * (if capacity in quote is false), \\n     *\\n     * or the number of quote tokens that the market can buy\\n     * (if capacity in quote is true)\\n     */\\n    \\n    // capacity is decreased by the deposited or paid amount\\n    market.capacity -= market.capacityInQuote\\n      ? _amounts[0]\\n      : payout_;\\n\\n    // markets keep track of how many quote tokens have been\\n    // purchased, and how many base tokens have been sold\\n    market.purchased += _amounts[0];\\n    market.sold += payout_;\\n\\n    // incrementing total debt raises the price of the next bond\\n    market.totalDebt += payout_;\\n\\n    emit Bond(_id, _amounts[0], price);\\n\\n    // if max debt is breached, the market is closed\\n    // this a circuit breaker\\n    if (term.maxDebt < market.totalDebt) {\\n        market.capacity = 0;\\n        emit CloseMarket(_id);\\n    } else {\\n      // if market will continue, the control variable is tuned to hit targets on time\\n      _tune(_id, currentTime, price); // TODO\\n    }\\n\\n    // give fees, and transfer in base tokens from creator\\n    _getBaseTokens(market.call, _id, _amounts[0], payout_, _addresses[1]);\\n\\n    // if instant swap, send payout to recipient. otherwise, sent to vesting\\n    markets[_id].baseToken.safeTransfer(sendTo, payout_);\\n\\n    // transfer payment to creator\\n    markets[_id].quoteToken.safeTransferFrom(msg.sender, markets[_id].creator, _amounts[0]);\\n  }\\n\\n/* ========== INTERNAL ========== */\\n\\n  /**\\n   * @notice             calculate current market price of base token in quote tokens\\n   * @dev                see marketPrice() for explanation of price computation\\n   * @dev                uses info from storage because data has been updated before call (vs marketPrice())\\n   * @param _id          market ID\\n   * @return             price for market in base token decimals\\n   */ \\n  function _marketPrice(uint256 _id) internal view returns (uint256) {\\n    return \\n      terms[_id].controlVariable \\n      * markets[_id].totalDebt\\n      / 10 ** metadata[_id].baseDecimals;\\n  }\\n\\n  /**\\n   * @notice             decay debt, and adjust control variable if there is an active change\\n   * @param _id          ID of market\\n   * @param _time        uint48 timestamp (saves gas when passed in)\\n   */\\n  function _decayAndGetPrice(uint256 _id, uint48 _time) internal returns (uint256 marketPrice_) {\\n\\n    // Debt decay\\n\\n    /*\\n     * Debt is a time-decayed sum of tokens spent in a market\\n     * Debt is added when deposits occur and removed over time\\n     * |\\n     * |    debt falls with\\n     * |   / \\\\  inactivity       / \\\\\\n     * | /     \\\\              /\\\\/    \\\\\\n     * |         \\\\           /         \\\\\\n     * |           \\\\      /\\\\/            \\\\\\n     * |             \\\\  /  and rises       \\\\\\n     * |                with deposits\\n     * |\\n     * |------------------------------------| t\\n     */\\n    markets[_id].totalDebt -= _debtDecay(_id);\\n    metadata[_id].lastDecay = _time;\\n\\n\\n    // Control variable decay\\n\\n    // The bond control variable is continually tuned. When it is lowered (which\\n    // lowers the market price), the change is carried out smoothly over time.\\n    if (adjustments[_id].active) {\\n      Adjustment storage adjustment = adjustments[_id];\\n\\n      (uint256 adjustBy, uint48 secondsSince, bool stillActive) = _controlDecay(_id); // implementation in ProViewer\\n      terms[_id].controlVariable -= adjustBy;\\n\\n      if (stillActive) {\\n        adjustment.change -= uint128(adjustBy);\\n        adjustment.timeToAdjusted -= secondsSince;\\n        adjustment.lastAdjustment = _time;\\n      } else {\\n        adjustment.active = false;\\n      }\\n    }\\n\\n    // a minimum price is maintained by raising debt back up if price has fallen below.\\n    marketPrice_ = _marketPrice(_id);\\n    uint256 minPrice = markets[_id].minPrice;\\n    if (marketPrice_ < minPrice) {\\n      markets[_id].totalDebt = markets[_id].totalDebt * minPrice / marketPrice_;\\n      marketPrice_ = minPrice;\\n    } \\n  }\\n\\n  /**\\n   * @notice             auto-adjust control variable to hit capacity/spend target\\n   * @param _id          ID of market\\n   * @param _time        uint48 timestamp (saves gas when passed in)\\n   */\\n  function _tune(uint256 _id, uint48 _time, uint256 _price) internal {\\n    Metadata memory meta = metadata[_id];\\n\\n    if (_time >= meta.lastTune + meta.tuneInterval) {\\n      Market memory market = markets[_id];\\n      \\n      // compute seconds remaining until market will conclude\\n      uint256 timeRemaining = terms[_id].conclusion - _time;\\n\\n      // standardize capacity into an base token amount\\n      uint256 capacity = market.capacityInQuote\\n        ? (market.capacity * (10 ** (2 * meta.baseDecimals)) / _price) / (10 ** meta.quoteDecimals)\\n        : market.capacity;\\n\\n      /**\\n       * calculate the correct payout to complete on time assuming each bond\\n       * will be max size in the desired deposit interval for the remaining time\\n       *\\n       * i.e. market has 10 days remaining. deposit interval is 1 day. capacity\\n       * is 10,000 TOKEN. max payout would be 1,000 TOKEN (10,000 * 1 / 10).\\n       */  \\n      markets[_id].maxPayout = capacity * meta.depositInterval / timeRemaining;\\n\\n      // calculate the ideal total debt to satisfy capacity in the remaining time\\n      uint256 targetDebt = capacity * meta.length / timeRemaining;\\n\\n      // derive a new control variable from the target deb\\n      uint256 newControlVariable = _price * (10 ** meta.baseDecimals) / targetDebt;\\n\\n      emit Tuned(_id, terms[_id].controlVariable, newControlVariable);\\n\\n      if (newControlVariable >= terms[_id].controlVariable) {\\n        terms[_id].controlVariable = newControlVariable;\\n      } else {\\n        // if decrease, control variable change will be carried out over the tune interval\\n        // this is because price will be lowered\\n        uint256 change = terms[_id].controlVariable - newControlVariable;\\n        adjustments[_id] = Adjustment(uint128(change), _time, meta.tuneInterval, true);\\n      }\\n      metadata[_id].lastTune = _time;\\n    }\\n  }\\n\\n  function _getBaseTokens(bool _call, uint48 _id, uint256 _amount, uint256 _payout, address _referrer) internal {\\n    IERC20 baseToken = markets[_id].baseToken;\\n\\n    /**\\n     * front end operators can earn rewards by referring users\\n     * transfers in reward amount to this contract (must be separate\\n     * transfer because payout may be sent directly to _address[0])\\n     */ \\n    uint256 fee = _giveRewards(baseToken, _payout, _referrer);\\n\\n    /**\\n     * instead of basic transferFrom, creator can be called. useful if creator \\n     * i.e. mints the tokens, or wants custom logic blocking transactions. \\n     * the balance of the correct recipient must be increased by the payout amount. \\n     * note that call could reenter, so this is done second to last, followed only by paying creator.\\n     */ \\n    if (_call) { \\n      uint256 balance = baseToken.balanceOf(address(this));\\n      IProCall(markets[_id].creator).call(_id, _amount, _payout + fee); \\n      require(baseToken.balanceOf(address(this)) >= balance + _payout + fee, \\\"Depository: not funded\\\");\\n\\n    // default is to simply transfer tokens in. make sure creator has approved this address.\\n    } else baseToken.safeTransferFrom(markets[_id].creator, address(this), _payout + fee);\\n  }\\n\\n  /**\\n   * @notice             amount of debt to decay from total debt for market ID\\n   * @param _id          ID of market\\n   * @return             amount of debt to decay\\n   */\\n  function _debtDecay(uint256 _id) internal view returns (uint256) {\\n    Metadata memory meta = metadata[_id];\\n\\n    uint256 secondsSince = block.timestamp - meta.lastDecay;\\n\\n    return markets[_id].totalDebt * secondsSince / meta.length;\\n  }\\n}\"\r\n    },\r\n    \"contracts/types/Pro/MarketCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport \\\"../../interfaces/IERC20Metadata.sol\\\";\\nimport \\\"../../interfaces/IProMarketCreator.sol\\\";\\n\\nabstract contract ProMarketCreator is IProMarketCreator {\\n\\n/* ========== EVENTS ========== */\\n\\n  event CreateMarket(uint256 indexed id, address baseToken, address quoteToken, uint256 initialPrice, uint256 conclusion);\\n  event CloseMarket(uint256 indexed id);\\n\\n/* ========== STATE VARIABLES ========== */\\n\\n  // Markets\\n  Market[] public markets; // persistent market data\\n  Terms[] public terms; // deposit construction data\\n  Metadata[] public metadata; // extraneous market data\\n  mapping(uint256 => Adjustment) public adjustments; // control variable changes\\n\\n  // Queries\\n  mapping(address => uint256[]) public marketsForBase; // market IDs for base token\\n  mapping(address => uint256[]) public marketsForQuote; // market IDs for quote token\\n  mapping(address => uint256[]) public marketsForCreator; // market IDs for market creator\\n\\n/* ========== CREATE ========== */\\n\\n  /**\\n   * @notice             creates a new market type\\n   * @dev                current price should be in base token decimals.\\n   * @param _tokens      [base token for payout, quote token used to deposit]\\n   * @param _market      [capacity (in base or quote), initial price / base, minimum price, debt buffer (3 decimals)]\\n   * @param _booleans    [capacity in quote, fixed term, call]\\n   * @param _terms       [vesting length (if fixed term) or vested timestamp, conclusion timestamp]\\n   * @param _intervals   [deposit interval (seconds), tune interval (seconds)]\\n   * @return id_         ID of new bond market\\n   */\\n  function create(\\n    IERC20[2] memory _tokens,\\n    uint256[4] memory _market,\\n    bool[2] memory _booleans,\\n    uint256[2] memory _terms,\\n    uint32[2] memory _intervals\\n  ) external override returns (uint256 id_) {\\n    require(_market[1] >= _market[2], \\\"Creator: min price must be > initial\\\");\\n\\n    // depositing into, or getting info for, the created market uses this ID\\n    id_ = markets.length;\\n\\n    marketsForBase[address(_tokens[0])].push(id_);\\n    marketsForQuote[address(_tokens[1])].push(id_);\\n    marketsForCreator[msg.sender].push(id_);\\n\\n    emit CreateMarket(id_, address(_tokens[0]), address(_tokens[1]), _market[1], _terms[1]);\\n\\n    // the length of the program, in seconds\\n    uint256 secondsToConclusion = _terms[1] - block.timestamp;\\n\\n    // the decimal count of the base and quote token\\n    uint256 baseDecimals = IERC20Metadata(address(_tokens[0])).decimals();\\n    uint256 quoteDecimals = IERC20Metadata(address(_tokens[1])).decimals();\\n\\n    metadata.push(Metadata({\\n      lastTune: uint48(block.timestamp),\\n      lastDecay: uint48(block.timestamp),\\n      length: uint48(secondsToConclusion),\\n      depositInterval: _intervals[0],\\n      tuneInterval: _intervals[1],\\n      baseDecimals: uint8(baseDecimals),\\n      quoteDecimals: uint8(quoteDecimals)\\n    }));\\n\\n    /* \\n     * initial target debt is equal to capacity (this is the amount of debt\\n     * that will decay over in the length of the program if price remains the same).\\n     * it is converted into base token terms if passed in in quote token terms.\\n     */\\n    uint256 targetDebt = _booleans[0]\\n      ? (_market[0] * (10 ** (2 * baseDecimals)) / _market[1]) / 10 ** quoteDecimals\\n      : _market[0];\\n\\n    /*\\n     * max payout is the amount of capacity that should be utilized in a deposit\\n     * interval. for example, if capacity is 1,000 TOKEN, there are 10 days to conclusion, \\n     * and the preferred deposit interval is 1 day, max payout would be 100 TOKEN.\\n     */\\n    uint256 maxPayout = targetDebt * _intervals[0] / secondsToConclusion;\\n\\n    markets.push(Market({\\n      creator: msg.sender,\\n      baseToken: _tokens[0],\\n      quoteToken: _tokens[1],\\n      call: false,\\n      capacityInQuote: _booleans[0],\\n      capacity: _market[0],\\n      totalDebt: targetDebt, \\n      minPrice: _market[2],\\n      maxPayout: maxPayout,\\n      purchased: 0,\\n      sold: 0\\n    }));\\n\\n    /*\\n     * max debt serves as a circuit breaker for the market. let's say the quote\\n     * token is a stablecoin, and that stablecoin depegs. without max debt, the\\n     * market would continue to buy until it runs out of capacity. this is\\n     * configurable with a 3 decimal buffer (1000 = 1% above initial price).\\n     * note that its likely advisable to keep this buffer wide.\\n     * note that the buffer is above 100%. i.e. 10% buffer = initial debt * 1.1\\n     */\\n    uint256 maxDebt = targetDebt + (targetDebt * _market[3] / 1e5); // 1e5 = 100,000. 10,000 / 100,000 = 10%.\\n\\n    /*\\n     * the control variable is set so that initial price equals the desired\\n     * initial price. the control variable is the ultimate determinant of price,\\n     * so we compute this last.\\n     *\\n     * price = control variable * debt ratio\\n     * debt ratio = total debt / supply\\n     * therefore, control variable = price / debt ratio\\n     */\\n    uint256 controlVariable = _market[1] * (10 ** baseDecimals) / targetDebt;\\n\\n    terms.push(Terms({\\n      fixedTerm: _booleans[1], \\n      controlVariable: controlVariable,\\n      vesting: uint48(_terms[0]), \\n      conclusion: uint48(_terms[1]), \\n      maxDebt: maxDebt\\n    }));\\n  }\\n\\n/* ========== CLOSE ========== */\\n\\n  /**\\n   * @notice             disable existing market\\n   * @notice             must be creator\\n   * @param _id          ID of market to close\\n   */\\n  function close(uint256 _id) external override {\\n    require(msg.sender == markets[_id].creator, \\\"Only creator\\\");\\n    terms[_id].conclusion = uint48(block.timestamp);\\n    markets[_id].capacity = 0;\\n    emit CloseMarket(_id);\\n  }\\n}\"\r\n    },\r\n    \"contracts/types/Pro/NoteKeeper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport \\\"../../interfaces/IProNoteKeeper.sol\\\";\\n\\ncontract ProVesting {\\n    address internal immutable depository;\\n    \\n    constructor() {\\n      depository = msg.sender;\\n    }\\n\\n    function transfer(address token, address to, uint256 amount) external {\\n        require(msg.sender == depository, \\\"Vesting: Only depository\\\");\\n        IERC20(token).transfer(to, amount);\\n    }\\n}\\n\\ninterface IVesting {\\n  function transfer(address token, address to, uint256 amount) external;\\n}\\n\\nabstract contract ProNoteKeeper is IProNoteKeeper {\\n\\n  mapping(address => Note[]) public notes; // user deposit data\\n  mapping(address => mapping(uint256 => address)) private noteTransfers; // change note ownership\\n\\n  IVesting public immutable vestingContract;\\n\\n  constructor () {\\n    vestingContract = IVesting(address(new ProVesting()));\\n  }\\n\\n/* ========== REDEEM ========== */\\n\\n  /**\\n   * @notice             redeem notes for user\\n   * @param _user        the user to redeem for\\n   * @param _indexes     the note indexes to redeem\\n   */\\n  function redeem(address _user, uint256[] memory _indexes) public override {\\n    uint48 time = uint48(block.timestamp);\\n\\n    for (uint256 i = 0; i < _indexes.length; i++) {\\n      Note storage note = notes[_user][_indexes[i]];\\n\\n      bool matured = note.redeemed == 0 && note.matured <= block.timestamp && note.payout != 0;\\n\\n      if (matured) {\\n        note.redeemed = time; // mark as redeemed\\n        vestingContract.transfer(note.token, _user, note.payout);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice             redeem all redeemable markets for user\\n   * @dev                if possible, query indexesFor() off-chain and input in redeem() to save gas\\n   * @param _user        user to redeem all notes for\\n   */ \\n  function redeemAll(address _user) external override {\\n    return redeem(_user, indexesFor(_user));\\n  }\\n\\n/* ========== TRANSFER ========== */\\n\\n  /**\\n   * @notice             approve an address to transfer a note\\n   * @param _to          address to approve note transfer for\\n   * @param _index       index of note to approve transfer for\\n   */ \\n  function pushNote(address _to, uint256 _index) external override {\\n    require(notes[msg.sender][_index].created != 0, \\\"Depository: note not found\\\");\\n    noteTransfers[msg.sender][_index] = _to;\\n  }\\n\\n  /**\\n   * @notice             transfer a note that has been approved by an address\\n   * @param _from        the address that approved the note transfer\\n   * @param _index       the index of the note to transfer (in the sender's array)\\n   */ \\n  function pullNote(address _from, uint256 _index) external override returns (uint256 newIndex_) {\\n    require(noteTransfers[_from][_index] == msg.sender, \\\"Depository: transfer not found\\\");\\n    require(notes[_from][_index].redeemed == 0, \\\"Depository: note redeemed\\\");\\n\\n    newIndex_ = notes[msg.sender].length;\\n    notes[msg.sender].push(notes[_from][_index]);\\n\\n    delete notes[_from][_index];\\n  }\\n\\n/* ========== VIEW ========== */\\n\\n  // Note info\\n\\n  /**\\n   * @notice             all pending notes for user\\n   * @param _user        the user to query notes for\\n   * @return indexes_    the pending notes for the user\\n   */\\n  function indexesFor(address _user) public view override returns (uint256[] memory indexes_) {\\n    Note[] memory info = notes[_user];\\n\\n    uint256 length;\\n    for (uint256 i = 0; i < info.length; i++) {\\n      if (info[i].redeemed == 0 && info[i].payout != 0) length++;\\n    }\\n\\n    indexes_ = new uint256[](length);\\n    uint256 position;\\n\\n    for (uint256 i = 0; i < info.length; i++) {\\n      if (info[i].redeemed == 0 && info[i].payout != 0) {\\n        indexes_[position] = i;\\n        position++;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice             calculate amount available for claim for a single note\\n   * @param _user        the user that the note belongs to\\n   * @param _index       the index of the note in the user's array\\n   * @return payout_     the payout due\\n   * @return matured_    if the payout can be redeemed\\n   */\\n  function pendingFor(address _user, uint256 _index) public view override returns (uint256 payout_, bool matured_) {\\n    Note memory note = notes[_user][_index];\\n\\n    payout_ = note.payout;\\n    matured_ = note.redeemed == 0 && note.matured <= block.timestamp && note.payout != 0;\\n  }\\n}\"\r\n    },\r\n    \"contracts/types/Pro/Rewarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport \\\"../OlympusAccessControlled.sol\\\";\\n\\nimport \\\"../../interfaces/IERC20.sol\\\";\\n\\nabstract contract ProRewarder is OlympusAccessControlled {\\n\\n/* ========== STATE VARIABLES ========== */\\n\\n  uint256 public daoReward; // % reward for dao (3 decimals: 100 = 1%)\\n  uint256 public refReward; // % reward for referrer (3 decimals: 100 = 1%)\\n\\n  mapping(address => mapping(IERC20 => uint256)) public rewards; // front end operator rewards\\n  mapping(address => bool) public whitelisted; // whitelisted status for operators\\n\\n  constructor(IOlympusAuthority _authority) OlympusAccessControlled(_authority) {}\\n\\n/* ========== EXTERNAL FUNCTIONS ========== */\\n\\n  // pay reward to front end operator\\n  function getReward(IERC20[] memory tokens) external {\\n    for (uint256 i; i < tokens.length; i++) {\\n      uint256 reward = rewards[msg.sender][tokens[i]];\\n\\n      rewards[msg.sender][tokens[i]] = 0;\\n      tokens[i].transfer(msg.sender, reward);\\n    }\\n  }\\n\\n/* ========== INTERNAL ========== */\\n\\n  /** \\n   * @notice add new market payout to user data\\n   */\\n  function _giveRewards(\\n    IERC20 _token,\\n    uint256 _payout,\\n    address _referral\\n  ) internal returns (uint256) {\\n    // first we calculate rewards paid to the DAO and to the front end operator (referrer)\\n    uint256 toDAO = _payout * daoReward / 1e4;\\n    uint256 toRef = _payout * refReward / 1e4;\\n\\n    // and store them in our rewards mapping\\n    if (whitelisted[_referral]) {\\n      rewards[_referral][_token] += toRef;\\n      rewards[authority.guardian()][_token] += toDAO;\\n    } else { // the DAO receives both rewards if referrer is not whitelisted\\n      rewards[authority.guardian()][_token] += toDAO + toRef;\\n    }\\n    return toDAO + toRef;\\n  }\\n\\n/* ========== OWNABLE ========== */ \\n\\n  /**\\n   * @notice turn on rewards for front end operators and DAO\\n   */\\n  function enableRewards() external onlyGovernor {\\n    refReward = 3;\\n    daoReward = 30;\\n  }\\n\\n  /**\\n   * @notice turn off rewards for front end operators and DAO\\n   */\\n  function disableRewards(bool _dao) external onlyGovernor {\\n    if (_dao) {\\n      daoReward = 0;\\n    } else {\\n      refReward = 0;\\n    }\\n  }\\n\\n  /**\\n   * @notice add or remove addresses from the front end reward whitelist\\n   */\\n  function whitelist(address _operator) external onlyPolicy {\\n    whitelisted[_operator] = !whitelisted[_operator];\\n  }\\n}\"\r\n    },\r\n    \"contracts/types/Pro/Viewer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport \\\"./MarketCreator.sol\\\";\\nimport \\\"../../interfaces/IProViewer.sol\\\";\\n\\nabstract contract ProViewer is IProViewer, ProMarketCreator {\\n\\n    constructor() ProMarketCreator() {}\\n\\n/* ========== EXTERNAL VIEW ========== */\\n\\n  /**\\n   * @notice             calculate current market price of base token in quote tokens\\n   * @dev                accounts for debt and control variable decay since last deposit (vs _marketPrice())\\n   * @param _id          ID of market\\n   * @return             price for market in base token decimals\\n   *\\n   * price is derived from the equation\\n   *\\n   * p = c * d\\n   *\\n   * where\\n   * p = price\\n   * c = control variable\\n   * d = debt\\n   *\\n   * d -= ( d * (dt / l) )\\n   * \\n   * where\\n   * dt = change in time\\n   * l = length of program\\n   *\\n   * if price is below minimum price, minimum price is returned\\n   * this is enforced on deposits by manipulating total debt (see _decay())\\n   */\\n  function marketPrice(uint256 _id) public view override returns (uint256) {\\n    uint256 price = \\n      currentControlVariable(_id)\\n      * currentDebt(_id)\\n      / (10 ** metadata[_id].baseDecimals);\\n    return \\n      (price > markets[_id].minPrice) \\n      ? price \\n      : markets[_id].minPrice;\\n  }\\n\\n  /**\\n   * @notice             payout due for amount of quote tokens\\n   * @dev                accounts for debt and control variable decay so it is up to date\\n   * @param _amount      amount of quote tokens to spend\\n   * @param _id          ID of market\\n   * @return             amount of base tokens to be paid\\n   */\\n  function payoutFor(uint256 _amount, uint256 _id) public view override returns (uint256) {\\n    Metadata memory meta = metadata[_id];\\n    return \\n      _amount\\n      * 10 ** (2 * meta.baseDecimals)\\n      / marketPrice(_id)\\n      / 10 ** meta.quoteDecimals;\\n  }\\n\\n  /**\\n   * @notice             calculate debt factoring in decay\\n   * @dev                accounts for debt decay since last deposit\\n   * @param _id          ID of market\\n   * @return             current debt for market in base token decimals\\n   */\\n  function currentDebt(uint256 _id) public view override returns (uint256) {\\n    uint256 decay = markets[_id].totalDebt \\n      * (block.timestamp - metadata[_id].lastDecay) \\n      / metadata[_id].length;\\n    return markets[_id].totalDebt - decay;\\n  }\\n\\n  /**\\n   * @notice             up to date control variable\\n   * @dev                accounts for control variable adjustment\\n   * @param _id          ID of market\\n   * @return             control variable for market in base token decimals\\n   */\\n  function currentControlVariable(uint256 _id) public view returns (uint256) {\\n    (uint256 decay,,) = _controlDecay(_id);\\n    return terms[_id].controlVariable - decay;\\n  }\\n\\n  /**\\n   * @notice             returns maximum quote token in for market\\n   */\\n  function maxIn(uint256 _id) public view returns (uint256) {\\n    Metadata memory meta = metadata[_id];\\n    return\\n      markets[_id].maxPayout\\n      * 10 ** meta.quoteDecimals\\n      * marketPrice(_id)\\n      / 2 * (10 ** meta.baseDecimals);\\n  }\\n\\n  /**\\n   * @notice             does market send payout immediately\\n   * @param _id          market ID to search for\\n   */\\n  function instantSwap(uint256 _id) public view returns (bool) {\\n    Terms memory term = terms[_id];\\n    return (term.fixedTerm && term.vesting == 0) || (!term.fixedTerm && term.vesting <= block.timestamp);\\n  }\\n\\n  /**\\n   * @notice             is a given market accepting deposits\\n   * @param _id          ID of market\\n   */\\n  function isLive(uint256 _id) public view override returns (bool) {\\n    return (markets[_id].capacity != 0 && terms[_id].conclusion > block.timestamp);\\n  }\\n\\n  /**\\n   * @notice             returns an array of all active market IDs\\n   */\\n  function liveMarkets() external view override returns (uint256[] memory) {\\n    return liveMarketsBetween(0, markets.length);\\n  }\\n\\n  /**\\n   * @notice             returns array of active market IDs within a range\\n   * @notice             should be used if length exceeds max to query entire array\\n   */\\n  function liveMarketsBetween(uint256 firstIndex, uint256 lastIndex) public view returns (uint256[] memory) {\\n    uint256 num;\\n    for (uint256 i = firstIndex; i < lastIndex; i++) {\\n      if (isLive(i)) num++;\\n    }\\n\\n    uint256[] memory ids = new uint256[](num);\\n    uint256 nonce;\\n    for (uint256 i = firstIndex; i < lastIndex; i++) {\\n      if (isLive(i)) {\\n        ids[nonce] = i;\\n        nonce++;\\n      }\\n    }\\n    return ids;\\n  }\\n\\n  /**\\n   * @notice             returns an array of all active market IDs for a given quote token\\n   * @param _creator     is query for markets by creator, or for markets by token\\n   * @param _base        if query is for markets by token, search by base or quote token\\n   * @param _address     address of creator or token to query by\\n   */\\n  function liveMarketsFor(bool _creator, bool _base, address _address) public view override returns (uint256[] memory) {\\n    uint256[] memory mkts;\\n    \\n    if (_creator) {\\n      mkts = marketsForCreator[_address];\\n    } else {\\n      mkts = _base \\n      ? marketsForBase[_address]\\n      : marketsForQuote[_address];\\n    }\\n\\n    uint256 num;\\n\\n    for (uint256 i = 0; i < mkts.length; i++) {\\n      if (isLive(mkts[i])) num++;\\n    }\\n\\n    uint256[] memory ids = new uint256[](num);\\n    uint256 nonce;\\n\\n    for (uint256 i = 0; i < mkts.length; i++) {\\n      if (isLive(mkts[i])) {\\n        ids[nonce] = mkts[i];\\n        nonce++;\\n      }\\n    }\\n    return ids;\\n  }\\n\\n\\n  function marketsFor(address tokenIn, address tokenOut) public view returns (uint256[] memory) {\\n    uint256[] memory forBase = liveMarketsFor(false, true, tokenOut);\\n    uint256[] memory ids;\\n    uint256 nonce;\\n    for(uint256 i; i < forBase.length; i++) {\\n      if (address(markets[forBase[i]].quoteToken) == tokenIn) {\\n        ids[nonce] = forBase[i];\\n      }\\n    }\\n    return ids;\\n  }\\n\\n  function findMarketFor(\\n    address tokenIn, \\n    address tokenOut, \\n    uint256 amountIn, \\n    uint256 minAmountOut, \\n    uint256 maxExpiry\\n  ) external view returns (uint256 id) {\\n    uint256[] memory ids = marketsFor(tokenIn, tokenOut);\\n    uint256[] memory payouts;\\n    uint256 n;\\n    for(uint256 i; i < ids.length; i++) {\\n      Terms memory term = terms[ids[i]];\\n\\n      uint256 expiry = term.fixedTerm ? block.timestamp + term.vesting : term.vesting;\\n      require(expiry <= maxExpiry, \\\"Bad expiry\\\");\\n\\n      if (minAmountOut > markets[ids[i]].maxPayout) {\\n        payouts[n] = payoutFor(amountIn, ids[i]);\\n      } else {\\n        payouts[n] = 0;\\n      }\\n      n++;\\n    }\\n    uint256 highestOut;\\n    for (uint256 i; i < payouts.length; i++) {\\n      if (payouts[i] > highestOut) {\\n        highestOut = payouts[i];\\n        id = ids[i];\\n      }\\n    }\\n  }\\n\\n/* ========== INTERNAL VIEW ========== */\\n\\n  /**\\n   * @notice                  amount to decay control variable by\\n   * @param _id               ID of market\\n   * @return decay_           change in control variable\\n   * @return secondsSince_    seconds since last change in control variable\\n   * @return active_          whether or not change remains active\\n   */ \\n  function _controlDecay(uint256 _id) internal view returns (uint256 decay_, uint48 secondsSince_, bool active_) {\\n    Adjustment memory info = adjustments[_id];\\n    if (!info.active) return (0, 0, false);\\n\\n    secondsSince_ = uint48(block.timestamp) - info.lastAdjustment;\\n\\n    active_ = secondsSince_ < info.timeToAdjusted;\\n    decay_ = active_ \\n      ? info.change * secondsSince_ / info.timeToAdjusted\\n      : info.change;\\n  }\\n}\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.5;\\n\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\\n/// Taken from Solmate\\nlibrary SafeERC20 {\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        (bool success, ) = to.call{value: amount}(new bytes(0));\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20Metadata is IERC20 {\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IOlympusPro.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.10;\\n\\nimport \\\"./IProMarketCreator.sol\\\";\\nimport \\\"./IProNoteKeeper.sol\\\";\\nimport \\\"./IProViewer.sol\\\";\\n\\ninterface IOlympusPro is IProMarketCreator, IProNoteKeeper, IProViewer {\\n\\n  /**\\n   * @notice deposit quote tokens in exchange for a bond in a specified market\\n   */\\n  function deposit(\\n    uint48 _id,\\n    uint256[2] memory _amounts,\\n    address[2] memory _addresses\\n  ) external returns (\\n    uint256 payout_,\\n    uint256 expiry_,\\n    uint256 index_\\n  );\\n}\"\r\n    },\r\n    \"contracts/interfaces/IProCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.10;\\n\\ninterface IProCall {\\n  function call(uint256 id, uint256 amountIn, uint256 amountOut) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IProMarketCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.10;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IProMarketCreator {\\n\\n  // Info about each type of market\\n  struct Market {\\n    address creator; // market creator. sends base tokens, receives quote tokens\\n    IERC20 baseToken; // token to pay depositors with\\n    IERC20 quoteToken; // token to accept as payment\\n    bool call; // perform custom call for payout\\n    bool capacityInQuote; // capacity limit is in payment token (true) or in OHM (false, default)\\n    uint256 capacity; // capacity remaining\\n    uint256 totalDebt; // total base token debt from market\\n    uint256 minPrice; // minimum price (debt will stop decaying to maintain this)\\n    uint256 maxPayout; // max base tokens out in one order\\n    uint256 sold; // base tokens out\\n    uint256 purchased; // quote tokens in\\n  }\\n\\n  // Info for creating new markets\\n  struct Terms {\\n    uint256 controlVariable; // scaling variable for price\\n    uint256 maxDebt; // max base token debt accrued\\n    bool fixedTerm; // fixed term or fixed expiration\\n    uint48 vesting; // length of time from deposit to maturity if fixed-term\\n    uint48 conclusion; // timestamp when market no longer offered (doubles as time when market matures if fixed-expiry)\\n  }\\n\\n  // Additional info about market.\\n  struct Metadata {\\n    uint48 lastTune; // last timestamp when control variable was tuned\\n    uint48 lastDecay; // last timestamp when market was created and debt was decayed\\n    uint48 length; // time from creation to conclusion. used as speed to decay debt.\\n    uint48 depositInterval; // target frequency of deposits\\n    uint48 tuneInterval; // frequency of tuning\\n    uint8 baseDecimals; // decimals of base token\\n    uint8 quoteDecimals; // decimals of quote token\\n  }\\n\\n  // Control variable adjustment data\\n  struct Adjustment {\\n    uint128 change;\\n    uint48 lastAdjustment;\\n    uint48 timeToAdjusted;\\n    bool active;\\n  }\\n\\n  function create (\\n    IERC20[2] memory _tokens, // [base token, quote token]\\n    uint256[4] memory _market, // [capacity, initial price, minimum price, debt buffer]\\n    bool[2] memory _booleans, // [capacity in quote, fixed term]\\n    uint256[2] memory _terms, // [vesting, conclusion]\\n    uint32[2] memory _intervals // [deposit interval, tune interval]\\n  ) external returns (uint256 id_);\\n\\n  function close(uint256 _id) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProNoteKeeper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.10;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IProNoteKeeper {\\n  // Info for market note\\n  struct Note {\\n    uint256 payout; // gOHM remaining to be paid\\n    uint48 created; // time market was created\\n    uint48 matured; // timestamp when market is matured\\n    uint48 redeemed; // time market was redeemed\\n    uint48 marketID; // market ID of deposit. uint48 to avoid adding a slot.\\n    address token; // token to be paid.\\n  }\\n\\n  function redeem(address _user, uint256[] memory _indexes) external;\\n  function redeemAll(address _user) external;\\n  function pushNote(address to, uint256 index) external;\\n  function pullNote(address from, uint256 index) external returns (uint256 newIndex_);\\n\\n  function indexesFor(address _user) external view returns (uint256[] memory);\\n  function pendingFor(address _user, uint256 _index) external view returns (uint256 payout_, bool matured_);\\n}\"\r\n    },\r\n    \"contracts/types/OlympusAccessControlled.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.5;\\n\\nimport \\\"../interfaces/IOlympusAuthority.sol\\\";\\n\\nabstract contract OlympusAccessControlled {\\n\\n    /* ========== EVENTS ========== */\\n\\n    event AuthorityUpdated(IOlympusAuthority indexed authority);\\n\\n    string UNAUTHORIZED = \\\"UNAUTHORIZED\\\"; // save gas\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IOlympusAuthority public authority;\\n\\n\\n    /* ========== Constructor ========== */\\n\\n    constructor(IOlympusAuthority _authority) {\\n        authority = _authority;\\n        emit AuthorityUpdated(_authority);\\n    }\\n    \\n\\n    /* ========== MODIFIERS ========== */\\n    \\n    modifier onlyGovernor() {\\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\\n        _;\\n    }\\n    \\n    modifier onlyGuardian() {\\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\\n        _;\\n    }\\n    \\n    modifier onlyPolicy() {\\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    modifier onlyVault() {\\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\\n        _;\\n    }\\n    \\n    /* ========== GOV ONLY ========== */\\n    \\n    function setAuthority(IOlympusAuthority _newAuthority) external onlyGovernor {\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOlympusAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IOlympusAuthority {\\n    /* ========== EVENTS ========== */\\n    \\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \\n\\n    event GovernorPulled(address indexed from, address indexed to);\\n    event GuardianPulled(address indexed from, address indexed to);\\n    event PolicyPulled(address indexed from, address indexed to);\\n    event VaultPulled(address indexed from, address indexed to);\\n\\n    /* ========== VIEW ========== */\\n    \\n    function governor() external view returns (address);\\n    function guardian() external view returns (address);\\n    function policy() external view returns (address);\\n    function vault() external view returns (address);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IProViewer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.10;\\n\\ninterface IProViewer {\\n  function isLive(uint256 _bid) external view returns (bool);\\n  function liveMarkets() external view returns (uint256[] memory);\\n  function liveMarketsFor(bool _creator, bool _base, address _address) external view returns (uint256[] memory);\\n  function payoutFor(uint256 _amount, uint256 _bid) external view returns (uint256);\\n  function marketPrice(uint256 _bid) external view returns (uint256);\\n  function currentDebt(uint256 _bid) external view returns (uint256);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authority\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IOlympusAuthority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Bond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"CloseMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"conclusion\",\"type\":\"uint256\"}],\"name\":\"CreateMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldControlVariable\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newControlVariable\",\"type\":\"uint256\"}],\"name\":\"Tuned\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"adjustments\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"change\",\"type\":\"uint128\"},{\"internalType\":\"uint48\",\"name\":\"lastAdjustment\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"timeToAdjusted\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[2]\",\"name\":\"_tokens\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[4]\",\"name\":\"_market\",\"type\":\"uint256[4]\"},{\"internalType\":\"bool[2]\",\"name\":\"_booleans\",\"type\":\"bool[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"_terms\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint32[2]\",\"name\":\"_intervals\",\"type\":\"uint32[2]\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"currentControlVariable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"currentDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"_id\",\"type\":\"uint48\"},{\"internalType\":\"uint256[2]\",\"name\":\"_amounts\",\"type\":\"uint256[2]\"},{\"internalType\":\"address[2]\",\"name\":\"_addresses\",\"type\":\"address[2]\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_dao\",\"type\":\"bool\"}],\"name\":\"disableRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxExpiry\",\"type\":\"uint256\"}],\"name\":\"findMarketFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"indexesFor\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"indexes_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"instantSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"isLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liveMarkets\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"firstIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastIndex\",\"type\":\"uint256\"}],\"name\":\"liveMarketsBetween\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_creator\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_base\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"liveMarketsFor\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"marketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"markets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"baseToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"call\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"capacityInQuote\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"capacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchased\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"marketsFor\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketsForBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketsForCreator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketsForQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"maxIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"metadata\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"lastTune\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"lastDecay\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"length\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"depositInterval\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"tuneInterval\",\"type\":\"uint48\"},{\"internalType\":\"uint8\",\"name\":\"baseDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"quoteDecimals\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"notes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"created\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"matured\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"redeemed\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"marketID\",\"type\":\"uint48\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"payoutFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"pendingFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"matured_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"pullNote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newIndex_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"pushNote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_indexes\",\"type\":\"uint256[]\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"redeemAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"_newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"terms\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"controlVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDebt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fixedTerm\",\"type\":\"bool\"},{\"internalType\":\"uint48\",\"name\":\"vesting\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"conclusion\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingContract\",\"outputs\":[{\"internalType\":\"contract IVesting\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OlympusProV2", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "0000000000000000000000001c21f8ea7e39e2ba00bc12d2968d63f4acb38b7a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}