{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/Stake.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract Stake is Ownable {\r\n\tstruct sStake {\r\n    uint256 total_rewards_unclaimed;\r\n    uint256 total_rewards_claimed;\r\n    uint256 total_staked;\r\n    uint256 rewards_claimed_at;\r\n    uint256 stake_started_at;\r\n\t}\r\n\r\n  // Stakes\r\n  mapping(address => sStake) public stakes;\r\n\r\n  // Refers\r\n  mapping(address => address) public refers;\r\n\r\n  // total staked\r\n  uint256 public totalStaked = 0;\r\n\r\n  // minimum value to stake\r\n  uint256 public minValueToStake = 0.01 ether;\r\n\r\n  // maximum value to stake\r\n  uint256 public maxValueToStake = 1 ether;\r\n\r\n  // Yield multiply by 10000\r\n  uint256 public yield = 110;\r\n\r\n  // Maximum Claim Rewards\r\n  uint256 public maximumClaimRewardsPorcentage = 3;\r\n\r\n  // Refer Porcentage\r\n  uint256 public referPorcentage = 10;\r\n\r\n  function setMinValueToStake(uint256 _value) public onlyOwner {\r\n    minValueToStake = _value;\r\n  }\r\n\r\n  function setMaxValueToStake(uint256 _value) public onlyOwner {\r\n    maxValueToStake = _value;\r\n  }\r\n\r\n  function setYield(uint256 _value) public onlyOwner {\r\n    yield = _value;\r\n  }\r\n\r\n  function setMaximumClaimRewardsPorcentage(uint256 _value) public onlyOwner {\r\n    maximumClaimRewardsPorcentage = _value;\r\n  }\r\n\r\n  function setReferPorcentage(uint256 _value) public onlyOwner {\r\n    referPorcentage = _value;\r\n  }\r\n\r\n  function stake(address _address, address _refer) public payable {\r\n    require(minValueToStake <= msg.value, \"Value not enoght!\");\r\n    require(maxValueToStake >= (msg.value + stakes[_address].total_staked), \"Maximum of stake exceeded!\");\r\n    require(_address != _refer, \"Address and Refer can not be equal!\");\r\n\r\n    _stake(_address, msg.value);\r\n\r\n    // Set refer address\r\n    if(refers[_address] == address(0x0)){\r\n      refers[_address] = _refer;\r\n    }else{\r\n      _refer = refers[_address];\r\n    }\r\n\r\n    // Indication to refer\r\n    if(referPorcentage > 0 && stakes[_refer].total_staked > 0){\r\n      _stake(_refer, msg.value / referPorcentage);\r\n    }\r\n  }\r\n\r\n  function _stake(address _address, uint256 _value) internal {\r\n    // Update the actual rewards unclaimed\r\n    if(stakes[_address].total_staked > 0){\r\n      updateAndGetTotalRewardsUnclaimed(_address);\r\n    }\r\n\r\n    totalStaked += _value;\r\n    stakes[_address].total_staked += _value;\r\n    stakes[_address].stake_started_at = block.timestamp;\r\n\r\n    emit StartStake(_address, msg.value);\r\n  }\r\n\r\n  function claimRewards(address payable _address) public payable{\r\n    // Get rewards unclaimed\r\n    uint256 _total_rewards_unclaimed = updateAndGetTotalRewardsUnclaimed(_address);\r\n\r\n    require(address(this).balance > _total_rewards_unclaimed, \"Balance of contract not enoght!\");\r\n\r\n    if(_total_rewards_unclaimed > 0){\r\n      //Update total rewards unclaimed\r\n      stakes[_address].total_rewards_unclaimed = 0;\r\n\r\n      // Update total rewards claimed\r\n      stakes[_address].total_rewards_claimed += _total_rewards_unclaimed;\r\n\r\n      // If Stake is Over\r\n      if(stakes[_address].total_rewards_claimed >= getMaximumClaimRewardsTotal(_address)){\r\n        uint256 _total_rewards_claimed = stakes[_address].total_rewards_claimed;\r\n\r\n        // Remove of total staked\r\n        totalStaked -= stakes[_address].total_staked;\r\n\r\n        // Reset All Stake Data\r\n        stakes[_address].total_rewards_claimed = 0;\r\n        stakes[_address].total_staked = 0;\r\n        stakes[_address].rewards_claimed_at = 0;\r\n        stakes[_address].stake_started_at = 0;\r\n\r\n        emit StopStake(_address, _total_rewards_claimed);\r\n      }\r\n\r\n      _address.transfer(_total_rewards_unclaimed);\r\n      emit ClaimRewards(_address, _total_rewards_unclaimed);\r\n    }\r\n  }\r\n\r\n  function updateAndGetTotalRewardsUnclaimed(address _address) public returns(uint256){\r\n    //Update total rewards unclaimed\r\n    stakes[_address].total_rewards_unclaimed = getTotalRewardsUnclaimed(_address);\r\n\r\n    //Update reward claimed at\r\n    stakes[_address].rewards_claimed_at = block.timestamp;\r\n\r\n    //Return total rewards unclaimed\r\n    return stakes[_address].total_rewards_unclaimed;\r\n  }\r\n\r\n  function getTotalRewardsUnclaimed(address _address) public view returns(uint256){\r\n    // Set total rewards unclaimed\r\n    uint256 totalRewardsUnclaimed = stakes[_address].total_rewards_unclaimed + calculeStakeBalance(_address);\r\n\r\n    // Set the maximum Claim Rewards Total\r\n    uint256 maximumClaimRewardsTotal = getMaximumClaimRewardsTotal(_address);\r\n\r\n    // Check the maximum of Rewards\r\n    if((totalRewardsUnclaimed + stakes[_address].total_rewards_claimed) > maximumClaimRewardsTotal) {\r\n      totalRewardsUnclaimed -= (totalRewardsUnclaimed + stakes[_address].total_rewards_claimed) - maximumClaimRewardsTotal;\r\n    }\r\n\r\n    // Filter to 0\r\n    if(totalRewardsUnclaimed < 0){\r\n      totalRewardsUnclaimed = 0;\r\n    }\r\n\r\n    return totalRewardsUnclaimed;\r\n  }\r\n\r\n  function getMaximumClaimRewardsTotal(address _address) public view returns(uint256){\r\n    uint256 maximumClaimRewardsTotal;\r\n\r\n    // Set the maximum Claim Rewards Total\r\n    maximumClaimRewardsTotal = (maximumClaimRewardsPorcentage*stakes[_address].total_staked);\r\n\r\n    return maximumClaimRewardsTotal;\r\n  }\r\n\r\n  function calculeStakeBalance(address _address) public view returns(uint256){\r\n    uint256 totalReward;\r\n    uint256 timeStakingBySeconds;\r\n    uint256 actualTime;\r\n\r\n    actualTime = block.timestamp;\r\n    timeStakingBySeconds = 0;\r\n\r\n    // Calculate total brains staked\r\n    if(stakes[_address].rewards_claimed_at > 0){\r\n      timeStakingBySeconds = actualTime - stakes[_address].rewards_claimed_at;\r\n    }else{\r\n      timeStakingBySeconds = actualTime - stakes[_address].stake_started_at;\r\n    }\r\n\r\n    totalReward = (yield * stakes[_address].total_staked * timeStakingBySeconds) / 864000000;\r\n\r\n    // Filter to 0\r\n    if(totalReward < 0){\r\n      totalReward = 0;\r\n    }\r\n\r\n    return totalReward;\r\n  }\r\n\r\n  function withdraw(uint256 amount) public onlyOwner {\r\n    require(amount <= address(this).balance, \"Amount should be equal or lower of balance.\");\r\n    payable(msg.sender).transfer(amount);\r\n  }\r\n  /*\r\n   * Event\r\n   */\r\n\r\n  event StartStake(address _address, uint256 value);\r\n  event StopStake(address _address, uint256 value);\r\n  event ClaimRewards(address _address, uint256 value);\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ClaimRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"StartStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"StopStake\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"calculeStakeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getMaximumClaimRewardsTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTotalRewardsUnclaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxValueToStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumClaimRewardsPorcentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minValueToStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referPorcentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"refers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setMaxValueToStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setMaximumClaimRewardsPorcentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setMinValueToStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setReferPorcentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_refer\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total_rewards_unclaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_rewards_claimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_staked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards_claimed_at\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake_started_at\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateAndGetTotalRewardsUnclaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Stake", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e28349eeb94cf46bf1e58157d1cce8ef6a936e194c0f626a92911a350314cc26"}]}