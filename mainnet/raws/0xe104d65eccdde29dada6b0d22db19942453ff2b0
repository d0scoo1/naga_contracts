{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.4;\r\n\r\n/*\r\n __________________________________\r\n|                                  |\r\n| $ + $ + $ + $ + $ + $ + $ + $ + $|\r\n|+ $ + $ + $ + $ + $ + $ + $ + $ + |\r\n| + $ + $ + $ + $ + $ + $ + $ + $ +|\r\n|$ + $ + $ + $ + $ + $ + $ + $ + $ |\r\n| $ + $ + $ + $ + $ + $ + $ + $ + $|\r\n|+ $ + $ + $ + $ + $ + $ + $ + $ + |\r\n| + $ + $ + $ + $ + $ + $ + $ + $ +|\r\n|__________________________________|\r\n\r\n*/\r\n\r\n/**\r\n * @title NFT Broker\r\n * @author CXIP-Labs\r\n * @notice A simple smart contract for selling NFTs from a private storefront.\r\n * @dev The entire logic and functionality of the smart contract is self-contained.\r\n */\r\ncontract NFTBroker {\r\n\r\n    /**\r\n     * @dev Address of admin user. Primarily used as an additional recovery address.\r\n     */\r\n    address private _admin;\r\n\r\n    /**\r\n     * @dev Address of contract owner. This address can run all onlyOwner functions.\r\n     */\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev Address of wallet that can authorise proof of stake claims.\r\n     */\r\n    address private _notary;\r\n\r\n    /**\r\n     * @dev Address of the token being sold.\r\n     */\r\n    address payable private _tokenContract;\r\n\r\n    /**\r\n     * @dev UNIX timestamp of from when the tier 1 is open.\r\n     */\r\n    uint256 private _tier1;\r\n\r\n    /**\r\n     * @dev UNIX timestamp of from when the tier 2 is open.\r\n     */\r\n    uint256 private _tier2;\r\n\r\n    /**\r\n     * @dev UNIX timestamp of from when the tier 3 is open.\r\n     */\r\n    uint256 private _tier3;\r\n\r\n    /**\r\n     * @dev List of all wallets that are tier1.\r\n     */\r\n    mapping(address => bool) private _tier1wallets;\r\n\r\n    /**\r\n     * @dev Specific map of what tokenId is allowed to mint for a specific wallet.\r\n     */\r\n    mapping(address => uint256[]) private _reservedTokens;\r\n\r\n    /**\r\n     * @dev Specific map of amount of free tokens that a specific wallet can mint.\r\n     */\r\n    mapping(address => uint256) private _reservedTokenAmounts;\r\n\r\n    /**\r\n     * @dev A map keeping tally of total numer of tokens purchased by a wallet.\r\n     */\r\n    mapping(address => uint256) private _purchasedTokens;\r\n\r\n    /**\r\n     * @dev Base purchase price of token in wei.\r\n     */\r\n    uint256 private _tokenBasePrice;\r\n\r\n    /**\r\n     * @dev Stake purchase price of token in wei.\r\n     */\r\n    uint256 private _tokenStakePrice;\r\n\r\n    /**\r\n     * @dev Claim purchase price of token in wei.\r\n     */\r\n    uint256 private _tokenClaimPrice;\r\n\r\n    /**\r\n     * @dev Array of all tokenIds available for minting/purchasing.\r\n     */\r\n    uint256[] private _allTokens;\r\n\r\n    /**\r\n     * @dev Mapping from token id to position in the allTokens array.\r\n     */\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    /**\r\n     * @dev Boolean indicating whether to automatically withdraw payments made for minting.\r\n     */\r\n    bool private _autoWithdraw;\r\n\r\n    /**\r\n     * @dev Capped limit of how many purchases can be made per wallet.\r\n     */\r\n    uint256 private _maxPurchases;\r\n\r\n    /**\r\n     * @dev Boolean indicating whether _maxPurchases should be enforced.\r\n     */\r\n    bool private _reserveLifted;\r\n\r\n    /**\r\n     * @dev Mapping of all approved functions for specific contracts. To be used for delegate calls.\r\n     */\r\n    mapping(address => mapping(bytes4 => bool)) private _approvedFunctions;\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner/admin.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"CXIP: caller not an owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Can be deployed with factory contracts, _admin will always be set to transaction initiator.\r\n     * @param tokenContract Address of the contract that will mint the tokens.\r\n     * @param notary Address of the wallet that will be used for validating stake&mint function values.\r\n     * @param autoWithdraw If enabled, eth will be sent to Identity automatically on payment for minting.\r\n     * @param newOwner Address of wallet/contract that will have authorization to make onlyOwner calls.\r\n     */\r\n    constructor (address tokenContract, address notary, bool autoWithdraw, uint256 maxPurchases, address newOwner) {\r\n        _admin = tx.origin;\r\n        _owner = newOwner;\r\n        _tokenContract = payable(tokenContract);\r\n        _notary = notary;\r\n        _autoWithdraw = autoWithdraw;\r\n        _maxPurchases = maxPurchases;\r\n    }\r\n\r\n    /**\r\n     * @notice Pay eth and buy a token.\r\n     * @dev Token must first be added to list of available tokens. A non-minted token will fail this call.\r\n     * @param tokenId The id of token to buy.\r\n     */\r\n    function buyToken (uint256 tokenId) public payable {\r\n        ISNUFFY500 snuffy = ISNUFFY500(_tokenContract);\r\n        require(snuffy.exists(tokenId), \"CXIP: token not minted\");\r\n        require(_exists(tokenId), \"CXIP: token not for sale\");\r\n        require(snuffy.ownerOf(tokenId) == address(this), \"CXIP: broker not owner of token\");\r\n        if (_tier1wallets[msg.sender]) {\r\n            require(msg.value >= _tokenClaimPrice, \"CXIP: payment amount is too low\");\r\n        } else {\r\n            require(msg.value >= _tokenBasePrice, \"CXIP: payment amount is too low\");\r\n        }\r\n        if (!_reserveLifted) {\r\n            require(_purchasedTokens[msg.sender] < _maxPurchases, \"CXIP: max allowance reached\");\r\n        }\r\n        _purchasedTokens[msg.sender] = _purchasedTokens[msg.sender] + 1;\r\n        snuffy.safeTransferFrom(address(this), msg.sender, tokenId);\r\n        _removeTokenFromAllTokensEnumeration(tokenId);\r\n        if (_autoWithdraw) {\r\n            _moveEth();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Claim and mint free token.\r\n     * @dev Wallets needs to be added to whitelist in order for this function to work.\r\n     * @param tokenId The id of token to mint.\r\n     * @param tokenData The complete data for the minted token.\r\n     * @param verification A signature for the tokenId and tokenData, made by a wallet authorized by Identity\r\n     */\r\n    function claimAndMint (uint256 tokenId, TokenData[] calldata tokenData, Verification calldata verification) public {\r\n        require(block.timestamp >= _tier1, \"CXIP: too early to claim\");\r\n        require(!ISNUFFY500(_tokenContract).exists(tokenId), \"CXIP: token snatched\");\r\n        if (_reservedTokenAmounts[msg.sender] > 0) {\r\n            require(_exists(tokenId), \"CXIP: token not for sale\");\r\n            ISNUFFY500(_tokenContract).mint(0, tokenId, tokenData, _admin, verification, msg.sender);\r\n            _reservedTokenAmounts[msg.sender] = _reservedTokenAmounts[msg.sender] - 1;\r\n            _removeTokenFromAllTokensEnumeration(tokenId);\r\n        } else {\r\n            uint256 length = _reservedTokens[msg.sender].length;\r\n            require(length > 0, \"CXIP: no tokens to claim\");\r\n            uint256 index = length - 1;\r\n            require(_reservedTokens[msg.sender][index] == tokenId, \"CXIP: not your token\");\r\n            delete _reservedTokens[msg.sender][index];\r\n            _reservedTokens[msg.sender].pop();\r\n            ISNUFFY500(_tokenContract).mint(1, tokenId, tokenData, _admin, verification, msg.sender);\r\n        }\r\n        if (!_tier1wallets[msg.sender]) {\r\n            _tier1wallets[msg.sender] = true;\r\n        }\r\n        if (_autoWithdraw) {\r\n            _moveEth();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Call a pre-approved external function.\r\n     * @dev This allows to extend the functionality of the contract, without the need of a complete re-deployment.\r\n     * @param target Address of smart contract to call.\r\n     * @param functionHash Function hash of the external contract function to call.\r\n     * @param payload Entire payload to include in the external call. Keep in mind to not include function hash.\r\n     */\r\n    function delegateApproved (address target, bytes4 functionHash, bytes calldata payload) public payable {\r\n        require(_approvedFunctions[target][functionHash], \"CXIP: not approved delegate call\");\r\n        (bool success, bytes memory data) = target.delegatecall(abi.encodePacked(functionHash, payload));\r\n        require(success, string(data));\r\n    }\r\n\r\n    /**\r\n     * @notice Pay eth and mint a token.\r\n     * @dev Token must first be added to list of available tokens. An already minted token will fail on mint.\r\n     * @param tokenId The id of token to mint.\r\n     * @param tokenData The complete data for the minted token.\r\n     * @param verification A signature for the tokenId and tokenData, made by a wallet authorized by Identity\r\n     */\r\n    function payAndMint (uint256 tokenId, TokenData[] calldata tokenData, Verification calldata verification) public payable {\r\n        require(block.timestamp >= _tier3 || _tier1wallets[msg.sender], \"CXIP: too early to buy\");\r\n        require(!ISNUFFY500(_tokenContract).exists(tokenId), \"CXIP: token snatched\");\r\n        require(_exists(tokenId), \"CXIP: token not for sale\");\r\n        if (_tier1wallets[msg.sender]) {\r\n            if (_purchasedTokens[msg.sender] > 0) {\r\n                require(msg.value >= _tokenClaimPrice, \"CXIP: payment amount is too low\");\r\n            }\r\n        } else {\r\n            require(msg.value >= _tokenBasePrice, \"CXIP: payment amount is too low\");\r\n        }\r\n        if (!_reserveLifted) {\r\n            require(_purchasedTokens[msg.sender] < _maxPurchases, \"CXIP: max allowance reached\");\r\n        }\r\n        _purchasedTokens[msg.sender] = _purchasedTokens[msg.sender] + 1;\r\n        ISNUFFY500(_tokenContract).mint(0, tokenId, tokenData, _admin, verification, msg.sender);\r\n        _removeTokenFromAllTokensEnumeration(tokenId);\r\n        if (_autoWithdraw) {\r\n            _moveEth();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Show proof of stake, and mint a token.\r\n     * @dev First an off-chain validation of staking must be made, and signed by the notary wallet.\r\n     * @param proof Signature made by the notary wallet, proving validity of stake.\r\n     * @param tokens The total number of tokens staked by wallet.\r\n     * @param tokenId The id of token to mint.\r\n     * @param tokenData The complete data for the minted token.\r\n     * @param verification A signature for the tokenId and tokenData, made by a wallet authorized by Identity\r\n     */\r\n    function proofOfStakeAndMint (Verification calldata proof, uint256 tokens, uint256 tokenId, TokenData[] calldata tokenData, Verification calldata verification) public payable {\r\n        require(block.timestamp >= _tier2, \"CXIP: too early to stake\");\r\n        require(msg.value >= _tokenStakePrice, \"CXIP: payment amount is too low\");\r\n        require(!ISNUFFY500(_tokenContract).exists(tokenId), \"CXIP: token snatched\");\r\n        require(_exists(tokenId), \"CXIP: token not for sale\");\r\n        bytes memory encoded = abi.encodePacked(msg.sender, tokens);\r\n        require(Signature.Valid(\r\n            _notary,\r\n            proof.r,\r\n            proof.s,\r\n            proof.v,\r\n            encoded\r\n        ), \"CXIP: invalid signature\");\r\n        if (!_reserveLifted) {\r\n            require(_purchasedTokens[msg.sender] < _maxPurchases, \"CXIP: max allowance reached\");\r\n        }\r\n        _purchasedTokens[msg.sender] = _purchasedTokens[msg.sender] + 1;\r\n        ISNUFFY500(_tokenContract).mint(0, tokenId, tokenData, _admin, verification, msg.sender);\r\n        _removeTokenFromAllTokensEnumeration(tokenId);\r\n        if (_autoWithdraw) {\r\n            _moveEth();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a token id from being reserved by a wallet.\r\n     * @dev If you want to add a token id to for sale list, first remove it from a wallet if it has been reserved.\r\n     * @param wallets Array of wallets for which to remove reserved tokens for.\r\n     */\r\n    function clearReservedTokens (address[] calldata wallets) public onlyOwner {\r\n        for (uint256 i = 0; i < wallets.length; i++) {\r\n            _reservedTokens[wallets[i]] = new uint256[](0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Can be used to bring logic from other smart contracts in (temporarily).\r\n     * @dev Useful for fixing critical bugs, recovering lost tokens, and reversing accidental payments to contract.\r\n     */\r\n    /**\r\n     * @notice Use an external contract's logic for internal use.\r\n     * @dev This will make a delegate call and use an external contract's logic, while using internal storage.\r\n     * @param target Address of smart contract to call.\r\n     * @param payload Bytes of the payload to send. Including the 4 byte function hash.\r\n     */\r\n    function delegate (address target, bytes calldata payload) public onlyOwner {\r\n        (bool success, bytes memory data) = target.delegatecall(payload);\r\n        require(success, string(data));\r\n    }\r\n\r\n    /**\r\n     * @notice Lift the imposed purchase limits.\r\n     * @dev Use this function after purchasing is opened to all with no limits.\r\n     */\r\n    function liftPurchaseLimits () public onlyOwner {\r\n        _reserveLifted = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a token from being for sale.\r\n     * @dev If you want to reserve a token, or it is no longer available, make sure to use this function and remove it.\r\n     * @param tokens Array of token ids to remove from being for sale.\r\n     */\r\n    function removeOpenTokens (uint256[] calldata tokens) public onlyOwner {\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            _removeTokenFromAllTokensEnumeration(tokens[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a token id from being reserved by a wallet.\r\n     * @dev If you want to add a token id to for sale list, first remove it from a wallet if it has been reserved.\r\n     * @param wallets Array of wallets for which to remove reserved tokens for.\r\n     */\r\n    function removeReservedTokens (address[] calldata wallets) public onlyOwner {\r\n        for (uint256 i = 0; i < wallets.length; i++) {\r\n            delete _reservedTokens[wallets[i]];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Configure a delegate function call for use.\r\n     * @dev This will allow users to call delegate calls on external contracts to the approved function.\r\n     * @param target Address of smart contract that will be called.\r\n     * @param functionHash Hash of function that will be called.\r\n     * @param value Boolean indicating whether to approve or deny such a call.\r\n     */\r\n    function setApprovedFunction (address target, bytes4 functionHash, bool value) public onlyOwner {\r\n        _approvedFunctions[target][functionHash] = value;\r\n    }\r\n\r\n    /**\r\n     * @notice Set notary wallet address.\r\n     * @dev The notary is used as a way to sign and validate proof of stake function calls.\r\n     * @param notary Address of notary wallet to use.\r\n     */\r\n    function setNotary (address notary) public onlyOwner {\r\n        _notary = notary;\r\n    }\r\n\r\n    /**\r\n     * @notice Add token ids that are available for purchase.\r\n     * @dev These tokens can be either those that still need to be minted, or already minted tokens.\r\n     * @param tokens Array of token ids to add as available for sale.\r\n     */\r\n    function setOpenTokens (uint256[] calldata tokens) public onlyOwner {\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            _addTokenToEnumeration(tokens[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Set prices for each tier.\r\n     * @dev It is recommended to make tier 1 price lowest, and tier 3 price highest.\r\n     * @param claimPrice Amount in wei for Tier 3 purchase price.\r\n     * @param claimPrice Amount in wei for Tier 1 purchase price.\r\n     * @param stakePrice Amount in wei for Tier 2 purchase price.\r\n     */\r\n    function setPrices (uint256 basePrice, uint256 claimPrice, uint256 stakePrice) public onlyOwner {\r\n        _tokenBasePrice = basePrice;\r\n        _tokenClaimPrice = claimPrice;\r\n        _tokenStakePrice = stakePrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Set maximum amount of purchases allowed to be made by a single wallet.\r\n     * @dev This is only enforced if arePurchasesLimited is true. Claims do not count toward purchases.\r\n     * @param limit Amount of token purchases that can be made.\r\n     */\r\n    function setPurchaseLimit (uint256 limit) public onlyOwner {\r\n        _maxPurchases = limit;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the amounts of tokens that have already been purchased by wallets.\r\n     * @dev Use this to add information for sales that occurred outside of this contract.\r\n     * @param wallets Array of wallets to set specific amounts for.\r\n     * @param amounts Array of specific amounts to set for the wallets.\r\n     */\r\n    function setPurchasedTokensAmount (address[] calldata wallets, uint256[] calldata amounts) public onlyOwner {\r\n        for (uint256 i = 0; i < wallets.length; i++) {\r\n            _purchasedTokens[wallets[i]] = amounts[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Set a specific amount of tokens that can be claimed by a wallet.\r\n     * @dev Use this if a wallet is allowed to claim, but no specific token ids have been assigned.\r\n     * @param wallets Array of wallets to add specific amounts for.\r\n     * @param amounts Array of specific amounts to set for the wallets.\r\n     */\r\n    function setReservedTokenAmounts (address[] calldata wallets, uint256[] calldata amounts) public onlyOwner {\r\n        for (uint256 i = 0; i < wallets.length; i++) {\r\n            _reservedTokenAmounts[wallets[i]] = amounts[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Add a token that a wallet is pre-authorized to claim and mint.\r\n     * @dev This function adds to the list of claimable tokens.\r\n     * @param wallets Array of wallets for which to add a token that can be claimed.\r\n     * @param tokens Array of token ids that a wallet can claim.\r\n     */\r\n    function setReservedTokens (address[] calldata wallets, uint256[] calldata tokens) public onlyOwner {\r\n        for (uint256 i = 0; i < wallets.length; i++) {\r\n            _reservedTokens[wallets[i]].push (tokens[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Set the list of tokens that a wallet is pre-authorized to claim and mint.\r\n     * @dev Resets the list of tokens for wallet to new submitted list.\r\n     * @param wallets Array of wallets for which to set the list of tokens that can be claimed.\r\n     * @param tokens Array of token ids that a wallet can claim.\r\n     */\r\n    function setReservedTokensArrays (address[] calldata wallets, uint256[][] calldata tokens) public onlyOwner {\r\n        for (uint256 i = 0; i < wallets.length; i++) {\r\n            _reservedTokens[wallets[i]] = tokens[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Set the time of each tier's activation.\r\n     * @dev Can be changed at any time to push forward/back the activation times of each tier.\r\n     * @param tier1 UNIX timestamp of when Tier 1 activates.\r\n     * @param tier2 UNIX timestamp of when Tier 2 activates.\r\n     * @param tier3 UNIX timestamp of when Tier 3 activates.\r\n     */\r\n    function setTierTimes (uint256 tier1, uint256 tier2, uint256 tier3) public onlyOwner {\r\n        _tier1 = tier1;\r\n        _tier2 = tier2;\r\n        _tier3 = tier3;\r\n    }\r\n\r\n    /**\r\n     * @notice Set a list of wallets as VIP.\r\n     * @dev This allows to have wallets skip claim process and get discounted pricing directly.\r\n     * @param wallets Array of wallets to set as VIPs.\r\n     */\r\n    function setVIPs (address[] calldata wallets) public onlyOwner {\r\n        for (uint256 i = 0; i < wallets.length; i++) {\r\n            _tier1wallets[wallets[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of the smart contract.\r\n     * @dev Can't be transferred to a zero address.\r\n     * @param newOwner Address of new owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(!Address.isZero(newOwner), \"CXIP: zero address\");\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws all smart contract ETH.\r\n     * @dev Can only be called by _admin or _owner. All contract ETH is send to sender.\r\n     */\r\n    function withdrawEth () public onlyOwner {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @notice Call a pre-approved external function.\r\n     * @dev This allows to extend the functionality of the contract, without the need of a complete re-deployment.\r\n     * @param target Address of smart contract to call.\r\n     * @param functionHash Function hash of the external contract function to call.\r\n     * @param payload Entire payload to include in the external call. Keep in mind to not include function hash.\r\n     * @return bytes Returns data of response as raw bytes.\r\n     */\r\n    function delegateApprovedCall (address target, bytes4 functionHash, bytes calldata payload) public returns (bytes memory) {\r\n        require(_approvedFunctions[target][functionHash], \"CXIP: not approved delegate call\");\r\n        (bool success, bytes memory data) = target.delegatecall(abi.encodePacked(functionHash, payload));\r\n        require(success, string(data));\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * @notice Simple function to accept safe transfers.\r\n     * @dev Token transfers that are related to the _tokenContract are automatically added to _allTokens.\r\n     * @param _operator The address of the smart contract that operates the token.\r\n     * @dev Since it's not being used, the _from variable is commented out to avoid compiler warnings.\r\n     * @dev _tokenId Id of the token being transferred in.\r\n     * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\r\n     * @return bytes4 Returns the interfaceId of onERC721Received.\r\n     */\r\n    function onERC721Received(\r\n        address payable _operator,\r\n        address/* _from*/,\r\n        uint256 _tokenId,\r\n        bytes calldata /*_data*/\r\n    ) public returns (bytes4) {\r\n        if (_operator == _tokenContract) {\r\n            if (ISNUFFY500(_operator).ownerOf(_tokenId) == address(this)) {\r\n                _addTokenToEnumeration (_tokenId);\r\n            }\r\n        }\r\n        return 0x150b7a02;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if purchasing is limited.\r\n     * @dev Call getPurchaseLimit if this returns true, to find out purchase limits.\r\n     * @return bool Returns true if purchases are limited.\r\n     */\r\n    function arePurchasesLimited () public view returns (bool) {\r\n        return !_reserveLifted;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the notary wallet address.\r\n     * @dev This wallet is used to sign and validate proof of stake wallets.\r\n     * @return address Returns address of wallet that signs the proof of stake messages.\r\n     */\r\n    function getNotary () public view returns (address) {\r\n        return _notary;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the purchase prices for each tier.\r\n     * @dev VIP wallets that are claiming tokens are not charged a fee.\r\n     * @return basePrice Price of Tier 3 purchases.\r\n     * @return claimPrice Price of Tier 1 purchases.\r\n     * @return stakePrice Price of Tier 2 purchases.\r\n     */\r\n    function getPrices () public view returns (uint256 basePrice, uint256 claimPrice, uint256 stakePrice) {\r\n        basePrice = _tokenBasePrice;\r\n        claimPrice = _tokenClaimPrice;\r\n        stakePrice = _tokenStakePrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Get maximum number of tokens that can be purchased.\r\n     * @dev Used in conjunction with arePurchasesLimited function.\r\n     * @return uint256 Returns the maximum amount of tokens that can be purchased at the moment.\r\n     */\r\n    function getPurchaseLimit() public view returns (uint256) {\r\n        return _maxPurchases;\r\n    }\r\n\r\n    /**\r\n     * @notice Check how many tokens have been purchased by a wallet.\r\n     * @dev Used in conjunction with arePurchasesLimited function.\r\n     * @param wallet Address of wallet in question.\r\n     * @return uint256 Returns number of tokens that a wallet has already claimed/minted.\r\n     */\r\n    function getPurchasedTokensAmount (address wallet) public view returns (uint256) {\r\n        return _purchasedTokens[wallet];\r\n    }\r\n\r\n    /**\r\n     * @notice Check how many free token claims are available for a wallet.\r\n     * @dev These are not token id locked claims.\r\n     * @param wallet Address of wallet in question.\r\n     * @return uint256 Returns the number of free claims available.\r\n     */\r\n    function getReservedTokenAmounts(address wallet) public view returns (uint256) {\r\n        return _reservedTokenAmounts[wallet];\r\n    }\r\n\r\n    /**\r\n     * @notice Check if there are any tokens specifically reserved for a wallet.\r\n     * @dev Helpful function for front-end UI development.\r\n     * @param wallet Address of the wallet to check.\r\n     * @return uint256[] Returns an array of token ids that are reserved for that wallet to claim.\r\n     */\r\n    function getReservedTokens(address wallet) public view returns (uint256[] memory) {\r\n        return _reservedTokens[wallet];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the timestamps for when each tier is activated.\r\n     * @dev Check if a tier is active, meaning that relevant functions will work.\r\n     * @return tier1 UNIX timestamp of when Tier 1 activates.\r\n     * @return tier2 UNIX timestamp of when Tier 2 activates.\r\n     * @return tier3 UNIX timestamp of when Tier 3 activates.\r\n     */\r\n    function getTierTimes () public view returns (uint256 tier1, uint256 tier2, uint256 tier3) {\r\n        tier1 = _tier1;\r\n        tier2 = _tier2;\r\n        tier3 = _tier3;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the sender is the owner.\r\n     * @dev The owner could also be the admin.\r\n     * @return bool Returns true if owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return (msg.sender == _owner || msg.sender == _admin);\r\n    }\r\n\r\n    /**\r\n     * @notice Check if a wallet is VIP.\r\n     * @dev Any wallet that was whitelisted for specific tokenId or amount, is marked as VIP after first claim.\r\n     * @param wallet Address of wallet in question.\r\n     * @return bool Returns true if wallet is VIP.\r\n     */\r\n    function isVIP (address wallet) public view returns (bool) {\r\n        return _tier1wallets[wallet];\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the owner's address.\r\n     * @dev _owner is first set in init.\r\n     * @return address Returns the address of owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @notice Get token by index.\r\n     * @dev Used in conjunction with totalSupply function to iterate over all tokens in collection.\r\n     * @param index Index of token in array.\r\n     * @return uint256 Returns the token id of token located at that index.\r\n     */\r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        require(index < totalSupply(), \"CXIP: index out of bounds\");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Get x amount of token ids, starting from index x.\r\n     * @dev Can be used as pagination, to not have to get each token id through separate call.\r\n     * @param start Index from which to start from.\r\n     * @param length Total number of items to read in array.\r\n     * @return tokens Returns an array of token ids.\r\n     */\r\n    function tokensByChunk(uint256 start, uint256 length) public view returns (uint256[] memory tokens) {\r\n        if (start + length > totalSupply()) {\r\n            length = totalSupply() - start;\r\n        }\r\n        tokens = new uint256[](length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            tokens[i] = _allTokens[start + i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Total amount of tokens available for sale.\r\n     * @dev Does not include/count reserved tokens.\r\n     * @return uint256 Returns the total number of available tokens.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Shows the interfaces the contracts support\r\n     * @dev Must add new 4 byte interface Ids here to acknowledge support\r\n     * @param interfaceId ERC165 style 4 byte interfaceId.\r\n     * @return bool True if supported.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\r\n        if (\r\n            interfaceId == 0x01ffc9a7 || // ERC165\r\n            interfaceId == 0x150b7a02    // ERC721TokenReceiver\r\n        ) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add a newly added token into managed list of tokens.\r\n     * @param tokenId Id of token to add.\r\n     */\r\n    function _addTokenToEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer all smart contract ETH to token contract's Identity contract.\r\n     */\r\n    function _moveEth() internal {\r\n        uint256 amount = address(this).balance;\r\n        payable(ISNUFFY500(_tokenContract).getIdentity()).transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a token from managed list of tokens.\r\n     * @param tokenId Id of token to remove.\r\n     */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        uint256 lastTokenIndex = _allTokens.length - 1;\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n        _allTokens[tokenIndex] = lastTokenId;\r\n        _allTokensIndex[lastTokenId] = tokenIndex;\r\n        delete _allTokensIndex[tokenId];\r\n        delete _allTokens[lastTokenIndex];\r\n        _allTokens.pop();\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the token is in our possession.\r\n     * @dev We check that returned value actually matches the tokenId, to avoid zero index issue.\r\n     * @param tokenId The token in question.\r\n     * @return bool Returns true if token exists.\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        return _allTokens[_allTokensIndex[tokenId]] == tokenId;\r\n    }\r\n\r\n}\r\n\r\n\r\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\r\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\r\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\r\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\r\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\r\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\r\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\r\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\r\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\r\n    }\r\n\r\n    function isZero(address account) internal pure returns (bool) {\r\n        return (account == address(0));\r\n    }\r\n}\r\n\r\n\r\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\r\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\r\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\r\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\r\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\r\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\r\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\r\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\r\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\r\n\r\nlibrary Signature {\r\n    function Derive(\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v,\r\n        bytes memory encoded\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            address derived1,\r\n            address derived2,\r\n            address derived3,\r\n            address derived4\r\n        )\r\n    {\r\n        bytes32 encoded32;\r\n        assembly {\r\n            encoded32 := mload(add(encoded, 32))\r\n        }\r\n        derived1 = ecrecover(encoded32, v, r, s);\r\n        derived2 = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", encoded32)), v, r, s);\r\n        encoded32 = keccak256(encoded);\r\n        derived3 = ecrecover(encoded32, v, r, s);\r\n        encoded32 = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", encoded32));\r\n        derived4 = ecrecover(encoded32, v, r, s);\r\n    }\r\n\r\n    function PackMessage(bytes memory encoded, bool geth) internal pure returns (bytes32) {\r\n        bytes32 hash = keccak256(encoded);\r\n        if (geth) {\r\n            hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n        }\r\n        return hash;\r\n    }\r\n\r\n    function Valid(\r\n        address target,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v,\r\n        bytes memory encoded\r\n    ) internal pure returns (bool) {\r\n        bytes32 encoded32;\r\n        address derived;\r\n        if (encoded.length == 32) {\r\n            assembly {\r\n                encoded32 := mload(add(encoded, 32))\r\n            }\r\n            derived = ecrecover(encoded32, v, r, s);\r\n            if (target == derived) {\r\n                return true;\r\n            }\r\n            derived = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", encoded32)), v, r, s);\r\n            if (target == derived) {\r\n                return true;\r\n            }\r\n        }\r\n        bytes32 hash = keccak256(encoded);\r\n        derived = ecrecover(hash, v, r, s);\r\n        if (target == derived) {\r\n            return true;\r\n        }\r\n        hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n        derived = ecrecover(hash, v, r, s);\r\n        return target == derived;\r\n    }\r\n}\r\n\r\n\r\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\r\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\r\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\r\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\r\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\r\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\r\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\r\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\r\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\r\n\r\nstruct Verification {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n}\r\n\r\n\r\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\r\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\r\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\r\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\r\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\r\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\r\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\r\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\r\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\r\n\r\nstruct TokenData {\r\n    bytes32 payloadHash;\r\n    Verification payloadSignature;\r\n    address creator;\r\n    bytes32 arweave;\r\n    bytes11 arweave2;\r\n    bytes32 ipfs;\r\n    bytes14 ipfs2;\r\n}\r\n\r\n\r\n/*\r\n\r\n            O\r\n            _\r\n     ---\\ _|.|_ /---\r\n      ---|  |  |---\r\n         |_/ \\_|\r\n          |   |\r\n          |   |\r\n          |___|\r\n           | |\r\n           / \\\r\n\r\n       SNUFFY 500\r\n\r\n*/\r\n\r\ninterface ISNUFFY500 {\r\n\r\n    function mint(uint256 state, uint256 tokenId, TokenData[] memory tokenData, address signer, Verification memory verification, address recipient) external;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) external;\r\n\r\n    function balanceOf(address wallet) external view returns (uint256);\r\n\r\n    function exists(uint256 tokenId) external view returns (bool);\r\n\r\n    function getIdentity() external view returns (address);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"notary\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"autoWithdraw\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxPurchases\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"arePurchasesLimited\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"buyToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"payloadSignature\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"arweave\",\"type\":\"bytes32\"},{\"internalType\":\"bytes11\",\"name\":\"arweave2\",\"type\":\"bytes11\"},{\"internalType\":\"bytes32\",\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"internalType\":\"bytes14\",\"name\":\"ipfs2\",\"type\":\"bytes14\"}],\"internalType\":\"struct TokenData[]\",\"name\":\"tokenData\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"verification\",\"type\":\"tuple\"}],\"name\":\"claimAndMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"clearReservedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"functionHash\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"delegateApproved\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"functionHash\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"delegateApprovedCall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNotary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakePrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPurchaseLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getPurchasedTokensAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getReservedTokenAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getReservedTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTierTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tier1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tier2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tier3\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"isVIP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liftPurchaseLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"payloadSignature\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"arweave\",\"type\":\"bytes32\"},{\"internalType\":\"bytes11\",\"name\":\"arweave2\",\"type\":\"bytes11\"},{\"internalType\":\"bytes32\",\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"internalType\":\"bytes14\",\"name\":\"ipfs2\",\"type\":\"bytes14\"}],\"internalType\":\"struct TokenData[]\",\"name\":\"tokenData\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"verification\",\"type\":\"tuple\"}],\"name\":\"payAndMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"proof\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"payloadSignature\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"arweave\",\"type\":\"bytes32\"},{\"internalType\":\"bytes11\",\"name\":\"arweave2\",\"type\":\"bytes11\"},{\"internalType\":\"bytes32\",\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"internalType\":\"bytes14\",\"name\":\"ipfs2\",\"type\":\"bytes14\"}],\"internalType\":\"struct TokenData[]\",\"name\":\"tokenData\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"verification\",\"type\":\"tuple\"}],\"name\":\"proofOfStakeAndMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"removeOpenTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"removeReservedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"functionHash\",\"type\":\"bytes4\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setApprovedFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"notary\",\"type\":\"address\"}],\"name\":\"setNotary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"setOpenTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakePrice\",\"type\":\"uint256\"}],\"name\":\"setPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setPurchaseLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"setPurchasedTokensAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"setReservedTokenAmounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"setReservedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"tokens\",\"type\":\"uint256[][]\"}],\"name\":\"setReservedTokensArrays\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tier1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tier2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tier3\",\"type\":\"uint256\"}],\"name\":\"setTierTimes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"setVIPs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"tokensByChunk\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NFTBroker", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://689218d61d00b41391ee80869cfc3136816d5c22c967ee2633d05f345d98cbcc"}]}