{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/RedeemBBTV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.13;\\n\\nimport { IERC20     } from \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Owned      } from \\\"solmate/auth/Owned.sol\\\";\\nimport { ICNV       } from \\\"./ICNV.sol\\\";\\nimport { IRedeemBBT } from \\\"./IRedeemBBT.sol\\\";\\n\\ncontract RedeemBBTV2 is Owned {\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    // EVENTS\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    // @notice Emitted when a BBT redemption happens.\\n    event Redemption(\\n        address indexed _from,\\n        uint256 indexed _amount\\n    );\\n\\n    // @notice Emitted when contract is paused/unpaused\\n    event Paused (\\n        address indexed caller,\\n        bool isPaused\\n    );\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    // MUTABLE STATE\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice address of bbtCNV Token\\n    address public immutable bbtCNV;\\n    /// @notice address of CNV Token\\n    address public immutable CNV;\\n    /// @notice address of RedeemBBT V1\\n    address public immutable redeemBBTV1;\\n    /// @notice mapping of how many CNV tokens a bbtCNV holder has redeemed\\n    mapping(address => uint256) public redeemed;\\n    /// @notice redeem paused;\\n    bool public paused;\\n    \\n    ////////////////////////////////////////////////////////////////////////////\\n    // IMMUTABLE STATE\\n    ////////////////////////////////////////////////////////////////////////////\\n    \\n    string internal constant NONE = \\\"NONE LEFT\\\";\\n    uint256 internal constant JUNE_5_2022 = 1654387200;\\n    uint256 internal constant APRIL_1_2023 = 1680307200;\\n\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    // CONSTRUCTOR\\n    ////////////////////////////////////////////////////////////////////////////\\n    \\n    // Better to use cosntants for production here. \\n    constructor(\\n        address _bbtCNV, \\n        address _CNV, \\n        address _redeemBBTV1\\n    ) Owned(msg.sender) {\\n        bbtCNV = _bbtCNV;\\n        CNV = _CNV;\\n        redeemBBTV1 = _redeemBBTV1;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    // ADMIN/MGMT\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    function setPause(\\n        bool _paused\\n    ) external onlyOwner {\\n        paused = _paused;\\n        emit Paused(msg.sender, _paused);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    // ACTIONS\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice             redeem bbtCNV for CNV following vesting schedule\\n    /// @param  _amount     amount of CNV to redeem, irrelevant if _max = true\\n    /// @param  _to         address to which to mint CNV\\n    /// @param  _max        whether to redeem maximum amount possible\\n    /// @return amountOut   amount of CNV tokens to be minted to _to\\n    function redeem(\\n        uint256 _amount, \\n        address _to, \\n        bool _max\\n    ) external returns (uint256 amountOut) {\\n        // Check if it's paused\\n        require(!paused, \\\"PAUSED\\\");\\n        // Get user bbtCNV balance, and get amount already redeemed.\\n        // If already redeemed full balance - revert on \\\"FULLY_REDEEMED\\\" since\\n        // all balance has already been redeemed.\\n        uint256 bbtCNVBalance = IERC20(bbtCNV).balanceOf(msg.sender);\\n        uint256 amountRedeemed = redeemed[msg.sender] + IRedeemBBT(redeemBBTV1).redeemed(msg.sender);\\n        require(bbtCNVBalance > amountRedeemed, NONE);\\n\\n        // Check how much is currently vested for user.\\n        // Revert if currently no more available to redeem.\\n        uint256 currentTime = block.timestamp;\\n        require(currentTime >= JUNE_5_2022, \\\"NOT_VESTED\\\");\\n        uint256 amountVested;\\n        \\n        if (currentTime > APRIL_1_2023) {\\n            amountVested = bbtCNVBalance;\\n        } else {\\n            uint256 vpct = vestedPercent(currentTime);\\n            amountVested = bbtCNVBalance * vpct / 1e18;\\n        }\\n        \\n        require(amountVested > amountRedeemed, NONE);\\n\\n        // Calculate amount redeemable as the amountVested minus the amount that\\n        // has previously been redeemed.\\n        // If _max was not selected and thus a specified amount is to be\\n        // redeemed, ensure this amount doesn't exceed amountRedeemable.\\n        uint256 amountRedeemable = amountVested - amountRedeemed;\\n        amountOut = amountRedeemable;\\n        if (!_max) {\\n            require(amountRedeemable >= _amount,\\\"EXCEEDS\\\");\\n            amountOut = _amount;\\n        }\\n\\n        // Update state to reflect redemption.\\n        redeemed[msg.sender] += amountOut;\\n\\n        // Transfer CNV\\n        ICNV(CNV).transfer(_to, amountOut);\\n\\n        emit Redemption(msg.sender, amountOut);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    // VIEW\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice         to view how much a holder has redeemable\\n    /// @param  _who    bbtHolder address\\n    /// @return         amount redeemable\\n    function redeemable(\\n        address _who\\n    ) external view returns (uint256) {\\n        uint256 bbtCNVBalance = IERC20(bbtCNV).balanceOf(_who);\\n        uint256 amountRedeemed = redeemed[_who] + IRedeemBBT(redeemBBTV1).redeemed(_who);\\n        if (bbtCNVBalance == amountRedeemed) return 0;\\n\\n        uint256 currentTime = block.timestamp;\\n        if (currentTime < JUNE_5_2022) return 0;\\n\\n        uint256 amountVested;\\n        if (currentTime > APRIL_1_2023) {\\n            amountVested = bbtCNVBalance;\\n        } else {\\n            uint256 vpct = vestedPercent(currentTime);\\n            amountVested = bbtCNVBalance * vpct / 1e18;\\n        }\\n        if (amountVested <= amountRedeemed) return 0;\\n\\n        return amountVested - amountRedeemed;\\n    }\\n\\n    /// @notice         returns the percent of holdings vested for a given point\\n    ///                 in time.\\n    /// @param  _time   point in time\\n    /// @return vpct    percent of holdings vested\\n    function vestedPercent(\\n        uint256 _time\\n    ) public pure returns (uint256 vpct) {\\n        // Hardcode variables in method to avoid state reads and save gas.\\n        //\\n        // vestingTimeStart\\n        // - time vesting begins: JUNE_5_2022 (Sun Jun 05 2022 00:00:00 GMT+0000)\\n        //\\n        // vestingTimeLength\\n        // - duration of vesting: 25920000 (10 30-day months)\\n        //\\n        // vestingAmountStart\\n        // - vesting begins at 2%\\n        //\\n        // vestingAmountLength\\n        // - vesting grows to 100%, thus has a length of 98\\n\\n        uint256 vestingTimeStart    = JUNE_5_2022;\\n        uint256 vestingTimeLength   = 25920000;\\n        uint256 vestingAmountStart  = 2e16;\\n        uint256 vestingAmountLength = 98e16;\\n\\n        uint256 pctOf = _percentOf(vestingTimeStart, _time, vestingTimeLength);\\n        vpct = _linearMapping(vestingAmountStart, pctOf, vestingAmountLength);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    // INTERNAL\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice             returns the elapsed percentage of a point within\\n    ///                     a given range\\n    /// @param  _start      starting point\\n    /// @param  _point      current point\\n    /// @param  _length     lenght\\n    /// @return elapsedPct  percent from _start\\n    function _percentOf(\\n        uint256 _start, \\n        uint256 _point, \\n        uint256 _length\\n    ) internal pure returns(uint256 elapsedPct) {\\n        uint256 elapsed             = _point - _start;\\n                elapsedPct          = elapsed * 1e18 / _length;\\n    }\\n\\n    /// @notice             linearly maps a percentage point to a range\\n    /// @param  _start      starting point\\n    /// @param  _pct        percentage point\\n    /// @param  _length     lenght\\n    /// @return point       point\\n    function _linearMapping(\\n        uint256 _start, \\n        uint256 _pct, \\n        uint256 _length\\n    ) internal pure returns (uint256 point) {\\n        uint256 elapsed             = _length * _pct / 1e18;\\n                point               = _start + elapsed;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnerUpdated(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setOwner(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ICNV.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\nimport {IERC20} from \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface ICNV is IERC20 {\\n    function mint(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/IRedeemBBT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\n\\ninterface IRedeemBBT {\\n\\n    /// @notice mapping of how many CNV tokens a bbtCNV holder has redeemed\\n    /// @param      _who    address\\n    /// @return     amount  amount redeemed so far\\n    function redeemed(address _who)\\n        external\\n        view\\n        returns(uint256 amount);\\n\\n    /// @notice             redeem bbtCNV for CNV following vesting schedule\\n    /// @param  _amount     amount of CNV to redeem, irrelevant if _max = true\\n    /// @param  _who        address of bbtCNV holder to redeem\\n    /// @param  _to         address to which to mint CNV\\n    /// @param  _max        whether to redeem maximum amount possible\\n    /// @return amountOut   amount of CNV tokens to be minted to _to\\n    function redeem(uint256 _amount, address _who, address _to, bool _max)\\n        external\\n        returns(uint256 amountOut);\\n\\n    /// @notice         to view how much a holder has redeemable\\n    /// @param  _who    bbtHolder address\\n    /// @return         amount redeemable\\n    function redeemable(address _who)\\n        external\\n        view\\n        returns(uint256);\\n\\n    /// @notice         returns the percent of holdings vested for a given point\\n    ///                 in time.\\n    /// @param  _time   point in time\\n    /// @return vpct    percent of holdings vested\\n    function vestedPercent(uint256 _time)\\n        external\\n        pure\\n        returns(uint256 vpct);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\"\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bbtCNV\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_CNV\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_redeemBBTV1\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Redemption\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CNV\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bbtCNV\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_max\",\"type\":\"bool\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemBBTV1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"redeemable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"redeemed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"vestedPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vpct\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "RedeemBBTV2", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000012a0592c154d552c410030e724b2ea00000000000000000000000000000000007a58f5f58e697e51ab0357bc9e260a040000000000000000000000007fcc30e97d718864d46a84f13e3ba111a56123d3", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}