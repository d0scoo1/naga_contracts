{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: CC-BY-ND-4.0\r\n\r\npragma solidity ^0.8.7;\r\n\r\ninterface IUniswapV2Router01 {\r\n  function factory() external pure returns (address);\r\n  function WETH() external pure returns (address);\r\n\r\n  function addLiquidity(\r\n      address tokenA,\r\n      address tokenB,\r\n      uint amountADesired,\r\n      uint amountBDesired,\r\n      uint amountAMin,\r\n      uint amountBMin,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint amountA, uint amountB, uint liquidity);\r\n  function addLiquidityETH(\r\n      address token,\r\n      uint amountTokenDesired,\r\n      uint amountTokenMin,\r\n      uint amountETHMin,\r\n      address to,\r\n      uint deadline\r\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n  function removeLiquidity(\r\n      address tokenA,\r\n      address tokenB,\r\n      uint liquidity,\r\n      uint amountAMin,\r\n      uint amountBMin,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint amountA, uint amountB);\r\n  function removeLiquidityETH(\r\n      address token,\r\n      uint liquidity,\r\n      uint amountTokenMin,\r\n      uint amountETHMin,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint amountToken, uint amountETH);\r\n  function removeLiquidityWithPermit(\r\n      address tokenA,\r\n      address tokenB,\r\n      uint liquidity,\r\n      uint amountAMin,\r\n      uint amountBMin,\r\n      address to,\r\n      uint deadline,\r\n      bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n  ) external returns (uint amountA, uint amountB);\r\n  function removeLiquidityETHWithPermit(\r\n      address token,\r\n      uint liquidity,\r\n      uint amountTokenMin,\r\n      uint amountETHMin,\r\n      address to,\r\n      uint deadline,\r\n      bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n  ) external returns (uint amountToken, uint amountETH);\r\n  function swapExactTokensForTokens(\r\n      uint amountIn,\r\n      uint amountOutMin,\r\n      address[] calldata path,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n  function swapTokensForExactTokens(\r\n      uint amountOut,\r\n      uint amountInMax,\r\n      address[] calldata path,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n      external\r\n      payable\r\n      returns (uint[] memory amounts);\r\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n      external\r\n      returns (uint[] memory amounts);\r\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n      external\r\n      returns (uint[] memory amounts);\r\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n      external\r\n      payable\r\n      returns (uint[] memory amounts);\r\n\r\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n  function allPairs(uint) external view returns (address pair);\r\n  function allPairsLength() external view returns (uint);\r\n\r\n  function feeTo() external view returns (address);\r\n  function feeToSetter() external view returns (address);\r\n\r\n  function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n  function name() external pure returns (string memory);\r\n  function symbol() external pure returns (string memory);\r\n  function decimals() external pure returns (uint8);\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address owner) external view returns (uint);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n  function nonces(address owner) external view returns (uint);\r\n\r\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n  event Mint(address indexed sender, uint amount0, uint amount1);\r\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n  event Swap(\r\n      address indexed sender,\r\n      uint amount0In,\r\n      uint amount1In,\r\n      uint amount0Out,\r\n      uint amount1Out,\r\n      address indexed to\r\n  );\r\n  event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n  function factory() external view returns (address);\r\n  function token0() external view returns (address);\r\n  function token1() external view returns (address);\r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n  function price0CumulativeLast() external view returns (uint);\r\n  function price1CumulativeLast() external view returns (uint);\r\n  function kLast() external view returns (uint);\r\n\r\n  function mint(address to) external returns (uint liquidity);\r\n  function burn(address to) external returns (uint amount0, uint amount1);\r\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n  function skim(address to) external;\r\n  function sync() external;\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function decimals() external view returns(uint);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\ncontract token_price {\r\n\r\n    /// @dev Native token paired price for target\r\n    function getTokenPrice(address pairAddress, uint amount) public view returns(uint)\r\n            {\r\n                IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\r\n                ERC20 token1 = ERC20(pair.token1());\r\n            \r\n            \r\n                (uint Res0, uint Res1,) = pair.getReserves();\r\n\r\n                // decimals\r\n                uint res0 = Res0*(10**token1.decimals());\r\n                return((amount*res0)/Res1); // return amount of token0 needed to buy token1\r\n        }\r\n    \r\n    /// @dev USDC based price took from reserves\r\n    function get_price_in_usd(address tkn) private view returns(uint usd) {\r\n        address _router_address = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n        IUniswapV2Factory factory = IUniswapV2Factory(IUniswapV2Router02(_router_address).factory());\r\n        address pair = factory.getPair(IUniswapV2Router02(_router_address).WETH(), tkn);\r\n        uint tken_price = getTokenPrice(pair, 1);\r\n        address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n        address usd_eth_pair = factory.getPair(USDC, IUniswapV2Router02(_router_address).WETH());\r\n        uint eth_price = getTokenPrice(usd_eth_pair, 1);\r\n        uint final_price = eth_price * tken_price;\r\n        return final_price;\r\n    }\r\n}\r\n\r\n/// @dev This contract allows to have reentrancy protection and ownership based protection in a\r\n/// gas efficient way without unnecessary definitions or bloatings\r\n/// author: tcsenpai aka pci aka drotodev\r\ncontract protected {\r\n\r\n    mapping (address => bool) is_auth;\r\n\r\n    function authorized(address addy) public view returns(bool) {\r\n        return is_auth[addy];\r\n    }\r\n\r\n    function set_authorized(address addy, bool booly) public onlyAuth {\r\n        is_auth[addy] = booly;\r\n    }\r\n\r\n    modifier onlyAuth() {\r\n        require( is_auth[msg.sender] || msg.sender==owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    address owner;\r\n    modifier onlyOwner() {\r\n        require(msg.sender==owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    bool locked;\r\n    modifier safe() {\r\n        require(!locked, \"reentrant\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    function change_owner(address new_owner) public onlyAuth {\r\n        owner = new_owner;\r\n    }\r\n\r\n    receive() external payable {}\r\n    fallback() external payable {}\r\n}\r\n\r\ncontract KaibexLimit is protected, token_price {\r\n\r\n    /// @notice The structure part shows how an order is managed\r\n    /// by first getting the univoque virtualized account of the \r\n    /// actor and then by creating the ORDER structure.\r\n    /// Once this is done, the struct of the virtual account is updated.\r\n\r\n    struct ORDER {\r\n        uint exec_price;\r\n        uint[] tp_prices;\r\n        uint[] sl_prices;\r\n        bool direction; // true = buy, false = sell\r\n        uint qty;\r\n        bytes32 virtual_actor; \r\n        address token;   \r\n    }\r\n\r\n    struct ACCOUNT {\r\n        bytes32[] vtx_list;\r\n    }\r\n\r\n    mapping(bytes32 => ACCOUNT) virtual_account;\r\n    mapping(bytes32 => address) reverse_virtual_account;\r\n    mapping(bytes32 => ORDER) virtual_tx;\r\n\r\n    address uniswap_router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    IUniswapV2Router02 router;\r\n    \r\n    /// @notice Tokens and interfaces definition for paywall\r\n    address fang;\r\n    address kaiba;\r\n    ERC20 fang_token;\r\n    ERC20 kaiba_token;\r\n    uint min_kaiba;\r\n    uint min_fang;\r\n\r\n    /// @notice Middleware related wallet\r\n    address limit_account;\r\n\r\n    /// @notice Events definition\r\n    event limit_buy(uint price, uint amount, address tkn, address sender, bytes32 txhash);\r\n    event limit_sell(uint price, uint amount, address tkn, address sender, bytes32 txhash);\r\n    event set_tp(uint price, uint amount, address tkn, address sender, bytes32 txhash);\r\n    event set_sl(uint price, uint amount, address tkn, address sender, bytes32 txhash);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        is_auth[owner] = true;\r\n        is_auth[0xaD9748dd4E3a58A0083CF83Fb710F6890bD14736] = true;\r\n        router = IUniswapV2Router02(uniswap_router);\r\n    }\r\n\r\n    /****************************** PRIVATE WRITES ***********************************/\r\n\r\n    /// @dev limit_account operated order\r\n    function execute_buy(bytes32 order) payable public onlyAuth {\r\n        address[] memory path;\r\n        path[0] = (router.WETH());\r\n        path[1] = (virtual_tx[order].token);\r\n        uint qty = virtual_tx[order].qty;\r\n        require(msg.value==qty, \"Wrong value\");\r\n        address recipient = reverse_virtual_account[virtual_tx[order].virtual_actor];\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens {value: msg.value}(\r\n            0,\r\n            path,\r\n            recipient,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /// @dev limit_account operated order\r\n    function execute_sell(bytes32 order) payable public onlyAuth {\r\n        address[] memory path;\r\n        path[0] = (virtual_tx[order].token);\r\n        path[1] = (router.WETH());\r\n        uint qty = virtual_tx[order].qty;\r\n        address recipient = reverse_virtual_account[virtual_tx[order].virtual_actor];\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens (\r\n            qty,\r\n            0,\r\n            path,\r\n            recipient,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /// @dev Target account that operates in the middleware\r\n    function set_limit_account(address la) public onlyAuth {\r\n        limit_account = la;\r\n        is_auth[limit_account] = true;\r\n    }\r\n\r\n    function electrode() public onlyAuth {\r\n        selfdestruct(payable(msg.sender));\r\n    }\r\n\r\n    /****************************** PRIVATE VIEWS ***********************************/\r\n\r\n     \r\n    /****************************** PUBLIC WRITES ***********************************/\r\n\r\n    modifier paywalled() {\r\n        require(kaiba_token.balanceOf(msg.sender) >= min_kaiba);\r\n        require(fang_token.balanceOf(msg.sender) >= min_fang);\r\n        _;\r\n    }\r\n\r\n    /// @dev Payable function: keeps native token reserved for the order\r\n    function set_limit_buy(address tkn, uint price) payable public paywalled returns (bytes32 txhash_) {\r\n        bytes32 txhash = get_virtual_tx(msg.sender, tkn, price, true, msg.value);\r\n        virtual_tx[txhash].exec_price = price;\r\n        virtual_tx[txhash].qty = msg.value;\r\n        virtual_tx[txhash].direction = true;\r\n        bytes32 vaccount = get_virtual_account(msg.sender);\r\n        virtual_account[vaccount].vtx_list.push(txhash);\r\n        emit limit_buy(price, msg.value, tkn, msg.sender, txhash);\r\n        return txhash;\r\n    }\r\n\r\n    /// @dev Allowance based function: keeps target token reserved for the order\r\n    function set_limit_sell(address tkn, uint price, uint qty) public paywalled returns (bytes32 txhash_) {\r\n        bytes32 txhash = get_virtual_tx(msg.sender, tkn, price, false, qty);\r\n        require(ERC20(tkn).allowance(msg.sender, address(this)) >= qty, \"Allowance\");\r\n        ERC20(tkn).transferFrom(msg.sender, address(this), qty);\r\n        virtual_tx[txhash].exec_price = price;\r\n        virtual_tx[txhash].qty = qty;\r\n        virtual_tx[txhash].direction = false;\r\n        bytes32 vaccount = get_virtual_account(msg.sender);\r\n        virtual_account[vaccount].vtx_list.push(txhash);\r\n        emit limit_sell(price, qty ,tkn, msg.sender, txhash);\r\n        return txhash;\r\n    }\r\n\r\n    function set_tp_on_order(address tkn, uint price, uint perc, bytes32 txhash_) public paywalled {\r\n    }\r\n\r\n    function set_sl_on_order(address tkn, uint price, uint perc, bytes32 txhash_) public paywalled {\r\n    }\r\n\r\n\r\n\r\n    /// @dev Keep in mind where kaiba is\r\n    function set_kaiba(address k) public onlyAuth {\r\n        kaiba = k;\r\n        kaiba_token = ERC20(k);\r\n    }\r\n\r\n    /// @dev Keep in mind where fang is\r\n    function set_fang(address f) public onlyAuth {\r\n        fang = f;\r\n        fang_token = ERC20(f);\r\n    }\r\n\r\n    /// @dev Define paywall limits in kaiba\r\n    function set_min_kaiba(uint mk) public onlyAuth {\r\n        min_kaiba = mk;\r\n    }\r\n\r\n    /// @dev Define paywall limits in fang\r\n    function set_min_fang(uint mf) public onlyAuth {\r\n        min_fang = mf;\r\n    }\r\n\r\n    /****************************** PUBLIC VIEWS ***********************************/\r\n\r\n    /// @dev Get the unique virtual account hash for a given actor\r\n    function get_virtual_account(address actor) public view returns(bytes32 vaccount) {\r\n        return keccak256(abi.encode(actor, address(this)));\r\n    }\r\n\r\n    function get_virtual_tx(address sender, address tkn, uint price, bool buy, uint qty) public pure returns(bytes32 txhash_) {\r\n        return keccak256(abi.encode(sender, qty, tkn, price, buy));\r\n    }\r\n\r\n\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txhash\",\"type\":\"bytes32\"}],\"name\":\"limit_buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txhash\",\"type\":\"bytes32\"}],\"name\":\"limit_sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txhash\",\"type\":\"bytes32\"}],\"name\":\"set_sl\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txhash\",\"type\":\"bytes32\"}],\"name\":\"set_tp\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"change_owner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"electrode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"order\",\"type\":\"bytes32\"}],\"name\":\"execute_buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"order\",\"type\":\"bytes32\"}],\"name\":\"execute_sell\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"actor\",\"type\":\"address\"}],\"name\":\"get_virtual_account\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"vaccount\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"buy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"}],\"name\":\"get_virtual_tx\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"txhash_\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"set_authorized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"}],\"name\":\"set_fang\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"k\",\"type\":\"address\"}],\"name\":\"set_kaiba\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"la\",\"type\":\"address\"}],\"name\":\"set_limit_account\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"set_limit_buy\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"txhash_\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"}],\"name\":\"set_limit_sell\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"txhash_\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mf\",\"type\":\"uint256\"}],\"name\":\"set_min_fang\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mk\",\"type\":\"uint256\"}],\"name\":\"set_min_kaiba\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perc\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"txhash_\",\"type\":\"bytes32\"}],\"name\":\"set_sl_on_order\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perc\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"txhash_\",\"type\":\"bytes32\"}],\"name\":\"set_tp_on_order\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "KaibexLimit", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://36ef3df2957a38e0f9428b5bdcad68eeaafe92f403218d9dd557c6fd17b97cdf"}]}