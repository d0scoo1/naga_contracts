{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: contracts/v1/NFTBulkSaleV1.sol\r\n\r\n\r\npragma solidity 0.8.11;\r\npragma abicoder v2;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20Upgradeable {\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n}\r\n\r\ncontract INFT {\r\n\r\n    function getTokenSaleInfo(uint256 tokenId) external view returns(bool isOnSale, bool exists, SaleInfo memory data, address owner) {}\r\n    function mintAndDistribute(uint256[] memory tokenIds, address[] memory addresses) external {\r\n    \r\n    }\r\n    struct SaleInfo { \r\n        uint64 onSaleUntil; \r\n        address currency;\r\n        uint256 price;\r\n    }\r\n    struct CommissionData {\r\n        uint64 value;\r\n        address recipient;\r\n    }\r\n\r\n    struct SeriesInfo { \r\n        address payable author;\r\n        uint32 limit;\r\n        SaleInfo saleInfo;\r\n        CommissionData commission;\r\n        string baseURI;\r\n        string suffix;\r\n    }\r\n\r\n    // version2\r\n    //mapping (uint64 => INFT.SeriesInfo) public seriesInfo;  // seriesId => SeriesInfo\r\n    //function seriesInfo(uint64 seriesId) external view returns(SeriesInfo memory);\r\n    // version 1\r\n    mapping (uint256 => INFT.SeriesInfo) public seriesInfo;  // seriesId => SeriesInfo\r\n    //function seriesInfo(uint256 seriesId) external view returns(SeriesInfo memory);\r\n    \r\n}\r\n\r\ninterface Ownable {\r\n/**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() external view returns (address);\r\n}\r\n\r\ncontract NFTBulkSaleV1{\r\n   \r\n    /**\r\n    * expects:\r\n    * - all tokenIds belong to the same series and owner for each token able to primary sale (token owner == address(0))\r\n    */\r\n    function distribute(\r\n        address nftAddress,\r\n        uint256[] memory tokenIds, \r\n        address[] memory addresses\r\n    ) \r\n        public \r\n        payable\r\n    {\r\n\r\n\r\n        require(tokenIds.length != 0 && tokenIds.length == addresses.length);\r\n        \r\n        uint256 tokenId = tokenIds[0];\r\n        uint256 seriesId = uint256(tokenId >> 192);//getSeriesId(tokenId);\r\n\r\n        address payable author;\r\n        uint32 limit;\r\n        INFT.SaleInfo memory saleInfo;\r\n        INFT.CommissionData memory commission;\r\n        string memory baseURI;\r\n        string memory suffix;\r\n\r\n        //seriesInfo \r\n        (author, limit, saleInfo, commission, baseURI, suffix)\r\n        = INFT(nftAddress).seriesInfo(seriesId);\r\n        \r\n        require (author != address(0));\r\n\r\n        bool transferSuccess;\r\n        \r\n        uint256 totalPrice = (saleInfo.price)*(tokenIds.length);\r\n        if (saleInfo.currency == address(0)) {\r\n            \r\n            (transferSuccess, ) = (author).call{gas: 3000, value: (totalPrice)}(new bytes(0));\r\n            require(transferSuccess, \"TRANSFER_COMMISSION_FAILED\");\r\n        } else {\r\n            IERC20Upgradeable(saleInfo.currency).transferFrom(msg.sender, author, totalPrice);\r\n        }\r\n\r\n        address owner = Ownable(nftAddress).owner();\r\n\r\n        bytes memory returndata;\r\n\r\n        (transferSuccess, returndata) = nftAddress.call(\r\n                abi.encodePacked(\r\n                    abi.encodeWithSelector(\r\n                        INFT.mintAndDistribute.selector,\r\n                        tokenIds, addresses\r\n                    ),\r\n                    owner\r\n                )\r\n            );\r\n        _verifyCallResult(transferSuccess, returndata, \"low level error\");\r\n        \r\n    }\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "NFTBulkSaleV1", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://63a820b1d095858a4c36ea17919228edbd7f11ce4dc986cfa9de0da04694207a"}]}