{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/invaded/invader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @creator: denkozeth\\r\\n/// Special thanks to Pak and his Censored collection for inspiring us.\\r\\n\\r\\n//    \u2588\u2588 \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588  \u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\\r\\n//    \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588\\r\\n//    \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588   \u2588\u2588\\r\\n//    \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588  \u2588\u2588  \u2588\u2588  \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588\\r\\n//    \u2588\u2588 \u2588\u2588   \u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588   \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\n\\r\\ncontract Invader {\\r\\n    using Strings for uint256;\\r\\n\\r\\n    string private constant _MESSAGE_TAG = \\\"<MESSAGE>\\\";\\r\\n    string private constant _TRACK_TAG = \\\"<TRACK>\\\";\\r\\n    string private constant _COMMUNITY_TAG = \\\"<COMMUNITY>\\\";\\r\\n    string[] private _imageParts;\\r\\n\\r\\n    constructor() {\\r\\n        _imageParts.push(\\r\\n            \\\"<svg xmlns='http://www.w3.org/2000/svg' width='1000' height='1000' viewBox='0 0 1000 1000'>\\\"\\r\\n        );\\r\\n        _imageParts.push(\\\"<style>@font-face {font-family: 'C';src: \\\");\\r\\n        _imageParts.push(\\r\\n            \\\"url('data:font/woff2;charset=utf-8;base64,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') format('woff2');\\\"\\r\\n        );\\r\\n        _imageParts.push(\\r\\n            \\\"font-weight: 500; font-style: normal; font-display: swap;}\\\"\\r\\n        );\\r\\n        _imageParts.push(\\\".f { width: 100%; height: 100%; }\\\");\\r\\n        _imageParts.push(\\\".b { fill: black; }\\\");\\r\\n        _imageParts.push(\\\".a { animation: o 2s ease-out forwards; }\\\");\\r\\n        _imageParts.push(\\r\\n            \\\"@keyframes o { 10% { opacity: 1; } 100% { opacity: 0; } }\\\"\\r\\n        );\\r\\n        _imageParts.push(\\r\\n            \\\"tspan { fill: lightgray; font-family: 'C'; font-size: 70px; text-transform: uppercase; text-anchor: middle; }\\\"\\r\\n        );\\r\\n        _imageParts.push(\\\"</style>\\\");\\r\\n        _imageParts.push(\\\"<rect class='b f' />\\\");\\r\\n        _imageParts.push(\\\"<svg>\\\");\\r\\n        _imageParts.push(_TRACK_TAG);\\r\\n        _imageParts.push(\\\"</svg>\\\");\\r\\n        _imageParts.push(_MESSAGE_TAG);\\r\\n        _imageParts.push(\\\"<svg overflow='visible'><text>\\\");\\r\\n        _imageParts.push(_COMMUNITY_TAG);\\r\\n        _imageParts.push(\\r\\n            \\\"<tspan y='85' x='150'>%23nowar</tspan><tspan y='85' x='740'>%23freeukraine</tspan></text></svg><rect class='b f a' />\\\"\\r\\n        );\\r\\n        _imageParts.push(\\\"</svg>\\\");\\r\\n    }\\r\\n\\r\\n    function metadata(\\r\\n        uint256 tokenId,\\r\\n        string memory message,\\r\\n        uint256 value,\\r\\n        uint256 angle,\\r\\n        string memory community\\r\\n    ) external view returns (string memory) {\\r\\n        return\\r\\n            string(\\r\\n                abi.encodePacked(\\r\\n                    'data:application/json;utf8,{\\\"name\\\":\\\"Invaded #',\\r\\n                    tokenId.toString(),\\r\\n                    '\\\", \\\"description\\\":\\\"',\\r\\n                    _toUpperCase(message),\\r\\n                    '\\\", \\\"created_by\\\":\\\"You\\\", \\\"image\\\":\\\"data:image/svg+xml;utf8,',\\r\\n                    svg(tokenId, message, value, angle, community),\\r\\n                    '\\\",\\\"attributes\\\":[{\\\"trait_type\\\":\\\"Invaded\\\",\\\"value\\\":\\\"True\\\"},{\\\"trait_type\\\":\\\"Initial Price\\\",\\\"value\\\":',\\r\\n                    _valueString(value),\\r\\n                    bytes(community).length > 0\\r\\n                        ? string(\\r\\n                            abi.encodePacked(\\r\\n                                '},{\\\"trait_type\\\":\\\"Community\\\",\\\"value\\\":\\\"',\\r\\n                                community,\\r\\n                                '\\\"}]}'\\r\\n                            )\\r\\n                        )\\r\\n                        : \\\"}]}\\\"\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function _toUpperCase(string memory message)\\r\\n        private\\r\\n        pure\\r\\n        returns (string memory)\\r\\n    {\\r\\n        bytes memory messageBytes = bytes(message);\\r\\n        bytes memory upperMessageBytes = new bytes(messageBytes.length);\\r\\n        for (uint256 i = 0; i < messageBytes.length; i++) {\\r\\n            bytes1 char = messageBytes[i];\\r\\n            if (char >= 0x61 && char <= 0x7A) {\\r\\n                // So we add 32 to make it lowercase\\r\\n                upperMessageBytes[i] = bytes1(uint8(char) - 32);\\r\\n            } else {\\r\\n                upperMessageBytes[i] = char;\\r\\n            }\\r\\n        }\\r\\n        return string(upperMessageBytes);\\r\\n    }\\r\\n\\r\\n    function renderLines(string memory message)\\r\\n        public\\r\\n        pure\\r\\n        returns (string memory)\\r\\n    {\\r\\n        // Allocate memory for max number of lines (7) at 18 characters each (126)\\r\\n        bytes memory lineBytes = new bytes(126);\\r\\n        uint8[] memory lineLengths = new uint8[](7);\\r\\n\\r\\n        // Compute line count\\r\\n        bytes memory messageBytes = bytes(message);\\r\\n        uint8 wordLength;\\r\\n        uint8 lineLength;\\r\\n        uint8 lineIndex;\\r\\n        uint256 messageLastIndex = messageBytes.length - 1;\\r\\n        for (uint256 i = 0; i <= messageLastIndex; i++) {\\r\\n            bytes1 char = messageBytes[i];\\r\\n            if (i == 0 || char != 0x20 || i == messageLastIndex) {\\r\\n                wordLength += 1;\\r\\n            }\\r\\n            if (char == 0x20 || i == messageLastIndex) {\\r\\n                // Check line length is < 18 after adding new word\\r\\n                if (\\r\\n                    (lineLength == 0 && lineLength + wordLength <= 18) ||\\r\\n                    (lineLength + wordLength <= 17)\\r\\n                ) {\\r\\n                    // Add into the current lineBytes\\r\\n                    uint256 lineBytesOffset = lineIndex * 18;\\r\\n                    if (lineLength > 0) {\\r\\n                        // Additional word, add a space\\r\\n                        lineBytes[lineBytesOffset + lineLength] = 0x20;\\r\\n                        lineLength += 1;\\r\\n                    }\\r\\n                    for (uint256 j = 0; j < wordLength; j++) {\\r\\n                        lineBytes[\\r\\n                            lineBytesOffset + lineLength + j\\r\\n                        ] = messageBytes[\\r\\n                            (i == messageLastIndex ? 1 : 0) + i - wordLength + j\\r\\n                        ];\\r\\n                    }\\r\\n                    lineLength += wordLength;\\r\\n                    lineLengths[lineIndex] = lineLength;\\r\\n                } else {\\r\\n                    // Word plus existing line length over max\\r\\n                    if (wordLength > 18) {\\r\\n                        if (lineLength > 0) {\\r\\n                            // Move to new line if there have already been words added to this line\\r\\n                            lineIndex += 1;\\r\\n                            lineLength = 0;\\r\\n                        }\\r\\n                        uint256 lineBytesOffset = lineIndex * 18;\\r\\n                        for (uint256 j = 0; j < wordLength; j++) {\\r\\n                            lineLength += 1;\\r\\n                            lineBytes[\\r\\n                                lineBytesOffset + (j % 18)\\r\\n                            ] = messageBytes[\\r\\n                                (i == messageLastIndex ? 1 : 0) +\\r\\n                                    i -\\r\\n                                    wordLength +\\r\\n                                    j\\r\\n                            ];\\r\\n                            if (j > 0 && j % 18 == 17) {\\r\\n                                // New line every 18 characters\\r\\n                                lineLengths[lineIndex] = lineLength;\\r\\n                                lineIndex += 1;\\r\\n                                lineLength = 0;\\r\\n                                lineBytesOffset = lineIndex * 18;\\r\\n                            }\\r\\n                        }\\r\\n                        lineLengths[lineIndex] = lineLength;\\r\\n                    } else {\\r\\n                        // New line\\r\\n                        lineIndex += 1;\\r\\n                        uint256 lineBytesOffset = lineIndex * 18;\\r\\n                        for (uint256 j = 0; j < wordLength; j++) {\\r\\n                            lineBytes[lineBytesOffset + j] = messageBytes[\\r\\n                                (i == messageLastIndex ? 1 : 0) +\\r\\n                                    i -\\r\\n                                    wordLength +\\r\\n                                    j\\r\\n                            ];\\r\\n                        }\\r\\n                        lineLength = wordLength;\\r\\n                        lineLengths[lineIndex] = lineLength;\\r\\n                    }\\r\\n                }\\r\\n                wordLength = 0;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        string memory lines;\\r\\n        uint8 lineCount;\\r\\n        for (uint256 i = 0; i <= lineIndex; i++) {\\r\\n            uint256 lineBytesOffset = i * 18;\\r\\n            if (lineLengths[i] > 0) {\\r\\n                lineCount += 1;\\r\\n                bytes memory line = new bytes(lineLengths[i]);\\r\\n                for (uint256 j = 0; j < lineLengths[i]; j++) {\\r\\n                    line[j] = lineBytes[lineBytesOffset + j];\\r\\n                }\\r\\n                if (i == 0) {\\r\\n                    lines = string(\\r\\n                        abi.encodePacked(\\r\\n                            lines,\\r\\n                            \\\"<tspan x='500'>\\\",\\r\\n                            line,\\r\\n                            \\\"</tspan>\\\"\\r\\n                        )\\r\\n                    );\\r\\n                } else {\\r\\n                    lines = string(\\r\\n                        abi.encodePacked(\\r\\n                            lines,\\r\\n                            \\\"<tspan x='500' dy='1em'>\\\",\\r\\n                            line,\\r\\n                            \\\"</tspan>\\\"\\r\\n                        )\\r\\n                    );\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return\\r\\n            string(\\r\\n                abi.encodePacked(\\r\\n                    \\\"<svg y='\\\",\\r\\n                    (560 - uint256(lineCount) * 35).toString(),\\r\\n                    \\\"' overflow='visible'><text>\\\",\\r\\n                    lines,\\r\\n                    \\\"</text></svg>\\\"\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function _valueString(uint256 value) private pure returns (string memory) {\\r\\n        uint256 eth = value / 10**18;\\r\\n        uint256 decimal4 = value / 10**14 - eth * 10**4;\\r\\n        return\\r\\n            string(\\r\\n                abi.encodePacked(\\r\\n                    eth.toString(),\\r\\n                    \\\".\\\",\\r\\n                    _decimal4ToString(decimal4)\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function _decimal4ToString(uint256 decimal4)\\r\\n        private\\r\\n        pure\\r\\n        returns (string memory)\\r\\n    {\\r\\n        bytes memory decimal4Characters = new bytes(4);\\r\\n        for (uint256 i = 0; i < 4; i++) {\\r\\n            decimal4Characters[3 - i] = bytes1(uint8(0x30 + (decimal4 % 10)));\\r\\n            decimal4 /= 10;\\r\\n        }\\r\\n        return string(abi.encodePacked(decimal4Characters));\\r\\n    }\\r\\n\\r\\n    function _renderTrack(uint256 offset) private pure returns (string memory) {\\r\\n        bytes memory byteString;\\r\\n        byteString = abi.encodePacked(\\r\\n            byteString,\\r\\n            abi.encodePacked(\\r\\n                \\\"<g fill='grey' transform='translate(\\\",\\r\\n                offset.toString(),\\r\\n                \\\",-150)' style='fill-opacity: .4;'>\\\"\\r\\n            )\\r\\n        );\\r\\n        uint256 y = 0;\\r\\n        for (uint256 z = 0; z < 35; z++) {\\r\\n            uint256 x = 0;\\r\\n            for (uint256 i = 0; i < 4; i++) {\\r\\n                byteString = abi.encodePacked(\\r\\n                    byteString,\\r\\n                    abi.encodePacked(\\r\\n                        \\\"<rect transform='translate(\\\",\\r\\n                        x.toString(),\\r\\n                        \\\",\\\",\\r\\n                        (i % 2 == 0 ? y + 10 : y).toString(),\\r\\n                        \\\") rotate(\\\",\\r\\n                        (i % 2 != 0 ? \\\"\\\" : \\\"-\\\"),\\r\\n                        \\\"35)' x='0' width='50' height='20' rx='10' />\\\"\\r\\n                    )\\r\\n                );\\r\\n                x = i % 2 == 0 ? x + 55 : x + 35;\\r\\n            }\\r\\n            y = y + 40;\\r\\n        }\\r\\n        byteString = abi.encodePacked(byteString, abi.encodePacked(\\\"</g>\\\"));\\r\\n        return string(byteString);\\r\\n    }\\r\\n\\r\\n    function _renderTracks(uint256 angle) private pure returns (string memory) {\\r\\n        bytes memory byteString;\\r\\n        byteString = abi.encodePacked(\\r\\n            byteString,\\r\\n            abi.encodePacked(\\r\\n                \\\"<g transform='rotate(\\\",\\r\\n                angle.toString(),\\r\\n                \\\", 500, 500)'>\\\"\\r\\n            )\\r\\n        );\\r\\n        byteString = abi.encodePacked(byteString, _renderTrack(100));\\r\\n        byteString = abi.encodePacked(byteString, _renderTrack(650));\\r\\n        byteString = abi.encodePacked(byteString, abi.encodePacked(\\\"</g>\\\"));\\r\\n        return string(byteString);\\r\\n    }\\r\\n\\r\\n    function _renderCommunityTag(string memory community)\\r\\n        private\\r\\n        pure\\r\\n        returns (string memory)\\r\\n    {\\r\\n        bytes memory byteString;\\r\\n        byteString = abi.encodePacked(\\r\\n            byteString,\\r\\n            abi.encodePacked(\\r\\n                \\\"<tspan y='970' x='500' style='font-size: 50px; font-style: italic'>\\\",\\r\\n                community,\\r\\n                \\\"</tspan>\\\"\\r\\n            )\\r\\n        );\\r\\n        return string(byteString);\\r\\n    }\\r\\n\\r\\n    function svg(\\r\\n        uint256,\\r\\n        string memory message,\\r\\n        uint256,\\r\\n        uint256 angle,\\r\\n        string memory community\\r\\n    ) public view returns (string memory) {\\r\\n        bytes memory byteString;\\r\\n        for (uint256 i = 0; i < _imageParts.length; i++) {\\r\\n            if (_checkTag(_imageParts[i], _MESSAGE_TAG)) {\\r\\n                byteString = abi.encodePacked(byteString, renderLines(message));\\r\\n            } else {\\r\\n                if (_checkTag(_imageParts[i], _TRACK_TAG)) {\\r\\n                    byteString = abi.encodePacked(\\r\\n                        byteString,\\r\\n                        _renderTracks(angle)\\r\\n                    );\\r\\n                } else {\\r\\n                    if (_checkTag(_imageParts[i], _COMMUNITY_TAG)) {\\r\\n                        byteString = abi.encodePacked(\\r\\n                            byteString,\\r\\n                            _renderCommunityTag(community)\\r\\n                        );\\r\\n                    } else {\\r\\n                        byteString = abi.encodePacked(\\r\\n                            byteString,\\r\\n                            _imageParts[i]\\r\\n                        );\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return string(byteString);\\r\\n    }\\r\\n\\r\\n    function _checkTag(string storage a, string memory b)\\r\\n        private\\r\\n        pure\\r\\n        returns (bool)\\r\\n    {\\r\\n        return (keccak256(abi.encodePacked((a))) ==\\r\\n            keccak256(abi.encodePacked((b))));\\r\\n    }\\r\\n\\r\\n    function getAngle() public view returns (uint256) {\\r\\n        uint256 seed = uint256(\\r\\n            keccak256(\\r\\n                abi.encodePacked(\\r\\n                    block.timestamp +\\r\\n                        block.difficulty +\\r\\n                        ((\\r\\n                            uint256(keccak256(abi.encodePacked(block.coinbase)))\\r\\n                        ) / block.timestamp) +\\r\\n                        block.gaslimit +\\r\\n                        ((uint256(keccak256(abi.encodePacked(msg.sender)))) /\\r\\n                            block.timestamp) +\\r\\n                        block.number\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n\\r\\n        return (seed - ((seed / 1000) * 1000)) % 360;\\r\\n    }\\r\\n\\r\\n    function validateMessage(string memory message_)\\r\\n        public\\r\\n        pure\\r\\n        returns (bool)\\r\\n    {\\r\\n        // Max length 72, a-z- only\\r\\n        bytes memory messageBytes = bytes(message_);\\r\\n        require(\\r\\n            messageBytes.length > 0 &&\\r\\n                messageBytes[0] != 0x20 &&\\r\\n                messageBytes[messageBytes.length - 1] != 0x20,\\r\\n            \\\"Invalid characters\\\"\\r\\n        );\\r\\n        require(messageBytes.length <= 72, \\\"Message too long\\\");\\r\\n\\r\\n        for (uint256 i = 0; i < messageBytes.length; i++) {\\r\\n            bytes1 char = messageBytes[i];\\r\\n            if (\\r\\n                !(char >= 0x61 && char <= 0x7A) && char != 0x20 && char != 0x2D\\r\\n            ) {\\r\\n                revert(\\\"Invalid character\\\");\\r\\n            } else if (i >= 1 && char == 0x20 && messageBytes[i - 1] == 0x20) {\\r\\n                revert(\\\"Cannot have multiple sequential spaces\\\");\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"getAngle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"angle\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"community\",\"type\":\"string\"}],\"name\":\"metadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"renderLines\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"angle\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"community\",\"type\":\"string\"}],\"name\":\"svg\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message_\",\"type\":\"string\"}],\"name\":\"validateMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "Invader", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}