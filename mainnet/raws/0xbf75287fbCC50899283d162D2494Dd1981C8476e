{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IWeedWarsERC721.sol\\\";\\nimport \\\"./interfaces/IWeedERC20.sol\\\";\\nimport \\\"./types/OwnerOrAdmin.sol\\\";\\n\\ncontract Staking is OwnerOrAdmin {\\n\\n    event Stake(\\n        address indexed holder,\\n        Collection indexed collection,\\n        uint256 indexed tokenId,\\n        uint256 period,\\n        uint256 end,\\n        uint256 reward\\n    );\\n    event Unstake(\\n        address indexed holder,\\n        Collection indexed collection,\\n        uint256 indexed tokenId,\\n        uint256 reward\\n    );\\n    event Lock(\\n        address indexed receiver,\\n        Collection indexed collection,\\n        uint256 indexed tokenId,\\n        uint256 lockId,\\n        uint256 start,\\n        uint256 lockPeriod,\\n        uint256 amountLocked\\n    );\\n    event Claim(\\n        address indexed receiver, \\n        uint256 lockId,\\n        uint256 claimIndex\\n    );\\n\\n    bool public isStakingActive;\\n    bool public isPrestaking;\\n    uint16[4] public periods = [30, 90, 180, 270];\\n    uint32 public stakingPeriodUnit = 86_400; // day\\n    uint32[4][5] public rewards = [\\n        [180, 620, 1240, uint32(2420)],\\n        [420, 1420, 2840, uint32(4200)],\\n        [880, 2840, 5420, uint32(8420)],\\n        [1820, 6420, 11420, uint32(17420)],\\n        [4200, 14200, 28420, uint32(42000)]\\n    ];\\n    uint8 public lockPeriod = 10;\\n    uint32 public lockPeriodUnit = 2_592_000; // month\\n\\n    mapping(address => mapping(uint256 => StakingInfo)) public warriorsStaked;\\n    mapping(address => mapping(uint256 => StakingInfo)) public synthsStaked;\\n    mapping(address => WeedLock[]) public locks;\\n\\n    IWeedWarsERC721 public warriorsERC721;\\n    IWeedWarsERC721 public synthsERC721;\\n    IWeedERC20 public weedERC20;\\n\\n    enum Collection {\\n        WARRIOR,\\n        SYNTH\\n    }\\n\\n    struct StakingInfo {\\n        Collection collection;\\n        uint256 start;\\n        uint256 end;\\n        uint256 reward;\\n    }\\n\\n    struct WeedLock {\\n        uint256 monthlyReward;\\n        uint256 start;\\n        uint256 vestingPeriod;\\n        uint256 claimIndex;\\n        bool vested;\\n        Collection collection;\\n        uint256 tokenId;\\n    }\\n\\n    // constructor\\n\\n    constructor(\\n        address _warriorsERC721,\\n        address _synthsERC721,\\n        address _weedERC20,\\n        bool _isStakingActive,\\n        bool _isPrestaking\\n    ) {\\n        warriorsERC721 = IWeedWarsERC721(_warriorsERC721);\\n        synthsERC721 = IWeedWarsERC721(_synthsERC721);\\n        weedERC20 = IWeedERC20(_weedERC20);\\n        isStakingActive = _isStakingActive;\\n        isPrestaking = _isPrestaking;\\n    }\\n\\n    // only owner\\n\\n    function setStakingActive(bool _isStakingActive) external onlyOwnerOrAdmin {\\n        isStakingActive = _isStakingActive;\\n    }\\n\\n    function setPrestaking(bool _isPrestaking) external onlyOwnerOrAdmin {\\n        isPrestaking = _isPrestaking;\\n    }\\n\\n    function setStakingPeriods(uint16[4] memory _periods) external onlyOwnerOrAdmin {\\n        periods = _periods;\\n    }\\n\\n    function setStakingRewards(uint32[4][5] memory _rewards) external onlyOwnerOrAdmin {\\n        rewards = _rewards;\\n    }\\n\\n    function setLockPeriod(uint8 _lockPeriod) external onlyOwnerOrAdmin {\\n        require(_lockPeriod > 0, \\\"Staking: should be > 0\\\");\\n        lockPeriod = _lockPeriod;\\n    }\\n\\n    function setStakingPeriodUnit(uint32 _stakingPeriodUnit) external onlyOwnerOrAdmin {\\n        require(_stakingPeriodUnit > 0, \\\"Staking: should be > 0\\\");\\n        stakingPeriodUnit = _stakingPeriodUnit;\\n    }\\n\\n    function setLockPeriodUnit(uint32 _lockPeriodUnit) external onlyOwnerOrAdmin {\\n        require(_lockPeriodUnit > 0, \\\"Staking: should be > 0\\\");\\n        lockPeriodUnit = _lockPeriodUnit;\\n    }\\n\\n    // user\\n\\n    function stake(\\n        uint256 _tokenId,\\n        Collection _collection,\\n        uint8 _stakingPeriod\\n    ) public {\\n        require(isStakingActive, \\\"Staking: not active\\\");\\n        require(\\n            _stakingPeriod >= 0 && _stakingPeriod < 4,\\n            \\\"Staking: incorrect staking period\\\"\\n        );\\n        StakingInfo memory stakingInfo = stakeInfo(msg.sender, _tokenId, _collection);\\n        require(stakingInfo.start == 0, \\\"Staking: already staked\\\");\\n\\n        IWeedWarsERC721 nftContract = _collection == Collection.WARRIOR\\n            ? warriorsERC721\\n            : synthsERC721;\\n\\n        nftContract.setLock(_tokenId, msg.sender, true);\\n\\n        uint256 reward;\\n        if (isPrestaking || (_tokenId >= 0 && _tokenId <= 556)) {\\n            reward = rewards[4][_stakingPeriod];\\n        } else {\\n            uint256 mergeCount = nftContract.getMergeCount(_tokenId);\\n            uint256 rank = mergeCount <= 4 ? mergeCount : 4;\\n            reward = rewards[rank][_stakingPeriod];\\n        }\\n\\n        uint16 stakingPeriod = periods[_stakingPeriod];\\n        uint256 end = block.timestamp + uint256(stakingPeriod) * stakingPeriodUnit;\\n\\n        stakingInfo = StakingInfo(_collection, block.timestamp, end, reward);\\n        if (_collection == Collection.WARRIOR) {\\n            warriorsStaked[msg.sender][_tokenId] = stakingInfo;\\n        } else {\\n            synthsStaked[msg.sender][_tokenId] = stakingInfo;\\n        }\\n\\n        emit Stake(\\n            msg.sender,\\n            _collection,\\n            _tokenId,\\n            stakingPeriod,\\n            end,\\n            reward\\n        );\\n    }\\n\\n    function unstake(uint256 _tokenId, Collection _collection) public {\\n        StakingInfo memory stakingInfo = stakeInfo(msg.sender, _tokenId, _collection);\\n        require(stakingInfo.start != 0, \\\"Staking: Not found\\\");\\n\\n        uint256 rewardNow;\\n        if (isStakingFinished(msg.sender, _tokenId, _collection)) {\\n            rewardNow = stakingInfo.reward / 2;\\n            _sendReward(rewardNow, msg.sender);\\n            uint256 lockedReward = stakingInfo.reward - rewardNow;\\n            _lockReward(\\n                lockedReward,\\n                msg.sender,\\n                stakingInfo.end,\\n                _collection,\\n                _tokenId\\n            );\\n        }\\n        emit Unstake(msg.sender, _collection, _tokenId, rewardNow);\\n\\n        _unstake(_tokenId, _collection);\\n    }\\n\\n    function stakeBulk(\\n        uint256[] memory _tokenIds,\\n        Collection[] memory _collections,\\n        uint8 _stakingPeriod\\n    ) external {\\n        require(\\n            _tokenIds.length == _collections.length,\\n            \\\"Staking: invalid input\\\"\\n        );\\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\\n            stake(_tokenIds[i], _collections[i], _stakingPeriod);\\n        }\\n    }\\n\\n    function unstakeBulk(\\n        uint256[] memory _tokenIds,\\n        Collection[] memory _collections\\n    ) external {\\n        require(\\n            _tokenIds.length == _collections.length,\\n            \\\"Staking: invalid input\\\"\\n        );\\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\\n            unstake(_tokenIds[i], _collections[i]);\\n        }\\n    }\\n\\n    function claimRewards(uint256 _index) public {\\n        WeedLock storage lock = locks[msg.sender][_index];\\n        require(lock.start != 0, \\\"Staking: lock not found\\\");\\n        require(!lock.vested, \\\"Staking: already vested\\\");\\n\\n        (uint256 claimableReward, uint256 claimsCount) = lockInfo(\\n            msg.sender,\\n            _index\\n        );\\n\\n        require(claimsCount > 0, \\\"Staking: nothing to claim\\\");\\n        lock.claimIndex = lock.claimIndex + claimsCount;\\n\\n        if (lock.claimIndex == lock.vestingPeriod) {\\n            lock.vested = true;\\n        }\\n\\n        _sendReward(claimableReward, msg.sender);\\n\\n        emit Claim(msg.sender, _index, lock.claimIndex);\\n    }\\n\\n    function claimRewardsBulk(uint256[] memory _indexes) external {\\n        for (uint256 i = 0; i < _indexes.length; i++) {\\n            claimRewards(_indexes[i]);\\n        }\\n    }\\n\\n    function locksNumber(address addr) external view returns (uint256) {\\n        return locks[addr].length;\\n    }\\n\\n    function lockInfo(address _receiver, uint256 _index)\\n        public\\n        view\\n        returns (\\n            uint256 claimableReward_,\\n            uint256 claimsCount_\\n        )\\n    {\\n        WeedLock memory lock = locks[_receiver][_index];\\n        require(lock.start != 0, \\\"Staking: lock not found\\\");\\n\\n        if (lock.vested) {\\n            return (0, 0);\\n        }\\n\\n        uint256 claimsLeft = lock.vestingPeriod - lock.claimIndex;\\n        uint256 monthsVested = (block.timestamp - lock.start) / lockPeriodUnit;\\n\\n        if (monthsVested > lock.vestingPeriod) {\\n            monthsVested = lock.vestingPeriod;\\n        }\\n\\n        if (lock.claimIndex >= monthsVested) {\\n            claimsCount_ = 0;\\n        } else {\\n            claimableReward_ =\\n                (monthsVested - lock.claimIndex) *\\n                lock.monthlyReward;\\n            claimsCount_ = monthsVested - lock.claimIndex;\\n        }\\n\\n        if (claimsCount_ >= claimsLeft) {\\n            claimsCount_ = claimsLeft;\\n        }\\n    }\\n\\n    function stakeInfo(address _address, uint256 _tokenId, Collection _collection)\\n        public\\n        view\\n        returns (StakingInfo memory stakingInfo_)\\n    {\\n        return\\n            _collection == Collection.WARRIOR\\n                ? warriorsStaked[_address][_tokenId]\\n                : synthsStaked[_address][_tokenId];\\n    }\\n\\n    function isStakingFinished(address _address, uint256 _tokenId, Collection _collection)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        StakingInfo memory stakingInfo = stakeInfo(_address, _tokenId, _collection);\\n        if (stakingInfo.start == 0) {\\n            return false;\\n        }\\n        if (block.timestamp >= stakingInfo.end) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _sendReward(uint256 _amount, address _receiver) internal {\\n        weedERC20.mint(_receiver, _amount * 10**18);\\n    }\\n\\n    function _lockReward(\\n        uint256 _amount,\\n        address _receiver,\\n        uint256 _startTime,\\n        Collection _collection,\\n        uint256 _tokenId\\n    ) internal {\\n        locks[_receiver].push(\\n            WeedLock(\\n                _amount / lockPeriod,\\n                _startTime,\\n                lockPeriod,\\n                0,\\n                false,\\n                _collection,\\n                _tokenId\\n            )\\n        );\\n        emit Lock(_receiver, _collection, _tokenId, locks[_receiver].length - 1, _startTime, lockPeriod, _amount);\\n    }\\n\\n    function _unstake(uint256 _tokenId, Collection _collection) internal {\\n        if (_collection == Collection.WARRIOR) {\\n            warriorsERC721.setLock(_tokenId, msg.sender, false);\\n            delete warriorsStaked[msg.sender][_tokenId];\\n        } else {\\n            synthsERC721.setLock(_tokenId, msg.sender, false);\\n            delete synthsStaked[msg.sender][_tokenId];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWeedERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface IWeedERC20 {\\n    function mint(address _address, uint256 _amount) external;\\n    function burn(address _address, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWeedWarsERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface IWeedWarsERC721 {\\n    function mint(uint256 _claimQty, address _reciever) external;\\n    function setLock(uint256 _tokenId, address _owner, bool _isLocked) external;\\n    function getMergeCount(uint256 _tokenId) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/types/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/types/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/types/OwnerOrAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\nimport \\\"../types/Ownable.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\ncontract OwnerOrAdmin is Ownable {\\n\\n    mapping(address => bool) public admins;\\n\\n    function _isOwnerOrAdmin() private view {\\n        require(\\n            owner() == msg.sender || admins[msg.sender],\\n            \\\"OwnerOrAdmin: unauthorized\\\"\\n        );\\n    }\\n\\n    modifier onlyOwnerOrAdmin() {\\n        _isOwnerOrAdmin();\\n        _;\\n    }\\n\\n    function setAdmin(address _address, bool _hasAccess) external onlyOwner {\\n        admins[_address] = _hasAccess;\\n    }\\n\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_warriorsERC721\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_synthsERC721\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weedERC20\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isStakingActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isPrestaking\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimIndex\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum Staking.Collection\",\"name\":\"collection\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLocked\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum Staking.Collection\",\"name\":\"collection\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum Staking.Collection\",\"name\":\"collection\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_indexes\",\"type\":\"uint256[]\"}],\"name\":\"claimRewardsBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPrestaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStakingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum Staking.Collection\",\"name\":\"_collection\",\"type\":\"uint8\"}],\"name\":\"isStakingFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"lockInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimableReward_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimsCount_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockPeriod\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockPeriodUnit\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"locks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"monthlyReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"vested\",\"type\":\"bool\"},{\"internalType\":\"enum Staking.Collection\",\"name\":\"collection\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"locksNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periods\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_hasAccess\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_lockPeriod\",\"type\":\"uint8\"}],\"name\":\"setLockPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_lockPeriodUnit\",\"type\":\"uint32\"}],\"name\":\"setLockPeriodUnit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isPrestaking\",\"type\":\"bool\"}],\"name\":\"setPrestaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isStakingActive\",\"type\":\"bool\"}],\"name\":\"setStakingActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_stakingPeriodUnit\",\"type\":\"uint32\"}],\"name\":\"setStakingPeriodUnit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[4]\",\"name\":\"_periods\",\"type\":\"uint16[4]\"}],\"name\":\"setStakingPeriods\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[4][5]\",\"name\":\"_rewards\",\"type\":\"uint32[4][5]\"}],\"name\":\"setStakingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum Staking.Collection\",\"name\":\"_collection\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_stakingPeriod\",\"type\":\"uint8\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"enum Staking.Collection[]\",\"name\":\"_collections\",\"type\":\"uint8[]\"},{\"internalType\":\"uint8\",\"name\":\"_stakingPeriod\",\"type\":\"uint8\"}],\"name\":\"stakeBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum Staking.Collection\",\"name\":\"_collection\",\"type\":\"uint8\"}],\"name\":\"stakeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"enum Staking.Collection\",\"name\":\"collection\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"internalType\":\"struct Staking.StakingInfo\",\"name\":\"stakingInfo_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPeriodUnit\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"synthsERC721\",\"outputs\":[{\"internalType\":\"contract IWeedWarsERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"synthsStaked\",\"outputs\":[{\"internalType\":\"enum Staking.Collection\",\"name\":\"collection\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum Staking.Collection\",\"name\":\"_collection\",\"type\":\"uint8\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"enum Staking.Collection[]\",\"name\":\"_collections\",\"type\":\"uint8[]\"}],\"name\":\"unstakeBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"warriorsERC721\",\"outputs\":[{\"internalType\":\"contract IWeedWarsERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"warriorsStaked\",\"outputs\":[{\"internalType\":\"enum Staking.Collection\",\"name\":\"collection\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weedERC20\",\"outputs\":[{\"internalType\":\"contract IWeedERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000098929a1a41687f0b92a367b045763e67b3b815be0000000000000000000000007ae569f8e73e51fbdaf24068e626c0b633f397dc0000000000000000000000005631c6e3d8c758fb953fca07c3384e63383fc3fd00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}