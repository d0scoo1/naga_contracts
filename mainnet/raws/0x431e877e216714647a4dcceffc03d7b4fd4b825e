{"status": "1", "message": "OK", "result": [{"SourceCode": "// Sources flattened with hardhat v2.6.1 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.3.2\r\n\r\n// : MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.3.2\r\n\r\n// : MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/resolver/Lib_AddressManager.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\n/* External Imports */\r\n\r\n/**\r\n * @title Lib_AddressManager\r\n */\r\ncontract Lib_AddressManager is Ownable {\r\n    /**********\r\n     * Events *\r\n     **********/\r\n\r\n    event AddressSet(string indexed _name, address _newAddress, address _oldAddress);\r\n\r\n    /*************\r\n     * Variables *\r\n     *************/\r\n\r\n    mapping(bytes32 => address) private addresses;\r\n\r\n    /********************\r\n     * Public Functions *\r\n     ********************/\r\n\r\n    /**\r\n     * Changes the address associated with a particular name.\r\n     * @param _name String name to associate an address with.\r\n     * @param _address Address to associate with the name.\r\n     */\r\n    function setAddress(string memory _name, address _address) external onlyOwner {\r\n        bytes32 nameHash = _getNameHash(_name);\r\n        address oldAddress = addresses[nameHash];\r\n        addresses[nameHash] = _address;\r\n\r\n        emit AddressSet(_name, _address, oldAddress);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the address associated with a given name.\r\n     * @param _name Name to retrieve an address for.\r\n     * @return Address associated with the given name.\r\n     */\r\n    function getAddress(string memory _name) external view returns (address) {\r\n        return addresses[_getNameHash(_name)];\r\n    }\r\n\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    /**\r\n     * Computes the hash of a name.\r\n     * @param _name Name to compute a hash for.\r\n     * @return Hash of the given name.\r\n     */\r\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_name));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/resolver/Lib_AddressResolver.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/* Library Imports */\r\n\r\n/**\r\n * @title Lib_AddressResolver\r\n */\r\nabstract contract Lib_AddressResolver {\r\n    /*************\r\n     * Variables *\r\n     *************/\r\n\r\n    Lib_AddressManager public libAddressManager;\r\n\r\n    /***************\r\n     * Constructor *\r\n     ***************/\r\n\r\n    /**\r\n     * @param _libAddressManager Address of the Lib_AddressManager.\r\n     */\r\n    constructor(address _libAddressManager) {\r\n        libAddressManager = Lib_AddressManager(_libAddressManager);\r\n    }\r\n\r\n    /********************\r\n     * Public Functions *\r\n     ********************/\r\n\r\n    /**\r\n     * Resolves the address associated with a given name.\r\n     * @param _name Name to resolve an address for.\r\n     * @return Address associated with the given name.\r\n     */\r\n    function resolve(string memory _name) public view returns (address) {\r\n        return libAddressManager.getAddress(_name);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/MVM/iMVM_CanonicalTransaction.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/* Contract Imports */\r\n\r\n/* External Imports */\r\n\r\n/**\r\n * @title ICanonicalTransactionChain\r\n */\r\ninterface iMVM_CanonicalTransaction {\r\n    /*********\r\n     * Enums *\r\n     *********/\r\n\r\n    enum STAKESTATUS {\r\n        INIT,\r\n        SEQ_SET,\r\n        VERIFIER_SET,\r\n        PAYBACK\r\n    }\r\n\r\n    /**********\r\n     * Events *\r\n     **********/\r\n\r\n    event VerifierStake(\r\n        address _sender,\r\n        uint256 _chainId,\r\n        uint256 _batchIndex,\r\n        uint256 _blockNumber,\r\n        uint256 _amount\r\n    );\r\n\r\n    // default : stakeAmount=0, verified=true, sequencer=true\r\n    // sequencer response for stake: stakeAmount>0, verified=true, sequencer=true\r\n    // verifier response for stake timeout: stakeAmount>0, verified=false, sequencer=false\r\n    event SetBatchTxData(\r\n        address _sender,\r\n        uint256 _chainId,\r\n        uint256 _batchIndex,\r\n        uint256 _blockNumber,\r\n        uint256 _stakeAmount,\r\n        bool _verified,\r\n        bool _sequencer\r\n    );\r\n\r\n    event AppendBatchElement (\r\n        uint256 _chainId,\r\n        uint256 _batchIndex,\r\n        uint40 _shouldStartAtElement,\r\n        uint24 _totalElementsToAppend,\r\n        uint256 _txBatchSize,\r\n        uint256 _txBatchTime,\r\n        bytes32 _root\r\n    );\r\n\r\n    /***********\r\n     * Structs *\r\n     ***********/\r\n\r\n    // locker the same sender for 30 min\r\n    struct TxDataSlice {\r\n        address sender;\r\n        uint256 blockNumber;\r\n        uint256 batchIndex;\r\n        uint256 timestamp;\r\n        bytes txData;\r\n        bool verified;\r\n    }\r\n\r\n    struct TxDataRequestStake {\r\n        address sender;\r\n        uint256 blockNumber;\r\n        uint256 batchIndex;\r\n        uint256 timestamp;\r\n        uint256 endtime;\r\n        uint256 amount;\r\n        STAKESTATUS status;\r\n    }\r\n\r\n    struct BatchElement {\r\n        uint40 shouldStartAtElement;\r\n        uint24 totalElementsToAppend;\r\n        uint256 txBatchSize;\r\n        uint256 txBatchTime; // sequencer client encode timestamp(ms)\r\n        bytes32 root; // merkle hash root with [hash(txDataBytes + blockNumber)]\r\n        uint256 timestamp; // block timestamp\r\n    }\r\n\r\n    /*******************************\r\n     * Authorized Setter Functions *\r\n     *******************************/\r\n\r\n    /**\r\n     * Sets address's chain id.\r\n     * @param _address contract address.\r\n     * @param _chainId chain id.\r\n     */\r\n    // function setAddressChainId(address _address, uint256 _chainId) external;\r\n\r\n    /**\r\n     * Gets address's chain id.\r\n     */\r\n    // function getAddressChainId(address _address) external view returns (uint256);\r\n\r\n    /**\r\n     * Sets the verifier stake base cost of ETH.\r\n     * @param _stakeBaseCost Stake base cost for verifier.\r\n     */\r\n    function setStakeBaseCost(uint256 _stakeBaseCost) external;\r\n\r\n    /**\r\n     * Gets the verifier stake base cost of ETH.\r\n     */\r\n    function getStakeBaseCost() external view returns (uint256);\r\n\r\n    /**\r\n     * Sets the verifier stake unit cost of ETH.\r\n     * @param _stakeUnitCost Stake cost for verifier.\r\n     */\r\n    function setStakeUnitCost(uint256 _stakeUnitCost) external;\r\n\r\n    /**\r\n     * Gets the verifier stake unit cost of ETH for per storage unit.\r\n     */\r\n    function getStakeUnitCost() external view returns (uint256);\r\n\r\n    /**\r\n     * Gets the verifier stake cost of ETH by batch index.\r\n     */\r\n    function getStakeCostByBatch(uint256 _chainId, uint256 _batchIndex) external view returns (uint256);\r\n\r\n    /**\r\n     * Sets batch transaction data slice size per submit.\r\n     * @param _size Slice size of batch transaction data.\r\n     */\r\n    function setTxDataSliceSize(uint256 _size) external;\r\n\r\n    /**\r\n     * Gets batch transaction data slice size per submit.\r\n     */\r\n    function getTxDataSliceSize() external view returns (uint256);\r\n\r\n    /**\r\n     * Sets batch size per batch.\r\n     * @param _size Batch size of batch.\r\n     */\r\n    function setTxBatchSize(uint256 _size) external;\r\n\r\n    /**\r\n     * Gets batch size per batch.\r\n     */\r\n    function getTxBatchSize() external view returns (uint256);\r\n\r\n    /**\r\n     * Sets slice count per batch transaction data.\r\n     * @param _count Slice count per batch transaction data.\r\n     */\r\n    function setTxDataSliceCount(uint256 _count) external;\r\n\r\n    /**\r\n     * Gets slice count per batch transaction data.\r\n     */\r\n    function getTxDataSliceCount() external view returns (uint256);\r\n\r\n    /**\r\n     * Sets seconds can submit transaction data after staking.\r\n     * @param _seconds Seconds the Sequencer can sumbit transaction data after verifier staking.\r\n     */\r\n    function setStakeSeqSeconds(uint256 _seconds) external;\r\n\r\n    /**\r\n     * Gets seconds can submit transaction data after staking.\r\n     * @return Seconds the Sequencer can sumbit transaction data after verifier staking.\r\n     */\r\n    function getStakeSeqSeconds() external view returns (uint256);\r\n\r\n    function isWhiteListed(address _verifier) external view returns(bool);\r\n\r\n    // add the verifier to the whitelist\r\n    function setWhiteList(address _verifier, bool _allowed) external;\r\n\r\n    // allow everyone to be the verifier\r\n    function disableWhiteList() external;\r\n\r\n    /**\r\n     * Allows the sequencer to append a batch of transactions.\r\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\r\n     */\r\n    function appendSequencerBatchByChainId() external;\r\n\r\n    /**\r\n     * Sets batch tx data for stake.\r\n     * @param _chainId chain id.\r\n     * @param _batchIndex batch index of CTC.\r\n     * @param _blockNumber slice index.\r\n     * @param _data tx data hex.\r\n    */\r\n    function setBatchTxDataForStake(uint256 _chainId, uint256 _batchIndex, uint256 _blockNumber, bytes memory _data, uint256 _leafIndex, uint256 _totalLeaves, bytes32[] memory _proof) external;\r\n\r\n    /**\r\n     * Sets batch tx data for verifier.\r\n     * @param _chainId chain id.\r\n     * @param _batchIndex batch index of CTC.\r\n     * @param _blockNumber slice index.\r\n     * @param _data tx data hex.\r\n    */\r\n    function setBatchTxDataForVerifier(uint256 _chainId, uint256 _batchIndex, uint256 _blockNumber, bytes memory _data) external;\r\n\r\n    /**\r\n     * Gets batch tx data.\r\n     * @param _chainId chain id.\r\n     * @param _batchIndex batch index of CTC.\r\n     * @param _blockNumber block number.\r\n     * @return txData\r\n     * @return verified\r\n    */\r\n    function getBatchTxData(uint256 _chainId, uint256 _batchIndex, uint256 _blockNumber) external view returns (bytes memory txData, bool verified);\r\n\r\n    function checkBatchTxHash(uint256 _chainId, uint256 _batchIndex, uint256 _blockNumber, bytes memory _data) external view returns (bytes32 txHash, bool verified);\r\n\r\n    function setBatchTxDataVerified(uint256 _chainId, uint256 _batchIndex, uint256 _blockNumber, bool _verified) external;\r\n\r\n    /**\r\n     * Stake by verifier.\r\n     * @param _chainId chain id.\r\n     * @param _batchIndex batch index of CTC.\r\n     * @param _blockNumber block number.\r\n    */\r\n    function verifierStake(uint256 _chainId, uint256 _batchIndex, uint256 _blockNumber) external payable;\r\n\r\n    /**\r\n     * Withdraw stake by verifier.\r\n     * @param _chainId chain id.\r\n     * @param _batchIndex batch index of CTC.\r\n     * @param _blockNumber block number.\r\n    */\r\n    function withdrawStake(uint256 _chainId, uint256 _batchIndex, uint256 _blockNumber) external;\r\n\r\n}\r\n\r\n\r\n// File contracts/libraries/rlp/Lib_RLPReader.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * @title Lib_RLPReader\r\n * @dev Adapted from \"RLPReader\" by Hamdi Allam (hamdi.allam97@gmail.com).\r\n */\r\nlibrary Lib_RLPReader {\r\n    /*************\r\n     * Constants *\r\n     *************/\r\n\r\n    uint256 internal constant MAX_LIST_LENGTH = 32;\r\n\r\n    /*********\r\n     * Enums *\r\n     *********/\r\n\r\n    enum RLPItemType {\r\n        DATA_ITEM,\r\n        LIST_ITEM\r\n    }\r\n\r\n    /***********\r\n     * Structs *\r\n     ***********/\r\n\r\n    struct RLPItem {\r\n        uint256 length;\r\n        uint256 ptr;\r\n    }\r\n\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    /**\r\n     * Converts bytes to a reference to memory position and length.\r\n     * @param _in Input bytes to convert.\r\n     * @return Output memory reference.\r\n     */\r\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\r\n        uint256 ptr;\r\n        assembly {\r\n            ptr := add(_in, 32)\r\n        }\r\n\r\n        return RLPItem({ length: _in.length, ptr: ptr });\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP list value into a list of RLP items.\r\n     * @param _in RLP list value.\r\n     * @return Decoded RLP list items.\r\n     */\r\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\r\n        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\r\n\r\n        require(itemType == RLPItemType.LIST_ITEM, \"Invalid RLP list value.\");\r\n\r\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\r\n        // writing to the length. Since we can't know the number of RLP items without looping over\r\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\r\n        // simply set a reasonable maximum list length and decrease the size before we finish.\r\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\r\n\r\n        uint256 itemCount = 0;\r\n        uint256 offset = listOffset;\r\n        while (offset < _in.length) {\r\n            require(itemCount < MAX_LIST_LENGTH, \"Provided RLP list exceeds max list length.\");\r\n\r\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\r\n                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })\r\n            );\r\n\r\n            out[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });\r\n\r\n            itemCount += 1;\r\n            offset += itemOffset + itemLength;\r\n        }\r\n\r\n        // Decrease the array size to match the actual item count.\r\n        assembly {\r\n            mstore(out, itemCount)\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP list value into a list of RLP items.\r\n     * @param _in RLP list value.\r\n     * @return Decoded RLP list items.\r\n     */\r\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\r\n        return readList(toRLPItem(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP bytes value into bytes.\r\n     * @param _in RLP bytes value.\r\n     * @return Decoded bytes.\r\n     */\r\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\r\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\r\n\r\n        require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes value.\");\r\n\r\n        return _copy(_in.ptr, itemOffset, itemLength);\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP bytes value into bytes.\r\n     * @param _in RLP bytes value.\r\n     * @return Decoded bytes.\r\n     */\r\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\r\n        return readBytes(toRLPItem(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP string value into a string.\r\n     * @param _in RLP string value.\r\n     * @return Decoded string.\r\n     */\r\n    function readString(RLPItem memory _in) internal pure returns (string memory) {\r\n        return string(readBytes(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP string value into a string.\r\n     * @param _in RLP string value.\r\n     * @return Decoded string.\r\n     */\r\n    function readString(bytes memory _in) internal pure returns (string memory) {\r\n        return readString(toRLPItem(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP bytes32 value into a bytes32.\r\n     * @param _in RLP bytes32 value.\r\n     * @return Decoded bytes32.\r\n     */\r\n    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\r\n        require(_in.length <= 33, \"Invalid RLP bytes32 value.\");\r\n\r\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\r\n\r\n        require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes32 value.\");\r\n\r\n        uint256 ptr = _in.ptr + itemOffset;\r\n        bytes32 out;\r\n        assembly {\r\n            out := mload(ptr)\r\n\r\n            // Shift the bytes over to match the item size.\r\n            if lt(itemLength, 32) {\r\n                out := div(out, exp(256, sub(32, itemLength)))\r\n            }\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP bytes32 value into a bytes32.\r\n     * @param _in RLP bytes32 value.\r\n     * @return Decoded bytes32.\r\n     */\r\n    function readBytes32(bytes memory _in) internal pure returns (bytes32) {\r\n        return readBytes32(toRLPItem(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP uint256 value into a uint256.\r\n     * @param _in RLP uint256 value.\r\n     * @return Decoded uint256.\r\n     */\r\n    function readUint256(RLPItem memory _in) internal pure returns (uint256) {\r\n        return uint256(readBytes32(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP uint256 value into a uint256.\r\n     * @param _in RLP uint256 value.\r\n     * @return Decoded uint256.\r\n     */\r\n    function readUint256(bytes memory _in) internal pure returns (uint256) {\r\n        return readUint256(toRLPItem(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP bool value into a bool.\r\n     * @param _in RLP bool value.\r\n     * @return Decoded bool.\r\n     */\r\n    function readBool(RLPItem memory _in) internal pure returns (bool) {\r\n        require(_in.length == 1, \"Invalid RLP boolean value.\");\r\n\r\n        uint256 ptr = _in.ptr;\r\n        uint256 out;\r\n        assembly {\r\n            out := byte(0, mload(ptr))\r\n        }\r\n\r\n        require(out == 0 || out == 1, \"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\");\r\n\r\n        return out != 0;\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP bool value into a bool.\r\n     * @param _in RLP bool value.\r\n     * @return Decoded bool.\r\n     */\r\n    function readBool(bytes memory _in) internal pure returns (bool) {\r\n        return readBool(toRLPItem(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP address value into a address.\r\n     * @param _in RLP address value.\r\n     * @return Decoded address.\r\n     */\r\n    function readAddress(RLPItem memory _in) internal pure returns (address) {\r\n        if (_in.length == 1) {\r\n            return address(0);\r\n        }\r\n\r\n        require(_in.length == 21, \"Invalid RLP address value.\");\r\n\r\n        return address(uint160(readUint256(_in)));\r\n    }\r\n\r\n    /**\r\n     * Reads an RLP address value into a address.\r\n     * @param _in RLP address value.\r\n     * @return Decoded address.\r\n     */\r\n    function readAddress(bytes memory _in) internal pure returns (address) {\r\n        return readAddress(toRLPItem(_in));\r\n    }\r\n\r\n    /**\r\n     * Reads the raw bytes of an RLP item.\r\n     * @param _in RLP item to read.\r\n     * @return Raw RLP bytes.\r\n     */\r\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\r\n        return _copy(_in);\r\n    }\r\n\r\n    /*********************\r\n     * Private Functions *\r\n     *********************/\r\n\r\n    /**\r\n     * Decodes the length of an RLP item.\r\n     * @param _in RLP item to decode.\r\n     * @return Offset of the encoded data.\r\n     * @return Length of the encoded data.\r\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\r\n     */\r\n    function _decodeLength(RLPItem memory _in)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            RLPItemType\r\n        )\r\n    {\r\n        require(_in.length > 0, \"RLP item cannot be null.\");\r\n\r\n        uint256 ptr = _in.ptr;\r\n        uint256 prefix;\r\n        assembly {\r\n            prefix := byte(0, mload(ptr))\r\n        }\r\n\r\n        if (prefix <= 0x7f) {\r\n            // Single byte.\r\n\r\n            return (0, 1, RLPItemType.DATA_ITEM);\r\n        } else if (prefix <= 0xb7) {\r\n            // Short string.\r\n\r\n            uint256 strLen = prefix - 0x80;\r\n\r\n            require(_in.length > strLen, \"Invalid RLP short string.\");\r\n\r\n            return (1, strLen, RLPItemType.DATA_ITEM);\r\n        } else if (prefix <= 0xbf) {\r\n            // Long string.\r\n            uint256 lenOfStrLen = prefix - 0xb7;\r\n\r\n            require(_in.length > lenOfStrLen, \"Invalid RLP long string length.\");\r\n\r\n            uint256 strLen;\r\n            assembly {\r\n                // Pick out the string length.\r\n                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\r\n            }\r\n\r\n            require(_in.length > lenOfStrLen + strLen, \"Invalid RLP long string.\");\r\n\r\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\r\n        } else if (prefix <= 0xf7) {\r\n            // Short list.\r\n            uint256 listLen = prefix - 0xc0;\r\n\r\n            require(_in.length > listLen, \"Invalid RLP short list.\");\r\n\r\n            return (1, listLen, RLPItemType.LIST_ITEM);\r\n        } else {\r\n            // Long list.\r\n            uint256 lenOfListLen = prefix - 0xf7;\r\n\r\n            require(_in.length > lenOfListLen, \"Invalid RLP long list length.\");\r\n\r\n            uint256 listLen;\r\n            assembly {\r\n                // Pick out the list length.\r\n                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\r\n            }\r\n\r\n            require(_in.length > lenOfListLen + listLen, \"Invalid RLP long list.\");\r\n\r\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Copies the bytes from a memory location.\r\n     * @param _src Pointer to the location to read from.\r\n     * @param _offset Offset to start reading from.\r\n     * @param _length Number of bytes to read.\r\n     * @return Copied bytes.\r\n     */\r\n    function _copy(\r\n        uint256 _src,\r\n        uint256 _offset,\r\n        uint256 _length\r\n    ) private pure returns (bytes memory) {\r\n        bytes memory out = new bytes(_length);\r\n        if (out.length == 0) {\r\n            return out;\r\n        }\r\n\r\n        uint256 src = _src + _offset;\r\n        uint256 dest;\r\n        assembly {\r\n            dest := add(out, 32)\r\n        }\r\n\r\n        // Copy over as many complete words as we can.\r\n        for (uint256 i = 0; i < _length / 32; i++) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += 32;\r\n            dest += 32;\r\n        }\r\n\r\n        // Pick out the remaining bytes.\r\n        uint256 mask;\r\n        unchecked {\r\n            mask = 256**(32 - (_length % 32)) - 1;\r\n        }\r\n\r\n        assembly {\r\n            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Copies an RLP item into bytes.\r\n     * @param _in RLP item to copy.\r\n     * @return Copied bytes.\r\n     */\r\n    function _copy(RLPItem memory _in) private pure returns (bytes memory) {\r\n        return _copy(_in.ptr, 0, _in.length);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/rlp/Lib_RLPWriter.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * @title Lib_RLPWriter\r\n * @author Bakaoh (with modifications)\r\n */\r\nlibrary Lib_RLPWriter {\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    /**\r\n     * RLP encodes a byte string.\r\n     * @param _in The byte string to encode.\r\n     * @return The RLP encoded string in bytes.\r\n     */\r\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\r\n        bytes memory encoded;\r\n\r\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\r\n            encoded = _in;\r\n        } else {\r\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\r\n        }\r\n\r\n        return encoded;\r\n    }\r\n\r\n    /**\r\n     * RLP encodes a list of RLP encoded byte byte strings.\r\n     * @param _in The list of RLP encoded byte strings.\r\n     * @return The RLP encoded list of items in bytes.\r\n     */\r\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\r\n        bytes memory list = _flatten(_in);\r\n        return abi.encodePacked(_writeLength(list.length, 192), list);\r\n    }\r\n\r\n    /**\r\n     * RLP encodes a string.\r\n     * @param _in The string to encode.\r\n     * @return The RLP encoded string in bytes.\r\n     */\r\n    function writeString(string memory _in) internal pure returns (bytes memory) {\r\n        return writeBytes(bytes(_in));\r\n    }\r\n\r\n    /**\r\n     * RLP encodes an address.\r\n     * @param _in The address to encode.\r\n     * @return The RLP encoded address in bytes.\r\n     */\r\n    function writeAddress(address _in) internal pure returns (bytes memory) {\r\n        return writeBytes(abi.encodePacked(_in));\r\n    }\r\n\r\n    /**\r\n     * RLP encodes a uint.\r\n     * @param _in The uint256 to encode.\r\n     * @return The RLP encoded uint256 in bytes.\r\n     */\r\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\r\n        return writeBytes(_toBinary(_in));\r\n    }\r\n\r\n    /**\r\n     * RLP encodes a bool.\r\n     * @param _in The bool to encode.\r\n     * @return The RLP encoded bool in bytes.\r\n     */\r\n    function writeBool(bool _in) internal pure returns (bytes memory) {\r\n        bytes memory encoded = new bytes(1);\r\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\r\n        return encoded;\r\n    }\r\n\r\n    /*********************\r\n     * Private Functions *\r\n     *********************/\r\n\r\n    /**\r\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\r\n     * @param _len The length of the string or the payload.\r\n     * @param _offset 128 if item is string, 192 if item is list.\r\n     * @return RLP encoded bytes.\r\n     */\r\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\r\n        bytes memory encoded;\r\n\r\n        if (_len < 56) {\r\n            encoded = new bytes(1);\r\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\r\n        } else {\r\n            uint256 lenLen;\r\n            uint256 i = 1;\r\n            while (_len / i != 0) {\r\n                lenLen++;\r\n                i *= 256;\r\n            }\r\n\r\n            encoded = new bytes(lenLen + 1);\r\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\r\n            for (i = 1; i <= lenLen; i++) {\r\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\r\n            }\r\n        }\r\n\r\n        return encoded;\r\n    }\r\n\r\n    /**\r\n     * Encode integer in big endian binary form with no leading zeroes.\r\n     * @notice TODO: This should be optimized with assembly to save gas costs.\r\n     * @param _x The integer to encode.\r\n     * @return RLP encoded bytes.\r\n     */\r\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\r\n        bytes memory b = abi.encodePacked(_x);\r\n\r\n        uint256 i = 0;\r\n        for (; i < 32; i++) {\r\n            if (b[i] != 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        bytes memory res = new bytes(32 - i);\r\n        for (uint256 j = 0; j < res.length; j++) {\r\n            res[j] = b[i++];\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Copies a piece of memory to another location.\r\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\r\n     * @param _dest Destination location.\r\n     * @param _src Source location.\r\n     * @param _len Length of memory to copy.\r\n     */\r\n    function _memcpy(\r\n        uint256 _dest,\r\n        uint256 _src,\r\n        uint256 _len\r\n    ) private pure {\r\n        uint256 dest = _dest;\r\n        uint256 src = _src;\r\n        uint256 len = _len;\r\n\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        uint256 mask;\r\n        unchecked {\r\n            mask = 256**(32 - len) - 1;\r\n        }\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Flattens a list of byte strings into one byte string.\r\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\r\n     * @param _list List of byte strings to flatten.\r\n     * @return The flattened byte string.\r\n     */\r\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\r\n        if (_list.length == 0) {\r\n            return new bytes(0);\r\n        }\r\n\r\n        uint256 len;\r\n        uint256 i = 0;\r\n        for (; i < _list.length; i++) {\r\n            len += _list[i].length;\r\n        }\r\n\r\n        bytes memory flattened = new bytes(len);\r\n        uint256 flattenedPtr;\r\n        assembly {\r\n            flattenedPtr := add(flattened, 0x20)\r\n        }\r\n\r\n        for (i = 0; i < _list.length; i++) {\r\n            bytes memory item = _list[i];\r\n\r\n            uint256 listPtr;\r\n            assembly {\r\n                listPtr := add(item, 0x20)\r\n            }\r\n\r\n            _memcpy(flattenedPtr, listPtr, item.length);\r\n            flattenedPtr += _list[i].length;\r\n        }\r\n\r\n        return flattened;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/utils/Lib_BytesUtils.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * @title Lib_BytesUtils\r\n */\r\nlibrary Lib_BytesUtils {\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    ) internal pure returns (bytes memory) {\r\n        require(_length + 31 >= _length, \"slice_overflow\");\r\n        require(_start + _length >= _start, \"slice_overflow\");\r\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                //zero out the 32 bytes slice we are about to return\r\n                //we need to do it because Solidity does not garbage collect\r\n                mstore(tempBytes, 0)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\r\n        if (_start >= _bytes.length) {\r\n            return bytes(\"\");\r\n        }\r\n\r\n        return slice(_bytes, _start, _bytes.length - _start);\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {\r\n        if (_bytes.length < 32) {\r\n            bytes32 ret;\r\n            assembly {\r\n                ret := mload(add(_bytes, 32))\r\n            }\r\n            return ret;\r\n        }\r\n\r\n        return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\r\n    }\r\n\r\n    function toUint256(bytes memory _bytes) internal pure returns (uint256) {\r\n        return uint256(toBytes32(_bytes));\r\n    }\r\n\r\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\r\n        bytes memory nibbles = new bytes(_bytes.length * 2);\r\n\r\n        for (uint256 i = 0; i < _bytes.length; i++) {\r\n            nibbles[i * 2] = _bytes[i] >> 4;\r\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\r\n        }\r\n\r\n        return nibbles;\r\n    }\r\n\r\n    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\r\n        bytes memory ret = new bytes(_bytes.length / 2);\r\n\r\n        for (uint256 i = 0; i < ret.length; i++) {\r\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\r\n        return keccak256(_bytes) == keccak256(_other);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/utils/Lib_Bytes32Utils.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * @title Lib_Byte32Utils\r\n */\r\nlibrary Lib_Bytes32Utils {\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    /**\r\n     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to \"true.\"\r\n     * @param _in Input bytes32 value.\r\n     * @return Bytes32 as a boolean.\r\n     */\r\n    function toBool(bytes32 _in) internal pure returns (bool) {\r\n        return _in != 0;\r\n    }\r\n\r\n    /**\r\n     * Converts a boolean to a bytes32 value.\r\n     * @param _in Input boolean value.\r\n     * @return Boolean as a bytes32.\r\n     */\r\n    function fromBool(bool _in) internal pure returns (bytes32) {\r\n        return bytes32(uint256(_in ? 1 : 0));\r\n    }\r\n\r\n    /**\r\n     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.\r\n     * @param _in Input bytes32 value.\r\n     * @return Bytes32 as an address.\r\n     */\r\n    function toAddress(bytes32 _in) internal pure returns (address) {\r\n        return address(uint160(uint256(_in)));\r\n    }\r\n\r\n    /**\r\n     * Converts an address to a bytes32.\r\n     * @param _in Input address value.\r\n     * @return Address as a bytes32.\r\n     */\r\n    function fromAddress(address _in) internal pure returns (bytes32) {\r\n        return bytes32(uint256(uint160(_in)));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/codec/Lib_OVMCodec.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/* Library Imports */\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Lib_OVMCodec\r\n */\r\nlibrary Lib_OVMCodec {\r\n    /*********\r\n     * Enums *\r\n     *********/\r\n\r\n    enum QueueOrigin {\r\n        SEQUENCER_QUEUE,\r\n        L1TOL2_QUEUE\r\n    }\r\n\r\n    /***********\r\n     * Structs *\r\n     ***********/\r\n\r\n    struct EVMAccount {\r\n        uint256 nonce;\r\n        uint256 balance;\r\n        bytes32 storageRoot;\r\n        bytes32 codeHash;\r\n    }\r\n\r\n    struct ChainBatchHeader {\r\n        uint256 batchIndex;\r\n        bytes32 batchRoot;\r\n        uint256 batchSize;\r\n        uint256 prevTotalElements;\r\n        bytes extraData;\r\n    }\r\n\r\n    struct ChainInclusionProof {\r\n        uint256 index;\r\n        bytes32[] siblings;\r\n    }\r\n\r\n    struct Transaction {\r\n        uint256 timestamp;\r\n        uint256 blockNumber;\r\n        QueueOrigin l1QueueOrigin;\r\n        address l1TxOrigin;\r\n        address entrypoint;\r\n        uint256 gasLimit;\r\n        bytes data;\r\n    }\r\n\r\n    struct TransactionChainElement {\r\n        bool isSequenced;\r\n        uint256 queueIndex; // QUEUED TX ONLY\r\n        uint256 timestamp; // SEQUENCER TX ONLY\r\n        uint256 blockNumber; // SEQUENCER TX ONLY\r\n        bytes txData; // SEQUENCER TX ONLY\r\n    }\r\n\r\n    struct QueueElement {\r\n        bytes32 transactionHash;\r\n        uint40 timestamp;\r\n        uint40 blockNumber;\r\n    }\r\n\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    /**\r\n     * Encodes a standard OVM transaction.\r\n     * @param _transaction OVM transaction to encode.\r\n     * @return Encoded transaction bytes.\r\n     */\r\n    function encodeTransaction(Transaction memory _transaction)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            abi.encodePacked(\r\n                _transaction.timestamp,\r\n                _transaction.blockNumber,\r\n                _transaction.l1QueueOrigin,\r\n                _transaction.l1TxOrigin,\r\n                _transaction.entrypoint,\r\n                _transaction.gasLimit,\r\n                _transaction.data\r\n            );\r\n    }\r\n\r\n    /**\r\n     * Hashes a standard OVM transaction.\r\n     * @param _transaction OVM transaction to encode.\r\n     * @return Hashed transaction\r\n     */\r\n    function hashTransaction(Transaction memory _transaction) internal pure returns (bytes32) {\r\n        return keccak256(encodeTransaction(_transaction));\r\n    }\r\n\r\n    /**\r\n     * @notice Decodes an RLP-encoded account state into a useful struct.\r\n     * @param _encoded RLP-encoded account state.\r\n     * @return Account state struct.\r\n     */\r\n    function decodeEVMAccount(bytes memory _encoded) internal pure returns (EVMAccount memory) {\r\n        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\r\n\r\n        return\r\n            EVMAccount({\r\n                nonce: Lib_RLPReader.readUint256(accountState[0]),\r\n                balance: Lib_RLPReader.readUint256(accountState[1]),\r\n                storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\r\n                codeHash: Lib_RLPReader.readBytes32(accountState[3])\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Calculates a hash for a given batch header.\r\n     * @param _batchHeader Header to hash.\r\n     * @return Hash of the header.\r\n     */\r\n    function hashBatchHeader(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    _batchHeader.batchRoot,\r\n                    _batchHeader.batchSize,\r\n                    _batchHeader.prevTotalElements,\r\n                    _batchHeader.extraData\r\n                )\r\n            );\r\n    }\r\n}\r\n\r\n\r\n// File contracts/L1/rollup/IChainStorageContainer.sol\r\n\r\n// : MIT\r\npragma solidity >0.5.0 <0.9.0;\r\n\r\n/**\r\n * @title IChainStorageContainer\r\n */\r\ninterface IChainStorageContainer {\r\n    /********************\r\n     * Public Functions *\r\n     ********************/\r\n\r\n    /**\r\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\r\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\r\n     * 27 bytes to store arbitrary data.\r\n     * @param _globalMetadata New global metadata to set.\r\n     */\r\n    function setGlobalMetadata(bytes27 _globalMetadata) external;\r\n\r\n    /**\r\n     * Retrieves the container's global metadata field.\r\n     * @return Container global metadata field.\r\n     */\r\n    function getGlobalMetadata() external view returns (bytes27);\r\n\r\n    /**\r\n     * Retrieves the number of objects stored in the container.\r\n     * @return Number of objects in the container.\r\n     */\r\n    function length() external view returns (uint256);\r\n\r\n    /**\r\n     * Pushes an object into the container.\r\n     * @param _object A 32 byte value to insert into the container.\r\n     */\r\n    function push(bytes32 _object) external;\r\n\r\n    /**\r\n     * Pushes an object into the container. Function allows setting the global metadata since\r\n     * we'll need to touch the \"length\" storage slot anyway, which also contains the global\r\n     * metadata (it's an optimization).\r\n     * @param _object A 32 byte value to insert into the container.\r\n     * @param _globalMetadata New global metadata for the container.\r\n     */\r\n    function push(bytes32 _object, bytes27 _globalMetadata) external;\r\n\r\n    /**\r\n     * Set an object into the container. Function allows setting the global metadata since\r\n     * we'll need to touch the \"length\" storage slot anyway, which also contains the global\r\n     * metadata (it's an optimization).\r\n     * @param _index position.\r\n     * @param _object A 32 byte value to insert into the container.\r\n     */  \r\n    function setByChainId(\r\n        uint256 _chainId,\r\n        uint256 _index,\r\n        bytes32 _object\r\n    )\r\n        external;\r\n        \r\n    /**\r\n     * Retrieves an object from the container.\r\n     * @param _index Index of the particular object to access.\r\n     * @return 32 byte object value.\r\n     */\r\n    function get(uint256 _index) external view returns (bytes32);\r\n\r\n    /**\r\n     * Removes all objects after and including a given index.\r\n     * @param _index Object index to delete from.\r\n     */\r\n    function deleteElementsAfterInclusive(uint256 _index) external;\r\n\r\n    /**\r\n     * Removes all objects after and including a given index. Also allows setting the global\r\n     * metadata field.\r\n     * @param _index Object index to delete from.\r\n     * @param _globalMetadata New global metadata for the container.\r\n     */\r\n    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata) external;\r\n\r\n    /**\r\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\r\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\r\n     * 27 bytes to store arbitrary data.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _globalMetadata New global metadata to set.\r\n     */\r\n    function setGlobalMetadataByChainId(\r\n        uint256 _chainId,\r\n        bytes27 _globalMetadata\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Retrieves the container's global metadata field.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return Container global metadata field.\r\n     */\r\n    function getGlobalMetadataByChainId(\r\n        uint256 _chainId\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            bytes27\r\n        );\r\n\r\n    /**\r\n     * Retrieves the number of objects stored in the container.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return Number of objects in the container.\r\n     */\r\n    function lengthByChainId(\r\n        uint256 _chainId\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint256\r\n        );\r\n\r\n    /**\r\n     * Pushes an object into the container.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _object A 32 byte value to insert into the container.\r\n     */\r\n    function pushByChainId(\r\n        uint256 _chainId,\r\n        bytes32 _object\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Pushes an object into the container. Function allows setting the global metadata since\r\n     * we'll need to touch the \"length\" storage slot anyway, which also contains the global\r\n     * metadata (it's an optimization).\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _object A 32 byte value to insert into the container.\r\n     * @param _globalMetadata New global metadata for the container.\r\n     */\r\n    function pushByChainId(\r\n        uint256 _chainId,\r\n        bytes32 _object,\r\n        bytes27 _globalMetadata\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Retrieves an object from the container.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _index Index of the particular object to access.\r\n     * @return 32 byte object value.\r\n     */\r\n    function getByChainId(\r\n        uint256 _chainId,\r\n        uint256 _index\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32\r\n        );\r\n\r\n    /**\r\n     * Removes all objects after and including a given index.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _index Object index to delete from.\r\n     */\r\n    function deleteElementsAfterInclusiveByChainId(\r\n        uint256 _chainId,\r\n        uint256 _index\r\n    )\r\n        external;\r\n        \r\n    /**\r\n     * Removes all objects after and including a given index. Also allows setting the global\r\n     * metadata field.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _index Object index to delete from.\r\n     * @param _globalMetadata New global metadata for the container.\r\n     */\r\n    function deleteElementsAfterInclusiveByChainId(\r\n        uint256 _chainId,\r\n        uint256 _index,\r\n        bytes27 _globalMetadata\r\n    )\r\n        external;\r\n        \r\n}\r\n\r\n\r\n// File contracts/L1/rollup/ICanonicalTransactionChain.sol\r\n\r\n// : MIT\r\npragma solidity >0.5.0 <0.9.0;\r\n\r\n/* Library Imports */\r\n\r\n/* Interface Imports */\r\n\r\n/**\r\n * @title ICanonicalTransactionChain\r\n */\r\ninterface ICanonicalTransactionChain {\r\n    /**********\r\n     * Events *\r\n     **********/\r\n    event QueueGlobalMetadataSet(\r\n        address _sender,\r\n        uint256 _chainId,\r\n        bytes27 _globalMetadata\r\n    );\r\n    \r\n    event QueuePushed(\r\n        address _sender,\r\n        uint256 _chainId,\r\n        Lib_OVMCodec.QueueElement _object\r\n    );\r\n\r\n    event QueueSetted(\r\n        address _sender,\r\n        uint256 _chainId,\r\n        uint256 _index,\r\n        Lib_OVMCodec.QueueElement _object\r\n    );\r\n\r\n    event QueueElementDeleted(\r\n        address _sender,\r\n        uint256 _chainId,\r\n        uint256 _index,\r\n        bytes27 _globalMetadata\r\n    );\r\n\r\n    event BatchesGlobalMetadataSet(\r\n        address _sender,\r\n        uint256 _chainId,\r\n        bytes27 _globalMetadata\r\n    );\r\n    \r\n    event BatchPushed(\r\n        address _sender,\r\n        uint256 _chainId,\r\n        bytes32 _object,\r\n        bytes27 _globalMetadata\r\n    );\r\n\r\n    event BatchSetted(\r\n        address _sender,\r\n        uint256 _chainId,\r\n        uint256 _index,\r\n        bytes32 _object\r\n    );\r\n\r\n    event BatchElementDeleted(\r\n        address _sender,\r\n        uint256 _chainId,\r\n        uint256 _index,\r\n        bytes27 _globalMetadata\r\n    );\r\n\r\n    event L2GasParamsUpdated(\r\n        uint256 l2GasDiscountDivisor,\r\n        uint256 enqueueGasCost,\r\n        uint256 enqueueL2GasPrepaid\r\n    );\r\n\r\n    event TransactionEnqueued(\r\n        uint256 _chainId,\r\n        address indexed _l1TxOrigin,\r\n        address indexed _target,\r\n        uint256 _gasLimit,\r\n        bytes _data,\r\n        uint256 indexed _queueIndex,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    event QueueBatchAppended(\r\n        uint256 _chainId,\r\n        uint256 _startingQueueIndex,\r\n        uint256 _numQueueElements,\r\n        uint256 _totalElements\r\n    );\r\n\r\n    event SequencerBatchAppended(\r\n        uint256 _chainId,\r\n        uint256 _startingQueueIndex,\r\n        uint256 _numQueueElements,\r\n        uint256 _totalElements\r\n    );\r\n\r\n    event TransactionBatchAppended(\r\n        uint256 _chainId,\r\n        uint256 indexed _batchIndex,\r\n        bytes32 _batchRoot,\r\n        uint256 _batchSize,\r\n        uint256 _prevTotalElements,\r\n        bytes _extraData\r\n    );\r\n\r\n    /***********\r\n     * Structs *\r\n     ***********/\r\n\r\n    struct BatchContext {\r\n        uint256 numSequencedTransactions;\r\n        uint256 numSubsequentQueueTransactions;\r\n        uint256 timestamp;\r\n        uint256 blockNumber;\r\n    }\r\n\r\n    /*******************************\r\n     * Authorized Setter Functions *\r\n     *******************************/\r\n\r\n    /**\r\n     * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.\r\n     * The value of enqueueL2GasPrepaid is immediately updated as well.\r\n     */\r\n    function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost) external;\r\n\r\n    /********************\r\n     * Public Functions *\r\n     ********************/\r\n\r\n    /**\r\n     * Accesses the batch storage container.\r\n     * @return Reference to the batch storage container.\r\n     */\r\n    function batches() external view returns (IChainStorageContainer);\r\n\r\n    /**\r\n     * Accesses the queue storage container.\r\n     * @return Reference to the queue storage container.\r\n     */\r\n    function queue() external view returns (IChainStorageContainer);\r\n\r\n    /**\r\n     * Retrieves the total number of elements submitted.\r\n     * @return _totalElements Total submitted elements.\r\n     */\r\n    function getTotalElements() external view returns (uint256 _totalElements);\r\n\r\n    /**\r\n     * Retrieves the total number of batches submitted.\r\n     * @return _totalBatches Total submitted batches.\r\n     */\r\n    function getTotalBatches() external view returns (uint256 _totalBatches);\r\n\r\n    /**\r\n     * Returns the index of the next element to be enqueued.\r\n     * @return Index for the next queue element.\r\n     */\r\n    function getNextQueueIndex() external view returns (uint40);\r\n\r\n    /**\r\n     * Gets the queue element at a particular index.\r\n     * @param _index Index of the queue element to access.\r\n     * @return _element Queue element at the given index.\r\n     */\r\n    function getQueueElement(uint256 _index)\r\n        external\r\n        view\r\n        returns (Lib_OVMCodec.QueueElement memory _element);\r\n\r\n    /**\r\n     * Returns the timestamp of the last transaction.\r\n     * @return Timestamp for the last transaction.\r\n     */\r\n    function getLastTimestamp() external view returns (uint40);\r\n\r\n    /**\r\n     * Returns the blocknumber of the last transaction.\r\n     * @return Blocknumber for the last transaction.\r\n     */\r\n    function getLastBlockNumber() external view returns (uint40);\r\n\r\n    /**\r\n     * Get the number of queue elements which have not yet been included.\r\n     * @return Number of pending queue elements.\r\n     */\r\n    function getNumPendingQueueElements() external view returns (uint40);\r\n\r\n    /**\r\n     * Retrieves the length of the queue, including\r\n     * both pending and canonical transactions.\r\n     * @return Length of the queue.\r\n     */\r\n    function getQueueLength() external view returns (uint40);\r\n\r\n    /**\r\n     * Adds a transaction to the queue.\r\n     * @param _target Target contract to send the transaction to.\r\n     * @param _gasLimit Gas limit for the given transaction.\r\n     * @param _data Transaction data.\r\n     */\r\n    function enqueue(\r\n        address _target,\r\n        uint256 _gasLimit,\r\n        bytes memory _data\r\n    ) external;\r\n\r\n    /**\r\n     * Allows the sequencer to append a batch of transactions.\r\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\r\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\r\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\r\n     * .param _contexts Array of batch contexts.\r\n     * .param _transactionDataFields Array of raw transaction data.\r\n     */\r\n    function appendSequencerBatch(\r\n        // uint40 _shouldStartAtElement,\r\n        // uint24 _totalElementsToAppend,\r\n        // BatchContext[] _contexts,\r\n        // bytes[] _transactionDataFields\r\n    )\r\n        external;\r\n        \r\n    //added chain id function\r\n    \r\n    /**\r\n     * Retrieves the total number of elements submitted.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return _totalElements Total submitted elements.\r\n     */\r\n    function getTotalElementsByChainId(\r\n        uint256 _chainId\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 _totalElements\r\n        );\r\n\r\n    /**\r\n     * Retrieves the total number of batches submitted.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return _totalBatches Total submitted batches.\r\n     */\r\n    function getTotalBatchesByChainId(\r\n        uint256 _chainId\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 _totalBatches\r\n        );\r\n\r\n    /**\r\n     * Returns the index of the next element to be enqueued.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return Index for the next queue element.\r\n     */\r\n    function getNextQueueIndexByChainId(\r\n        uint256 _chainId\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint40\r\n        );\r\n\r\n    /**\r\n     * Gets the queue element at a particular index.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _index Index of the queue element to access.\r\n     * @return _element Queue element at the given index.\r\n     */\r\n    function getQueueElementByChainId(\r\n        uint256 _chainId,\r\n        uint256 _index\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            Lib_OVMCodec.QueueElement memory _element\r\n        );\r\n\r\n    /**\r\n     * Returns the timestamp of the last transaction.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return Timestamp for the last transaction.\r\n     */\r\n    function getLastTimestampByChainId(\r\n        uint256 _chainId\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint40\r\n        );\r\n\r\n    /**\r\n     * Returns the blocknumber of the last transaction.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return Blocknumber for the last transaction.\r\n     */\r\n    function getLastBlockNumberByChainId(\r\n        uint256 _chainId\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint40\r\n        );\r\n\r\n    /**\r\n     * Get the number of queue elements which have not yet been included.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return Number of pending queue elements.\r\n     */\r\n    function getNumPendingQueueElementsByChainId(\r\n        uint256 _chainId\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint40\r\n        );\r\n\r\n    /**\r\n     * Retrieves the length of the queue, including\r\n     * both pending and canonical transactions.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return Length of the queue.\r\n     */\r\n    function getQueueLengthByChainId(\r\n        uint256 _chainId\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint40\r\n        );\r\n\r\n\r\n    /**\r\n     * Adds a transaction to the queue.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _target Target contract to send the transaction to.\r\n     * @param _gasLimit Gas limit for the given transaction.\r\n     * @param _data Transaction data.\r\n     */\r\n    function enqueueByChainId(\r\n        uint256 _chainId,\r\n        address _target,\r\n        uint256 _gasLimit,\r\n        bytes memory _data\r\n    )\r\n        external;\r\n        \r\n    /**\r\n     * Allows the sequencer to append a batch of transactions.\r\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\r\n     * .param _chainId identity for the l2 chain.\r\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\r\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\r\n     * .param _contexts Array of batch contexts.\r\n     * .param _transactionDataFields Array of raw transaction data.\r\n     */\r\n    function appendSequencerBatchByChainId(\r\n        // uint256 _chainId,\r\n        // uint40 _shouldStartAtElement,\r\n        // uint24 _totalElementsToAppend,\r\n        // BatchContext[] _contexts,\r\n        // bytes[] _transactionDataFields\r\n    )\r\n        external;\r\n    \r\n    function pushQueueByChainId(\r\n        uint256 _chainId,\r\n        Lib_OVMCodec.QueueElement calldata _object\r\n    )\r\n        external;\r\n\r\n    function setQueueByChainId(\r\n        uint256 _chainId,\r\n        uint256 _index,\r\n        Lib_OVMCodec.QueueElement calldata _object\r\n    )\r\n        external;\r\n\r\n    function setBatchGlobalMetadataByChainId(\r\n        uint256 _chainId,\r\n        bytes27 _globalMetadata\r\n    )\r\n        external;\r\n    \r\n    function getBatchGlobalMetadataByChainId(uint256 _chainId)\r\n        external\r\n        view\r\n        returns (\r\n            bytes27\r\n        );\r\n        \r\n    function lengthBatchByChainId(uint256 _chainId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256\r\n        );\r\n        \r\n    function pushBatchByChainId(\r\n        uint256 _chainId,\r\n        bytes32 _object,\r\n        bytes27 _globalMetadata\r\n    )\r\n        external;\r\n    \r\n    function setBatchByChainId(\r\n        uint256 _chainId,\r\n        uint256 _index,\r\n        bytes32 _object\r\n    )\r\n        external;\r\n        \r\n    function getBatchByChainId(\r\n        uint256 _chainId,\r\n        uint256 _index\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32\r\n        );\r\n        \r\n    function deleteBatchElementsAfterInclusiveByChainId(\r\n        uint256 _chainId,\r\n        uint256 _index,\r\n        bytes27 _globalMetadata\r\n    )\r\n        external;\r\n}\r\n\r\n\r\n// File contracts/libraries/utils/Lib_MerkleTree.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * @title Lib_MerkleTree\r\n * @author River Keefer\r\n */\r\nlibrary Lib_MerkleTree {\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    /**\r\n     * Calculates a merkle root for a list of 32-byte leaf hashes.  WARNING: If the number\r\n     * of leaves passed in is not a power of two, it pads out the tree with zero hashes.\r\n     * If you do not know the original length of elements for the tree you are verifying, then\r\n     * this may allow empty leaves past _elements.length to pass a verification check down the line.\r\n     * Note that the _elements argument is modified, therefore it must not be used again afterwards\r\n     * @param _elements Array of hashes from which to generate a merkle root.\r\n     * @return Merkle root of the leaves, with zero hashes for non-powers-of-two (see above).\r\n     */\r\n    function getMerkleRoot(bytes32[] memory _elements) internal pure returns (bytes32) {\r\n        require(_elements.length > 0, \"Lib_MerkleTree: Must provide at least one leaf hash.\");\r\n\r\n        if (_elements.length == 1) {\r\n            return _elements[0];\r\n        }\r\n\r\n        uint256[16] memory defaults = [\r\n            0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563,\r\n            0x633dc4d7da7256660a892f8f1604a44b5432649cc8ec5cb3ced4c4e6ac94dd1d,\r\n            0x890740a8eb06ce9be422cb8da5cdafc2b58c0a5e24036c578de2a433c828ff7d,\r\n            0x3b8ec09e026fdc305365dfc94e189a81b38c7597b3d941c279f042e8206e0bd8,\r\n            0xecd50eee38e386bd62be9bedb990706951b65fe053bd9d8a521af753d139e2da,\r\n            0xdefff6d330bb5403f63b14f33b578274160de3a50df4efecf0e0db73bcdd3da5,\r\n            0x617bdd11f7c0a11f49db22f629387a12da7596f9d1704d7465177c63d88ec7d7,\r\n            0x292c23a9aa1d8bea7e2435e555a4a60e379a5a35f3f452bae60121073fb6eead,\r\n            0xe1cea92ed99acdcb045a6726b2f87107e8a61620a232cf4d7d5b5766b3952e10,\r\n            0x7ad66c0a68c72cb89e4fb4303841966e4062a76ab97451e3b9fb526a5ceb7f82,\r\n            0xe026cc5a4aed3c22a58cbd3d2ac754c9352c5436f638042dca99034e83636516,\r\n            0x3d04cffd8b46a874edf5cfae63077de85f849a660426697b06a829c70dd1409c,\r\n            0xad676aa337a485e4728a0b240d92b3ef7b3c372d06d189322bfd5f61f1e7203e,\r\n            0xa2fca4a49658f9fab7aa63289c91b7c7b6c832a6d0e69334ff5b0a3483d09dab,\r\n            0x4ebfd9cd7bca2505f7bef59cc1c12ecc708fff26ae4af19abe852afe9e20c862,\r\n            0x2def10d13dd169f550f578bda343d9717a138562e0093b380a1120789d53cf10\r\n        ];\r\n\r\n        // Reserve memory space for our hashes.\r\n        bytes memory buf = new bytes(64);\r\n\r\n        // We'll need to keep track of left and right siblings.\r\n        bytes32 leftSibling;\r\n        bytes32 rightSibling;\r\n\r\n        // Number of non-empty nodes at the current depth.\r\n        uint256 rowSize = _elements.length;\r\n\r\n        // Current depth, counting from 0 at the leaves\r\n        uint256 depth = 0;\r\n\r\n        // Common sub-expressions\r\n        uint256 halfRowSize; // rowSize / 2\r\n        bool rowSizeIsOdd; // rowSize % 2 == 1\r\n\r\n        while (rowSize > 1) {\r\n            halfRowSize = rowSize / 2;\r\n            rowSizeIsOdd = rowSize % 2 == 1;\r\n\r\n            for (uint256 i = 0; i < halfRowSize; i++) {\r\n                leftSibling = _elements[(2 * i)];\r\n                rightSibling = _elements[(2 * i) + 1];\r\n                assembly {\r\n                    mstore(add(buf, 32), leftSibling)\r\n                    mstore(add(buf, 64), rightSibling)\r\n                }\r\n\r\n                _elements[i] = keccak256(buf);\r\n            }\r\n\r\n            if (rowSizeIsOdd) {\r\n                leftSibling = _elements[rowSize - 1];\r\n                rightSibling = bytes32(defaults[depth]);\r\n                assembly {\r\n                    mstore(add(buf, 32), leftSibling)\r\n                    mstore(add(buf, 64), rightSibling)\r\n                }\r\n\r\n                _elements[halfRowSize] = keccak256(buf);\r\n            }\r\n\r\n            rowSize = halfRowSize + (rowSizeIsOdd ? 1 : 0);\r\n            depth++;\r\n        }\r\n\r\n        return _elements[0];\r\n    }\r\n\r\n    /**\r\n     * Verifies a merkle branch for the given leaf hash.  Assumes the original length\r\n     * of leaves generated is a known, correct input, and does not return true for indices\r\n     * extending past that index (even if _siblings would be otherwise valid.)\r\n     * @param _root The Merkle root to verify against.\r\n     * @param _leaf The leaf hash to verify inclusion of.\r\n     * @param _index The index in the tree of this leaf.\r\n     * @param _siblings Array of sibline nodes in the inclusion proof, starting from depth 0\r\n     * (bottom of the tree).\r\n     * @param _totalLeaves The total number of leaves originally passed into.\r\n     * @return Whether or not the merkle branch and leaf passes verification.\r\n     */\r\n    function verify(\r\n        bytes32 _root,\r\n        bytes32 _leaf,\r\n        uint256 _index,\r\n        bytes32[] memory _siblings,\r\n        uint256 _totalLeaves\r\n    ) internal pure returns (bool) {\r\n        require(_totalLeaves > 0, \"Lib_MerkleTree: Total leaves must be greater than zero.\");\r\n\r\n        require(_index < _totalLeaves, \"Lib_MerkleTree: Index out of bounds.\");\r\n\r\n        require(\r\n            _siblings.length == _ceilLog2(_totalLeaves),\r\n            \"Lib_MerkleTree: Total siblings does not correctly correspond to total leaves.\"\r\n        );\r\n\r\n        bytes32 computedRoot = _leaf;\r\n\r\n        for (uint256 i = 0; i < _siblings.length; i++) {\r\n            if ((_index & 1) == 1) {\r\n                computedRoot = keccak256(abi.encodePacked(_siblings[i], computedRoot));\r\n            } else {\r\n                computedRoot = keccak256(abi.encodePacked(computedRoot, _siblings[i]));\r\n            }\r\n\r\n            _index >>= 1;\r\n        }\r\n\r\n        return _root == computedRoot;\r\n    }\r\n\r\n    /*********************\r\n     * Private Functions *\r\n     *********************/\r\n\r\n    /**\r\n     * Calculates the integer ceiling of the log base 2 of an input.\r\n     * @param _in Unsigned input to calculate the log.\r\n     * @return ceil(log_base_2(_in))\r\n     */\r\n    function _ceilLog2(uint256 _in) private pure returns (uint256) {\r\n        require(_in > 0, \"Lib_MerkleTree: Cannot compute ceil(log_2) of 0.\");\r\n\r\n        if (_in == 1) {\r\n            return 0;\r\n        }\r\n\r\n        // Find the highest set bit (will be floor(log_2)).\r\n        // Borrowed with <3 from https://github.com/ethereum/solidity-examples\r\n        uint256 val = _in;\r\n        uint256 highest = 0;\r\n        for (uint256 i = 128; i >= 1; i >>= 1) {\r\n            if (val & (((uint256(1) << i) - 1) << i) != 0) {\r\n                highest += i;\r\n                val >>= i;\r\n            }\r\n        }\r\n\r\n        // Increment by one if this is not a perfect logarithm.\r\n        if ((uint256(1) << highest) != _in) {\r\n            highest += 1;\r\n        }\r\n\r\n        return highest;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/L1/rollup/IStateCommitmentChain.sol\r\n\r\n// : MIT\r\npragma solidity >0.5.0 <0.9.0;\r\n\r\n/* Library Imports */\r\n\r\n\r\n/**\r\n * @title IStateCommitmentChain\r\n */\r\ninterface IStateCommitmentChain {\r\n    /**********\r\n     * Events *\r\n     **********/\r\n\r\n    event StateBatchAppended(\r\n        uint256 _chainId,\r\n        uint256 indexed _batchIndex,\r\n        bytes32 _batchRoot,\r\n        uint256 _batchSize,\r\n        uint256 _prevTotalElements,\r\n        bytes _extraData\r\n    );\r\n\r\n    event StateBatchDeleted(\r\n        uint256 _chainId,\r\n        uint256 indexed _batchIndex,\r\n        bytes32 _batchRoot\r\n    );\r\n\r\n\r\n    /********************\r\n     * Public Functions *\r\n     ********************/\r\n    \r\n    function batches() external view returns (IChainStorageContainer);\r\n    \r\n    /**\r\n     * Retrieves the total number of elements submitted.\r\n     * @return _totalElements Total submitted elements.\r\n     */\r\n    function getTotalElements() external view returns (uint256 _totalElements);\r\n\r\n    /**\r\n     * Retrieves the total number of batches submitted.\r\n     * @return _totalBatches Total submitted batches.\r\n     */\r\n    function getTotalBatches() external view returns (uint256 _totalBatches);\r\n\r\n    /**\r\n     * Retrieves the timestamp of the last batch submitted by the sequencer.\r\n     * @return _lastSequencerTimestamp Last sequencer batch timestamp.\r\n     */\r\n    function getLastSequencerTimestamp() external view returns (uint256 _lastSequencerTimestamp);\r\n\r\n    /**\r\n     * Appends a batch of state roots to the chain.\r\n     * @param _batch Batch of state roots.\r\n     * @param _shouldStartAtElement Index of the element at which this batch should start.\r\n     */\r\n    function appendStateBatch(bytes32[] calldata _batch, uint256 _shouldStartAtElement) external;\r\n\r\n    /**\r\n     * Deletes all state roots after (and including) a given batch.\r\n     * @param _batchHeader Header of the batch to start deleting from.\r\n     */\r\n    function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) external;\r\n\r\n    /**\r\n     * Verifies a batch inclusion proof.\r\n     * @param _element Hash of the element to verify a proof for.\r\n     * @param _batchHeader Header of the batch in which the element was included.\r\n     * @param _proof Merkle inclusion proof for the element.\r\n     */\r\n    function verifyStateCommitment(\r\n        bytes32 _element,\r\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\r\n        Lib_OVMCodec.ChainInclusionProof memory _proof\r\n    ) external view returns (bool _verified);\r\n\r\n    /**\r\n     * Checks whether a given batch is still inside its fraud proof window.\r\n     * @param _batchHeader Header of the batch to check.\r\n     * @return _inside Whether or not the batch is inside the fraud proof window.\r\n     */\r\n    function insideFraudProofWindow(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\r\n        external\r\n        view\r\n        returns (\r\n            bool _inside\r\n        );\r\n        \r\n        \r\n        \r\n     /********************\r\n     * chain id added func *\r\n     ********************/\r\n\r\n    /**\r\n     * Retrieves the total number of elements submitted.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return _totalElements Total submitted elements.\r\n     */\r\n    function getTotalElementsByChainId(uint256 _chainId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 _totalElements\r\n        );\r\n\r\n    /**\r\n     * Retrieves the total number of batches submitted.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return _totalBatches Total submitted batches.\r\n     */\r\n    function getTotalBatchesByChainId(uint256 _chainId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 _totalBatches\r\n        );\r\n\r\n    /**\r\n     * Retrieves the timestamp of the last batch submitted by the sequencer.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @return _lastSequencerTimestamp Last sequencer batch timestamp.\r\n     */\r\n    function getLastSequencerTimestampByChainId(uint256 _chainId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 _lastSequencerTimestamp\r\n        );\r\n        \r\n    /**\r\n     * Appends a batch of state roots to the chain.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _batch Batch of state roots.\r\n     * @param _shouldStartAtElement Index of the element at which this batch should start.\r\n     */\r\n    function appendStateBatchByChainId(\r\n        uint256 _chainId,\r\n        bytes32[] calldata _batch,\r\n        uint256 _shouldStartAtElement,\r\n        string calldata proposer\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Deletes all state roots after (and including) a given batch.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _batchHeader Header of the batch to start deleting from.\r\n     */\r\n    function deleteStateBatchByChainId(\r\n        uint256 _chainId,\r\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Verifies a batch inclusion proof.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _element Hash of the element to verify a proof for.\r\n     * @param _batchHeader Header of the batch in which the element was included.\r\n     * @param _proof Merkle inclusion proof for the element.\r\n     */\r\n    function verifyStateCommitmentByChainId(\r\n        uint256 _chainId,\r\n        bytes32 _element,\r\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\r\n        Lib_OVMCodec.ChainInclusionProof memory _proof\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bool _verified\r\n        );\r\n\r\n    /**\r\n     * Checks whether a given batch is still inside its fraud proof window.\r\n     * @param _chainId identity for the l2 chain.\r\n     * @param _batchHeader Header of the batch to check.\r\n     * @return _inside Whether or not the batch is inside the fraud proof window.\r\n     */\r\n    function insideFraudProofWindowByChainId(\r\n        uint256 _chainId,\r\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bool _inside\r\n        );\r\n}\r\n\r\n\r\n// File contracts/L1/verification/IBondManager.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * @title IBondManager\r\n */\r\ninterface IBondManager {\r\n    /********************\r\n     * Public Functions *\r\n     ********************/\r\n\r\n    function isCollateralized(address _who) external view returns (bool);\r\n    function isCollateralizedByChainId(\r\n        uint256 _chainId,\r\n        address _who,\r\n        address _prop\r\n    ) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/L1/rollup/StateCommitmentChain.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/* Library Imports */\r\n\r\n\r\n\r\n/* Interface Imports */\r\n\r\n\r\n\r\n\r\n/**\r\n * @title StateCommitmentChain\r\n * @dev The State Commitment Chain (SCC) contract contains a list of proposed state roots which\r\n * Proposers assert to be a result of each transaction in the Canonical Transaction Chain (CTC).\r\n * Elements here have a 1:1 correspondence with transactions in the CTC, and should be the unique\r\n * state root calculated off-chain by applying the canonical transactions one by one.\r\n *\r\n * Runtime target: EVM\r\n */\r\ncontract StateCommitmentChain is IStateCommitmentChain, Lib_AddressResolver {\r\n\r\n    /*************\r\n     * Constants *\r\n     *************/\r\n\r\n    uint256 public FRAUD_PROOF_WINDOW;\r\n    uint256 public SEQUENCER_PUBLISH_WINDOW;\r\n    \r\n    \r\n    uint256 public DEFAULT_CHAINID = 1088;\r\n\r\n\r\n    /***************\r\n     * Constructor *\r\n     ***************/\r\n\r\n    /**\r\n     * @param _libAddressManager Address of the Address Manager.\r\n     */\r\n    constructor(\r\n        address _libAddressManager,\r\n        uint256 _fraudProofWindow,\r\n        uint256 _sequencerPublishWindow\r\n    )\r\n        Lib_AddressResolver(_libAddressManager)\r\n    {\r\n        FRAUD_PROOF_WINDOW = _fraudProofWindow;\r\n        SEQUENCER_PUBLISH_WINDOW = _sequencerPublishWindow;\r\n    }\r\n    \r\n    function setFraudProofWindow (uint256 window) public {\r\n        require (msg.sender == resolve(\"METIS_MANAGER\"), \"now allowed\");\r\n        FRAUD_PROOF_WINDOW = window;\r\n    }\r\n\r\n    /********************\r\n     * Public Functions *\r\n     ********************/\r\n\r\n    /**\r\n     * Accesses the batch storage container.\r\n     * @return Reference to the batch storage container.\r\n     */\r\n    function batches() public view returns (IChainStorageContainer) {\r\n        return IChainStorageContainer(resolve(\"ChainStorageContainer-SCC-batches\"));\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IStateCommitmentChain\r\n     */\r\n    function getTotalElements() public view returns (uint256 _totalElements) {\r\n        return getTotalElementsByChainId(DEFAULT_CHAINID);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IStateCommitmentChain\r\n     */\r\n    function getTotalBatches() public view returns (uint256 _totalBatches) {\r\n        return getTotalBatchesByChainId(DEFAULT_CHAINID);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IStateCommitmentChain\r\n     */\r\n    function getLastSequencerTimestamp() public view returns (uint256 _lastSequencerTimestamp) {\r\n        return getLastSequencerTimestampByChainId(DEFAULT_CHAINID);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IStateCommitmentChain\r\n     */\r\n    function appendStateBatch(bytes32[] memory _batch, uint256 _shouldStartAtElement) public {\r\n        require (1==0, \"don't use\");\r\n        //appendStateBatchByChainId(DEFAULT_CHAINID, _batch, _shouldStartAtElement, \"1088_MVM_Proposer\");\r\n    }\r\n    \r\n    /**\r\n     * @inheritdoc IStateCommitmentChain\r\n     */\r\n    function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) public {\r\n        deleteStateBatchByChainId(DEFAULT_CHAINID, _batchHeader);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IStateCommitmentChain\r\n     */\r\n    function verifyStateCommitment(\r\n        bytes32 _element,\r\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\r\n        Lib_OVMCodec.ChainInclusionProof memory _proof\r\n    ) public view returns (bool) {\r\n        return verifyStateCommitmentByChainId(DEFAULT_CHAINID, _element, _batchHeader, _proof);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IStateCommitmentChain\r\n     */\r\n    function insideFraudProofWindow(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\r\n        public\r\n        view\r\n        returns (bool _inside)\r\n    {\r\n        (uint256 timestamp, ) = abi.decode(_batchHeader.extraData, (uint256, address));\r\n\r\n        require(timestamp != 0, \"Batch header timestamp cannot be zero\");\r\n        return (timestamp + FRAUD_PROOF_WINDOW) > block.timestamp;\r\n    }\r\n\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    /**\r\n     * Parses the batch context from the extra data.\r\n     * @return Total number of elements submitted.\r\n     * @return Timestamp of the last batch submitted by the sequencer.\r\n     */\r\n    function _getBatchExtraData() internal view returns (uint40, uint40) {\r\n        bytes27 extraData = batches().getGlobalMetadata();\r\n\r\n        // solhint-disable max-line-length\r\n        uint40 totalElements;\r\n        uint40 lastSequencerTimestamp;\r\n        assembly {\r\n            extraData := shr(40, extraData)\r\n            totalElements := and(\r\n                extraData,\r\n                0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF\r\n            )\r\n            lastSequencerTimestamp := shr(\r\n                40,\r\n                and(extraData, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000)\r\n            )\r\n        }\r\n        // solhint-enable max-line-length\r\n\r\n        return (totalElements, lastSequencerTimestamp);\r\n    }\r\n\r\n    /**\r\n     * Encodes the batch context for the extra data.\r\n     * @param _totalElements Total number of elements submitted.\r\n     * @param _lastSequencerTimestamp Timestamp of the last batch submitted by the sequencer.\r\n     * @return Encoded batch context.\r\n     */\r\n    function _makeBatchExtraData(uint40 _totalElements, uint40 _lastSequencerTimestamp)\r\n        internal\r\n        pure\r\n        returns (bytes27)\r\n    {\r\n        bytes27 extraData;\r\n        assembly {\r\n            extraData := _totalElements\r\n            extraData := or(extraData, shl(40, _lastSequencerTimestamp))\r\n            extraData := shl(40, extraData)\r\n        }\r\n\r\n        return extraData;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IStateCommitmentChain\r\n     */\r\n    function getTotalElementsByChainId(\r\n        uint256 _chainId\r\n        )\r\n        override\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _totalElements\r\n        )\r\n    {\r\n        (uint40 totalElements, ) = _getBatchExtraDataByChainId(_chainId);\r\n        return uint256(totalElements);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IStateCommitmentChain\r\n     */\r\n    function getTotalBatchesByChainId(\r\n        uint256 _chainId\r\n        )\r\n        override\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _totalBatches\r\n        )\r\n    {\r\n        return batches().lengthByChainId(_chainId);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IStateCommitmentChain\r\n     */\r\n    function getLastSequencerTimestampByChainId(\r\n        uint256 _chainId\r\n        )\r\n        override\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _lastSequencerTimestamp\r\n        )\r\n    {\r\n        (, uint40 lastSequencerTimestamp) = _getBatchExtraDataByChainId(_chainId);\r\n        return uint256(lastSequencerTimestamp);\r\n    }\r\n    \r\n    /**\r\n     * @inheritdoc IStateCommitmentChain\r\n     */\r\n    function appendStateBatchByChainId(\r\n        uint256 _chainId,\r\n        bytes32[] calldata _batch,\r\n        uint256 _shouldStartAtElement,\r\n        string calldata proposer\r\n    )\r\n        override\r\n        public\r\n    {\r\n        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\r\n        // publication of batches by some other user.\r\n        require(\r\n            _shouldStartAtElement == getTotalElementsByChainId(_chainId),\r\n            \"Actual batch start index does not match expected start index.\"\r\n        );\r\n        \r\n        address proposerAddr = resolve(proposer);\r\n\r\n        // Proposers must have previously staked at the BondManager\r\n        require(\r\n            IBondManager(resolve(\"BondManager\")).isCollateralizedByChainId(_chainId,msg.sender,proposerAddr),\r\n            \"Proposer does not have enough collateral posted\"\r\n        );\r\n\r\n        require(\r\n            _batch.length > 0,\r\n            \"Cannot submit an empty state batch.\"\r\n        );\r\n\r\n        require(\r\n            getTotalElementsByChainId(_chainId) + _batch.length <= ICanonicalTransactionChain(resolve(\"CanonicalTransactionChain\")).getTotalElementsByChainId(_chainId),\r\n            \"Number of state roots cannot exceed the number of canonical transactions.\"\r\n        );\r\n\r\n        // Pass the block's timestamp and the publisher of the data\r\n        // to be used in the fraud proofs\r\n        _appendBatchByChainId(\r\n            _chainId,\r\n            _batch,\r\n            abi.encode(block.timestamp, msg.sender),\r\n            proposerAddr\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IStateCommitmentChain\r\n     */\r\n    function deleteStateBatchByChainId(\r\n        uint256 _chainId,\r\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\r\n    )\r\n        override\r\n        public\r\n    {\r\n        require(\r\n            msg.sender == resolve(\r\n              string(abi.encodePacked(uint2str(_chainId),\"_MVM_FraudVerifier\"))),\r\n            \"State batches can only be deleted by the MVM_FraudVerifier.\"\r\n        );\r\n\r\n        require(\r\n            _isValidBatchHeaderByChainId(_chainId,_batchHeader),\r\n            \"Invalid batch header.\"\r\n        );\r\n\r\n        require(\r\n            insideFraudProofWindowByChainId(_chainId,_batchHeader),\r\n            \"State batches can only be deleted within the fraud proof window.\"\r\n        );\r\n\r\n        _deleteBatchByChainId(_chainId,_batchHeader);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IStateCommitmentChain\r\n     */\r\n    function verifyStateCommitmentByChainId(\r\n        uint256 _chainId,\r\n        bytes32 _element,\r\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\r\n        Lib_OVMCodec.ChainInclusionProof memory _proof\r\n    )\r\n        override\r\n        public\r\n        view\r\n        returns (\r\n            bool\r\n        )\r\n    {\r\n        require(\r\n            _isValidBatchHeaderByChainId(_chainId,_batchHeader),\r\n            \"Invalid batch header.\"\r\n        );\r\n\r\n        require(\r\n            Lib_MerkleTree.verify(\r\n                _batchHeader.batchRoot,\r\n                _element,\r\n                _proof.index,\r\n                _proof.siblings,\r\n                _batchHeader.batchSize\r\n            ),\r\n            \"Invalid inclusion proof.\"\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IStateCommitmentChain\r\n     */\r\n    function insideFraudProofWindowByChainId(\r\n        uint256 _chainId,\r\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\r\n    )\r\n        override\r\n        public\r\n        view\r\n        returns (\r\n            bool _inside\r\n        )\r\n    {\r\n        (uint256 timestamp,) = abi.decode(\r\n            _batchHeader.extraData,\r\n            (uint256, address)\r\n        );\r\n\r\n        require(\r\n            timestamp != 0,\r\n            \"Batch header timestamp cannot be zero\"\r\n        );\r\n        return timestamp + FRAUD_PROOF_WINDOW > block.timestamp;\r\n    }\r\n    \r\n\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    /**\r\n     * Parses the batch context from the extra data.\r\n     * @return Total number of elements submitted.\r\n     * @return Timestamp of the last batch submitted by the sequencer.\r\n     */\r\n    function _getBatchExtraDataByChainId(\r\n        uint256 _chainId\r\n        )\r\n        internal\r\n        view\r\n        returns (\r\n            uint40,\r\n            uint40\r\n        )\r\n    {\r\n        bytes27 extraData = batches().getGlobalMetadataByChainId(_chainId);\r\n\r\n        uint40 totalElements;\r\n        uint40 lastSequencerTimestamp;\r\n        assembly {\r\n            extraData              := shr(40, extraData)\r\n            totalElements          :=         and(extraData, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)\r\n            lastSequencerTimestamp := shr(40, and(extraData, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000))\r\n        }\r\n\r\n        return (\r\n            totalElements,\r\n            lastSequencerTimestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Encodes the batch context for the extra data.\r\n     * @param _totalElements Total number of elements submitted.\r\n     * @param _lastSequencerTimestamp Timestamp of the last batch submitted by the sequencer.\r\n     * @return Encoded batch context.\r\n     */\r\n    function _makeBatchExtraDataByChainId(\r\n        uint256 _chainId,\r\n        uint40 _totalElements,\r\n        uint40 _lastSequencerTimestamp\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            bytes27\r\n        )\r\n    {\r\n        bytes27 extraData;\r\n        assembly {\r\n            extraData := _totalElements\r\n            extraData := or(extraData, shl(40, _lastSequencerTimestamp))\r\n            extraData := shl(40, extraData)\r\n        }\r\n\r\n        return extraData;\r\n    }\r\n\r\n    /**\r\n     * Appends a batch to the chain.\r\n     * @param _batch Elements within the batch.\r\n     * @param _extraData Any extra data to append to the batch.\r\n     */\r\n    function _appendBatchByChainId(\r\n        uint256 _chainId,\r\n        bytes32[] memory _batch,\r\n        bytes memory _extraData,\r\n        address proposer\r\n    )\r\n        internal\r\n    {\r\n        (uint40 totalElements, uint40 lastSequencerTimestamp) = _getBatchExtraDataByChainId(_chainId);\r\n\r\n        if (msg.sender == proposer) {\r\n            lastSequencerTimestamp = uint40(block.timestamp);\r\n        } else {\r\n            // We keep track of the last batch submitted by the sequencer so there's a window in\r\n            // which only the sequencer can publish state roots. A window like this just reduces\r\n            // the chance of \"system breaking\" state roots being published while we're still in\r\n            // testing mode. This window should be removed or significantly reduced in the future.\r\n            require(\r\n                lastSequencerTimestamp + SEQUENCER_PUBLISH_WINDOW < block.timestamp,\r\n                \"Cannot publish state roots within the sequencer publication window.\"\r\n            );\r\n        }\r\n\r\n        // For efficiency reasons getMerkleRoot modifies the `_batch` argument in place\r\n        // while calculating the root hash therefore any arguments passed to it must not\r\n        // be used again afterwards\r\n        Lib_OVMCodec.ChainBatchHeader memory batchHeader = Lib_OVMCodec.ChainBatchHeader({\r\n            batchIndex: getTotalBatchesByChainId(_chainId),\r\n            batchRoot: Lib_MerkleTree.getMerkleRoot(_batch),\r\n            batchSize: _batch.length,\r\n            prevTotalElements: totalElements,\r\n            extraData: _extraData\r\n        });\r\n\r\n        emit StateBatchAppended(\r\n            _chainId,\r\n            batchHeader.batchIndex,\r\n            batchHeader.batchRoot,\r\n            batchHeader.batchSize,\r\n            batchHeader.prevTotalElements,\r\n            batchHeader.extraData\r\n        );\r\n\r\n        batches().pushByChainId(\r\n            _chainId,\r\n            Lib_OVMCodec.hashBatchHeader(batchHeader),\r\n            _makeBatchExtraDataByChainId(\r\n                _chainId,\r\n                uint40(batchHeader.prevTotalElements + batchHeader.batchSize),\r\n                lastSequencerTimestamp\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Removes a batch and all subsequent batches from the chain.\r\n     * @param _batchHeader Header of the batch to remove.\r\n     */\r\n    function _deleteBatchByChainId(\r\n        uint256 _chainId,\r\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\r\n    )\r\n        internal\r\n    {\r\n        require(\r\n            _batchHeader.batchIndex < batches().lengthByChainId(_chainId),\r\n            \"Invalid batch index.\"\r\n        );\r\n\r\n        require(\r\n            _isValidBatchHeaderByChainId(_chainId,_batchHeader),\r\n            \"Invalid batch header.\"\r\n        );\r\n\r\n        batches().deleteElementsAfterInclusiveByChainId(\r\n            _chainId,\r\n            _batchHeader.batchIndex,\r\n            _makeBatchExtraDataByChainId(\r\n                _chainId,\r\n                uint40(_batchHeader.prevTotalElements),\r\n                0\r\n            )\r\n        );\r\n\r\n        emit StateBatchDeleted(\r\n            _chainId,\r\n            _batchHeader.batchIndex,\r\n            _batchHeader.batchRoot\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks that a batch header matches the stored hash for the given index.\r\n     * @param _batchHeader Batch header to validate.\r\n     * @return Whether or not the header matches the stored one.\r\n     */\r\n    function _isValidBatchHeaderByChainId(\r\n        uint256 _chainId,\r\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            bool\r\n        )\r\n    {\r\n        return Lib_OVMCodec.hashBatchHeader(_batchHeader) == batches().getByChainId(_chainId,_batchHeader.batchIndex);\r\n    }\r\n    \r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/MVM/MVM_CanonicalTransaction.sol\r\n\r\n// : MIT\r\npragma solidity ^0.8.9;\r\n\r\n/* Library Imports */\r\n\r\n/* Interface Imports */\r\n\r\n\r\n\r\n\r\n\r\ncontract MVM_CanonicalTransaction is iMVM_CanonicalTransaction, Lib_AddressResolver{\r\n    /*************\r\n     * Constants *\r\n     *************/\r\n\r\n    string constant public CONFIG_OWNER_KEY = \"METIS_MANAGER\";\r\n\r\n    // lock seconds when begin to submit batch tx data slice\r\n    uint256 constant public TXDATA_SUBMIT_TIMEOUT = 1800;\r\n\r\n    /*************\r\n     * Variables *\r\n     *************/\r\n\r\n    // submit tx data slice size (in bytes)\r\n    uint256 public txDataSliceSize;\r\n    // stake duration seconds for sequencer submit batch tx data\r\n    uint256 public stakeSeqSeconds;\r\n    // verifier stake base cost for a batch tx data requirement (in ETH)\r\n    uint256 public stakeBaseCost;\r\n    // submit tx data slice count (a whole tx batch)\r\n    uint256 public txDataSliceCount;\r\n    // submit tx batch size (in bytes)\r\n    uint256 public txBatchSize;\r\n    // verifier stake unit cost for a batch tx data requirement (in ETH)\r\n    uint256 public stakeUnitCost;\r\n\r\n    bool useWhiteList;\r\n\r\n    /***************\r\n     * Queue State *\r\n     ***************/\r\n\r\n    // white list\r\n    mapping (address => bool) public whitelist;\r\n\r\n    // mapping(address => uint256) private addressChains;\r\n\r\n    // verifier stakes statistic\r\n    mapping(address => uint256) private verifierStakes;\r\n\r\n    // batch element information for validation queue\r\n    mapping(uint256 => mapping(uint256 => BatchElement)) queueBatchElement;\r\n\r\n    // tx data request stake queue\r\n    mapping(uint256 => mapping(uint256 => TxDataRequestStake)) queueTxDataRequestStake;\r\n\r\n    // tx data for verification queue\r\n    mapping(uint256 => mapping(uint256 => TxDataSlice)) queueTxData;\r\n\r\n    /***************\r\n     * Constructor *\r\n     ***************/\r\n\r\n    constructor() Lib_AddressResolver(address(0)) {}\r\n\r\n    /**********************\r\n     * Function Modifiers *\r\n     **********************/\r\n\r\n    modifier onlyManager {\r\n        require(\r\n            msg.sender == resolve(CONFIG_OWNER_KEY),\r\n            \"MVM_CanonicalTransaction: Function can only be called by the METIS_MANAGER.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhitelisted {\r\n        require(isWhiteListed(msg.sender), \"only whitelisted verifiers can call\");\r\n        _;\r\n    }\r\n\r\n    /********************\r\n     * Public Functions *\r\n     ********************/\r\n    /**\r\n    receive() external payable {\r\n        // msg.sender\r\n        if (msg.sender == resolve('MVM_DiscountOracle')) {\r\n            uint256 _chainId = getAddressChainId(msg.sender);\r\n            if (_chainId > 0) {\r\n                address _to = resolve(string(abi.encodePacked(uint2str(_chainId),\"_MVM_Sequencer_Wrapper\")));\r\n                if (_to != address(0) && _to != address(this)) {\r\n                    _to.call{value: msg.value}(\"\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function setAddressChainId(address _address, uint256 _chainId)  override public onlyManager {\r\n        require(_address != address(0), \"address not available\");\r\n        require(_chainId > 0, \"chainId not available\");\r\n        require(addressChains[_address] != _chainId, \"no change\");\r\n        addressChains[_address] = _chainId;\r\n    }\r\n\r\n    function getAddressChainId(address _address) override public view returns (uint256) {\r\n        return addressChains[_address];\r\n    }\r\n    */\r\n\r\n    function setStakeBaseCost(uint256 _stakeBaseCost) override public onlyManager {\r\n        // 1e16 = 0.01 ether\r\n        // require(_stakeBaseCost >= 1e16, \"stake base cost should gte 1e16\");\r\n        stakeBaseCost = _stakeBaseCost;\r\n    }\r\n\r\n    function getStakeBaseCost() override public view returns (uint256) {\r\n        return stakeBaseCost;\r\n    }\r\n\r\n    function setStakeUnitCost(uint256 _stakeUnitCost) override public onlyManager {\r\n        // 1e16 = 0.01 ether\r\n        stakeUnitCost = _stakeUnitCost;\r\n    }\r\n\r\n    function getStakeUnitCost() override public view returns (uint256) {\r\n        return stakeUnitCost;\r\n    }\r\n\r\n    function getStakeCostByBatch(uint256 _chainId, uint256 _batchIndex) override public view returns (uint256) {\r\n        require(stakeBaseCost > 0, \"stake base cost not config yet\");\r\n        require(queueBatchElement[_chainId][_batchIndex].txBatchTime > 0, \"batch element does not exist\");\r\n        return stakeBaseCost + queueBatchElement[_chainId][_batchIndex].txBatchSize * stakeUnitCost;\r\n    }\r\n\r\n    function setTxDataSliceSize(uint256 _size) override public onlyManager {\r\n        require(_size > 0, \"slice size should gt 0\");\r\n        require(_size != txDataSliceSize, \"slice size has not changed\");\r\n        txDataSliceSize = _size;\r\n    }\r\n\r\n    function getTxDataSliceSize() override public view returns (uint256) {\r\n        return txDataSliceSize;\r\n    }\r\n\r\n    function setTxDataSliceCount(uint256 _count) override public onlyManager {\r\n        require(_count > 0, \"slice count should gt 0\");\r\n        require(_count != txDataSliceCount, \"slice count has not changed\");\r\n        txDataSliceCount = _count;\r\n    }\r\n\r\n    function getTxDataSliceCount() override public view returns (uint256) {\r\n        return txDataSliceCount;\r\n    }\r\n\r\n    function setTxBatchSize(uint256 _size) override public onlyManager {\r\n        require(_size > 0, \"batch size should gt 0\");\r\n        require(_size != txBatchSize, \"batch size has not changed\");\r\n        txBatchSize = _size;\r\n    }\r\n\r\n    function getTxBatchSize() override public view returns (uint256) {\r\n        return txBatchSize;\r\n    }\r\n\r\n    function setStakeSeqSeconds(uint256 _seconds) override public onlyManager {\r\n        require(_seconds > 0, \"seconds should gt 0\");\r\n        require(_seconds != stakeSeqSeconds, \"seconds has not changed\");\r\n        stakeSeqSeconds = _seconds;\r\n    }\r\n\r\n    function getStakeSeqSeconds() override public view returns (uint256) {\r\n        return stakeSeqSeconds;\r\n    }\r\n\r\n    function isWhiteListed(address _verifier) override public view returns(bool){\r\n        return !useWhiteList || whitelist[_verifier];\r\n    }\r\n\r\n    function setWhiteList(address _verifier, bool _allowed) override public onlyManager {\r\n        whitelist[_verifier] = _allowed;\r\n        useWhiteList = true;\r\n    }\r\n\r\n    function disableWhiteList() override public onlyManager {\r\n        useWhiteList = false;\r\n    }\r\n\r\n    function appendSequencerBatchByChainId() override public {\r\n        uint256 _chainId;\r\n        uint40 shouldStartAtElement;\r\n        uint24 totalElementsToAppend;\r\n        uint24 numContexts;\r\n        uint256 batchTime;\r\n        uint256 _dataSize;\r\n        uint256 txSize;\r\n        bytes32 root;\r\n        assembly {\r\n            _dataSize             := calldatasize()\r\n            _chainId              := calldataload(4)\r\n            shouldStartAtElement  := shr(216, calldataload(36))\r\n            totalElementsToAppend := shr(232, calldataload(41))\r\n            numContexts           := shr(232, calldataload(44))\r\n        }\r\n        require(\r\n            msg.sender == resolve(string(abi.encodePacked(uint2str(_chainId),\"_MVM_Sequencer_Wrapper\"))),\r\n            \"Function can only be called by the Sequencer.\"\r\n        );\r\n        uint256 posTs =  47 + 16 * numContexts;\r\n        if (_dataSize > posTs) {\r\n            // when tx count = 0, there is no hash!\r\n            // string len: [13]{milliseconds}-[1]{0}-[8]{sizeOfData}-[64]{hash}-[64]{root}\r\n            uint256 posTxSize = 7 + posTs;\r\n            uint256 posRoot =  11 + posTs;\r\n            assembly {\r\n                batchTime := shr(204, calldataload(posTs))\r\n                txSize := shr(224, calldataload(posTxSize))\r\n                root := calldataload(posRoot)\r\n            }\r\n\r\n            // check batch size\r\n            require(txSize / 2 <= txBatchSize, \"size of tx data is too large\");\r\n        }\r\n\r\n        address ctc = resolve(\"CanonicalTransactionChain\");\r\n        IChainStorageContainer batchesRef = ICanonicalTransactionChain(ctc).batches();\r\n        uint256 batchIndex = batchesRef.lengthByChainId(_chainId);\r\n        {\r\n            // ctc call\r\n            (bool success, bytes memory result) = ctc.call(msg.data);\r\n            if (success == false) {\r\n                assembly {\r\n                    let ptr := mload(0x40)\r\n                    let size := returndatasize()\r\n                    returndatacopy(ptr, 0, size)\r\n                    revert(ptr, size)\r\n                }\r\n            }\r\n        }\r\n\r\n        // save\r\n        queueBatchElement[_chainId][batchIndex] = BatchElement({\r\n            shouldStartAtElement:  shouldStartAtElement,\r\n            totalElementsToAppend: totalElementsToAppend,\r\n            txBatchSize:           txSize,\r\n            txBatchTime:           batchTime,\r\n            root:                  root,\r\n            timestamp:             block.timestamp\r\n        });\r\n\r\n        emit AppendBatchElement(\r\n            _chainId,\r\n            batchIndex,\r\n            shouldStartAtElement,\r\n            totalElementsToAppend,\r\n            txSize,\r\n            batchTime,\r\n            root\r\n        );\r\n    }\r\n\r\n    function setBatchTxDataForStake(\r\n        uint256 _chainId,\r\n        uint256 _batchIndex,\r\n        uint256 _blockNumber,\r\n        bytes memory _data,\r\n        uint256 _leafIndex,\r\n        uint256 _totalLeaves,\r\n        bytes32[] memory _proof\r\n    )\r\n        override\r\n        public\r\n    {\r\n        require(\r\n            msg.sender == resolve(string(abi.encodePacked(uint2str(_chainId),\"_MVM_Sequencer_Wrapper\"))),\r\n            \"Function can only be called by the Sequencer.\"\r\n        );\r\n        // check stake\r\n        require(queueTxDataRequestStake[_chainId][_blockNumber].timestamp > 0, \"there is no stake for this block number\");\r\n        require(queueTxDataRequestStake[_chainId][_blockNumber].batchIndex == _batchIndex, \"incorrect batch index\");\r\n        require(queueTxDataRequestStake[_chainId][_blockNumber].status == STAKESTATUS.INIT, \"not allowed to submit\");\r\n        // sequencer can submit at any time\r\n        // require(queueTxDataRequestStake[_chainId][_blockNumber].endtime >= block.timestamp, \"can not submit out of sequencer submit protection\");\r\n\r\n        _setBatchTxData(_chainId, _batchIndex, _blockNumber, _data, _leafIndex, _totalLeaves,  _proof,  true);\r\n\r\n        if (queueTxDataRequestStake[_chainId][_blockNumber].status == STAKESTATUS.INIT) {\r\n            require(\r\n                queueTxDataRequestStake[_chainId][_blockNumber].amount <= verifierStakes[queueTxDataRequestStake[_chainId][_blockNumber].sender],\r\n                \"insufficient stake\"\r\n            );\r\n            require(\r\n                queueTxDataRequestStake[_chainId][_blockNumber].amount <= address(this).balance,\r\n                \"insufficient balance\"\r\n            );\r\n            queueTxDataRequestStake[_chainId][_blockNumber].status = STAKESTATUS.SEQ_SET;\r\n            if (queueTxDataRequestStake[_chainId][_blockNumber].amount > 0){\r\n                verifierStakes[queueTxDataRequestStake[_chainId][_blockNumber].sender] -= queueTxDataRequestStake[_chainId][_blockNumber].amount;\r\n                // transfer from contract to sender ETHER and record\r\n                (bool success, ) = payable(msg.sender).call{value: queueTxDataRequestStake[_chainId][_blockNumber].amount}(\"\");\r\n                require(success, \"insufficient balance\");\r\n                queueTxDataRequestStake[_chainId][_blockNumber].amount = 0;\r\n            }\r\n        }\r\n\r\n        emit SetBatchTxData(\r\n            msg.sender,\r\n            _chainId,\r\n            _batchIndex,\r\n            _blockNumber,\r\n            queueTxDataRequestStake[_chainId][_blockNumber].amount,\r\n            true,\r\n            true\r\n        );\r\n    }\r\n\r\n    function setBatchTxDataForVerifier(\r\n        uint256 _chainId,\r\n        uint256 _batchIndex,\r\n        uint256 _blockNumber,\r\n        bytes memory _data\r\n    )\r\n        override\r\n        public\r\n    {\r\n         require(\r\n            msg.sender != resolve(string(abi.encodePacked(uint2str(_chainId),\"_MVM_Sequencer_Wrapper\"))),\r\n            \"Function can not be called by the Sequencer.\"\r\n        );\r\n        // check stake\r\n        require(queueTxDataRequestStake[_chainId][_blockNumber].timestamp > 0, \"there is no stake for this block number\");\r\n        require(queueTxDataRequestStake[_chainId][_blockNumber].batchIndex == _batchIndex, \"incorrect batch index\");\r\n        // require(queueTxDataRequestStake[_chainId][_blockNumber].status == STAKESTATUS.INIT, \"not allowed to submit\");\r\n        // require(queueTxDataRequestStake[_chainId][_blockNumber].sender == msg.sender, \"can not submit with other's stake\");\r\n        require(queueTxDataRequestStake[_chainId][_blockNumber].endtime < block.timestamp, \"can not submit during sequencer submit protection\");\r\n        if (queueTxDataRequestStake[_chainId][_blockNumber].sender != msg.sender) {\r\n            // other verifier can submit in double window times\r\n            require(queueTxDataRequestStake[_chainId][_blockNumber].endtime + stakeSeqSeconds < block.timestamp, \"can not submit during staker submit protection\");\r\n        }\r\n\r\n        _setBatchTxData(_chainId, _batchIndex, _blockNumber, _data, 0, 0, new bytes32[](0), false);\r\n\r\n        if (queueTxDataRequestStake[_chainId][_blockNumber].status == STAKESTATUS.INIT) {\r\n            queueTxDataRequestStake[_chainId][_blockNumber].status = STAKESTATUS.VERIFIER_SET;\r\n\r\n            address claimer = queueTxDataRequestStake[_chainId][_blockNumber].sender;\r\n            if (queueTxDataRequestStake[_chainId][_blockNumber].amount <= verifierStakes[claimer] && queueTxDataRequestStake[_chainId][_blockNumber].amount > 0) {\r\n                require(\r\n                    queueTxDataRequestStake[_chainId][_blockNumber].amount <= address(this).balance,\r\n                    \"insufficient balance\"\r\n                );\r\n                verifierStakes[claimer] -= queueTxDataRequestStake[_chainId][_blockNumber].amount;\r\n                // transfer from contract to sender ETHER and record\r\n                (bool success, ) = payable(claimer).call{value: queueTxDataRequestStake[_chainId][_blockNumber].amount}(\"\");\r\n                require(success, \"insufficient balance\");\r\n                queueTxDataRequestStake[_chainId][_blockNumber].amount = 0;\r\n            }\r\n        }\r\n\r\n        emit SetBatchTxData(\r\n            msg.sender,\r\n            _chainId,\r\n            _batchIndex,\r\n            _blockNumber,\r\n            queueTxDataRequestStake[_chainId][_blockNumber].amount,\r\n            false,\r\n            false\r\n        );\r\n    }\r\n\r\n    function _setBatchTxData(\r\n        uint256 _chainId,\r\n        uint256 _batchIndex,\r\n        uint256 _blockNumber,\r\n        bytes memory _data,\r\n        uint256 _leafIndex,\r\n        uint256 _totalLeaves,\r\n        bytes32[] memory _proof,\r\n        bool _requireVerify\r\n    )\r\n        internal\r\n    {\r\n        require(_data.length > 0, \"empty data\");\r\n        // check queue BatchElement\r\n        require(queueBatchElement[_chainId][_batchIndex].txBatchTime > 0, \"batch element does not exist\");\r\n        require(queueBatchElement[_chainId][_batchIndex].totalElementsToAppend > 0, \"batch total element to append should not be zero\");\r\n       \r\n        // sequencer protect\r\n        if (queueTxData[_chainId][_blockNumber].timestamp > 0) {\r\n            require(queueTxData[_chainId][_blockNumber].verified == false, \"tx data verified\");\r\n            if (queueTxData[_chainId][_blockNumber].sender != msg.sender) {\r\n                require(queueTxData[_chainId][_blockNumber].timestamp + TXDATA_SUBMIT_TIMEOUT > block.timestamp, \"in submitting\");\r\n\r\n                // change sumbitter\r\n                queueTxData[_chainId][_blockNumber].sender = msg.sender;\r\n                queueTxData[_chainId][_blockNumber].blockNumber = _blockNumber;\r\n                queueTxData[_chainId][_blockNumber].batchIndex = _batchIndex;\r\n                queueTxData[_chainId][_blockNumber].timestamp = block.timestamp;\r\n                queueTxData[_chainId][_blockNumber].txData = _data;\r\n                queueTxData[_chainId][_blockNumber].verified = false;\r\n            }\r\n            else {\r\n                queueTxData[_chainId][_blockNumber].txData = _data;\r\n                // verified restore to false\r\n                queueTxData[_chainId][_blockNumber].verified = false;\r\n            }\r\n        }\r\n        else {\r\n            queueTxData[_chainId][_blockNumber] = TxDataSlice({\r\n                sender:         msg.sender,\r\n                blockNumber:    _blockNumber,\r\n                batchIndex:    _batchIndex,\r\n                timestamp:      block.timestamp,\r\n                txData:         _data,\r\n                verified:       false\r\n            });\r\n        }\r\n        if (_requireVerify) {\r\n            bytes32 currLeaf = keccak256(abi.encodePacked(_blockNumber, _data));\r\n            bool verified = Lib_MerkleTree.verify(queueBatchElement[_chainId][_batchIndex].root, currLeaf, _leafIndex, _proof, _totalLeaves);\r\n            require(verified == true, \"tx data verify failed\");\r\n\r\n            // save verified status\r\n            queueTxData[_chainId][_blockNumber].verified = true;\r\n        }\r\n    }\r\n\r\n    function getBatchTxData(\r\n        uint256 _chainId,\r\n        uint256 _batchIndex,\r\n        uint256 _blockNumber\r\n    )\r\n        override\r\n        external\r\n        view\r\n        returns (\r\n            bytes memory txData,\r\n            bool verified\r\n        )\r\n    {\r\n        require(queueTxData[_chainId][_blockNumber].timestamp != 0, \"tx data does not exist\");\r\n        require(queueTxData[_chainId][_blockNumber].batchIndex == _batchIndex, \"incorrect batch index\");\r\n        return (\r\n            queueTxData[_chainId][_blockNumber].txData,\r\n            queueTxData[_chainId][_blockNumber].verified\r\n        );\r\n    }\r\n\r\n    function checkBatchTxHash(\r\n        uint256 _chainId,\r\n        uint256 _batchIndex,\r\n        uint256 _blockNumber,\r\n        bytes memory _data\r\n    )\r\n        override\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 txHash,\r\n            bool verified\r\n        )\r\n    {\r\n        require(queueTxData[_chainId][_blockNumber].timestamp != 0, \"tx data does not exist\");\r\n        require(queueTxData[_chainId][_blockNumber].batchIndex == _batchIndex, \"incorrect batch index\");\r\n        return (\r\n            keccak256(abi.encodePacked(_blockNumber, _data)),\r\n            queueTxData[_chainId][_blockNumber].verified\r\n        );\r\n    }\r\n\r\n    function setBatchTxDataVerified(\r\n        uint256 _chainId,\r\n        uint256 _batchIndex,\r\n        uint256 _blockNumber,\r\n        bool _verified\r\n    )\r\n        override\r\n        public\r\n        onlyManager\r\n    {\r\n        require(queueTxData[_chainId][_blockNumber].timestamp != 0, \"tx data does not exist\");\r\n        require(queueTxData[_chainId][_blockNumber].batchIndex == _batchIndex, \"incorrect batch index\");\r\n        require(queueTxData[_chainId][_blockNumber].verified != _verified, \"verified status not change\");\r\n\r\n        queueTxData[_chainId][_blockNumber].verified = _verified;\r\n    }\r\n\r\n    function verifierStake(\r\n        uint256 _chainId,\r\n        uint256 _batchIndex,\r\n        uint256 _blockNumber\r\n    )\r\n        override\r\n        public\r\n        payable\r\n        onlyWhitelisted\r\n    {\r\n        uint256 _amount = msg.value;\r\n        uint256 stakeCost = getStakeCostByBatch(_chainId, _batchIndex);\r\n        require(stakeBaseCost > 0, \"stake base cost not config yet\");\r\n        require(stakeCost == _amount, \"stake cost incorrect\");\r\n        require(stakeSeqSeconds > 0, \"sequencer submit seconds not config yet\");\r\n        // check queue BatchElement\r\n        require(queueBatchElement[_chainId][_batchIndex].txBatchTime > 0, \"batch element does not exist\");\r\n        // check block number in batch range, block number = index + 1\r\n        require(queueBatchElement[_chainId][_batchIndex].totalElementsToAppend + queueBatchElement[_chainId][_batchIndex].shouldStartAtElement >= _blockNumber && queueBatchElement[_chainId][_batchIndex].shouldStartAtElement < _blockNumber, \"block number is not in this batch\");\r\n        if (queueTxDataRequestStake[_chainId][_blockNumber].timestamp > 0) {\r\n            require(queueTxDataRequestStake[_chainId][_blockNumber].status == STAKESTATUS.PAYBACK, \"there is a stake for this batch index\");\r\n        }\r\n\r\n        //check window\r\n        StateCommitmentChain stateChain = StateCommitmentChain(resolve(\"StateCommitmentChain\"));\r\n        require(queueBatchElement[_chainId][_batchIndex].timestamp + stateChain.FRAUD_PROOF_WINDOW() > block.timestamp, \"the batch is outside of the fraud proof window\");\r\n\r\n        queueTxDataRequestStake[_chainId][_blockNumber] = TxDataRequestStake({\r\n            sender:      msg.sender,\r\n            blockNumber: _blockNumber,\r\n            batchIndex:  _batchIndex,\r\n            timestamp:   block.timestamp,\r\n            endtime:     block.timestamp + stakeSeqSeconds,\r\n            amount:      _amount,\r\n            status:      STAKESTATUS.INIT\r\n        });\r\n        verifierStakes[msg.sender] += _amount;\r\n\r\n        emit VerifierStake(msg.sender, _chainId, _batchIndex, _blockNumber, _amount);\r\n    }\r\n\r\n    function withdrawStake(\r\n        uint256 _chainId,\r\n        uint256 _batchIndex,\r\n        uint256 _blockNumber\r\n    )\r\n        override\r\n        public\r\n    {\r\n        require(queueTxDataRequestStake[_chainId][_blockNumber].timestamp > 0, \"there is no stake for this batch index\");\r\n        require(queueTxDataRequestStake[_chainId][_blockNumber].amount > 0, \"stake amount is zero\");\r\n        require(queueTxDataRequestStake[_chainId][_blockNumber].status == STAKESTATUS.INIT, \"withdrawals are not allowed\");\r\n        require(queueTxDataRequestStake[_chainId][_blockNumber].sender == msg.sender, \"can not withdraw other's stake\");\r\n        require(queueTxDataRequestStake[_chainId][_blockNumber].endtime < block.timestamp, \"can not withdraw during submit protection\");\r\n        require(queueTxDataRequestStake[_chainId][_blockNumber].amount <= verifierStakes[msg.sender], \"insufficient stake\");\r\n\r\n        require(\r\n            queueTxDataRequestStake[_chainId][_blockNumber].amount <= address(this).balance,\r\n            \"insufficient balance\"\r\n        );\r\n        queueTxDataRequestStake[_chainId][_blockNumber].status = STAKESTATUS.PAYBACK;\r\n        verifierStakes[msg.sender] -= queueTxDataRequestStake[_chainId][_blockNumber].amount;\r\n        // transfer from contract to sender ETHER and record\r\n        (bool success, ) = payable(msg.sender).call{value: queueTxDataRequestStake[_chainId][_blockNumber].amount}(\"\");\r\n        require(success, \"insufficient balance\");\r\n        queueTxDataRequestStake[_chainId][_blockNumber].amount = 0;\r\n    }\r\n\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_batchIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"_shouldStartAtElement\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"_totalElementsToAppend\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_txBatchSize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_txBatchTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"AppendBatchElement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_batchIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_verified\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_sequencer\",\"type\":\"bool\"}],\"name\":\"SetBatchTxData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_batchIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"VerifierStake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONFIG_OWNER_KEY\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TXDATA_SUBMIT_TIMEOUT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"appendSequencerBatchByChainId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"checkBatchTxHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"verified\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"getBatchTxData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"verified\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeBaseCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_batchIndex\",\"type\":\"uint256\"}],\"name\":\"getStakeCostByBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeSeqSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeUnitCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTxBatchSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTxDataSliceCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTxDataSliceSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_verifier\",\"type\":\"address\"}],\"name\":\"isWhiteListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"libAddressManager\",\"outputs\":[{\"internalType\":\"contract Lib_AddressManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_leafIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalLeaves\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"setBatchTxDataForStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"setBatchTxDataForVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_verified\",\"type\":\"bool\"}],\"name\":\"setBatchTxDataVerified\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeBaseCost\",\"type\":\"uint256\"}],\"name\":\"setStakeBaseCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"}],\"name\":\"setStakeSeqSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeUnitCost\",\"type\":\"uint256\"}],\"name\":\"setStakeUnitCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_size\",\"type\":\"uint256\"}],\"name\":\"setTxBatchSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"setTxDataSliceCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_size\",\"type\":\"uint256\"}],\"name\":\"setTxDataSliceSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_verifier\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"setWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeBaseCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeSeqSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeUnitCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txBatchSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txDataSliceCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txDataSliceSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"verifierStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MVM_CanonicalTransaction", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b865b1352f49fb7dbbf6ba69c7849a98a4245ea8715f098bfa725a02c5222053"}]}