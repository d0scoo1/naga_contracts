{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/tokens/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*///////////////////////////////////////////////////////////////\\n                                EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        uint256 ownersLength = owners.length; // Saves MLOADs.\\n\\n        require(ownersLength == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < ownersLength; i++) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\ninterface ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"/contracts/ERC1155Contract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@rari-capital/solmate/src/tokens/ERC1155.sol\\\";\\n\\ncontract ERC1155Contract is ERC1155, ReentrancyGuard, Ownable {\\n\\n    struct InitialParameters {\\n        uint256 id;\\n        uint256 launchpassId;\\n        string name;\\n        string symbol;\\n        string uri;\\n        uint24 maxSupply;\\n        uint24 maxPerWallet;\\n        uint24 maxPerTransaction;\\n        uint72 preSalePrice;\\n        uint72 pubSalePrice;\\n        address payable multisigAddress;\\n    }\\n\\n    struct TokenParameters {\\n        bytes32 merkleRoot;\\n        string uri;\\n        uint24 maxSupply;\\n        uint24 maxPerWallet;\\n        uint24 maxPerTransaction;\\n        uint72 preSalePrice;\\n        uint72 pubSalePrice;\\n        bool preSaleIsActive;\\n        bool saleIsActive;\\n        bool supplyLock;\\n        address creator;\\n        uint256 totalSupply;\\n    }\\n\\n    mapping(uint256 => TokenParameters) public tokenParameters;\\n    mapping (uint256 => mapping(address => uint256)) public hasMinted;\\n    address payable public multisigAddress;\\n    address payable public wentMintAddress;\\n    uint8 public wenmintShare;\\n    uint256 public launchpassId;\\n    string public name;\\n    string public symbol;\\n\\n    modifier onlyMultisig() {\\n        require(msg.sender == multisigAddress, \\\"Only multisig wallet can perfrom this action\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address payable _wentMintAddress,\\n        uint8 _wenmintShare,\\n        address _owner,\\n        InitialParameters memory initialParameters\\n      ) ERC1155() {\\n        name = initialParameters.name;\\n        symbol = initialParameters.symbol;\\n        uint256 _id = initialParameters.id;\\n        launchpassId = initialParameters.launchpassId;\\n        tokenParameters[_id].creator = msg.sender;\\n        tokenParameters[_id].uri = initialParameters.uri;\\n        tokenParameters[_id].maxSupply = initialParameters.maxSupply;\\n        tokenParameters[_id].maxPerWallet = initialParameters.maxPerWallet;\\n        tokenParameters[_id].maxPerTransaction = initialParameters.maxPerTransaction;\\n        tokenParameters[_id].preSalePrice = initialParameters.preSalePrice;\\n        tokenParameters[_id].pubSalePrice = initialParameters.pubSalePrice;\\n        tokenParameters[_id].preSaleIsActive = false;\\n        tokenParameters[_id].saleIsActive = false;\\n        tokenParameters[_id].supplyLock = false;\\n        tokenParameters[_id].totalSupply = 0;\\n        multisigAddress = initialParameters.multisigAddress;\\n        wenmintShare = _wenmintShare;\\n        wentMintAddress = _wentMintAddress;\\n        transferOwnership(_owner);\\n    }\\n\\n    function uri(\\n        uint256 _id\\n    ) override public view returns (string memory) {\\n        require(tokenParameters[_id].creator != address(0), \\\"Token does not exists\\\");\\n        return tokenParameters[_id].uri;\\n    }\\n\\n    function totalSupply(\\n        uint256 _id\\n    ) public view returns (uint256) {\\n        return tokenParameters[_id].totalSupply;\\n    }\\n\\n    function maxSupply(\\n        uint256 _id\\n    ) public view returns (uint24) {\\n        return tokenParameters[_id].maxSupply;\\n    }\\n\\n    function preSalePrice(\\n        uint256 _id\\n    ) public view returns (uint72) {\\n        return tokenParameters[_id].preSalePrice;\\n    }\\n\\n    function pubSalePrice(\\n        uint256 _id\\n    ) public view returns (uint72) {\\n        return tokenParameters[_id].pubSalePrice;\\n    }\\n\\n    function maxPerWallet(\\n        uint256 _id\\n    ) public view returns (uint24) {\\n        return tokenParameters[_id].maxPerWallet;\\n    }\\n\\n    function maxPerTransaction(\\n        uint256 _id\\n    ) public view returns (uint24) {\\n        return tokenParameters[_id].maxPerTransaction;\\n    }\\n\\n    function preSaleIsActive(\\n        uint256 _id\\n    ) public view returns (bool) {\\n        return tokenParameters[_id].preSaleIsActive;\\n    }\\n\\n    function supplyLock(\\n        uint256 _id\\n    ) public view returns (bool) {\\n        return tokenParameters[_id].supplyLock;\\n    }\\n\\n    function saleIsActive(\\n        uint256 _id\\n    ) public view returns (bool) {\\n        return tokenParameters[_id].saleIsActive;\\n    }\\n\\n    function setMaxSupply(uint256 _id, uint24 _supply) public onlyOwner {\\n        require(!tokenParameters[_id].supplyLock, \\\"Supply is locked.\\\");\\n       tokenParameters[_id].maxSupply = _supply;\\n    }\\n\\n    function lockSupply(uint256 _id) public onlyOwner {\\n        tokenParameters[_id].supplyLock = true;\\n    }\\n\\n    function setURI(uint256 _id, string memory _uri) public onlyOwner {\\n        tokenParameters[_id].uri = _uri;\\n    }\\n\\n    function setPreSalePrice(uint256 _id, uint72 _price) public onlyOwner {\\n        tokenParameters[_id].preSalePrice = _price;\\n    }\\n\\n    function setPublicSalePrice(uint256 _id, uint72 _price) public onlyOwner {\\n        tokenParameters[_id].pubSalePrice = _price;\\n    }\\n\\n    function setMaxPerWallet(uint256 _id, uint24 _quantity) public onlyOwner {\\n        tokenParameters[_id].maxPerWallet = _quantity;\\n    }\\n\\n    function setMaxPerTransaction(uint256 _id, uint24 _quantity) public onlyOwner {\\n        tokenParameters[_id].maxPerTransaction = _quantity;\\n    }\\n\\n    function setRoot(uint256 _id, bytes32 _root) public onlyOwner {\\n        tokenParameters[_id].merkleRoot = _root;\\n    }\\n\\n    function setPubSaleState(uint256 _id, bool _isActive) public onlyOwner {\\n        tokenParameters[_id].saleIsActive = _isActive;\\n    }\\n\\n    function setPreSaleState(uint256 _id, bool _isActive) public onlyOwner {\\n        require(tokenParameters[_id].merkleRoot != \\\"\\\", \\\"Merkle root is undefined.\\\");\\n        tokenParameters[_id].preSaleIsActive = _isActive;\\n    }\\n\\n    function verify(uint256 _id, bytes32 leaf, bytes32[] memory proof) public view returns (bool) {\\n        bytes32 computedHash = leaf;\\n        for (uint i = 0; i < proof.length; i++) {\\n          bytes32 proofElement = proof[i];\\n          if (computedHash <= proofElement) {\\n            computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n          } else {\\n            computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n          }\\n        }\\n        return computedHash == tokenParameters[_id].merkleRoot;\\n    }\\n\\n    function create(\\n        uint256 _id,\\n        TokenParameters memory initialParameters\\n    ) public onlyOwner {\\n        require(tokenParameters[_id].creator == address(0), \\\"token _id already exists\\\");\\n        tokenParameters[_id] = initialParameters;\\n    }\\n\\n    function mint(\\n        uint256 _id,\\n        bytes memory _data,\\n        uint256 _quantity,\\n        bytes32[] memory proof\\n    ) public payable {\\n        uint _maxSupply = tokenParameters[_id].maxSupply;\\n        uint _maxPerWallet = tokenParameters[_id].maxPerWallet;\\n        uint _maxPerTransaction = tokenParameters[_id].maxPerTransaction;\\n        uint _preSalePrice = tokenParameters[_id].preSalePrice;\\n        uint _pubSalePrice = tokenParameters[_id].pubSalePrice;\\n        bool _saleIsActive = tokenParameters[_id].saleIsActive;\\n        bool _preSaleIsActive = tokenParameters[_id].preSaleIsActive;\\n        uint256 _currentSupply = tokenParameters[_id].totalSupply;\\n\\n        require(_saleIsActive, \\\"Sale is not active.\\\");\\n        require(_currentSupply <= _maxSupply, \\\"Sold out.\\\");\\n        require(_currentSupply + _quantity <= _maxSupply, \\\"Requested quantity would exceed total supply.\\\");\\n        if(_preSaleIsActive) {\\n            require(_preSalePrice * _quantity <= msg.value, \\\"ETH sent is incorrect.\\\");\\n            require(_quantity <= _maxPerWallet, \\\"Exceeds wallet presale limit.\\\");\\n            uint mintedAmount = hasMinted[_id][msg.sender] + _quantity;\\n            require(mintedAmount <= _maxPerWallet, \\\"Exceeds per wallet presale limit.\\\");\\n            hasMinted[_id][msg.sender] = mintedAmount;\\n            bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\\n            require(verify(_id, leaf, proof), \\\"You are not whitelisted.\\\");\\n        } else {\\n            require(_pubSalePrice * _quantity <= msg.value, \\\"ETH sent is incorrect.\\\");\\n            require(_quantity <= _maxPerTransaction, \\\"Exceeds per transaction limit for public sale.\\\");\\n        }\\n        _mint(msg.sender, _id, _quantity, _data);\\n        tokenParameters[_id].totalSupply = _currentSupply + _quantity;\\n    }\\n\\n    function airdrop(address[] memory _addrs, uint256[] memory _quantities, uint256 _id) public onlyMultisig {\\n        for (uint256 i = 0; i < _addrs.length; i++) {\\n            _mint(_addrs[i], _id, _quantities[i], \\\"\\\");\\n            tokenParameters[_id].totalSupply = tokenParameters[_id].totalSupply + _quantities[i];\\n        }\\n    }\\n\\n    function setMultiSig(address payable _address) public onlyMultisig {\\n        multisigAddress = _address;\\n    }\\n\\n    function reserve(uint256 _id, bytes memory _data, address _address, uint256 _quantity) public onlyMultisig {\\n        _mint(_address, _id, _quantity, _data);\\n        tokenParameters[_id].totalSupply = tokenParameters[_id].totalSupply + _quantity;\\n    }\\n\\n    function withdraw() external nonReentrant onlyMultisig {\\n        uint balance = address(this).balance;\\n        uint wenMintAmount = balance * wenmintShare / 100;\\n        (bool sentWenMint, ) = wentMintAddress.call{ value: wenMintAmount }(\\\"\\\");\\n        require(sentWenMint, \\\"Failed to send ETH to WenMint.\\\");\\n        uint multiSigAmount = balance - wenMintAmount;\\n        (bool sentMultiSig, ) = multisigAddress.call{ value: multiSigAmount }(\\\"\\\");\\n        require(sentMultiSig, \\\"Failed to send ETH to Gnosis Safe.\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_wentMintAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_wenmintShare\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"launchpassId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"uint24\",\"name\":\"maxSupply\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"maxPerWallet\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"maxPerTransaction\",\"type\":\"uint24\"},{\"internalType\":\"uint72\",\"name\":\"preSalePrice\",\"type\":\"uint72\"},{\"internalType\":\"uint72\",\"name\":\"pubSalePrice\",\"type\":\"uint72\"},{\"internalType\":\"address payable\",\"name\":\"multisigAddress\",\"type\":\"address\"}],\"internalType\":\"struct ERC1155Contract.InitialParameters\",\"name\":\"initialParameters\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_quantities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"uint24\",\"name\":\"maxSupply\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"maxPerWallet\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"maxPerTransaction\",\"type\":\"uint24\"},{\"internalType\":\"uint72\",\"name\":\"preSalePrice\",\"type\":\"uint72\"},{\"internalType\":\"uint72\",\"name\":\"pubSalePrice\",\"type\":\"uint72\"},{\"internalType\":\"bool\",\"name\":\"preSaleIsActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"saleIsActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"supplyLock\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC1155Contract.TokenParameters\",\"name\":\"initialParameters\",\"type\":\"tuple\"}],\"name\":\"create\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchpassId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"lockSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"maxPerTransaction\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"maxPerWallet\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multisigAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"preSaleIsActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"preSalePrice\",\"outputs\":[{\"internalType\":\"uint72\",\"name\":\"\",\"type\":\"uint72\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"pubSalePrice\",\"outputs\":[{\"internalType\":\"uint72\",\"name\":\"\",\"type\":\"uint72\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"reserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"saleIsActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"_quantity\",\"type\":\"uint24\"}],\"name\":\"setMaxPerTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"_quantity\",\"type\":\"uint24\"}],\"name\":\"setMaxPerWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"_supply\",\"type\":\"uint24\"}],\"name\":\"setMaxSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setMultiSig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint72\",\"name\":\"_price\",\"type\":\"uint72\"}],\"name\":\"setPreSalePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"setPreSaleState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"setPubSaleState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint72\",\"name\":\"_price\",\"type\":\"uint72\"}],\"name\":\"setPublicSalePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"setRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"supplyLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenParameters\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"uint24\",\"name\":\"maxSupply\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"maxPerWallet\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"maxPerTransaction\",\"type\":\"uint24\"},{\"internalType\":\"uint72\",\"name\":\"preSalePrice\",\"type\":\"uint72\"},{\"internalType\":\"uint72\",\"name\":\"pubSalePrice\",\"type\":\"uint72\"},{\"internalType\":\"bool\",\"name\":\"preSaleIsActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"saleIsActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"supplyLock\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wenmintShare\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wentMintAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC1155Contract", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "20", "ConstructorArguments": "00000000000000000000000098ee85e7cc2665261d9fd3ea53f2db4491c547e3000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000ffe5cbcddf2bd1b4dc3c00455d4cdccf20f7758700000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000001f4000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000098ee85e7cc2665261d9fd3ea53f2db4491c547e3000000000000000000000000000000000000000000000000000000000000000b57656e426f6f7463616d70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000757454e424f4f5400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002868747470733a2f2f6170692d6d696e742e77656e626f6f7463616d702e636f6d2f746f6b656e2f31000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}