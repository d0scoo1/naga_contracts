{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ninterface IERC721Custom {\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    \r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC20Custom {\r\n    function mint(address to, uint256 amount) external;\r\n    function hasRole(bytes32 role, address account) external view returns (bool);\r\n}\r\n\r\ninterface IVesting {\r\n    function addLock(address to, uint256 amount) external;\r\n}\r\n\r\n/**\r\n * @dev {ERC20} token, including:\r\n *\r\n *  - ability for holders to burn (destroy) their tokens\r\n *  - a minter role that allows for token minting (creation)\r\n *  - a pauser role that allows to stop all token transfers\r\n *\r\n * This contract uses {AccessControl} to lock permissioned functions using the\r\n * different roles - head to its documentation for details.\r\n *\r\n * The account that deploys the contract will be granted the minter and pauser\r\n * roles, as well as the default admin role, which will let it grant both minter\r\n * and pauser roles to other accounts.\r\n *\r\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\r\n */\r\ncontract NFTStaking is Context, Ownable, IERC721Receiver, ERC165, ReentrancyGuard {\r\n    IERC721Custom public nftForStaking;\r\n    IERC20Custom public rewardToken;\r\n    IVesting public vestingContract;\r\n    \r\n    uint256 public firstStakingPoolRewardPercent  = 25;\r\n    uint256 public secondStakingPoolRewardPercent = 35;\r\n    uint256 public thirdStakingPoolRewardPercent  = 40;\r\n\r\n    uint256 public defaultStakingPool = 3;\r\n\r\n    uint256[25] public allPeriods;    \r\n    uint256[24] public tokenMultipliers = [10,10,13,13,15,15,15,15,20,20,20,20,25,25,25,25,30,30,30,30,40,40,40,40];\r\n    uint256[24] public periodRewards = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\r\n    uint256[24] public periodBonuses = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\r\n    uint256[24] public periodEstimatedRewards = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\r\n    uint256[24][3] public periodPoolsRewards;\r\n    uint256[24][3] public periodPoolsBonuses;\r\n    uint256[24][3] public periodPoolsEstimatedRewards;\r\n\r\n    mapping(address => uint256[]) public stakedNfts;\r\n    address[] public firstDayStakersAddresses;\r\n    \r\n    bool private stakingAllowance = false;\r\n    uint256[3] private _isPoolEnabled = [1,1,1];\r\n    mapping(address => bool) private _isFirstDayStaker;\r\n    mapping(uint256 => address) private _nftsOwners;\r\n    mapping(uint256 => uint256[11]) private _stakes;\r\n    mapping(address => uint256[11][]) private _stakeSnapshots;\r\n    uint256[24][3] private _allSharesPowerPerStakingPool;\r\n    uint256 private _lastPeriodEstimatedRewards;\r\n\r\n    uint256 quarter = 90;\r\n    uint256 recalculation = 1;\r\n    uint256 quantity = 1 days;\r\n  \r\n    \r\n    // constructor\r\n    constructor(address nft, address token) {\r\n        _setNft(nft);\r\n        _setToken(token);\r\n        periodPoolsRewards[0] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\r\n        periodPoolsRewards[1] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\r\n        periodPoolsRewards[2] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\r\n        periodPoolsBonuses[0] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\r\n        periodPoolsBonuses[1] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\r\n        periodPoolsBonuses[2] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\r\n        periodPoolsEstimatedRewards[0] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\r\n        periodPoolsEstimatedRewards[1] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\r\n        periodPoolsEstimatedRewards[2] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\r\n        quarter = quarter * quantity;\r\n        recalculation = recalculation * quantity;\r\n    }\r\n\r\n\r\n    // external functions\r\n    function onERC721Received(\r\n        address,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata\r\n    ) external override returns (bytes4) {\r\n        require (_msgSender() == address(nftForStaking), \"NFTStaking: transfer not allowed\");\r\n        require(isStakingAllowed(), \"NFTStaking: staking is not allowed\");\r\n        \r\n        _addStake(from, tokenId, defaultStakingPool);\r\n\r\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n    }\r\n\r\n\r\n    // ownable public functions\r\n    function setNft(address nft) public onlyOwner {\r\n        require(nftForStaking.balanceOf(address(this)) == uint256(0), \"NFTStaking: not empty balance\");\r\n        _setNft(nft);\r\n    }\r\n\r\n    function setToken(address erc20) public onlyOwner {\r\n        IERC20Custom token = IERC20Custom(erc20);\r\n        require(token.hasRole(keccak256(\"MINTER_ROLE\"), address(this)), \"NFTStaking: must have minter role to mint\");\r\n        _setToken(erc20);\r\n    }   \r\n\r\n    function setVesting(address vesting) public onlyOwner {\r\n        _setVesting(vesting);\r\n    }\r\n\r\n    function allowStaking(address vesting) public onlyOwner {\r\n        require(!stakingAllowance, \"NFTStaking: staking is already allowed\");\r\n        require(rewardToken.hasRole(keccak256(\"MINTER_ROLE\"), address(this)), \"NFTStaking: must have minter role to mint\");\r\n        _setVesting(vesting);\r\n        uint256 timestamp = block.timestamp;\r\n        allPeriods[0] = timestamp;\r\n        \r\n        for (uint256 i = 1; i < 25; i++) {\r\n            timestamp = timestamp + quarter;\r\n            allPeriods[i] = timestamp;            \r\n        }       \r\n        stakingAllowance = true;\r\n    }   \r\n\r\n    function setStakingPoolsRewardPercentages(uint256 first, uint256 second, uint256 third) public onlyOwner {\r\n        require((first + second + third) == 100, \"NFTStaking: wrong percentages\");\r\n        firstStakingPoolRewardPercent = first;\r\n        secondStakingPoolRewardPercent = second;\r\n        thirdStakingPoolRewardPercent = third;\r\n        \r\n        _isPoolEnabled[0] = first > 0 ? 1 : 0;\r\n        _isPoolEnabled[1] = second > 0 ? 1 : 0;\r\n        _isPoolEnabled[2] = third > 0 ? 1 : 0;\r\n        \r\n        if (_isPoolEnabled[defaultStakingPool - 1] == 0) {\r\n            for (uint256 pool = 0; pool < 3; pool++) {\r\n                if (_isPoolEnabled[pool] == 1) {\r\n                    defaultStakingPool = pool + 1;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function setDefaultStakingPool(uint256 pool) public onlyOwner {\r\n        require(pool != 0 && pool < 4, \"NFTStaking: wrong pool\");\r\n        require(_isPoolEnabled[pool - 1] != 0, \"NFTStaking: pool is disabled\");\r\n        defaultStakingPool = pool;\r\n    }\r\n\r\n    function setRewardForLastPeriod(uint256 amount) public onlyOwner {\r\n        require(stakingAllowance, \"NFTStaking: staking is not allowed\");\r\n        require(amount > 0, \"NFTStaking: empty reward\");\r\n        uint256 currentPeriod = (block.timestamp - allPeriods[0]) / quarter;\r\n        if (currentPeriod > 0 && currentPeriod < 25) {\r\n            if (periodRewards[currentPeriod - 1] == 0) {\r\n                periodRewards[currentPeriod - 1] = amount;\r\n                periodPoolsRewards[0][currentPeriod - 1] = amount * firstStakingPoolRewardPercent / 100;\r\n                periodPoolsRewards[1][currentPeriod - 1] = amount * secondStakingPoolRewardPercent / 100;\r\n                periodPoolsRewards[2][currentPeriod - 1] = amount * thirdStakingPoolRewardPercent / 100;\r\n            }\r\n        }\r\n        \r\n        if (currentPeriod > 24) {\r\n            stakingAllowance = false;\r\n        }\r\n    }\r\n    \r\n    function setBonusForLastPeriod(uint256 amount) public onlyOwner {\r\n        require(stakingAllowance, \"NFTStaking: staking is not allowed\");\r\n        require(amount > 0, \"NFTStaking: empty bonus\");\r\n        uint256 currentPeriod = (block.timestamp - allPeriods[0]) / quarter;\r\n        if (currentPeriod > 0 && currentPeriod < 25) {\r\n            if (periodRewards[currentPeriod - 1] != 0 && periodBonuses[currentPeriod - 1] == 0) {\r\n                periodBonuses[currentPeriod - 1] = amount;\r\n                periodPoolsBonuses[0][currentPeriod - 1] = amount * firstStakingPoolRewardPercent / 100;\r\n                periodPoolsBonuses[1][currentPeriod - 1] = amount * secondStakingPoolRewardPercent / 100;\r\n                periodPoolsBonuses[2][currentPeriod - 1] = amount * thirdStakingPoolRewardPercent / 100;\r\n            }\r\n        }\r\n        \r\n        if (currentPeriod > 24) {\r\n            stakingAllowance = false;\r\n        }\r\n    }\r\n\r\n    function setEstimatedReward(uint256 amount) public onlyOwner {\r\n        require(stakingAllowance, \"NFTStaking: staking is not allowed\");\r\n        require(amount > 0, \"NFTStaking: empty reward\");\r\n        uint256 currentPeriod = (block.timestamp - allPeriods[0]) / quarter;\r\n        if (currentPeriod < 24) {\r\n            periodEstimatedRewards[currentPeriod] = amount;\r\n            periodPoolsEstimatedRewards[0][currentPeriod] = amount * firstStakingPoolRewardPercent / 100;\r\n            periodPoolsEstimatedRewards[1][currentPeriod] = amount * secondStakingPoolRewardPercent / 100;\r\n            periodPoolsEstimatedRewards[2][currentPeriod] = amount * thirdStakingPoolRewardPercent / 100;\r\n            _lastPeriodEstimatedRewards = currentPeriod;\r\n        }\r\n\r\n        if (currentPeriod > 24) {\r\n            stakingAllowance = false;\r\n        }\r\n    }\r\n\r\n    // public functions\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721Receiver).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }    \r\n\r\n    function isStakingAllowed() public view returns (bool) {\r\n        if (stakingAllowance && ((block.timestamp - allPeriods[0]) / quarter) < 23) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getOwnerByTokenId(uint256 tokenId) public view returns (address) {\r\n        return _nftsOwners[tokenId];\r\n    }\r\n    \r\n    function getCurrentQuarterFromStart() public view returns (uint256) {\r\n        uint256 count = ((block.timestamp - allPeriods[0]) / quarter) + 1;\r\n        return count;\r\n    }\r\n    \r\n    function getCurrentDayOfQuarter() public view returns (uint256) {\r\n        uint256 currentQuarter = (block.timestamp - allPeriods[0]) / quarter;\r\n        uint256 day = ((block.timestamp - allPeriods[currentQuarter]) / recalculation) + 1;\r\n        return day;\r\n    }\r\n    \r\n    function getCurrentMultiplierForToken(uint256 tokenId) public view returns (uint256) {\r\n        uint256 startTime = _stakes[tokenId][2];\r\n        uint256 duration = (block.timestamp - startTime) / quarter;\r\n        uint256 multiplier = tokenMultipliers[duration];\r\n        return multiplier;\r\n    }\r\n\r\n    function getStakingPoolsOfToken(uint256 tokenId) public view returns (uint256 pools) {\r\n        uint256 pool1 = _stakes[tokenId][8];\r\n        uint256 pool2 = _stakes[tokenId][9];\r\n        uint256 pool3 = _stakes[tokenId][10];\r\n        if (pool1 == 1 && pool2 == 0 && pool3 == 0) {\r\n            return 1;\r\n        }\r\n        if (pool1 == 0 && pool2 == 1 && pool3 == 0) {\r\n            return 2;\r\n        }\r\n        if (pool1 == 0 && pool2 == 0 && pool3 == 1) {\r\n            return 3;\r\n        }\r\n        if (pool1 == 1 && pool2 == 1 && pool3 == 0) {\r\n            return 12;\r\n        }\r\n        if (pool1 == 1 && pool2 == 0 && pool3 == 1) {\r\n            return 13;\r\n        }\r\n        if (pool1 == 0 && pool2 == 1 && pool3 == 1) {\r\n            return 23;\r\n        }\r\n        if (pool1 == 1 && pool2 == 1 && pool3 == 1) {\r\n            return 123;\r\n        }                \r\n    }\r\n\r\n    function getNftsCount() public view returns (uint256) {\r\n        uint256 len = stakedNfts[_msgSender()].length;\r\n        return len;\r\n    }\r\n    \r\n     function getNfts() public view returns (uint256[] memory) {\r\n        uint256 len = stakedNfts[_msgSender()].length;\r\n        uint256[] memory nfts = new uint256[](len);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            nfts[i] = stakedNfts[_msgSender()][i];\r\n        }\r\n        return nfts;\r\n    }\r\n\r\n    function getNftsByAddress(address user) public view returns (uint256[] memory) {\r\n        uint256 len = stakedNfts[user].length;\r\n        uint256[] memory nfts = new uint256[](len);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            nfts[i] = stakedNfts[user][i];\r\n        }\r\n        return nfts;\r\n    }\r\n\r\n    function getCurrentMultipliers() public view returns (uint256[] memory) {\r\n        uint256 len = stakedNfts[_msgSender()].length;\r\n        uint256[] memory multipliers = new uint256[](len);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            uint256 tokenId = stakedNfts[_msgSender()][i];\r\n            uint256 startTime = _stakes[tokenId][2];\r\n            uint256 duration = (block.timestamp - startTime) / quarter;\r\n            uint256 multiplier = tokenMultipliers[duration];\r\n            multipliers[i] = multiplier;\r\n        }\r\n        return multipliers;               \r\n    }\r\n\r\n    function claimableRewards(address user) public view returns (uint256) {\r\n        return _calcAccruedRewards(user);\r\n    }\r\n\r\n    function estimatedRewards(address user) public view returns (uint256) {\r\n        return _calcEstimatedRewards(user);\r\n    }\r\n\r\n    function firstDayStakersCount() public view returns (uint256) {\r\n        return firstDayStakersAddresses.length;\r\n    }\r\n    \r\n    function stake(uint256 tokenId, uint256 pool) public nonReentrant {\r\n        require(isStakingAllowed(), \"NFTStaking: staking is not allowed\");     \r\n        require((nftForStaking.getApproved(tokenId) == address(this)) || (nftForStaking.isApprovedForAll(_msgSender(),address(this))), \"NFTStaking: transfer not allowed\");\r\n        require(pool != 0 && pool < 4, \"NFTStaking: wrong pool\");\r\n        require(_isPoolEnabled[pool - 1] != 0, \"NFTStaking: pool is disabled\");\r\n        nftForStaking.transferFrom(_msgSender(), address(this), tokenId);\r\n        _addStake(_msgSender(), tokenId, pool);\r\n    }\r\n\r\n    function chooseAdditionalStakingPool(uint256 tokenId, uint256 pool) public nonReentrant {\r\n        require(isStakingAllowed(), \"NFTStaking: staking is not allowed\");\r\n        require(tokenId > 250 && tokenId < 1501, \"NFTStaking: not allowing additional staking\");\r\n        require(_msgSender() == _nftsOwners[tokenId], \"NFTStaking: not a token owner\");\r\n        require(pool != 0 && pool < 4, \"NFTStaking: wrong pool\");\r\n        require(_isPoolEnabled[pool - 1] != 0, \"NFTStaking: pool is disabled\");\r\n        require((_stakes[tokenId][8] + _stakes[tokenId][9] + _stakes[tokenId][10]) == 1, \"NFTStaking: additional pool already chosen\");\r\n        if (pool == 1) {\r\n            require(_stakes[tokenId][8] == 0, \"NFTStaking: pool already chosen\");\r\n            _stakes[tokenId][8] = 1;\r\n        }\r\n        else if (pool == 2) {\r\n            require(_stakes[tokenId][9] == 0, \"NFTStaking: pool already chosen\");\r\n            _stakes[tokenId][9] = 1;\r\n        }        \r\n        else if (pool == 3) {\r\n            require(_stakes[tokenId][10] == 0, \"NFTStaking: pool already chosen\");\r\n            _stakes[tokenId][10] = 1;\r\n        }          \r\n\r\n        uint256 tokenPower = _stakes[tokenId][5];        \r\n        uint256 currentPeriod = _stakes[tokenId][3];\r\n        uint256 startDay = _stakes[tokenId][4];      \r\n        _addShare(tokenPower, currentPeriod, startDay, pool);\r\n    }\r\n\r\n    function unstake(uint256 tokenId) public {\r\n        require(_msgSender() == _nftsOwners[tokenId], \"NFTStaking: not a token owner\");\r\n        uint256 accruedInterest = _calcAccruedRewards(_msgSender());\r\n        if (accruedInterest > 0) {\r\n            claim();\r\n        }\r\n        _unstake(_msgSender(), tokenId);\r\n        uint256 len = stakedNfts[_msgSender()].length;       \r\n        for (uint256 i = 0; i < len; i++) {\r\n            if (stakedNfts[_msgSender()][i] == tokenId) {\r\n                stakedNfts[_msgSender()][i] = stakedNfts[_msgSender()][len - 1];\r\n            }\r\n        }     \r\n        stakedNfts[_msgSender()].pop();      \r\n    }\r\n\r\n    function unstakeAll() public {\r\n        uint256 len = stakedNfts[_msgSender()].length;\r\n        uint256 accruedInterest = _calcAccruedRewards(_msgSender());\r\n        if (accruedInterest > 0) {\r\n            claim();\r\n        }\r\n        for (uint256 i = 0; i < len; i++) {\r\n            uint256 tokenId = stakedNfts[_msgSender()][i];\r\n            _unstake(_msgSender(), tokenId);\r\n        }\r\n        for (uint256 i = 0; i < len; i++) {\r\n            stakedNfts[_msgSender()].pop();\r\n        }\r\n    }\r\n\r\n    function claim() public nonReentrant {\r\n        uint256 accruedInterest = _calcAccruedRewards(_msgSender());      \r\n        require(accruedInterest > 0, \"NFTStaking: nothing to claim\");\r\n        uint256 currentPeriod = (block.timestamp - allPeriods[0]) / quarter;\r\n        uint256 i;\r\n        \r\n        if (currentPeriod > 23) {\r\n            currentPeriod = 24;\r\n        }\r\n\r\n        for (i = 0; i < stakedNfts[_msgSender()].length; i++) {\r\n            uint256 tokenId = stakedNfts[_msgSender()][i];        \r\n            \r\n            if (periodRewards[currentPeriod - 1] > 0 ) {\r\n                _stakes[tokenId][0] = currentPeriod + 1;\r\n            }\r\n            else {\r\n                _stakes[tokenId][0] = currentPeriod;\r\n            }\r\n\r\n            if (periodBonuses[currentPeriod - 1] > 0 ) {\r\n                _stakes[tokenId][1] = currentPeriod + 1;\r\n            }\r\n            else {\r\n                _stakes[tokenId][1] = currentPeriod;\r\n            }\r\n        }\r\n    \r\n        uint256 count = 0;\r\n        for (i = 0; i < _stakeSnapshots[_msgSender()].length; i++) {\r\n            uint256[11] memory snapshot = _stakeSnapshots[_msgSender()][i];\r\n            uint256 check = 0;     \r\n          \r\n            if (periodRewards[snapshot[6]] > 0) {\r\n                _stakeSnapshots[_msgSender()][i][0] = 99;\r\n                check++;\r\n            }\r\n            else if (periodRewards[snapshot[6]] == 0 && periodRewards[snapshot[6] - 1] > 0) {\r\n                _stakeSnapshots[_msgSender()][i][0] = snapshot[6] + 1;\r\n            }\r\n            else if (periodRewards[snapshot[6]] == 0 && periodRewards[snapshot[6] - 1] == 0) {\r\n                _stakeSnapshots[_msgSender()][i][0] = snapshot[6];\r\n            }\r\n\r\n            if (periodBonuses[snapshot[6]] > 0 || periodRewards[snapshot[6] + 1] > 0) {\r\n                _stakeSnapshots[_msgSender()][i][1] = 99;\r\n                check++;\r\n            }\r\n            else if (periodBonuses[snapshot[6] - 1] > 0 || periodRewards[snapshot[6]] > 0) {\r\n                _stakeSnapshots[_msgSender()][i][1] = snapshot[6] + 1;\r\n            }            \r\n            else if (periodBonuses[snapshot[6] - 1] == 0 && periodRewards[snapshot[6]] == 0) {\r\n                _stakeSnapshots[_msgSender()][i][1] = snapshot[6];\r\n            }\r\n         \r\n            if (check == 2) {\r\n                count++;\r\n            }\r\n        }\r\n        \r\n        while (count != 0) {\r\n            _stakeSnapshots[_msgSender()].pop();\r\n            count--;\r\n        }\r\n        \r\n        uint256 amountToWallet = (accruedInterest / 100) * 33;\r\n        uint256 amountToVesting = (accruedInterest / 100) * 67;\r\n        rewardToken.mint(_msgSender(), amountToWallet);\r\n        rewardToken.mint(address(vestingContract), amountToVesting);\r\n        vestingContract.addLock(_msgSender(), amountToVesting);        \r\n    }\r\n\r\n    // private functions \r\n    function _setNft(address erc721) private {\r\n        require(erc721 != address(0), \"not valid address\");\r\n        IERC721Custom nft = IERC721Custom(erc721);       \r\n        require(nft.supportsInterface(bytes4(0x80ac58cd)), \"not ERC721\");       \r\n        nftForStaking = nft;\r\n    }\r\n    \r\n    function _setToken(address erc20) private {\r\n        require(erc20 != address(0), \"NFTStaking: not valid address\");\r\n        IERC20Custom token = IERC20Custom(erc20);\r\n        rewardToken = token;\r\n    }\r\n\r\n    function _setVesting(address vesting_) private {\r\n        require(vesting_ != address(0), \"NFTStaking: not valid address\");\r\n        IVesting vesting = IVesting(vesting_);\r\n        vestingContract = vesting;\r\n    }\r\n\r\n    function _addStake(address staker, uint256 tokenId, uint256 pool) private {\r\n        stakedNfts[staker].push(tokenId);\r\n        _nftsOwners[tokenId] = staker;\r\n\r\n        uint256 currentPeriod = (block.timestamp - allPeriods[0]) / quarter;\r\n        uint256 nextPeriod = currentPeriod + 1;\r\n        uint256 startDay = ((block.timestamp - allPeriods[currentPeriod]) / recalculation) + 1;\r\n        uint256 tokenPower = _getTokenPower(tokenId);\r\n        \r\n        if (tokenId < 251) {\r\n            _stakes[tokenId] = [nextPeriod,nextPeriod,block.timestamp,currentPeriod,startDay,tokenPower,0,0,1,1,1];\r\n            _addShare(tokenPower, currentPeriod, startDay, 1);\r\n            _addShare(tokenPower, currentPeriod, startDay, 2);\r\n            _addShare(tokenPower, currentPeriod, startDay, 3);\r\n        }\r\n        else {\r\n            if (pool == 1) {\r\n                _stakes[tokenId] = [nextPeriod,nextPeriod,block.timestamp,currentPeriod,startDay,tokenPower,0,0,1,0,0];\r\n                _addShare(tokenPower, currentPeriod, startDay, 1);\r\n            }\r\n            else if (pool == 2) {\r\n                _stakes[tokenId] = [nextPeriod,nextPeriod,block.timestamp,currentPeriod,startDay,tokenPower,0,0,0,1,0];\r\n                _addShare(tokenPower, currentPeriod, startDay, 2);\r\n            }\r\n            else if (pool == 3) {\r\n                _stakes[tokenId] = [nextPeriod,nextPeriod,block.timestamp,currentPeriod,startDay,tokenPower,0,0,0,0,1];\r\n                _addShare(tokenPower, currentPeriod, startDay, 3);\r\n            }        \r\n        }\r\n        \r\n        if (currentPeriod == 0 && startDay == 1) {\r\n            if (!_isFirstDayStaker[staker]) {\r\n                _isFirstDayStaker[staker] = true;\r\n                firstDayStakersAddresses.push(staker);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _addShare(uint256 tokenPower, uint256 currentPeriod, uint256 startDay, uint256 pool) private {\r\n        for (uint256 i = currentPeriod; i < 24; i++) {\r\n            if (i == currentPeriod) {\r\n                _allSharesPowerPerStakingPool[pool - 1][i] = _allSharesPowerPerStakingPool[pool - 1][i] + (tokenPower * tokenMultipliers[0] * (quarter + recalculation - startDay));\r\n            }\r\n            else {\r\n                _allSharesPowerPerStakingPool[pool - 1][i] = _allSharesPowerPerStakingPool[pool - 1][i] + (tokenPower * ((tokenMultipliers[i - currentPeriod - 1] * startDay) + (tokenMultipliers[i - currentPeriod] * (quarter + recalculation - startDay))));\r\n            }\r\n        }\r\n    }\r\n\r\n    function _unstake(address staker, uint256 tokenId) private {    \r\n        _removeStake(staker, tokenId);        \r\n        nftForStaking.transferFrom(address(this), staker, tokenId);       \r\n    }\r\n\r\n    function _removeStake(address staker, uint256 tokenId) private {       \r\n        delete _nftsOwners[tokenId];\r\n        uint256 currentPeriod = (block.timestamp - allPeriods[0]) / quarter;\r\n        \r\n        if (currentPeriod < 24) {        \r\n            uint256 duration = (block.timestamp - _stakes[tokenId][2]) / quarter;\r\n            uint256 startPeriod = _stakes[tokenId][3];\r\n            uint256 startDay = _stakes[tokenId][4];\r\n            uint256 tokenPower = _stakes[tokenId][5];\r\n            uint256 endDay = ((block.timestamp - allPeriods[currentPeriod]) / recalculation) + 1;\r\n            uint256 i;\r\n\r\n            if (duration >= 1) {      \r\n                _stakes[tokenId][6] = currentPeriod;\r\n                _stakes[tokenId][7] = endDay;\r\n                _createSnapshot(staker, tokenId);\r\n            }\r\n        \r\n            for (uint256 p = 8; p < 11; p++) {\r\n                uint256 pool = 0;\r\n                if (p == 8 && _stakes[tokenId][8] == 1) {\r\n                    pool = 1;\r\n                }\r\n                else if (p == 9 && _stakes[tokenId][9] == 1) {\r\n                    pool = 2;\r\n                }\r\n                else if (p == 10 && _stakes[tokenId][10] == 1) {\r\n                    pool = 3;\r\n                }\r\n\r\n                if (pool > 0) {\r\n                    if (duration >= 1) {      \r\n                        for (i = currentPeriod; i < 24; i++) {\r\n                            _allSharesPowerPerStakingPool[pool - 1][i] = _allSharesPowerPerStakingPool[pool - 1][i] - (tokenPower * ((tokenMultipliers[i - startPeriod - 1] * startDay) + (tokenMultipliers[i - startPeriod] * (quarter + recalculation - startDay))));\r\n                            if (i == currentPeriod) {\r\n                                if (endDay < startDay) {\r\n                                    _allSharesPowerPerStakingPool[pool - 1][i] = _allSharesPowerPerStakingPool[pool - 1][i] + (tokenPower * tokenMultipliers[i - startPeriod - 1] * endDay);\r\n                                } \r\n                                else {\r\n                                    _allSharesPowerPerStakingPool[pool - 1][i] = _allSharesPowerPerStakingPool[pool - 1][i] + (tokenPower * ((tokenMultipliers[i - startPeriod - 1] * startDay) + (tokenMultipliers[i - startPeriod] * (endDay - startDay))));\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {        \r\n                        for (i = startPeriod; i < 24; i++) {\r\n                            if (i == startPeriod) {\r\n                                _allSharesPowerPerStakingPool[pool - 1][i] = _allSharesPowerPerStakingPool[pool - 1][i] - (tokenPower * tokenMultipliers[0] * (quarter + recalculation - startDay)); \r\n                            }\r\n                            else {\r\n                                _allSharesPowerPerStakingPool[pool - 1][i] = _allSharesPowerPerStakingPool[pool - 1][i] - (tokenPower * ((tokenMultipliers[i - startPeriod - 1] * startDay) + (tokenMultipliers[i - startPeriod] * (quarter + recalculation - startDay))));\r\n                            }\r\n                        }   \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        delete _stakes[tokenId];\r\n    }\r\n\r\n    function _createSnapshot(address staker, uint256 tokenId) private {\r\n        uint256[11] memory snapshot = _stakes[tokenId];    \r\n        uint256 len = _stakeSnapshots[staker].length + 1;\r\n        uint256[11][] memory newStakeSnapshots = new uint256[11][](len);\r\n        newStakeSnapshots[0] = snapshot;\r\n\r\n        for (uint256 i = 0; i < _stakeSnapshots[staker].length; i++) {\r\n            newStakeSnapshots[i + 1] = _stakeSnapshots[staker][i];\r\n        }\r\n        _stakeSnapshots[staker] = newStakeSnapshots;\r\n    }\r\n\r\n    function _calcAccruedRewards(address staker) private view returns (uint256) {\r\n        uint256 currentPeriod = (block.timestamp - allPeriods[0]) / quarter;        \r\n        if (currentPeriod > 24) {\r\n            currentPeriod = 24;\r\n        }\r\n        uint256 sum = 0;\r\n        uint256 i;        \r\n        for (i = 0; i < stakedNfts[staker].length; i++) {\r\n            uint256 tokenId = stakedNfts[staker][i];\r\n            uint256 nextClaim = _stakes[tokenId][0];\r\n            uint256 nextBonus = _stakes[tokenId][1];\r\n            uint256 startTime = _stakes[tokenId][2];\r\n            uint256 duration = (block.timestamp - startTime) / quarter;\r\n            uint256 startPeriod = _stakes[tokenId][3];\r\n            uint256 startDay = _stakes[tokenId][4];\r\n            uint256 tokenPower = _stakes[tokenId][5];\r\n            uint256 delta;\r\n            uint256 j;\r\n\r\n            for (uint256 p = 8; p < 11; p++) {\r\n                uint256 pool = 0;\r\n                if (p == 8 && _stakes[tokenId][8] == 1) {\r\n                    pool = 1;\r\n                }\r\n                else if (p == 9 && _stakes[tokenId][9] == 1) {\r\n                    pool = 2;\r\n                }\r\n                else if (p == 10 && _stakes[tokenId][10] == 1) {\r\n                    pool = 3;\r\n                }\r\n            \r\n                if (pool > 0) { \r\n                    if (currentPeriod >= nextClaim && duration >= 1) {\r\n                        for (j = nextClaim - 1; j < currentPeriod; j++) {               \r\n                            delta = (allPeriods[j + 1] - startTime) / quarter;                    \r\n                            if (j == startPeriod) {\r\n                                sum = sum + ((tokenPower * tokenMultipliers[0] * (quarter + recalculation - startDay) * periodPoolsRewards[pool - 1][j]) / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                            }\r\n                            else {\r\n                                sum = sum + (((tokenPower * ((tokenMultipliers[delta - 1] * startDay) + (tokenMultipliers[delta] * (quarter + recalculation - startDay)))) * periodPoolsRewards[pool - 1][j]) / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                            }\r\n                        }\r\n                    }            \r\n                    if (currentPeriod >= nextBonus && duration >= 1) {\r\n                        for (j = nextBonus - 1; j < currentPeriod; j++) {               \r\n                            delta = (allPeriods[j + 1] - startTime) / quarter;                    \r\n                            if (j == startPeriod) {\r\n                                sum = sum + ((tokenPower * tokenMultipliers[0] * (quarter + recalculation - startDay) * periodPoolsBonuses[pool - 1][j]) / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                            }\r\n                            else {\r\n                                sum = sum + (((tokenPower * ((tokenMultipliers[delta - 1] * startDay) + (tokenMultipliers[delta] * (quarter + recalculation - startDay)))) * periodPoolsBonuses[pool - 1][j]) / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                            }\r\n                        }\r\n                    } \r\n                }\r\n            }\r\n        }\r\n        sum = sum + _calcAccruedSnapshots(staker);\r\n        return sum;\r\n    }\r\n\r\n    function _calcAccruedSnapshots(address staker) private view returns (uint256) { \r\n        uint256 sum = 0;\r\n        uint256 i;\r\n        for (i = 0; i < _stakeSnapshots[staker].length; i++) {\r\n            uint256[11] memory snapshot = _stakeSnapshots[staker][i];        \r\n            uint256 nextClaim = snapshot[0];\r\n            uint256 nextBonus = snapshot[1];\r\n            uint256 startTime = snapshot[2];\r\n            uint256 startPeriod = snapshot[3];\r\n            uint256 startDay = snapshot[4];\r\n            uint256 tokenPower = snapshot[5];          \r\n            uint256 endPeriod = snapshot[6];\r\n            uint256 endDay = snapshot[7];     \r\n\r\n            for (uint256 p = 8; p < 11; p++) {\r\n                uint256 pool = 0;\r\n                if (p == 8 && snapshot[8] == 1) {\r\n                    pool = 1;\r\n                }\r\n                else if (p == 9 && snapshot[9] == 1) {\r\n                    pool = 2;\r\n                }\r\n                else if (p == 10 && snapshot[10] == 1) {\r\n                    pool = 3;\r\n                }\r\n            \r\n                if (pool > 0) {\r\n                    uint256 j;\r\n                    uint256 delta;\r\n                    if (((block.timestamp - allPeriods[0]) / quarter) >= nextClaim) {\r\n                        for (j = nextClaim - 1; j < endPeriod + 1; j++) {\r\n                            delta = (allPeriods[j + 1] - startTime) / quarter;\r\n                            if (j == startPeriod) {\r\n                                sum = sum + ((tokenPower * tokenMultipliers[0] * (quarter + recalculation - startDay) * periodPoolsRewards[pool - 1][j]) / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                            }\r\n                            else if (j == endPeriod) {\r\n                                if (endDay >= startDay) {\r\n                                    sum = sum + ((tokenPower * ((tokenMultipliers[delta - 1] * startDay) + (tokenMultipliers[delta] * (endDay - startDay)))) * periodPoolsRewards[pool - 1][j] / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                                } \r\n                                else {\r\n                                    sum = sum + (tokenPower * tokenMultipliers[delta - 1] * endDay * periodPoolsRewards[pool - 1][j] / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                                }\r\n                            }\r\n                            else {\r\n                                sum = sum + (((tokenPower * ((tokenMultipliers[delta - 1] * startDay) + (tokenMultipliers[delta] * (quarter + recalculation - startDay)))) * periodPoolsRewards[pool - 1][j]) / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                            }\r\n                        }\r\n                        for (j = nextBonus - 1; j < endPeriod + 1; j++) {\r\n                            delta = (allPeriods[j + 1] - startTime) / quarter;\r\n                            if (j == startPeriod) {\r\n                                sum = sum + ((tokenPower * tokenMultipliers[0] * (quarter + recalculation - startDay) * periodPoolsBonuses[pool - 1][j]) / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                            }\r\n                            else if (j == endPeriod) {\r\n                                if (endDay >= startDay) {\r\n                                    sum = sum + ((tokenPower * ((tokenMultipliers[delta - 1] * startDay) + (tokenMultipliers[delta] * (endDay - startDay)))) * periodPoolsBonuses[pool - 1][j] / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                                } \r\n                                else {\r\n                                    sum = sum + (tokenPower * tokenMultipliers[delta - 1] * endDay * periodPoolsBonuses[pool - 1][j] / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                                }\r\n                            }\r\n                            else {\r\n                                sum = sum + (((tokenPower * ((tokenMultipliers[delta - 1] * startDay) + (tokenMultipliers[delta] * (quarter + recalculation - startDay)))) * periodPoolsBonuses[pool - 1][j]) / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                            }\r\n                        }\r\n                    }\r\n                    if (nextClaim == 99) {                        \r\n                        for (j = nextBonus - 1; j < endPeriod + 1; j++) {\r\n                            delta = (allPeriods[j + 1] - startTime) / quarter;\r\n                            if (j == startPeriod) {\r\n                                sum = sum + ((tokenPower * tokenMultipliers[0] * (quarter + recalculation - startDay) * periodPoolsBonuses[pool - 1][j]) / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                            }\r\n                            else if (j == endPeriod) {\r\n                                if (endDay >= startDay) {\r\n                                    sum = sum + ((tokenPower * ((tokenMultipliers[delta - 1] * startDay) + (tokenMultipliers[delta] * (endDay - startDay)))) * periodPoolsBonuses[pool - 1][j] / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                                } \r\n                                else {\r\n                                    sum = sum + (tokenPower * tokenMultipliers[delta - 1] * endDay * periodPoolsBonuses[pool - 1][j] / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                                }\r\n                            }\r\n                            else {\r\n                                sum = sum + (((tokenPower * ((tokenMultipliers[delta - 1] * startDay) + (tokenMultipliers[delta] * (quarter + recalculation - startDay)))) * periodPoolsBonuses[pool - 1][j]) / _allSharesPowerPerStakingPool[pool - 1][j]);\r\n                            }\r\n                        }                      \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    function _calcEstimatedRewards(address staker) private view returns (uint256) {\r\n        uint256 currentPeriod = (block.timestamp - allPeriods[0]) / quarter;\r\n        if (currentPeriod > 23) {\r\n            return 0;\r\n        }\r\n        uint256 sum = 0;\r\n        uint256 i;        \r\n        for (i = 0; i < stakedNfts[staker].length; i++) {\r\n            uint256 tokenId = stakedNfts[staker][i];\r\n            uint256 startPeriod = _stakes[tokenId][3];\r\n            uint256 startDay = _stakes[tokenId][4];\r\n            uint256 tokenPower = _stakes[tokenId][5];\r\n            uint256 delta = currentPeriod - startPeriod;\r\n\r\n            for (uint256 p = 8; p < 11; p++) {\r\n                uint256 pool = 0;\r\n                if (p == 8 && _stakes[tokenId][8] == 1) {\r\n                    pool = 1;\r\n                }\r\n                else if (p == 9 && _stakes[tokenId][9] == 1) {\r\n                    pool = 2;\r\n                }\r\n                else if (p == 10 && _stakes[tokenId][10] == 1) {\r\n                    pool = 3;\r\n                }\r\n            \r\n                if (pool > 0) {\r\n                    if (periodPoolsEstimatedRewards[pool - 1][currentPeriod] > 0) {\r\n                        if (currentPeriod == startPeriod) {\r\n                            sum = sum + ((tokenPower * tokenMultipliers[0] * (quarter + recalculation - startDay) * periodPoolsEstimatedRewards[pool - 1][currentPeriod]) / _allSharesPowerPerStakingPool[pool - 1][currentPeriod]);\r\n                        }\r\n                        else {\r\n                            sum = sum + (((tokenPower * ((tokenMultipliers[delta - 1] * startDay) + (tokenMultipliers[delta] * (quarter + recalculation - startDay)))) * periodPoolsEstimatedRewards[pool - 1][currentPeriod]) / _allSharesPowerPerStakingPool[pool - 1][currentPeriod]);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (currentPeriod > 0) {\r\n                            if (currentPeriod == startPeriod) {\r\n                                sum = sum + ((tokenPower * tokenMultipliers[0] * (quarter + recalculation - startDay) * periodPoolsEstimatedRewards[pool - 1][_lastPeriodEstimatedRewards]) / _allSharesPowerPerStakingPool[pool - 1][currentPeriod]);\r\n                            }\r\n                            else {\r\n                                sum = sum + (((tokenPower * ((tokenMultipliers[delta - 1] * startDay) + (tokenMultipliers[delta] * (quarter + recalculation - startDay)))) * periodPoolsEstimatedRewards[pool - 1][_lastPeriodEstimatedRewards]) / _allSharesPowerPerStakingPool[pool - 1][currentPeriod]);\r\n\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n             }\r\n        }\r\n        sum = sum + _calcEstimatedSnapshots(staker);\r\n        return sum;\r\n    }\r\n\r\n    function _calcEstimatedSnapshots(address staker) private view returns (uint256) { \r\n        uint256 currentPeriod = (block.timestamp - allPeriods[0]) / quarter;  \r\n        uint256 sum = 0;\r\n        uint256 i;\r\n        \r\n        for (i = 0; i < _stakeSnapshots[staker].length; i++) {\r\n            uint256[11] memory snapshot = _stakeSnapshots[staker][i];        \r\n            uint256 startPeriod = snapshot[3];\r\n            uint256 startDay = snapshot[4];\r\n            uint256 tokenPower = snapshot[5];\r\n            uint256 endPeriod = snapshot[6]; \r\n            uint256 endDay = snapshot[7];     \r\n            uint256 delta = currentPeriod - startPeriod;\r\n            if (currentPeriod == endPeriod) {\r\n                for (uint256 p = 8; p < 11; p++) {\r\n                    uint256 pool = 0;\r\n                    if (p == 8 && snapshot[8] == 1) {\r\n                        pool = 1;\r\n                    }\r\n                    else if (p == 9 && snapshot[9] == 1) {\r\n                        pool = 2;\r\n                    }\r\n                    else if (p == 10 && snapshot[10] == 1) {\r\n                        pool = 3;\r\n                    }\r\n            \r\n                    if (pool > 0) {\r\n                        if (periodPoolsEstimatedRewards[pool - 1][currentPeriod] > 0) {\r\n                            if (endDay >= startDay) {\r\n                                sum = sum + (((tokenPower * ((tokenMultipliers[delta - 1] * startDay) + (tokenMultipliers[delta] * (endDay - startDay)))) * periodPoolsEstimatedRewards[pool - 1][currentPeriod]) / _allSharesPowerPerStakingPool[pool - 1][currentPeriod]);\r\n                            }\r\n                            else {\r\n                                sum = sum + (tokenPower * tokenMultipliers[delta - 1] * endDay * periodPoolsEstimatedRewards[pool - 1][currentPeriod] / _allSharesPowerPerStakingPool[pool - 1][currentPeriod]);\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (endDay >= startDay) {\r\n                                sum = sum + (((tokenPower * ((tokenMultipliers[delta - 1] * startDay) + (tokenMultipliers[delta] * (endDay - startDay)))) * periodPoolsEstimatedRewards[pool - 1][_lastPeriodEstimatedRewards]) / _allSharesPowerPerStakingPool[pool - 1][currentPeriod]);\r\n                            }\r\n                            else {\r\n                                sum = sum + (tokenPower * tokenMultipliers[delta - 1] * endDay * periodPoolsEstimatedRewards[pool - 1][_lastPeriodEstimatedRewards] / _allSharesPowerPerStakingPool[pool - 1][currentPeriod]);\r\n                            }\r\n                        } \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    function _getTokenPower(uint256 tokenId) private pure returns (uint256 rate) {\r\n        if (tokenId >= 1501) {\r\n            return 100;\r\n        }\r\n        else if (tokenId >= 751) {\r\n            return 130;\r\n        }\r\n        else if (tokenId >= 251) {\r\n            return 150;\r\n        }\r\n        else if (tokenId >= 26) {\r\n            return 175;\r\n        }\r\n        else if (tokenId >= 4) {\r\n            return 200;\r\n        }        \r\n        else if (tokenId == 3) {\r\n            return 250;\r\n        }\r\n        else if (tokenId == 2) {\r\n            return 300;\r\n        }\r\n        else if (tokenId == 1) {\r\n            return 400;\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPeriods\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vesting\",\"type\":\"address\"}],\"name\":\"allowStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"}],\"name\":\"chooseAdditionalStakingPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultStakingPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"estimatedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"firstDayStakersAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstDayStakersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstStakingPoolRewardPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentDayOfQuarter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCurrentMultiplierForToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentMultipliers\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentQuarterFromStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNfts\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getNftsByAddress\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNftsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getOwnerByTokenId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getStakingPoolsOfToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pools\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStakingAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftForStaking\",\"outputs\":[{\"internalType\":\"contract IERC721Custom\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periodBonuses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periodEstimatedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periodPoolsBonuses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periodPoolsEstimatedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periodPoolsRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periodRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20Custom\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondStakingPoolRewardPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setBonusForLastPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"}],\"name\":\"setDefaultStakingPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setEstimatedReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"}],\"name\":\"setNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setRewardForLastPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"first\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"second\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"third\",\"type\":\"uint256\"}],\"name\":\"setStakingPoolsRewardPercentages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vesting\",\"type\":\"address\"}],\"name\":\"setVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakedNfts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thirdStakingPoolRewardPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenMultipliers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingContract\",\"outputs\":[{\"internalType\":\"contract IVesting\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NFTStaking", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000df686b3eae2c1b576f0570f1f2c516fee03987a8000000000000000000000000b0915aa56d49785926c62b862115cb979a0f6443", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b2585f2a64efa3f4c6fa27ec5a05068f53a143816231cdcfbc66f757fd63b9c0"}]}