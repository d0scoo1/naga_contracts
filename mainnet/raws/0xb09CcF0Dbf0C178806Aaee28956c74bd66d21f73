{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/buOLAS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"./interfaces/IErrors.sol\\\";\\n\\n/// @title Burnable Locked OLAS Token - OLAS burnable contract\\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\\n\\n// Interface for IOLAS burn functionality\\ninterface IOLAS {\\n    /// @dev Burns OLAS tokens.\\n    /// @param amount OLAS token amount to burn.\\n    function burn(uint256 amount) external;\\n}\\n\\n// Struct for storing balance, lock and unlock time\\n// The struct size is one storage slot of uint256 (96 + 96 + 32 + 32)\\nstruct LockedBalance {\\n    // Token amount locked. Initial OLAS cap is 1 bn tokens, or 1e27.\\n    // After 10 years, the inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1\\n    uint96 totalAmount;\\n    // Token amount transferred to its owner. It is of the value of at most the total amount locked\\n    uint96 transferredAmount;\\n    // Lock time start\\n    uint32 startTime;\\n    // Lock end time\\n    // 2^32 - 1 is enough to count 136 years starting from the year of 1970. This counter is safe until the year of 2106\\n    uint32 endTime;\\n}\\n\\n/// @notice This token supports the ERC20 interface specifications except for transfers.\\ncontract buOLAS is IErrors, IERC20, IERC165 {\\n    event Lock(address indexed account, uint256 amount, uint256 startTime, uint256 endTime);\\n    event Withdraw(address indexed account, uint256 amount, uint256 ts);\\n    event Revoke(address indexed account, uint256 amount, uint256 ts);\\n    event Burn(address indexed account, uint256 amount, uint256 ts);\\n    event Supply(uint256 previousSupply, uint256 currentSupply);\\n    event OwnerUpdated(address indexed owner);\\n\\n    // Locking step time\\n    uint32 internal constant STEP_TIME = 365 * 86400;\\n    // Maximum number of steps\\n    uint32 internal constant MAX_NUM_STEPS = 10;\\n    // Total token supply\\n    uint256 public supply;\\n    // Number of decimals\\n    uint8 public constant decimals = 18;\\n\\n    // Token address\\n    address public immutable token;\\n    // Owner address\\n    address public owner;\\n    // Mapping of account address => LockedBalance\\n    mapping(address => LockedBalance) public mapLockedBalances;\\n\\n    // Token name\\n    string public name;\\n    // Token symbol\\n    string public symbol;\\n\\n    /// @dev Contract constructor\\n    /// @param _token Token address.\\n    /// @param _name Token name.\\n    /// @param _symbol Token symbol.\\n    constructor(address _token, string memory _name, string memory _symbol)\\n    {\\n        token = _token;\\n        name = _name;\\n        symbol = _symbol;\\n        owner = msg.sender;\\n    }\\n\\n    /// @dev Changes the owner address.\\n    /// @param newOwner Address of a new owner.\\n    function changeOwner(address newOwner) external {\\n        if (msg.sender != owner) {\\n            revert OwnerOnly(msg.sender, owner);\\n        }\\n\\n        if (newOwner == address(0)) {\\n            revert ZeroAddress();\\n        }\\n\\n        owner = newOwner;\\n        emit OwnerUpdated(newOwner);\\n    }\\n\\n    /// @dev Deposits `amount` tokens for the `account` and locks for the `numSteps` time periods.\\n    /// @notice Tokens are taken from `msg.sender`'s balance.\\n    /// @param account Target account address.\\n    /// @param amount Amount to deposit.\\n    /// @param numSteps Number of locking steps.\\n    function createLockFor(address account, uint256 amount, uint256 numSteps) external {\\n        // Check if the account is zero\\n        if (account == address(0)) {\\n            revert ZeroAddress();\\n        }\\n        // Check if the amount is zero\\n        if (amount == 0) {\\n            revert ZeroValue();\\n        }\\n        // The locking makes sense for one step or more only\\n        if (numSteps == 0) {\\n            revert ZeroValue();\\n        }\\n        // Check the maximum number of steps\\n        if (numSteps > MAX_NUM_STEPS) {\\n            revert Overflow(numSteps, MAX_NUM_STEPS);\\n        }\\n        // Lock time is equal to the number of fixed steps multiply on a step time\\n        uint256 unlockTime = block.timestamp + uint256(STEP_TIME) * numSteps;\\n        // Max of 2^32 - 1 value, the counter is safe until the year of 2106\\n        if (unlockTime > type(uint32).max) {\\n            revert Overflow(unlockTime, type(uint32).max);\\n        }\\n        // After 10 years, the inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1 total supply\\n        if (amount > type(uint96).max) {\\n            revert Overflow(amount, type(uint96).max);\\n        }\\n\\n        LockedBalance memory lockedBalance = mapLockedBalances[account];\\n        // The locked balance must be zero in order to start the lock\\n        if (lockedBalance.totalAmount > 0) {\\n            revert LockedValueNotZero(account, lockedBalance.totalAmount);\\n        }\\n\\n        // Store the locked information for the account\\n        lockedBalance.startTime = uint32(block.timestamp);\\n        lockedBalance.endTime = uint32(unlockTime);\\n        lockedBalance.totalAmount = uint96(amount);\\n        mapLockedBalances[account] = lockedBalance;\\n\\n        // Calculate total supply\\n        uint256 supplyBefore = supply;\\n        uint256 supplyAfter;\\n        // Cannot overflow because we do not add more tokens than the OLAS supply\\n        unchecked {\\n            supplyAfter = supplyBefore + amount;\\n            supply = supplyAfter;\\n        }\\n\\n        // OLAS is a solmate-based ERC20 token with optimized transferFrom() that either returns true or reverts\\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\\n\\n        emit Lock(account, amount, block.timestamp, unlockTime);\\n        emit Supply(supplyBefore, supplyAfter);\\n    }\\n\\n    /// @dev Releases all matured tokens for `msg.sender`.\\n    function withdraw() external {\\n        LockedBalance memory lockedBalance = mapLockedBalances[msg.sender];\\n        // If the balances are still active and not fully withdrawn, start time must be greater than zero\\n        if (lockedBalance.startTime > 0) {\\n            // Calculate the amount to release\\n            uint256 amount = _releasableAmount(lockedBalance);\\n            // Check if at least one locking step has passed\\n            if (amount == 0) {\\n                revert LockNotExpired(msg.sender, lockedBalance.endTime, block.timestamp);\\n            }\\n\\n            uint256 supplyBefore = supply;\\n            uint256 supplyAfter = supplyBefore;\\n            // End time is greater than zero if withdraw was not fully completed and `revoke` was not called on the account\\n            if (lockedBalance.endTime > 0) {\\n                unchecked {\\n                    // Update the account locked amount.\\n                    // Cannot practically overflow since the amount to release is smaller than the locked amount\\n                    lockedBalance.transferredAmount += uint96(amount);\\n                }\\n                // The balance is fully unlocked. Released amount must be equal to the locked one\\n                if ((lockedBalance.transferredAmount + 1) > lockedBalance.totalAmount) {\\n                    mapLockedBalances[msg.sender] = LockedBalance(0, 0, 0, 0);\\n                } else {\\n                    mapLockedBalances[msg.sender] = lockedBalance;\\n                }\\n            } else {\\n                // This means revoke has been called on this account and some tokens must be burned\\n                uint256 amountBurn = uint256(lockedBalance.totalAmount);\\n                // Burn revoked tokens\\n                if (amountBurn > 0) {\\n                    IOLAS(token).burn(amountBurn);\\n                    // Update total supply\\n                    unchecked {\\n                        // Amount to burn cannot be bigger than the supply before the burn\\n                        supplyAfter = supplyBefore - amountBurn;\\n                    }\\n                    emit Burn(msg.sender, amountBurn, block.timestamp);\\n                }\\n                // Set all the data to zero\\n                mapLockedBalances[msg.sender] = LockedBalance(0, 0, 0, 0);\\n            }\\n\\n            // The amount cannot be bigger than the total supply\\n            unchecked {\\n                supplyAfter -= amount;\\n                supply = supplyAfter;\\n            }\\n\\n            emit Withdraw(msg.sender, amount, block.timestamp);\\n            emit Supply(supplyBefore, supplyAfter);\\n\\n            // OLAS is a solmate-based ERC20 token with optimized transfer() that either returns true or reverts\\n            IERC20(token).transfer(msg.sender, amount);\\n        }\\n    }\\n\\n    /// @dev Revoke and burn all non-matured tokens from the `account`.\\n    /// @param accounts Account addresses.\\n    function revoke(address[] memory accounts) external {\\n        // Check for the ownership\\n        if (owner != msg.sender) {\\n            revert OwnerOnly(msg.sender, owner);\\n        }\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            address account = accounts[i];\\n            LockedBalance memory lockedBalance = mapLockedBalances[account];\\n\\n            // Get the amount to release\\n            uint256 amountRelease = _releasableAmount(lockedBalance);\\n            // Amount locked now represents the burn amount, which can not become less than zero\\n            unchecked {\\n                lockedBalance.totalAmount -= (uint96(amountRelease) + lockedBalance.transferredAmount);\\n            }\\n            // This is the release amount that will be transferred to the account when they withdraw\\n            lockedBalance.transferredAmount = uint96(amountRelease);\\n            // Termination state of the revoke procedure\\n            lockedBalance.endTime = 0;\\n            // Update the account data\\n            mapLockedBalances[account] = lockedBalance;\\n\\n            emit Revoke(account, uint256(lockedBalance.totalAmount), block.timestamp);\\n        }\\n    }\\n\\n    /// @dev Gets the account locking balance.\\n    /// @param account Account address.\\n    /// @return balance Account balance.\\n    function balanceOf(address account) public view override returns (uint256 balance) {\\n        LockedBalance memory lockedBalance = mapLockedBalances[account];\\n        // If the end is equal 0, this balance is either left after revoke or expired\\n        if (lockedBalance.endTime == 0) {\\n            // The maximum balance in this case is the released amount value\\n            balance = uint256(lockedBalance.transferredAmount);\\n        } else {\\n            // Otherwise the balance is the difference between locked and released amounts\\n            balance = uint256(lockedBalance.totalAmount - lockedBalance.transferredAmount);\\n        }\\n    }\\n\\n    /// @dev Gets total token supply.\\n    /// @return Total token supply.\\n    function totalSupply() public view override returns (uint256) {\\n        return supply;\\n    }\\n\\n    /// @dev Gets the account releasable amount.\\n    /// @param account Account address.\\n    /// @return amount Amount to release.\\n    function releasableAmount(address account) external view returns (uint256 amount) {\\n        LockedBalance memory lockedBalance = mapLockedBalances[account];\\n        amount = _releasableAmount(lockedBalance);\\n    }\\n\\n    /// @dev Gets the account releasable amount.\\n    /// @param lockedBalance Account locked balance struct.\\n    /// @return amount Amount to release.\\n    function _releasableAmount(LockedBalance memory lockedBalance) private view returns (uint256 amount) {\\n        // If the end is equal 0, this balance is either left after revoke or expired\\n        if (lockedBalance.endTime == 0) {\\n            return lockedBalance.transferredAmount;\\n        }\\n        // Number of steps\\n        uint32 numSteps;\\n        // Current locked time\\n        uint32 releasedSteps;\\n        // Time in the future will be greater than the start time\\n        unchecked {\\n            numSteps = (lockedBalance.endTime - lockedBalance.startTime) / STEP_TIME;\\n            releasedSteps = (uint32(block.timestamp) - lockedBalance.startTime) / STEP_TIME;\\n        }\\n\\n        // If the number of release steps is greater or equal to the number of steps, all the available tokens are unlocked\\n        if ((releasedSteps + 1) > numSteps) {\\n            // Return the remainder from the last release since it's the last one\\n            unchecked {\\n                amount = uint256(lockedBalance.totalAmount - lockedBalance.transferredAmount);\\n            }\\n        } else {\\n            // Calculate the amount to release\\n            unchecked {\\n                amount = uint256(lockedBalance.totalAmount * releasedSteps / numSteps);\\n                amount -= uint256(lockedBalance.transferredAmount);\\n            }\\n        }\\n    }\\n\\n    /// @dev Gets the `account`'s locking end time.\\n    /// @param account Account address.\\n    /// @return unlockTime Maturity time.\\n    function lockedEnd(address account) external view returns (uint256 unlockTime) {\\n        unlockTime = uint256(mapLockedBalances[account].endTime);\\n    }\\n\\n    /// @dev Gets information about the interface support.\\n    /// @param interfaceId A specified interface Id.\\n    /// @return True if this contract implements the interface defined by interfaceId.\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC20).interfaceId || interfaceId == type(IERC165).interfaceId;\\n    }\\n\\n    /// @dev Reverts the transfer of this token.\\n    function transfer(address to, uint256 amount) external virtual override returns (bool) {\\n        revert NonTransferable(address(this));\\n    }\\n\\n    /// @dev Reverts the approval of this token.\\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\\n        revert NonTransferable(address(this));\\n    }\\n\\n    /// @dev Reverts the transferFrom of this token.\\n    function transferFrom(address from, address to, uint256 amount) external virtual override returns (bool) {\\n        revert NonTransferable(address(this));\\n    }\\n\\n    /// @dev Reverts the allowance of this token.\\n    function allowance(address owner, address spender) external view virtual override returns (uint256)\\n    {\\n        revert NonTransferable(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/// @dev Errors.\\ninterface IErrors {\\n    /// @dev Only `owner` has a privilege, but the `sender` was provided.\\n    /// @param sender Sender address.\\n    /// @param owner Required sender address as an owner.\\n    error OwnerOnly(address sender, address owner);\\n\\n    /// @dev Provided zero address.\\n    error ZeroAddress();\\n\\n    /// @dev Zero value when it has to be different from zero.\\n    error ZeroValue();\\n\\n    /// @dev Non-zero value when it has to be zero.\\n    error NonZeroValue();\\n\\n    /// @dev Wrong length of two arrays.\\n    /// @param numValues1 Number of values in a first array.\\n    /// @param numValues2 Numberf of values in a second array.\\n    error WrongArrayLength(uint256 numValues1, uint256 numValues2);\\n\\n    /// @dev Value overflow.\\n    /// @param provided Overflow value.\\n    /// @param max Maximum possible value.\\n    error Overflow(uint256 provided, uint256 max);\\n\\n    /// @dev Token is non-transferable.\\n    /// @param account Token address.\\n    error NonTransferable(address account);\\n\\n    /// @dev Token is non-delegatable.\\n    /// @param account Token address.\\n    error NonDelegatable(address account);\\n\\n    /// @dev Insufficient token allowance.\\n    /// @param provided Provided amount.\\n    /// @param expected Minimum expected amount.\\n    error InsufficientAllowance(uint256 provided, uint256 expected);\\n\\n    /// @dev No existing lock value is found.\\n    /// @param account Address that is checked for the locked value.\\n    error NoValueLocked(address account);\\n\\n    /// @dev Locked value is not zero.\\n    /// @param account Address that is checked for the locked value.\\n    /// @param amount Locked amount.\\n    error LockedValueNotZero(address account, uint256 amount);\\n\\n    /// @dev Value lock is expired.\\n    /// @param account Address that is checked for the locked value.\\n    /// @param deadline The lock expiration deadline.\\n    /// @param curTime Current timestamp.\\n    error LockExpired(address account, uint256 deadline, uint256 curTime);\\n\\n    /// @dev Value lock is not expired.\\n    /// @param account Address that is checked for the locked value.\\n    /// @param deadline The lock expiration deadline.\\n    /// @param curTime Current timestamp.\\n    error LockNotExpired(address account, uint256 deadline, uint256 curTime);\\n\\n    /// @dev Provided unlock time is incorrect.\\n    /// @param account Address that is checked for the locked value.\\n    /// @param minUnlockTime Minimal unlock time that can be set.\\n    /// @param providedUnlockTime Provided unlock time.\\n    error UnlockTimeIncorrect(address account, uint256 minUnlockTime, uint256 providedUnlockTime);\\n\\n    /// @dev Provided unlock time is bigger than the maximum allowed.\\n    /// @param account Address that is checked for the locked value.\\n    /// @param maxUnlockTime Max unlock time that can be set.\\n    /// @param providedUnlockTime Provided unlock time.\\n    error MaxUnlockTimeReached(address account, uint256 maxUnlockTime, uint256 providedUnlockTime);\\n\\n    /// @dev Provided block number is incorrect (has not been processed yet).\\n    /// @param providedBlockNumber Provided block number.\\n    /// @param actualBlockNumber Actual block number.\\n    error WrongBlockNumber(uint256 providedBlockNumber, uint256 actualBlockNumber);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"provided\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curTime\",\"type\":\"uint256\"}],\"name\":\"LockExpired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curTime\",\"type\":\"uint256\"}],\"name\":\"LockNotExpired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LockedValueNotZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxUnlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"providedUnlockTime\",\"type\":\"uint256\"}],\"name\":\"MaxUnlockTimeReached\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NoValueLocked\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NonDelegatable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NonTransferable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonZeroValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"provided\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"Overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerOnly\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minUnlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"providedUnlockTime\",\"type\":\"uint256\"}],\"name\":\"UnlockTimeIncorrect\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numValues1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numValues2\",\"type\":\"uint256\"}],\"name\":\"WrongArrayLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"providedBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualBlockNumber\",\"type\":\"uint256\"}],\"name\":\"WrongBlockNumber\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroValue\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentSupply\",\"type\":\"uint256\"}],\"name\":\"Supply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numSteps\",\"type\":\"uint256\"}],\"name\":\"createLockFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"lockedEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mapLockedBalances\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"totalAmount\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"transferredAmount\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"releasableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "buOLAS", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000000001a500a6b18995b03f44bb040a5ffc28e45cb0000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000144275726e61626c65204c6f636b6564204f4c4153000000000000000000000000000000000000000000000000000000000000000000000000000000000000000662754f4c41530000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}