{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/game/GameStats.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n ______     __                            __           __                      __\\n|_   _ \\\\   [  |                          |  ]         [  |                    |  ]\\n  | |_) |   | |    .--.     .--.     .--.| |   .--.    | |--.    .---.    .--.| |\\n  |  __'.   | |  / .'`\\\\ \\\\ / .'`\\\\ \\\\ / /'`\\\\' |  ( (`\\\\]   | .-. |  / /__\\\\\\\\ / /'`\\\\' |\\n _| |__) |  | |  | \\\\__. | | \\\\__. | | \\\\__/  |   `'.'.   | | | |  | \\\\__., | \\\\__/  |\\n|_______/  [___]  '.__.'   '.__.'   '.__.;__] [\\\\__) ) [___]|__]  '.__.'  '.__.;__]\\n                      ________\\n                      ___  __ )_____ ______ _________________\\n                      __  __  |_  _ \\\\_  __ `/__  ___/__  ___/\\n                      _  /_/ / /  __// /_/ / _  /    _(__  )\\n                      /_____/  \\\\___/ \\\\__,_/  /_/     /____/\\n*/\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    function approve(address spender, uint256 value) external returns (bool success);\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function decimals() external view returns (uint8 decimalPlaces);\\n\\n    function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n    function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n    function name() external view returns (string memory tokenName);\\n\\n    function symbol() external view returns (string memory tokenSymbol);\\n\\n    function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n    function transfer(address to, uint256 value) external returns (bool success);\\n\\n    function transferAndCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool success);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool success);\\n}\\n\\npragma solidity ^0.8.0;\\n\\ncontract VRFRequestIDBase {\\n    /**\\n     * @notice returns the seed which is actually input to the VRF coordinator\\n   *\\n   * @dev To prevent repetition of VRF output due to repetition of the\\n   * @dev user-supplied seed, that seed is combined in a hash with the\\n   * @dev user-specific nonce, and the address of the consuming contract. The\\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\\n   * @dev the final seed, but the nonce does protect against repetition in\\n   * @dev requests which are included in a single block.\\n   *\\n   * @param _userSeed VRF seed input provided by user\\n   * @param _requester Address of the requesting contract\\n   * @param _nonce User-specific nonce at the time of the request\\n   */\\n    function makeVRFInputSeed(\\n        bytes32 _keyHash,\\n        uint256 _userSeed,\\n        address _requester,\\n        uint256 _nonce\\n    ) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\n    }\\n\\n    /**\\n     * @notice Returns the id for this request\\n   * @param _keyHash The serviceAgreement ID to be used for this request\\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\\n   * @return The id for this request\\n   *\\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\\n   * @dev contract, but the one generated by makeVRFInputSeed\\n   */\\n    function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\n    }\\n}\\n\\npragma solidity ^0.8.0;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\\n * @dev want to generate randomness from.\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomness method.\\n *\\n * @dev The randomness argument to fulfillRandomness is the actual random value\\n * @dev generated from your seed.\\n *\\n * @dev The requestId argument is generated from the keyHash and the seed by\\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\\n * @dev requests open, you can use the requestId to track which seed is\\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\\n * @dev details. (See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.)\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ. (Which is critical to making unpredictable randomness! See the\\n * @dev next section.)\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\\n * @dev block in which the request is made, user-provided seeds have no impact\\n * @dev on its economic security properties. They are only included for API\\n * @dev compatability with previous versions of this contract.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request.\\n */\\nabstract contract VRFConsumerBase is VRFRequestIDBase {\\n    /**\\n     * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomness the VRF output\\n   */\\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\\n\\n    /**\\n     * @dev In order to keep backwards compatibility we have kept the user\\n   * seed field around. We remove the use of it because given that the blockhash\\n   * enters later, it overrides whatever randomness the used seed provides.\\n   * Given that it adds no security, and can easily lead to misunderstandings,\\n   * we have removed it from usage and can now provide a simpler API.\\n   */\\n    uint256 private constant USER_SEED_PLACEHOLDER = 0;\\n\\n    /**\\n     * @notice requestRandomness initiates a request for VRF output given _seed\\n   *\\n   * @dev The fulfillRandomness method receives the output, once it's provided\\n   * @dev by the Oracle, and verified by the vrfCoordinator.\\n   *\\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\\n   * @dev the _fee must exceed the fee specified during registration of the\\n   * @dev _keyHash.\\n   *\\n   * @dev The _seed parameter is vestigial, and is kept only for API\\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\\n   * @dev your own randomness, here, but it's not necessary because the VRF\\n   * @dev oracle will mix the hash of the block containing your request into the\\n   * @dev VRF seed it ultimately uses.\\n   *\\n   * @param _keyHash ID of public key against which randomness is generated\\n   * @param _fee The amount of LINK to send with the request\\n   *\\n   * @return requestId unique ID for this request\\n   *\\n   * @dev The returned requestId can be used to distinguish responses to\\n   * @dev concurrent requests. It is passed as the first argument to\\n   * @dev fulfillRandomness.\\n   */\\n    function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\\n        LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\\n        // This is the seed passed to VRFCoordinator. The oracle will mix this with\\n        // the hash of the block containing this request to obtain the seed/input\\n        // which is finally passed to the VRF cryptographic machinery.\\n        uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\\n        // nonces[_keyHash] must stay in sync with\\n        // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\\n        // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\\n        // This provides protection against the user repeating their input seed,\\n        // which would result in a predictable/duplicate output, if multiple such\\n        // requests appeared in the same block.\\n        nonces[_keyHash] = nonces[_keyHash] + 1;\\n        return makeRequestId(_keyHash, vRFSeed);\\n    }\\n\\n    LinkTokenInterface internal immutable LINK;\\n    address private immutable vrfCoordinator;\\n\\n    // Nonces for each VRF key from which randomness has been requested.\\n    //\\n    // Must stay in sync with VRFCoordinator[_keyHash][this]\\n    mapping(bytes32 => uint256) /* keyHash */ /* nonce */\\n    private nonces;\\n\\n    /**\\n     * @param _vrfCoordinator address of VRFCoordinator contract\\n   * @param _link address of LINK token contract\\n   *\\n   * @dev https://docs.chain.link/docs/link-token-contracts\\n   */\\n    constructor(address _vrfCoordinator, address _link) {\\n        vrfCoordinator = _vrfCoordinator;\\n        LINK = LinkTokenInterface(_link);\\n    }\\n\\n    // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n    // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n    // the origin of the call\\n    function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\\n        require(msg.sender == vrfCoordinator, \\\"Only VRFCoordinator can fulfill\\\");\\n        fulfillRandomness(requestId, randomness);\\n    }\\n}\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\\ninterface IToken {\\n    function add(address wallet, uint256 amount) external;\\n    function spend(address wallet, uint256 amount) external;\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function mintTokens(address to, uint256 amount) external;\\n    function getWalletBalance(address wallet) external returns (uint256);\\n}\\n\\ninterface IStakingContract {\\n    function ownerOf(address collection, uint256 token) external returns (address);\\n}\\n\\npragma solidity ^0.8.0;\\n\\ncontract GameStats is Ownable, VRFConsumerBase, Pausable {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    struct TokenSelection {\\n        address collectionAddress;\\n        uint256[] tokens;\\n    }\\n\\n    struct ImpactType {\\n        uint256 boost;\\n        uint256 riskReduction;\\n    }\\n\\n    struct TokenData {\\n        bool isElite;\\n        bool faction;\\n        uint256 level;\\n        uint256 levelEnrolDate;\\n        uint256 stakeType;\\n        address owner;\\n    }\\n\\n    mapping(bytes32 => TokenData) tokenDataEncoded;\\n    EnumerableSet.Bytes32Set redElites;\\n    EnumerableSet.Bytes32Set blueElites;\\n\\n    uint256 houseUpgradeCost = 1000000000 ether;\\n\\n    uint256 public treeHouseRisk = 25;\\n    uint256 public tokenGeneratorRisk = 25;\\n\\n    uint256 public HOUSE_CAP = 5;\\n    uint256 public LEVEL_CAP = 1000;\\n    uint256 public BASE_RISK = 50;\\n    uint256 public HOME_STAKE = 1;\\n    uint256 public TREE_HOUSE_STAKE = 2;\\n\\n    mapping(string => address) public contractsAddressesMap;\\n\\n    uint256[] public levelMilestones;\\n    mapping(uint256 => ImpactType) public levelImpacts;\\n\\n    mapping(uint256 => ImpactType) public stakeTypeImpacts;\\n\\n    uint256 private vrfFee;\\n    bytes32 private vrfKeyHash;\\n\\n    uint256 private seed;\\n\\n\\n    mapping(address => bool) public authorisedAddresses;\\n\\n    modifier authorised() {\\n        require(authorisedAddresses[msg.sender], \\\"The token contract is not authorised\\\");\\n        _;\\n    }\\n\\n    event SeedFulfilled();\\n\\n    event BLDStolen(address to, uint256 amount);\\n\\n    constructor(\\n        address vrfCoordinatorAddr_,\\n        address linkTokenAddr_,\\n        bytes32 vrfKeyHash_,\\n        uint256 fee_\\n    ) VRFConsumerBase(vrfCoordinatorAddr_, linkTokenAddr_) {\\n        vrfKeyHash = vrfKeyHash_;\\n        vrfFee = fee_;\\n    }\\n\\n    // ADMIN\\n    function setCollectionsKeys(\\n        string[] calldata keys_,\\n        address[] calldata collections_\\n    ) external onlyOwner {\\n        for (uint i = 0; i < keys_.length; ++i) {\\n            contractsAddressesMap[keys_[i]] = collections_[i];\\n        }\\n    }\\n\\n    function setLevelImpacts(uint256[] memory milestones_, ImpactType[] calldata impacts_) external onlyOwner {\\n\\n        require(milestones_.length == impacts_.length, \\\"INVALID LENGTH\\\");\\n\\n        levelMilestones = milestones_;\\n\\n        for (uint256 i = 0; i < milestones_.length; i++) {\\n            ImpactType storage levelImpact = levelImpacts[milestones_[i]];\\n            levelImpact.boost = impacts_[i].boost;\\n            levelImpact.riskReduction = impacts_[i].riskReduction;\\n        }\\n    }\\n\\n    function setStakeTypeImpacts(uint256[] calldata stakeTypes_, ImpactType[] calldata impacts_) external onlyOwner {\\n\\n        require(stakeTypes_.length == impacts_.length, \\\"INVALID LENGTH\\\");\\n\\n        for (uint256 i = 0; i < stakeTypes_.length; i++) {\\n            ImpactType storage levelImpact = stakeTypeImpacts[stakeTypes_[i]];\\n            levelImpact.boost = impacts_[i].boost;\\n            levelImpact.riskReduction = impacts_[i].riskReduction;\\n        }\\n    }\\n\\n    function setAuthorised(address[] calldata addresses_, bool[] calldata authorisations_) external onlyOwner {\\n        for (uint256 i = 0; i < addresses_.length; ++i) {\\n            authorisedAddresses[addresses_[i]] = authorisations_[i];\\n        }\\n    }\\n\\n    function setHouseUpgradeCost(uint256 houseUpgradeCost_) external onlyOwner {\\n        houseUpgradeCost = houseUpgradeCost_;\\n    }\\n\\n    function setTokensData(\\n        address collection_,\\n        uint256[] calldata tokenIds_,\\n        uint256[] calldata levels_,\\n        bool[] calldata factions_,\\n        bool[] calldata elites_\\n    ) external authorised {\\n\\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\\n            bytes32 tokenKey = getTokenKey(collection_, tokenIds_[i]);\\n            TokenData storage tokenData = tokenDataEncoded[tokenKey];\\n            if (tokenData.level == 0) {\\n                tokenData.faction = factions_[i];\\n                tokenData.isElite = elites_[i];\\n                tokenData.level = levels_[i];\\n            }\\n        }\\n    }\\n\\n    function setStakedTokenData(\\n        address collection_,\\n        address owner_,\\n        uint256 stakeType_,\\n        uint256[] calldata tokenIds_\\n    ) external authorised {\\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\\n            bytes32 tokenKey = getTokenKey(collection_, tokenIds_[i]);\\n            TokenData storage tokenData = tokenDataEncoded[tokenKey];\\n\\n            tokenData.owner = owner_;\\n\\n            if (tokenData.isElite) {\\n                if (tokenData.faction) {\\n                    blueElites.add(tokenKey);\\n                } else {\\n                    redElites.add(tokenKey);\\n                }\\n            }\\n\\n            tokenData.stakeType = stakeType_;\\n            tokenData.levelEnrolDate = block.timestamp;\\n        }\\n    }\\n\\n    function unsetStakedTokenData(\\n        address collection_,\\n        uint256[] calldata tokenIds_\\n    ) external authorised {\\n\\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\\n\\n            bytes32 tokenKey = getTokenKey(collection_, tokenIds_[i]);\\n            TokenData storage tokenData = tokenDataEncoded[tokenKey];\\n\\n            if (tokenData.isElite) {\\n                if (tokenData.faction) {\\n                    blueElites.remove(tokenKey);\\n                } else {\\n                    redElites.remove(tokenKey);\\n                }\\n            }\\n\\n            _claimLevelForToken(collection_, tokenIds_[i]);\\n\\n            tokenData.stakeType = 0;\\n\\n        }\\n    }\\n\\n\\n    function getTokenKey(address collection_, uint256 tokenId_) public pure returns (bytes32) {\\n        return keccak256(abi.encode(collection_, tokenId_));\\n    }\\n\\n    function getLevel(address collection_, uint256 tokenId_) public view returns (uint256) {\\n        return tokenDataEncoded[getTokenKey(collection_, tokenId_)].level;\\n    }\\n\\n    function getLevels(\\n        address collection_,\\n        uint256[] calldata tokenIds_\\n    ) external view returns (uint256[] memory) {\\n        uint256[] memory levels = new uint256[](tokenIds_.length);\\n\\n        for (uint256 i = 0; i < tokenIds_.length; ++i) {\\n            levels[i] = getLevel(collection_, tokenIds_[i]);\\n        }\\n\\n        return levels;\\n    }\\n\\n    function getLevelBoosts(\\n        address collection_,\\n        uint256[] calldata tokenIds_\\n    ) external view returns (uint256[] memory) {\\n        uint256[] memory levelBoosts = new uint256[](tokenIds_.length);\\n\\n        for (uint256 i = 0; i < tokenIds_.length; ++i) {\\n            bytes32 tokenKey = getTokenKey(collection_, tokenIds_[i]);\\n            for (uint256 j = levelMilestones.length - 1; j >= 0; --j) {\\n                if (tokenDataEncoded[tokenKey].level >= levelMilestones[j]) {\\n                    levelBoosts[i] = levelImpacts[levelMilestones[j]].boost;\\n                    break;\\n                }\\n            }\\n        }\\n        return levelBoosts;\\n    }\\n\\n    function getLevelBoost(address collection, uint256 tokenId) external view returns (uint256) {\\n        uint256 levelBoost;\\n        bytes32 tokenKey = getTokenKey(collection, tokenId);\\n        for (uint256 j = levelMilestones.length - 1; j >= 0; --j) {\\n            if (tokenDataEncoded[tokenKey].level >= levelMilestones[j]) {\\n                levelBoost = levelImpacts[levelMilestones[j]].boost;\\n                break;\\n            }\\n        }\\n\\n        return levelBoost;\\n    }\\n\\n    function claimLevel(TokenSelection[] calldata tokensSelection_) public {\\n        for (uint256 i = 0; i < tokensSelection_.length; ++i) {\\n            for (uint256 j = 0; j < tokensSelection_[i].tokens.length; ++j) {\\n                bytes32 tokenKey = getTokenKey(\\n                    tokensSelection_[i].collectionAddress,\\n                    tokensSelection_[i].tokens[j]\\n                );\\n\\n                require(tokenDataEncoded[tokenKey].owner == msg.sender);\\n                _claimLevelForToken(tokensSelection_[i].collectionAddress, tokensSelection_[i].tokens[j]);\\n            }\\n        }\\n    }\\n\\n    function _claimLevelForToken(address collection_, uint256 tokenId_) internal {\\n\\n        bytes32 tokenKey = getTokenKey(collection_, tokenId_);\\n        if (\\n            tokenDataEncoded[tokenKey].stakeType == TREE_HOUSE_STAKE ||\\n            tokenDataEncoded[tokenKey].stakeType == HOME_STAKE ||\\n            tokenDataEncoded[tokenKey].stakeType == 0\\n        ) {\\n            return;\\n        }\\n\\n        if (\\n            collection_ != contractsAddressesMap[\\\"gen0\\\"] &&\\n            collection_ != contractsAddressesMap[\\\"gen1\\\"]\\n        ) {\\n            return;\\n        }\\n\\n\\n        if (tokenDataEncoded[tokenKey].level != LEVEL_CAP) {\\n\\n            uint256 levelYield = (block.timestamp - tokenDataEncoded[tokenKey].levelEnrolDate) /\\n                (stakeTypeImpacts[tokenDataEncoded[tokenKey].stakeType].boost * 1 days);\\n\\n\\n            if (tokenDataEncoded[tokenKey].level + levelYield > LEVEL_CAP) {\\n                tokenDataEncoded[tokenKey].level = LEVEL_CAP;\\n            } else {\\n                tokenDataEncoded[tokenKey].level += levelYield;\\n            }\\n\\n            delete levelYield;\\n\\n            tokenDataEncoded[tokenKey].levelEnrolDate = block.timestamp;\\n        }\\n\\n        delete tokenKey;\\n    }\\n\\n    function isClaimSuccessful(\\n        address collection_,\\n        uint256 tokenId,\\n        uint256 amount_,\\n        uint256 stakeType_\\n    ) external returns (bool) {\\n\\n        uint256 risk;\\n\\n        bool isBearCollection =\\n            collection_ == contractsAddressesMap[\\\"gen0\\\"]\\n            || collection_ == contractsAddressesMap[\\\"gen1\\\"];\\n\\n        if (isBearCollection) {\\n            risk = BASE_RISK * 100;\\n\\n            for (uint256 j = levelMilestones.length - 1; j >= 0; --j) {\\n                if (tokenDataEncoded[getTokenKey(collection_, tokenId)].level >= levelMilestones[j]) {\\n                    risk -= levelImpacts[levelMilestones[j]].riskReduction;\\n                    break;\\n                }\\n            }\\n\\n            risk = risk / stakeTypeImpacts[stakeType_].riskReduction / 100;\\n\\n            risk = risk < 10 ? 10 : risk;\\n        } else {\\n            if (collection_ == contractsAddressesMap[\\\"tokenGenerator\\\"]) {\\n                risk = tokenGeneratorRisk;\\n            } else if (collection_ == contractsAddressesMap[\\\"treeHouse\\\"]) {\\n                risk = treeHouseRisk;\\n            }\\n        }\\n\\n        bool didLose = _didLoseClaimAmount(risk, tokenId, amount_);\\n        if (didLose) {\\n            bool winningFaction;\\n            if (isBearCollection) {\\n                winningFaction = !tokenDataEncoded[getTokenKey(collection_, tokenId)].faction;\\n            } else {\\n                winningFaction = _getFaction(tokenId);\\n            }\\n\\n            address winner = pickWinnerFromElites(\\n                winningFaction,\\n                tokenId\\n            );\\n\\n            if (winner != address(0)) {\\n                emit BLDStolen(winner, amount_);\\n                IToken(contractsAddressesMap[\\\"token\\\"]).add(winner, amount_);\\n            } else {\\n                didLose = false;\\n            }\\n        }\\n\\n        delete isBearCollection;\\n\\n        return !didLose;\\n    }\\n\\n    function _didLoseClaimAmount(uint256 risk_, uint256 tokenId_, uint256 amount_) internal view returns (bool) {\\n        return uint256(\\n            keccak256(\\n                abi.encodePacked(\\n                    seed,\\n                    tokenId_,\\n                    amount_,\\n                    tx.origin,\\n                    blockhash(block.number - 1),\\n                    block.timestamp)\\n            )\\n        ) % 100 < risk_;\\n    }\\n\\n    function pickWinnerFromElites(bool faction_, uint256 tokenId) public view returns (address) {\\n        if (faction_) {\\n            return _pickWinnerFromElitesBySide(blueElites, tokenId);\\n        } else {\\n            return _pickWinnerFromElitesBySide(redElites, tokenId);\\n        }\\n    }\\n\\n    function _pickWinnerFromElitesBySide(\\n        EnumerableSet.Bytes32Set storage elites_,\\n        uint256 tokenId\\n    ) internal view returns (address) {\\n\\n        if(elites_.length() == 0) {\\n            return address(0);\\n        }\\n\\n        uint256 index = _getRandom(elites_.length(), tokenId);\\n\\n        return tokenDataEncoded[elites_.at(index)].owner;\\n    }\\n\\n    function _getRandom(uint256 len, uint256 tokenId) internal view returns (uint256) {\\n        return uint256(\\n            keccak256(\\n                abi.encodePacked(\\n                    seed,\\n                    tokenId,\\n                    tx.origin,\\n                    blockhash(block.number - 1),\\n                    block.timestamp\\n                )\\n            )\\n        ) % len;\\n    }\\n\\n    function _getFaction(uint256 tokenId) internal view returns (bool) {\\n        return uint256(\\n            keccak256(\\n                abi.encodePacked(\\n                    seed,\\n                    tokenId,\\n                    tx.origin,\\n                    blockhash(block.number - 1),\\n                    block.timestamp\\n                )\\n            )\\n        ) & 1 == 1;\\n    }\\n\\n    function initSeedGeneration() public onlyOwner returns (bytes32 requestId) {\\n        require(LINK.balanceOf(address(this)) >= vrfFee, \\\"Not enough LINK\\\");\\n        return requestRandomness(vrfKeyHash, vrfFee);\\n    }\\n\\n    function fulfillRandomness(bytes32, uint256 randomness) internal override {\\n        seed = randomness;\\n        emit SeedFulfilled();\\n    }\\n\\n    function upgradeHouseSize(uint256 tokenId_, uint256 upgrade_) external {\\n\\n        require(tokenDataEncoded[getTokenKey(contractsAddressesMap[\\\"treeHouse\\\"], tokenId_)].level + upgrade_ <= HOUSE_CAP);\\n        require(tokenDataEncoded[getTokenKey(contractsAddressesMap[\\\"treeHouse\\\"], tokenId_)].owner == msg.sender);\\n        require(IToken(contractsAddressesMap[\\\"token\\\"]).getWalletBalance(msg.sender) >= houseUpgradeCost * upgrade_);\\n\\n        IToken(contractsAddressesMap[\\\"token\\\"]).spend(msg.sender, houseUpgradeCost * upgrade_);\\n\\n        tokenDataEncoded[getTokenKey(contractsAddressesMap[\\\"treeHouse\\\"], tokenId_)].level += upgrade_;\\n    }\\n\\n    function addLevel(address collection_, uint256 tokenId_, uint256 levelIncrease_) external authorised {\\n        tokenDataEncoded[getTokenKey(collection_, tokenId_)].level += levelIncrease_;\\n    }\\n\\n    function setLevel(address collection_, uint256 tokenId_, uint256 levelIncrease_) external authorised {\\n        tokenDataEncoded[getTokenKey(collection_, tokenId_)].level = levelIncrease_;\\n    }\\n\\n    function setEliteStatus(address collection_, uint256 tokenId_) external authorised {\\n\\n        bytes32 tokenKey = getTokenKey(collection_, tokenId_);\\n\\n        require(!tokenDataEncoded[tokenKey].isElite);\\n        require(tokenDataEncoded[tokenKey].stakeType == 0);\\n\\n        tokenDataEncoded[tokenKey].isElite = true;\\n\\n        delete tokenKey;\\n    }\\n\\n    function setHousesLevels(uint256[] calldata tokenIds_, uint256[] calldata levels_) external authorised {\\n        for (uint256 i = 0; i < tokenIds_.length; ++i) {\\n            tokenDataEncoded[getTokenKey(contractsAddressesMap[\\\"treeHouse\\\"], tokenIds_[i])].level = levels_[i];\\n        }\\n    }\\n\\n    function calculateLevels(\\n        address collection,\\n        uint256[] calldata tokenIds_\\n    ) external view returns (uint256[] memory) {\\n        uint256[] memory expectedLevels = new uint256[](tokenIds_.length);\\n\\n        for (uint256 i = 0; i < tokenIds_.length; ++i) {\\n            expectedLevels[i] = calculateLevel(collection, tokenIds_[i]);\\n        }\\n\\n        return expectedLevels;\\n    }\\n\\n    function calculateLevel(address collection_, uint256 tokenId_) public view returns (uint256) {\\n\\n        bytes32 tokenKey = getTokenKey(collection_, tokenId_);\\n\\n        if (\\n            tokenDataEncoded[tokenKey].stakeType == TREE_HOUSE_STAKE ||\\n            tokenDataEncoded[tokenKey].stakeType == HOME_STAKE ||\\n            tokenDataEncoded[tokenKey].stakeType == 0\\n        ) {\\n            return tokenDataEncoded[tokenKey].level;\\n        }\\n\\n        if (\\n            collection_ != contractsAddressesMap[\\\"gen0\\\"] &&\\n            collection_ != contractsAddressesMap[\\\"gen1\\\"]\\n        ) {\\n            return tokenDataEncoded[tokenKey].level;\\n        }\\n\\n        if (tokenDataEncoded[tokenKey].level == LEVEL_CAP) {\\n            return LEVEL_CAP;\\n        }\\n\\n        uint256 levelYield = (block.timestamp - tokenDataEncoded[tokenKey].levelEnrolDate) /\\n\\n        (stakeTypeImpacts[tokenDataEncoded[tokenKey].stakeType].boost * 1 days);\\n\\n\\n        if (tokenDataEncoded[tokenKey].level + levelYield > LEVEL_CAP) {\\n            return LEVEL_CAP;\\n        }\\n\\n        return tokenDataEncoded[tokenKey].level + levelYield;\\n    }\\n\\n    function setTokenGeneratorRisk(uint256 risk_) external onlyOwner {\\n        tokenGeneratorRisk = risk_;\\n    }\\n\\n    function setTreeHouseRisk(uint256 risk_) external onlyOwner {\\n        treeHouseRisk = risk_;\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vrfCoordinatorAddr_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"linkTokenAddr_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"vrfKeyHash_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"fee_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BLDStolen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SeedFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_RISK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOME_STAKE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOUSE_CAP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LEVEL_CAP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TREE_HOUSE_STAKE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelIncrease_\",\"type\":\"uint256\"}],\"name\":\"addLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorisedAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"calculateLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"calculateLevels\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"internalType\":\"struct GameStats.TokenSelection[]\",\"name\":\"tokensSelection_\",\"type\":\"tuple[]\"}],\"name\":\"claimLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"contractsAddressesMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"getLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getLevelBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"getLevelBoosts\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"getLevels\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"getTokenKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initSeedGeneration\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeType_\",\"type\":\"uint256\"}],\"name\":\"isClaimSuccessful\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelImpacts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"riskReduction\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelMilestones\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"faction_\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"pickWinnerFromElites\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses_\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"authorisations_\",\"type\":\"bool[]\"}],\"name\":\"setAuthorised\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"keys_\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"collections_\",\"type\":\"address[]\"}],\"name\":\"setCollectionsKeys\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"setEliteStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"houseUpgradeCost_\",\"type\":\"uint256\"}],\"name\":\"setHouseUpgradeCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"levels_\",\"type\":\"uint256[]\"}],\"name\":\"setHousesLevels\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelIncrease_\",\"type\":\"uint256\"}],\"name\":\"setLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"milestones_\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"riskReduction\",\"type\":\"uint256\"}],\"internalType\":\"struct GameStats.ImpactType[]\",\"name\":\"impacts_\",\"type\":\"tuple[]\"}],\"name\":\"setLevelImpacts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"stakeTypes_\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"riskReduction\",\"type\":\"uint256\"}],\"internalType\":\"struct GameStats.ImpactType[]\",\"name\":\"impacts_\",\"type\":\"tuple[]\"}],\"name\":\"setStakeTypeImpacts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeType_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"setStakedTokenData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"risk_\",\"type\":\"uint256\"}],\"name\":\"setTokenGeneratorRisk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"levels_\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"factions_\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"elites_\",\"type\":\"bool[]\"}],\"name\":\"setTokensData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"risk_\",\"type\":\"uint256\"}],\"name\":\"setTreeHouseRisk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeTypeImpacts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"riskReduction\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenGeneratorRisk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treeHouseRisk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"unsetStakedTokenData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upgrade_\",\"type\":\"uint256\"}],\"name\":\"upgradeHouseSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GameStats", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f0d54349addcf704f77ae15b96510dea15cb7952000000000000000000000000514910771af9ca656af840dff83e8264ecf986caaa77729d3466ca35ae8d28b3bbac7cc36a5031efdc430821c02bc31a238af4450000000000000000000000000000000000000000000000001bc16d674ec80000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}