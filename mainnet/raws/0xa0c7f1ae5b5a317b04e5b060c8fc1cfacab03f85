{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: IWhitelist.sol\r\n\r\n\r\n// Creator: OZ\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface IWhitelist {\r\n    function check(address addr) external view returns(bool);\r\n}\r\n\r\n// File: Errors.sol\r\n\r\n\r\n// Creator: OZ using Chiru Labs\r\n\r\npragma solidity ^0.8.4;\r\n\r\nerror ApprovalQueryForNonexistentToken();\r\nerror ApproveToCaller();\r\nerror ApprovalToCurrentOwner();\r\nerror AssetCannotBeTransfered();\r\nerror AssetLocked();\r\nerror AssetNotLocked();\r\nerror BalanceQueryForZeroAddress();\r\nerror BurnedQueryForZeroAddress();\r\nerror CallerNotOwnerNorApproved();\r\nerror Err();\r\nerror LackOfMoney();\r\nerror LockCallerNotOwnerNorApproved();\r\nerror MintShouldBeOpened();\r\nerror MintToZeroAddress();\r\nerror MintZeroQuantity();\r\nerror MintedQueryForZeroAddress();\r\nerror OutOfMintBoundaries();\r\nerror OwnerIndexOutOfBounds();\r\nerror OwnerQueryForNonexistentToken();\r\nerror RootAddressError();\r\nerror TokenIndexOutOfBounds();\r\nerror TransferCallerNotOwnerNorApproved();\r\nerror TransferFromIncorrectOwner();\r\nerror TransferToNonERC721ReceiverImplementer();\r\nerror TransferToZeroAddress();\r\nerror URIQueryForNonexistentToken();\r\nerror WhitelistedOnly();\r\n\r\n// File: @openzeppelin/contracts/utils/cryptography/MerkleProof.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Trees proofs.\r\n *\r\n * The proofs can be generated using the JavaScript library\r\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\r\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\r\n *\r\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = _efficientHash(computedHash, proofElement);\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = _efficientHash(proofElement, computedHash);\r\n            }\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\n// File: Strings.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * Libraries\r\n * Used https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol for Strings\r\n */\r\n\r\nlibrary Strings{\r\n\r\n    bytes16 private constant _HEXSYMBOLS = \"0123456789abcdef\";\r\n\r\n    function toString(address account) public pure returns(string memory) {\r\n        return toString(abi.encodePacked(account));\r\n    }\r\n\r\n    function toString(bytes32 value) public pure returns(string memory) {\r\n        return toString(abi.encodePacked(value));\r\n    }\r\n\r\n    function toString(bytes memory data) public pure returns(string memory) {\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(2 + data.length * 2);\r\n        str[0] = \"0\";\r\n        str[1] = \"x\";\r\n        for (uint i = 0; i < data.length; i++) {\r\n            str[2+i*2] = alphabet[uint(uint8(data[i] >> 4))];\r\n            str[3+i*2] = alphabet[uint(uint8(data[i] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    function toString(uint256 value) internal pure returns(string memory)\r\n    {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (0 == value) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (0 != temp) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (0 != value) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    function toHexString(uint256 value) internal pure returns(string memory)\r\n    {\r\n        if (0 == value) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (0 != temp) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value,length);\r\n    }\r\n\r\n    function toHexString(uint256 value,uint256 length) internal pure returns(string memory)\r\n    {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEXSYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0);\r\n        return string(buffer);\r\n    }\r\n    \r\n    function concat(string memory self, string memory other) internal pure returns(string memory)\r\n    {\r\n        return string(\r\n        abi.encodePacked(\r\n            self,\r\n            other\r\n        ));\r\n    }\r\n    \r\n}\r\n\r\n// File: TokenStorage.sol\r\n\r\n\r\n// Creator: OZ\r\n\r\npragma solidity ^0.8.4;\r\n\r\ncontract TokenStorage {\r\n\r\n    enum MintStatus {\r\n        NONE,\r\n        PRESALE,\r\n        SALE\r\n    }\r\n\r\n    // Compiler will pack this into a single 256bit word.\r\n    struct TokenOwnership {\r\n        // The address of the owner.\r\n        address addr;\r\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\r\n        uint64 startTimestamp;\r\n        // Whether the token has been burned.\r\n        bool burned;\r\n    }\r\n\r\n    // Compiler will pack this into a single 256bit word.\r\n    struct AddressData {\r\n        // Realistically, 2**64-1 is more than enough.\r\n        uint64 balance;\r\n        // Keeps track of mint count with minimal overhead for tokenomics.\r\n        uint64 numberMinted;\r\n        uint64 numberMintedOnPresale;\r\n        // Keeps track of burn count with minimal overhead for tokenomics.\r\n        uint64 numberBurned;\r\n    }\r\n\r\n    struct ContractData {\r\n        // Token name\r\n        string name;\r\n        // Token description\r\n        string description;\r\n        // Token symbol\r\n        string symbol;\r\n        // Base URL for tokens metadata\r\n        string baseURL;\r\n        // Contract-level metadata URL\r\n        string contractURL;\r\n        // Whitelist Merkle tree root\r\n        bytes32 wl;\r\n        // Is it set or asset?\r\n        bool isEnvelope;\r\n        // Revealed?\r\n        bool isRevealed;\r\n        // Mint status managed by\r\n        bool mintStatusAuto;\r\n        // Status\r\n        MintStatus mintStatus;\r\n    }\r\n\r\n    struct EnvelopeTypes {\r\n        address envelope;\r\n        address[] types;\r\n    }\r\n\r\n    struct MintSettings {\r\n        uint8 mintOnPresale;\r\n        uint8 maxMintPerUser;\r\n        uint8 minMintPerUser;\r\n        uint64 maxTokenSupply;\r\n        uint256 priceOnPresale;\r\n        uint256 priceOnSale;\r\n        uint256 envelopeConcatPrice;\r\n        uint256 envelopeSplitPrice;\r\n        // MintStatus timing\r\n        uint256 mintStatusPreale;\r\n        uint256 mintStatusSale;\r\n        uint256 mintStatusFinished;\r\n    }\r\n\r\n    // Contract root address\r\n    address internal _root;\r\n\r\n    // The tokenId of the next token to be minted.\r\n    uint256 internal _currentIndex;\r\n\r\n    // The number of tokens burned.\r\n    uint256 internal _burnCounter;\r\n\r\n    // Contract data\r\n    ContractData internal _contractData;\r\n\r\n    // Envelope data\r\n    EnvelopeTypes internal _envelopeTypes;\r\n\r\n    // Mint settings\r\n    MintSettings internal _mintSettings;\r\n\r\n    // Mapping from token ID to ownership details\r\n    // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.\r\n    mapping(uint256 => TokenOwnership) internal _ownerships;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) internal _tokenApprovals;\r\n\r\n    // Mapping owner address to address data\r\n    mapping(address => AddressData) internal _addressData;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\r\n\r\n    // Envelope container\r\n    mapping(uint256 => mapping(address => uint256)) internal _assetsEnvelope;\r\n    mapping(address => mapping(uint256 => bool)) internal _assetsEnveloped;\r\n\r\n}\r\n// File: IEnvelope.sol\r\n\r\n\r\n// Creator: OZ\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface IEnvelope {\r\n    function locked(address _asset,uint256 _assetId) external view returns(bool);\r\n    function ownerOfAsset(uint256 _assetId) external view returns(address);\r\n    }\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n    /**\r\n     * @dev Returns the total amount of tokens stored by the contract.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * Use along with {totalSupply} to enumerate all tokens.\r\n     */\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: Ownership.sol\r\n\r\n\r\n// Creator: OZ using Chiru Labs\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\n\r\ncontract Ownership is Context, TokenStorage {\r\n\r\n    /**\r\n     * Gas spent here starts off proportional to the maximum mint batch size.\r\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\r\n     */\r\n    function ownershipOf(uint256 tokenId)\r\n    internal view\r\n    returns (TokenOwnership memory)\r\n    {\r\n        uint256 curr = tokenId;\r\n\r\n        unchecked {\r\n            if (curr < _currentIndex) {\r\n                TokenOwnership memory ownership = _ownerships[curr];\r\n                if (!ownership.burned) {\r\n                    if (ownership.addr != address(0)) {\r\n                        return ownership;\r\n                    }\r\n                    // Invariant: \r\n                    // There will always be an ownership that has an address and is not burned \r\n                    // before an ownership that does not have an address and is not burned.\r\n                    // Hence, curr will not underflow.\r\n                    while (true) {\r\n                        curr--;\r\n                        ownership = _ownerships[curr];\r\n                        if (ownership.addr != address(0)) {\r\n                            return ownership;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        revert OwnerQueryForNonexistentToken();\r\n    }\r\n\r\n    uint256[] private __tokens__;\r\n\r\n    function tokensOf(address _owner)\r\n    external\r\n    returns(uint256[] memory tokens)\r\n    {\r\n        unchecked {\r\n            for(uint i=0;i<_currentIndex;i++) {\r\n                TokenOwnership memory ownership = ownershipOf(i);\r\n                if(ownership.addr == _owner) {\r\n                    if (!ownership.burned) {\r\n                        if(_contractData.isEnvelope) {\r\n                            __tokens__.push(i);\r\n                        } else {\r\n                            if(!IEnvelope(_envelopeTypes.envelope).locked(address(this),i)) {\r\n                                __tokens__.push(i);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return __tokens__;\r\n        }\r\n    }\r\n\r\n}\r\n// File: AccessControl.sol\r\n\r\n\r\n// Creator: OZ\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\ncontract AccessControl is Ownership {\r\n\r\n    function ActiveMint()\r\n    internal view\r\n    {\r\n        if(MintStatus.NONE == _contractData.mintStatus)\r\n            revert MintShouldBeOpened();\r\n    }\r\n\r\n    function ApprovedOnly(address owner)\r\n    internal view\r\n    {\r\n        if (!_operatorApprovals[owner][_msgSender()])\r\n            revert CallerNotOwnerNorApproved();\r\n    }\r\n\r\n    function BotProtection()\r\n    internal view\r\n    {\r\n        if(tx.origin != msg.sender)\r\n            revert Err();\r\n    }\r\n\r\n    function OwnerOnly(address owner,uint256 tokenId)\r\n    internal view\r\n    {\r\n        if (owner != ownershipOf(tokenId).addr)\r\n            revert CallerNotOwnerNorApproved();\r\n    }\r\n\r\n    function RootOnly()\r\n    internal view\r\n    {\r\n        address sender = _msgSender();\r\n        if(\r\n            sender != _root &&\r\n            sender != _envelopeTypes.envelope\r\n        ) revert RootAddressError();\r\n    }\r\n\r\n    function Whitelisted(bytes32[] calldata _merkleProof)\r\n    internal view\r\n    {\r\n        address sender = _msgSender();\r\n        bool flag =\r\n            _root == sender ||\r\n            _contractData.mintStatus == MintStatus.SALE\r\n        ;\r\n\r\n        /**\r\n         * Set merkle tree root\r\n         */\r\n        if(!flag)\r\n            flag = MerkleProof.verify(_merkleProof, _contractData.wl, keccak256(abi.encodePacked(sender)));\r\n\r\n        /**/\r\n        if(!flag)\r\n            revert WhitelistedOnly();\r\n    }\r\n\r\n    function setWLRoot(bytes32 _root)\r\n    external\r\n    {\r\n        RootOnly();\r\n\r\n        _contractData.wl = _root;\r\n    }\r\n\r\n}\r\n// File: Array.sol\r\n\r\n\r\n// Creator: OZ\r\n\r\npragma solidity ^0.8.4;\r\n\r\ncontract Array{\r\n\r\n    function remove(uint256[] memory arr, uint256 e)\r\n    internal pure\r\n    {\r\n        unchecked {\r\n            uint idx = 0;\r\n            for(uint i = 0; i < arr.length; i++) {\r\n                if(arr[i] == e) {\r\n                    idx = i;\r\n                }\r\n            }\r\n            for (uint i = idx; i < arr.length-1; i++){\r\n                arr[i] = arr[i+1];        \r\n            }\r\n            delete arr[arr.length - 1];\r\n        }\r\n    }\r\n    \r\n}\r\n// File: Math.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\nlibrary Math{\r\n\r\n    function max(uint256 a,uint256 b) internal pure returns(uint256)\r\n    {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min(uint256 a,uint256 b) internal pure returns(uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function average(uint256 a,uint256 b) internal pure returns(uint256)\r\n    {\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    function ceilDiv(uint256 a,uint256 b) internal pure returns(uint256)\r\n    {\r\n        return a / b + (a % b == 0 ? 0 : 1);\r\n    }\r\n\r\n    function mul(uint256 a,uint256 b) internal pure returns(uint256 c)\r\n    {\r\n        if (0 == a) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a,uint256 b) internal pure returns(uint256)\r\n    {\r\n        assert(0 != b);\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a,uint256 b) internal pure returns(uint256)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a,uint256 b) internal pure returns(uint256 c)\r\n    {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: Payment.sol\r\n\r\n\r\n// Creator: OZ\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\ncontract Payment is TokenStorage {\r\n\r\n    function lackOfMoney(uint _quantity)\r\n    internal\r\n    returns(bool)\r\n    {\r\n        return msg.value < Math.mul(_contractData.mintStatus == MintStatus.PRESALE ?\r\n        _mintSettings.priceOnPresale : _mintSettings.priceOnSale\r\n        ,_quantity);\r\n    }\r\n\r\n    function lackOfMoneyForConcat()\r\n    internal\r\n    returns(bool)\r\n    {\r\n        return\r\n            _mintSettings.envelopeConcatPrice != 0 &&\r\n            _mintSettings.envelopeConcatPrice > msg.value\r\n            ;\r\n    }\r\n\r\n    function lackOfMoneyForSplit()\r\n    internal\r\n    returns(bool)\r\n    {\r\n        return\r\n            _mintSettings.envelopeSplitPrice != 0 &&\r\n            _mintSettings.envelopeSplitPrice > msg.value\r\n            ;\r\n    }\r\n\r\n}\r\n// File: Quantity.sol\r\n\r\n\r\n// Creator: OZ\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\ncontract Quantity is TokenStorage {\r\n\r\n    function quantityIsGood(uint256 _quantity,uint256 _minted,uint256 _mintedOnPresale)\r\n    internal view\r\n    returns(bool)\r\n    {\r\n        return\r\n            (\r\n                _contractData.mintStatus == MintStatus.PRESALE &&\r\n                _mintSettings.mintOnPresale >= _quantity + _minted\r\n            ) || (\r\n                _contractData.mintStatus == MintStatus.SALE &&\r\n                _mintSettings.maxMintPerUser >= _quantity + _minted - _mintedOnPresale &&\r\n                _mintSettings.minMintPerUser <= _quantity\r\n            )\r\n            ;\r\n    }\r\n\r\n    function supplyIsGood()\r\n    internal view\r\n    returns(bool)\r\n    {\r\n        return\r\n            _contractData.isEnvelope || (\r\n                _contractData.isEnvelope == false &&\r\n                _mintSettings.maxTokenSupply > _currentIndex\r\n            )\r\n            ;\r\n    }\r\n\r\n}\r\n// File: ERC721A.sol\r\n\r\n\r\n// Creator: Chiru Labs\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//import \"hardhat/console.sol\";\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n * the Metadata extension. Built to optimize for lower gas during batch mints.\r\n *\r\n * Assumes serials are sequentially minted starting at 0 (e.g. 0, 1, 2, 3..).\r\n *\r\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\r\n *\r\n * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).\r\n */\r\nabstract contract ERC721A is Context, ERC165, IERC721, IERC721Metadata, AccessControl, Quantity {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory description_,\r\n        string memory symbol_,\r\n        string memory baseURL_,\r\n        string memory contractURL_\r\n    ) {\r\n        _contractData.name = name_;\r\n        _contractData.description = description_;\r\n        _contractData.symbol = symbol_;\r\n        _contractData.baseURL = baseURL_;\r\n        _contractData.contractURL = contractURL_;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-totalSupply}.\r\n     */\r\n    function totalSupply()\r\n    public view\r\n    returns(uint256)\r\n    {\r\n        // Counter underflow is impossible as _burnCounter cannot be incremented\r\n        // more than _currentIndex times\r\n        unchecked {\r\n            return _currentIndex - _burnCounter;    \r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n    public view virtual\r\n    override(ERC165, IERC165)\r\n    returns(bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner)\r\n    public view\r\n    override\r\n    returns(uint256)\r\n    {\r\n        if (owner == address(0))\r\n            revert BalanceQueryForZeroAddress();\r\n        return uint256(_addressData[owner].balance);\r\n    }\r\n\r\n    /**\r\n     * returnsthe number of tokens minted by `owner`.\r\n     */\r\n    function _numberMinted(address owner)\r\n    internal view\r\n    returns(uint256)\r\n    {\r\n        if (owner == address(0))\r\n            revert MintedQueryForZeroAddress();\r\n        else return\r\n            uint256(_addressData[owner].numberMinted);\r\n    }\r\n\r\n    function _numberMintedOnPresale(address owner)\r\n    internal view\r\n    returns(uint256)\r\n    {\r\n        if (owner == address(0))\r\n            revert MintedQueryForZeroAddress();\r\n        else return\r\n            uint256(_addressData[owner].numberMintedOnPresale);\r\n    }\r\n\r\n    /**\r\n     * returnsthe number of tokens burned by or on behalf of `owner`.\r\n     */\r\n    function _numberBurned(address owner)\r\n    internal view\r\n    returns(uint256)\r\n    {\r\n        if (owner == address(0))\r\n            revert BurnedQueryForZeroAddress();\r\n        else return\r\n            uint256(_addressData[owner].numberBurned);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId)\r\n    public view\r\n    override\r\n    returns(address)\r\n    {\r\n        if(!_contractData.isEnvelope) {\r\n            if(IEnvelope(_envelopeTypes.envelope).locked(address(this),tokenId)) {\r\n                return address(0);\r\n            }\r\n        }\r\n        return ownershipOf(tokenId).addr;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId)\r\n    public\r\n    override\r\n    {\r\n        address owner = ERC721A.ownerOf(tokenId);\r\n        if (to == owner)\r\n            revert ApprovalToCurrentOwner();\r\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender()))\r\n            revert CallerNotOwnerNorApproved();\r\n        _approve(to, tokenId, owner);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId)\r\n    public view\r\n    override\r\n    returns(address)\r\n    {\r\n        if (!_exists(tokenId))\r\n            revert ApprovalQueryForNonexistentToken();\r\n        else return\r\n            _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved)\r\n    public\r\n    override\r\n    {\r\n        if (operator == _msgSender())\r\n            revert ApproveToCaller();\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator)\r\n    public view virtual\r\n    override\r\n    returns(bool)\r\n    {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        if(!_contractData.isEnvelope)\r\n            if(IEnvelope(_envelopeTypes.envelope).locked(address(this),tokenId))\r\n                revert AssetLocked();\r\n                \r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, '');\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        if(!_contractData.isEnvelope)\r\n            if(IEnvelope(_envelopeTypes.envelope).locked(address(this),tokenId))\r\n                revert AssetLocked();\r\n\r\n        _transfer(from, to, tokenId);\r\n        if (!_checkOnERC721Received(from, to, tokenId, _data))\r\n            revert TransferToNonERC721ReceiverImplementer();\r\n    }\r\n\r\n    /**\r\n     * @dev returnswhether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     */\r\n    function _exists(uint256 tokenId)\r\n    internal view\r\n    returns(bool)\r\n    {\r\n        return tokenId < _currentIndex && !_ownerships[tokenId].burned;\r\n    }\r\n\r\n    function _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, '');\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\r\n     * - `quantity` must be greater than 0.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeMint(\r\n        address to,\r\n        uint256 quantity,\r\n        bytes memory _data\r\n    ) internal {\r\n        _mint(to, quantity, _data, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `quantity` tokens and transfers them to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `quantity` must be greater than 0.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(\r\n        address to,\r\n        uint256 quantity,\r\n        bytes memory _data,\r\n        bool safe\r\n    ) internal {\r\n        uint256 startTokenId = _currentIndex;\r\n        if(!supplyIsGood())\r\n            revert OutOfMintBoundaries();\r\n        if (to == address(0))\r\n            revert MintToZeroAddress();\r\n        if (quantity == 0)\r\n            revert MintZeroQuantity();\r\n\r\n        // Overflows are incredibly unrealistic.\r\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\r\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\r\n        unchecked {\r\n            _addressData[to].balance += uint64(quantity);\r\n            _addressData[to].numberMinted += uint64(quantity);\r\n            if(_contractData.mintStatus == MintStatus.PRESALE)\r\n                _addressData[to].numberMintedOnPresale = _addressData[to].numberMintedOnPresale + uint64(quantity);\r\n\r\n            _ownerships[startTokenId].addr = to;\r\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\r\n\r\n            uint256 updatedIndex = startTokenId;\r\n            for (uint256 i; i < quantity; i++) {\r\n                emit Transfer(address(0), to, updatedIndex);\r\n                if (safe && !_checkOnERC721Received(address(0), to, updatedIndex, _data))\r\n                    revert TransferToNonERC721ReceiverImplementer();\r\n                updatedIndex++;\r\n            }\r\n\r\n            _currentIndex = updatedIndex;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transfer set and all its assets\r\n     */\r\n    function _transferEnvelope(address _to,uint256 _assetId)\r\n    internal\r\n    {\r\n        unchecked {\r\n            for (uint i = 0; i < _envelopeTypes.types.length; i++) {\r\n                (bool success,bytes memory res) = _envelopeTypes.types[i].call(\r\n                    abi.encodeWithSignature(\"unlock(uint256,address)\",\r\n                        _assetsEnvelope[_assetId][_envelopeTypes.types[i]],\r\n                        _to)\r\n                );\r\n                if(!success)\r\n                    revert AssetCannotBeTransfered();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal {\r\n\r\n        TokenOwnership memory prevOwnership = ownershipOf(tokenId);\r\n        address sender = _msgSender();\r\n\r\n        bool isApprovedOrOwner = (\r\n            sender == _envelopeTypes.envelope ||\r\n            sender == prevOwnership.addr ||\r\n            sender == getApproved(tokenId) ||\r\n            isApprovedForAll(prevOwnership.addr, sender)\r\n        );\r\n\r\n        if (!isApprovedOrOwner)\r\n            revert TransferCallerNotOwnerNorApproved();\r\n        if (prevOwnership.addr != from)\r\n            revert TransferFromIncorrectOwner();\r\n        if (to == address(0))\r\n            revert TransferToZeroAddress();\r\n\r\n        /*\r\n        if(\r\n            sender == prevOwnership.addr &&\r\n            _contractData.isEnvelope\r\n        ) _transferEnvelope(to,tokenId);\r\n        */\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId, prevOwnership.addr);\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\r\n        unchecked {\r\n            _addressData[from].balance -= 1;\r\n            _addressData[to].balance += 1;\r\n\r\n            _ownerships[tokenId].addr = to;\r\n            _ownerships[tokenId].startTimestamp = uint64(block.timestamp);\r\n\r\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\r\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\r\n            uint256 nextTokenId = tokenId + 1;\r\n            if (_ownerships[nextTokenId].addr == address(0)) {\r\n                // This will suffice for checking _exists(nextTokenId),\r\n                // as a burned slot cannot contain the zero address.\r\n                if (nextTokenId < _currentIndex) {\r\n                    _ownerships[nextTokenId].addr = prevOwnership.addr;\r\n                    _ownerships[nextTokenId].startTimestamp = prevOwnership.startTimestamp;\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId)\r\n    internal virtual\r\n    {\r\n        TokenOwnership memory prevOwnership = ownershipOf(tokenId);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId, prevOwnership.addr);\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\r\n        unchecked {\r\n            _addressData[prevOwnership.addr].balance -= 1;\r\n            _addressData[prevOwnership.addr].numberBurned += 1;\r\n\r\n            // Keep track of who burned the token, and the timestamp of burning.\r\n            _ownerships[tokenId].addr = prevOwnership.addr;\r\n            _ownerships[tokenId].startTimestamp = uint64(block.timestamp);\r\n            _ownerships[tokenId].burned = true;\r\n\r\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\r\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\r\n            uint256 nextTokenId = tokenId + 1;\r\n            if (_ownerships[nextTokenId].addr == address(0)) {\r\n                // This will suffice for checking _exists(nextTokenId),\r\n                // as a burned slot cannot contain the zero address.\r\n                if (nextTokenId < _currentIndex) {\r\n                    _ownerships[nextTokenId].addr = prevOwnership.addr;\r\n                    _ownerships[nextTokenId].startTimestamp = prevOwnership.startTimestamp;\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(prevOwnership.addr, address(0), tokenId);\r\n\r\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\r\n        unchecked {\r\n            _burnCounter++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(\r\n        address to,\r\n        uint256 tokenId,\r\n        address owner\r\n    ) private {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns(bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns(bytes4 retval) {\r\n                return retval == IERC721Receiver(to).onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert TransferToNonERC721ReceiverImplementer();\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function getBalance()\r\n    external view\r\n    returns(uint256)\r\n    {\r\n        if(_root != _msgSender())\r\n            revert RootAddressError();\r\n        return address(this).balance;\r\n    }\r\n\r\n    function withdraw(address _to,uint256 _amount)\r\n    external\r\n    {\r\n        if(_root != _msgSender())\r\n            revert RootAddressError();\r\n        if(address(this).balance < _amount)\r\n            revert LackOfMoney();\r\n        payable(_to).transfer(_amount);\r\n    }\r\n\r\n}\r\n\r\n// File: ERC721AToken.sol\r\n\r\n\r\n// Creator: Chiru Labs & OZ\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721A Base Token\r\n * @dev ERC721A Token that can be irreversibly burned (destroyed).\r\n */\r\nabstract contract ERC721AToken is Context, Ownership, ERC721A {\r\n    using Strings for uint256;\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name()\r\n    external view virtual\r\n    override\r\n    returns(string memory)\r\n    {\r\n        return _contractData.name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol()\r\n    external view virtual\r\n    override\r\n    returns(string memory)\r\n    {\r\n        return _contractData.symbol;\r\n    }\r\n\r\n    function baseTokenURI()\r\n    external view\r\n    returns(string memory)\r\n    {\r\n        return _contractData.baseURL;\r\n    }\r\n  \r\n    function contractURI()\r\n    external view\r\n    returns(string memory)\r\n    {\r\n        return _contractData.contractURL;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId)\r\n    external view\r\n    override\r\n    returns(string memory)\r\n    {\r\n        if (!_exists(tokenId))\r\n            revert URIQueryForNonexistentToken();\r\n\r\n        return string(\r\n                abi.encodePacked(\r\n                    _contractData.baseURL,\r\n                    \"/\",\r\n                    Strings.toString(tokenId),\r\n                    \".json\"\r\n                ));\r\n    }\r\n\r\n    function decimals()\r\n    external pure\r\n    returns(uint8)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Burns `tokenId`. See {ERC721A-_burn}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own `tokenId` or be an approved operator.\r\n     */\r\n    function burn(uint256 tokenId)\r\n    internal\r\n    {\r\n        if(!_contractData.isEnvelope)\r\n            if(IEnvelope(_envelopeTypes.envelope).locked(address(this),tokenId))\r\n                revert AssetLocked();\r\n                \r\n        TokenOwnership memory prevOwnership = ownershipOf(tokenId);\r\n\r\n        bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr ||\r\n            isApprovedForAll(prevOwnership.addr, _msgSender()) ||\r\n            getApproved(tokenId) == _msgSender());\r\n\r\n        if (!isApprovedOrOwner)\r\n            revert TransferCallerNotOwnerNorApproved();\r\n\r\n        _burn(tokenId);\r\n    }\r\n\r\n}\r\n// File: IAsset.sol\r\n\r\n\r\n// Creator: OZ\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface IAsset {\r\n    function checkMint(address _owner,uint256 _quantity) external returns(uint256);\r\n    function locked(uint256 _assetId) external view returns(bool);\r\n    function ownerOfAsset(uint256 _assetId) external view returns(address);\r\n    }\r\n\r\n// File: ERC721AEnvelope.sol\r\n\r\n\r\n// Creator: OZ\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\n\r\n//import \"hardhat/console.sol\";\r\n\r\nabstract contract ERC721AEnvelope is Array, Context, ERC721AToken {\r\n    using Math for uint256;\r\n\r\n    function _mintSetOfAssets(address _owner,uint _quantity)\r\n    internal\r\n    {\r\n        unchecked {\r\n            for(uint i = 0; i < _envelopeTypes.types.length; i++) {\r\n                (bool success,bytes memory res) = _envelopeTypes.types[i].call(\r\n                    abi.encodeWithSignature(\"safeMint(address,uint256)\",\r\n                        _owner,\r\n                        _quantity\r\n                        )\r\n                );\r\n                if(!success)\r\n                    revert Err();\r\n            }\r\n        }\r\n    }\r\n\r\n    function _envelopeAssets(uint256 _envelopeId)\r\n    internal view\r\n    returns(address[] memory,uint256[] memory)\r\n    {\r\n        unchecked {\r\n            uint len = 0;\r\n            for (uint i = 0; i < _envelopeTypes.types.length; i++) {\r\n                len++;\r\n            }\r\n            address[] memory addrs = new address[](len);\r\n            uint256[] memory tokens = new uint256[](len);\r\n            len = 0;\r\n            for (uint i = 0; i < _envelopeTypes.types.length; i++) {\r\n                addrs[len] = _envelopeTypes.types[i];\r\n                tokens[len++] = _assetsEnvelope[_envelopeId][_envelopeTypes.types[i]];\r\n            }\r\n            return (addrs,tokens);\r\n        }\r\n    }\r\n\r\n    function _envelopeSplit(address _owner,uint256 _envelopeId)\r\n    internal\r\n    returns(address[] memory,uint256[] memory)\r\n    {\r\n        OwnerOnly(_owner,_envelopeId);\r\n\r\n        (address[] memory addrs,uint256[] memory tokens) = _envelopeAssets(_envelopeId);\r\n        _burn(_envelopeId);\r\n        _transferEnvelope(_owner,_envelopeId);\r\n        unchecked {\r\n            for(uint i = 0; i < addrs.length; i++) {\r\n                _unlockEnvelopeAsset(\r\n                        _envelopeId,\r\n                        addrs[i],\r\n                        tokens[i]\r\n                        );\r\n            }\r\n        }\r\n        return (addrs,tokens);\r\n    }\r\n\r\n    function _unlockEnvelopeAsset(uint256 _envelopeId,address _asset,uint256 _assetId)\r\n    internal\r\n    {\r\n        if(!_locked(_asset,_assetId))\r\n            revert AssetNotLocked();\r\n        if(_msgSender() != IAsset(_asset).ownerOfAsset(_assetId))\r\n            revert CallerNotOwnerNorApproved();\r\n\r\n        delete _assetsEnveloped[_asset][_assetId];\r\n        delete _assetsEnvelope[_envelopeId][_asset];\r\n    }\r\n\r\n    function _envelopeCreate(address _owner,address[] calldata _assets,uint256[] calldata _assetIds)\r\n    internal\r\n    returns(uint256)\r\n    {\r\n        if(\r\n            _assets.length == 0 &&\r\n            _assets.length != _assetIds.length\r\n        ) revert Err();\r\n\r\n        uint256 envelopeId = _currentIndex;\r\n        _safeMint(_owner,1);\r\n        unchecked {\r\n            _assetsEnvelope[envelopeId][_envelopeTypes.envelope] = envelopeId;\r\n            for(uint i = 0; i < _assets.length; i++) {\r\n                if(_locked(_assets[i],_assetIds[i]))\r\n                    revert AssetLocked();\r\n                if(_owner != IAsset(_assets[i]).ownerOfAsset(_assetIds[i]))\r\n                    revert CallerNotOwnerNorApproved();\r\n                _assetsEnvelope[envelopeId][_assets[i]] = _assetIds[i];\r\n                _assetsEnveloped[_assets[i]][_assetIds[i]] = true;\r\n            }\r\n        }\r\n        return envelopeId;\r\n    }\r\n\r\n    function _locked(address _asset,uint256 _assetId)\r\n    internal view\r\n    returns(bool)\r\n    {\r\n        if (_contractData.isEnvelope)\r\n            return _assetsEnveloped[_asset][_assetId];\r\n        else\r\n            return IAsset(_envelopeTypes.envelope).locked(_assetId);\r\n    }\r\n\r\n}\r\n\r\n// File: Master.sol\r\n\r\n\r\n// Creator: OZ\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\nabstract contract Master is ERC721AEnvelope {\r\n\r\n    constructor() {\r\n        _root = _msgSender();\r\n        _contractData.isRevealed = false;\r\n        _contractData.mintStatus = MintStatus.NONE;\r\n        _contractData.mintStatusAuto = true;\r\n        _mintSettings.mintOnPresale = 1; // number of tokens on presale\r\n        _mintSettings.maxMintPerUser = 2; // max tokens on sale\r\n        _mintSettings.minMintPerUser = 1; // min tokens on sale\r\n        _mintSettings.maxTokenSupply = 5000;\r\n        _mintSettings.priceOnPresale = 37500000000000000; // in wei, may be changed later\r\n        _mintSettings.priceOnSale = 47500000000000000; // in wei, may be changed later\r\n        _mintSettings.envelopeConcatPrice = 0; // in wei, may be changed later\r\n        _mintSettings.envelopeSplitPrice = 0; // in wei, may be changed later\r\n        _mintSettings.mintStatusPreale = 1649683800; // Monday, April 11, 2022 2:00:00 PM GMT\r\n        _mintSettings.mintStatusSale = 1649734200; // Tuesday, April 12, 2022 3:30:00 AM\r\n        _mintSettings.mintStatusFinished = 0; //does not specified\r\n    }\r\n\r\n    function exists(uint256 tokenId)\r\n    external view\r\n    returns(bool)\r\n    {\r\n        return _exists(tokenId);\r\n    }\r\n\r\n    function setRoot(address _owner)\r\n    external\r\n    {\r\n        RootOnly();\r\n        \r\n        _root = _owner;\r\n    }\r\n\r\n    function getRoot()\r\n    external view\r\n    returns(address)\r\n    {\r\n        return _root;\r\n    }\r\n\r\n    function CheckMintStatus()\r\n    internal\r\n    {\r\n        if(!_contractData.mintStatusAuto)\r\n            return;\r\n        \r\n        uint256 mps = _mintSettings.mintStatusPreale;\r\n        uint256 ms = _mintSettings.mintStatusSale;\r\n        uint256 mf = _mintSettings.mintStatusFinished;\r\n        if (mps <= block.timestamp && block.timestamp < ms) {\r\n            _contractData.mintStatus = MintStatus.PRESALE;\r\n        } else if (ms <= block.timestamp && (block.timestamp < mf || 0 == mf)) {\r\n            _contractData.mintStatus = MintStatus.SALE;\r\n        } else {\r\n            _contractData.mintStatus = MintStatus.NONE;\r\n        }\r\n    }\r\n\r\n    function toggleMintStatus(bool _mode)\r\n    external\r\n    {\r\n        RootOnly();\r\n\r\n        _contractData.mintStatusAuto = _mode;\r\n    }\r\n\r\n    function setMintingIsOnPresale()\r\n    external\r\n    {\r\n        RootOnly();\r\n\r\n        _contractData.mintStatus = MintStatus.PRESALE;\r\n    }\r\n    \r\n    function setMintingIsOnSale()\r\n    external\r\n    {\r\n        RootOnly();\r\n\r\n        _contractData.mintStatus = MintStatus.SALE;\r\n    }\r\n     \r\n    function stopMinting()\r\n    external\r\n    {\r\n        RootOnly();\r\n\r\n        _contractData.mintStatus = MintStatus.NONE;\r\n    }\r\n\r\n    function updateContract(\r\n        uint256 _pricePresale,\r\n        uint256 _priceSale,\r\n        uint8 _minMint,\r\n        uint8 _maxMint,\r\n        uint64 _maxSupply\r\n        )\r\n    external\r\n    {\r\n        RootOnly();\r\n\r\n        _mintSettings.priceOnPresale = _pricePresale;\r\n        _mintSettings.priceOnSale = _priceSale;\r\n        _mintSettings.maxMintPerUser = _maxMint;\r\n        _mintSettings.minMintPerUser = _minMint;\r\n        _mintSettings.maxTokenSupply = _maxSupply;\r\n    }\r\n\r\n    function setRevealed(string calldata _url)\r\n    external\r\n    {\r\n        RootOnly();\r\n\r\n        _contractData.isRevealed = true;\r\n        _contractData.baseURL = _url;\r\n    }\r\n\r\n    function updateBaseURL(string calldata _url)\r\n    external\r\n    {\r\n        RootOnly();\r\n\r\n        _contractData.baseURL = _url;\r\n    }\r\n\r\n}\r\n// File: Contract.sol\r\n\r\n\r\n// Creator: OZ\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\ncontract Contract is Master, Payment, IEnvelope {\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory description_,\r\n        string memory symbol_,\r\n        string memory baseURL_,\r\n        string memory contractURL_\r\n    ) ERC721A(\r\n        name_,\r\n        description_,\r\n        symbol_,\r\n        baseURL_,\r\n        contractURL_\r\n    ) Master() {\r\n        _contractData.isEnvelope = true;\r\n        //_contractData.wl = 0x7355b511eb06aa6d5a11b366b27ed407bc3237cf6e2eafe1799efef4a678756f;\r\n        _contractData.wl = 0xcdab47e163c1eb6040f36523ce1ddb86b732c6e652e159613a6e0b896d4f8232;\r\n    }\r\n\r\n    function addAssetType(address _asset)\r\n    external\r\n    {\r\n        RootOnly();\r\n\r\n        unchecked {\r\n            _envelopeTypes.types.push(_asset);\r\n        }\r\n    }\r\n\r\n    function setEnvelopeConcatPrice(uint256 _price)\r\n    external\r\n    {\r\n        RootOnly();\r\n\r\n        _mintSettings.envelopeConcatPrice = _price;\r\n    }\r\n\r\n    function setEnvelopeSplitPrice(uint256 _price)\r\n    external\r\n    {\r\n        RootOnly();\r\n\r\n        _mintSettings.envelopeSplitPrice = _price;\r\n    }\r\n\r\n    function addMint(uint _quantity)\r\n    external payable\r\n    returns(uint256)\r\n    {\r\n        BotProtection();\r\n        CheckMintStatus();\r\n        ActiveMint();\r\n\r\n        if(_contractData.mintStatus != MintStatus.SALE)\r\n            revert WhitelistedOnly();\r\n\r\n        //\r\n        if (lackOfMoney(_quantity * _envelopeTypes.types.length))\r\n            revert LackOfMoney();\r\n        else {\r\n            _mintSetOfAssets(_msgSender(), _quantity);\r\n            return _quantity;\r\n        }\r\n    }\r\n\r\n    function addMint(uint _quantity,bytes32[] calldata _merkleProof)\r\n    external payable\r\n    returns(uint256)\r\n    {\r\n        BotProtection();\r\n        CheckMintStatus();\r\n        ActiveMint();\r\n        Whitelisted(_merkleProof);\r\n\r\n        if (lackOfMoney(_quantity * _envelopeTypes.types.length))\r\n            revert LackOfMoney();\r\n        else {\r\n            _mintSetOfAssets(_msgSender(), _quantity);\r\n            return _quantity;\r\n        }\r\n    }\r\n\r\n    function addMint(address _owner,uint _quantity)\r\n    external\r\n    {\r\n        RootOnly();\r\n        CheckMintStatus();\r\n\r\n        _mintSetOfAssets(_owner, _quantity);\r\n    }\r\n\r\n    function envelopeCreate(address[] calldata _assets,uint256[] calldata _assetIds)\r\n    external payable \r\n    returns(uint256)\r\n    {\r\n        if(lackOfMoneyForConcat())\r\n            revert LackOfMoney();\r\n        else return\r\n            _envelopeCreate(_msgSender(),_assets, _assetIds);\r\n    }\r\n\r\n    function envelopeSplit(uint256 _envelopeId)\r\n    external payable\r\n    returns(address[] memory,uint256[] memory)\r\n    {\r\n        OwnerOnly(_msgSender(),_envelopeId);\r\n\r\n        if(lackOfMoneyForSplit())\r\n            revert LackOfMoney();\r\n        else return\r\n            _envelopeSplit(_msgSender(),_envelopeId);\r\n    }\r\n\r\n    function getAssetTypes()\r\n    external view\r\n    returns(address[] memory)\r\n    {\r\n        return _envelopeTypes.types;\r\n    }\r\n\r\n    function getEnvelopeAssets(uint256 _envelopeId)\r\n    external view\r\n    returns(address[] memory,uint256[] memory)\r\n    {\r\n        return _envelopeAssets(_envelopeId);\r\n    }\r\n\r\n    function locked(address _asset,uint256 _assetId)\r\n    external view\r\n    override\r\n    returns(bool)\r\n    {\r\n        return _assetsEnveloped[_asset][_assetId];\r\n    }\r\n\r\n    function ownerOfAsset(uint256 _assetId)\r\n    external view\r\n    override\r\n    returns(address)\r\n    {\r\n        return ownershipOf(_assetId).addr;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURL_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractURL_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalToCurrentOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveToCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AssetCannotBeTransfered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AssetLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AssetNotLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Err\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LackOfMoney\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintShouldBeOpened\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OutOfMintBoundaries\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootAddressError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WhitelistedOnly\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"addAssetType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"addMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"addMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"addMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_assetIds\",\"type\":\"uint256[]\"}],\"name\":\"envelopeCreate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_envelopeId\",\"type\":\"uint256\"}],\"name\":\"envelopeSplit\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAssetTypes\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_envelopeId\",\"type\":\"uint256\"}],\"name\":\"getEnvelopeAssets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRoot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"ownerOfAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setEnvelopeConcatPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setEnvelopeSplitPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setMintingIsOnPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setMintingIsOnSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"setRevealed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"setWLRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_mode\",\"type\":\"bool\"}],\"name\":\"toggleMintStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"updateBaseURL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pricePresale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceSale\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_minMint\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_maxMint\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"_maxSupply\",\"type\":\"uint64\"}],\"name\":\"updateContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Contract", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000841696c6f7365747300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000741494c4f53455400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007568747470733a2f2f636f6c6c656374696f6e2e61696c6f76657273652e636f6d2f73746f726167652f66696c65732f746f6b656e2f393938663666613136333339653839663263666437613861316662343431383231653831666230356236336638646264666339356362633339306138353135620000000000000000000000000000000000000000000000000000000000000000000000000000000000007d68747470733a2f2f636f6c6c656374696f6e2e61696c6f76657273652e636f6d2f73746f726167652f66696c65732f636f6e74726163742f393938663666613136333339653839663263666437613861316662343431383231653831666230356236336638646264666339356362633339306138353135622e6a736f6e000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9b9832035cbe2f11b3ae77aef04a8389d80b163e2966407e0e5e1cc172f43ea9"}]}