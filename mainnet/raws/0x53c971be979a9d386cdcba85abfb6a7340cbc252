{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n//////////////////////////////////////////////////\r\n//      ____               __  ___     __   __  //\r\n//     / __/__  ___  ______\\ \\/ (_)__ / /__/ /  //\r\n//    _\\ \\/ _ \\/ _ \\/ __/ -_)  / / -_) / _  /   //\r\n//   /___/ .__/\\___/_/  \\__//_/_/\\__/_/\\_,_/    //\r\n//      /_/                                     //\r\n//                        by 0xInuarashi.eth    //\r\n//////////////////////////////////////////////////\r\n\r\n// Open0x ECDSA \r\nlibrary ECDSA {\r\n\r\n    ///// Signer Address Recovery /////\r\n    \r\n    // In its pure form, address recovery requires the following parameters\r\n    // params: hash, v, r ,s\r\n\r\n    // First, we define some standard checks\r\n    function checkValidityOf_s(bytes32 s) public pure returns (bool) {\r\n        if (uint256(s) > \r\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            revert(\"recoverAddressFrom_hash_v_r_s: Invalid s value\");\r\n        }\r\n        return true;\r\n    }\r\n    function checkValidityOf_v(uint8 v) public pure returns (bool) {\r\n        if (v != 27 && v != 28) {\r\n            revert(\"recoverAddressFrom_hash_v_r_s: Invalid v value\");\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Then, we first define the pure form of recovery.\r\n    function recoverAddressFrom_hash_v_r_s(bytes32 hash, uint8 v, bytes32 r,\r\n    bytes32 s) public pure returns (address) {\r\n        // First, we need to make sure that s and v are in correct ranges\r\n        require(checkValidityOf_s(s) && checkValidityOf_v(v));\r\n\r\n        // call recovery using solidity's built-in ecrecover method\r\n        address _signer = ecrecover(hash, v, r, s);\r\n        \r\n        require(_signer != address(0),\r\n            \"_signer == address(0)\");\r\n\r\n        return _signer;\r\n    }\r\n\r\n    // There are also other ways to receive input without v, r, s values which\r\n    // you will need to parse the unsupported data to find v, r, s and then\r\n    // use those to call ecrecover.\r\n\r\n    // For these, there are 2 other methods:\r\n    // 1. params: hash, r, vs\r\n    // 2. params: hash, signature\r\n\r\n    // These then return the v, r, s values required to use recoverAddressFrom_hash_v_r_s\r\n\r\n    // So, we will parse the first method to get v, r, s\r\n    function get_v_r_s_from_r_vs(bytes32 r, bytes32 vs) public pure \r\n    returns (uint8, bytes32, bytes32) {\r\n        bytes32 s = vs & \r\n            bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        \r\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\r\n\r\n        return (v, r, s);\r\n    }\r\n\r\n    function get_v_r_s_from_signature(bytes memory signature) public pure \r\n    returns (uint8, bytes32, bytes32) {\r\n        // signature.length can be 64 and 65. this depends on the method\r\n        // the standard is 65 bytes1, eip-2098 is 64 bytes1.\r\n        // so, we need to account for these differences\r\n\r\n        // in the case that it is a standard 65 bytes1 signature\r\n        if (signature.length == 65) {\r\n            uint8 v;\r\n            bytes32 r;\r\n            bytes32 s;\r\n\r\n            // assembly magic\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n\r\n            // return the v, r, s \r\n            return (v, r, s);\r\n        }\r\n\r\n        // in the case that it is eip-2098 64 bytes1 signature\r\n        else if (signature.length == 64) {\r\n            bytes32 r;\r\n            bytes32 vs;\r\n\r\n            // assembly magic \r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                vs := mload(add(signature, 0x40))\r\n            }\r\n\r\n            return get_v_r_s_from_r_vs(r, vs);\r\n        }\r\n\r\n        else {\r\n            revert(\"Invalid signature length\");\r\n        }\r\n    }\r\n\r\n    // ///// Embedded toString /////\r\n\r\n    // // We need this in one of the methods of returning a signed message below.\r\n\r\n    // function _toString(uint256 value_) internal pure returns (string memory) {\r\n    //     if (value_ == 0) { return \"0\"; }\r\n    //     uint256 _iterate = value_; uint256 _digits;\r\n    //     while (_iterate != 0) { _digits++; _iterate /= 10; } // get digits in value_\r\n    //     bytes memory _buffer = new bytes(_digits);\r\n    //     while (value_ != 0) { _digits--; _buffer[_digits] = bytes1(uint8(\r\n    //         48 + uint256(value_ % 10 ))); value_ /= 10; } // create bytes of value_\r\n    //     return string(_buffer); // return string converted bytes of value_\r\n    // }\r\n\r\n    // ///// Generation of Hashes /////\r\n    \r\n    // // We need these methods because these methods are used to compare\r\n    // // hash generated off-chain to hash generated on-chain to cross-check the\r\n    // // validity of the signatures\r\n\r\n    // // 1. A bytes32 hash to generate a bytes32 hash embedded with prefix\r\n    // // 2. A bytes memory s to generate a bytes32 hash embedded with prefix\r\n    // // 3. A bytes32 domain seperator and bytes32 structhash to generate \r\n    // //      a bytes32 hash embedded with prefix\r\n\r\n    // // See: EIP-191\r\n    // function toEthSignedMessageHashBytes32(bytes32 hash) public pure \r\n    // returns (bytes32) {\r\n    //     return keccak256(abi.encodePacked(\r\n    //         // Magic prefix determined by the devs\r\n    //         \"\\x19Ethereum Signed Message:\\n32\",\r\n    //         hash\r\n    //     ));\r\n    // }\r\n\r\n    // // See: EIP-191\r\n    // function toEthSignedMessageHashBytes(bytes memory s) public pure\r\n    // returns (bytes32) {\r\n    //     return keccak256(abi.encodePacked(\r\n    //         // Another magic prefix determined by the devs\r\n    //         \"\\x19Ethereum Signed Message:\\n\", \r\n    //         // The bytes length of s\r\n    //         _toString(s.length),\r\n    //         // s itself\r\n    //         s\r\n    //     ));\r\n    // }\r\n\r\n    // // See: EIP-712\r\n    // function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) public\r\n    // pure returns (bytes32) {\r\n    //     return keccak256(abi.encodePacked(\r\n    //         // Yet another magic prefix determined by the devs\r\n    //         \"\\x19\\x01\",\r\n    //         // The domain seperator (EIP-712)\r\n    //         domainSeparator,\r\n    //         // struct hash\r\n    //         structHash\r\n    //     ));\r\n    // }\r\n}\r\n\r\nabstract contract Ownable {\r\n    address public owner; \r\n    constructor() { owner = msg.sender; }\r\n    modifier onlyOwner { require(owner == msg.sender, \"Not Owner!\"); _; }\r\n    function transferOwnership(address new_) external onlyOwner { owner = new_; }\r\n}\r\n\r\ninterface iSpore {\r\n    function transfer(address to_, uint256 amount_) external;\r\n    function mintAsController(address to_, uint256 amount_) external;\r\n}\r\n\r\ninterface iNFF {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address address_) external view returns (uint256);\r\n    function ownerOf(uint256 tokenId_) external view returns (address);\r\n    function walletOfOwner(address address_) external view returns (uint256[] memory);\r\n\r\n    function transferFrom(address from_, address to_, uint256 tokenId_) external;\r\n}\r\n\r\n\r\ncontract SporeYield is Ownable {\r\n\r\n    // Events\r\n    event Claim(address to_, uint256[] indexes_, uint256 totalClaimed);\r\n\r\n    // Interfaces\r\n    // NOTE: change this address (After spore token deployment)\r\n    iSpore public Spore = iSpore(0xD5E6d515b18004d0d4b2813078988cD67aDa6D7C); \r\n    function setSpore(address address_) external onlyOwner { \r\n        Spore = iSpore(address_); \r\n    }\r\n\r\n    iNFF public NFFGenerative = iNFF(0x90ee3Cf59FcDe2FE11838b9075Ea4681462362F1);\r\n    function setNFFGenerative(address address_) external onlyOwner {\r\n        NFFGenerative = iNFF(address_);\r\n    }\r\n\r\n    iNFF public NFFGenesis = iNFF(0x5f47079D0E45d95f5d5167A480B695883C4E47D9);\r\n    function setNFFGenesis(address address_) external onlyOwner {\r\n        NFFGenesis = iNFF(address_);\r\n    }\r\n\r\n    // // Constructor to set the contract addresses (optional)\r\n    // constructor(address spore, address generative, address genesis) Ownable() {\r\n    //     Spore = iSpore(spore);\r\n    //     NFFGenerative = iNFF(generative);\r\n    //     NFFGenesis = iNFF(genesis);\r\n    // }\r\n\r\n    // Times\r\n    uint256 public yieldStartTime = 1653264000; // May 23 2022 14:00:00 GMT+0000\r\n    uint256 public yieldEndTime = 1732060800; // November 20 2024 14:00:00 GMT+0000\r\n    function setYieldEndTime(uint256 yieldEndTime_) external onlyOwner { \r\n        yieldEndTime = yieldEndTime_; }\r\n\r\n    // Yield Info\r\n    mapping(uint256 => uint256) public indexToYield;\r\n    \r\n    // @dev this is a function to override yield setting. use it with caution.\r\n    function O_setIndexToYields(uint256[] calldata tokenIds_,\r\n    uint256[] calldata yields_) external onlyOwner {\r\n        require(tokenIds_.length == yields_.length,\r\n            \"Array lengths mismatch!\");\r\n        \r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            indexToYield[tokenIds_[i]] = yields_[i];\r\n        }\r\n    }\r\n\r\n    // Yield Database\r\n    mapping(uint256 => uint256) public indexToClaimedTimestamp;\r\n\r\n    // // Timestamp Controller (Optional)\r\n\r\n    // mapping(address => bool) public addressToTimestampControllers;\r\n\r\n    // // Timestamp Controllers can be given externally to other addresses \r\n    // // in order to modify the timestamp of mappings. \r\n    // // Only use if you know what you are doing. \r\n    // modifier onlyTimestampControllers {\r\n    //     require(addressToTimestampControllers[msg.sender],\r\n    //         \"Invalid timestamp controller!\");\r\n    //     _;\r\n    // }\r\n\r\n    // function controllerSetClaimTimestamps(uint256[] memory indexes_, \r\n    // uint256[] memory timestamps_) public onlyTimestampControllers {\r\n    //     for (uint256 i = 0; i < indexes_.length; i++) {\r\n    //         // The timestamp set must never be below the yieldStartTime\r\n    //         require(yieldStartTime <= timestamps_[i],\r\n    //             \"Timestamp set below yieldStartTime!\");\r\n\r\n    //         indexToClaimedTimestamp[indexes_[i]] = timestamps_[i];\r\n    //     }\r\n    // }\r\n    // ////\r\n\r\n    // Internal Calculators\r\n    function _getCurrentTimeOrEnded() public view returns (uint256) {\r\n        // Return block.timestamp if it's lower than yieldEndTime, otherwise\r\n        // return yieldEndTime instead.\r\n        return block.timestamp < yieldEndTime ?\r\n            block.timestamp : yieldEndTime;\r\n    }\r\n    function _getTimestampOfToken(uint256 index_) public view returns (uint256) {\r\n        // return indexToClaimedTimestamp[index_] == 0 ?\r\n\r\n        // Adjusted to yieldStartTime and hardcoded to save gas\r\n        return indexToClaimedTimestamp[index_] < 1653264000 ?\r\n            yieldStartTime : indexToClaimedTimestamp[index_];\r\n    }\r\n\r\n    // Yield Accountants\r\n    function getPendingTokens(uint256 index_) public view returns (uint256) {\r\n\r\n        // First, grab the timestamp of the token\r\n        uint256 _lastClaimedTimestamp = _getTimestampOfToken(index_);\r\n\r\n        // Then, we grab the current timestamp or ended\r\n        uint256 _timeCurrentOrEnded = _getCurrentTimeOrEnded();\r\n\r\n        // Lastly, we calculate the time-units in seconds of elapsed time\r\n        uint256 _timeElapsed = _timeCurrentOrEnded - _lastClaimedTimestamp;\r\n\r\n        // Now, return the calculation of yield\r\n        require(indexToYield[index_] != 0,\r\n            \"Yield Lookup not Initialized!\");\r\n        \r\n        return (_timeElapsed * indexToYield[index_]) / 1 days;\r\n    }\r\n    function getInitializedTokenYields(uint256[] memory indexes_) public\r\n    view returns (uint256[] memory) {\r\n        uint256[] memory _tokenYields = new uint256[](indexes_.length);\r\n        for (uint256 i = 0; i < indexes_.length; i++) {\r\n            _tokenYields[i] = indexToYield[indexes_[i]];\r\n        }\r\n        // Then, return the final value\r\n        return _tokenYields;\r\n    }\r\n    function getPendingTokensMany(uint256[] memory indexes_) public\r\n    view returns (uint256) {\r\n        // First, create an empty MSTORE to store the pending tokens tracker\r\n        uint256 _pendingTokens;\r\n        // Now, run a loop through the entire indexes array to add it\r\n        for (uint256 i = 0; i < indexes_.length; i++) {\r\n            _pendingTokens += getPendingTokens(indexes_[i]);\r\n        }\r\n\r\n        // Then, return the final value\r\n        return _pendingTokens;\r\n    }\r\n\r\n    function getPendingTokensWithUninitialized(uint256 index_, uint256 yieldRate_) public view returns (uint256) {\r\n\r\n        // First, grab the timestamp of the token\r\n        uint256 _lastClaimedTimestamp = _getTimestampOfToken(index_);\r\n\r\n        // Then, we grab the current timestamp or ended\r\n        uint256 _timeCurrentOrEnded = _getCurrentTimeOrEnded();\r\n\r\n        // Lastly, we calculate the time-units in seconds of elapsed time\r\n        uint256 _timeElapsed = _timeCurrentOrEnded - _lastClaimedTimestamp;\r\n\r\n        // Now, return the calculation of yield\r\n        return (_timeElapsed * yieldRate_) / 1 days;\r\n    }\r\n    function getPendingTokensManyWithUninitialized(uint256[] memory indexes_, uint256[] calldata yieldRates_) public\r\n    view returns (uint256) {\r\n        require(indexes_.length == yieldRates_.length);\r\n\r\n        // First, create an empty MSTORE to store the pending tokens tracker\r\n        uint256 _pendingTokens;\r\n\r\n        // Now, run a loop through the entire indexes array to add it\r\n        for (uint256 i = 0; i < indexes_.length; i++) {\r\n            _pendingTokens += getPendingTokensWithUninitialized(indexes_[i], yieldRates_[i]);\r\n        }\r\n\r\n        // Then, return the final value\r\n        return _pendingTokens;\r\n    }\r\n\r\n    // Internal Timekeepers\r\n    function _updateTimestampOfTokens(uint256[] memory indexes_) internal {\r\n        // Get the timestamp using internal function\r\n        uint256 _timeCurrentOrEnded = _getCurrentTimeOrEnded();\r\n        \r\n        // Loop through the entire indexes_ array and set the timestamps\r\n        for (uint256 i = 0; i < indexes_.length; i++) {\r\n            // Prevents duplicate setting of same token in the same block\r\n            require(indexToClaimedTimestamp[indexes_[i]] != _timeCurrentOrEnded,\r\n                \"Unable to set timestamp duplication in the same block!\");\r\n\r\n            indexToClaimedTimestamp[indexes_[i]] = _timeCurrentOrEnded;\r\n        }\r\n    }\r\n\r\n    function getIndexOfTokens(address[] memory contracts_,\r\n    uint256[] memory tokenIds_) public view returns (uint256[] memory) {\r\n\r\n        // Make sure the array lengths are equal\r\n        require(contracts_.length == tokenIds_.length,\r\n            \"getIndexOfTokens(): Array lengths mismatch!\");\r\n        \r\n        // MSTORE to save GAS\r\n        uint256 _items = tokenIds_.length;\r\n        address _NFFGenerativeAddress = address(NFFGenerative);\r\n        address _NFFGenesisAddress = address(NFFGenesis);\r\n\r\n        // Make sure all items are of supported contracts\r\n        for (uint256 i = 0; i < _items; i++) {\r\n            require(contracts_[i] == _NFFGenerativeAddress ||\r\n                contracts_[i] == _NFFGenesisAddress,\r\n                \"getIndexOfTokens(): Unsupported Contract!\");\r\n        }\r\n        \r\n        // MSTORE _indexes to return\r\n        uint256[] memory _indexes = new uint256[](_items);\r\n\r\n        // Generate the index array\r\n        for (uint256 i = 0; i < _items; i++) {\r\n            // Generate the offset. If generative, offeset is 10000, else, it's 0.\r\n            uint256 _offset = contracts_[i] == _NFFGenerativeAddress ? 0 : 10000;\r\n            _indexes[i] = tokenIds_[i] + _offset;\r\n        }\r\n\r\n        // Return the _indexes array\r\n        return _indexes;\r\n    }\r\n\r\n    function claim(uint256[] calldata tokenIds_) \r\n    public returns (uint256) {\r\n        // Make sure the sender owns all the tokens\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            if(tokenIds_[i] < 10000)\r\n            {\r\n                require(msg.sender == NFFGenerative.ownerOf(tokenIds_[i]),\r\n                    \"You do not own this token!\");\r\n            }\r\n            else\r\n            {\r\n                require(msg.sender == NFFGenesis.ownerOf(tokenIds_[i] - 10000),\r\n                    \"You do not own this token!\");\r\n            }\r\n        }\r\n\r\n        // Calculate the total pending tokens to be claimed from index array\r\n        uint256 _pendingTokens = getPendingTokensMany(tokenIds_);\r\n\r\n        // Set the new timestamp of the tokens\r\n        // @dev: this step will fail if duplicate tokenIds_ are passed in\r\n        _updateTimestampOfTokens(tokenIds_);\r\n\r\n        // Mint the total tokens for the msg.sender\r\n        Spore.mintAsController(msg.sender, _pendingTokens);\r\n\r\n        // Emit claim of total tokens\r\n        emit Claim(msg.sender, tokenIds_, _pendingTokens);\r\n\r\n        // Return the claim amount\r\n        return _pendingTokens;\r\n    }\r\n\r\n    // NOTE: change this to the correct spore data signer!\r\n    address public sporeDataSigner = 0xe4535f8EE9b374BBc2c5A57B35f09A89fe43a657; \r\n\r\n    function setSporeDataSigner(address address_) public onlyOwner {\r\n        sporeDataSigner = address_;\r\n    }\r\n\r\n    // Data initializer controllers\r\n    mapping(address => bool) public addressToYieldDataInitializers;\r\n\r\n    function setYieldDataInitializers(address[] calldata initializers_,\r\n    bool bool_) external onlyOwner {\r\n        for (uint256 i = 0; i < initializers_.length; i++) {\r\n            addressToYieldDataInitializers[initializers_[i]] = bool_;\r\n        }\r\n    }\r\n\r\n    modifier onlyYieldDataInitializer {\r\n        require(addressToYieldDataInitializers[msg.sender],\r\n            \"Invalid yield data initializer!\");\r\n        _;\r\n    }\r\n\r\n    function controllerInitializeYieldDatas(uint256[] memory indexes_, \r\n    uint256[] memory yieldDatas_, bytes[] memory signatures_) public \r\n    onlyYieldDataInitializer {\r\n        _initializeYieldDatas(indexes_, yieldDatas_, signatures_);\r\n    }\r\n    ////\r\n\r\n    // Core initialization logic\r\n    function _initializeYieldDatas(uint256[] memory indexes_, \r\n    uint256[] memory yieldDatas_, bytes[] memory signatures_) internal {\r\n        \r\n        // In order to effectively use this function, the index and yielddata\r\n        // array must be passed in as uninitialized-FIRST with signature\r\n        // length only in the amount of uninitialized yield datas.\r\n\r\n        // The function itself supports input of both uninitialized and initialized\r\n        // tokens based on signature length.\r\n        \r\n        // Make sure all the indexes to yieldDatas is valid through ECDSA \r\n        for (uint256 i = 0; i < signatures_.length; i++) {\r\n            // make sure the yieldDatas_[i] and signatures_[i] is correct\r\n            // thus we need to use get_v_r_s_from_signature function before\r\n            // address recovery\r\n            (uint8 v, bytes32 r, bytes32 s) = \r\n                ECDSA.get_v_r_s_from_signature(signatures_[i]);\r\n\r\n            // Create the token data hash to use with ecrecover\r\n            bytes32 _tokenDataHash = keccak256(abi.encodePacked(\r\n                indexes_[i],\r\n                yieldDatas_[i]\r\n            ));\r\n\r\n            require(sporeDataSigner == \r\n                ECDSA.recoverAddressFrom_hash_v_r_s(_tokenDataHash, v, r, s),\r\n                \"Invalid signer\");\r\n\r\n            // Initialize them if empty\r\n            if (indexToYield[indexes_[i]] == 0) { \r\n                // 10 Ether is the maximum per day as yield data is concerned.\r\n                // We added leeway for 20 Ether in case any future changes.\r\n                // We hardcoded this to save on gas.\r\n                require(20 ether >= yieldDatas_[i],\r\n                    \"Yield value not intended!\");\r\n                \r\n                indexToYield[indexes_[i]] = yieldDatas_[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    function claimWithInitializable(  \r\n    uint256[] calldata tokenIds_, uint256[] calldata yieldDatas_,\r\n    bytes[] calldata signatures_) external returns (uint256) {\r\n        require(tokenIds_.length >= yieldDatas_.length &&\r\n            tokenIds_.length >= signatures_.length,\r\n            \"Array Lengths Mismatch!\");\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            if(tokenIds_[i] < 10000)\r\n            {\r\n                require(msg.sender == NFFGenerative.ownerOf(tokenIds_[i]),\r\n                    \"You do not own this token!\");\r\n            }\r\n            else\r\n            {\r\n                require(msg.sender == NFFGenesis.ownerOf(tokenIds_[i] - 10000),\r\n                    \"You do not own this token!\");\r\n            }\r\n        }\r\n        // Initialize the Yield Datas\r\n        _initializeYieldDatas(tokenIds_, yieldDatas_, signatures_);\r\n\r\n        // Calculate the total pending tokens to be claimed from index array\r\n        // Without _initializeYieldDatas, this function would revert.\r\n        uint256 _pendingTokens = getPendingTokensMany(tokenIds_);\r\n\r\n        // Set the new timestamp of the tokens\r\n        // If there are duplicate indexes in the array, this function will revert.\r\n        _updateTimestampOfTokens(tokenIds_);\r\n\r\n        // Mint the total tokens for the msg.sender\r\n        Spore.mintAsController(msg.sender, _pendingTokens);\r\n\r\n        // Emit claim of total tokens\r\n        emit Claim(msg.sender, tokenIds_, _pendingTokens);\r\n\r\n        // Return token amount\r\n        return _pendingTokens;\r\n    }\r\n\r\n    // Public View Functions for Helpers\r\n    function walletOfGenesis(address address_) public view \r\n    returns (uint256[] memory) {\r\n        return NFFGenesis.walletOfOwner(address_);\r\n    }\r\n    function walletOfGenerative(address address_) public view \r\n    returns (uint256[] memory) {\r\n        return NFFGenerative.walletOfOwner(address_);\r\n    }\r\n\r\n    function walletIndexOfOwner(address address_) public view \r\n    returns (uint256[] memory) {\r\n        // For this function, we want to return a unified index \r\n        uint256 _genesisBalance = NFFGenesis.balanceOf(address_);\r\n        uint256 _generativeBalance = NFFGenerative.balanceOf(address_);\r\n        uint256 _totalBalance = _genesisBalance + _generativeBalance;\r\n        \r\n        // Create the indexes based on a combined balance to input datas\r\n        uint256[] memory _indexes = new uint256[] (_totalBalance);\r\n\r\n        // Call both wallet of owners\r\n        uint256[] memory _walletOfGenesis = walletOfGenesis(address_);\r\n        uint256[] memory _walletOfGenerative = walletOfGenerative(address_);\r\n\r\n        // Now start inserting into the index with both wallets with offsets\r\n        uint256 _currentIndex;\r\n        for (uint256 i = 0; i < _walletOfGenerative.length; i++) {\r\n            // Generative has an offset of 0\r\n            _indexes[_currentIndex++] = _walletOfGenerative[i];\r\n        }\r\n        for (uint256 i = 0; i < _walletOfGenesis.length; i++) {\r\n            // Genesis has an offset of 10000\r\n            _indexes[_currentIndex++] = _walletOfGenesis[i] + 10000;\r\n        }\r\n\r\n        return _indexes;\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"indexes_\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalClaimed\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NFFGenerative\",\"outputs\":[{\"internalType\":\"contract iNFF\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFFGenesis\",\"outputs\":[{\"internalType\":\"contract iNFF\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"yields_\",\"type\":\"uint256[]\"}],\"name\":\"O_setIndexToYields\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Spore\",\"outputs\":[{\"internalType\":\"contract iSpore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getCurrentTimeOrEnded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"}],\"name\":\"_getTimestampOfToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToYieldDataInitializers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"yieldDatas_\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures_\",\"type\":\"bytes[]\"}],\"name\":\"claimWithInitializable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"indexes_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"yieldDatas_\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures_\",\"type\":\"bytes[]\"}],\"name\":\"controllerInitializeYieldDatas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"getIndexOfTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"indexes_\",\"type\":\"uint256[]\"}],\"name\":\"getInitializedTokenYields\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"}],\"name\":\"getPendingTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"indexes_\",\"type\":\"uint256[]\"}],\"name\":\"getPendingTokensMany\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"indexes_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"yieldRates_\",\"type\":\"uint256[]\"}],\"name\":\"getPendingTokensManyWithUninitialized\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yieldRate_\",\"type\":\"uint256\"}],\"name\":\"getPendingTokensWithUninitialized\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"indexToClaimedTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"indexToYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"setNFFGenerative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"setNFFGenesis\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"setSpore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"setSporeDataSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"initializers_\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"bool_\",\"type\":\"bool\"}],\"name\":\"setYieldDataInitializers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"yieldEndTime_\",\"type\":\"uint256\"}],\"name\":\"setYieldEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sporeDataSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"walletIndexOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"walletOfGenerative\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"walletOfGenesis\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SporeYield", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "ECDSA:677e66ead8e9572a841dc54b0a3c69160ed8efa4", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7f44bb1094f778fa42c836ffc8e553319d1dbfe7983059cea318b512065fedc5"}]}