{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0\r\n\r\n    pragma solidity ^0.8.11;\r\n\r\n    /// @title ClonesWithImmutableArgs\r\n    /// @author wighawag, zefram.eth\r\n    /// @notice Enables creating clone contracts with immutable args\r\n    library ClonesWithImmutableArgs {\r\n        error CreateFail();\r\n\r\n        /// @notice Creates a clone proxy of the implementation contract, with immutable args\r\n        /// @dev data cannot exceed 65535 bytes, since 2 bytes are used to store the data length\r\n        /// @param implementation The implementation contract to clone\r\n        /// @param data Encoded immutable args\r\n        /// @return instance The address of the created clone\r\n        function clone(address implementation, bytes memory data)\r\n            internal\r\n            returns (address instance)\r\n        {\r\n            // unrealistic for memory ptr or data length to exceed 256 bits\r\n            unchecked {\r\n                uint256 extraLength = data.length + 2; // +2 bytes for telling how much data there is appended to the call\r\n                uint256 creationSize = 0x43 + extraLength;\r\n                uint256 runSize = creationSize - 11;\r\n                uint256 dataPtr;\r\n                uint256 ptr;\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    ptr := mload(0x40)\r\n\r\n                    // -------------------------------------------------------------------------------------------------------------\r\n                    // CREATION (11 bytes)\r\n                    // -------------------------------------------------------------------------------------------------------------\r\n\r\n                    // 3d          | RETURNDATASIZE        | 0                       | \u2013\r\n                    // 61 runtime  | PUSH2 runtime (r)     | r 0                     | \u2013\r\n                    mstore(\r\n                        ptr,\r\n                        0x3d61000000000000000000000000000000000000000000000000000000000000\r\n                    )\r\n                    mstore(add(ptr, 0x02), shl(240, runSize)) // size of the contract running bytecode (16 bits)\r\n\r\n                    // creation size = 0b\r\n                    // 80          | DUP1                  | r r 0                   | \u2013\r\n                    // 60 creation | PUSH1 creation (c)    | c r r 0                 | \u2013\r\n                    // 3d          | RETURNDATASIZE        | 0 c r r 0               | \u2013\r\n                    // 39          | CODECOPY              | r 0                     | [0-2d]: runtime code\r\n                    // 81          | DUP2                  | 0 c  0                  | [0-2d]: runtime code\r\n                    // f3          | RETURN                | 0                       | [0-2d]: runtime code\r\n                    mstore(\r\n                        add(ptr, 0x04),\r\n                        0x80600b3d3981f300000000000000000000000000000000000000000000000000\r\n                    )\r\n\r\n                    // -------------------------------------------------------------------------------------------------------------\r\n                    // RUNTIME\r\n                    // -------------------------------------------------------------------------------------------------------------\r\n\r\n                    // 36          | CALLDATASIZE          | cds                     | \u2013\r\n                    // 3d          | RETURNDATASIZE        | 0 cds                   | \u2013\r\n                    // 3d          | RETURNDATASIZE        | 0 0 cds                 | \u2013\r\n                    // 37          | CALLDATACOPY          | \u2013                       | [0, cds] = calldata\r\n                    // 61          | PUSH2 extra           | extra                   | [0, cds] = calldata\r\n                    mstore(\r\n                        add(ptr, 0x0b),\r\n                        0x363d3d3761000000000000000000000000000000000000000000000000000000\r\n                    )\r\n                    mstore(add(ptr, 0x10), shl(240, extraLength))\r\n\r\n                    // 60 0x38     | PUSH1 0x38            | 0x38 extra              | [0, cds] = calldata // 0x38 (56) is runtime size - data\r\n                    // 36          | CALLDATASIZE          | cds 0x38 extra          | [0, cds] = calldata\r\n                    // 39          | CODECOPY              | _                       | [0, cds] = calldata\r\n                    // 3d          | RETURNDATASIZE        | 0                       | [0, cds] = calldata\r\n                    // 3d          | RETURNDATASIZE        | 0 0                     | [0, cds] = calldata\r\n                    // 3d          | RETURNDATASIZE        | 0 0 0                   | [0, cds] = calldata\r\n                    // 36          | CALLDATASIZE          | cds 0 0 0               | [0, cds] = calldata\r\n                    // 61 extra    | PUSH2 extra           | extra cds 0 0 0         | [0, cds] = calldata\r\n                    mstore(\r\n                        add(ptr, 0x12),\r\n                        0x603836393d3d3d36610000000000000000000000000000000000000000000000\r\n                    )\r\n                    mstore(add(ptr, 0x1b), shl(240, extraLength))\r\n\r\n                    // 01          | ADD                   | cds+extra 0 0 0         | [0, cds] = calldata\r\n                    // 3d          | RETURNDATASIZE        | 0 cds 0 0 0             | [0, cds] = calldata\r\n                    // 73 addr     | PUSH20 0x123\u2026         | addr 0 cds 0 0 0        | [0, cds] = calldata\r\n                    mstore(\r\n                        add(ptr, 0x1d),\r\n                        0x013d730000000000000000000000000000000000000000000000000000000000\r\n                    )\r\n                    mstore(add(ptr, 0x20), shl(0x60, implementation))\r\n\r\n                    // 5a          | GAS                   | gas addr 0 cds 0 0 0    | [0, cds] = calldata\r\n                    // f4          | DELEGATECALL          | success 0               | [0, cds] = calldata\r\n                    // 3d          | RETURNDATASIZE        | rds success 0           | [0, cds] = calldata\r\n                    // 82          | DUP3                  | 0 rds success 0         | [0, cds] = calldata\r\n                    // 80          | DUP1                  | 0 0 rds success 0       | [0, cds] = calldata\r\n                    // 3e          | RETURNDATACOPY        | success 0               | [0, rds] = return data (there might be some irrelevant leftovers in memory [rds, cds] when rds < cds)\r\n                    // 90          | SWAP1                 | 0 success               | [0, rds] = return data\r\n                    // 3d          | RETURNDATASIZE        | rds 0 success           | [0, rds] = return data\r\n                    // 91          | SWAP2                 | success 0 rds           | [0, rds] = return data\r\n                    // 60 0x36     | PUSH1 0x36            | 0x36 sucess 0 rds       | [0, rds] = return data\r\n                    // 57          | JUMPI                 | 0 rds                   | [0, rds] = return data\r\n                    // fd          | REVERT                | \u2013                       | [0, rds] = return data\r\n                    // 5b          | JUMPDEST              | 0 rds                   | [0, rds] = return data\r\n                    // f3          | RETURN                | \u2013                       | [0, rds] = return data\r\n\r\n                    mstore(\r\n                        add(ptr, 0x34),\r\n                        0x5af43d82803e903d91603657fd5bf30000000000000000000000000000000000\r\n                    )\r\n                }\r\n\r\n                // -------------------------------------------------------------------------------------------------------------\r\n                // APPENDED DATA (Accessible from extcodecopy)\r\n                // (but also send as appended data to the delegatecall)\r\n                // -------------------------------------------------------------------------------------------------------------\r\n\r\n                extraLength -= 2;\r\n                uint256 counter = extraLength;\r\n                uint256 copyPtr = ptr + 0x43;\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    dataPtr := add(data, 32)\r\n                }\r\n                for (; counter >= 32; counter -= 32) {\r\n                    // solhint-disable-next-line no-inline-assembly\r\n                    assembly {\r\n                        mstore(copyPtr, mload(dataPtr))\r\n                    }\r\n\r\n                    copyPtr += 32;\r\n                    dataPtr += 32;\r\n                }\r\n                uint256 mask = ~(256**(32 - counter) - 1);\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    mstore(copyPtr, and(mload(dataPtr), mask))\r\n                }\r\n                copyPtr += counter;\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    mstore(copyPtr, shl(240, extraLength))\r\n                }\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    instance := create(0, ptr, creationSize)\r\n                }\r\n                if (instance == address(0)) {\r\n                    revert CreateFail();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /// @title Clone\r\n    /// @author zefram.eth\r\n    /// @notice Provides helper functions for reading immutable args from calldata\r\n    contract Clone {\r\n        /// @notice Reads an immutable arg with type address\r\n        /// @param argOffset The offset of the arg in the packed data\r\n        /// @return arg The arg value\r\n        function _getArgAddress(uint256 argOffset)\r\n            internal\r\n            pure\r\n            returns (address arg)\r\n        {\r\n            uint256 offset = _getImmutableArgsOffset();\r\n            assembly {\r\n                arg := shr(0x60, calldataload(add(offset, argOffset)))\r\n            }\r\n        }\r\n\r\n        /// @notice Reads an immutable arg with type uint256\r\n        /// @param argOffset The offset of the arg in the packed data\r\n        /// @return arg The arg value\r\n        function _getArgUint256(uint256 argOffset)\r\n            internal\r\n            pure\r\n            returns (uint256 arg)\r\n        {\r\n            uint256 offset = _getImmutableArgsOffset();\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                arg := calldataload(add(offset, argOffset))\r\n            }\r\n        }\r\n\r\n        /// @notice Reads an immutable arg with type uint64\r\n        /// @param argOffset The offset of the arg in the packed data\r\n        /// @return arg The arg value\r\n        function _getArgUint64(uint256 argOffset)\r\n            internal\r\n            pure\r\n            returns (uint64 arg)\r\n        {\r\n            uint256 offset = _getImmutableArgsOffset();\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                arg := shr(0xc0, calldataload(add(offset, argOffset)))\r\n            }\r\n        }\r\n\r\n        /// @notice Reads an immutable arg with type uint8\r\n        /// @param argOffset The offset of the arg in the packed data\r\n        /// @return arg The arg value\r\n        function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\r\n            uint256 offset = _getImmutableArgsOffset();\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                arg := shr(0xf8, calldataload(add(offset, argOffset)))\r\n            }\r\n        }\r\n\r\n        /// @return offset The offset of the packed immutable args in calldata\r\n        function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                offset := sub(\r\n                    calldatasize(),\r\n                    add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n    /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\r\n    /// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n    /// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\n    abstract contract ERC20Clone is Clone {\r\n        /*///////////////////////////////////////////////////////////////\r\n                                    EVENTS\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n        event Approval(\r\n            address indexed owner,\r\n            address indexed spender,\r\n            uint256 amount\r\n        );\r\n\r\n        /*///////////////////////////////////////////////////////////////\r\n                                ERC20 STORAGE\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        uint256 public totalSupply;\r\n\r\n        mapping(address => uint256) public balanceOf;\r\n\r\n        mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n        /*///////////////////////////////////////////////////////////////\r\n                                METADATA\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        function name() external pure returns (string memory) {\r\n            return string(abi.encodePacked(_getArgUint256(0)));\r\n        }\r\n\r\n        function symbol() external pure returns (string memory) {\r\n            return string(abi.encodePacked(_getArgUint256(0x20)));\r\n        }\r\n\r\n        function decimals() external pure returns (uint8) {\r\n            return _getArgUint8(0x40);\r\n        }\r\n\r\n        /*///////////////////////////////////////////////////////////////\r\n                                ERC20 LOGIC\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        function approve(address spender, uint256 amount)\r\n            public\r\n            virtual\r\n            returns (bool)\r\n        {\r\n            allowance[msg.sender][spender] = amount;\r\n\r\n            emit Approval(msg.sender, spender, amount);\r\n\r\n            return true;\r\n        }\r\n\r\n        function transfer(address to, uint256 amount)\r\n            public\r\n            virtual\r\n            returns (bool)\r\n        {\r\n            balanceOf[msg.sender] -= amount;\r\n\r\n            // Cannot overflow because the sum of all user\r\n            // balances can't exceed the max uint256 value.\r\n            unchecked {\r\n                balanceOf[to] += amount;\r\n            }\r\n\r\n            emit Transfer(msg.sender, to, amount);\r\n\r\n            return true;\r\n        }\r\n\r\n        function transferFrom(\r\n            address from,\r\n            address to,\r\n            uint256 amount\r\n        ) public virtual returns (bool) {\r\n            uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n            if (allowed != type(uint256).max)\r\n                allowance[from][msg.sender] = allowed - amount;\r\n\r\n            balanceOf[from] -= amount;\r\n\r\n            // Cannot overflow because the sum of all user\r\n            // balances can't exceed the max uint256 value.\r\n            unchecked {\r\n                balanceOf[to] += amount;\r\n            }\r\n\r\n            emit Transfer(from, to, amount);\r\n\r\n            return true;\r\n        }\r\n\r\n        /*///////////////////////////////////////////////////////////////\r\n                        INTERNAL LOGIC\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        function _mint(address to, uint256 amount) internal virtual {\r\n            totalSupply += amount;\r\n\r\n            // Cannot overflow because the sum of all user\r\n            // balances can't exceed the max uint256 value.\r\n            unchecked {\r\n                balanceOf[to] += amount;\r\n            }\r\n\r\n            emit Transfer(address(0), to, amount);\r\n        }\r\n\r\n        function _burn(address from, uint256 amount) internal virtual {\r\n            balanceOf[from] -= amount;\r\n\r\n            // Cannot underflow because a user's balance\r\n            // will never be larger than the total supply.\r\n            unchecked {\r\n                totalSupply -= amount;\r\n            }\r\n\r\n            emit Transfer(from, address(0), amount);\r\n        }\r\n\r\n        function _getImmutableVariablesOffset()\r\n            internal\r\n            pure\r\n            returns (uint256 offset)\r\n        {\r\n            assembly {\r\n                offset := sub(\r\n                    calldatasize(),\r\n                    add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n    /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\r\n    /// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n    /// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\n    abstract contract ERC20 {\r\n        /*///////////////////////////////////////////////////////////////\r\n                                    EVENTS\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n        event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n        /*///////////////////////////////////////////////////////////////\r\n                                METADATA STORAGE\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        string public name;\r\n\r\n        string public symbol;\r\n\r\n        uint8 public immutable decimals;\r\n\r\n        /*///////////////////////////////////////////////////////////////\r\n                                ERC20 STORAGE\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        uint256 public totalSupply;\r\n\r\n        mapping(address => uint256) public balanceOf;\r\n\r\n        mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n        /*///////////////////////////////////////////////////////////////\r\n                                EIP-2612 STORAGE\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        bytes32 public constant PERMIT_TYPEHASH =\r\n            keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\r\n        uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n        bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n        mapping(address => uint256) public nonces;\r\n\r\n        /*///////////////////////////////////////////////////////////////\r\n                                CONSTRUCTOR\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        constructor(\r\n            string memory _name,\r\n            string memory _symbol,\r\n            uint8 _decimals\r\n        ) {\r\n            name = _name;\r\n            symbol = _symbol;\r\n            decimals = _decimals;\r\n\r\n            INITIAL_CHAIN_ID = block.chainid;\r\n            INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n        }\r\n\r\n        /*///////////////////////////////////////////////////////////////\r\n                                ERC20 LOGIC\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n            allowance[msg.sender][spender] = amount;\r\n\r\n            emit Approval(msg.sender, spender, amount);\r\n\r\n            return true;\r\n        }\r\n\r\n        function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n            balanceOf[msg.sender] -= amount;\r\n\r\n            // Cannot overflow because the sum of all user\r\n            // balances can't exceed the max uint256 value.\r\n            unchecked {\r\n                balanceOf[to] += amount;\r\n            }\r\n\r\n            emit Transfer(msg.sender, to, amount);\r\n\r\n            return true;\r\n        }\r\n\r\n        function transferFrom(\r\n            address from,\r\n            address to,\r\n            uint256 amount\r\n        ) public virtual returns (bool) {\r\n            uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n            if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n\r\n            balanceOf[from] -= amount;\r\n\r\n            // Cannot overflow because the sum of all user\r\n            // balances can't exceed the max uint256 value.\r\n            unchecked {\r\n                balanceOf[to] += amount;\r\n            }\r\n\r\n            emit Transfer(from, to, amount);\r\n\r\n            return true;\r\n        }\r\n\r\n        /*///////////////////////////////////////////////////////////////\r\n                                EIP-2612 LOGIC\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        function permit(\r\n            address owner,\r\n            address spender,\r\n            uint256 value,\r\n            uint256 deadline,\r\n            uint8 v,\r\n            bytes32 r,\r\n            bytes32 s\r\n        ) public virtual {\r\n            require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n            // Unchecked because the only math done is incrementing\r\n            // the owner's nonce which cannot realistically overflow.\r\n            unchecked {\r\n                bytes32 digest = keccak256(\r\n                    abi.encodePacked(\r\n                        \"\\x19\\x01\",\r\n                        DOMAIN_SEPARATOR(),\r\n                        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n                    )\r\n                );\r\n\r\n                address recoveredAddress = ecrecover(digest, v, r, s);\r\n\r\n                require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n\r\n                allowance[recoveredAddress][spender] = value;\r\n            }\r\n\r\n            emit Approval(owner, spender, value);\r\n        }\r\n\r\n        function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n            return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n        }\r\n\r\n        function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n            return\r\n                keccak256(\r\n                    abi.encode(\r\n                        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                        keccak256(bytes(name)),\r\n                        keccak256(\"1\"),\r\n                        block.chainid,\r\n                        address(this)\r\n                    )\r\n                );\r\n        }\r\n\r\n        /*///////////////////////////////////////////////////////////////\r\n                        INTERNAL MINT/BURN LOGIC\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        function _mint(address to, uint256 amount) internal virtual {\r\n            totalSupply += amount;\r\n\r\n            // Cannot overflow because the sum of all user\r\n            // balances can't exceed the max uint256 value.\r\n            unchecked {\r\n                balanceOf[to] += amount;\r\n            }\r\n\r\n            emit Transfer(address(0), to, amount);\r\n        }\r\n\r\n        function _burn(address from, uint256 amount) internal virtual {\r\n            balanceOf[from] -= amount;\r\n\r\n            // Cannot underflow because a user's balance\r\n            // will never be larger than the total supply.\r\n            unchecked {\r\n                totalSupply -= amount;\r\n            }\r\n\r\n            emit Transfer(from, address(0), amount);\r\n        }\r\n    }\r\n\r\n\r\n    /// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\r\n    /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n    /// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\r\n    /// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\n    library SafeTransferLib {\r\n        /*///////////////////////////////////////////////////////////////\r\n                                ETH OPERATIONS\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        function safeTransferETH(address to, uint256 amount) internal {\r\n            bool callStatus;\r\n\r\n            assembly {\r\n                // Transfer the ETH and store if it succeeded or not.\r\n                callStatus := call(gas(), to, amount, 0, 0, 0, 0)\r\n            }\r\n\r\n            require(callStatus, \"ETH_TRANSFER_FAILED\");\r\n        }\r\n\r\n        /*///////////////////////////////////////////////////////////////\r\n                            ERC20 OPERATIONS\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        function safeTransferFrom(\r\n            ERC20 token,\r\n            address from,\r\n            address to,\r\n            uint256 amount\r\n        ) internal {\r\n            bool callStatus;\r\n\r\n            assembly {\r\n                // Get a pointer to some free memory.\r\n                let freeMemoryPointer := mload(0x40)\r\n\r\n                // Write the abi-encoded calldata to memory piece by piece:\r\n                mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n                mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\r\n                mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n                mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n                // Call the token and store if it succeeded or not.\r\n                // We use 100 because the calldata length is 4 + 32 * 3.\r\n                callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\r\n            }\r\n\r\n            require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\r\n        }\r\n\r\n        function safeTransfer(\r\n            ERC20 token,\r\n            address to,\r\n            uint256 amount\r\n        ) internal {\r\n            bool callStatus;\r\n\r\n            assembly {\r\n                // Get a pointer to some free memory.\r\n                let freeMemoryPointer := mload(0x40)\r\n\r\n                // Write the abi-encoded calldata to memory piece by piece:\r\n                mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n                mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n                mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n                // Call the token and store if it succeeded or not.\r\n                // We use 68 because the calldata length is 4 + 32 * 2.\r\n                callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n            }\r\n\r\n            require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\r\n        }\r\n\r\n        function safeApprove(\r\n            ERC20 token,\r\n            address to,\r\n            uint256 amount\r\n        ) internal {\r\n            bool callStatus;\r\n\r\n            assembly {\r\n                // Get a pointer to some free memory.\r\n                let freeMemoryPointer := mload(0x40)\r\n\r\n                // Write the abi-encoded calldata to memory piece by piece:\r\n                mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n                mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n                mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n                // Call the token and store if it succeeded or not.\r\n                // We use 68 because the calldata length is 4 + 32 * 2.\r\n                callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n            }\r\n\r\n            require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\r\n        }\r\n\r\n        /*///////////////////////////////////////////////////////////////\r\n                            INTERNAL HELPER LOGIC\r\n        //////////////////////////////////////////////////////////////*/\r\n\r\n        function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\r\n            assembly {\r\n                // Get how many bytes the call returned.\r\n                let returnDataSize := returndatasize()\r\n\r\n                // If the call reverted:\r\n                if iszero(callStatus) {\r\n                    // Copy the revert message into memory.\r\n                    returndatacopy(0, 0, returnDataSize)\r\n\r\n                    // Revert with the same message.\r\n                    revert(0, returnDataSize)\r\n                }\r\n\r\n                switch returnDataSize\r\n                case 32 {\r\n                    // Copy the return data into memory.\r\n                    returndatacopy(0, 0, returnDataSize)\r\n\r\n                    // Set success to whether it returned true.\r\n                    success := iszero(iszero(mload(0)))\r\n                }\r\n                case 0 {\r\n                    // There was no return data.\r\n                    success := 1\r\n                }\r\n                default {\r\n                    // It returned some malformed input.\r\n                    success := 0\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    /// @title Contains 512-bit math functions\r\n    /// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\r\n    /// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\r\n    library FullMath {\r\n        /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n        /// @param a The multiplicand\r\n        /// @param b The multiplier\r\n        /// @param denominator The divisor\r\n        /// @return result The 256-bit result\r\n        /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\r\n        function mulDiv(\r\n            uint256 a,\r\n            uint256 b,\r\n            uint256 denominator\r\n        ) internal pure returns (uint256 result) {\r\n            unchecked {\r\n                // 512-bit multiply [prod1 prod0] = a * b\r\n                // Compute the product mod 2**256 and mod 2**256 - 1\r\n                // then use the Chinese Remainder Theorem to reconstruct\r\n                // the 512 bit result. The result is stored in two 256\r\n                // variables such that product = prod1 * 2**256 + prod0\r\n                uint256 prod0; // Least significant 256 bits of the product\r\n                uint256 prod1; // Most significant 256 bits of the product\r\n                assembly {\r\n                    let mm := mulmod(a, b, not(0))\r\n                    prod0 := mul(a, b)\r\n                    prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n                }\r\n\r\n                // Handle non-overflow cases, 256 by 256 division\r\n                if (prod1 == 0) {\r\n                    require(denominator > 0);\r\n                    assembly {\r\n                        result := div(prod0, denominator)\r\n                    }\r\n                    return result;\r\n                }\r\n\r\n                // Make sure the result is less than 2**256.\r\n                // Also prevents denominator == 0\r\n                require(denominator > prod1);\r\n\r\n                ///////////////////////////////////////////////\r\n                // 512 by 256 division.\r\n                ///////////////////////////////////////////////\r\n\r\n                // Make division exact by subtracting the remainder from [prod1 prod0]\r\n                // Compute remainder using mulmod\r\n                uint256 remainder;\r\n                assembly {\r\n                    remainder := mulmod(a, b, denominator)\r\n                }\r\n                // Subtract 256 bit number from 512 bit number\r\n                assembly {\r\n                    prod1 := sub(prod1, gt(remainder, prod0))\r\n                    prod0 := sub(prod0, remainder)\r\n                }\r\n\r\n                // Factor powers of two out of denominator\r\n                // Compute largest power of two divisor of denominator.\r\n                // Always >= 1.\r\n                uint256 twos = (type(uint256).max - denominator + 1) & denominator;\r\n                // Divide denominator by power of two\r\n                assembly {\r\n                    denominator := div(denominator, twos)\r\n                }\r\n\r\n                // Divide [prod1 prod0] by the factors of two\r\n                assembly {\r\n                    prod0 := div(prod0, twos)\r\n                }\r\n                // Shift in bits from prod1 into prod0. For this we need\r\n                // to flip `twos` such that it is 2**256 / twos.\r\n                // If twos is zero, then it becomes one\r\n                assembly {\r\n                    twos := add(div(sub(0, twos), twos), 1)\r\n                }\r\n                prod0 |= prod1 * twos;\r\n\r\n                // Invert denominator mod 2**256\r\n                // Now that denominator is an odd number, it has an inverse\r\n                // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n                // Compute the inverse by starting with a seed that is correct\r\n                // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n                uint256 inv = (3 * denominator) ^ 2;\r\n                // Now use Newton-Raphson iteration to improve the precision.\r\n                // Thanks to Hensel's lifting lemma, this also works in modular\r\n                // arithmetic, doubling the correct bits in each step.\r\n                inv *= 2 - denominator * inv; // inverse mod 2**8\r\n                inv *= 2 - denominator * inv; // inverse mod 2**16\r\n                inv *= 2 - denominator * inv; // inverse mod 2**32\r\n                inv *= 2 - denominator * inv; // inverse mod 2**64\r\n                inv *= 2 - denominator * inv; // inverse mod 2**128\r\n                inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n                // Because the division is now exact we can divide by multiplying\r\n                // with the modular inverse of denominator. This will give us the\r\n                // correct result modulo 2**256. Since the precoditions guarantee\r\n                // that the outcome is less than 2**256, this is the final result.\r\n                // We don't need to compute the high bits of the result and prod1\r\n                // is no longer required.\r\n                result = prod0 * inv;\r\n                return result;\r\n            }\r\n        }\r\n\r\n        /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n        /// @param a The multiplicand\r\n        /// @param b The multiplier\r\n        /// @param denominator The divisor\r\n        /// @return result The 256-bit result\r\n        function mulDivRoundingUp(\r\n            uint256 a,\r\n            uint256 b,\r\n            uint256 denominator\r\n        ) internal pure returns (uint256 result) {\r\n            result = mulDiv(a, b, denominator);\r\n            unchecked {\r\n                if (mulmod(a, b, denominator) > 0) {\r\n                    require(result < type(uint256).max);\r\n                    result++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @title VestedERC20\r\n    /// @author zefram.eth\r\n    /// @notice An ERC20 wrapper token that linearly vests an underlying token to\r\n    /// its holders\r\n    contract VestedERC20 is ERC20Clone {\r\n        /// -----------------------------------------------------------------------\r\n        /// Library usage\r\n        /// -----------------------------------------------------------------------\r\n\r\n        using SafeTransferLib for ERC20;\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// Errors\r\n        /// -----------------------------------------------------------------------\r\n\r\n        error Error_Wrap_VestOver();\r\n        error Error_Wrap_AmountTooLarge();\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// Storage variables\r\n        /// -----------------------------------------------------------------------\r\n\r\n        /// @notice The amount of underlying tokens claimed by a token holder\r\n        mapping(address => uint256) public claimedUnderlyingAmount;\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// Immutable parameters\r\n        /// -----------------------------------------------------------------------\r\n\r\n        /// @notice The token that is vested\r\n        /// @return _underlying The address of the underlying token\r\n        function underlying() public pure returns (address _underlying) {\r\n            return _getArgAddress(0x41);\r\n        }\r\n\r\n        /// @notice The Unix timestamp (in seconds) of the start of the vest\r\n        /// @return _startTimestamp The vest start timestamp\r\n        function startTimestamp() public pure returns (uint64 _startTimestamp) {\r\n            return _getArgUint64(0x55);\r\n        }\r\n\r\n        /// @notice The Unix timestamp (in seconds) of the end of the vest\r\n        /// @return _endTimestamp The vest end timestamp\r\n        function endTimestamp() public pure returns (uint64 _endTimestamp) {\r\n            return _getArgUint64(0x5d);\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// User actions\r\n        /// -----------------------------------------------------------------------\r\n\r\n        /// @notice Mints wrapped tokens using underlying tokens. Can only be called before the vest is over.\r\n        /// @param underlyingAmount The amount of underlying tokens to wrap\r\n        /// @param recipient The address that will receive the minted wrapped tokens\r\n        /// @return wrappedTokenAmount The amount of wrapped tokens minted\r\n        function wrap(uint256 underlyingAmount, address recipient)\r\n            external\r\n            returns (uint256 wrappedTokenAmount)\r\n        {\r\n            /// -------------------------------------------------------------------\r\n            /// Validation\r\n            /// -------------------------------------------------------------------\r\n\r\n            uint256 _startTimestamp = startTimestamp();\r\n            uint256 _endTimestamp = endTimestamp();\r\n            if (block.timestamp >= _endTimestamp) {\r\n                revert Error_Wrap_VestOver();\r\n            }\r\n            if (\r\n                underlyingAmount >=\r\n                type(uint256).max / (_endTimestamp - _startTimestamp)\r\n            ) {\r\n                revert Error_Wrap_AmountTooLarge();\r\n            }\r\n\r\n            /// -------------------------------------------------------------------\r\n            /// State updates\r\n            /// -------------------------------------------------------------------\r\n\r\n            if (block.timestamp >= _startTimestamp) {\r\n                // vest already started\r\n                // wrappedTokenAmount * (endTimestamp() - block.timestamp) / (endTimestamp() - startTimestamp()) == underlyingAmount\r\n                // thus, wrappedTokenAmount = underlyingAmount * (endTimestamp() - startTimestamp()) / (endTimestamp() - block.timestamp)\r\n                wrappedTokenAmount =\r\n                    (underlyingAmount * (_endTimestamp - _startTimestamp)) /\r\n                    (_endTimestamp - block.timestamp);\r\n\r\n                // pretend we have claimed the vested underlying amount\r\n                claimedUnderlyingAmount[recipient] +=\r\n                    wrappedTokenAmount -\r\n                    underlyingAmount;\r\n            } else {\r\n                // vest hasn't started yet\r\n                wrappedTokenAmount = underlyingAmount;\r\n            }\r\n            // mint wrapped tokens\r\n            _mint(recipient, wrappedTokenAmount);\r\n\r\n            /// -------------------------------------------------------------------\r\n            /// Effects\r\n            /// -------------------------------------------------------------------\r\n\r\n            ERC20 underlyingToken = ERC20(underlying());\r\n            underlyingToken.safeTransferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                underlyingAmount\r\n            );\r\n        }\r\n\r\n        /// @notice Allows a holder of the wrapped token to redeem the vested tokens\r\n        /// @param recipient The address that will receive the vested tokens\r\n        /// @return redeemedAmount The amount of vested tokens redeemed\r\n        function redeem(address recipient)\r\n            external\r\n            returns (uint256 redeemedAmount)\r\n        {\r\n            /// -------------------------------------------------------------------\r\n            /// State updates\r\n            /// -------------------------------------------------------------------\r\n\r\n            uint256 _claimedUnderlyingAmount = claimedUnderlyingAmount[msg.sender];\r\n            redeemedAmount = _getRedeemableAmount(\r\n                msg.sender,\r\n                _claimedUnderlyingAmount\r\n            );\r\n            claimedUnderlyingAmount[msg.sender] =\r\n                _claimedUnderlyingAmount +\r\n                redeemedAmount;\r\n\r\n            /// -------------------------------------------------------------------\r\n            /// Effects\r\n            /// -------------------------------------------------------------------\r\n\r\n            if (redeemedAmount > 0) {\r\n                ERC20 underlyingToken = ERC20(underlying());\r\n                underlyingToken.safeTransfer(recipient, redeemedAmount);\r\n            }\r\n        }\r\n\r\n        /// @notice The ERC20 transfer function\r\n        function transfer(address to, uint256 amount)\r\n            public\r\n            override\r\n            returns (bool)\r\n        {\r\n            uint256 senderBalance = balanceOf[msg.sender];\r\n            uint256 senderClaimedUnderlyingAmount = claimedUnderlyingAmount[\r\n                msg.sender\r\n            ];\r\n\r\n            balanceOf[msg.sender] = senderBalance - amount;\r\n\r\n            // Cannot overflow because the sum of all user\r\n            // balances can't exceed the max uint256 value.\r\n            unchecked {\r\n                balanceOf[to] += amount;\r\n            }\r\n\r\n            uint256 claimedUnderlyingAmountToTransfer = FullMath.mulDiv(\r\n                senderClaimedUnderlyingAmount,\r\n                amount,\r\n                senderBalance\r\n            );\r\n\r\n            if (claimedUnderlyingAmountToTransfer > 0) {\r\n                claimedUnderlyingAmount[msg.sender] =\r\n                    senderClaimedUnderlyingAmount -\r\n                    claimedUnderlyingAmountToTransfer;\r\n                unchecked {\r\n                    claimedUnderlyingAmount[\r\n                        to\r\n                    ] += claimedUnderlyingAmountToTransfer;\r\n                }\r\n            }\r\n\r\n            emit Transfer(msg.sender, to, amount);\r\n\r\n            return true;\r\n        }\r\n\r\n        /// @notice The ERC20 transferFrom function\r\n        function transferFrom(\r\n            address from,\r\n            address to,\r\n            uint256 amount\r\n        ) public override returns (bool) {\r\n            uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n            if (allowed != type(uint256).max)\r\n                allowance[from][msg.sender] = allowed - amount;\r\n\r\n            uint256 fromBalance = balanceOf[from];\r\n            uint256 fromClaimedUnderlyingAmount = claimedUnderlyingAmount[from];\r\n\r\n            balanceOf[from] = fromBalance - amount;\r\n\r\n            // Cannot overflow because the sum of all user\r\n            // balances can't exceed the max uint256 value.\r\n            unchecked {\r\n                balanceOf[to] += amount;\r\n            }\r\n\r\n            uint256 claimedUnderlyingAmountToTransfer = FullMath.mulDiv(\r\n                fromClaimedUnderlyingAmount,\r\n                amount,\r\n                fromBalance\r\n            );\r\n            if (claimedUnderlyingAmountToTransfer > 0) {\r\n                claimedUnderlyingAmount[from] =\r\n                    fromClaimedUnderlyingAmount -\r\n                    claimedUnderlyingAmountToTransfer;\r\n                unchecked {\r\n                    claimedUnderlyingAmount[\r\n                        to\r\n                    ] += claimedUnderlyingAmountToTransfer;\r\n                }\r\n            }\r\n\r\n            emit Transfer(from, to, amount);\r\n\r\n            return true;\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// Getters\r\n        /// -----------------------------------------------------------------------\r\n\r\n        /// @notice Computes the amount of vested tokens redeemable by an account\r\n        /// @param holder The wrapped token holder to query\r\n        /// @return The amount of vested tokens redeemable\r\n        function getRedeemableAmount(address holder)\r\n            external\r\n            view\r\n            returns (uint256)\r\n        {\r\n            return _getRedeemableAmount(holder, claimedUnderlyingAmount[holder]);\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// Internal functions\r\n        /// -----------------------------------------------------------------------\r\n\r\n        function _getRedeemableAmount(\r\n            address holder,\r\n            uint256 holderClaimedUnderlyingAmount\r\n        ) internal view returns (uint256) {\r\n            uint256 _startTimestamp = startTimestamp();\r\n            uint256 _endTimestamp = endTimestamp();\r\n            if (block.timestamp <= _startTimestamp) {\r\n                // vest hasn't started yet, nothing is vested\r\n                return 0;\r\n            } else if (block.timestamp >= _endTimestamp) {\r\n                // vest is over, everything is vested\r\n                return balanceOf[holder] - holderClaimedUnderlyingAmount;\r\n            } else {\r\n                // middle of vest, compute linear vesting\r\n                return\r\n                    (balanceOf[holder] * (block.timestamp - _startTimestamp)) /\r\n                    (_endTimestamp - _startTimestamp) -\r\n                    holderClaimedUnderlyingAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @title VestedERC20Factory\r\n    /// @author zefram.eth\r\n    /// @notice Factory for deploying VestedERC20 contracts cheaply\r\n    contract VestedERC20Factory {\r\n        /// -----------------------------------------------------------------------\r\n        /// Library usage\r\n        /// -----------------------------------------------------------------------\r\n\r\n        using ClonesWithImmutableArgs for address;\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// Errors\r\n        /// -----------------------------------------------------------------------\r\n\r\n        error Error_InvalidTimeRange();\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// Events\r\n        /// -----------------------------------------------------------------------\r\n\r\n        event CreateVestedERC20(VestedERC20 vestedERC20);\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// Immutable parameters\r\n        /// -----------------------------------------------------------------------\r\n\r\n        /// @notice The VestedERC20 used as the template for all clones created\r\n        VestedERC20 public immutable implementation;\r\n\r\n        constructor(VestedERC20 implementation_) {\r\n            implementation = implementation_;\r\n        }\r\n\r\n        /// @notice Creates a VestedERC20 contract\r\n        /// @dev Uses a modified minimal proxy contract that stores immutable parameters in code and\r\n        /// passes them in through calldata. See ClonesWithCallData.\r\n        /// @param name The name of the VestedERC20 token\r\n        /// @param symbol The symbol of the VestedERC20 token\r\n        /// @param decimals The number of decimals used by the VestedERC20 token\r\n        /// @param underlying The ERC20 token that is vested\r\n        /// @param startTimestamp The start time of the vest, Unix timestamp in seconds\r\n        /// @param endTimestamp The end time of the vest, must be greater than startTimestamp, Unix timestamp in seconds\r\n        /// @return vestedERC20 The created VestedERC20 contract\r\n        function createVestedERC20(\r\n            bytes32 name,\r\n            bytes32 symbol,\r\n            uint8 decimals,\r\n            address underlying,\r\n            uint64 startTimestamp,\r\n            uint64 endTimestamp\r\n        ) external returns (VestedERC20 vestedERC20) {\r\n            if (endTimestamp <= startTimestamp) {\r\n                revert Error_InvalidTimeRange();\r\n            }\r\n            bytes memory data = abi.encodePacked(\r\n                name,\r\n                symbol,\r\n                decimals,\r\n                underlying,\r\n                startTimestamp,\r\n                endTimestamp\r\n            );\r\n            vestedERC20 = VestedERC20(address(implementation).clone(data));\r\n            emit CreateVestedERC20(vestedERC20);\r\n        }\r\n    }", "ABI": "[{\"inputs\":[{\"internalType\":\"contract VestedERC20\",\"name\":\"implementation_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CreateFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Error_InvalidTimeRange\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract VestedERC20\",\"name\":\"vestedERC20\",\"type\":\"address\"}],\"name\":\"CreateVestedERC20\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"symbol\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTimestamp\",\"type\":\"uint64\"}],\"name\":\"createVestedERC20\",\"outputs\":[{\"internalType\":\"contract VestedERC20\",\"name\":\"vestedERC20\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"contract VestedERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VestedERC20Factory", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000a9e42b01c2e122b0779b91c059fdeee41cbaf37f", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7b626395f36e8da0f57d50841c4ac644f260789cfbf4af4f839bccc0286ca417"}]}