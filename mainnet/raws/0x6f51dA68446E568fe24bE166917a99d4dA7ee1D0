{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/council/vaults/FrozenLockingVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\nimport \\\"./LockingVault.sol\\\";\\n\\n// All elves stay in the elfiverse\\ncontract FrozenLockingVault is AbstractLockingVault {\\n    /// @notice Constructs the contract by setting immutables\\n    /// @param _token The external erc20 token contract\\n    /// @param _staleBlockLag The number of blocks before the delegation history is forgotten\\n    constructor(IERC20 _token, uint256 _staleBlockLag)\\n        AbstractLockingVault(_token, _staleBlockLag)\\n    {}\\n\\n    // These functions are the only way for tokens to leave the contract\\n    // Therefore they now revert\\n\\n    /// @notice Does nothing, always reverts\\n    function withdraw(uint256) external pure override {\\n        revert(\\\"Frozen\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/council/vaults/LockingVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\nimport \\\"../libraries/History.sol\\\";\\nimport \\\"../libraries/Storage.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IVotingVault.sol\\\";\\nimport \\\"../interfaces/ILockingVault.sol\\\";\\n\\nabstract contract AbstractLockingVault is IVotingVault, ILockingVault {\\n    // Bring our libraries into scope\\n    using History for *;\\n    using Storage for *;\\n\\n    // Immutables are in bytecode so don't need special storage treatment\\n    IERC20 public immutable override token;\\n    // A constant which is how far back stale blocks are\\n    uint256 public immutable staleBlockLag;\\n\\n    // Event to track delegation data\\n    event VoteChange(address indexed from, address indexed to, int256 amount);\\n\\n    /// @notice Constructs the contract by setting immutables\\n    /// @param _token The external erc20 token contract\\n    /// @param _staleBlockLag The number of blocks before the delegation history is forgotten\\n    constructor(IERC20 _token, uint256 _staleBlockLag) {\\n        token = _token;\\n        staleBlockLag = _staleBlockLag;\\n    }\\n\\n    // This contract is a proxy so we use the custom state management system from\\n    // storage and return the following as methods to isolate that call.\\n\\n    // deposits mapping(address => (address, uint96))\\n    /// @notice A single function endpoint for loading storage for deposits\\n    /// @return returns a storage mapping which can be used to look up deposit data\\n    function _deposits()\\n        internal\\n        pure\\n        returns (mapping(address => Storage.AddressUint) storage)\\n    {\\n        // This call returns a storage mapping with a unique non overwrite-able storage location\\n        // which can be persisted through upgrades, even if they change storage layout\\n        return (Storage.mappingAddressToPackedAddressUint(\\\"deposits\\\"));\\n    }\\n\\n    /// Getter for the deposits mapping\\n    /// @param who The user to query the balance of\\n    /// @return (address delegated to, amount of deposit)\\n    function deposits(address who) external view returns (address, uint96) {\\n        Storage.AddressUint storage userData = _deposits()[who];\\n        return (userData.who, userData.amount);\\n    }\\n\\n    /// @notice Returns the historical voting power tracker\\n    /// @return A struct which can push to and find items in block indexed storage\\n    function _votingPower()\\n        internal\\n        pure\\n        returns (History.HistoricalBalances memory)\\n    {\\n        // This call returns a storage mapping with a unique non overwrite-able storage location\\n        // which can be persisted through upgrades, even if they change storage layout\\n        return (History.load(\\\"votingPower\\\"));\\n    }\\n\\n    /// @notice Attempts to load the voting power of a user\\n    /// @param user The address we want to load the voting power of\\n    /// @param blockNumber the block number we want the user's voting power at\\n    /// @return the number of votes\\n    function queryVotePower(\\n        address user,\\n        uint256 blockNumber,\\n        bytes calldata\\n    ) external override returns (uint256) {\\n        // Get our reference to historical data\\n        History.HistoricalBalances memory votingPower = _votingPower();\\n        // Find the historical data and clear everything more than 'staleBlockLag' into the past\\n        return\\n            votingPower.findAndClear(\\n                user,\\n                blockNumber,\\n                block.number - staleBlockLag\\n            );\\n    }\\n\\n    /// @notice Loads the voting power of a user without changing state\\n    /// @param user The address we want to load the voting power of\\n    /// @param blockNumber the block number we want the user's voting power at\\n    /// @return the number of votes\\n    function queryVotePowerView(address user, uint256 blockNumber)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        // Get our reference to historical data\\n        History.HistoricalBalances memory votingPower = _votingPower();\\n        // Find the historical datum\\n        return votingPower.find(user, blockNumber);\\n    }\\n\\n    /// @notice Deposits and delegates voting power to an address provided with the call\\n    /// @param fundedAccount The address to credit this deposit to\\n    /// @param amount The amount of token which is deposited\\n    /// @param firstDelegation First delegation address\\n    /// @dev Note - There's a minor griefing attack on this which sets someones delegation\\n    ///      address by depositing before them, requiring them to call delegate to reset it.\\n    ///      Given the gas price required and 0 financial benefit we consider it unlikely.\\n    ///      Warning - Users should not set delegation to the zero address as this will allow\\n    ///                someone to change their delegation by depositing a small amount to their\\n    ///                account.\\n    function deposit(\\n        address fundedAccount,\\n        uint256 amount,\\n        address firstDelegation\\n    ) external override {\\n        // No delegating to zero\\n        require(firstDelegation != address(0), \\\"Zero addr delegation\\\");\\n        // Move the tokens into this contract\\n        token.transferFrom(msg.sender, address(this), amount);\\n        // Load our deposits storage\\n        Storage.AddressUint storage userData = _deposits()[fundedAccount];\\n        // Load who has the user's votes\\n        address delegate = userData.who;\\n\\n        if (delegate == address(0)) {\\n            // If the user is un-delegated we delegate to their indicated address\\n            delegate = firstDelegation;\\n            // Set the delegation\\n            userData.who = delegate;\\n            // Now we increase the user's balance\\n            userData.amount += uint96(amount);\\n        } else {\\n            // In this case we make no change to the user's delegation\\n            // Now we increase the user's balance\\n            userData.amount += uint96(amount);\\n        }\\n        // Next we increase the delegation to their delegate\\n        // Get the storage pointer\\n        History.HistoricalBalances memory votingPower = _votingPower();\\n        // Load the most recent voter power stamp\\n        uint256 delegateeVotes = votingPower.loadTop(delegate);\\n        // Emit an event to track votes\\n        emit VoteChange(fundedAccount, delegate, int256(amount));\\n        // Add the newly deposited votes to the delegate\\n        votingPower.push(delegate, delegateeVotes + amount);\\n    }\\n\\n    /// @notice Removes tokens from this contract and the voting power they represent\\n    /// @param amount The amount of token to withdraw\\n    function withdraw(uint256 amount) external virtual override {\\n        // Load our deposits storage\\n        Storage.AddressUint storage userData = _deposits()[msg.sender];\\n        // Reduce the user's stored balance\\n        // If properly optimized this block should result in 1 sload 1 store\\n        userData.amount -= uint96(amount);\\n        address delegate = userData.who;\\n        // Reduce the delegate voting power\\n        // Get the storage pointer\\n        History.HistoricalBalances memory votingPower = _votingPower();\\n        // Load the most recent voter power stamp\\n        uint256 delegateeVotes = votingPower.loadTop(delegate);\\n        // remove the votes from the delegate\\n        votingPower.push(delegate, delegateeVotes - amount);\\n        // Emit an event to track votes\\n        emit VoteChange(msg.sender, delegate, -1 * int256(amount));\\n        // Transfers the result to the sender\\n        token.transfer(msg.sender, amount);\\n    }\\n\\n    /// @notice Changes a user's voting power\\n    /// @param newDelegate The new address which gets voting power\\n    function changeDelegation(address newDelegate) external {\\n        // Get the stored user data\\n        Storage.AddressUint storage userData = _deposits()[msg.sender];\\n        // Get the user balance\\n        uint256 userBalance = uint256(userData.amount);\\n        address oldDelegate = userData.who;\\n        // Reset the user delegation\\n        userData.who = newDelegate;\\n        // Reduce the old voting power\\n        // Get the storage pointer\\n        History.HistoricalBalances memory votingPower = _votingPower();\\n        // Load the old delegate's voting power\\n        uint256 oldDelegateVotes = votingPower.loadTop(oldDelegate);\\n        // Reduce the old voting power\\n        votingPower.push(oldDelegate, oldDelegateVotes - userBalance);\\n        // Emit an event to track votes\\n        emit VoteChange(msg.sender, oldDelegate, -1 * int256(userBalance));\\n        // Get the new delegate's votes\\n        uint256 newDelegateVotes = votingPower.loadTop(newDelegate);\\n        // Store the increase in power\\n        votingPower.push(newDelegate, newDelegateVotes + userBalance);\\n        // Emit an event tracking this voting power change\\n        emit VoteChange(msg.sender, newDelegate, int256(userBalance));\\n    }\\n}\\n\\ncontract LockingVault is AbstractLockingVault {\\n    /// @notice Constructs the contract by setting immutables\\n    /// @param _token The external erc20 token contract\\n    /// @param _staleBlockLag The number of blocks before the delegation history is forgotten\\n    constructor(IERC20 _token, uint256 _staleBlockLag)\\n        AbstractLockingVault(_token, _staleBlockLag)\\n    {}\\n}\\n\"\r\n    },\r\n    \"contracts/council/libraries/History.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\nimport \\\"./Storage.sol\\\";\\n\\n// This library is an assembly optimized storage library which is designed\\n// to track timestamp history in a struct which uses hash derived pointers.\\n// WARNING - Developers using it should not access the underlying storage\\n// directly since we break some assumptions of high level solidity. Please\\n// note this library also increases the risk profile of memory manipulation\\n// please be cautious in your usage of uninitialized memory structs and other\\n// anti patterns.\\nlibrary History {\\n    // The storage layout of the historical array looks like this\\n    // [(128 bit min index)(128 bit length)] [0][0] ... [(64 bit block num)(192 bit data)] .... [(64 bit block num)(192 bit data)]\\n    // We give the option to the invoker of the search function the ability to clear\\n    // stale storage. To find data we binary search for the block number we need\\n    // This library expects the blocknumber indexed data to be pushed in ascending block number\\n    // order and if data is pushed with the same blocknumber it only retains the most recent.\\n    // This ensures each blocknumber is unique and contains the most recent data at the end\\n    // of whatever block it indexes [as long as that block is not the current one].\\n\\n    // A struct which wraps a memory pointer to a string and the pointer to storage\\n    // derived from that name string by the storage library\\n    // WARNING - For security purposes never directly construct this object always use load\\n    struct HistoricalBalances {\\n        string name;\\n        // Note - We use bytes32 to reduce how easy this is to manipulate in high level sol\\n        bytes32 cachedPointer;\\n    }\\n\\n    /// @notice The method by which inheriting contracts init the HistoricalBalances struct\\n    /// @param name The name of the variable. Note - these are globals, any invocations of this\\n    ///             with the same name work on the same storage.\\n    /// @return The memory pointer to the wrapper of the storage pointer\\n    function load(string memory name)\\n        internal\\n        pure\\n        returns (HistoricalBalances memory)\\n    {\\n        mapping(address => uint256[]) storage storageData =\\n            Storage.mappingAddressToUnit256ArrayPtr(name);\\n        bytes32 pointer;\\n        assembly {\\n            pointer := storageData.slot\\n        }\\n        return HistoricalBalances(name, pointer);\\n    }\\n\\n    /// @notice An unsafe method of attaching the cached ptr in a historical balance memory objects\\n    /// @param pointer cached pointer to storage\\n    /// @return storageData A storage array mapping pointer\\n    /// @dev PLEASE DO NOT USE THIS METHOD WITHOUT SERIOUS REVIEW. IF AN EXTERNAL ACTOR CAN CALL THIS WITH\\n    //       ARBITRARY DATA THEY MAY BE ABLE TO OVERWRITE ANY STORAGE IN THE CONTRACT.\\n    function _getMapping(bytes32 pointer)\\n        private\\n        pure\\n        returns (mapping(address => uint256[]) storage storageData)\\n    {\\n        assembly {\\n            storageData.slot := pointer\\n        }\\n    }\\n\\n    /// @notice This function adds a block stamp indexed piece of data to a historical data array\\n    ///         To prevent duplicate entries if the top of the array has the same blocknumber\\n    ///         the value is updated instead\\n    /// @param wrapper The wrapper which hold the reference to the historical data storage pointer\\n    /// @param who The address which indexes the array we need to push to\\n    /// @param data The data to append, should be at most 192 bits and will revert if not\\n    function push(\\n        HistoricalBalances memory wrapper,\\n        address who,\\n        uint256 data\\n    ) internal {\\n        // Check preconditions\\n        // OoB = Out of Bounds, short for contract bytecode size reduction\\n        require(data <= type(uint192).max, \\\"OoB\\\");\\n        // Get the storage this is referencing\\n        mapping(address => uint256[]) storage storageMapping =\\n            _getMapping(wrapper.cachedPointer);\\n        // Get the array we need to push to\\n        uint256[] storage storageData = storageMapping[who];\\n        // We load the block number and then shift it to be in the top 64 bits\\n        uint256 blockNumber = block.number << 192;\\n        // We combine it with the data, because of our require this will have a clean\\n        // top 64 bits\\n        uint256 packedData = blockNumber | data;\\n        // Load the array length\\n        (uint256 minIndex, uint256 length) = _loadBounds(storageData);\\n        // On the first push we don't try to load\\n        uint256 loadedBlockNumber = 0;\\n        if (length != 0) {\\n            (loadedBlockNumber, ) = _loadAndUnpack(storageData, length - 1);\\n        }\\n        // The index we push to, note - we use this pattern to not branch the assembly\\n        uint256 index = length;\\n        // If the caller is changing data in the same block we change the entry for this block\\n        // instead of adding a new one. This ensures each block numb is unique in the array.\\n        if (loadedBlockNumber == block.number) {\\n            index = length - 1;\\n        }\\n        // We use assembly to write our data to the index\\n        assembly {\\n            // Stores packed data in the equivalent of storageData[length]\\n            sstore(\\n                add(\\n                    // The start of the data slots\\n                    add(storageData.slot, 1),\\n                    // index where we store\\n                    index\\n                ),\\n                packedData\\n            )\\n        }\\n        // Reset the boundaries if they changed\\n        if (loadedBlockNumber != block.number) {\\n            _setBounds(storageData, minIndex, length + 1);\\n        }\\n    }\\n\\n    /// @notice Loads the most recent timestamp of delegation power\\n    /// @param wrapper The memory struct which we want to search for historical data\\n    /// @param who The user who's balance we want to load\\n    /// @return the top slot of the array\\n    function loadTop(HistoricalBalances memory wrapper, address who)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        // Load the storage pointer\\n        uint256[] storage userData = _getMapping(wrapper.cachedPointer)[who];\\n        // Load the length\\n        (, uint256 length) = _loadBounds(userData);\\n        // If it's zero no data has ever been pushed so we return zero\\n        if (length == 0) {\\n            return 0;\\n        }\\n        // Load the current top\\n        (, uint256 storedData) = _loadAndUnpack(userData, length - 1);\\n        // and return it\\n        return (storedData);\\n    }\\n\\n    /// @notice Finds the data stored with the highest block number which is less than or equal to a provided\\n    ///         blocknumber.\\n    /// @param wrapper The memory struct which we want to search for historical data\\n    /// @param who The address which indexes the array to be searched\\n    /// @param blocknumber The blocknumber we want to load the historical data of\\n    /// @return The loaded unpacked data at this point in time.\\n    function find(\\n        HistoricalBalances memory wrapper,\\n        address who,\\n        uint256 blocknumber\\n    ) internal view returns (uint256) {\\n        // Get the storage this is referencing\\n        mapping(address => uint256[]) storage storageMapping =\\n            _getMapping(wrapper.cachedPointer);\\n        // Get the array we need to push to\\n        uint256[] storage storageData = storageMapping[who];\\n        // Pre load the bounds\\n        (uint256 minIndex, uint256 length) = _loadBounds(storageData);\\n        // Search for the blocknumber\\n        (, uint256 loadedData) =\\n            _find(storageData, blocknumber, 0, minIndex, length);\\n        // In this function we don't have to change the stored length data\\n        return (loadedData);\\n    }\\n\\n    /// @notice Finds the data stored with the highest blocknumber which is less than or equal to a provided block number\\n    ///         Opportunistically clears any data older than staleBlock which is possible to clear.\\n    /// @param wrapper The memory struct which points to the storage we want to search\\n    /// @param who The address which indexes the historical data we want to search\\n    /// @param blocknumber The blocknumber we want to load the historical state of\\n    /// @param staleBlock A block number which we can [but are not obligated to] delete history older than\\n    /// @return The found data\\n    function findAndClear(\\n        HistoricalBalances memory wrapper,\\n        address who,\\n        uint256 blocknumber,\\n        uint256 staleBlock\\n    ) internal returns (uint256) {\\n        // Get the storage this is referencing\\n        mapping(address => uint256[]) storage storageMapping =\\n            _getMapping(wrapper.cachedPointer);\\n        // Get the array we need to push to\\n        uint256[] storage storageData = storageMapping[who];\\n        // Pre load the bounds\\n        (uint256 minIndex, uint256 length) = _loadBounds(storageData);\\n        // Search for the blocknumber\\n        (uint256 staleIndex, uint256 loadedData) =\\n            _find(storageData, blocknumber, staleBlock, minIndex, length);\\n        // We clear any data in the stale region\\n        // Note - Since find returns 0 if no stale data is found and we use > instead of >=\\n        //        this won't trigger if no stale data is found. Plus it won't trigger on minIndex == staleIndex\\n        //        == maxIndex and clear the whole array.\\n        if (staleIndex > minIndex) {\\n            // Delete the outdated stored info\\n            _clear(minIndex, staleIndex, storageData);\\n            // Reset the array info with stale index as the new minIndex\\n            _setBounds(storageData, staleIndex, length);\\n        }\\n        return (loadedData);\\n    }\\n\\n    /// @notice Searches for the data stored at the largest blocknumber index less than a provided parameter.\\n    ///         Allows specification of a expiration stamp and returns the greatest examined index which is\\n    ///         found to be older than that stamp.\\n    /// @param data The stored data\\n    /// @param blocknumber the blocknumber we want to load the historical data for.\\n    /// @param staleBlock The oldest block that we care about the data stored for, all previous data can be deleted\\n    /// @param startingMinIndex The smallest filled index in the array\\n    /// @param length the length of the array\\n    /// @return Returns the largest stale data index seen or 0 for no seen stale data and the stored data\\n    function _find(\\n        uint256[] storage data,\\n        uint256 blocknumber,\\n        uint256 staleBlock,\\n        uint256 startingMinIndex,\\n        uint256 length\\n    ) private view returns (uint256, uint256) {\\n        // We explicitly revert on the reading of memory which is uninitialized\\n        require(length != 0, \\\"uninitialized\\\");\\n        // Do some correctness checks\\n        require(staleBlock <= blocknumber);\\n        require(startingMinIndex < length);\\n        // Load the bounds of our binary search\\n        uint256 maxIndex = length - 1;\\n        uint256 minIndex = startingMinIndex;\\n        uint256 staleIndex = 0;\\n\\n        // We run a binary search on the block number fields in the array between\\n        // the minIndex and maxIndex. If we find indexes with blocknumber < staleBlock\\n        // we set staleIndex to them and return that data for an optional clearing step\\n        // in the calling function.\\n        while (minIndex != maxIndex) {\\n            // We use the ceil instead of the floor because this guarantees that\\n            // we pick the highest blocknumber less than or equal the requested one\\n            uint256 mid = (minIndex + maxIndex + 1) / 2;\\n            // Load and unpack the data in the midpoint index\\n            (uint256 pastBlock, uint256 loadedData) = _loadAndUnpack(data, mid);\\n\\n            //  If we've found the exact block we are looking for\\n            if (pastBlock == blocknumber) {\\n                // Then we just return the data\\n                return (staleIndex, loadedData);\\n\\n                // Otherwise if the loaded block is smaller than the block number\\n            } else if (pastBlock < blocknumber) {\\n                // Then we first check if this is possibly a stale block\\n                if (pastBlock < staleBlock) {\\n                    // If it is we mark it for clearing\\n                    staleIndex = mid;\\n                }\\n                // We then repeat the search logic on the indices greater than the midpoint\\n                minIndex = mid;\\n\\n                // In this case the pastBlock > blocknumber\\n            } else {\\n                // We then repeat the search on the indices below the midpoint\\n                maxIndex = mid - 1;\\n            }\\n        }\\n\\n        // We load at the final index of the search\\n        (uint256 _pastBlock, uint256 _loadedData) =\\n            _loadAndUnpack(data, minIndex);\\n        // This will only be hit if a user has misconfigured the stale index and then\\n        // tried to load father into the past than has been preserved\\n        require(_pastBlock <= blocknumber, \\\"Search Failure\\\");\\n        return (staleIndex, _loadedData);\\n    }\\n\\n    /// @notice Clears storage between two bounds in array\\n    /// @param oldMin The first index to set to zero\\n    /// @param newMin The new minimum filled index, ie clears to index < newMin\\n    /// @param data The storage array pointer\\n    function _clear(\\n        uint256 oldMin,\\n        uint256 newMin,\\n        uint256[] storage data\\n    ) private {\\n        // Correctness checks on this call\\n        require(oldMin <= newMin);\\n        // This function is private and trusted and should be only called by functions which ensure\\n        // that oldMin < newMin < length\\n        assembly {\\n            // The layout of arrays in solidity is [length][data]....[data] so this pointer is the\\n            // slot to write to data\\n            let dataLocation := add(data.slot, 1)\\n            // Loop through each index which is below new min and clear the storage\\n            // Note - Uses strict min so if given an input like oldMin = 5 newMin = 5 will be a no op\\n            for {\\n                let i := oldMin\\n            } lt(i, newMin) {\\n                i := add(i, 1)\\n            } {\\n                // store at the starting data pointer + i 256 bits of zero\\n                sstore(add(dataLocation, i), 0)\\n            }\\n        }\\n    }\\n\\n    /// @notice Loads and unpacks the block number index and stored data from a data array\\n    /// @param data the storage array\\n    /// @param i the index to load and unpack\\n    /// @return (block number, stored data)\\n    function _loadAndUnpack(uint256[] storage data, uint256 i)\\n        private\\n        view\\n        returns (uint256, uint256)\\n    {\\n        // This function is trusted and should only be called after checking data lengths\\n        // we use assembly for the sload to avoid reloading length.\\n        uint256 loaded;\\n        assembly {\\n            loaded := sload(add(add(data.slot, 1), i))\\n        }\\n        // Unpack the packed 64 bit block number and 192 bit data field\\n        return (\\n            loaded >> 192,\\n            loaded &\\n                0x0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff\\n        );\\n    }\\n\\n    /// @notice This function sets our non standard bounds data field where a normal array\\n    ///         would have length\\n    /// @param data the pointer to the storage array\\n    /// @param minIndex The minimum non stale index\\n    /// @param length The length of the storage array\\n    function _setBounds(\\n        uint256[] storage data,\\n        uint256 minIndex,\\n        uint256 length\\n    ) private {\\n        // Correctness check\\n        require(minIndex < length);\\n\\n        assembly {\\n            // Ensure data cleanliness\\n            let clearedLength := and(\\n                length,\\n                0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff\\n            )\\n            // We move the min index into the top 128 bits by shifting it left by 128 bits\\n            let minInd := shl(128, minIndex)\\n            // We pack the data using binary or\\n            let packed := or(minInd, clearedLength)\\n            // We store in the packed data in the length field of this storage array\\n            sstore(data.slot, packed)\\n        }\\n    }\\n\\n    /// @notice This function loads and unpacks our packed min index and length for our custom storage array\\n    /// @param data The pointer to the storage location\\n    /// @return minInd the first filled index in the array\\n    /// @return length the length of the array\\n    function _loadBounds(uint256[] storage data)\\n        private\\n        view\\n        returns (uint256 minInd, uint256 length)\\n    {\\n        // Use assembly to manually load the length storage field\\n        uint256 packedData;\\n        assembly {\\n            packedData := sload(data.slot)\\n        }\\n        // We use a shift right to clear out the low order bits of the data field\\n        minInd = packedData >> 128;\\n        // We use a binary and to extract only the bottom 128 bits\\n        length =\\n            packedData &\\n            0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/council/libraries/Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\n// This library allows for secure storage pointers across proxy implementations\\n// It will return storage pointers based on a hashed name and type string.\\nlibrary Storage {\\n    // This library follows a pattern which if solidity had higher level\\n    // type or macro support would condense quite a bit.\\n\\n    // Each basic type which does not support storage locations is encoded as\\n    // a struct of the same name capitalized and has functions 'load' and 'set'\\n    // which load the data and set the data respectively.\\n\\n    // All types will have a function of the form 'typename'Ptr('name') -> storage ptr\\n    // which will return a storage version of the type with slot which is the hash of\\n    // the variable name and type string. This pointer allows easy state management between\\n    // upgrades and overrides the default solidity storage slot system.\\n\\n    /// @dev The address type container\\n    struct Address {\\n        address data;\\n    }\\n\\n    /// @notice A function which turns a variable name for a storage address into a storage\\n    ///         pointer for its container.\\n    /// @param name the variable name\\n    /// @return data the storage pointer\\n    function addressPtr(string memory name)\\n        internal\\n        pure\\n        returns (Address storage data)\\n    {\\n        bytes32 typehash = keccak256(\\\"address\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n\\n    /// @notice A function to load an address from the container struct\\n    /// @param input the storage pointer for the container\\n    /// @return the loaded address\\n    function load(Address storage input) internal view returns (address) {\\n        return input.data;\\n    }\\n\\n    /// @notice A function to set the internal field of an address container\\n    /// @param input the storage pointer to the container\\n    /// @param to the address to set the container to\\n    function set(Address storage input, address to) internal {\\n        input.data = to;\\n    }\\n\\n    /// @dev The uint256 type container\\n    struct Uint256 {\\n        uint256 data;\\n    }\\n\\n    /// @notice A function which turns a variable name for a storage uint256 into a storage\\n    ///         pointer for its container.\\n    /// @param name the variable name\\n    /// @return data the storage pointer\\n    function uint256Ptr(string memory name)\\n        internal\\n        pure\\n        returns (Uint256 storage data)\\n    {\\n        bytes32 typehash = keccak256(\\\"uint256\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n\\n    /// @notice A function to load an uint256 from the container struct\\n    /// @param input the storage pointer for the container\\n    /// @return the loaded uint256\\n    function load(Uint256 storage input) internal view returns (uint256) {\\n        return input.data;\\n    }\\n\\n    /// @notice A function to set the internal field of a unit256 container\\n    /// @param input the storage pointer to the container\\n    /// @param to the address to set the container to\\n    function set(Uint256 storage input, uint256 to) internal {\\n        input.data = to;\\n    }\\n\\n    /// @notice Returns the storage pointer for a named mapping of address to uint256\\n    /// @param name the variable name for the pointer\\n    /// @return data the mapping pointer\\n    function mappingAddressToUnit256Ptr(string memory name)\\n        internal\\n        pure\\n        returns (mapping(address => uint256) storage data)\\n    {\\n        bytes32 typehash = keccak256(\\\"mapping(address => uint256)\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n\\n    /// @notice Returns the storage pointer for a named mapping of address to uint256[]\\n    /// @param name the variable name for the pointer\\n    /// @return data the mapping pointer\\n    function mappingAddressToUnit256ArrayPtr(string memory name)\\n        internal\\n        pure\\n        returns (mapping(address => uint256[]) storage data)\\n    {\\n        bytes32 typehash = keccak256(\\\"mapping(address => uint256[])\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n\\n    /// @notice Allows external users to calculate the slot given by this lib\\n    /// @param typeString the string which encodes the type\\n    /// @param name the variable name\\n    /// @return the slot assigned by this lib\\n    function getPtr(string memory typeString, string memory name)\\n        external\\n        pure\\n        returns (uint256)\\n    {\\n        bytes32 typehash = keccak256(abi.encodePacked(typeString));\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        return (uint256)(offset);\\n    }\\n\\n    // A struct which represents 1 packed storage location with a compressed\\n    // address and uint96 pair\\n    struct AddressUint {\\n        address who;\\n        uint96 amount;\\n    }\\n\\n    /// @notice Returns the storage pointer for a named mapping of address to uint256[]\\n    /// @param name the variable name for the pointer\\n    /// @return data the mapping pointer\\n    function mappingAddressToPackedAddressUint(string memory name)\\n        internal\\n        pure\\n        returns (mapping(address => AddressUint) storage data)\\n    {\\n        bytes32 typehash = keccak256(\\\"mapping(address => AddressUint)\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/council/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\ninterface IERC20 {\\n    function symbol() external view returns (string memory);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    // Note this is non standard but nearly all ERC20 have exposed decimal functions\\n    function decimals() external view returns (uint8);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/council/interfaces/IVotingVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\ninterface IVotingVault {\\n    /// @notice Attempts to load the voting power of a user\\n    /// @param user The address we want to load the voting power of\\n    /// @param blockNumber the block number we want the user's voting power at\\n    /// @param extraData Abi encoded optional extra data used by some vaults, such as merkle proofs\\n    /// @return the number of votes\\n    function queryVotePower(\\n        address user,\\n        uint256 blockNumber,\\n        bytes calldata extraData\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/council/interfaces/ILockingVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface ILockingVault {\\n    /// @notice Deposits and delegates voting power to an address provided with the call\\n    /// @param fundedAccount The address to credit this deposit to\\n    /// @param amount The amount of token which is deposited\\n    /// @param firstDelegation First delegation address\\n    function deposit(\\n        address fundedAccount,\\n        uint256 amount,\\n        address firstDelegation\\n    ) external;\\n\\n    /// @notice Removes tokens from this contract and the voting power they represent\\n    /// @param amount The amount of token to withdraw\\n    function withdraw(uint256 amount) external;\\n\\n    /// @notice The token for this locking vault\\n    function token() external returns (IERC20);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_staleBlockLag\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"VoteChange\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDelegate\",\"type\":\"address\"}],\"name\":\"changeDelegation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fundedAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"firstDelegation\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"queryVotePower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"queryVotePowerView\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staleBlockLag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "FrozenLockingVault", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "0000000000000000000000005c6d51ecba4d8e4f20373e3ce96a62342b125d6d0000000000000000000000000000000000000000000000000000000000030d40", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}