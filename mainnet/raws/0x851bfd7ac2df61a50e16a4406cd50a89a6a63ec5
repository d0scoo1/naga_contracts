{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface ERC20 {\r\n    function transfer(address, uint256) external;\r\n\r\n    function transferFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external;\r\n}\r\n\r\ncontract TokenRelease {\r\n    struct Release {\r\n        uint48 start; // Start of release period  [timestamp]\r\n        uint48 cliff; // The cliff date           [timestamp]\r\n        uint48 end; // End of release period    [timestamp]\r\n        uint256 amount; // Total release amount\r\n        uint256 claimed; // Amount of release claimed\r\n    }\r\n\r\n    event Claim(address indexed beneficiary, uint256 indexed amt);\r\n\r\n    //////////////////////////\r\n    /////// Storage //////////\r\n    //////////////////////////\r\n\r\n    /// Mapping of release beneficiaries to releases\r\n    mapping(address => Release) public s_releases;\r\n\r\n    /// Owner of this contract\r\n    address public s_owner;\r\n\r\n    // The address of the token this contract releases\r\n    address public immutable FUEL_TOKEN_ADDRESS;\r\n\r\n    /// @notice The contract contructor\r\n    /// @param tokenAddress :  The token this contract releases\r\n    /// @dev Sets the owner\r\n    constructor(address tokenAddress, address owner) {\r\n        FUEL_TOKEN_ADDRESS = tokenAddress;\r\n        s_owner = owner;\r\n    }\r\n\r\n    // Minimal SafeMath\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"add-overflow\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"sub-underflow\");\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == s_owner, \"sender-not-owner\");\r\n        _;\r\n    }\r\n\r\n    // --------------------------------- PERMISSIONED FUNCTIONS --------------------------------------\r\n\r\n    /// @notice Create a new entity\r\n    /// @param  beneficiary : The address of the payee\r\n    /// @param release : The release struct\r\n    /// @param overwrite : Boolean flag to set if intentionally overwriting a payee\r\n    /// @dev Note that this function funds the contract with the total amount, so msg.sender must have done necessary approval before\r\n    /// @dev WARNING : This function will overwrite an existing entity without checks if the overwrite flag is set\r\n    function create(\r\n        address beneficiary,\r\n        Release memory release,\r\n        bool overwrite\r\n    ) public onlyOwner {\r\n        require(s_releases[beneficiary].amount == 0 || overwrite, \"Must use overwrite flag\");\r\n        s_releases[beneficiary] = release;\r\n        ERC20(FUEL_TOKEN_ADDRESS).transferFrom(msg.sender, address(this), release.amount);\r\n    }\r\n\r\n    /// @notice Owner can withdraw tokens\r\n    /// @param amt: The amount to withdraw\r\n    function withdrawTokens(uint256 amt) public onlyOwner {\r\n        ERC20(FUEL_TOKEN_ADDRESS).transfer(msg.sender, amt);\r\n    }\r\n\r\n    /// @notice Transfer ownership of this contract\r\n    /// @param newOwner: The new owner of the contract\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        s_owner = newOwner;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------------------------------\r\n\r\n    /// @notice Change the beneficiary of a release\r\n    /// @param newBeneficiary : The new beneficiary of the release\r\n    /// @dev Only beneficiary can call\r\n    function changeBeneficiary(address newBeneficiary) public {\r\n        Release memory release = s_releases[msg.sender];\r\n        delete s_releases[msg.sender];\r\n        s_releases[newBeneficiary] = release;\r\n    }\r\n\r\n    ///@notice Claim tokens which are accrued but not yet claimed\r\n    function claim() public {\r\n        Release memory release = s_releases[msg.sender];\r\n        uint256 amt =\r\n            unpaidInternal(\r\n                // solhint-disable-next-line not-rely-on-time\r\n                block.timestamp,\r\n                release.start,\r\n                release.cliff,\r\n                release.end,\r\n                release.amount,\r\n                release.claimed\r\n            );\r\n        s_releases[msg.sender].claimed = add(release.claimed, amt);\r\n        ERC20(FUEL_TOKEN_ADDRESS).transfer(msg.sender, amt);\r\n        emit Claim(msg.sender, amt);\r\n    }\r\n\r\n    ///@notice The total number of tokens accrued (paid and unpaid)\r\n    ///@param beneficiary: The address of the beneficiary to check\r\n    /// @return amt : The amount of tokens accrued\r\n    function accrued(address beneficiary) public view returns (uint256 amt) {\r\n        Release memory release = s_releases[beneficiary];\r\n        // solhint-disable-next-line not-rely-on-time\r\n        amt = accruedInternal(block.timestamp, release.start, release.end, release.amount);\r\n    }\r\n\r\n    ///@notice The number of accrued but unpaid tokens\r\n    ///@param beneficiary: The address of the beneficiary to check\r\n    /// @return amt : The amount of tokens unpaid\r\n    function unpaid(address beneficiary) public view returns (uint256 amt) {\r\n        Release memory release = s_releases[beneficiary];\r\n        amt = unpaidInternal(\r\n            // solhint-disable-next-line not-rely-on-time\r\n            block.timestamp,\r\n            release.start,\r\n            release.cliff,\r\n            release.end,\r\n            release.amount,\r\n            release.claimed\r\n        );\r\n    }\r\n\r\n    /// @notice Calculates accrued tokens\r\n    /// @param time: The timestamp up to which check unpaid tokens\r\n    /// @param start : The start time of the release\r\n    /// @param end : The end time of the release\r\n    /// @param amount : The total amount of the release\r\n    /// @return amt : The amount of tokens accrued\r\n    function accruedInternal(\r\n        uint256 time,\r\n        uint48 start,\r\n        uint48 end,\r\n        uint256 amount\r\n    ) internal pure returns (uint256 amt) {\r\n        if (time < start) {\r\n            amt = 0;\r\n        } else if (time >= end) {\r\n            amt = amount;\r\n        } else {\r\n            // accrued = total_amount * (time_so_far / total_time)\r\n            amt = mul(amount, sub(time, start)) / sub(end, start);\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates unpaid tokens\r\n    /// @param time: The timestamp up to which check unpaid tokens\r\n    /// @param start : The start time of the release\r\n    /// @param cliff : The cliff time of the release\r\n    /// @param end : The end time of the release\r\n    /// @param amount : The total amount of the release\r\n    /// @param claimed: The amount of the release already claimed\r\n    /// @return amt : The amount of tokens unpaid\r\n    function unpaidInternal(\r\n        uint256 time,\r\n        uint48 start,\r\n        uint48 cliff,\r\n        uint48 end,\r\n        uint256 amount,\r\n        uint256 claimed\r\n    ) internal pure returns (uint256 amt) {\r\n        amt = time < cliff ? 0 : sub(accruedInternal(time, start, end, amount), claimed);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FUEL_TOKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"accrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"changeBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"cliff\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"end\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenRelease.Release\",\"name\":\"release\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"overwrite\",\"type\":\"bool\"}],\"name\":\"create\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"s_releases\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"cliff\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"end\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"unpaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenRelease", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000056ebdae96d179549f279ea0cfea3b3432b8cd2bc000000000000000000000000d8ffccaca136580308117feac2dd0ace7c67447d", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1fe4c8e17145cdab86032d9bffb7d48a5e24109c264c56fa5b31ad4e2a0971e0"}]}