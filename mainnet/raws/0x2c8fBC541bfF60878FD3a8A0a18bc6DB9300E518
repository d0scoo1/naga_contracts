{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SoloFlashGovernor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./FlashGovernor.sol\\\";\\n\\ncontract SoloFlashGovernor is FlashGovernor {\\n    /**\\n     * @notice Upgradeable contract constructor\\n     * @dev Can be used instead of base governor initializer with many arguments\\n     */\\n    function soloInitialize() external initializer {\\n        initialize(address(0), address(0), 0, 0);\\n    }\\n\\n    /**\\n     * @notice Function is called by owner to vote for some proposal\\n     * @param proposalId ID of the proposal to vote for\\n     * @param support Support of the proposal (true to support, false to reject)\\n     */\\n    function vote(uint32 proposalId, bool support) external override onlyOwner {\\n        if (support) {\\n            proposals[proposalId].forVotes++;\\n        } else {\\n            proposals[proposalId].againstVotes++;\\n        }\\n        emit VoteCast(proposalId, msg.sender, support);\\n    }\\n\\n    /**\\n     * @notice Function to get state of some proposal\\n     * @param proposalId ID of the proposal\\n     * @return Current proposal's state (as ProposalState enum)\\n     */\\n    function state(uint32 proposalId)\\n        public\\n        view\\n        override\\n        returns (ProposalState)\\n    {\\n        if (\\n            proposals[proposalId].forVotes == proposals[proposalId].againstVotes\\n        ) {\\n            return ProposalState.Active;\\n        } else if (\\n            proposals[proposalId].forVotes < proposals[proposalId].againstVotes\\n        ) {\\n            return ProposalState.Defeated;\\n        } else if (!proposals[proposalId].executed) {\\n            return ProposalState.Succeeded;\\n        } else {\\n            return ProposalState.Executed;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/FlashGovernor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"./interfaces/ICPOOL.sol\\\";\\nimport \\\"./interfaces/IMembershipStaking.sol\\\";\\nimport \\\"./interfaces/IFlashGovernor.sol\\\";\\n\\ncontract FlashGovernor is IFlashGovernor, OwnableUpgradeable {\\n    struct Receipt {\\n        bool hasVoted;\\n        bool support;\\n    }\\n\\n    struct Proposal {\\n        bool executed;\\n        uint256 startBlock;\\n        uint256 endBlock;\\n        uint256 forVotes;\\n        uint256 againstVotes;\\n        mapping(address => Receipt) receipts;\\n    }\\n\\n    /// @notice Mapping of IDs to proposals\\n    mapping(uint256 => Proposal) public proposals;\\n\\n    /// @notice Mapping from addresses to flags if they are allowed to propose (no direct proposals from users to FlashGovernor)\\n    mapping(address => bool) public allowedProposers;\\n\\n    /// @notice Minimal number of votes to reach quorum\\n    uint256 public quorumVotes;\\n\\n    /// @notice Period of voting for proposal (in blocks)\\n    uint256 public votingPeriod;\\n\\n    /// @notice CPOOL token contract (as primary votes source)\\n    ICPOOL public cpool;\\n\\n    /// @notice Membership staking contract (as staked votes source)\\n    IMembershipStaking public staking;\\n\\n    /// @notice ID of last created proposal\\n    uint32 public lastProposalId;\\n\\n    // EVENTS\\n\\n    /// @notice Event emitted when new proposal is created\\n    event ProposalCreated(uint32 indexed proposalId);\\n\\n    /// @notice Event emitted when vote is case for some proposal\\n    event VoteCast(uint32 indexed proposalId, address voter, bool support);\\n\\n    /// @notice Event emitted when proposal is executed\\n    event ProposalExecuted(uint32 indexed proposalId);\\n\\n    /// @notice Event emitted when new quorum votes value is set\\n    event QuorumVotesSet(uint256 votes);\\n\\n    /// @notice Event emitted when new voting period is set\\n    event VotingPeriodSet(uint256 period);\\n\\n    /// @notice Event emitted when state of address as allowed proposer is changed\\n    event AllowedProposerSet(address proposer, bool allowed);\\n\\n    // CONSTRUCTOR\\n\\n    /**\\n     * @notice Upgradeable contract constructor\\n     * @param cpool_ The address of the CPOOL contract\\n     * @param staking_ The address of the MembershipStaking contract\\n     * @param quorumVotes_ Minimal number of votes to reach quorum\\n     * @param votingPeriod_ Period of voting for proposal (in blocks)\\n     */\\n    function initialize(\\n        address cpool_,\\n        address staking_,\\n        uint256 quorumVotes_,\\n        uint256 votingPeriod_\\n    ) public initializer {\\n        __Ownable_init();\\n        cpool = ICPOOL(cpool_);\\n        staking = IMembershipStaking(staking_);\\n        quorumVotes = quorumVotes_;\\n        votingPeriod = votingPeriod_;\\n    }\\n\\n    // PUBLIC FUNCTIONS\\n\\n    /**\\n     * @notice Function is called by allowed proposer to create new proposal\\n     * @return ID of the created proposal\\n     */\\n    function propose() external returns (uint32) {\\n        require(allowedProposers[msg.sender], \\\"PNA\\\");\\n\\n        lastProposalId++;\\n        proposals[lastProposalId].startBlock = block.number + 1;\\n        proposals[lastProposalId].endBlock = block.number + votingPeriod;\\n\\n        emit ProposalCreated(lastProposalId);\\n        return lastProposalId;\\n    }\\n\\n    /**\\n     * @notice Function is called by CPOOL delegate to vote for some proposal\\n     * @param proposalId ID of the proposal to vote for\\n     * @param support Support of the proposal (true to support, false to reject)\\n     */\\n    function vote(uint32 proposalId, bool support) external virtual {\\n        require(state(proposalId) == ProposalState.Active, \\\"PWS\\\");\\n        require(!proposals[proposalId].receipts[msg.sender].hasVoted, \\\"HWA\\\");\\n\\n        proposals[proposalId].receipts[msg.sender].hasVoted = true;\\n        proposals[proposalId].receipts[msg.sender].support = support;\\n        uint256 votes = getVotesAtBlock(\\n            msg.sender,\\n            proposals[proposalId].startBlock\\n        );\\n        if (support) {\\n            proposals[proposalId].forVotes += votes;\\n        } else {\\n            proposals[proposalId].againstVotes += votes;\\n        }\\n\\n        emit VoteCast(proposalId, msg.sender, support);\\n    }\\n\\n    /**\\n     * @notice Function is called by allowed proposer to mark succeeded proposal as executed\\n     * @param proposalId ID of the proposal to mark\\n     */\\n    function execute(uint32 proposalId) external {\\n        require(state(proposalId) == ProposalState.Succeeded, \\\"PWS\\\");\\n        require(allowedProposers[msg.sender], \\\"APE\\\");\\n\\n        proposals[proposalId].executed = true;\\n\\n        emit ProposalExecuted(proposalId);\\n    }\\n\\n    // RESTRICTED FUNCTIONS\\n\\n    /**\\n     * @notice Function is called by contract owner to set quorum votes\\n     * @param quorumVotes_ New value for quorum votes\\n     */\\n    function setQuorumVotes(uint256 quorumVotes_) external onlyOwner {\\n        quorumVotes = quorumVotes_;\\n        emit QuorumVotesSet(quorumVotes_);\\n    }\\n\\n    /**\\n     * @notice Function is called by contract owner to set voting period\\n     * @param votingPeriod_ New value for voting period\\n     */\\n    function setVotingPeriod(uint256 votingPeriod_) external onlyOwner {\\n        require(votingPeriod_ > 0, \\\"VPZ\\\");\\n        votingPeriod = votingPeriod_;\\n        emit VotingPeriodSet(votingPeriod_);\\n    }\\n\\n    /**\\n     * @notice Function is called by contract owner to allow or forbid some proposer\\n     * @param proposer Address of the proposer to allow or forbid\\n     * @param allowed Allowance (true to allow, false to forbid)\\n     */\\n    function setAllowedProposer(address proposer, bool allowed)\\n        external\\n        onlyOwner\\n    {\\n        allowedProposers[proposer] = allowed;\\n        emit AllowedProposerSet(proposer, allowed);\\n    }\\n\\n    // VIEW FUNCTIONS\\n\\n    /**\\n     * @notice Function to get state of some proposal\\n     * @param proposalId ID of the proposal\\n     * @return Current proposal's state (as ProposalState enum)\\n     */\\n    function state(uint32 proposalId)\\n        public\\n        view\\n        virtual\\n        returns (ProposalState)\\n    {\\n        if (block.number <= proposals[proposalId].startBlock) {\\n            return ProposalState.Pending;\\n        } else if (block.number <= proposals[proposalId].endBlock) {\\n            return ProposalState.Active;\\n        } else if (\\n            proposals[proposalId].forVotes <=\\n            proposals[proposalId].againstVotes ||\\n            proposals[proposalId].forVotes +\\n                proposals[proposalId].againstVotes <\\n            quorumVotes\\n        ) {\\n            return ProposalState.Defeated;\\n        } else if (!proposals[proposalId].executed) {\\n            return ProposalState.Succeeded;\\n        } else {\\n            return ProposalState.Executed;\\n        }\\n    }\\n\\n    /**\\n     * @notice Function to get voting end block of some proposal\\n     * @param proposalId ID of the proposal\\n     * @return Proposal's voting end block\\n     */\\n    function proposalEndBlock(uint32 proposalId)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return proposals[proposalId].endBlock;\\n    }\\n\\n    /**\\n     * @notice Function returns given account votes at given block\\n     * @param account Account to get votes for\\n     * @param blockNumber Block number to get votes at\\n     * @return Number of votes\\n     */\\n    function getVotesAtBlock(address account, uint256 blockNumber)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return (uint256(cpool.getPriorVotes(account, blockNumber)) +\\n            staking.getPriorVotes(account, blockNumber));\\n    }\\n\\n    /**\\n     * @notice Function to determine if sender has voted for given proposal\\n     * @param proposalId ID of the proposal\\n     * @return Receipt struct with voting information\\n     */\\n    function hasVoted(uint32 proposalId)\\n        external\\n        view\\n        returns (Receipt memory)\\n    {\\n        return proposals[proposalId].receipts[msg.sender];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICPOOL.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface ICPOOL {\\n    function getPriorVotes(address account, uint256 blockNumber)\\n        external\\n        view\\n        returns (uint96);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMembershipStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IMembershipStaking {\\n    function managerMinimalStake() external view returns (uint256);\\n\\n    function getPriorVotes(address account, uint256 blockNumber)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function lockStake(address account) external returns (uint256);\\n\\n    function unlockStake(address account, uint256 amount) external;\\n\\n    function burnStake(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFlashGovernor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IFlashGovernor {\\n    function proposalEndBlock(uint32 proposalId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function propose() external returns (uint32);\\n\\n    function execute(uint32 proposalId) external;\\n\\n    enum ProposalState {\\n        Pending,\\n        Active,\\n        Defeated,\\n        Succeeded,\\n        Executed\\n    }\\n\\n    function state(uint32 proposalId) external view returns (ProposalState);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"AllowedProposerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"proposalId\",\"type\":\"uint32\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"proposalId\",\"type\":\"uint32\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"name\":\"QuorumVotesSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"proposalId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"}],\"name\":\"VoteCast\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"VotingPeriodSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedProposers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cpool\",\"outputs\":[{\"internalType\":\"contract ICPOOL\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"proposalId\",\"type\":\"uint32\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getVotesAtBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"proposalId\",\"type\":\"uint32\"}],\"name\":\"hasVoted\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasVoted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"}],\"internalType\":\"struct FlashGovernor.Receipt\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cpool_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staking_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quorumVotes_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingPeriod_\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastProposalId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"proposalId\",\"type\":\"uint32\"}],\"name\":\"proposalEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quorumVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setAllowedProposer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quorumVotes_\",\"type\":\"uint256\"}],\"name\":\"setQuorumVotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"votingPeriod_\",\"type\":\"uint256\"}],\"name\":\"setVotingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"soloInitialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"contract IMembershipStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"proposalId\",\"type\":\"uint32\"}],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum IFlashGovernor.ProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"proposalId\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SoloFlashGovernor", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}