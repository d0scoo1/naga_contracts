{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MarsBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nimport \\\"./MarsBaseCommon.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nlibrary MarsBase {\\n  // MarsBaseCommon.OfferType as int\\n  /*\\n    Full Purchase - 0\\n    Limited Time / Deadline - 1\\n    Chunked Purchase - 2\\n    Chunked Purchse with Minimum - 3\\n    Limited Time / Deadline with Minimum - 4\\n    Limited Time / Deaadline and Chunked - 5\\n    Limited Time / Deadline, Chunked with Minimum - 6\\n    Limited Time / Deadline, Chunked with Minimum with delyed distribution - 7\\n  */\\n\\n  function contractType(MarsBaseCommon.OfferType offerType) public pure returns (MarsBaseCommon.ContractType) {\\n    if (uint8(offerType) < 4) {\\n      return MarsBaseCommon.ContractType.Offers;\\n    } else {\\n      return MarsBaseCommon.ContractType.MinimumOffers;\\n    }\\n  }\\n\\n\\n  function price(uint256 amountAlice, uint256 offerAmountAlice, uint256 offerAmountBob) public pure returns (uint256) {\\n    uint256 numerator = amountAlice * offerAmountBob;\\n    uint256 denominator = offerAmountAlice;\\n    uint256 finalPrice = numerator / denominator;\\n    return finalPrice;\\n  }\\n\\n  function setOfferProperties (MarsBaseCommon.MBOffer memory offer, MarsBaseCommon.OfferParams calldata offerParams) public view returns (MarsBaseCommon.MBOffer memory) {\\n    require(offer.amountAlice >= offerParams.smallestChunkSize, \\\"M1\\\");\\n    require(block.timestamp < offerParams.deadline || offerParams.deadline == 0, \\\"M2\\\");\\n\\n    offer.offerType = getOfferType(offer.amountAlice, offerParams);\\n\\n    offer.smallestChunkSize = offerParams.smallestChunkSize;\\n\\n    if (offerParams.cancelEnabled == true) {\\n      offer.capabilities[1] = true;\\n    }\\n\\n    if (offerParams.modifyEnabled == true) {\\n      offer.capabilities[0] = true;\\n    }\\n\\n    if (offerParams.minimumSize != 0) {\\n      offer.minimumSize = offerParams.minimumSize;\\n\\n      if (offerParams.minimumSize != 0 && offerParams.holdTokens == true) {\\n        offer.capabilities[2] = true;\\n      }\\n\\n    } else {\\n      offer.minimumSize = 0;\\n    }\\n\\n    offer.deadline = offerParams.deadline;\\n\\n    return offer;\\n  }\\n\\n  function getOfferType (uint256 amountAlice, MarsBaseCommon.OfferParams calldata offerParameters) public pure returns (MarsBaseCommon.OfferType) {\\n    MarsBaseCommon.OfferType offerType = MarsBaseCommon.OfferType.FullPurchase;\\n\\n    if (offerParameters.minimumSize == 0) {\\n      if (offerParameters.deadline > 0 && offerParameters.smallestChunkSize > 0 && offerParameters.smallestChunkSize != amountAlice) {\\n        offerType = MarsBaseCommon.OfferType.LimitedTimeChunkedPurchase;\\n      } else if (offerParameters.smallestChunkSize > 0 && offerParameters.smallestChunkSize != amountAlice) {\\n        offerType = MarsBaseCommon.OfferType.ChunkedPurchase;\\n      } else if (offerParameters.deadline > 0) {\\n        offerType = MarsBaseCommon.OfferType.LimitedTime;\\n      } else {\\n        offerType = MarsBaseCommon.OfferType.FullPurchase;\\n      }\\n    } else {\\n      if (offerParameters.deadline > 0 && offerParameters.smallestChunkSize > 0 && offerParameters.smallestChunkSize != amountAlice && offerParameters.holdTokens == true) {\\n        offerType = MarsBaseCommon.OfferType.LimitedTimeMinimumChunkedDeadlinePurchase;\\n      } else if (offerParameters.deadline > 0 && offerParameters.smallestChunkSize > 0 && offerParameters.smallestChunkSize != amountAlice) {\\n        offerType = MarsBaseCommon.OfferType.LimitedTimeMinimumChunkedPurchase;\\n      } else if (offerParameters.smallestChunkSize > 0 && offerParameters.smallestChunkSize != amountAlice) {\\n        offerType = MarsBaseCommon.OfferType.MinimumChunkedPurchase;\\n      } else if (offerParameters.deadline > 0) {\\n        offerType = MarsBaseCommon.OfferType.LimitedTimeMinimumPurchase;\\n      } else {\\n        offerType = MarsBaseCommon.OfferType.MinimumChunkedPurchase;\\n      }\\n    }\\n\\n    return offerType;\\n  }\\n\\n  function initOffer(uint256 nextOfferId, address tokenAlice, address[] calldata tokenBob, uint256 amountAlice, uint256[] calldata amountBob, MarsBaseCommon.OfferParams calldata offerParameters) public pure returns (MarsBaseCommon.MBOffer memory) {\\n    \\n    MarsBaseCommon.MBOffer memory offer;\\n\\n    offer.offerId = nextOfferId;\\n\\n    offer.tokenAlice = tokenAlice;\\n    offer.tokenBob = tokenBob;\\n\\n    offer.amountAlice = amountAlice;\\n    offer.amountBob = amountBob;\\n\\n    offer.feeAlice = offerParameters.feeAlice;\\n    offer.feeBob = offerParameters.feeBob;\\n\\n    offer.amountRemaining = amountAlice;\\n\\n    // offer.minimumOrderTokens = new address[](0);\\n    // offer.minimumOrderAddresses = new address[](0);\\n    // offer.minimumOrderAmountsAlice = new uint256[](0);\\n    // offer.minimumOrderAmountsBob = new uint256[](0);\\n\\n    offer.capabilities = new bool[](3);\\n\\n    offer.active = true;\\n    offer.minimumMet = false;\\n\\n    return offer;\\n  }\\n\\n  function createOffer(uint256 nextOfferId, address tokenAlice, address[] calldata tokenBob, uint256 amountAlice, uint256[] calldata amountBob, MarsBaseCommon.OfferParams calldata offerParameters) public returns (MarsBaseCommon.MBOffer memory) {\\n    MarsBaseCommon.MBOffer memory offer = initOffer(nextOfferId, tokenAlice, tokenBob, amountAlice, amountBob, offerParameters);\\n    offer = setOfferProperties(offer, offerParameters);\\n    offer.offerType = getOfferType(amountAlice, offerParameters);\\n    offer.feeAlice = offerParameters.feeAlice;\\n    offer.feeBob = offerParameters.feeBob;\\n    offer.payoutAddress = msg.sender;\\n    offer.offerer = msg.sender;\\n\\n    require(amountAlice >= offerParameters.smallestChunkSize, \\\"M1\\\");\\n    require(amountAlice >= offerParameters.minimumSize, \\\"M13\\\");\\n    require(block.timestamp < offerParameters.deadline || offerParameters.deadline == 0, \\\"M2\\\");\\n\\n    if (tokenAlice != address(0)) {\\n      require(IERC20(offer.tokenAlice).transferFrom(msg.sender, address(this), amountAlice), \\\"T1a\\\");\\n    } else {\\n      require(msg.value > 0, \\\"T0\\\");\\n      offer.amountAlice = msg.value;\\n    }\\n\\n    return offer;\\n  }\\n\\n  function changeOfferParams(MarsBaseCommon.MBOffer memory offer, address[] calldata tokenBob, uint256[] calldata amountBob, MarsBaseCommon.OfferParams calldata offerParameters) public view returns (MarsBaseCommon.MBOffer memory) {\\n    require(offer.offerer == msg.sender, \\\"S2\\\");\\n    require(tokenBob.length == amountBob.length, \\\"M5\\\");\\n\\n    require(offer.capabilities[0] == true, \\\"S4\\\");\\n\\n    require(offerParameters.smallestChunkSize <= offer.amountAlice, \\\"M1\\\");\\n\\n    offer.tokenBob = tokenBob;\\n    offer.amountBob = amountBob;\\n    offer.feeAlice = offerParameters.feeAlice;\\n    offer.feeBob = offerParameters.feeBob;\\n    offer.smallestChunkSize = offerParameters.smallestChunkSize;\\n    offer.deadline = offerParameters.deadline;\\n\\n    return offer;\\n  }\\n\\n  function acceptOfferPartWithMinimum(MarsBaseCommon.MBOffer memory offer, address tokenBob, uint256 amountBob) public returns (MarsBaseCommon.MBOffer memory) {\\n    require(offer.active == true, \\\"S0\\\");\\n    require(offer.offerType == MarsBaseCommon.OfferType.MinimumChunkedPurchase || \\n      offer.offerType == MarsBaseCommon.OfferType.LimitedTimeMinimumPurchase || \\n      offer.offerType == MarsBaseCommon.OfferType.LimitedTimeMinimumChunkedPurchase ||\\n      offer.offerType == MarsBaseCommon.OfferType.LimitedTimeMinimumChunkedDeadlinePurchase, \\\"S5\\\");\\n\\n    address acceptedTokenBob = address(0);\\n    uint256 acceptedAmountBob = 0;\\n    for (uint256 index = 0; index < offer.tokenBob.length; index++) {\\n      if (offer.tokenBob[index] == tokenBob) {\\n        acceptedTokenBob = offer.tokenBob[index];\\n        acceptedAmountBob = offer.amountBob[index];\\n      }\\n    }\\n\\n    // if (acceptedTokenBob == address(0)) {\\n    //   acceptedAmountBob = msg.value;\\n    // }\\n\\n    uint256 partialAmountAlice = price(amountBob, acceptedAmountBob, offer.amountAlice);\\n    uint256 partialAmountBob = price(partialAmountAlice, offer.amountAlice, acceptedAmountBob);\\n\\n    uint256 amountAfterFeeAlice = partialAmountBob * (1000-offer.feeBob) / 1000;\\n    uint256 amountAfterFeeBob = partialAmountAlice * (1000-offer.feeAlice) / 1000;\\n\\n    require(acceptedTokenBob == tokenBob, \\\"T3\\\");\\n\\n    require(partialAmountBob >= 0, \\\"M6\\\");\\n\\n    require(partialAmountAlice >= offer.smallestChunkSize, \\\"M1\\\");\\n    require(partialAmountAlice <= offer.amountRemaining, \\\"M10\\\");\\n    \\n    offer.amountRemaining -= partialAmountAlice;\\n\\n    uint256 tokensSold = offer.amountAlice - offer.amountRemaining;\\n\\n    offer = payMinimumOffer(offer, tokensSold, acceptedTokenBob, amountAfterFeeAlice, amountAfterFeeBob, partialAmountAlice, partialAmountBob);\\n\\n    if (offer.amountRemaining == 0) {\\n      delete offer;\\n    }\\n\\n    return offer;\\n  }\\n\\n  function cancelExpiredMinimumOffer(MarsBaseCommon.MBOffer memory offer) public returns (MarsBaseCommon.MBOffer memory) {\\n    require(offer.offerType != MarsBaseCommon.OfferType.LimitedTimeMinimumChunkedDeadlinePurchase && offer.deadline < block.timestamp, \\\"S1\\\");\\n    require(offer.active == true, \\\"S0\\\");\\n    require(offer.amountAlice > 0, \\\"M3\\\");\\n    require(contractType(offer.offerType) == MarsBaseCommon.ContractType.MinimumOffers, \\\"S5\\\");\\n\\n    for (uint256 index = 0; index < offer.minimumOrderAddresses.length; index++) {\\n      if (offer.minimumOrderAmountsAlice[index] != 0) {\\n        if (offer.minimumOrderTokens[index] != address(0)) {\\n          require(IERC20(offer.minimumOrderTokens[index]).transfer(offer.minimumOrderAddresses[index], offer.minimumOrderAmountsBob[index]), \\\"T2b\\\");\\n        } else {\\n          (bool success, bytes memory data) = offer.minimumOrderAddresses[index].call{value: offer.minimumOrderAmountsBob[index]}(\\\"\\\");\\n          require(success, \\\"t1b\\\");\\n        }\\n      }\\n    }\\n\\n    require(IERC20(offer.tokenAlice).transfer(offer.offerer, offer.amountAlice), \\\"T1b\\\");\\n\\n    delete offer;\\n\\n    return offer;\\n  }\\n\\n  function payMinimumOffer(MarsBaseCommon.MBOffer memory offer, uint256 tokensSold, address acceptedTokenBob, uint256 amountAfterFeeAlice, uint256 amountAfterFeeBob, uint256 partialAmountAlice, uint256 partialAmountBob) private returns (MarsBaseCommon.MBOffer memory) {\\n    if ((tokensSold >= offer.minimumSize && offer.capabilities[2] == false) ||\\n      (tokensSold == offer.amountAlice && offer.capabilities[2] == true) || \\n      (tokensSold >= offer.minimumSize && offer.capabilities[2] == true && offer.deadline < block.timestamp)) {\\n      if (acceptedTokenBob != address(0)) {\\n        require(IERC20(acceptedTokenBob).transferFrom(msg.sender, offer.payoutAddress, amountAfterFeeAlice), \\\"T2a\\\");\\n        require(IERC20(offer.tokenAlice).transfer(msg.sender, amountAfterFeeBob), \\\"T5\\\");\\n        // require(IERC20(acceptedTokenBob).transferFrom(msg.sender, commissionWallet, partialAmountBob - amountAfterFeeBob), \\\"T1a\\\");\\n      } else {\\n        require(IERC20(offer.tokenAlice).transfer(msg.sender, amountAfterFeeBob), \\\"T5\\\");\\n        (bool success, bytes memory data) = offer.payoutAddress.call{value: amountAfterFeeAlice}(\\\"\\\");\\n        require(success, \\\"t1b\\\");\\n      }\\n      for (uint256 index = 0; index < offer.minimumOrderAddresses.length; index++) {\\n        if (offer.minimumOrderAmountsAlice[index] != 0) {\\n          if (offer.minimumOrderTokens[index] != address(0)) {\\n            require(IERC20(offer.minimumOrderTokens[index]).transfer(offer.payoutAddress, offer.minimumOrderAmountsBob[index] * (1000-offer.feeBob) / 1000), \\\"T2b\\\");\\n            require(IERC20(offer.tokenAlice).transfer(offer.minimumOrderAddresses[index], offer.minimumOrderAmountsAlice[index] * (1000-offer.feeAlice) / 1000), \\\"T1b\\\");\\n            // require(IERC20(offer.minimumOrderTokens[index]).transfer(commissionWallet, offer.minimumOrderAmountsBob[index] - (offer.minimumOrderAmountsBob[index] * (1000-offer.feeBob))), \\\"T1a\\\");\\n          } else {\\n            (bool success, bytes memory data) = offer.minimumOrderAddresses[index].call{value: offer.minimumOrderAmountsBob[index] * (1000-offer.feeAlice) / 1000}(\\\"\\\");\\n            require(success, \\\"t1b\\\");\\n            require(IERC20(offer.tokenAlice).transfer(offer.minimumOrderAddresses[index], offer.minimumOrderAmountsAlice[index] * (1000-offer.feeBob) / 1000), \\\"T1b\\\");\\n          }\\n        }\\n\\n        offer.minimumMet = true;\\n      }\\n\\n      delete offer.minimumOrderAddresses;\\n      delete offer.minimumOrderAmountsBob;\\n      delete offer.minimumOrderAmountsAlice;\\n      delete offer.minimumOrderTokens;\\n\\n      if (offer.amountRemaining > 0 && (((offer.amountRemaining * 1000) / (offer.amountAlice) <= 10) || offer.smallestChunkSize > offer.amountRemaining)) {\\n        require(IERC20(offer.tokenAlice).transfer(offer.payoutAddress, offer.amountRemaining), \\\"T1b\\\");\\n        offer.amountRemaining = 0;\\n      }\\n\\n    } else if (tokensSold < offer.minimumSize && offer.capabilities[2] == true && offer.offerType == MarsBaseCommon.OfferType.LimitedTimeMinimumChunkedDeadlinePurchase && offer.deadline < block.timestamp) {\\n      cancelExpiredMinimumOffer(offer);\\n      return offer;\\n    } else {\\n      uint256 chunkAlicedex = offer.minimumOrderAddresses.length;\\n\\n      if (chunkAlicedex > 0) {\\n        chunkAlicedex -= 1;\\n      }\\n\\n      offer = setMinimumOrderHold(offer, acceptedTokenBob, partialAmountAlice, partialAmountBob);\\n    }\\n\\n    return offer;\\n  }\\n\\n  function setMinimumOrderHold(MarsBaseCommon.MBOffer memory offer, address acceptedTokenBob, uint256 partialAmountAlice, uint256 partialAmountBob) private returns (MarsBaseCommon.MBOffer memory) {\\n    uint count = offer.minimumOrderAddresses.length;\\n    count++;\\n\\n    address[] memory minimumOrderAddresses = new address[](count);\\n    uint256[] memory minimumOrderAmountsBob = new uint256[](count);\\n    uint256[] memory minimumOrderAmountsAlice = new uint256[](count);\\n    address[] memory minimumOrderTokens = new address[](count);\\n\\n    if (count > 1) {\\n      for (uint i = 0; i < count - 1; i++) {\\n        minimumOrderAddresses[i] = offer.minimumOrderAddresses[i];\\n        minimumOrderAmountsBob[i] = offer.minimumOrderAmountsBob[i];\\n        minimumOrderAmountsAlice[i] = offer.minimumOrderAmountsAlice[i];\\n        minimumOrderTokens[i] = offer.minimumOrderTokens[i];\\n      }\\n    }\\n\\n    minimumOrderAddresses[count - 1] = msg.sender;\\n    minimumOrderAmountsBob[count - 1] = partialAmountBob;\\n    minimumOrderAmountsAlice[count - 1] = partialAmountAlice;\\n    minimumOrderTokens[count - 1] = acceptedTokenBob;\\n\\n    offer.minimumOrderAddresses = minimumOrderAddresses;\\n    offer.minimumOrderAmountsBob = minimumOrderAmountsBob;\\n    offer.minimumOrderAmountsAlice = minimumOrderAmountsAlice;\\n    offer.minimumOrderTokens = minimumOrderTokens;\\n\\n    if (acceptedTokenBob != address(0)) {\\n      require(IERC20(acceptedTokenBob).transferFrom(msg.sender, address(this), partialAmountBob), \\\"T2a\\\");\\n    }\\n\\n    return offer;\\n  }\\n\\n  function cancelOffer(MarsBaseCommon.MBOffer memory offer) public returns (MarsBaseCommon.MBOffer memory) {\\n    require(msg.sender == offer.offerer, \\\"S2\\\");\\n    require(offer.active == true, \\\"S0\\\");\\n    require(offer.capabilities[1] == true, \\\"S1\\\");\\n    require(offer.amountAlice > 0, \\\"M3\\\");\\n\\n    if (contractType(offer.offerType) == MarsBaseCommon.ContractType.Offers) {\\n      if (offer.tokenAlice == address(0)) {\\n        (bool success, bytes memory data) = offer.offerer.call{value: offer.amountRemaining}(\\\"\\\");\\n        require(success, \\\"t1b\\\");\\n      } else {\\n        require(IERC20(offer.tokenAlice).transfer(offer.offerer, offer.amountRemaining), \\\"T1b\\\");\\n      }\\n    } else {\\n      if (offer.minimumMet == true) {\\n        for (uint256 index = 0; index < offer.minimumOrderAddresses.length; index++) {\\n          if (offer.minimumOrderTokens[index] != address(0)) {\\n            require(IERC20(offer.minimumOrderTokens[index]).transfer(offer.minimumOrderAddresses[index], offer.minimumOrderAmountsBob[index]), \\\"T2b\\\");\\n          } else {\\n            (bool success, bytes memory data) = offer.minimumOrderAddresses[index].call{value: offer.minimumOrderAmountsBob[index]}(\\\"\\\");\\n            require(success, \\\"t1b\\\");\\n          }\\n        }\\n\\n        require(IERC20(offer.tokenAlice).transfer(offer.offerer, offer.amountRemaining), \\\"T1b\\\");\\n      } else {\\n        for (uint256 index = 0; index < offer.minimumOrderAddresses.length; index++) {\\n          if (offer.minimumOrderAmountsAlice[index] != 0) {\\n            if (offer.minimumOrderTokens[index] != address(0)) {\\n              require(IERC20(offer.tokenAlice).transfer(offer.minimumOrderAddresses[index], offer.minimumOrderAmountsAlice[index] * (1000-offer.feeAlice) / 1000), \\\"T2b\\\");\\n              require(IERC20(offer.minimumOrderTokens[index]).transfer(offer.payoutAddress, offer.minimumOrderAmountsBob[index] * (1000-offer.feeBob) / 1000), \\\"T1b\\\");\\n              // require(IERC20(offer.minimumOrderTokens[index]).transfer(commissionWallet, offer.minimumOrderAmountsBob[index] - (offer.minimumOrderAmountsBob[index] * (1000-offer.feeBob))), \\\"T1a\\\");\\n            } else {\\n              (bool success, bytes memory data) = offer.minimumOrderAddresses[index].call{value: offer.minimumOrderAmountsBob[index] * (1000-offer.feeAlice) / 1000}(\\\"\\\");\\n              require(success, \\\"t1b\\\");\\n              require(IERC20(offer.tokenAlice).transfer(offer.minimumOrderAddresses[index], offer.minimumOrderAmountsAlice[index] * (1000-offer.feeBob) / 1000), \\\"T1b\\\");\\n            }\\n          }\\n        }\\n\\n        require(IERC20(offer.tokenAlice).transfer(offer.offerer, offer.amountRemaining), \\\"T1b\\\");\\n      }\\n    }\\n\\n    delete offer;\\n\\n    return offer;\\n  }\\n\\n\\n  function cancelBid(MarsBaseCommon.MBOffer memory offer) public returns (MarsBaseCommon.MBOffer memory) {\\n    require(offer.active == true, \\\"S0\\\");\\n    require(offer.amountAlice > 0, \\\"M3\\\");\\n\\n    require (contractType(offer.offerType) == MarsBaseCommon.ContractType.MinimumOffers, \\\"S5\\\");\\n    \\n    for (uint256 index = 0; index < offer.minimumOrderAddresses.length; index++) {\\n      if (offer.minimumOrderAddresses[index] == msg.sender && offer.minimumOrderAmountsAlice[index] != 0) {\\n        require(IERC20(offer.tokenAlice).transfer(msg.sender, offer.minimumOrderAmountsAlice[index]), \\\"T2b\\\");\\n        if (offer.minimumOrderTokens[index] != address(0)) {\\n          require(IERC20(offer.minimumOrderTokens[index]).transfer(offer.offerer, offer.minimumOrderAmountsBob[index]), \\\"T1b\\\");\\n        } else {\\n          (bool success, bytes memory data) = offer.minimumOrderAddresses[index].call{value: offer.minimumOrderAmountsBob[index]}(\\\"\\\");\\n          require(success, \\\"t1b\\\");\\n        }\\n\\n        offer.amountRemaining += offer.minimumOrderAmountsBob[index];\\n\\n        delete offer.minimumOrderAddresses[index];\\n        delete offer.minimumOrderAmountsBob[index];\\n        delete offer.minimumOrderAmountsAlice[index];\\n        delete offer.minimumOrderTokens[index];\\n      }\\n    }\\n\\n    return offer;\\n  }\\n\\n  // MB Offers Normal\\n\\n  function acceptOffer(MarsBaseCommon.MBOffer memory offer, address tokenBob, uint256 amountBob) public returns (MarsBaseCommon.MBOffer memory) {\\n    require(offer.active == true, \\\"S0\\\");\\n    require(block.timestamp < offer.deadline || offer.deadline == 0, \\\"M2\\\");\\n\\n    address acceptedTokenBob = address(0);\\n    uint256 acceptedAmountBob = 0;\\n    for (uint256 index = 0; index < offer.tokenBob.length; index++) {\\n      if (offer.tokenBob[index] == tokenBob && offer.amountBob[index] == amountBob) {\\n        acceptedTokenBob = offer.tokenBob[index];\\n        acceptedAmountBob = offer.amountBob[index];\\n      }\\n    }\\n\\n    require(acceptedTokenBob == tokenBob, \\\"T3\\\");\\n    require(acceptedAmountBob == amountBob, \\\"T4\\\");\\n\\n    uint256 amountAfterFeeAlice = offer.amountRemaining * (1000-offer.feeAlice) / 1000;\\n    uint256 amountAfterFeeBob = acceptedAmountBob * (1000-offer.feeBob) / 1000;\\n    uint256 amountFeeDex = acceptedAmountBob - amountAfterFeeBob;\\n\\n    if (acceptedTokenBob != address(0)) {\\n      require(IERC20(acceptedTokenBob).transferFrom(msg.sender, offer.payoutAddress, amountAfterFeeBob), \\\"T2a\\\");\\n      require(IERC20(offer.tokenAlice).transfer(msg.sender, amountAfterFeeAlice), \\\"T1b\\\");\\n      require(IERC20(acceptedTokenBob).transferFrom(msg.sender, address(this), amountFeeDex), \\\"T5\\\");\\n    } else {\\n      //send ether\\n      (bool success, bytes memory data) = offer.payoutAddress.call{value: amountAfterFeeBob}(\\\"\\\");\\n      require(success, \\\"t1b\\\");\\n      require(IERC20(offer.tokenAlice).transfer(msg.sender, amountAfterFeeAlice), \\\"T1b\\\");\\n    }\\n\\n    delete offer;\\n\\n    return offer;\\n  }\\n\\n  function acceptOfferPart(MarsBaseCommon.MBOffer memory offer, address tokenBob, uint256 amountBob) public returns (MarsBaseCommon.MBOffer memory) {\\n\\n    require(offer.active == true, \\\"S0\\\");\\n    require(block.timestamp < offer.deadline || offer.deadline == 0, \\\"M2\\\");\\n    require(offer.offerType == MarsBaseCommon.OfferType.ChunkedPurchase || \\n      offer.offerType == MarsBaseCommon.OfferType.LimitedTimeChunkedPurchase || \\n      offer.offerType == MarsBaseCommon.OfferType.LimitedTimeMinimumChunkedPurchase || \\n      offer.offerType == MarsBaseCommon.OfferType.MinimumChunkedPurchase, \\\"S5\\\");\\n\\n    address acceptedTokenBob = address(0);\\n    uint256 acceptedAmountBob = 0;\\n    for (uint256 index = 0; index < offer.tokenBob.length; index++) {\\n      if (offer.tokenBob[index] == tokenBob) {\\n        acceptedTokenBob = offer.tokenBob[index];\\n        acceptedAmountBob = offer.amountBob[index];\\n      }\\n    }\\n\\n    if (acceptedTokenBob == address(0)) {\\n      amountBob = msg.value;\\n    }\\n\\n    uint256 partialAmountAlice = price(amountBob, acceptedAmountBob, offer.amountAlice);\\n    uint256 partialAmountBob = price(partialAmountAlice, offer.amountAlice, acceptedAmountBob);\\n\\n    uint256 amountAfterFeeAlice = partialAmountAlice * (1000-offer.feeAlice) / 1000;\\n    uint256 amountAfterFeeBob = partialAmountBob * (1000-offer.feeBob) / 1000;\\n    uint256 amountFeeDex = partialAmountBob - amountAfterFeeBob;\\n\\n    require(amountAfterFeeBob >= 0, \\\"M8\\\");\\n    require(amountFeeDex >= 0, \\\"M7\\\");\\n\\n    require(partialAmountAlice >= offer.smallestChunkSize, \\\"M1\\\");\\n    require(amountAfterFeeAlice <= offer.amountRemaining, \\\"M10\\\");\\n\\n    if (acceptedTokenBob != address(0)) {\\n      require(IERC20(acceptedTokenBob).transferFrom(msg.sender, offer.payoutAddress, amountAfterFeeBob), \\\"T2a\\\");\\n      require(IERC20(offer.tokenAlice).transfer(msg.sender, amountAfterFeeAlice), \\\"T1b\\\");\\n      require(IERC20(acceptedTokenBob).transferFrom(msg.sender, address(this), amountFeeDex), \\\"T5\\\");\\n    } else {\\n      //send ether\\n      (bool success, bytes memory data) = offer.payoutAddress.call{value: amountAfterFeeBob}(\\\"\\\");\\n      require(success, \\\"t1b\\\");\\n      require(IERC20(offer.tokenAlice).transfer(msg.sender, amountAfterFeeAlice), \\\"T1b\\\");\\n    }\\n\\n    offer.amountRemaining -= partialAmountAlice;\\n\\n    if (offer.amountRemaining > 0 && (((offer.amountRemaining * 1000) / (offer.amountAlice) < 10) || offer.smallestChunkSize > offer.amountRemaining)) {\\n      require(IERC20(offer.tokenAlice).transfer(offer.payoutAddress, offer.amountRemaining), \\\"T1b\\\");\\n      offer.amountRemaining = 0;\\n    }\\n    \\n    if (offer.amountRemaining == 0) {\\n      delete offer;\\n    }\\n\\n    return offer;\\n  }\\n\\n  function cancelExpiredOffer(MarsBaseCommon.MBOffer memory offer) public returns (MarsBaseCommon.MBOffer memory) {\\n    if (offer.capabilities[1] == false) {\\n      return offer;\\n    }\\n\\n    require(offer.capabilities[1] == true, \\\"S1\\\");\\n    require(offer.active == true, \\\"S0\\\");\\n    require(offer.amountAlice > 0, \\\"M3\\\");\\n\\n    if (offer.tokenAlice == address(0)) {\\n      (bool success, bytes memory data) = offer.offerer.call{value: offer.amountRemaining}(\\\"\\\");\\n      require(success, \\\"t1b\\\");\\n    } else {\\n      require(IERC20(offer.tokenAlice).transfer(offer.offerer, offer.amountRemaining), \\\"T1b\\\");\\n    }\\n\\n    delete offer;\\n\\n    return offer;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/MarsBaseCommon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\n/// @title MarsBase Common\\n/// @author dOTC Marsbase\\n/// @notice This library contains struct and enum definitions for the MarsBase Exchange and MarsBase Contracts.\\nlibrary MarsBaseCommon {\\n\\n  enum OfferType {\\n    FullPurchase,\\n    LimitedTime,\\n    ChunkedPurchase,\\n    LimitedTimeChunkedPurchase,\\n    MinimumChunkedPurchase,\\n    LimitedTimeMinimumPurchase,\\n    LimitedTimeMinimumChunkedPurchase,\\n    LimitedTimeMinimumChunkedDeadlinePurchase\\n  }\\n\\n  enum OfferCloseReason {\\n    Success,\\n    CancelledBySeller,\\n    DeadlinePassed\\n  }\\n\\n  /// @dev Offers is a simple offer type, that does the exchange immediately in all cases.\\n  /// @dev Minimum Offers can hold tokens until certain criteria are met.\\n  enum ContractType {\\n    Offers,\\n    MinimumOffers\\n  }\\n\\n  struct OfferParams {\\n    bool cancelEnabled;\\n    bool modifyEnabled;\\n    bool holdTokens;\\n    uint256 feeAlice;\\n    uint256 feeBob;\\n    uint256 smallestChunkSize;\\n    uint256 deadline;\\n    uint256 minimumSize;\\n  }\\n\\n/// @notice Primary Offer Data Structure\\n/// @notice Primary Offer Data Structure\\n/// @notice smallestChunkSize - Smallest amount that may be purchased in one transaction\\n  struct MBOffer {\\n    bool active;\\n    bool minimumMet;\\n    OfferType offerType;\\n    uint256 offerId;\\n    uint256 amountAlice;\\n    uint256 feeAlice;\\n    uint256 feeBob;\\n    uint256 smallestChunkSize;\\n    uint256 minimumSize;\\n    uint256 deadline;\\n    uint256 amountRemaining;\\n    address offerer;\\n    address payoutAddress;\\n    address tokenAlice;\\n    bool[] capabilities;\\n    uint256[] amountBob;\\n    uint256[] minimumOrderAmountsAlice;\\n    uint256[] minimumOrderAmountsBob;\\n    address[] minimumOrderAddresses;\\n    address[] minimumOrderTokens;\\n    address[] tokenBob;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"minimumMet\",\"type\":\"bool\"},{\"internalType\":\"enum MarsBaseCommon.OfferType\",\"name\":\"offerType\",\"type\":\"MarsBaseCommon.OfferType\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBob\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"smallestChunkSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRemaining\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payoutAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAlice\",\"type\":\"address\"},{\"internalType\":\"bool[]\",\"name\":\"capabilities\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountBob\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumOrderAmountsAlice\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumOrderAmountsBob\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"minimumOrderAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"minimumOrderTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenBob\",\"type\":\"address[]\"}],\"internalType\":\"struct MarsBaseCommon.MBOffer\",\"name\":\"offer\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"tokenBob\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountBob\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"cancelEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"modifyEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holdTokens\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"feeAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBob\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"smallestChunkSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumSize\",\"type\":\"uint256\"}],\"internalType\":\"struct MarsBaseCommon.OfferParams\",\"name\":\"offerParameters\",\"type\":\"tuple\"}],\"name\":\"changeOfferParams\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"minimumMet\",\"type\":\"bool\"},{\"internalType\":\"enum MarsBaseCommon.OfferType\",\"name\":\"offerType\",\"type\":\"MarsBaseCommon.OfferType\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBob\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"smallestChunkSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRemaining\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payoutAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAlice\",\"type\":\"address\"},{\"internalType\":\"bool[]\",\"name\":\"capabilities\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountBob\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumOrderAmountsAlice\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumOrderAmountsBob\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"minimumOrderAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"minimumOrderTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenBob\",\"type\":\"address[]\"}],\"internalType\":\"struct MarsBaseCommon.MBOffer\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MarsBaseCommon.OfferType\",\"name\":\"offerType\",\"type\":\"MarsBaseCommon.OfferType\"}],\"name\":\"contractType\",\"outputs\":[{\"internalType\":\"enum MarsBaseCommon.ContractType\",\"name\":\"\",\"type\":\"MarsBaseCommon.ContractType\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountAlice\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"cancelEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"modifyEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holdTokens\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"feeAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBob\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"smallestChunkSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumSize\",\"type\":\"uint256\"}],\"internalType\":\"struct MarsBaseCommon.OfferParams\",\"name\":\"offerParameters\",\"type\":\"tuple\"}],\"name\":\"getOfferType\",\"outputs\":[{\"internalType\":\"enum MarsBaseCommon.OfferType\",\"name\":\"\",\"type\":\"MarsBaseCommon.OfferType\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nextOfferId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAlice\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokenBob\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amountAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amountBob\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"cancelEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"modifyEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holdTokens\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"feeAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBob\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"smallestChunkSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumSize\",\"type\":\"uint256\"}],\"internalType\":\"struct MarsBaseCommon.OfferParams\",\"name\":\"offerParameters\",\"type\":\"tuple\"}],\"name\":\"initOffer\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"minimumMet\",\"type\":\"bool\"},{\"internalType\":\"enum MarsBaseCommon.OfferType\",\"name\":\"offerType\",\"type\":\"MarsBaseCommon.OfferType\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBob\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"smallestChunkSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRemaining\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payoutAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAlice\",\"type\":\"address\"},{\"internalType\":\"bool[]\",\"name\":\"capabilities\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountBob\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumOrderAmountsAlice\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumOrderAmountsBob\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"minimumOrderAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"minimumOrderTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenBob\",\"type\":\"address[]\"}],\"internalType\":\"struct MarsBaseCommon.MBOffer\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerAmountAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerAmountBob\",\"type\":\"uint256\"}],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"minimumMet\",\"type\":\"bool\"},{\"internalType\":\"enum MarsBaseCommon.OfferType\",\"name\":\"offerType\",\"type\":\"MarsBaseCommon.OfferType\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBob\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"smallestChunkSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRemaining\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payoutAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAlice\",\"type\":\"address\"},{\"internalType\":\"bool[]\",\"name\":\"capabilities\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountBob\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumOrderAmountsAlice\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumOrderAmountsBob\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"minimumOrderAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"minimumOrderTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenBob\",\"type\":\"address[]\"}],\"internalType\":\"struct MarsBaseCommon.MBOffer\",\"name\":\"offer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"cancelEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"modifyEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holdTokens\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"feeAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBob\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"smallestChunkSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumSize\",\"type\":\"uint256\"}],\"internalType\":\"struct MarsBaseCommon.OfferParams\",\"name\":\"offerParams\",\"type\":\"tuple\"}],\"name\":\"setOfferProperties\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"minimumMet\",\"type\":\"bool\"},{\"internalType\":\"enum MarsBaseCommon.OfferType\",\"name\":\"offerType\",\"type\":\"MarsBaseCommon.OfferType\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAlice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBob\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"smallestChunkSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRemaining\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payoutAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAlice\",\"type\":\"address\"},{\"internalType\":\"bool[]\",\"name\":\"capabilities\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountBob\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumOrderAmountsAlice\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minimumOrderAmountsBob\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"minimumOrderAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"minimumOrderTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenBob\",\"type\":\"address[]\"}],\"internalType\":\"struct MarsBaseCommon.MBOffer\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MarsBase", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}