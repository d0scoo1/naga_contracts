{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n* @dev to mint POE tokens\r\n */\r\ninterface PoExtended{\r\n    function mint(address) external returns (bool);\r\n}\r\n\r\n/**\r\n* @title NFT\r\n* @dev ERC721 contract that holds the bonus NFTs\r\n */\r\ninterface INFT{\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Trees proofs.\r\n *\r\n * The proofs can be generated using the JavaScript library\r\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\r\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\r\n *\r\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n}\r\n\r\n/**\r\n* @title PoExtended\r\n* @author Carson Case [carsonpcase@gmail.com]\r\n* @notice PoExtended is a POE token with owner delegated Admins and a merkle claim system\r\n*/\r\n\r\n/**\r\n* @title MerkleMinter\r\n* @author Carson Case > carsonpcase@gmail.com\r\n* @author Zane Huffman > @jeffthedunker\r\n* @dev is ownable. For now, by deployer, but can be changed to DAO\r\n */\r\n\r\ncontract SlimMerkleMinter is Ownable{\r\n    using MerkleProof for bytes32[];\r\n    /// @dev the merkle root which CAN be updated\r\n    bytes32 public merkleRoot;\r\n\r\n    \r\n    mapping(address => bool) admins;\r\n\r\n    //Treasury address\r\n    address payable public treasury;\r\n\r\n    //Base commission rate for refferals. Decimal expressed as an interger with decimal at 10^3 place (1 = 0.1%, 10 = 1%).\r\n    uint256 public baseCommission;\r\n\r\n    //xGDAO address\r\n    address public xGDAO;\r\n\r\n    //POE address\r\n    address public POEContract;\r\n\r\n    //Cost to sign up\r\n    uint256 public basePrice;\r\n\r\n    //NFT bonus address\r\n    address public bonusNFTAddress;\r\n\r\n    //Free if a users holds this much xGDAO or more\r\n    uint256 public minXGDAOFree;\r\n\r\n    //Nft bonus info\r\n    struct nftBonus{\r\n        uint128 id;\r\n        //Decimal expressed as an interger with decimal at 10^18 place.\r\n        uint128 multiplier;\r\n    }\r\n\r\n    //Array of NFT bonus info\r\n    nftBonus[] bonusNFTs; \r\n\r\n    /**\r\n    * @notice arrays must have the same length \r\n    * @param _treasury address to receive payments\r\n    * @param _basePrice for starting price\r\n    * @param _bonusNFTAddress to look up bonus NFTs\r\n    * @param _commission base referral commission before bonus\r\n    * @param _bonusNFTIDs ids of bonus NFTs (length must match multipliers)\r\n    * @param _bonusNFTMultipliers multipliers of bonus NFTs (length must match IDs) 100% is 10^18\r\n     */\r\n    constructor(\r\n        address payable _treasury,\r\n        address _xGDAOAddress,\r\n        uint256 _basePrice,\r\n        address _bonusNFTAddress,\r\n        uint256 _commission,\r\n        uint128[] memory _bonusNFTIDs,\r\n        uint128[] memory _bonusNFTMultipliers\r\n        ) \r\n        Ownable()\r\n        {\r\n        bonusNFTAddress = _bonusNFTAddress;\r\n        _addBonusNFTs(_bonusNFTIDs, _bonusNFTMultipliers);\r\n\r\n        treasury = _treasury;\r\n        xGDAO = _xGDAOAddress;\r\n        basePrice = _basePrice;\r\n        baseCommission = _commission;\r\n\r\n    }\r\n\r\n    /// @dev some functions only callable by approved Admins\r\n    modifier onlyAdmin(){\r\n        require(admins[msg.sender], \"must be approved by owner to call this function\");\r\n        _;\r\n    }\r\n\r\n     /// @dev only owner can add Admins\r\n    function addAdmin(address _admin) external onlyOwner{\r\n        require(admins[_admin] != true, \"Admin is already approved\");\r\n        admins[_admin] = true;\r\n    }\r\n\r\n    /// @dev owner can remove them too\r\n    function removeAdmin(address _admin) external onlyOwner{\r\n        require(admins[_admin] != false, \"Admin is already not-approved\");\r\n        admins[_admin] = false;\r\n    }\r\n\r\n    /// @dev A Admin can forefit their minting status (useful for contracts)\r\n    function forefitAdminRole()external{\r\n        require(admins[msg.sender] == true, \"msg.sender must be an approved Admin\");\r\n        admins[msg.sender] = false;\r\n    }\r\n\r\n    /// @dev set xGDAO address\r\n    function setXGDAOAddress(address _new) external onlyAdmin{\r\n        xGDAO = _new;\r\n    }\r\n\r\n    /// @dev set POE Contract address\r\n    function setPOEContractAddress(address _new) external onlyAdmin{\r\n        POEContract = _new;\r\n    }\r\n\r\n    /// @dev set minXGDAO. If zero, no free amount\r\n    function setMinXGDAOFree(uint _new) external onlyAdmin{\r\n        minXGDAOFree = _new;\r\n    }\r\n\r\n    function updateMerkleRoot(bytes32 _new) external onlyAdmin{\r\n        merkleRoot = _new;\r\n    }\r\n    /**\r\n    * @notice purchase function. Can only be called once by an address\r\n    * @param _referrer must have an auth token. Pass 0 address if no referrer\r\n     */\r\n    function purchasePOE(address payable _referrer, /*bytes32 _hashedRef,*/ bytes32[] memory proof) external payable{\r\n\t\t\r\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\r\n        require(proof.verify(merkleRoot,leaf), \"Address not eligible for claim\");\r\n\r\n        address payable referrer = _referrer;\r\n\r\n        uint256 price = basePrice;\r\n        if(minXGDAOFree != 0 && IERC20(xGDAO).balanceOf(msg.sender) >= minXGDAOFree){\r\n            price = 0;\r\n        }\r\n\r\n        require(msg.sender != _referrer, \"You cannot use yourself as a referrer\");\r\n        require(msg.value == price, \"You must pay the exact price to purchase. Call the getPrice() function to see the price in wei\");\r\n\r\n        if(price > 0){\r\n            //Give commisson if there's a referrer\r\n            if(referrer != address(0))\r\n            {\r\n                //Calculate commission and subtract from price to avoid rounding errors\r\n                uint256 commission = getCommission(price, referrer);\r\n                referrer.transfer(commission);\r\n                treasury.transfer(price-commission);\r\n                //If not, treasury gets all the price\r\n            }else{\r\n                treasury.transfer(price);\r\n            }\r\n        }\r\n\r\n        //Mint a POE\r\n        PoExtended(POEContract).mint(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice for owner to change base commission\r\n    * @param _new is new commission\r\n     */\r\n    function changeBaseCommission(uint256 _new) external onlyOwner {\r\n        baseCommission = _new;\r\n    }\r\n\r\n    /**\r\n    * @notice for owner to change the price curve contract address\r\n    * @param _new is the new address\r\n     */\r\n    function setBasePrice(uint256 _new) external onlyAdmin{\r\n        basePrice = _new;\r\n    }\r\n    \r\n    /**\r\n    * @notice for owner to add some new bonus NFTs\r\n    * @dev see _addBonusNFTs\r\n    * @param _bonusNFTIDs array of IDs\r\n    * @param  _bonusNFTMultipliers array of multipliers\r\n     */\r\n    function addBonusNFTs(uint128[] memory _bonusNFTIDs, uint128[] memory _bonusNFTMultipliers) public onlyOwner{\r\n        _addBonusNFTs(_bonusNFTIDs, _bonusNFTMultipliers);\r\n    }\r\n\t\r\n    /**\r\n    * @notice function returns the commission based on base commission rate, NFT bonus, and price\r\n    * @param _price is passed in, but should be calculated with getPrice()\r\n    * @param _referrer is to look up NFT bonuses\r\n    * @return the commission ammount\r\n     */\r\n    function getCommission(uint256 _price, address _referrer) internal view returns(uint256){\r\n        uint128 bonus = getNFTBonus(_referrer);\r\n        uint256 commission;\r\n        if(bonus > 0){\r\n            commission = baseCommission + ((baseCommission * bonus) / 1000);\r\n        }else{\r\n            commission = baseCommission;\r\n        }      \r\n        return((_price * commission) / 1000);\r\n    }\r\n\r\n    /**\r\n    * @notice function to get the NFT bonus of a person\r\n    * @param _referrer is the referrer address\r\n    * @return the sum of bonuses they own\r\n     */\r\n    function getNFTBonus(address _referrer) public view returns(uint128){\r\n        uint128 bonus = 0;\r\n        INFT nft = INFT(bonusNFTAddress);\r\n        //Loop through nfts and add up bonuses that the referrer owns\r\n        for(uint8 i = 0; i < bonusNFTs.length; i++){\r\n            if(nft.balanceOf(_referrer, bonusNFTs[i].id) > 0){\r\n                bonus += bonusNFTs[i].multiplier;\r\n            }\r\n        }\r\n        return bonus;\r\n    }\r\n\r\n    /**\r\n    * @notice private function to add new NFTs as bonuses \r\n    * @param _bonusNFTIDs array of ids matching multipliers\r\n    * @param _bonusNFTMultipliers array of multipliers matching ids\r\n     */\r\n    function _addBonusNFTs(uint128[] memory _bonusNFTIDs, uint128[] memory _bonusNFTMultipliers) private{\r\n        require(_bonusNFTIDs.length == _bonusNFTMultipliers.length, \"The array parameters must have the same length\");\r\n        //Add all the NFTs\r\n        for(uint8 i = 0; i < _bonusNFTIDs.length; i++){\r\n            bonusNFTs.push(\r\n                nftBonus(_bonusNFTIDs[i],_bonusNFTMultipliers[i])\r\n            );\r\n        }\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_xGDAOAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_basePrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_bonusNFTAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_commission\",\"type\":\"uint256\"},{\"internalType\":\"uint128[]\",\"name\":\"_bonusNFTIDs\",\"type\":\"uint128[]\"},{\"internalType\":\"uint128[]\",\"name\":\"_bonusNFTMultipliers\",\"type\":\"uint128[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"POEContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128[]\",\"name\":\"_bonusNFTIDs\",\"type\":\"uint128[]\"},{\"internalType\":\"uint128[]\",\"name\":\"_bonusNFTMultipliers\",\"type\":\"uint128[]\"}],\"name\":\"addBonusNFTs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusNFTAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"changeBaseCommission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forefitAdminRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"getNFTBonus\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minXGDAOFree\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"purchasePOE\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"setBasePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"setMinXGDAOFree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setPOEContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setXGDAOAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_new\",\"type\":\"bytes32\"}],\"name\":\"updateMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xGDAO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SlimMerkleMinter", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000007f651fa68337208ed54e92dde8a52c5d8b629a5c000000000000000000000000306978da6ebee060375f35418744f85c1cb6b3530000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d07dc4262bcdbf85190c01c996b4c06a461d243000000000000000000000000000000000000000000000000000000000000000fa00000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000063e7b0000000000000000000000000000000000000000000000000000000000063e8500000000000000000000000000000000000000000000000000000000000640900000000000000000000000000000000000000000000000000000000000063e9a000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000009600000000000000000000000000000000000000000000000000000000000000c8", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5e499de09df590f021285270e307b3ec6ed146af453114dfe03990249ae87d84"}]}