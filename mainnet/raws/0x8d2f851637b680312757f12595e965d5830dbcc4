{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\npragma solidity ^0.8.4;\n\ninterface IPriceCalculator {\n    // 1st arg: initial price [wad]\n    // 2nd arg: seconds since auction start [seconds]\n    // returns: current auction price [wad]\n    function price(uint256, uint256) external view returns (uint256);\n}\ninterface ICodex {\n    function init(address vault) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address,\n        bytes32,\n        uint256\n    ) external;\n\n    function credit(address) external view returns (uint256);\n\n    function unbackedDebt(address) external view returns (uint256);\n\n    function balances(\n        address,\n        uint256,\n        address\n    ) external view returns (uint256);\n\n    function vaults(address vault)\n        external\n        view\n        returns (\n            uint256 totalNormalDebt,\n            uint256 rate,\n            uint256 debtCeiling,\n            uint256 debtFloor\n        );\n\n    function positions(\n        address vault,\n        uint256 tokenId,\n        address position\n    ) external view returns (uint256 collateral, uint256 normalDebt);\n\n    function globalDebt() external view returns (uint256);\n\n    function globalUnbackedDebt() external view returns (uint256);\n\n    function globalDebtCeiling() external view returns (uint256);\n\n    function delegates(address, address) external view returns (uint256);\n\n    function grantDelegate(address) external;\n\n    function revokeDelegate(address) external;\n\n    function modifyBalance(\n        address,\n        uint256,\n        address,\n        int256\n    ) external;\n\n    function transferBalance(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function transferCredit(\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function modifyCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function transferCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function confiscateCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function settleUnbackedDebt(uint256 debt) external;\n\n    function createUnbackedDebt(\n        address debtor,\n        address creditor,\n        uint256 debt\n    ) external;\n\n    function modifyRate(\n        address vault,\n        address creditor,\n        int256 rate\n    ) external;\n\n    function lock() external;\n}\ninterface IPriceFeed {\n    function peek() external returns (bytes32, bool);\n\n    function read() external view returns (bytes32);\n}\n\ninterface ICollybus {\n    function vaults(address) external view returns (uint128, uint128);\n\n    function spots(address) external view returns (uint256);\n\n    function rates(uint256) external view returns (uint256);\n\n    function rateIds(address, uint256) external view returns (uint256);\n\n    function redemptionPrice() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint128 data\n    ) external;\n\n    function setParam(\n        address vault,\n        uint256 tokenId,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function updateDiscountRate(uint256 rateId, uint256 rate) external;\n\n    function updateSpot(address token, uint256 spot) external;\n\n    function read(\n        address vault,\n        address underlier,\n        uint256 tokenId,\n        uint256 maturity,\n        bool net\n    ) external view returns (uint256 price);\n\n    function lock() external;\n}\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\ninterface IDebtAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function tokenToSellBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function aer() external view returns (address);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(\n        address recipient,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock() external;\n\n    function cancelAuction(uint256 id) external;\n}\ninterface ISurplusAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(uint256 creditToSell, uint256 bid) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 creditToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock(uint256 credit) external;\n\n    function cancelAuction(uint256 id) external;\n}\n\ninterface IAer {\n    function codex() external view returns (ICodex);\n\n    function surplusAuction() external view returns (ISurplusAuction);\n\n    function debtAuction() external view returns (IDebtAuction);\n\n    function debtQueue(uint256) external view returns (uint256);\n\n    function queuedDebt() external view returns (uint256);\n\n    function debtOnAuction() external view returns (uint256);\n\n    function auctionDelay() external view returns (uint256);\n\n    function debtAuctionSellSize() external view returns (uint256);\n\n    function debtAuctionBidSize() external view returns (uint256);\n\n    function surplusAuctionSellSize() external view returns (uint256);\n\n    function surplusBuffer() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function queueDebt(uint256 debt) external;\n\n    function unqueueDebt(uint256 queuedAt) external;\n\n    function settleDebtWithSurplus(uint256 debt) external;\n\n    function settleAuctionedDebt(uint256 debt) external;\n\n    function startDebtAuction() external returns (uint256 auctionId);\n\n    function startSurplusAuction() external returns (uint256 auctionId);\n\n    function transferCredit(address to, uint256 credit) external;\n\n    function lock() external;\n}\ninterface ILimes {\n    function codex() external view returns (ICodex);\n\n    function aer() external view returns (IAer);\n\n    function vaults(address)\n        external\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function live() external view returns (uint256);\n\n    function globalMaxDebtOnAuction() external view returns (uint256);\n\n    function globalDebtOnAuction() external view returns (uint256);\n\n    function setParam(bytes32 param, address data) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        address collateralAuction\n    ) external;\n\n    function liquidationPenalty(address vault) external view returns (uint256);\n\n    function liquidate(\n        address vault,\n        uint256 tokenId,\n        address position,\n        address keeper\n    ) external returns (uint256 auctionId);\n\n    function liquidated(\n        address vault,\n        uint256 tokenId,\n        uint256 debt\n    ) external;\n\n    function lock() external;\n}\n\ninterface INoLossCollateralAuction {\n    function vaults(address)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            ICollybus,\n            IPriceCalculator\n        );\n\n    function codex() external view returns (ICodex);\n\n    function limes() external view returns (ILimes);\n\n    function aer() external view returns (IAer);\n\n    function feeTip() external view returns (uint64);\n\n    function flatTip() external view returns (uint192);\n\n    function auctionCounter() external view returns (uint256);\n\n    function activeAuctions(uint256) external view returns (uint256);\n\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            address,\n            uint96,\n            uint256\n        );\n\n    function stopped() external view returns (uint256);\n\n    function init(address vault, address collybus) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        address data\n    ) external;\n\n    function startAuction(\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address keeper\n    ) external returns (uint256 auctionId);\n\n    function redoAuction(uint256 auctionId, address keeper) external;\n\n    function takeCollateral(\n        uint256 auctionId,\n        uint256 collateralAmount,\n        uint256 maxPrice,\n        address recipient,\n        bytes calldata data\n    ) external;\n\n    function count() external view returns (uint256);\n\n    function list() external view returns (uint256[] memory);\n\n    function getStatus(uint256 auctionId)\n        external\n        view\n        returns (\n            bool needsRedo,\n            uint256 price,\n            uint256 collateralToSell,\n            uint256 debt\n        );\n\n    function updateAuctionDebtFloor(address vault) external;\n\n    function cancelAuction(uint256 auctionId) external;\n}// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n\ninterface IVault {\n    function codex() external view returns (ICodex);\n\n    function collybus() external view returns (ICollybus);\n\n    function token() external view returns (address);\n\n    function tokenScale() external view returns (uint256);\n\n    function underlierToken() external view returns (address);\n\n    function underlierScale() external view returns (uint256);\n\n    function vaultType() external view returns (bytes32);\n\n    function live() external view returns (uint256);\n\n    function lock() external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function maturity(uint256 tokenId) external returns (uint256);\n\n    function fairPrice(\n        uint256 tokenId,\n        bool net,\n        bool face\n    ) external view returns (uint256);\n\n    function enter(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n\n    function exit(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n}\ninterface IGuarded {\n    function ANY_SIG() external view returns (bytes32);\n\n    function ANY_CALLER() external view returns (address);\n\n    function allowCaller(bytes32 sig, address who) external;\n\n    function blockCaller(bytes32 sig, address who) external;\n\n    function canCall(bytes32 sig, address who) external view returns (bool);\n}\n/// @title Guarded\n/// @notice Mixin implementing an authentication scheme on a method level\nabstract contract Guarded is IGuarded {\n    /// ======== Custom Errors ======== ///\n\n    error Guarded__notRoot();\n    error Guarded__notGranted();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Wildcard for granting a caller to call every guarded method\n    bytes32 public constant override ANY_SIG = keccak256(\"ANY_SIG\");\n    /// @notice Wildcard for granting a caller to call every guarded method\n    address public constant override ANY_CALLER = address(uint160(uint256(bytes32(keccak256(\"ANY_CALLER\")))));\n\n    /// @notice Mapping storing who is granted to which method\n    /// @dev Method Signature => Caller => Bool\n    mapping(bytes32 => mapping(address => bool)) private _canCall;\n\n    /// ======== Events ======== ///\n\n    event AllowCaller(bytes32 sig, address who);\n    event BlockCaller(bytes32 sig, address who);\n\n    constructor() {\n        // set root\n        _setRoot(msg.sender);\n    }\n\n    /// ======== Auth ======== ///\n\n    modifier callerIsRoot() {\n        if (_canCall[ANY_SIG][msg.sender]) {\n            _;\n        } else revert Guarded__notRoot();\n    }\n\n    modifier checkCaller() {\n        if (canCall(msg.sig, msg.sender)) {\n            _;\n        } else revert Guarded__notGranted();\n    }\n\n    /// @notice Grant the right to call method `sig` to `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function allowCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = true;\n        emit AllowCaller(sig, who);\n    }\n\n    /// @notice Revoke the right to call method `sig` from `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should not be able to call `sig` anymore\n    function blockCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = false;\n        emit BlockCaller(sig, who);\n    }\n\n    /// @notice Returns if `who` can call `sig`\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function canCall(bytes32 sig, address who) public view override returns (bool) {\n        return (_canCall[sig][who] || _canCall[ANY_SIG][who] || _canCall[sig][ANY_CALLER]);\n    }\n\n    /// @notice Sets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be set as root\n    function _setRoot(address root) internal {\n        _canCall[ANY_SIG][root] = true;\n        emit AllowCaller(ANY_SIG, root);\n    }\n\n    /// @notice Unsets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be unset as root\n    function _unsetRoot(address root) internal {\n        _canCall[ANY_SIG][root] = false;\n        emit AllowCaller(ANY_SIG, root);\n    }\n}// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n\nuint256 constant MLN = 10**6;\nuint256 constant BLN = 10**9;\nuint256 constant WAD = 10**18;\nuint256 constant RAY = 10**18;\nuint256 constant RAD = 10**18;\n\n/* solhint-disable func-visibility, no-inline-assembly */\n\nerror Math__toInt256_overflow(uint256 x);\n\nfunction toInt256(uint256 x) pure returns (int256) {\n    if (x > uint256(type(int256).max)) revert Math__toInt256_overflow(x);\n    return int256(x);\n}\n\nfunction min(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x <= y ? x : y;\n    }\n}\n\nfunction max(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x >= y ? x : y;\n    }\n}\n\nerror Math__diff_overflow(uint256 x, uint256 y);\n\nfunction diff(uint256 x, uint256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) - int256(y);\n        if (!(int256(x) >= 0 && int256(y) >= 0)) revert Math__diff_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow(uint256 x, uint256 y);\n\nfunction add(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add_overflow(x, y);\n    }\n}\n\nerror Math__add48_overflow(uint256 x, uint256 y);\n\nfunction add48(uint48 x, uint48 y) pure returns (uint48 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add48_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow_signed(uint256 x, int256 y);\n\nfunction add(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x + uint256(y);\n        if (!(y >= 0 || z <= x)) revert Math__add_overflow_signed(x, y);\n        if (!(y <= 0 || z >= x)) revert Math__add_overflow_signed(x, y);\n    }\n}\n\nerror Math__sub_overflow(uint256 x, uint256 y);\n\nfunction sub(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x - y) > x) revert Math__sub_overflow(x, y);\n    }\n}\n\nerror Math__sub_overflow_signed(uint256 x, int256 y);\n\nfunction sub(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x - uint256(y);\n        if (!(y <= 0 || z <= x)) revert Math__sub_overflow_signed(x, y);\n        if (!(y >= 0 || z >= x)) revert Math__sub_overflow_signed(x, y);\n    }\n}\n\nerror Math__mul_overflow(uint256 x, uint256 y);\n\nfunction mul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (!(y == 0 || (z = x * y) / y == x)) revert Math__mul_overflow(x, y);\n    }\n}\n\nerror Math__mul_overflow_signed(uint256 x, int256 y);\n\nfunction mul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) * y;\n        if (int256(x) < 0) revert Math__mul_overflow_signed(x, y);\n        if (!(y == 0 || z / y == int256(x))) revert Math__mul_overflow_signed(x, y);\n    }\n}\n\nfunction wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, y) / WAD;\n    }\n}\n\nfunction wmul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = mul(x, y) / int256(WAD);\n    }\n}\n\nerror Math__div_overflow(uint256 x, uint256 y);\n\nfunction div(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (y == 0) revert Math__div_overflow(x, y);\n        return x / y;\n    }\n}\n\nfunction wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, WAD) / y;\n    }\n}\n\n// optimized version from dss PR #78\nfunction wpow(\n    uint256 x,\n    uint256 n,\n    uint256 b\n) pure returns (uint256 z) {\n    unchecked {\n        assembly {\n            switch n\n            case 0 {\n                z := b\n            }\n            default {\n                switch x\n                case 0 {\n                    z := 0\n                }\n                default {\n                    switch mod(n, 2)\n                    case 0 {\n                        z := b\n                    }\n                    default {\n                        z := x\n                    }\n                    let half := div(b, 2) // for rounding.\n                    for {\n                        n := div(n, 2)\n                    } n {\n                        n := div(n, 2)\n                    } {\n                        let xx := mul(x, x)\n                        if shr(128, x) {\n                            revert(0, 0)\n                        }\n                        let xxRound := add(xx, half)\n                        if lt(xxRound, xx) {\n                            revert(0, 0)\n                        }\n                        x := div(xxRound, b)\n                        if mod(n, 2) {\n                            let zx := mul(z, x)\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                                revert(0, 0)\n                            }\n                            let zxRound := add(zx, half)\n                            if lt(zxRound, zx) {\n                                revert(0, 0)\n                            }\n                            z := div(zxRound, b)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/* solhint-disable func-visibility, no-inline-assembly */\n/// @title Codex\n/// @notice `Codex` is responsible for the accounting of collateral and debt balances\n/// Uses Vat.sol from DSS (MakerDAO) / SafeEngine.sol from GEB (Reflexer Labs) as a blueprint\n/// Changes from Vat.sol / SafeEngine.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract Codex is Guarded, ICodex {\n    /// ======== Custom Errors ======== ///\n\n    error Codex__init_vaultAlreadyInit();\n    error Codex__setParam_notLive();\n    error Codex__setParam_unrecognizedParam();\n    error Codex__transferBalance_notAllowed();\n    error Codex__transferCredit_notAllowed();\n    error Codex__modifyCollateralAndDebt_notLive();\n    error Codex__modifyCollateralAndDebt_vaultNotInit();\n    error Codex__modifyCollateralAndDebt_ceilingExceeded();\n    error Codex__modifyCollateralAndDebt_notSafe();\n    error Codex__modifyCollateralAndDebt_notAllowedSender();\n    error Codex__modifyCollateralAndDebt_notAllowedCollateralizer();\n    error Codex__modifyCollateralAndDebt_notAllowedDebtor();\n    error Codex__modifyCollateralAndDebt_debtFloor();\n    error Codex__transferCollateralAndDebt_notAllowed();\n    error Codex__transferCollateralAndDebt_notSafeSrc();\n    error Codex__transferCollateralAndDebt_notSafeDst();\n    error Codex__transferCollateralAndDebt_debtFloorSrc();\n    error Codex__transferCollateralAndDebt_debtFloorDst();\n    error Codex__modifyRate_notLive();\n\n    /// ======== Storage ======== ///\n\n    // Vault Data\n    struct Vault {\n        // Total Normalised Debt in Vault [wad]\n        uint256 totalNormalDebt;\n        // Vault's Accumulation Rate [wad]\n        uint256 rate;\n        // Vault's Debt Ceiling [wad]\n        uint256 debtCeiling;\n        // Debt Floor for Positions corresponding to this Vault [wad]\n        uint256 debtFloor;\n    }\n    // Position Data\n    struct Position {\n        // Locked Collateral in Position [wad]\n        uint256 collateral;\n        // Normalised Debt (gross debt before rate is applied) generated by Position [wad]\n        uint256 normalDebt;\n    }\n\n    /// @notice Map of delegatees who can modify collateral, debt and credit on behalf of a delegator\n    /// @dev Delegator => Delegatee => hasDelegate\n    mapping(address => mapping(address => uint256)) public override delegates;\n    /// @notice Vaults\n    /// @dev Vault => Vault Data\n    mapping(address => Vault) public override vaults;\n    /// @notice Positions\n    /// @dev Vault => TokenId => Owner => Position\n    mapping(address => mapping(uint256 => mapping(address => Position))) public override positions;\n    /// @notice Token balances not put up for collateral in a Position\n    /// @dev Vault => TokenId => Owner => Balance [wad]\n    mapping(address => mapping(uint256 => mapping(address => uint256))) public override balances;\n    /// @notice Credit balances\n    /// @dev Account => Credit [wad]\n    mapping(address => uint256) public override credit;\n    /// @notice Unbacked Debt balances\n    /// @dev Account => Unbacked Debt [wad]\n    mapping(address => uint256) public override unbackedDebt;\n\n    /// @notice Global Debt (incl. rate) outstanding == Credit Issued [wad]\n    uint256 public override globalDebt;\n    /// @notice Global Unbacked Debt (incl. rate) oustanding == Total Credit [wad]\n    uint256 public override globalUnbackedDebt;\n    /// @notice Global Debt Ceiling [wad]\n    uint256 public override globalDebtCeiling;\n\n    /// @notice Boolean indicating if this contract is live (0 - not live, 1 - live)\n    uint256 public live;\n\n    /// ======== Events ======== ///\n    event Init(address indexed vault);\n    event SetParam(address indexed vault, bytes32 indexed param, uint256 data);\n    event GrantDelegate(address indexed delegator, address indexed delegatee);\n    event RevokeDelegate(address indexed delegator, address indexed delegatee);\n    event ModifyBalance(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        int256 amount,\n        uint256 balance\n    );\n    event TransferBalance(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed src,\n        address dst,\n        uint256 amount,\n        uint256 srcBalance,\n        uint256 dstBalance\n    );\n    event TransferCredit(\n        address indexed src,\n        address indexed dst,\n        uint256 amount,\n        uint256 srcCredit,\n        uint256 dstCredit\n    );\n    event ModifyCollateralAndDebt(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        address collateralizer,\n        address creditor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    );\n    event TransferCollateralAndDebt(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    );\n    event ConfiscateCollateralAndDebt(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    );\n    event SettleUnbackedDebt(address indexed debtor, uint256 debt);\n    event CreateUnbackedDebt(address indexed debtor, address indexed creditor, uint256 debt);\n    event ModifyRate(address indexed vault, address indexed creditor, int256 deltaRate);\n    event Lock();\n\n    constructor() Guarded() {\n        live = 1;\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Initializes a new Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    function init(address vault) external override checkCaller {\n        if (vaults[vault].rate != 0) revert Codex__init_vaultAlreadyInit();\n        vaults[vault].rate = WAD;\n        emit Init(vault);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (live == 0) revert Codex__setParam_notLive();\n        if (param == \"globalDebtCeiling\") globalDebtCeiling = data;\n        else revert Codex__setParam_unrecognizedParam();\n        emit SetParam(address(0), param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external override checkCaller {\n        if (live == 0) revert Codex__setParam_notLive();\n        if (param == \"debtCeiling\") vaults[vault].debtCeiling = data;\n        else if (param == \"debtFloor\") vaults[vault].debtFloor = data;\n        else revert Codex__setParam_unrecognizedParam();\n        emit SetParam(vault, param, data);\n    }\n\n    /// ======== Caller Delegation ======== ///\n\n    /// @notice Grants the delegatee the ability to modify collateral, debt and credit balances on behalf of the caller\n    /// @param delegatee Address of the delegatee\n    function grantDelegate(address delegatee) external override {\n        delegates[msg.sender][delegatee] = 1;\n        emit GrantDelegate(msg.sender, delegatee);\n    }\n\n    /// @notice Revokes the delegatee's ability to modify collateral, debt and credit balances on behalf of the caller\n    /// @param delegatee Address of the delegatee\n    function revokeDelegate(address delegatee) external override {\n        delegates[msg.sender][delegatee] = 0;\n        emit RevokeDelegate(msg.sender, delegatee);\n    }\n\n    /// @notice Checks the delegate\n    /// @param delegator Address of the delegator\n    /// @param delegatee Address of the delegatee\n    /// @return True if delegate is granted\n    function hasDelegate(address delegator, address delegatee) internal view returns (bool) {\n        return delegator == delegatee || delegates[delegator][delegatee] == 1;\n    }\n\n    /// ======== Credit and Token Balance Administration ======== ///\n\n    /// @notice Updates the token balance for a `user`\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param user Address of the user\n    /// @param amount Amount to add (positive) or subtract (negative) [wad]\n    function modifyBalance(\n        address vault,\n        uint256 tokenId,\n        address user,\n        int256 amount\n    ) external override checkCaller {\n        balances[vault][tokenId][user] = add(balances[vault][tokenId][user], amount);\n        emit ModifyBalance(vault, tokenId, user, amount, balances[vault][tokenId][user]);\n    }\n\n    /// @notice Transfer an `amount` of tokens from `src` to `dst`\n    /// @dev Sender has to be delegated by `src`\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param src From address\n    /// @param dst To address\n    /// @param amount Amount to be transferred [wad]\n    function transferBalance(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        uint256 amount\n    ) external override {\n        if (!hasDelegate(src, msg.sender)) revert Codex__transferBalance_notAllowed();\n        balances[vault][tokenId][src] = sub(balances[vault][tokenId][src], amount);\n        balances[vault][tokenId][dst] = add(balances[vault][tokenId][dst], amount);\n        emit TransferBalance(\n            vault,\n            tokenId,\n            src,\n            dst,\n            amount,\n            balances[vault][tokenId][src],\n            balances[vault][tokenId][dst]\n        );\n    }\n\n    /// @notice Transfer an `amount` of Credit from `src` to `dst`\n    /// @dev Sender has to be delegated by `src`\n    /// @param src From address\n    /// @param dst To address\n    /// @param amount Amount to be transferred [wad]\n    function transferCredit(\n        address src,\n        address dst,\n        uint256 amount\n    ) external override {\n        if (!hasDelegate(src, msg.sender)) revert Codex__transferCredit_notAllowed();\n        credit[src] = sub(credit[src], amount);\n        credit[dst] = add(credit[dst], amount);\n        emit TransferCredit(src, dst, amount, credit[src], credit[dst]);\n    }\n\n    /// ======== Position Administration ======== ///\n\n    /// @notice Modifies a Position's collateral and debt balances\n    /// @dev Checks that the global debt ceiling and the vault's debt ceiling have not been exceeded,\n    /// that the Position is still safe after the modification,\n    /// that the sender is delegated by the owner if the collateral-to-debt ratio decreased,\n    /// that the sender is delegated by the collateralizer if new collateral is put up,\n    /// that the sender is delegated by the creditor if debt is settled,\n    /// and that the vault debt floor is exceeded\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param user Address of the user\n    /// @param collateralizer Address of who puts up or receives the collateral delta\n    /// @param creditor Address of who provides or receives the credit delta for the debt delta\n    /// @param deltaCollateral Amount of collateral to put up (+) for or remove (-) from this Position [wad]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) on this Position [wad]\n    function modifyCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address creditor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external override {\n        // system is live\n        if (live == 0) revert Codex__modifyCollateralAndDebt_notLive();\n\n        Position memory p = positions[vault][tokenId][user];\n        Vault memory v = vaults[vault];\n        // vault has been initialised\n        if (v.rate == 0) revert Codex__modifyCollateralAndDebt_vaultNotInit();\n\n        p.collateral = add(p.collateral, deltaCollateral);\n        p.normalDebt = add(p.normalDebt, deltaNormalDebt);\n        v.totalNormalDebt = add(v.totalNormalDebt, deltaNormalDebt);\n\n        int256 deltaDebt = wmul(v.rate, deltaNormalDebt);\n        uint256 debt = wmul(v.rate, p.normalDebt);\n        globalDebt = add(globalDebt, deltaDebt);\n\n        // either debt has decreased, or debt ceilings are not exceeded\n        if (deltaNormalDebt > 0 && (wmul(v.totalNormalDebt, v.rate) > v.debtCeiling || globalDebt > globalDebtCeiling))\n            revert Codex__modifyCollateralAndDebt_ceilingExceeded();\n        // position is either less risky than before, or it is safe\n        if (\n            (deltaNormalDebt > 0 || deltaCollateral < 0) &&\n            debt > wmul(p.collateral, IVault(vault).fairPrice(tokenId, true, false))\n        ) revert Codex__modifyCollateralAndDebt_notSafe();\n\n        // position is either more safe, or the owner consents\n        if ((deltaNormalDebt > 0 || deltaCollateral < 0) && !hasDelegate(user, msg.sender))\n            revert Codex__modifyCollateralAndDebt_notAllowedSender();\n        // collateralizer consents if new collateral is put up\n        if (deltaCollateral > 0 && !hasDelegate(collateralizer, msg.sender))\n            revert Codex__modifyCollateralAndDebt_notAllowedCollateralizer();\n\n        // creditor consents if debt is settled with credit\n        if (deltaNormalDebt < 0 && !hasDelegate(creditor, msg.sender))\n            revert Codex__modifyCollateralAndDebt_notAllowedDebtor();\n\n        // position has no debt, or a non-dusty amount\n        if (p.normalDebt != 0 && debt < v.debtFloor) revert Codex__modifyCollateralAndDebt_debtFloor();\n\n        balances[vault][tokenId][collateralizer] = sub(balances[vault][tokenId][collateralizer], deltaCollateral);\n        credit[creditor] = add(credit[creditor], deltaDebt);\n\n        positions[vault][tokenId][user] = p;\n        vaults[vault] = v;\n\n        emit ModifyCollateralAndDebt(vault, tokenId, user, collateralizer, creditor, deltaCollateral, deltaNormalDebt);\n    }\n\n    /// @notice Transfers a Position's collateral and debt balances to another Position\n    /// @dev Checks that the sender is delegated by `src` and `dst` Position owners,\n    /// that the `src` and `dst` Positions are still safe after the transfer,\n    /// and that the `src` and `dst` Positions' debt exceed the vault's debt floor\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param src Address of the `src` Positions owner\n    /// @param dst Address of the `dst` Positions owner\n    /// @param deltaCollateral Amount of collateral to send to (+) or from (-) the `src` Position [wad]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to send to (+) or\n    /// from (-) the `dst` Position [wad]\n    function transferCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external override {\n        Position storage pSrc = positions[vault][tokenId][src];\n        Position storage pDst = positions[vault][tokenId][dst];\n        Vault storage v = vaults[vault];\n\n        pSrc.collateral = sub(pSrc.collateral, deltaCollateral);\n        pSrc.normalDebt = sub(pSrc.normalDebt, deltaNormalDebt);\n        pDst.collateral = add(pDst.collateral, deltaCollateral);\n        pDst.normalDebt = add(pDst.normalDebt, deltaNormalDebt);\n\n        uint256 debtSrc = wmul(pSrc.normalDebt, v.rate);\n        uint256 debtDst = wmul(pDst.normalDebt, v.rate);\n\n        // both sides consent\n        if (!hasDelegate(src, msg.sender) || !hasDelegate(dst, msg.sender))\n            revert Codex__transferCollateralAndDebt_notAllowed();\n\n        // both sides safe\n        if (debtSrc > wmul(pSrc.collateral, IVault(vault).fairPrice(tokenId, true, false)))\n            revert Codex__transferCollateralAndDebt_notSafeSrc();\n        if (debtDst > wmul(pDst.collateral, IVault(vault).fairPrice(tokenId, true, false)))\n            revert Codex__transferCollateralAndDebt_notSafeDst();\n\n        // both sides non-dusty\n        if (pSrc.normalDebt != 0 && debtSrc < v.debtFloor) revert Codex__transferCollateralAndDebt_debtFloorSrc();\n        if (pDst.normalDebt != 0 && debtDst < v.debtFloor) revert Codex__transferCollateralAndDebt_debtFloorDst();\n\n        emit TransferCollateralAndDebt(vault, tokenId, src, dst, deltaCollateral, deltaNormalDebt);\n    }\n\n    /// @notice Confiscates a Position's collateral and debt balances\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param user Address of the user\n    /// @param collateralizer Address of who puts up or receives the collateral delta\n    /// @param debtor Address of who provides or receives the debt delta\n    /// @param deltaCollateral Amount of collateral to put up (+) for or remove (-) from this Position [wad]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) on this Position [wad]\n    function confiscateCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external override checkCaller {\n        Position storage position = positions[vault][tokenId][user];\n        Vault storage v = vaults[vault];\n\n        position.collateral = add(position.collateral, deltaCollateral);\n        position.normalDebt = add(position.normalDebt, deltaNormalDebt);\n        v.totalNormalDebt = add(v.totalNormalDebt, deltaNormalDebt);\n\n        int256 deltaDebt = wmul(v.rate, deltaNormalDebt);\n\n        balances[vault][tokenId][collateralizer] = sub(balances[vault][tokenId][collateralizer], deltaCollateral);\n        unbackedDebt[debtor] = sub(unbackedDebt[debtor], deltaDebt);\n        globalUnbackedDebt = sub(globalUnbackedDebt, deltaDebt);\n\n        emit ConfiscateCollateralAndDebt(\n            vault,\n            tokenId,\n            user,\n            collateralizer,\n            debtor,\n            deltaCollateral,\n            deltaNormalDebt\n        );\n    }\n\n    /// ======== Unbacked Debt ======== ///\n\n    /// @notice Settles unbacked debt with the sender's credit\n    /// @dev Reverts if the sender does not have sufficient credit available to settle the debt\n    /// @param debt Amount of debt to settle [wawd]\n    function settleUnbackedDebt(uint256 debt) external override {\n        address debtor = msg.sender;\n        unbackedDebt[debtor] = sub(unbackedDebt[debtor], debt);\n        credit[debtor] = sub(credit[debtor], debt);\n        globalUnbackedDebt = sub(globalUnbackedDebt, debt);\n        globalDebt = sub(globalDebt, debt);\n        emit SettleUnbackedDebt(debtor, debt);\n    }\n\n    /// @notice Create unbacked debt / credit\n    /// @dev Sender has to be allowed to call this method\n    /// @param debtor Address of the account who takes the unbacked debt\n    /// @param creditor Address of the account who gets the credit\n    /// @param debt Amount of unbacked debt / credit to generate [wad]\n    function createUnbackedDebt(\n        address debtor,\n        address creditor,\n        uint256 debt\n    ) external override checkCaller {\n        unbackedDebt[debtor] = add(unbackedDebt[debtor], debt);\n        credit[creditor] = add(credit[creditor], debt);\n        globalUnbackedDebt = add(globalUnbackedDebt, debt);\n        globalDebt = add(globalDebt, debt);\n        emit CreateUnbackedDebt(debtor, creditor, debt);\n    }\n\n    /// ======== Debt Interest Rates ======== ///\n\n    /// @notice Updates the rate value and collects the accrued interest for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the vault\n    /// @param creditor Address of the account who gets the accrued interest\n    /// @param deltaRate Delta to increase (+) or decrease (-) the rate [percentage in wad]\n    function modifyRate(\n        address vault,\n        address creditor,\n        int256 deltaRate\n    ) external override checkCaller {\n        if (live == 0) revert Codex__modifyRate_notLive();\n        Vault storage v = vaults[vault];\n        v.rate = add(v.rate, deltaRate);\n        int256 wad = wmul(v.totalNormalDebt, deltaRate);\n        credit[creditor] = add(credit[creditor], wad);\n        globalDebt = add(globalDebt, wad);\n        emit ModifyRate(vault, creditor, deltaRate);\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Locks the contract\n    /// @dev Sender has to be allowed to call this method\n    function lock() external override checkCaller {\n        live = 0;\n        emit Lock();\n    }\n}\ninterface IGuard {\n    function isGuard() external view returns (bool);\n}\ncontract Delayed {\n    error Delayed__setParam_notDelayed();\n    error Delayed__delay_invalidEta();\n    error Delayed__execute_unknown();\n    error Delayed__execute_stillDelayed();\n    error Delayed__execute_executionError();\n\n    mapping(bytes32 => bool) public queue;\n    uint256 public delay;\n\n    event SetParam(bytes32 param, uint256 data);\n    event Queue(address target, bytes data, uint256 eta);\n    event Unqueue(address target, bytes data, uint256 eta);\n    event Execute(address target, bytes data, uint256 eta);\n\n    constructor(uint256 delay_) {\n        delay = delay_;\n        emit SetParam(\"delay\", delay_);\n    }\n\n    function _setParam(bytes32 param, uint256 data) internal {\n        if (param == \"delay\") delay = data;\n        emit SetParam(param, data);\n    }\n\n    function _delay(\n        address target,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        if (eta < block.timestamp + delay) revert Delayed__delay_invalidEta();\n        queue[keccak256(abi.encode(target, data, eta))] = true;\n        emit Queue(target, data, eta);\n    }\n\n    function _skip(\n        address target,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        queue[keccak256(abi.encode(target, data, eta))] = false;\n        emit Unqueue(target, data, eta);\n    }\n\n    function execute(\n        address target,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes memory out) {\n        bytes32 callHash = keccak256(abi.encode(target, data, eta));\n\n        if (!queue[callHash]) revert Delayed__execute_unknown();\n        if (block.timestamp < eta) revert Delayed__execute_stillDelayed();\n\n        queue[callHash] = false;\n\n        bool ok;\n        (ok, out) = target.call(data);\n        if (!ok) revert Delayed__execute_executionError();\n\n        emit Execute(target, data, eta);\n    }\n}\nabstract contract BaseGuard is Delayed, IGuard {\n    /// ======== Custom Errors ======== ///\n\n    error BaseGuard__isSenatus_notSenatus();\n    error BaseGuard__isGuardian_notGuardian();\n    error BaseGuard__isDelayed_notSelf(address, address);\n    error BaseGuard__inRange_notInRange();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Address of the DAO\n    address public immutable senatus;\n    /// @notice Address of the guardian\n    address public guardian;\n\n    constructor(\n        address senatus_,\n        address guardian_,\n        uint256 delay\n    ) Delayed(delay) {\n        senatus = senatus_;\n        guardian = guardian_;\n    }\n\n    modifier isSenatus() {\n        if (msg.sender != senatus) revert BaseGuard__isSenatus_notSenatus();\n        _;\n    }\n\n    modifier isGuardian() {\n        if (msg.sender != guardian) revert BaseGuard__isGuardian_notGuardian();\n        _;\n    }\n\n    modifier isDelayed() {\n        if (msg.sender != address(this)) revert BaseGuard__isDelayed_notSelf(msg.sender, address(this));\n        _;\n    }\n\n    /// @notice Callback method which allows Guard to check if he has sufficient rights over the corresponding contract\n    /// @return bool True if he has sufficient rights\n    function isGuard() external view virtual override returns (bool);\n\n    /// @notice Updates the address of the guardian\n    /// @dev Can only be called by Senatus\n    /// @param guardian_ Address of the new guardian\n    function setGuardian(address guardian_) external isSenatus {\n        guardian = guardian_;\n    }\n\n    /// ======== Capabilities ======== ///\n\n    /// @notice Updates the time which has to elapse for certain parameter updates\n    /// @dev Can only be called by Senatus\n    /// @param delay Time which has to elapse before parameter can be updated [seconds]\n    function setDelay(uint256 delay) external isSenatus {\n        _setParam(\"delay\", delay);\n    }\n\n    /// @notice Schedule method call for methods which have to be delayed\n    /// @dev Can only be called by the guardian\n    /// @param data Call data\n    function schedule(bytes calldata data) external isGuardian {\n        _delay(address(this), data, block.timestamp + delay);\n    }\n\n    /// ======== Helper Methods ======== ///\n\n    /// @notice Checks if `value` is at least equal to `min_` or at most equal to `max`\n    /// @dev Revers if check failed\n    /// @param value Value to check\n    /// @param min_ Min. value for `value`\n    /// @param max Max. value for `value`\n    function _inRange(\n        uint256 value,\n        uint256 min_,\n        uint256 max\n    ) internal pure {\n        if (max < value || value < min_) revert BaseGuard__inRange_notInRange();\n    }\n}\n/// @title CodexGuard\n/// @notice Contract which guards parameter updates for `Codex`\ncontract CodexGuard is BaseGuard {\n    /// ======== Custom Errors ======== ///\n\n    error CodexGuard__isGuard_cantCall();\n    error CodexGuard__addDebtCeilingAdjuster_invalidDelay();\n\n    /// ======== Storage ======== ///\n\n    struct DebtCeilingAdjuster {\n        // Max. ceiling possible [wad]\n        uint256 maxDebtCeiling;\n        // Max. value between current debt and maxDebtCeiling to be set [wad]\n        uint256 maxDelta;\n        // Min. time to pass before a new increase [seconds]\n        uint48 delay;\n        // Last block the ceiling was updated [blocks]\n        uint48 last;\n        // Last time the ceiling was increased compared to its previous value [seconds]\n        uint48 lastInc;\n    }\n    /// @notice Map of states defining the conditions according to which a vaults debt ceiling can be updated\n    /// Address of Vault => DebtCeilingAdjuster\n    mapping(address => DebtCeilingAdjuster) public debtCeilingAdjusters;\n\n    /// @notice Address of Codex\n    Codex public immutable codex;\n\n    constructor(\n        address senatus,\n        address guardian,\n        uint256 delay,\n        address codex_\n    ) BaseGuard(senatus, guardian, delay) {\n        codex = Codex(codex_);\n    }\n\n    /// @notice See `BaseGuard`\n    function isGuard() external view override returns (bool) {\n        if (!codex.canCall(codex.ANY_SIG(), address(this))) revert CodexGuard__isGuard_cantCall();\n        return true;\n    }\n\n    /// ======== Capabilities ======== ///\n\n    /// @notice Updates the debt ceiling adjuster function for a vault\n    /// @dev Can only be called by Senatus\n    /// @param vault Address of the vault for which to set the adjuster\n    /// @param maxDelta Max. amount by which the vaults debt ceiling can be adjusted at a given time [wad]\n    /// @param delay Min. time between debt ceiling adjustments [seconds]\n    function setDebtCeilingAdjuster(\n        address vault,\n        uint256 maxDebtCeiling,\n        uint256 maxDelta,\n        uint256 delay\n    ) external isSenatus {\n        if (maxDebtCeiling == 0) maxDebtCeiling = 10_000_000 * WAD;\n        if (delay >= type(uint48).max) revert CodexGuard__addDebtCeilingAdjuster_invalidDelay();\n        debtCeilingAdjusters[vault] = DebtCeilingAdjuster(maxDebtCeiling, maxDelta, uint48(delay), 0, 0);\n    }\n\n    /// @notice Removes the debt ceiling adjuster for a vault\n    /// @dev Can only be called by Senatus\n    /// @param vault Address of the vault for which to remove the debt ceiling adjuster\n    function removeDebtCeilingAdjuster(address vault) external isSenatus {\n        delete debtCeilingAdjusters[vault];\n    }\n\n    /// @notice Sets the `debtceiling` parameter on Codex\n    /// @dev Can only be called by the guardian. Checks if the value is in the allowed range.\n    /// @param vault Address of the vault for which to adjust the debt ceiling\n    function setDebtCeiling(address vault) external returns (uint256) {\n        (uint256 totalNormalDebt, uint256 rate, uint256 currentDebtCeiling, ) = codex.vaults(vault);\n        DebtCeilingAdjuster memory dca = debtCeilingAdjusters[vault];\n\n        // return if the vault is not enabled\n        if (dca.maxDebtCeiling == 0) return currentDebtCeiling;\n        // return if there was already an update in the same block\n        if (dca.last == block.number) return currentDebtCeiling;\n\n        // calculate debt\n        uint256 debt = wmul(totalNormalDebt, rate);\n        // calculate new debtCeiling based on the minimum between maxDebtCeiling and actual debt + maxDelta\n        uint256 debtCeiling = min(add(debt, dca.maxDelta), dca.maxDebtCeiling);\n\n        // short-circuit if there wasn't an update or if the time since last increment has not passed\n        if (\n            debtCeiling == currentDebtCeiling ||\n            (debtCeiling > currentDebtCeiling && block.timestamp < add(dca.lastInc, dca.delay))\n        ) return currentDebtCeiling;\n\n        // set debt ceiling\n        codex.setParam(vault, \"debtCeiling\", debtCeiling);\n        // set global debt ceiling\n        codex.setParam(\"globalDebtCeiling\", add(sub(codex.globalDebtCeiling(), currentDebtCeiling), debtCeiling));\n\n        // update lastInc if it is an increment in the debt ceiling\n        // and update last whatever the update is\n        if (debtCeiling > currentDebtCeiling) {\n            debtCeilingAdjusters[vault].lastInc = uint48(block.timestamp);\n            debtCeilingAdjusters[vault].last = uint48(block.number);\n        } else {\n            debtCeilingAdjusters[vault].last = uint48(block.number);\n        }\n\n        return debtCeiling;\n    }\n\n    /// @notice Sets the `debtFloor` parameter on Codex\n    /// @dev Can only be called by the guardian. Checks if the value is in the allowed range.\n    /// @param vault Vault for which to set the parameter\n    /// @param debtFloor See. Codex\n    /// @param collateralAuctions Impacted CollateralAuction's for which `updateAuctionDebtFloor` has to be triggered\n    function setDebtFloor(\n        address vault,\n        uint256 debtFloor,\n        address[] calldata collateralAuctions\n    ) external isGuardian {\n        _inRange(debtFloor, 0, 10_000 * WAD);\n        codex.setParam(vault, \"debtFloor\", debtFloor);\n        // update auctionDebtFloor for the provided collateral auction contracts\n        for (uint256 i = 0; i < collateralAuctions.length; i++) {\n            INoLossCollateralAuction(collateralAuctions[i]).updateAuctionDebtFloor(vault);\n        }\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"senatus\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"codex_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BaseGuard__inRange_notInRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"BaseGuard__isDelayed_notSelf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseGuard__isGuardian_notGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseGuard__isSenatus_notSenatus\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CodexGuard__addDebtCeilingAdjuster_invalidDelay\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CodexGuard__isGuard_cantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Delayed__delay_invalidEta\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Delayed__execute_executionError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Delayed__execute_stillDelayed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Delayed__execute_unknown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Delayed__setParam_notDelayed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"Math__add_overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"Math__mul_overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"Math__sub_overflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"Execute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"Queue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"param\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"SetParam\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"Unqueue\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"codex\",\"outputs\":[{\"internalType\":\"contract Codex\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"debtCeilingAdjusters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxDebtCeiling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDelta\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"delay\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"last\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"lastInc\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"out\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGuard\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"queue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"removeDebtCeilingAdjuster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"schedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"senatus\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"setDebtCeiling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxDebtCeiling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDelta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"setDebtCeilingAdjuster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debtFloor\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"collateralAuctions\",\"type\":\"address[]\"}],\"name\":\"setDebtFloor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"setDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guardian_\",\"type\":\"address\"}],\"name\":\"setGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CodexGuard", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "8000", "ConstructorArguments": "000000000000000000000000a55e0d3d697c4692e9c37bc3a7062b1beceef45b000000000000000000000000245bd99c7379df6740332d06530da7dedb062d61000000000000000000000000000000000000000000000000000000000002a300000000000000000000000000ce0e395cf61d0f836ddd4fc021f009c93dfe3a63", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}