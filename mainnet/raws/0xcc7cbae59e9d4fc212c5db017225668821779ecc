{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: EpigeonInterfaces.sol\r\n\r\n\r\npragma solidity ^0.4.11;\r\n\r\n//----------------------------------------------------------------------------------------------------\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n//----------------------------------------------------------------------------------------------------\r\ninterface IERC777 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function granularity() external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address owner) external view returns (uint256);\r\n    function send(address recipient, uint256 amount, bytes data) external;\r\n    function burn(uint256 amount, bytes data) external;\r\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\r\n    function authorizeOperator(address operator) external;\r\n    function revokeOperator(address operator) external;\r\n    function defaultOperators() external view returns (address[] memory);\r\n    function operatorSend(address sender, address recipient, uint256 amount, bytes data, bytes operatorData) external;\r\n    function operatorBurn(address account, uint256 amount, bytes data, bytes operatorData) external;\r\n    event Sent( address indexed operator, address indexed from, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n//----------------------------------------------------------------------------------------------------\r\ninterface ILockable {\r\n    function lock(address to, uint256 amount, bytes32 hash) external;\r\n    function operatorLock(address from, address to, uint256 amount, bytes32 hash, bytes data, bytes operatorData) external;\r\n    function unlock(string unlockerPhrase) external;\r\n    function operatorUnlock(address to, string unlockerPhrase, bytes data, bytes operatorData) external;\r\n    function reclaim(address to, string unlockerPhrase) external;\r\n    function operatorReclaim(address from, address to, string unlockerPhrase, bytes data, bytes operatorData) external;\r\n    function unlockByLockedCoinContract(address to, bytes32 hash) external;\r\n    function reclaimByLockedCoinContract(address from, address to, bytes32 hash) external;\r\n    function lockedSupply() external view returns (uint256 locked_supply);\r\n    function lockedAmount(address from, bytes32 hash) external view returns (uint256 amount);\r\n    function lockedBalanceOf(address account) external view returns (uint256);\r\n}\r\n//----------------------------------------------------------------------------------------------------\r\ninterface IPigeonFactory {\r\n    function createCryptoPigeon(address to) external returns (ICryptoPigeon pigeonAddress);    \r\n    function iAmFactory() external pure returns (bool);\r\n    function amIEpigeon() external returns (bool);\r\n    function factoryId() external view returns (uint256 id);\r\n    function getMetaDataForPigeon(address pigeon) external view returns (string metadata);\r\n    function mintingPrice() external view returns (uint256 price);\r\n    function totalSupply() external view returns (uint256 supply);\r\n    function maxSupply() external view returns (uint256 supply);\r\n    function getFactoryTokenPrice(address ERC20Token) external view returns (uint256 price);\r\n}\r\n//----------------------------------------------------------------------------------------------------\r\ninterface ICryptoPigeon {\r\n    function burnPigeon() external;    \r\n    function iAmPigeon() external pure returns (bool); \r\n    function transferPigeon(address newOwner) external; \r\n    function hasFlown() external view returns (bool);\r\n    function toAddress() external view returns (address addressee);   \r\n    function owner() external view returns (address ownerAddress);\r\n    function manager() external view returns (address managerAddress);\r\n    function factoryId() external view returns (uint256 id);\r\n}\r\n//----------------------------------------------------------------------------------------------------\r\ninterface IEpigeon {\r\n    function pigeonDestinations() external view returns (IPigeonDestinationDirectory destinations);\r\n    function nameAndKeyDirectory() external view returns (INameAndPublicKeyDirectory directory);\r\n    function getLastFactoryId() external view returns (uint256 id);\r\n    function getFactoryAddresstoId(uint256 id) external view returns (address factoryAddress);\r\n    function getPigeonPriceForFactory(uint256 factoryId) external view returns (uint256 price);\r\n    function getPigeonTokenPriceForFactory(address ERC20Token, uint256 factoryId) external view returns (uint256 price);\r\n    function createCryptoPigeonNFT(address to, uint256 factoryId) external returns (address pigeonaddress);\r\n    function transferPigeon(address from, address to, address pigeon) external;\r\n    function burnPigeon(address pigeon) external;\r\n    function nftContractAddress() external view returns (address nftContract);\r\n    function validPigeon(address pigeon, address pigeonOwner) external view returns (bool);\r\n}\r\n//----------------------------------------------------------------------------------------------------\r\ninterface IEpigeonNFT {\r\n    function isTokenizedPigeon(address pigeon) external view returns (bool);\r\n}\r\n//----------------------------------------------------------------------------------------------------\r\ninterface INameAndPublicKeyDirectory {\r\n    function getPublicKeyForAddress (address owner) external view returns (string key); \r\n    function getUserNameForAddress (address owner) external view returns (string name);\r\n}\r\n//----------------------------------------------------------------------------------------------------\r\ninterface IPigeonDestinationDirectory{\r\n    function changeToAddress(address newToAddress, address oldToAddress) external;\r\n    function setToAddress(address newToAddress) external;\r\n    function deleteToAddress(address oldToAddress) external;\r\n    function deleteToAddressByEpigeon(address pigeon) external;\r\n    function pigeonsSentToAddressLenght(address toAddress) external view returns (uint256 length);\r\n    function pigeonSentToAddressByIndex(address toAddress, uint index) external view returns (address pigeonAddress);   \r\n}\r\n//----------------------------------------------------------------------------------------------------\r\ninterface IPigeonManagerDirectory{\r\n    function changeManager(address newManager, address oldManager) external;\r\n    function deleteManager(address oldManager) external;\r\n    function setManager(address newManager) external;\r\n    function pigeonsOfManagerLenght(address toAddress) external view returns (uint256 length);\r\n    function pigeonOfManagerByIndex(address toAddress, uint index) external view returns (address pigeonAddress);   \r\n}\r\n//----------------------------------------------------------------------------------------------------\r\n\r\n\r\n// File: Epigeon.sol\r\n\r\n\r\npragma solidity ^0.4.11;\r\n\r\n\r\n//----------------------------------------------------------------------------------------------------\r\n\r\ncontract NameAndPublicKeyDirectory is INameAndPublicKeyDirectory{\r\n    \r\n    mapping (address => string) internal addressToPublicKey;\r\n    mapping (address => string) internal addressToUserName;\r\n    mapping (string => address) internal userNameToAddress;\r\n\t\r\n\tEpigeon epigeonAddress;\r\n\tuint256 public uniqueNamePrice;\r\n\t\r\n\tconstructor (){\r\n        epigeonAddress = Epigeon(msg.sender);\r\n    }\r\n    \r\n    function getPublicKeyForAddress (address owner) public view returns (string key){\r\n        return addressToPublicKey[owner];\r\n    }\r\n    \r\n    function getUserNameForAddress (address owner) public view returns (string name){\r\n        return addressToUserName[owner];\r\n    }\r\n    \r\n    function setPublicKeyToAddress (string key) public {\r\n        addressToPublicKey[msg.sender] = key;\r\n    }\r\n\t\r\n\tfunction setUniqueNamePrice (uint256 price) public {\r\n\t\trequire(msg.sender == epigeonAddress.owner(), \"Only Epigeon owner\");\r\n        uniqueNamePrice = price;\r\n    }\r\n    \r\n    function setUserNameToAddress (string name) public payable {\r\n        require(userNameToAddress[name] == msg.sender || userNameToAddress[name] == 0, \"Name is already in use\");\r\n        require(msg.value >= uniqueNamePrice, \"Not enough value\");\r\n        delete userNameToAddress[addressToUserName[msg.sender]];\r\n        addressToUserName[msg.sender] = name;\r\n        userNameToAddress[name] = msg.sender;\r\n\t\tepigeonAddress.owner().transfer(address(this).balance);\r\n    }\r\n\t\r\n\tfunction transferUniqueName (address toAddress) public {\r\n\t\taddressToUserName[toAddress]= addressToUserName[msg.sender];\r\n\t\tuserNameToAddress[addressToUserName[toAddress]] = toAddress;\r\n\t\tdelete addressToUserName[msg.sender];\r\n    }\r\n}\r\n//----------------------------------------------------------------------------------------------------\r\n\r\ncontract PigeonDestinationDirectory is IPigeonDestinationDirectory{\r\n    \r\n    address public epigeonAddress;\r\n    \r\n    mapping (address => address[]) internal toAddressToPigeon;\r\n    mapping (address => uint256) internal pigeonToToAddressIndex;\r\n    mapping (address => bool) internal pigeonToAddressExists;\r\n    \r\n    event PigeonSent(address toAddress);\r\n    \r\n    constructor (){\r\n        epigeonAddress = msg.sender;\r\n    }\r\n    \r\n    function changeToAddress(address newToAddress, address oldToAddress) public {\r\n        //Check if the call is from a CryptoPigeon\r\n        require(_isPigeon(msg.sender), \"Available only for Epigeon's pigeon contracts\");\r\n        ICryptoPigeon pigeon = ICryptoPigeon(msg.sender);\r\n        require(pigeonToAddressExists[msg.sender] == true, \"Pigeon has no recipient entry to change\");\r\n        \r\n        //Push new to address\r\n        toAddressToPigeon[newToAddress].push(pigeon);\r\n        pigeonToToAddressIndex[pigeon] = toAddressToPigeon[newToAddress].length-1;\r\n        \r\n        //Delete old to address\r\n        address pigeonToRemove = pigeon;\r\n        uint256 pigeonToRemoveIndex = pigeonToToAddressIndex[pigeon];\r\n        uint256 lastIdIndex = toAddressToPigeon[oldToAddress].length - 1;\r\n        if (toAddressToPigeon[oldToAddress][lastIdIndex] != pigeonToRemove)\r\n        {\r\n          address lastPigeon = toAddressToPigeon[oldToAddress][lastIdIndex];\r\n          toAddressToPigeon[oldToAddress][pigeonToToAddressIndex[pigeonToRemove]] = lastPigeon;\r\n          pigeonToToAddressIndex[lastPigeon] = pigeonToRemoveIndex;\r\n        }\r\n        delete toAddressToPigeon[oldToAddress][lastIdIndex];\r\n        toAddressToPigeon[oldToAddress].length--;\r\n        emit PigeonSent(newToAddress);\r\n    }\r\n    \r\n    function deleteToAddress(address oldToAddress) public {\r\n        //Check if the call is from a CryptoPigeon\r\n        require(_isPigeon(msg.sender), \"Available only for Epigeon's pigeon contracts\");\r\n        ICryptoPigeon pigeon = ICryptoPigeon(msg.sender);\r\n        \r\n        //Delete old to address \r\n        address pigeonToRemove = pigeon;\r\n        uint256 pigeonToRemoveIndex = pigeonToToAddressIndex[pigeon];\r\n        uint256 lastIdIndex = toAddressToPigeon[oldToAddress].length - 1;\r\n        if (toAddressToPigeon[oldToAddress][lastIdIndex] != pigeonToRemove)\r\n        {\r\n          address lastPigeon = toAddressToPigeon[oldToAddress][lastIdIndex];\r\n          toAddressToPigeon[oldToAddress][pigeonToToAddressIndex[pigeonToRemove]] = lastPigeon;\r\n          pigeonToToAddressIndex[lastPigeon] = pigeonToRemoveIndex;\r\n        }\r\n        delete toAddressToPigeon[oldToAddress][lastIdIndex];\r\n        toAddressToPigeon[oldToAddress].length--;\r\n        \r\n        pigeonToAddressExists[pigeon] = false;\r\n    }\r\n    \r\n    function deleteToAddressByEpigeon(address pigeon) public {\r\n        require(epigeonAddress == msg.sender, \"Available only for Epigeon Smart Contract\");\r\n        address pToAddress = ICryptoPigeon(pigeon).toAddress();\r\n        address pigeonToRemove = pigeon;\r\n        \r\n        //Delete to address\r\n        if (ICryptoPigeon(pigeon).hasFlown()){\r\n            uint256 pigeonToRemoveIndex = pigeonToToAddressIndex[pigeon];\r\n            uint256 lastIdIndex = toAddressToPigeon[pToAddress].length - 1;\r\n            if (toAddressToPigeon[pToAddress][lastIdIndex] != pigeonToRemove)\r\n            {\r\n              address alastPigeon = toAddressToPigeon[pToAddress][lastIdIndex];\r\n              toAddressToPigeon[pToAddress][pigeonToToAddressIndex[pigeonToRemove]] = alastPigeon;\r\n              pigeonToToAddressIndex[alastPigeon] = pigeonToRemoveIndex;\r\n            }\r\n            delete toAddressToPigeon[pToAddress][lastIdIndex];\r\n            toAddressToPigeon[pToAddress].length--;\r\n         }\r\n         pigeonToAddressExists[pigeon] = false;\r\n    }\r\n    \r\n    function pigeonSentToAddressByIndex(address toAddress, uint index) public view returns (address rpaddress){\r\n        rpaddress = toAddressToPigeon[toAddress][index];\r\n    }\r\n    \r\n    function pigeonsSentToAddressLenght(address toAddress) public view returns (uint256 length){\r\n        length = toAddressToPigeon[toAddress].length;\r\n    }\r\n    \r\n    function setToAddress(address newToAddress) public {\r\n        //Check if the call is from a CryptoPigeon\r\n        require(_isPigeon(msg.sender), \"Available only for Epigeon's pigeon contracts\");\r\n        ICryptoPigeon pigeon = ICryptoPigeon(msg.sender);\r\n        \r\n        //Push new to address\r\n        require(pigeonToAddressExists[msg.sender] != true, \"Pigeon already has recipient entry\");\r\n        toAddressToPigeon[newToAddress].push(pigeon);\r\n        pigeonToToAddressIndex[pigeon] = toAddressToPigeon[newToAddress].length-1;\r\n        \r\n        pigeonToAddressExists[pigeon] = true;\r\n        emit PigeonSent(newToAddress);\r\n    }\r\n    \r\n    function _isPigeon (address sender) internal view returns (bool indeed){\r\n        ICryptoPigeon pigeon = ICryptoPigeon(sender);\r\n        return IEpigeon(epigeonAddress).validPigeon(sender, pigeon.owner());\r\n    }\r\n}\r\n//----------------------------------------------------------------------------------------------------\r\n\r\ncontract Epigeon is IEpigeon{\r\n\r\n    address public owner;\r\n    string public egigeonURI;\r\n    address private _nftContractAddress;\r\n\r\n    INameAndPublicKeyDirectory private _nameAndKeyDirectory;\r\n    IPigeonDestinationDirectory private _pigeonDestinations;\r\n\r\n    uint256[] factoryIds;\r\n    mapping (address => bool) disabledFactories;\r\n    mapping (uint256 => address) factoryIdtoAddress;\r\n\r\n    mapping (address => address[]) internal ownerToPigeon;\r\n    mapping (address => uint256) internal pigeonToOwnerIndex;\r\n\r\n    event PigeonCreated(ICryptoPigeon pigeon);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor (){ \r\n        owner = msg.sender;\r\n        _nameAndKeyDirectory = new NameAndPublicKeyDirectory();\r\n        _pigeonDestinations = new PigeonDestinationDirectory();\r\n    }   \r\n\r\n    function addFactory(address factoryAddress) public {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        IPigeonFactory factory = IPigeonFactory(factoryAddress);\r\n        require(factory.iAmFactory(), \"Not a factory\");\r\n        require(factory.amIEpigeon(), \"Not the factory's Epigeon\");\r\n        require(factoryIdtoAddress[factory.factoryId()] == address(0), \"Existing Factory ID\");\r\n        factoryIds.push(factory.factoryId());\r\n        factoryIdtoAddress[factory.factoryId()] = factory;\r\n        disabledFactories[factory] = false;\r\n    }\r\n\r\n    function burnPigeon(address pigeon) public {\r\n        require((_nftContractAddress == msg.sender) || ((IEpigeonNFT(_nftContractAddress).isTokenizedPigeon(pigeon) == false) && (ICryptoPigeon(pigeon).owner() == msg.sender)), \"Not authorized\");\r\n        address pOwner = ICryptoPigeon(pigeon).owner();\r\n        address pigeonToRemove = pigeon;\r\n        \r\n        //Delete old owner address\r\n        uint256 pigeonToRemoveIndex = pigeonToOwnerIndex[pigeon];\r\n        uint256 lastIdIndex = ownerToPigeon[pOwner].length - 1;\r\n        if (ownerToPigeon[pOwner][lastIdIndex] != pigeonToRemove)\r\n        {\r\n          address lastPigeon = ownerToPigeon[pOwner][lastIdIndex];\r\n          ownerToPigeon[pOwner][pigeonToOwnerIndex[pigeonToRemove]] = lastPigeon;\r\n          pigeonToOwnerIndex[lastPigeon] = pigeonToRemoveIndex;       \r\n        }\r\n        delete ownerToPigeon[pOwner][lastIdIndex];\r\n        ownerToPigeon[pOwner].length--;\r\n         \r\n        //Delete to address\r\n        _pigeonDestinations.deleteToAddressByEpigeon(pigeon);\r\n        \r\n        //Burn contract too\r\n        ICryptoPigeon(pigeon).burnPigeon();        \r\n    }\r\n    \r\n    function createCryptoPigeon(uint256 factoryId) public payable returns (address pigeonAddress) {\r\n        require(msg.value >= getPigeonPriceForFactory(factoryId), \"Not enough value\"); \r\n        return _createPigeon(msg.sender, factoryId);\r\n    }\r\n    \r\n    function createCryptoPigeonByLatestFactory() public payable returns (address pigeonAddress) {\r\n        require(msg.value >= getPigeonPriceForFactory(getLastFactoryId()), \"Not enough value\");\r\n        return _createPigeon(msg.sender, getLastFactoryId());\r\n    }\r\n    \r\n    function createCryptoPigeonForToken(address ERC20Token, uint256 factoryId) public returns (address pigeonAddress) {\r\n        require(getPigeonTokenPriceForFactory(ERC20Token, factoryId) > 0, \"Price for token not available\");\r\n        require(IERC20(ERC20Token).balanceOf(msg.sender) >= getPigeonTokenPriceForFactory(ERC20Token, factoryId), \"Not enough balance\");\r\n        require(IERC20(ERC20Token).allowance(msg.sender, address(this)) >= getPigeonTokenPriceForFactory(ERC20Token, factoryId), \"Not enough allowance\");\r\n        IERC20(ERC20Token).transferFrom(msg.sender, owner, getPigeonTokenPriceForFactory(ERC20Token, factoryId));\r\n        return _createPigeon(msg.sender, factoryId);\r\n    }\r\n    \r\n    function createCryptoPigeonNFT(address to, uint256 factoryId) public returns (address pigeonAddress) {\r\n        require(_nftContractAddress == msg.sender, \"Available only for the NFT contract\");   \r\n        return _createPigeon(to, factoryId);\r\n    }\r\n    \r\n    function disableFactory(uint256 factoryId) public {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        disabledFactories[factoryIdtoAddress[factoryId]] = true;\r\n    }\r\n    \r\n    function enableFactory(uint256 factoryId) public {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        require(factoryIdtoAddress[factoryId] != address(0));\r\n        disabledFactories[factoryIdtoAddress[factoryId]] = false;\r\n    }\r\n    \r\n    function getFactoryAddresstoId(uint256 id) public view returns (address factory){\r\n        return factoryIdtoAddress[id];\r\n    }\r\n    \r\n    function getFactoryCount() public view returns (uint256 count){\r\n        return factoryIds.length;\r\n    }\r\n    \r\n    function getIdforFactory(uint256 index) public view returns (uint256 id){\r\n        return factoryIds[index];\r\n    }\r\n    \r\n    function getLastFactoryId() public view returns (uint256 id){\r\n        return factoryIds[factoryIds.length-1];\r\n    }\r\n    \r\n    function getPigeonPriceForFactory(uint256 factoryId) public view returns (uint256 price){\r\n        return IPigeonFactory(factoryIdtoAddress[factoryId]).mintingPrice();\r\n    }\r\n    \r\n    function getPigeonTokenPriceForFactory(address ERC20Token, uint256 factoryId) public view returns (uint256 price){\r\n        return IPigeonFactory(factoryIdtoAddress[factoryId]).getFactoryTokenPrice(ERC20Token);\r\n    }\r\n    \r\n    function isFactoryDisabled(address factoryAddress) public view returns (bool disabled){\r\n        return disabledFactories[factoryAddress];\r\n    }\r\n    \r\n    function nameAndKeyDirectory() external view returns (INameAndPublicKeyDirectory directory){\r\n        return _nameAndKeyDirectory;\r\n    }\r\n    \r\n    function nftContractAddress() external view returns (address _nftcontract){\r\n        return _nftContractAddress;\r\n    }\r\n\r\n    function payout() public {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        owner.transfer(address(this).balance);\r\n    }\r\n    \r\n    function pigeonDestinations() external view returns (IPigeonDestinationDirectory destinations){\r\n        return _pigeonDestinations;\r\n    }\r\n    \r\n    function pigeonsCountOfOwner(address pigeonOwner) public view returns (uint256 length){\r\n        length = ownerToPigeon[pigeonOwner].length;\r\n        return length;\r\n    }\r\n    \r\n    function pigeonOfOwnerByIndex(address pigeonOwner, uint index) public view returns (address rpaddress){\r\n        rpaddress = ownerToPigeon[pigeonOwner][index];\r\n        return rpaddress;\r\n    }\r\n    \r\n    function setNFTContractAddress(address nftContract) public { \r\n        require(owner == msg.sender, \"Only owner\");\r\n        require(_nftContractAddress == address(0), \"NFT contract already set\");\r\n        _nftContractAddress = nftContract;\r\n    }\r\n    \r\n    function setUri(string uri) public {  \r\n        require(owner == msg.sender, \"Only owner\");\r\n        egigeonURI = uri;\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) public {    \r\n        require(owner == msg.sender, \"Only owner\");\r\n        require(newOwner != address(0), \"Zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner.transfer(address(this).balance);\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function transferPigeon(address from, address to, address pigeon) public {\r\n    \r\n        if (IEpigeonNFT(_nftContractAddress).isTokenizedPigeon(pigeon)) {\r\n            require(_nftContractAddress == msg.sender, \"Tokenized Pigeon can only be transferred by NFT contract\");\r\n        }\r\n        else{\r\n            require(ICryptoPigeon(pigeon).owner() == msg.sender || pigeon == msg.sender, \"Only pigeon owner\");\r\n        }\r\n        \r\n        //Push new owner address\r\n        ownerToPigeon[to].push(pigeon);\r\n        pigeonToOwnerIndex[pigeon] = ownerToPigeon[to].length-1;\r\n        \r\n        //Delete old owner address\r\n        address pigeonToRemove = pigeon;\r\n        uint256 pigeonToRemoveIndex = pigeonToOwnerIndex[pigeon];\r\n        uint256 lastIdIndex = ownerToPigeon[from].length - 1;\r\n        if (ownerToPigeon[from][lastIdIndex] != pigeonToRemove)\r\n        {\r\n          address lastPigeon = ownerToPigeon[from][lastIdIndex];\r\n          ownerToPigeon[from][pigeonToOwnerIndex[pigeonToRemove]] = lastPigeon;\r\n          pigeonToOwnerIndex[lastPigeon] = pigeonToRemoveIndex;\r\n          \r\n        }\r\n        delete ownerToPigeon[from][lastIdIndex];\r\n        ownerToPigeon[from].length--;\r\n        \r\n        //Delete old to address\r\n        _pigeonDestinations.deleteToAddressByEpigeon(pigeon);\r\n         \r\n        //Transfer contract too\r\n        ICryptoPigeon(pigeon).transferPigeon(to);\r\n    }\r\n    \r\n    function validPigeon(address pigeon, address pigeonOwner) public view returns (bool valid){\r\n        require(pigeon != address(0), \"Null address\");\r\n        return ownerToPigeon[pigeonOwner][pigeonToOwnerIndex[pigeon]] == pigeon;\r\n    }\r\n    \r\n    function _createPigeon(address to, uint256 factoryId) internal returns (address pigeonAddress) {\r\n        require(isFactoryDisabled(factoryIdtoAddress[factoryId]) == false, \"Factory is disabled\");\r\n        ICryptoPigeon pigeon = IPigeonFactory(factoryIdtoAddress[factoryId]).createCryptoPigeon( to);\r\n        ownerToPigeon[to].push(pigeon);\r\n        pigeonToOwnerIndex[pigeon] = ownerToPigeon[to].length-1;\r\n        emit PigeonCreated(pigeon);\r\n        return pigeon;\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"oldToAddress\",\"type\":\"address\"}],\"name\":\"deleteToAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epigeonAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"pigeonsSentToAddressLenght\",\"outputs\":[{\"name\":\"length\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pigeon\",\"type\":\"address\"}],\"name\":\"deleteToAddressByEpigeon\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"toAddress\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"pigeonSentToAddressByIndex\",\"outputs\":[{\"name\":\"rpaddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newToAddress\",\"type\":\"address\"}],\"name\":\"setToAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newToAddress\",\"type\":\"address\"},{\"name\":\"oldToAddress\",\"type\":\"address\"}],\"name\":\"changeToAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"PigeonSent\",\"type\":\"event\"}]", "ContractName": "PigeonDestinationDirectory", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://567ebadbc3c8f030b9b3c39db80ae7ac801a54e20593e6fedd45e422ff288468"}]}