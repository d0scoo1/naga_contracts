{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/McdUtils.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./external/DSMath.sol\\\";\\nimport \\\"./interfaces/ManagerLike.sol\\\";\\nimport \\\"./interfaces/ICommand.sol\\\";\\nimport \\\"./interfaces/Mcd.sol\\\";\\nimport \\\"./interfaces/BotLike.sol\\\";\\n\\nimport \\\"./ServiceRegistry.sol\\\";\\n\\n/// @title Getter contract for Vault info from Maker protocol\\ncontract McdUtils is DSMath {\\n    address public immutable serviceRegistry;\\n    IERC20 private immutable DAI;\\n    address private immutable daiJoin;\\n    address public immutable jug;\\n\\n    constructor(\\n        address _serviceRegistry,\\n        IERC20 _dai,\\n        address _daiJoin,\\n        address _jug\\n    ) {\\n        serviceRegistry = _serviceRegistry;\\n        DAI = _dai;\\n        daiJoin = _daiJoin;\\n        jug = _jug;\\n    }\\n\\n    function toInt256(uint256 x) internal pure returns (int256 y) {\\n        y = int256(x);\\n        require(y >= 0, \\\"int256-overflow\\\");\\n    }\\n\\n    function _getDrawDart(\\n        address vat,\\n        address urn,\\n        bytes32 ilk,\\n        uint256 wad\\n    ) internal returns (int256 dart) {\\n        // Updates stability fee rate\\n        uint256 rate = IJug(jug).drip(ilk);\\n\\n        // Gets DAI balance of the urn in the vat\\n        uint256 dai = IVat(vat).dai(urn);\\n\\n        // If there was already enough DAI in the vat balance, just exits it without adding more debt\\n        if (dai < mul(wad, RAY)) {\\n            // Calculates the needed dart so together with the existing dai in the vat is enough to exit wad amount of DAI tokens\\n            dart = toInt256(sub(mul(wad, RAY), dai) / rate);\\n            // This is neeeded due lack of precision. It might need to sum an extra dart wei (for the given DAI wad amount)\\n            dart = mul(uint256(dart), rate) < mul(wad, RAY) ? dart + 1 : dart;\\n        }\\n    }\\n\\n    function drawDebt(\\n        uint256 borrowedDai,\\n        uint256 cdpId,\\n        ManagerLike manager,\\n        address sendTo\\n    ) external {\\n        address urn = manager.urns(cdpId);\\n        address vat = manager.vat();\\n\\n        manager.frob(cdpId, 0, _getDrawDart(vat, urn, manager.ilks(cdpId), borrowedDai));\\n        manager.move(cdpId, address(this), mul(borrowedDai, RAY));\\n\\n        if (IVat(vat).can(address(this), daiJoin) == 0) {\\n            IVat(vat).hope(daiJoin);\\n        }\\n\\n        IJoin(daiJoin).exit(sendTo, borrowedDai);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/external/DSMath.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ncontract DSMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"\\\");\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"\\\");\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"\\\");\\n    }\\n\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x / y;\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    uint256 internal constant WAD = 10**18;\\n    uint256 internal constant RAY = 10**27;\\n\\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n\\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ManagerLike.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface ManagerLike {\\n    function cdpCan(\\n        address owner,\\n        uint256 cdpId,\\n        address allowedAddr\\n    ) external view returns (uint256);\\n\\n    function vat() external view returns (address);\\n\\n    function ilks(uint256) external view returns (bytes32);\\n\\n    function owns(uint256) external view returns (address);\\n\\n    function urns(uint256) external view returns (address);\\n\\n    function cdpAllow(\\n        uint256 cdp,\\n        address usr,\\n        uint256 ok\\n    ) external;\\n\\n    function frob(\\n        uint256,\\n        int256,\\n        int256\\n    ) external;\\n\\n    function flux(\\n        uint256,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function move(\\n        uint256,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function exit(\\n        address,\\n        uint256,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICommand.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface ICommand {\\n    function isTriggerDataValid(uint256 _cdpId, bytes memory triggerData)\\n        external\\n        view\\n        returns (bool);\\n\\n    function isExecutionCorrect(uint256 cdpId, bytes memory triggerData)\\n        external\\n        view\\n        returns (bool);\\n\\n    function isExecutionLegal(uint256 cdpId, bytes memory triggerData) external view returns (bool);\\n\\n    function execute(\\n        bytes calldata executionData,\\n        uint256 cdpId,\\n        bytes memory triggerData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Mcd.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nabstract contract IVat {\\n    struct Urn {\\n        uint256 ink; // Locked Collateral  [wad]\\n        uint256 art; // Normalised Debt    [wad]\\n    }\\n\\n    struct Ilk {\\n        uint256 Art; // Total Normalised Debt     [wad]\\n        uint256 rate; // Accumulated Rates         [ray]\\n        uint256 spot; // Price with Safety Margin  [ray]\\n        uint256 line; // Debt Ceiling              [rad]\\n        uint256 dust; // Urn Debt Floor            [rad]\\n    }\\n\\n    mapping(bytes32 => mapping(address => Urn)) public urns;\\n    mapping(bytes32 => Ilk) public ilks;\\n    mapping(bytes32 => mapping(address => uint256)) public gem; // [wad]\\n\\n    function can(address, address) public view virtual returns (uint256);\\n\\n    function dai(address) public view virtual returns (uint256);\\n\\n    function frob(\\n        bytes32,\\n        address,\\n        address,\\n        address,\\n        int256,\\n        int256\\n    ) public virtual;\\n\\n    function hope(address) public virtual;\\n\\n    function move(\\n        address,\\n        address,\\n        uint256\\n    ) public virtual;\\n\\n    function fork(\\n        bytes32,\\n        address,\\n        address,\\n        int256,\\n        int256\\n    ) public virtual;\\n}\\n\\nabstract contract IGem {\\n    function dec() public virtual returns (uint256);\\n\\n    function gem() public virtual returns (IGem);\\n\\n    function join(address, uint256) public payable virtual;\\n\\n    function exit(address, uint256) public virtual;\\n\\n    function approve(address, uint256) public virtual;\\n\\n    function transfer(address, uint256) public virtual returns (bool);\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) public virtual returns (bool);\\n\\n    function deposit() public payable virtual;\\n\\n    function withdraw(uint256) public virtual;\\n\\n    function allowance(address, address) public virtual returns (uint256);\\n}\\n\\nabstract contract IJoin {\\n    bytes32 public ilk;\\n\\n    function dec() public view virtual returns (uint256);\\n\\n    function gem() public view virtual returns (IGem);\\n\\n    function join(address, uint256) public payable virtual;\\n\\n    function exit(address, uint256) public virtual;\\n}\\n\\nabstract contract IDaiJoin {\\n    function vat() public virtual returns (IVat);\\n\\n    function dai() public virtual returns (IGem);\\n\\n    function join(address, uint256) public payable virtual;\\n\\n    function exit(address, uint256) public virtual;\\n}\\n\\nabstract contract IJug {\\n    struct Ilk {\\n        uint256 duty;\\n        uint256 rho;\\n    }\\n\\n    mapping(bytes32 => Ilk) public ilks;\\n\\n    function drip(bytes32) public virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BotLike.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface BotLike {\\n    function addRecord(\\n        uint256 cdpId,\\n        uint256 triggerType,\\n        uint256 replacedTriggerId,\\n        bytes memory triggerData\\n    ) external;\\n\\n    function removeRecord(\\n        // This function should be executed allways in a context of AutomationBot address not DsProxy,\\n        //msg.sender should be dsProxy\\n        uint256 cdpId,\\n        uint256 triggerId\\n    ) external;\\n\\n    function execute(\\n        bytes calldata executionData,\\n        uint256 cdpId,\\n        bytes calldata triggerData,\\n        address commandAddress,\\n        uint256 triggerId,\\n        uint256 daiCoverage\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/ServiceRegistry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ncontract ServiceRegistry {\\n    uint256 public constant MAX_DELAY = 30 days;\\n\\n    mapping(bytes32 => uint256) public lastExecuted;\\n    mapping(bytes32 => address) private namedService;\\n    address public owner;\\n    uint256 public requiredDelay;\\n\\n    modifier validateInput(uint256 len) {\\n        require(msg.data.length == len, \\\"registry/illegal-padding\\\");\\n        _;\\n    }\\n\\n    modifier delayedExecution() {\\n        bytes32 operationHash = keccak256(msg.data);\\n        uint256 reqDelay = requiredDelay;\\n\\n        /* solhint-disable not-rely-on-time */\\n        if (lastExecuted[operationHash] == 0 && reqDelay > 0) {\\n            // not called before, scheduled for execution\\n            lastExecuted[operationHash] = block.timestamp;\\n            emit ChangeScheduled(operationHash, block.timestamp + reqDelay, msg.data);\\n        } else {\\n            require(\\n                block.timestamp - reqDelay > lastExecuted[operationHash],\\n                \\\"registry/delay-too-small\\\"\\n            );\\n            emit ChangeApplied(operationHash, block.timestamp, msg.data);\\n            _;\\n            lastExecuted[operationHash] = 0;\\n        }\\n        /* solhint-enable not-rely-on-time */\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"registry/only-owner\\\");\\n        _;\\n    }\\n\\n    constructor(uint256 initialDelay) {\\n        require(initialDelay <= MAX_DELAY, \\\"registry/invalid-delay\\\");\\n        requiredDelay = initialDelay;\\n        owner = msg.sender;\\n    }\\n\\n    function transferOwnership(address newOwner)\\n        external\\n        onlyOwner\\n        validateInput(36)\\n        delayedExecution\\n    {\\n        owner = newOwner;\\n    }\\n\\n    function changeRequiredDelay(uint256 newDelay)\\n        external\\n        onlyOwner\\n        validateInput(36)\\n        delayedExecution\\n    {\\n        require(newDelay <= MAX_DELAY, \\\"registry/invalid-delay\\\");\\n        requiredDelay = newDelay;\\n    }\\n\\n    function getServiceNameHash(string memory name) external pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(name));\\n    }\\n\\n    function addNamedService(bytes32 serviceNameHash, address serviceAddress)\\n        external\\n        onlyOwner\\n        validateInput(68)\\n        delayedExecution\\n    {\\n        require(namedService[serviceNameHash] == address(0), \\\"registry/service-override\\\");\\n        namedService[serviceNameHash] = serviceAddress;\\n    }\\n\\n    function updateNamedService(bytes32 serviceNameHash, address serviceAddress)\\n        external\\n        onlyOwner\\n        validateInput(68)\\n        delayedExecution\\n    {\\n        require(namedService[serviceNameHash] != address(0), \\\"registry/service-does-not-exist\\\");\\n        namedService[serviceNameHash] = serviceAddress;\\n    }\\n\\n    function removeNamedService(bytes32 serviceNameHash) external onlyOwner validateInput(36) {\\n        require(namedService[serviceNameHash] != address(0), \\\"registry/service-does-not-exist\\\");\\n        namedService[serviceNameHash] = address(0);\\n        emit NamedServiceRemoved(serviceNameHash);\\n    }\\n\\n    function getRegisteredService(string memory serviceName) external view returns (address) {\\n        return namedService[keccak256(abi.encodePacked(serviceName))];\\n    }\\n\\n    function getServiceAddress(bytes32 serviceNameHash) external view returns (address) {\\n        return namedService[serviceNameHash];\\n    }\\n\\n    function clearScheduledExecution(bytes32 scheduledExecution)\\n        external\\n        onlyOwner\\n        validateInput(36)\\n    {\\n        require(lastExecuted[scheduledExecution] > 0, \\\"registry/execution-not-scheduled\\\");\\n        lastExecuted[scheduledExecution] = 0;\\n        emit ChangeCancelled(scheduledExecution);\\n    }\\n\\n    event ChangeScheduled(bytes32 dataHash, uint256 scheduledFor, bytes data);\\n    event ChangeApplied(bytes32 dataHash, uint256 appliedAt, bytes data);\\n    event ChangeCancelled(bytes32 dataHash);\\n    event NamedServiceRemoved(bytes32 nameHash);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_serviceRegistry\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_dai\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_daiJoin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_jug\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowedDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"contract ManagerLike\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"drawDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jug\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"serviceRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "McdUtils", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000009b4ae7b164d195df9c4da5d08be88b2848b2eada0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000009759a6ac90977b93b58547b4a71c78317f391a2800000000000000000000000019c0976f590d67707e62397c87829d896dc0f1f1", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}