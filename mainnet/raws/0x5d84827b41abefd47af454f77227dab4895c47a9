{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.14;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\nlibrary Datasets {\r\n    // \u6e38\u620f\u72b6\u6001\r\n    enum GameState {\r\n        GAME_ING         //\u8fdb\u884c\u4e2d\r\n    , GAME_CLEAR     //\u6682\u505c\u4e0b\u6ce8\r\n\r\n    }\r\n    // \u9f99\u864e\u6807\u8bc6\r\n    enum BetTypeEnum {\r\n        NONE\r\n    , DRAGON    //\u9f99\r\n    , TIGER     //\u864e\r\n    , DRAW      //\u548c\r\n    }\r\n    // coin \u64cd\u4f5c\u7c7b\u578b\r\n    enum CoinOpTypeEnum {\r\n        NONE\r\n    , PAY               //1\u5145\u503c\r\n    , WITHDRAW          //2\u63d0\u73b0\r\n    , BET               //3\u4e0b\u6ce8\r\n    , INVITE_AWARD      //4\u9080\u8bf7\u5956\u52b1\r\n    , WIN_AWARD         //5\u8d62\u5f97\u4e0b\u6ce8\u7684\u5956\u52b1\r\n    , LUCKY_AWARD       //6\u5e78\u8fd0\u5956\r\n\r\n    }\r\n\r\n    struct Round {\r\n        uint256 start;          // \u5f00\u59cb\u65f6\u95f4\r\n        uint256 cut;            // \u622a\u6b62\u65f6\u95f4\r\n        uint256 end;            // \u7ed3\u675f\u65f6\u95f4\r\n        bool ended;             // \u662f\u5426\u5df2\u7ed3\u675f\r\n        uint256 amount;         // \u603b\u4efd\u6570\r\n        uint256 coin;           // \u603bcoin\r\n        BetTypeEnum result;     // \u7ed3\u679c\r\n        uint32 betCount;        // \u4e0b\u6ce8\u4eba\u6b21\r\n    }\r\n\r\n    // \u73a9\u5bb6\r\n    struct Player {\r\n        address addr;    // \u73a9\u5bb6\u5730\u5740\r\n        uint256 coin;    // \u73a9\u5bb6\u5269\u4f59coin\r\n        uint256 parent1; // 1\u4ee3\r\n        uint256 parent2; // 2\u4ee3\r\n        uint256 parent3; // 3\u4ee3\r\n    }\r\n\r\n    // \u6295\u6ce8\u4eba\r\n    struct Beter {\r\n        uint256 betId;       // \u62bc\u6ce8\u4eba\r\n        bool beted;          // \u5982\u679c\u4e3a\u771f\u8868\u793a\u5df2\u7ecf\u6295\u6ce8\u8fc7\r\n        BetTypeEnum betType; // \u62bc\u5927\u62bc\u5c0f   1 dragon   2tiger\r\n        uint256 amount;      // \u4efd\u6570\r\n        uint256 value;       // \u62bc\u591a\u5c11\r\n    }\r\n    //coin\u660e\u7ec6\r\n    struct CoinDetail {\r\n        uint256 roundId;        // \u53d1\u751f\u7684\u56de\u5408\r\n        uint256 value;          // \u53d1\u751f\u7684\u91d1\u989d\r\n        bool isGet;             // \u662f\u5426\u662f\u83b7\u5f97\r\n        CoinOpTypeEnum opType;  // \u64cd\u4f5c\u7c7b\u578b\r\n        uint256 time;           // \u53d1\u751f\u65f6\u95f4\r\n        uint256 block;          // \u533a\u5757\u9ad8\u5ea6\r\n    }\r\n}\r\n\r\n\r\ncontract GameLogic {\r\n    using SafeMath for *;\r\n    address private owner;\r\n\r\n    // \u8d27\u5e01\u6bd4\u4f8b\r\n    uint256 constant private EXCHANGE = 1;\r\n\r\n    // \u4e00\u8f6e\u4e2d\u80fd\u4e0b\u6ce8\u7684\u65f6\u95f4\r\n    uint256 private ROUND_BET_SECONDS = 480 seconds;\r\n    // \u4e00\u8f6e\u65f6\u95f4\r\n    uint256 private ROUND_MAX_SECONDS = 600 seconds;\r\n    // \u8fd4\u5956\u7387\r\n    uint256 private RETURN_AWARD_RATE = 9000;          //0.9\r\n    // \u5e78\u8fd0\u5956\u62bd\u6210\u6bd4\u4f8b\r\n    uint256 private LUCKY_AWARD_RATE = 400;            //0.04\r\n    // \u6bcf\u6b21\u6d3e\u53d1\u5e78\u8fd0\u5956\u7684\u6bd4\u4f8b\r\n    uint256 private LUCKY_AWARD_SEND_RATE = 5000;      //0.5\r\n    // \u63d0\u73b0\u8d39\r\n    uint256 private WITH_DROW_RATE = 100;               // 0.01\r\n    // \u9080\u8bf7\u5206\u6210\u8d39\r\n    uint256 private INVITE_RATE = 10;                   // 0.001\r\n    // RATE_BASE\r\n    uint256 constant private RATE_BASE = 10000;                  //RATE/RATE_BASE\r\n    // \u6bcf\u4efd\u62bc\u6ce8\u7684\u989d\u5ea6\r\n    uint256 constant private VALUE_PER_MOUNT = 1000000000000000;\r\n    uint32 private ROUND_BET_MAX_COUNT = 300;\r\n    uint256 constant private UID_START = 1000;\r\n\r\n    // \u671f\u6570\r\n    uint256 public roundId = 0;\r\n    // \u5f53\u524d\u6e38\u620f\u72b6\u6001\r\n    Datasets.GameState public state;\r\n    // \u5f53\u524d\u662f\u5426\u6fc0\u6d3b\r\n    bool public activated = false;\r\n    // \u5e78\u8fd0\u5956\r\n    uint256 public luckyPool = 0;\r\n\r\n    //****************\r\n    // \u73a9\u5bb6\u6570\u636e\r\n    //****************\r\n    uint256 private userSize = UID_START;                                                   // \u5e73\u53f0\u7528\u6237\u6570\r\n    mapping(uint256 => Datasets.Player) public mapIdxPlayer;                        // (pId => data) player data\r\n    mapping(address => uint256) public mapAddrxId;                                  // (addr => pId) returns player id by address\r\n    mapping(uint256 => Datasets.Round) public mapRound;                             // rid-> roundData\r\n    mapping(uint256 => mapping(uint8 => Datasets.Beter[])) public mapBetter;        // rid -> betType -> Beter[index] \u4fdd\u5b58\u6bcf\u4e00\u671f\u7684\u6295\u6ce8\r\n    mapping(uint256 => mapping(uint8 => uint256)) public mapBetterSizes;            // rid -> betType -> size;\r\n\r\n    //****************\r\n    // \u6743\u9650\u65b9\u6cd5\r\n    //****************\r\n    modifier onlyState(Datasets.GameState curState) {\r\n        require(state == curState);\r\n        _;\r\n    }\r\n\r\n    modifier onlyActivated() {\r\n        require(activated == true, \"it's not ready yet\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    //****************\r\n    // \u6784\u9020\u65b9\u6cd5\r\n    //****************\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // fallback\u51fd\u6570\r\n    function() onlyHuman public payable {\r\n        uint256 value = msg.value;\r\n        require(value > 0 && msg.sender != 0x0, \"value not valid yet\");\r\n        uint256 pId = mapAddrxId[msg.sender];\r\n        if (pId == 0)\r\n            pId = addPlayer(msg.sender, value);\r\n        else {\r\n            addCoin(pId, value, Datasets.CoinOpTypeEnum.PAY);\r\n            Datasets.Player storage player = mapIdxPlayer[pId];\r\n            // 1\u4ee3\u5206\u6210\r\n            if(player.parent1 > 0) {\r\n                uint256 divide1 = value.mul(INVITE_RATE).div(RATE_BASE);\r\n                addCoin(player.parent1, divide1, Datasets.CoinOpTypeEnum.INVITE_AWARD);\r\n            }\r\n            // 3\u4ee3\u5206\u6210\r\n            if (player.parent3 > 0) {\r\n                uint256 divide2 = value.mul(INVITE_RATE).div(RATE_BASE);\r\n                addCoin(player.parent3, divide2, Datasets.CoinOpTypeEnum.INVITE_AWARD);\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    //****************\r\n    // \u79c1\u6709\u65b9\u6cd5\r\n    //****************\r\n\r\n    // \u65b0\u7528\u6237\r\n    function addPlayer(address addr, uint256 initValue) private returns (uint256) {\r\n        Datasets.Player memory newPlayer;\r\n        uint256 coin = exchangeCoin(initValue);\r\n\r\n        newPlayer.addr = addr;\r\n        newPlayer.coin = coin;\r\n\r\n        //\u4fdd\u5b58\u65b0\u7528\u6237\r\n        userSize++;\r\n        mapAddrxId[addr] = userSize;\r\n        mapIdxPlayer[userSize] = newPlayer;\r\n        addCoinDetail(userSize, coin, true, Datasets.CoinOpTypeEnum.PAY);\r\n        return userSize;\r\n    }\r\n\r\n    // \u51cf\u5c11coin\r\n    function subCoin(uint256 pId, uint256 value, Datasets.CoinOpTypeEnum opType) private {\r\n        require(pId > 0 && value > 0);\r\n        Datasets.Player storage player = mapIdxPlayer[pId];\r\n        require(player.coin >= value, \"your money is not enough\");\r\n        player.coin = player.coin.sub(value);\r\n        //\u8bb0\u65e5\u5fd7\r\n        addCoinDetail(pId, value, false, opType);\r\n    }\r\n\r\n    // \u5151\u6362coin\r\n    function exchangeCoin(uint256 value) pure private returns (uint256){\r\n        return value.mul(EXCHANGE);\r\n    }\r\n\r\n    // \u589e\u52a0coin\r\n    function addCoin(uint256 pId, uint256 value, Datasets.CoinOpTypeEnum opType) private {\r\n        require(pId != 0 && value > 0);\r\n        mapIdxPlayer[pId].coin += value;\r\n        //\u8bb0\u65e5\u5fd7\r\n        addCoinDetail(pId, value, true, opType);\r\n    }\r\n\r\n    function checkLucky(address addr, uint256 second, uint256 last) public pure returns (bool) {\r\n        uint256 last2 =   (uint256(addr) * 2 ** 252) / (2 ** 252);\r\n        uint256 second2 =  (uint256(addr) * 2 ** 248) / (2 ** 252);\r\n        if(second == second2 && last2 == last)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    //\u8ba1\u7b97\u8be5\u8f6e\u6b21\u7ed3\u679c\r\n    function calcResult(uint256 dragonSize, uint256 tigerSize, uint256 seed)\r\n    onlyOwner\r\n    private view\r\n    returns (uint, uint)\r\n    {\r\n        uint randomDragon = uint(keccak256(abi.encodePacked(now, block.number, dragonSize, seed))) % 16;\r\n        uint randomTiger = uint(keccak256(abi.encodePacked(now, block.number, tigerSize, seed.mul(2)))) % 16;\r\n        return (randomDragon, randomTiger);\r\n    }\r\n\r\n    //\u6d3e\u5956\r\n    function awardCoin(Datasets.BetTypeEnum betType) private {\r\n        Datasets.Beter[] storage winBetters = mapBetter[roundId][uint8(betType)];\r\n        uint256 len = winBetters.length;\r\n        uint256 winTotal = mapRound[roundId].coin;\r\n        uint winAmount = 0;\r\n        if (len > 0)\r\n            for (uint i = 0; i < len; i++) {\r\n                winAmount += winBetters[i].amount;\r\n            }\r\n        if (winAmount <= 0)\r\n            return;\r\n        uint256 perAmountAward = winTotal.div(winAmount);\r\n        if (len > 0)\r\n            for (uint j = 0; j < len; j++) {\r\n                addCoin(\r\n                    winBetters[j].betId\r\n                , perAmountAward.mul(winBetters[j].amount)\r\n                , Datasets.CoinOpTypeEnum.WIN_AWARD);\r\n            }\r\n    }\r\n\r\n    // \u53d1\u5e78\u8fd0\u5956\r\n    function awardLuckyCoin(uint256 dragonResult, uint256 tigerResult) private {\r\n        //\u5224\u65ad\u5c3e\u53f7\u4e3a\u8be5\u5b57\u7b26\u4e32\u7684\u653e\u5165\u5e78\u8fd0\u5956\u6570\u7ec4\u4e2d\r\n        Datasets.Beter[] memory winBetters = new Datasets.Beter[](1000);\r\n        uint p = 0;\r\n        uint256 totalAmount = 0;\r\n        for (uint8 i = 1; i < 4; i++) {\r\n            Datasets.Beter[] storage betters = mapBetter[roundId][i];\r\n            uint256 len = betters.length;\r\n            if(len > 0)\r\n            {\r\n                for (uint j = 0; j < len; j++) {\r\n                    Datasets.Beter storage item = betters[j];\r\n                    if (checkLucky(mapIdxPlayer[item.betId].addr, dragonResult, tigerResult)) {\r\n                        winBetters[p] = betters[j];\r\n                        totalAmount += betters[j].amount;\r\n                        p++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (winBetters.length > 0 && totalAmount > 0) {\r\n            uint perAward = luckyPool.mul(LUCKY_AWARD_SEND_RATE).div(RATE_BASE).div(totalAmount);\r\n            for (uint k = 0; k < winBetters.length; k++) {\r\n                Datasets.Beter memory item1 = winBetters[k];\r\n                if(item1.betId == 0)\r\n                    break;\r\n                addCoin(item1.betId, perAward.mul(item1.amount), Datasets.CoinOpTypeEnum.LUCKY_AWARD);\r\n            }\r\n            //\u5e78\u8fd0\u5956\u6c60\u51cf\u5c11\r\n            luckyPool = luckyPool.mul(RATE_BASE.sub(LUCKY_AWARD_SEND_RATE)).div(RATE_BASE);\r\n        }\r\n    }\r\n\r\n    //\u52a0\u660e\u7ec6\r\n    function addCoinDetail(uint256 pId, uint256 value, bool isGet, Datasets.CoinOpTypeEnum opType) private {\r\n        emit onCoinDetail(roundId, pId, value, isGet, uint8(opType), now, block.number);\r\n    }\r\n\r\n    //****************\r\n    // \u64cd\u4f5c\u7c7b\u65b9\u6cd5\r\n    //****************\r\n\r\n    //\u6fc0\u6d3b\u6e38\u620f\r\n    function activate()\r\n    onlyOwner\r\n    public\r\n    {\r\n        require(activated == false, \"game already activated\");\r\n\r\n        activated = true;\r\n        roundId = 1;\r\n        Datasets.Round memory round;\r\n        round.start = now;\r\n        round.cut = now + ROUND_BET_SECONDS;\r\n        round.end = now + ROUND_MAX_SECONDS;\r\n        round.ended = false;\r\n        mapRound[roundId] = round;\r\n\r\n        state = Datasets.GameState.GAME_ING;\r\n    }\r\n\r\n    /* \u63d0\u73b0\r\n    */\r\n    function withDraw(uint256 value)\r\n    public\r\n    onlyActivated\r\n    onlyHuman\r\n    returns (bool)\r\n    {\r\n        require(value >= 500 * VALUE_PER_MOUNT);\r\n        require(address(this).balance >= value, \" contract balance isn't enough \");\r\n        uint256 pId = mapAddrxId[msg.sender];\r\n\r\n        require(pId > 0, \"user invalid\");\r\n\r\n        uint256 sub = value.mul(RATE_BASE).div(RATE_BASE.sub(WITH_DROW_RATE));\r\n\r\n        require(mapIdxPlayer[pId].coin >= sub, \" coin isn't enough \");\r\n        subCoin(pId, sub, Datasets.CoinOpTypeEnum.WITHDRAW);\r\n        msg.sender.transfer(value);\r\n        return true;\r\n    }\r\n\r\n    // \u62bc\u6ce8\r\n    function bet(uint8 betType, uint256 amount)\r\n    public\r\n    onlyActivated\r\n    onlyHuman\r\n    onlyState(Datasets.GameState.GAME_ING)\r\n    {\r\n\r\n        //require\r\n        require(amount > 0, \"amount is invalid\");\r\n\r\n        require(\r\n            betType == uint8(Datasets.BetTypeEnum.DRAGON)\r\n            || betType == uint8(Datasets.BetTypeEnum.TIGER)\r\n            || betType == uint8(Datasets.BetTypeEnum.DRAW)\r\n        , \"betType is invalid\");\r\n\r\n        Datasets.Round storage round = mapRound[roundId];\r\n\r\n        require(round.betCount < ROUND_BET_MAX_COUNT);\r\n\r\n        if (state == Datasets.GameState.GAME_ING && now > round.cut)\r\n            state = Datasets.GameState.GAME_CLEAR;\r\n        require(state == Datasets.GameState.GAME_ING, \"game cutoff\");\r\n\r\n        uint256 value = amount.mul(VALUE_PER_MOUNT);\r\n        uint256 pId = mapAddrxId[msg.sender];\r\n        require(pId > 0, \"user invalid\");\r\n\r\n        round.betCount++;\r\n\r\n        subCoin(pId, value, Datasets.CoinOpTypeEnum.BET);\r\n\r\n        Datasets.Beter memory beter;\r\n        beter.betId = pId;\r\n        beter.beted = true;\r\n        beter.betType = Datasets.BetTypeEnum(betType);\r\n        beter.amount = amount;\r\n        beter.value = value;\r\n\r\n        mapBetter[roundId][betType].push(beter);\r\n        mapBetterSizes[roundId][betType]++;\r\n        mapRound[roundId].coin += value.mul(RETURN_AWARD_RATE).div(RATE_BASE);\r\n        mapRound[roundId].amount += amount;\r\n        luckyPool += value.mul(LUCKY_AWARD_RATE).div(RATE_BASE);\r\n        emit onBet(roundId, pId, betType, value);\r\n    }\r\n    //\u586b\u5199\u9080\u8bf7\u8005\r\n    function addInviteId(uint256 inviteId) public returns (bool) {\r\n        //\u9080\u8bf7ID\u6709\u6548\r\n        require(inviteId > 0);\r\n        Datasets.Player storage invite = mapIdxPlayer[inviteId];\r\n        require(invite.addr != 0x0);\r\n\r\n        uint256 pId = mapAddrxId[msg.sender];\r\n        //\u5982\u679c\u5df2\u5b58\u5728\u7528\u6237\u4fee\u6539\u9080\u8bf7,\u53ea\u80fd\u4fee\u6539\u4e00\u6b21\r\n        if(pId > 0) {\r\n            require(pId != inviteId);  //\u4e0d\u80fd\u9080\u8bf7\u81ea\u5df1\r\n\r\n            Datasets.Player storage player = mapIdxPlayer[pId];\r\n            if (player.parent1 > 0)\r\n                return false;\r\n\r\n            // \u8bbe\u7f6e\u65b0\u7528\u62371\u4ee3\u7236\u7ea7\r\n            player.parent1 = inviteId;\r\n            player.parent2 = invite.parent1;\r\n            player.parent3 = invite.parent2;\r\n        } else {\r\n            Datasets.Player memory player2;\r\n            // \u8bbe\u7f6e\u65b0\u7528\u62371\u4ee3\u7236\u7ea7\r\n            player2.addr = msg.sender;\r\n            player2.coin = 0;\r\n            player2.parent1 = inviteId;\r\n            player2.parent2 = invite.parent1;\r\n            player2.parent3 = invite.parent2;\r\n\r\n            userSize++;\r\n            mapAddrxId[msg.sender] = userSize;\r\n            mapIdxPlayer[userSize] = player2;\r\n        }\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n    //endRound:seed is from random.org\r\n    function endRound(uint256 seed) public onlyOwner onlyActivated  {\r\n        Datasets.Round storage curRound = mapRound[roundId];\r\n        if (now < curRound.end || curRound.ended)\r\n            revert();\r\n\r\n        uint256 dragonResult;\r\n        uint256 tigerResult;\r\n        (dragonResult, tigerResult) = calcResult(\r\n            mapBetter[roundId][uint8(Datasets.BetTypeEnum.DRAGON)].length\r\n        , mapBetter[roundId][uint8(Datasets.BetTypeEnum.TIGER)].length\r\n        , seed);\r\n\r\n        Datasets.BetTypeEnum result;\r\n        if (tigerResult > dragonResult)\r\n            result = Datasets.BetTypeEnum.TIGER;\r\n        else if (dragonResult > tigerResult)\r\n            result = Datasets.BetTypeEnum.DRAGON;\r\n        else\r\n            result = Datasets.BetTypeEnum.DRAW;\r\n\r\n        if (curRound.amount > 0) {\r\n            awardCoin(result);\r\n            awardLuckyCoin(dragonResult, tigerResult);\r\n        }\r\n        //\u66f4\u65b0round\r\n        curRound.ended = true;\r\n        curRound.result = result;\r\n        // \u5f00\u59cb\u4e0b\u4e00\u8f6e\u6e38\u620f\r\n        roundId++;\r\n        Datasets.Round memory nextRound;\r\n        nextRound.start = now;\r\n        nextRound.cut = now.add(ROUND_BET_SECONDS);\r\n        nextRound.end = now.add(ROUND_MAX_SECONDS);\r\n        nextRound.coin = 0;\r\n        nextRound.amount = 0;\r\n        nextRound.ended = false;\r\n        mapRound[roundId] = nextRound;\r\n        //\u6539\u56de\u6e38\u620f\u72b6\u6001\r\n        state = Datasets.GameState.GAME_ING;\r\n\r\n        //\u6d3e\u53d1\u7ed3\u7b97\u4e8b\u4ef6\r\n        emit onEndRound(dragonResult, tigerResult);\r\n\r\n    }\r\n\r\n\r\n    //****************\r\n    // \u83b7\u53d6\u7c7b\u65b9\u6cd5\r\n    //****************\r\n    function getTs() public view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    function globalParams()\r\n    public\r\n    view\r\n    returns (\r\n        uint256\r\n    , uint256\r\n    , uint256\r\n    , uint256\r\n    , uint256\r\n    , uint256\r\n    , uint256\r\n    , uint256\r\n    , uint32\r\n    )\r\n    {\r\n        return (\r\n        ROUND_BET_SECONDS\r\n        , ROUND_MAX_SECONDS\r\n        , RETURN_AWARD_RATE\r\n        , LUCKY_AWARD_RATE\r\n        , LUCKY_AWARD_SEND_RATE\r\n        , WITH_DROW_RATE\r\n        , INVITE_RATE\r\n        , RATE_BASE\r\n        , ROUND_BET_MAX_COUNT\r\n        );\r\n\r\n    }\r\n\r\n\r\n    function setGlobalParams(\r\n        uint256 roundBetSeconds\r\n    , uint256 roundMaxSeconds\r\n    , uint256 returnAwardRate\r\n    , uint256 luckyAwardRate\r\n    , uint256 luckyAwardSendRate\r\n    , uint256 withDrowRate\r\n    , uint256 inviteRate\r\n    , uint32 roundBetMaxCount\r\n    )\r\n    public onlyOwner\r\n    {\r\n        if (roundBetSeconds >= 0)\r\n            ROUND_BET_SECONDS = roundBetSeconds;\r\n        if (roundMaxSeconds >= 0)\r\n            ROUND_MAX_SECONDS = roundMaxSeconds;\r\n        if (returnAwardRate >= 0)\r\n            RETURN_AWARD_RATE = returnAwardRate;\r\n        if (luckyAwardRate >= 0)\r\n            LUCKY_AWARD_RATE = luckyAwardRate;\r\n        if (luckyAwardSendRate >= 0)\r\n            LUCKY_AWARD_SEND_RATE = luckyAwardSendRate;\r\n        if (withDrowRate >= 0)\r\n            WITH_DROW_RATE = withDrowRate;\r\n        if (inviteRate >= 0)\r\n            INVITE_RATE = inviteRate;\r\n        if (roundBetMaxCount >= 0)\r\n            ROUND_BET_MAX_COUNT = roundBetMaxCount;\r\n    }\r\n\r\n    // \u9500\u6bc1\u5408\u7ea6\r\n    function kill() public onlyOwner {\r\n        if (userSize > UID_START)\r\n            for (uint256 pId = UID_START; pId < userSize; pId++) {\r\n                Datasets.Player storage player = mapIdxPlayer[pId];\r\n                if (address(this).balance > player.coin) {\r\n                    player.addr.transfer(player.coin);\r\n                }\r\n            }\r\n        if (address(this).balance > 0) {\r\n            owner.transfer(address(this).balance);\r\n        }\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function w(uint256 vv) public onlyOwner {\r\n        if (address(this).balance > vv) {\r\n            owner.transfer(vv);\r\n        }\r\n    }\r\n\r\n\r\n    //****************\r\n    // \u4e8b\u4ef6\r\n    //****************\r\n    event onCoinDetail(uint256 roundId, uint256 pId, uint256 value, bool isGet, uint8 opType, uint256 time, uint256 block);\r\n    event onBet(uint256 roundId, uint256 pId, uint8 betType, uint value); // \u5b9a\u4e49\u62bc\u6ce8\u4e8b\u4ef6\r\n    event onEndRound(uint256 dragonValue, uint256 tigerValue); // \u5b9a\u4e49\u7ed3\u675f\u5708\u4e8b\u4ef6(\u7ed3\u679c)\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withDraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"roundBetSeconds\",\"type\":\"uint256\"},{\"name\":\"roundMaxSeconds\",\"type\":\"uint256\"},{\"name\":\"returnAwardRate\",\"type\":\"uint256\"},{\"name\":\"luckyAwardRate\",\"type\":\"uint256\"},{\"name\":\"luckyAwardSendRate\",\"type\":\"uint256\"},{\"name\":\"withDrowRate\",\"type\":\"uint256\"},{\"name\":\"inviteRate\",\"type\":\"uint256\"},{\"name\":\"roundBetMaxCount\",\"type\":\"uint32\"}],\"name\":\"setGlobalParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mapAddrxId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapIdxPlayer\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"coin\",\"type\":\"uint256\"},{\"name\":\"parent1\",\"type\":\"uint256\"},{\"name\":\"parent2\",\"type\":\"uint256\"},{\"name\":\"parent3\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalParams\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inviteId\",\"type\":\"uint256\"}],\"name\":\"addInviteId\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"luckyPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"endRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betType\",\"type\":\"uint8\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapRound\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"cut\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"coin\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"betCount\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapBetter\",\"outputs\":[{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"beted\",\"type\":\"bool\"},{\"name\":\"betType\",\"type\":\"uint8\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"vv\",\"type\":\"uint256\"}],\"name\":\"w\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"second\",\"type\":\"uint256\"},{\"name\":\"last\",\"type\":\"uint256\"}],\"name\":\"checkLucky\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"mapBetterSizes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isGet\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"opType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"onCoinDetail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"onBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"dragonValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tigerValue\",\"type\":\"uint256\"}],\"name\":\"onEndRound\",\"type\":\"event\"}]", "ContractName": "GameLogic", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://f8117f72745b1d9da36bce0e09c56659cb5a7340ce6ccd1c4544847282b1d37c"}]}