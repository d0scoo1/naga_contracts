{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\r\n *\r\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\r\n * stuck.\r\n *\r\n * @dev _Available since v3.1._\r\n */\r\ncontract ERC1155Holder is ERC1155Receiver {\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n\r\n// File: contracts/aiNFT.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n\r\n\r\ninterface mintNFT{\r\n      function mint(\r\n        uint256 _category,\r\n        bytes memory _data,\r\n        bytes memory _signature\r\n    ) external ;\r\n}\r\n\r\n\r\ninterface transNFT{\r\n      function safeBatchTransferFrom(\r\n       address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external ;\r\n}\r\n\r\n \r\n\r\ncontract NaiveHodler {}\r\ncontract Claims  is   ERC1155Holder{\r\n      \r\n\r\n     // \u5b9a\u4e49\u4e8b\u4ef6\r\n    event adressEvent(address indexed originOp, address indexed sender,address indexed myaddress);\r\n\r\n\r\n    uint public countNumber ;\r\n\r\n\r\n     //address public nowAdr;\r\n\r\n       uint256[] public ids =     [1,2,3,4,5,6,7,8,9];\r\n        uint256[]  public amounts = [1,1,1,1,1,1,1,1,1];\r\n        //  uint256[] public ids =     [1];\r\n        // uint256[]  public amounts = [1];\r\n        bytes public  data =\"0x\";\r\n  \r\n    constructor(uint num){\r\n          // \u89e6\u53d1\u4e8b\u4ef6\r\n        emit adressEvent(tx.origin, msg.sender,  address(this));\r\n        countNumber = num ;\r\n    } \r\n\r\n\r\n   function doMint(address  contra ,bytes[] memory datas, bytes[] memory signatures) public  {\r\n        mintNFT(contra).mint(1, datas[0], signatures[0] ) ;\r\n        mintNFT(contra).mint(2,datas[1], signatures[1] ) ;\r\n        mintNFT(contra).mint(3,datas[2], signatures[2] ) ;\r\n        mintNFT(contra).mint(4,datas[3], signatures[3] ) ;\r\n        mintNFT(contra).mint(5,datas[4], signatures[4] ) ;\r\n        mintNFT(contra).mint(6,datas[5], signatures[5] ) ;\r\n        mintNFT(contra).mint(7,datas[6], signatures[6] ) ;\r\n        mintNFT(contra).mint(8,datas[7], signatures[7] ) ;\r\n        mintNFT(contra).mint(9,datas[8], signatures[8] ) ;\r\n        transNFT(contra).safeBatchTransferFrom( \r\n           address(this), \r\n           address(tx.origin) ,\r\n           ids,\r\n           amounts,\r\n           data\r\n        );\r\n        selfdestruct(payable(address(tx.origin)));\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract  MainASJMultiClaim{\r\n    address constant contra = address(0xFD43D1dA000558473822302e1d44D81dA2e4cC0d);\r\n  //  address constant nftContra = address(0xFD43D1dA000558473822302e1d44D81dA2e4cC0d);//\u4e3b\u7f51\u5408\u7ea6\r\n  // address constant nftContra = address(0xc169B28d3eA128ACe729fb7E7C27f6Ec0a95f549);//ROPSTEN\u6d4b\u8bd5\u7f51\r\n\r\n    //address constant contra = address(0x951331F36F27ebe99c1008AF68dC11D5A802E340);//RK \u6d4b\u8bd5\r\n\r\n   // address constant contra = address(0xFD43D1dA000558473822302e1d44D81dA2e4cC0d);//\r\n\r\n    // address constant contra = address(0xd9145CCE52D386f254917e481eB44e9943F39138);//bendi\r\n\r\n    \r\n \r\n\r\n     address public nowAdr;\r\n     address public prenowAdr;\r\n\r\n    struct Record {\r\n       uint countNumber;\r\n       bytes[]  _data;\r\n       bytes[]  _signature;\r\n    }\r\n\r\n\r\n   //\u5355\u4e2a\u94b1\u5305mint\r\n   function singleMint(bytes32 salt,uint countNumber,  bytes[] memory _data, bytes[] memory _signature) public  {\r\n          // bytes32 mintsalt =0x1;\r\n           Claims claims = new Claims{salt: salt}(countNumber);\r\n           claims.doMint(  contra , _data,  _signature) ;\r\n   } \r\n\r\n\r\n\r\n     //duo\u4e2a\u94b1\u5305mint\r\n   function mulMint(bytes32 salt,  Record[] memory records) public  {\r\n           // bytes32 mintsalt =0x1;\r\n         for(uint i= 0;i<records.length ;i++ ){\r\n              Record memory record =  records[i];\r\n              uint countNumber = record.countNumber;\r\n              bytes[]  memory data = record._data;\r\n               bytes[]  memory signature = record._signature;\r\n             Claims claims = new Claims{salt: salt}(countNumber);\r\n             claims.doMint(  contra , data,  signature) ;\r\n         }\r\n       \r\n   } \r\n\r\n\r\n\r\n   function testCreateDSalted(bytes32 salt,uint arg) public {\r\n\r\n        address predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(\r\n            bytes1(0xff),\r\n            address(this),\r\n            salt,\r\n            keccak256(abi.encodePacked(\r\n                type(Claims).creationCode,\r\n                arg\r\n            ))\r\n        )))));\r\n\r\n        Claims d = new Claims{salt:  salt}(arg);\r\n        nowAdr = address(d);\r\n        prenowAdr = predictedAddress;\r\n        //require(address(d) == predictedAddress);\r\n    }\r\n\r\n\r\n       function createDSalted( bytes32 salt ,uint arg) public {\r\n        // bytes32 salt =\"0x123\";\r\n        nowAdr = address(0);\r\n        prenowAdr = address(0);\r\n        /// \u8fd9\u4e2a\u590d\u6742\u7684\u8868\u8fbe\u5f0f\u53ea\u662f\u544a\u8bc9\u6211\u4eec\uff0c\u5982\u4f55\u9884\u5148\u8ba1\u7b97\u5730\u5740\u3002\r\n        /// \u8fd9\u91cc\u4ec5\u4ec5\u7528\u6765\u8bf4\u660e\u3002\r\n        /// \u5b9e\u9645\u4e0a\uff0c\u4f60\u4ec5\u4ec5\u9700\u8981 ``new D{salt: salt}(arg)``.\r\n        address predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(\r\n            bytes1(0xff),\r\n            address(this),\r\n            salt,\r\n            keccak256(abi.encodePacked(\r\n                type(Claims).creationCode,\r\n                arg\r\n            ))\r\n        )))));\r\n\r\n        // Claims d = new Claims{salt: salt}(arg);\r\n        // nowAdr = address(d);\r\n        prenowAdr = predictedAddress;\r\n        //require(address(d) == predictedAddress);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"arg\",\"type\":\"uint256\"}],\"name\":\"createDSalted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"countNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"_data\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_signature\",\"type\":\"bytes[]\"}],\"internalType\":\"struct MainASJMultiClaim.Record[]\",\"name\":\"records\",\"type\":\"tuple[]\"}],\"name\":\"mulMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nowAdr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prenowAdr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"countNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"_data\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_signature\",\"type\":\"bytes[]\"}],\"name\":\"singleMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"arg\",\"type\":\"uint256\"}],\"name\":\"testCreateDSalted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MainASJMultiClaim", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f5aa00ca7f4a818968c019841e265b9a00b7cc5032755e062ca895685931b8d7"}]}