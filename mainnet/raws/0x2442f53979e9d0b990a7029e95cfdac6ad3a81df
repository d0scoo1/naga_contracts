{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TsujiPoker/src/TsujiPoker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\nimport \\\"base64-sol/base64.sol\\\";\\nimport \\\"./Renderer.sol\\\";\\n\\n/// @title TsujiPoker\\n/// @author Shun Kakinoki\\n/// @notice Contract for certifying \\\"poker bound\\\" nfts\\n/// @notice Soulbount nft code is heavily taken from Miguel's awesome Souminter contracts: https://github.com/m1guelpf/soulminter-contracts\\ncontract TsujiPoker is Renderer {\\n  error NotPlayer();\\n  error PokerBound();\\n  error NotEnoughEth();\\n  error TsujiNotBack();\\n\\n  event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n  string public constant symbol = \\\"TSUJI\\\";\\n  string public constant name = \\\"Tsuji Poker NFT\\\";\\n  uint256 public immutable quorum = 5;\\n\\n  struct player {\\n    uint256 rank;\\n    string name;\\n    bool voted;\\n  }\\n\\n  mapping(address => player) public playerOf;\\n  mapping(uint256 => address) public ownerOf;\\n  mapping(address => uint256) public balanceOf;\\n\\n  // shugo.eth\\n  address payable internal immutable shugo =\\n    payable(address(0xE95330D7CDcd37bf0Ad875C29e2a2871FeFa3De8));\\n  uint256 internal nextTokenId = 1;\\n  uint256 public tsujiBackVote = 0;\\n\\n  constructor() payable {\\n    // shugo.eth\\n    playerOf[shugo] = player(2, \\\"shugo.eth\\\", false);\\n    // tomona.eth\\n    playerOf[address(0x2aF8DDAb77A7c90a38CF26F29763365D0028cfEf)] = player(\\n      8,\\n      \\\"mona.eth\\\",\\n      false\\n    );\\n    // kaki.eth\\n    playerOf[address(0x4fd9D0eE6D6564E80A9Ee00c0163fC952d0A45Ed)] = player(\\n      9,\\n      \\\"kaki.eth\\\",\\n      false\\n    );\\n    // kohei.eth\\n    playerOf[address(0x5D025814b6a21Cd6fcb4112F40f88bC823e6A9ab)] = player(\\n      6,\\n      \\\"kohei.eth\\\",\\n      false\\n    );\\n    // datz.eth\\n    playerOf[address(0x1F80593194F5E71087cAfF5309e85Fe68292CB63)] = player(\\n      3,\\n      \\\"datz.eth\\\",\\n      false\\n    );\\n    // eisuke.eth\\n    playerOf[address(0x7E989e785d0836b509B814a7898356FdeAAAE889)] = player(\\n      5,\\n      \\\"eisuke.eth\\\",\\n      false\\n    );\\n    // thomaskobayashi.eth\\n    playerOf[address(0xD30Fb00c2796cBAD72f6B9C410830Dc4FF05bA71)] = player(\\n      7,\\n      \\\"thomaskobayashi.eth\\\",\\n      false\\n    );\\n    // inakazu\\n    playerOf[address(0x5dC79C9fB20B6A81588a32589cb8Ae8f4983DfBc)] = player(\\n      4,\\n      \\\"inakazu\\\",\\n      false\\n    );\\n    // futa\\n    playerOf[address(0xe7236c912945C8B915c7C60b55e330b959801B45)] = player(\\n      10,\\n      \\\"futa\\\",\\n      false\\n    );\\n    // oliver\\n    playerOf[address(0x70B122116b50178D881e74Ec97b89c67E90b4A7c)] = player(\\n      1,\\n      \\\"oliver-diary.eth\\\",\\n      false\\n    );\\n  }\\n\\n  modifier onlyIfTsujiBack() {\\n    if (tsujiBackVote < quorum) revert TsujiNotBack();\\n    _;\\n  }\\n\\n  modifier onlyIfPlayer() {\\n    if (playerOf[msg.sender].rank == 0) revert NotPlayer();\\n    _;\\n  }\\n\\n  function approve(address, uint256) public virtual {\\n    revert PokerBound();\\n  }\\n\\n  function isApprovedForAll(address, address) public pure {\\n    revert PokerBound();\\n  }\\n\\n  function getApproved(uint256) public pure {\\n    revert PokerBound();\\n  }\\n\\n  function setApprovalForAll(address, bool) public virtual {\\n    revert PokerBound();\\n  }\\n\\n  function transferFrom(\\n    address,\\n    address,\\n    uint256\\n  ) public virtual {\\n    revert PokerBound();\\n  }\\n\\n  function safeTransferFrom(\\n    address,\\n    address,\\n    uint256\\n  ) public virtual {\\n    revert PokerBound();\\n  }\\n\\n  function safeTransferFrom(\\n    address,\\n    address,\\n    uint256,\\n    bytes calldata\\n  ) public virtual {\\n    revert PokerBound();\\n  }\\n\\n  function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\\n    return\\n      interfaceId == 0x01ffc9a7 ||\\n      interfaceId == 0x80ac58cd ||\\n      interfaceId == 0x5b5e139f;\\n  }\\n\\n  function mint() public payable onlyIfPlayer {\\n    if (msg.value < 0.01 ether) revert NotEnoughEth();\\n    if (balanceOf[msg.sender] > 0) revert PokerBound();\\n\\n    unchecked {\\n      balanceOf[msg.sender]++;\\n    }\\n\\n    ownerOf[nextTokenId] = msg.sender;\\n    emit Transfer(address(0), msg.sender, nextTokenId++);\\n  }\\n\\n  function tokenURI(uint256 tokenId) public view returns (string memory) {\\n    return\\n      string(\\n        abi.encodePacked(\\n          \\\"data:application/json;base64,\\\",\\n          Base64.encode(\\n            bytes(\\n              abi.encodePacked(\\n                '{\\\"name\\\":\\\"Tsuji Poker\\\",',\\n                '\\\"image\\\":\\\"data:image/svg+xml;base64,',\\n                Base64.encode(\\n                  bytes(\\n                    render(\\n                      playerOf[ownerOf[tokenId]].name,\\n                      playerOf[ownerOf[tokenId]].rank\\n                    )\\n                  )\\n                ),\\n                '\\\", \\\"description\\\": \\\"Tsuji Poker Night in San Francisco on 2022/05/29\\\"}'\\n              )\\n            )\\n          )\\n        )\\n      );\\n  }\\n\\n  function rankOf(address _to) public view returns (uint256) {\\n    return playerOf[_to].rank;\\n  }\\n\\n  function voterClaimOf(address _to) public view returns (bool) {\\n    return playerOf[_to].voted;\\n  }\\n\\n  function vote() public onlyIfPlayer {\\n    if (balanceOf[msg.sender] == 0) revert PokerBound();\\n    if (playerOf[msg.sender].voted == true) revert PokerBound();\\n\\n    unchecked {\\n      playerOf[msg.sender].voted = true;\\n      tsujiBackVote++;\\n    }\\n  }\\n\\n  function withdraw() public onlyIfPlayer onlyIfTsujiBack {\\n    shugo.transfer(address(this).balance);\\n  }\\n\\n  fallback() external payable {}\\n}\\n\"\r\n    },\r\n    \"lib/base64/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TsujiPoker/src/Renderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\nimport { ENSNameResolver } from \\\"./libs/ENSNameResolver.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\npragma solidity ^0.8.13;\\n\\ncontract Renderer is ENSNameResolver {\\n  using Strings for uint256;\\n\\n  function render(string memory _owner, uint256 _rank)\\n    public\\n    pure\\n    returns (string memory)\\n  {\\n    string memory rankString = Strings.toString(_rank);\\n\\n    return\\n      string.concat(\\n        '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 350 350\\\"><style>.base { fill: white; font-family: serif; font-size: 14px; }</style><rect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"black\\\" /><text x=\\\"10\\\" y=\\\"20\\\" class=\\\"base\\\">Tsuji Poker Night</text><text x=\\\"10\\\" y=\\\"40\\\" class=\\\"base\\\">Player:</text><text x=\\\"10\\\" y=\\\"60\\\" class=\\\"base\\\">',\\n        _owner,\\n        '</text><text x=\\\"10\\\" y=\\\"80\\\" class=\\\"base\\\">Rank:</text><text x=\\\"10\\\" y=\\\"100\\\" class=\\\"base\\\">',\\n        rankString,\\n        \\\"</text></svg>\\\"\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/TsujiPoker/src/libs/ENSNameResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\ninterface IReverseRegistrar {\\n  function node(address addr) external view returns (bytes32);\\n}\\n\\ninterface IReverseResolver {\\n  function name(bytes32 node) external view returns (string memory);\\n}\\n\\ncontract ENSNameResolver {\\n  IReverseRegistrar constant registrar =\\n    IReverseRegistrar(0x084b1c3C81545d370f3634392De611CaaBFf8148);\\n  IReverseResolver constant resolver =\\n    IReverseResolver(0xA2C122BE93b0074270ebeE7f6b7292C7deB45047);\\n\\n  function getENSName(address addr) public view returns (string memory) {\\n    try resolver.name(registrar.node(addr)) {\\n      return resolver.name(registrar.node(addr));\\n    } catch {\\n      return \\\"\\\";\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@0xsequence/sstore2/=lib/sstore2/\",\r\n      \"@chainlink/=lib/chainlink/\",\r\n      \"@divergencetech/ethier/=lib/ethier/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@rari-capital/solmate/=lib/solmate/\",\r\n      \"@shunkakinoki/aave/=contracts/Aave/src/\",\r\n      \"@shunkakinoki/box/=contracts/Box/src/\",\r\n      \"@shunkakinoki/greeter/=contracts/Greeter/src/\",\r\n      \"@shunkakinoki/huff/=contracts/HuffDeployer/src/\",\r\n      \"@zoralabs/nft-editions-contracts/=lib/nft-editions/\",\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"base64-sol/=lib/base64/\",\r\n      \"base64/=lib/base64/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"clones-with-immutable-args/=lib/clones-with-immutable-args/src/\",\r\n      \"contracts/=contracts/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"erc721a/=lib/ERC721A/\",\r\n      \"ethier/=lib/ethier/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=lib/hardhat/packages/hardhat-core/\",\r\n      \"hot-chain-svg/=lib/hot-chain-svg/contracts/\",\r\n      \"nft-editions/=lib/nft-editions/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"sstore2/=lib/sstore2/contracts/\",\r\n      \"contracts/=contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NotEnoughEth\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPlayer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PokerBound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TsujiNotBack\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getENSName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rank\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"voted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"rankOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_owner\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_rank\",\"type\":\"uint256\"}],\"name\":\"render\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tsujiBackVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"voterClaimOf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TsujiPoker", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}