{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FNDMiddleware.sol\": {\r\n      \"content\": \"/*\\n  \uff65\\n   *\u3000\u2605\\n      \uff65 \uff61\\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\\n\u200b\\n                      `                     .-:::::-.`              `-::---...```\\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\\n                                              `````\\n   *\u3000\\n      \uff65 \uff61\\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\\n\u3000\uff65\uff9f*\uff61\u2605\uff65\\n \u2606\u2234\uff61\u3000*\\n\uff65 \uff61\\n*/\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport \\\"./FNDNFTMarket.sol\\\";\\nimport \\\"./PercentSplitETH.sol\\\";\\nimport \\\"./CollectionContract.sol\\\";\\nimport \\\"./mixins/Constants.sol\\\";\\nimport \\\"./FETH.sol\\\";\\nimport \\\"./interfaces/ens/IENS.sol\\\";\\nimport \\\"./interfaces/ens/IPublicResolver.sol\\\";\\nimport \\\"./interfaces/ens/IReverseRegistrar.sol\\\";\\n\\n/**\\n * @title Convenience methods to ease integration with other contracts.\\n * @notice This will aggregate calls and format the output per the needs of our frontend or other consumers.\\n */\\ncontract FNDMiddleware is Constants {\\n  using AddressUpgradeable for address;\\n  using AddressUpgradeable for address payable;\\n  using Strings for uint256;\\n  using OZERC165Checker for address;\\n\\n  struct Fee {\\n    uint256 percentInBasisPoints;\\n    uint256 amountInWei;\\n  }\\n  struct FeeWithRecipient {\\n    uint256 percentInBasisPoints;\\n    uint256 amountInWei;\\n    address payable recipient;\\n  }\\n  struct RevSplit {\\n    uint256 relativePercentInBasisPoints;\\n    uint256 absolutePercentInBasisPoints;\\n    uint256 amountInWei;\\n    address payable recipient;\\n  }\\n\\n  FNDNFTMarket private immutable market;\\n  FETH private immutable feth;\\n  IENS private immutable ens;\\n\\n  constructor(\\n    address payable _market,\\n    address payable _feth,\\n    address _ens\\n  ) {\\n    market = FNDNFTMarket(_market);\\n    feth = FETH(_feth);\\n    ens = IENS(_ens);\\n  }\\n\\n  // solhint-disable-next-line code-complexity\\n  function getFees(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 price\\n  )\\n    public\\n    view\\n    returns (\\n      FeeWithRecipient memory protocol,\\n      Fee memory creator,\\n      FeeWithRecipient memory owner,\\n      RevSplit[] memory creatorRevSplit\\n    )\\n  {\\n    // Note that the protocol fee returned does not account for the referrals (which are not known until sale).\\n    protocol.recipient = market.getFoundationTreasury();\\n    address payable[] memory creatorRecipients;\\n    uint256[] memory creatorShares;\\n    uint256 creatorRev;\\n    {\\n      address payable ownerAddress;\\n      uint256 protocolFee;\\n      uint256 sellerRev;\\n      (protocolFee, creatorRev, creatorRecipients, creatorShares, sellerRev, ownerAddress) = market\\n        .getFeesAndRecipients(nftContract, tokenId, price);\\n      protocol.amountInWei = protocolFee;\\n      creator.amountInWei = creatorRev;\\n      owner.amountInWei = sellerRev;\\n      owner.recipient = ownerAddress;\\n      if (creatorShares.length == 0) {\\n        creatorShares = new uint256[](creatorRecipients.length);\\n        if (creatorShares.length == 1) {\\n          creatorShares[0] = BASIS_POINTS;\\n        }\\n      }\\n    }\\n    uint256 creatorRevBP;\\n    {\\n      uint256 protocolFeeBP;\\n      uint256 sellerRevBP;\\n      (protocolFeeBP, creatorRevBP, , , sellerRevBP, ) = market.getFeesAndRecipients(\\n        nftContract,\\n        tokenId,\\n        BASIS_POINTS\\n      );\\n      protocol.percentInBasisPoints = protocolFeeBP;\\n      creator.percentInBasisPoints = creatorRevBP;\\n      owner.percentInBasisPoints = sellerRevBP;\\n    }\\n\\n    // Normalize shares to 10%\\n    {\\n      uint256 totalShares = 0;\\n      for (uint256 i = 0; i < creatorShares.length; ++i) {\\n        // TODO handle ignore if > 100% (like the market would)\\n        totalShares += creatorShares[i];\\n      }\\n\\n      for (uint256 i = 0; i < creatorShares.length; ++i) {\\n        creatorShares[i] = (BASIS_POINTS * creatorShares[i]) / totalShares;\\n      }\\n    }\\n\\n    // Count creators and split recipients\\n    {\\n      uint256 creatorCount = creatorRecipients.length;\\n      for (uint256 i = 0; i < creatorRecipients.length; ++i) {\\n        // Check if the address is a percent split\\n        if (address(creatorRecipients[i]).isContract()) {\\n          try PercentSplitETH(creatorRecipients[i]).getShareLength{ gas: READ_ONLY_GAS_LIMIT }() returns (\\n            uint256 recipientCount\\n          ) {\\n            creatorCount += recipientCount - 1;\\n          } catch // solhint-disable-next-line no-empty-blocks\\n          {\\n            // Not a Foundation percent split\\n          }\\n        }\\n      }\\n      creatorRevSplit = new RevSplit[](creatorCount);\\n    }\\n\\n    // Populate rev splits, including any percent splits\\n    uint256 revSplitIndex = 0;\\n    for (uint256 i = 0; i < creatorRecipients.length; ++i) {\\n      if (address(creatorRecipients[i]).isContract()) {\\n        try PercentSplitETH(creatorRecipients[i]).getShareLength{ gas: READ_ONLY_GAS_LIMIT }() returns (\\n          uint256 recipientCount\\n        ) {\\n          uint256 totalSplitShares;\\n          for (uint256 splitIndex = 0; splitIndex < recipientCount; ++splitIndex) {\\n            uint256 share = PercentSplitETH(creatorRecipients[i]).getPercentInBasisPointsByIndex(splitIndex);\\n            totalSplitShares += share;\\n          }\\n          for (uint256 splitIndex = 0; splitIndex < recipientCount; ++splitIndex) {\\n            uint256 splitShare = (PercentSplitETH(creatorRecipients[i]).getPercentInBasisPointsByIndex(splitIndex) *\\n              BASIS_POINTS) / totalSplitShares;\\n            splitShare = (splitShare * creatorShares[i]) / BASIS_POINTS;\\n            creatorRevSplit[revSplitIndex++] = _calcRevSplit(\\n              price,\\n              splitShare,\\n              creatorRevBP,\\n              PercentSplitETH(creatorRecipients[i]).getShareRecipientByIndex(splitIndex)\\n            );\\n          }\\n          continue;\\n        } catch // solhint-disable-next-line no-empty-blocks\\n        {\\n          // Not a Foundation percent split\\n        }\\n      }\\n      {\\n        creatorRevSplit[revSplitIndex++] = _calcRevSplit(price, creatorShares[i], creatorRevBP, creatorRecipients[i]);\\n      }\\n    }\\n\\n    // Bubble the creator to the first position in `creatorRevSplit`\\n    {\\n      address creatorAddress;\\n      try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\\n        address payable _creator\\n      ) {\\n        creatorAddress = _creator;\\n      } catch // solhint-disable-next-line no-empty-blocks\\n      {\\n        // Fall through\\n      }\\n\\n      // 7th priority: owner from contract or override\\n      try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address _owner) {\\n        if (_owner != address(0)) {\\n          creatorAddress = _owner;\\n        }\\n      } catch // solhint-disable-next-line no-empty-blocks\\n      {\\n        // Fall through\\n      }\\n      if (creatorAddress != address(0)) {\\n        for (uint256 i = 1; i < creatorRevSplit.length; ++i) {\\n          if (creatorRevSplit[i].recipient == creatorAddress) {\\n            (creatorRevSplit[i], creatorRevSplit[0]) = (creatorRevSplit[0], creatorRevSplit[i]);\\n            break;\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Checks an NFT to confirm it will function correctly with our marketplace.\\n   * @dev This should be called with as `call` to simulate the tx; never `sendTransaction`.\\n   * @return 0 if the NFT is supported, otherwise a hash of the error reason.\\n   */\\n  function probeNFT(address nftContract, uint256 tokenId) external payable returns (bytes32) {\\n    if (!nftContract.supportsInterface(type(IERC721).interfaceId)) {\\n      return keccak256(\\\"Not an ERC721\\\");\\n    }\\n    (, , , RevSplit[] memory creatorRevSplit) = getFees(nftContract, tokenId, BASIS_POINTS);\\n    if (creatorRevSplit.length == 0) {\\n      return keccak256(\\\"No royalty recipients\\\");\\n    }\\n    for (uint256 i = 0; i < creatorRevSplit.length; ++i) {\\n      address recipient = creatorRevSplit[i].recipient;\\n      if (recipient == address(0)) {\\n        return keccak256(\\\"address(0) recipient\\\");\\n      }\\n      // Sending > 1 to help confirm when the recipient is a contract forwarding to other addresses\\n      // Silk Road by Ezra Miller requires > 100 wei to when testing payments\\n      // solhint-disable-next-line avoid-low-level-calls\\n      (bool success, ) = recipient.call{ value: 1000, gas: SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS }(\\\"\\\");\\n      if (!success) {\\n        return keccak256(\\\"Recipient not receivable\\\");\\n      }\\n    }\\n\\n    return 0x0;\\n  }\\n\\n  function getAccountInfo(address account)\\n    external\\n    view\\n    returns (\\n      uint256 ethBalance,\\n      uint256 availableFethBalance,\\n      uint256 lockedFethBalance,\\n      string memory ensName\\n    )\\n  {\\n    ethBalance = account.balance;\\n    availableFethBalance = feth.balanceOf(account);\\n    lockedFethBalance = feth.totalBalanceOf(account) - availableFethBalance;\\n\\n    // Lookup ENS name, if one was registered\\n    ensName = _getENSName(account);\\n  }\\n\\n  /**\\n   * @notice Retrieves details related to the NFT in the FND Market.\\n   * @param nftContract The address of the contract for the NFT\\n   * @param tokenId The id for the NFT in the contract.\\n   */\\n  function getNFTDetails(address nftContract, uint256 tokenId)\\n    public\\n    view\\n    returns (\\n      address owner,\\n      bool isInEscrow,\\n      address auctionBidder,\\n      uint256 auctionEndTime,\\n      uint256 auctionPrice,\\n      uint256 auctionId,\\n      uint256 buyPrice,\\n      uint256 offerAmount,\\n      address offerBuyer,\\n      uint256 offerExpiration\\n    )\\n  {\\n    (owner, buyPrice) = market.getBuyPrice(nftContract, tokenId);\\n    (offerBuyer, offerExpiration, offerAmount) = market.getOffer(nftContract, tokenId);\\n    auctionId = market.getReserveAuctionIdFor(nftContract, tokenId);\\n    if (auctionId != 0) {\\n      NFTMarketReserveAuction.ReserveAuction memory auction = market.getReserveAuction(auctionId);\\n      auctionEndTime = auction.endTime;\\n      auctionPrice = auction.amount;\\n      auctionBidder = auction.bidder;\\n      owner = auction.seller;\\n    }\\n\\n    if (owner == address(0)) {\\n      owner = payable(IERC721(nftContract).ownerOf(tokenId));\\n      isInEscrow = false;\\n    } else {\\n      isInEscrow = true;\\n    }\\n  }\\n\\n  // solhint-disable-next-line code-complexity\\n  function getNFTDetailString(address nftContract, uint256 tokenId) external view returns (string memory details) {\\n    (\\n      address owner,\\n      bool isInEscrow,\\n      address auctionBidder,\\n      uint256 auctionEndTime,\\n      uint256 auctionPrice,\\n      uint256 auctionId,\\n      uint256 buyPrice,\\n      uint256 offerAmount,\\n      address offerBuyer,\\n      uint256 offerExpiration\\n    ) = getNFTDetails(nftContract, tokenId);\\n    details = _getAddressAndName(owner);\\n    if (isInEscrow) {\\n      if (auctionEndTime > 0) {\\n        if (auctionEndTime >= block.timestamp) {\\n          // Active auction\\n          details = string.concat(\\n            details,\\n            \\\" has it in active auction going for \\\",\\n            _getETHString(auctionPrice),\\n            \\\", bid from \\\",\\n            _getAddressAndName(auctionBidder),\\n            \\\" and ends in \\\",\\n            _getDeltaTimeString(auctionEndTime - block.timestamp),\\n            \\\" [auctionId: \\\",\\n            auctionId.toString(),\\n            \\\"]\\\"\\n          );\\n        } else {\\n          // Auction ended, pending finalization\\n          details = string.concat(\\n            details,\\n            \\\" sold it in auction for \\\",\\n            _getETHString(auctionPrice),\\n            \\\" to \\\",\\n            _getAddressAndName(auctionBidder),\\n            \\\" \\\",\\n            _getDeltaTimeString(block.timestamp - auctionEndTime),\\n            \\\" ago [pending settlement / auctionId: \\\",\\n            auctionId.toString(),\\n            \\\"]\\\"\\n          );\\n        }\\n      } else {\\n        // Buy now and/or reserve price\\n        details = string.concat(details, \\\" listed for \\\");\\n        if (buyPrice < type(uint256).max) {\\n          details = string.concat(details, \\\"buy now at \\\", _getETHString(buyPrice));\\n        }\\n        if (buyPrice < type(uint256).max && auctionPrice > 0) {\\n          details = string.concat(details, \\\" or \\\");\\n        }\\n        if (auctionPrice > 0) {\\n          details = string.concat(\\n            details,\\n            \\\"reserve price of \\\",\\n            _getETHString(auctionPrice),\\n            \\\" [auctionId: \\\",\\n            auctionId.toString(),\\n            \\\"]\\\"\\n          );\\n        }\\n      }\\n\\n      if (offerAmount > 0) {\\n        // With an offer too\\n        details = string.concat(\\n          details,\\n          \\\" with an offer of \\\",\\n          _getOfferString(offerAmount, offerBuyer, offerExpiration)\\n        );\\n      }\\n    } else if (offerAmount > 0) {\\n      // Just an offer\\n      details = string.concat(details, \\\" has an offer for \\\", _getOfferString(offerAmount, offerBuyer, offerExpiration));\\n    } else {\\n      // Nothing\\n      details = string.concat(details, \\\" has not listed nor gotten an offer\\\");\\n    }\\n  }\\n\\n  function _calcRevSplit(\\n    uint256 price,\\n    uint256 share,\\n    uint256 creatorRevBP,\\n    address payable recipient\\n  ) private pure returns (RevSplit memory) {\\n    uint256 absoluteShare = (share * creatorRevBP) / BASIS_POINTS;\\n    uint256 amount = (absoluteShare * price) / BASIS_POINTS;\\n    return RevSplit(share, absoluteShare, amount, recipient);\\n  }\\n\\n  function _getAddressAndName(address account) private view returns (string memory name) {\\n    string memory ensName = _getENSName(account);\\n    if (bytes(ensName).length > 0) {\\n      name = string.concat(_toAsciiString(account), \\\" (\\\", ensName, \\\")\\\");\\n    } else {\\n      name = _toAsciiString(account);\\n    }\\n  }\\n\\n  // solhint-disable-next-line code-complexity\\n  function _getDeltaTimeString(uint256 timeRemaining) private pure returns (string memory delta) {\\n    uint256 secondsRemaining = timeRemaining;\\n    // Days\\n    if (timeRemaining >= 1 days) {\\n      uint256 day = secondsRemaining / (1 days);\\n      if (day == 1) {\\n        delta = \\\"1 day\\\";\\n      } else {\\n        delta = string.concat(day.toString(), \\\" days\\\");\\n      }\\n      secondsRemaining -= day * 1 days;\\n      if (secondsRemaining == 0) {\\n        return delta;\\n      } else {\\n        delta = string.concat(delta, \\\" \\\");\\n      }\\n    }\\n    // Hours\\n    if (timeRemaining >= 1 hours) {\\n      uint256 hrs = secondsRemaining / (1 hours);\\n      if (hrs == 1) {\\n        delta = string.concat(delta, \\\"1 hour\\\");\\n      } else {\\n        delta = string.concat(delta, hrs.toString(), \\\" hours\\\");\\n      }\\n      secondsRemaining -= hrs * 1 hours;\\n      if (secondsRemaining == 0) {\\n        return delta;\\n      } else {\\n        delta = string.concat(delta, \\\" \\\");\\n      }\\n    }\\n    // Minutes\\n    if (timeRemaining >= 1 minutes) {\\n      uint256 mins = secondsRemaining / (1 minutes);\\n      if (mins == 1) {\\n        delta = string.concat(delta, \\\"1 min\\\");\\n      } else {\\n        delta = string.concat(delta, mins.toString(), \\\" mins\\\");\\n      }\\n      secondsRemaining -= mins * 1 minutes;\\n      if (secondsRemaining == 0) {\\n        return delta;\\n      } else {\\n        delta = string.concat(delta, \\\" \\\");\\n      }\\n    }\\n    // Seconds\\n    if (secondsRemaining == 1) {\\n      delta = string.concat(delta, \\\"1 sec\\\");\\n    } else {\\n      delta = string.concat(delta, secondsRemaining.toString(), \\\" secs\\\");\\n    }\\n  }\\n\\n  // solhint-disable-next-line code-complexity\\n  function _getETHString(uint256 amount) private pure returns (string memory eth) {\\n    string memory amountString = amount.toString();\\n    uint256 printedCount = 0;\\n    if (bytes(amountString).length > 18) {\\n      for (uint256 i = 0; i < bytes(amountString).length - 18; ++i) {\\n        bytes memory byteArray = new bytes(1);\\n        byteArray[0] = bytes(amountString)[i];\\n        eth = string.concat(eth, string(byteArray));\\n        printedCount++;\\n      }\\n    } else {\\n      eth = \\\"0\\\";\\n    }\\n    uint256 endingZeros = 0;\\n    for (uint256 i = bytes(amountString).length - 1; i > 0; --i) {\\n      if (bytes(amountString)[i] == bytes(\\\"0\\\")[0]) {\\n        ++endingZeros;\\n      } else {\\n        break;\\n      }\\n    }\\n    if (endingZeros < 18) {\\n      eth = string.concat(eth, \\\".\\\");\\n\\n      if (bytes(amountString).length < 18) {\\n        // add leading zeros\\n        for (uint256 i = 0; i < 18 - bytes(amountString).length; ++i) {\\n          eth = string.concat(eth, \\\"0\\\");\\n        }\\n      }\\n      for (; printedCount < bytes(amountString).length - endingZeros; ++printedCount) {\\n        bytes memory byteArray = new bytes(1);\\n        byteArray[0] = bytes(amountString)[printedCount];\\n        eth = string.concat(eth, string(byteArray));\\n      }\\n    }\\n\\n    eth = string.concat(eth, \\\" ETH\\\");\\n  }\\n\\n  function _getENSName(address account) private view returns (string memory ensName) {\\n    IReverseRegistrar reverseRegistrar = IReverseRegistrar(\\n      ens.owner(\\n        keccak256(\\n          abi.encodePacked(keccak256(abi.encodePacked(abi.encode(bytes32(0)), keccak256(\\\"reverse\\\"))), keccak256(\\\"addr\\\"))\\n        )\\n      )\\n    );\\n    bytes32 node = reverseRegistrar.node(account);\\n    if (node != bytes32(0)) {\\n      IPublicResolver resolver = IPublicResolver(ens.resolver(node));\\n\\n      // The standard call style is reverting when no results are found\\n      (bool success, bytes memory data) = address(resolver).staticcall(abi.encodeWithSignature(\\\"name(bytes32)\\\", node));\\n\\n      if (success && data.length > 0) {\\n        ensName = resolver.name(node);\\n\\n        // TODO this only works for .eth names, subdomains and others will be ignored\\n        bytes32 nameNode = keccak256(\\n          abi.encodePacked(\\n            keccak256(abi.encodePacked(bytes32(0), keccak256(\\\"eth\\\"))),\\n            keccak256(_substring(ensName, 0, bytes(ensName).length - 4))\\n          )\\n        );\\n\\n        // Validate ownership\\n        address owner = ens.owner(nameNode);\\n        if (owner != account) {\\n          // Invalid reverse registration\\n          ensName = \\\"\\\";\\n        }\\n      }\\n    }\\n  }\\n\\n  function _getOfferString(\\n    uint256 amount,\\n    address buyer,\\n    uint256 expiration\\n  ) private view returns (string memory offer) {\\n    offer = string.concat(\\n      _getETHString(amount),\\n      \\\" from \\\",\\n      _getAddressAndName(buyer),\\n      \\\" that expires in \\\",\\n      _getDeltaTimeString(expiration - block.timestamp)\\n    );\\n  }\\n\\n  function _substring(\\n    string memory str,\\n    uint256 startIndex,\\n    uint256 endIndex\\n  ) private pure returns (bytes memory result) {\\n    bytes memory strBytes = bytes(str);\\n    result = new bytes(endIndex - startIndex);\\n    for (uint256 i = startIndex; i < endIndex; ++i) {\\n      result[i - startIndex] = strBytes[i];\\n    }\\n  }\\n\\n  /**\\n   * @notice Converts an address into a string.\\n   * @dev From https://ethereum.stackexchange.com/questions/8346/convert-address-to-string\\n   */\\n  function _toAsciiString(address x) private pure returns (string memory) {\\n    unchecked {\\n      bytes memory s = new bytes(42);\\n      s[0] = \\\"0\\\";\\n      s[1] = \\\"x\\\";\\n      for (uint256 i = 0; i < 20; ++i) {\\n        bytes1 b = bytes1(uint8(uint256(uint160(x)) / (2**(8 * (19 - i)))));\\n        bytes1 hi = bytes1(uint8(b) / 16);\\n        bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n        s[2 * i + 2] = _char(hi);\\n        s[2 * i + 3] = _char(lo);\\n      }\\n      return string(s);\\n    }\\n  }\\n\\n  /**\\n   * @notice Converts a byte to a UTF-8 character.\\n   */\\n  function _char(bytes1 b) private pure returns (bytes1 c) {\\n    unchecked {\\n      if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n      else return bytes1(uint8(b) + 0x57);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Burnable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721Upgradeable.sol\\\";\\nimport \\\"../../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @title ERC721 Burnable Token\\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\\n */\\nabstract contract ERC721BurnableUpgradeable is Initializable, ContextUpgradeable, ERC721Upgradeable {\\n    function __ERC721Burnable_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 tokenId) public virtual {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721Burnable: caller is not owner nor approved\\\");\\n        _burn(tokenId);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/FNDNFTMarket.sol\": {\r\n      \"content\": \"/*\\n  \uff65\\n   *\u3000\u2605\\n      \uff65 \uff61\\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\\n\u200b\\n                      `                     .-:::::-.`              `-::---...```\\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\\n                                              `````\\n   *\u3000\\n      \uff65 \uff61\\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\\n\u3000\uff65\uff9f*\uff61\u2605\uff65\\n \u2606\u2234\uff61\u3000*\\n\uff65 \uff61\\n*/\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"./mixins/Constants.sol\\\";\\nimport \\\"./mixins/FoundationTreasuryNode.sol\\\";\\nimport \\\"./mixins/NFTMarketAuction.sol\\\";\\nimport \\\"./mixins/NFTMarketBuyPrice.sol\\\";\\nimport \\\"./mixins/NFTMarketCore.sol\\\";\\nimport \\\"./mixins/NFTMarketCreators.sol\\\";\\nimport \\\"./mixins/NFTMarketFees.sol\\\";\\nimport \\\"./mixins/NFTMarketOffer.sol\\\";\\nimport \\\"./mixins/NFTMarketPrivateSale.sol\\\";\\nimport \\\"./mixins/NFTMarketReserveAuction.sol\\\";\\nimport \\\"./mixins/SendValueWithFallbackWithdraw.sol\\\";\\n\\n/**\\n * @title A market for NFTs on Foundation.\\n * @notice The Foundation marketplace is a contract which allows traders to buy and sell NFTs.\\n * It supports buying and selling via auctions, private sales, buy price, and offers.\\n * @dev All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific\\n * to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was\\n * originally deployed, it may be added using the [Royalty Registry](https://royaltyregistry.xyz/) which will be\\n * respected by our market contract.\\n */\\ncontract FNDNFTMarket is\\n  Constants,\\n  Initializable,\\n  FoundationTreasuryNode,\\n  NFTMarketCore,\\n  ReentrancyGuardUpgradeable,\\n  NFTMarketCreators,\\n  SendValueWithFallbackWithdraw,\\n  NFTMarketFees,\\n  NFTMarketAuction,\\n  NFTMarketReserveAuction,\\n  NFTMarketPrivateSale,\\n  NFTMarketBuyPrice,\\n  NFTMarketOffer\\n{\\n  /**\\n   * @notice Set immutable variables for the implementation contract.\\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\\n   * @param treasury The Foundation Treasury contract address.\\n   * @param feth The FETH ERC-20 token contract address.\\n   * @param royaltyRegistry The Royalty Registry contract address.\\n   * @param duration The duration of the auction in seconds.\\n   * @param marketProxyAddress The address of the proxy fronting this contract.\\n   */\\n  constructor(\\n    address payable treasury,\\n    address feth,\\n    address royaltyRegistry,\\n    uint256 duration,\\n    address marketProxyAddress\\n  )\\n    FoundationTreasuryNode(treasury)\\n    NFTMarketCore(feth)\\n    NFTMarketCreators(royaltyRegistry)\\n    NFTMarketReserveAuction(duration)\\n    NFTMarketPrivateSale(marketProxyAddress) // solhint-disable-next-line no-empty-blocks\\n  {}\\n\\n  /**\\n   * @notice Called once to configure the contract after the initial proxy deployment.\\n   * @dev This farms the initialize call out to inherited contracts as needed to initialize mutable variables.\\n   */\\n  function initialize() external initializer {\\n    NFTMarketAuction._initializeNFTMarketAuction();\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   * @dev This is a no-op function required to avoid compile errors.\\n   */\\n  function _beforeAuctionStarted(address nftContract, uint256 tokenId)\\n    internal\\n    override(NFTMarketCore, NFTMarketBuyPrice, NFTMarketOffer)\\n  {\\n    super._beforeAuctionStarted(nftContract, tokenId);\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   * @dev This is a no-op function required to avoid compile errors.\\n   */\\n  function _transferFromEscrow(\\n    address nftContract,\\n    uint256 tokenId,\\n    address recipient,\\n    address authorizeSeller\\n  ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice) {\\n    super._transferFromEscrow(nftContract, tokenId, recipient, authorizeSeller);\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   * @dev This is a no-op function required to avoid compile errors.\\n   */\\n  function _transferFromEscrowIfAvailable(\\n    address nftContract,\\n    uint256 tokenId,\\n    address recipient\\n  ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice) {\\n    super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   * @dev This is a no-op function required to avoid compile errors.\\n   */\\n  function _transferToEscrow(address nftContract, uint256 tokenId)\\n    internal\\n    override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice)\\n  {\\n    super._transferToEscrow(nftContract, tokenId);\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   * @dev This is a no-op function required to avoid compile errors.\\n   */\\n  function _getSellerFor(address nftContract, uint256 tokenId)\\n    internal\\n    view\\n    override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice)\\n    returns (address payable seller)\\n  {\\n    seller = super._getSellerFor(nftContract, tokenId);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/PercentSplitETH.sol\": {\r\n      \"content\": \"/*\\n  \uff65\\n   *\u3000\u2605\\n      \uff65 \uff61\\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\\n\u200b\\n                      `                     .-:::::-.`              `-::---...```\\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\\n                                              `````\\n   *\u3000\\n      \uff65 \uff61\\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\\n\u3000\uff65\uff9f*\uff61\u2605\uff65\\n \u2606\u2234\uff61\u3000*\\n\uff65 \uff61\\n*/\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IERC20Approve.sol\\\";\\nimport \\\"./interfaces/IERC20IncreaseAllowance.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"./libraries/BytesLibrary.sol\\\";\\n\\n/**\\n * @title Auto-forward ETH to a pre-determined list of addresses.\\n * @notice Deploys contracts which auto-forwards any ETH sent to it to a list of recipients\\n * considering their percent share of the payment received.\\n * ERC-20 tokens are also supported and may be split on demand by calling `splitERC20Tokens`.\\n * If another asset type is sent to this contract address such as an NFT, arbitrary calls may be made by one\\n * of the split recipients in order to recover them.\\n * @dev Uses create2 counterfactual addresses so that the destination is known from the terms of the split.\\n */\\ncontract PercentSplitETH is Initializable {\\n  using AddressUpgradeable for address payable;\\n  using AddressUpgradeable for address;\\n  using BytesLibrary for bytes;\\n  using SafeMath for uint256;\\n\\n  /// @notice A representation of shares using 16-bits for efficient storage.\\n  /// @dev This is only used internally.\\n  struct ShareCompressed {\\n    address payable recipient;\\n    uint16 percentInBasisPoints;\\n  }\\n\\n  /// @notice A representation of shares using 256-bits to ease integration.\\n  struct Share {\\n    address payable recipient;\\n    uint256 percentInBasisPoints;\\n  }\\n\\n  ShareCompressed[] private _shares;\\n\\n  uint256 private constant BASIS_POINTS = 10000;\\n\\n  /**\\n   * @notice Emitted when an ERC20 token is transferred to a recipient through this split contract.\\n   * @param erc20Contract The address of the ERC20 token contract.\\n   * @param account The account which received payment.\\n   * @param amount The amount of ERC20 tokens sent to this recipient.\\n   */\\n  event ERC20Transferred(address indexed erc20Contract, address indexed account, uint256 amount);\\n  /**\\n   * @notice Emitted when ETH is transferred to a recipient through this split contract.\\n   * @param account The account which received payment.\\n   * @param amount The amount of ETH payment sent to this recipient.\\n   */\\n  event ETHTransferred(address indexed account, uint256 amount);\\n  /**\\n   * @notice Emitted when a new percent split contract is created from this factory.\\n   * @param contractAddress The address of the new percent split contract.\\n   */\\n  event PercentSplitCreated(address indexed contractAddress);\\n  /**\\n   * @notice Emitted for each share of the split being defined.\\n   * @param recipient The address of the recipient when payment to the split is received.\\n   * @param percentInBasisPoints The percent of the payment received by the recipient, in basis points.\\n   */\\n  event PercentSplitShare(address indexed recipient, uint256 percentInBasisPoints);\\n\\n  /**\\n   * @dev Requires that the msg.sender is one of the recipients in this split.\\n   */\\n  modifier onlyRecipient() {\\n    for (uint256 i = 0; i < _shares.length; ++i) {\\n      if (_shares[i].recipient == msg.sender) {\\n        _;\\n        return;\\n      }\\n    }\\n    revert(\\\"Split: Can only be called by one of the recipients\\\");\\n  }\\n\\n  /**\\n   * @notice Called once to configure the contract after the initial deployment.\\n   * @dev This will be called by `createSplit` after deploying the proxy so it should never be called directly.\\n   * @param shares The list of recipients and their share of the payment for the template to use.\\n   */\\n  function initialize(Share[] memory shares) external initializer {\\n    require(shares.length >= 2, \\\"Split: Too few recipients\\\");\\n    require(shares.length <= 5, \\\"Split: Too many recipients\\\");\\n    uint256 total;\\n    unchecked {\\n      // The array length cannot overflow 256 bits.\\n      for (uint256 i = 0; i < shares.length; ++i) {\\n        require(shares[i].percentInBasisPoints < BASIS_POINTS, \\\"Split: Share must be less than 100%\\\");\\n        // Require above ensures total will not overflow.\\n        total += shares[i].percentInBasisPoints;\\n        _shares.push(\\n          ShareCompressed({\\n            recipient: shares[i].recipient,\\n            percentInBasisPoints: uint16(shares[i].percentInBasisPoints)\\n          })\\n        );\\n        emit PercentSplitShare(shares[i].recipient, shares[i].percentInBasisPoints);\\n      }\\n    }\\n    require(total == BASIS_POINTS, \\\"Split: Total amount must equal 100%\\\");\\n  }\\n\\n  /**\\n   * @notice Forwards any ETH received to the recipients in this split.\\n   * @dev Each recipient increases the gas required to split\\n   * and contract recipients may significantly increase the gas required.\\n   */\\n  receive() external payable {\\n    _splitETH(msg.value);\\n  }\\n\\n  /**\\n   * @notice Creates a new minimal proxy contract and initializes it with the given split terms.\\n   * If the contract had already been created, its address is returned.\\n   * This must be called on the original implementation and not a proxy created previously.\\n   * @param shares The list of recipients and their share of the payment for this split.\\n   * @return splitInstance The contract address for the split contract created.\\n   */\\n  function createSplit(Share[] memory shares) external returns (PercentSplitETH splitInstance) {\\n    bytes32 salt = keccak256(abi.encode(shares));\\n    address clone = Clones.predictDeterministicAddress(address(this), salt);\\n    splitInstance = PercentSplitETH(payable(clone));\\n    if (!clone.isContract()) {\\n      emit PercentSplitCreated(clone);\\n      Clones.cloneDeterministic(address(this), salt);\\n      splitInstance.initialize(shares);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows the split recipients to make an arbitrary contract call.\\n   * @dev This is provided to allow recovering from unexpected scenarios,\\n   * such as receiving an NFT at this address.\\n   *\\n   * It will first attempt a fair split of ERC20 tokens before proceeding.\\n   *\\n   * This contract is built to split ETH payments. The ability to attempt to make other calls is here\\n   * just in case other assets were also sent so that they don't get locked forever in the contract.\\n   * @param target The address of the contract to call.\\n   * @param callData The data to send to the `target` contract.\\n   */\\n  function proxyCall(address payable target, bytes memory callData) external onlyRecipient {\\n    require(\\n      !callData.startsWith(type(IERC20Approve).interfaceId) &&\\n        !callData.startsWith(type(IERC20IncreaseAllowance).interfaceId),\\n      \\\"Split: ERC20 tokens must be split\\\"\\n    );\\n    _splitERC20Tokens(IERC20(target));\\n    target.functionCall(callData);\\n  }\\n\\n  /**\\n   * @notice Allows any ETH stored by the contract to be split among recipients.\\n   * @dev Normally ETH is forwarded as it comes in, but a balance in this contract\\n   * is possible if it was sent before the contract was created or if self destruct was used.\\n   */\\n  function splitETH() external {\\n    _splitETH(address(this).balance);\\n  }\\n\\n  /**\\n   * @notice Anyone can call this function to split all available tokens at the provided address between the recipients.\\n   * @dev This contract is built to split ETH payments. The ability to attempt to split ERC20 tokens is here\\n   * just in case tokens were also sent so that they don't get locked forever in the contract.\\n   * @param erc20Contract The address of the ERC20 token contract to split tokens for.\\n   */\\n  function splitERC20Tokens(IERC20 erc20Contract) external {\\n    require(_splitERC20Tokens(erc20Contract), \\\"Split: ERC20 split failed\\\");\\n  }\\n\\n  function _splitERC20Tokens(IERC20 erc20Contract) private returns (bool) {\\n    try erc20Contract.balanceOf(address(this)) returns (uint256 balance) {\\n      if (balance == 0) {\\n        return false;\\n      }\\n      uint256 amountToSend;\\n      uint256 totalSent;\\n      unchecked {\\n        for (uint256 i = _shares.length - 1; i != 0; i--) {\\n          ShareCompressed memory share = _shares[i];\\n          bool success;\\n          (success, amountToSend) = balance.tryMul(share.percentInBasisPoints);\\n          if (!success) {\\n            return false;\\n          }\\n          amountToSend /= BASIS_POINTS;\\n          totalSent += amountToSend;\\n          try erc20Contract.transfer(share.recipient, amountToSend) {\\n            emit ERC20Transferred(address(erc20Contract), share.recipient, amountToSend);\\n          } catch {\\n            return false;\\n          }\\n        }\\n        // Favor the 1st recipient if there are any rounding issues\\n        amountToSend = balance - totalSent;\\n      }\\n      try erc20Contract.transfer(_shares[0].recipient, amountToSend) {\\n        emit ERC20Transferred(address(erc20Contract), _shares[0].recipient, amountToSend);\\n      } catch {\\n        return false;\\n      }\\n      return true;\\n    } catch {\\n      return false;\\n    }\\n  }\\n\\n  function _splitETH(uint256 value) private {\\n    if (value != 0) {\\n      uint256 totalSent;\\n      uint256 amountToSend;\\n      unchecked {\\n        for (uint256 i = _shares.length - 1; i != 0; i--) {\\n          ShareCompressed memory share = _shares[i];\\n          amountToSend = (value * share.percentInBasisPoints) / BASIS_POINTS;\\n          totalSent += amountToSend;\\n          share.recipient.sendValue(amountToSend);\\n          emit ETHTransferred(share.recipient, amountToSend);\\n        }\\n        // Favor the 1st recipient if there are any rounding issues\\n        amountToSend = value - totalSent;\\n      }\\n      _shares[0].recipient.sendValue(amountToSend);\\n      emit ETHTransferred(_shares[0].recipient, amountToSend);\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns a recipient's percent share in basis points.\\n   * @param index The index of the recipient to get the share of.\\n   * @return percentInBasisPoints The percent of the payment received by the recipient, in basis points.\\n   */\\n  function getPercentInBasisPointsByIndex(uint256 index) external view returns (uint256 percentInBasisPoints) {\\n    percentInBasisPoints = _shares[index].percentInBasisPoints;\\n  }\\n\\n  /**\\n   * @notice Returns the address for the proxy contract which would represent the given split terms.\\n   * @dev The contract may or may not already be deployed at the address returned.\\n   * Ensure that it is deployed before sending funds to this address.\\n   * @param shares The list of recipients and their share of the payment for this split.\\n   * @return splitInstance The contract address for the split contract created.\\n   */\\n  function getPredictedSplitAddress(Share[] memory shares) external view returns (address splitInstance) {\\n    bytes32 salt = keccak256(abi.encode(shares));\\n    splitInstance = Clones.predictDeterministicAddress(address(this), salt);\\n  }\\n\\n  /**\\n   * @notice Returns how many recipients are part of this split.\\n   * @return length The number of recipients in this split.\\n   */\\n  function getShareLength() external view returns (uint256 length) {\\n    length = _shares.length;\\n  }\\n\\n  /**\\n   * @notice Returns a recipient in this split.\\n   * @param index The index of the recipient to get.\\n   * @return recipient The recipient at the given index.\\n   */\\n  function getShareRecipientByIndex(uint256 index) external view returns (address payable recipient) {\\n    recipient = _shares[index].recipient;\\n  }\\n\\n  /**\\n   * @notice Returns a tuple with the terms of this split.\\n   * @return shares The list of recipients and their share of the payment for this split.\\n   */\\n  function getShares() external view returns (Share[] memory shares) {\\n    shares = new Share[](_shares.length);\\n    for (uint256 i = 0; i < shares.length; ++i) {\\n      shares[i] = Share({ recipient: _shares[i].recipient, percentInBasisPoints: _shares[i].percentInBasisPoints });\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/CollectionContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/ICollectionContractInitializer.sol\\\";\\nimport \\\"./interfaces/ICollectionFactory.sol\\\";\\nimport \\\"./interfaces/IGetRoyalties.sol\\\";\\nimport \\\"./interfaces/IProxyCall.sol\\\";\\nimport \\\"./interfaces/ITokenCreator.sol\\\";\\nimport \\\"./interfaces/IGetFees.sol\\\";\\nimport \\\"./interfaces/IRoyaltyInfo.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\n\\nimport \\\"./libraries/AccountMigrationLibrary.sol\\\";\\nimport \\\"./libraries/ProxyCall.sol\\\";\\nimport \\\"./libraries/BytesLibrary.sol\\\";\\n\\n/**\\n * @title A collection of NFTs by a single creator.\\n * @notice All NFTs from this contract are minted by the same creator.\\n * A 10% royalty to the creator is included which may be split with collaborators on a per-NFT basis.\\n */\\ncontract CollectionContract is\\n  ICollectionContractInitializer,\\n  IGetRoyalties,\\n  IGetFees,\\n  IRoyaltyInfo,\\n  ITokenCreator,\\n  ERC721BurnableUpgradeable\\n{\\n  using AccountMigrationLibrary for address;\\n  using AddressUpgradeable for address;\\n  using BytesLibrary for bytes;\\n  using ProxyCall for IProxyCall;\\n\\n  uint256 private constant ROYALTY_IN_BASIS_POINTS = 1000;\\n  uint256 private constant ROYALTY_RATIO = 10;\\n\\n  /**\\n   * @notice The baseURI to use for the tokenURI, if undefined then `ipfs://` is used.\\n   */\\n  string private baseURI_;\\n\\n  /**\\n   * @dev Stores hashes minted to prevent duplicates.\\n   */\\n  mapping(string => bool) private cidToMinted;\\n\\n  /**\\n   * @notice The factory which was used to create this collection.\\n   * @dev This is used to read common config.\\n   */\\n  ICollectionFactory public immutable collectionFactory;\\n\\n  /**\\n   * @notice The tokenId of the most recently created NFT.\\n   * @dev Minting starts at tokenId 1. Each mint will use this value + 1.\\n   */\\n  uint256 public latestTokenId;\\n\\n  /**\\n   * @notice The max tokenId which can be minted, or 0 if there's no limit.\\n   * @dev This value may be set at any time, but once set it cannot be increased.\\n   */\\n  uint256 public maxTokenId;\\n\\n  /**\\n   * @notice The owner/creator of this NFT collection.\\n   */\\n  address payable public owner;\\n\\n  /**\\n   * @dev Stores an optional alternate address to receive creator revenue and royalty payments.\\n   * The target address may be a contract which could split or escrow payments.\\n   */\\n  mapping(uint256 => address payable) private tokenIdToCreatorPaymentAddress;\\n\\n  /**\\n   * @dev Tracks how many tokens have been burned, used to calc the total supply efficiently.\\n   */\\n  uint256 private burnCounter;\\n\\n  /**\\n   * @dev Stores a CID for each NFT.\\n   */\\n  mapping(uint256 => string) private _tokenCIDs;\\n\\n  /**\\n   * @notice Emitted when the owner changes the base URI to be used for NFTs in this collection.\\n   * @param baseURI The new base URI to use.\\n   */\\n  event BaseURIUpdated(string baseURI);\\n  /**\\n   * @notice Emitted when the owner of this collection is changed through account migration.\\n   * @param originalAddress The address which was previously the owner.\\n   * @param newAddress The new address which is now the owner.\\n   */\\n  event CreatorMigrated(address indexed originalAddress, address indexed newAddress);\\n  /**\\n   * @notice Emitted when the max tokenId supported by this collection is defined.\\n   * @param maxTokenId The new max tokenId. All NFTs in this collection will have a tokenId less than\\n   * or equal to this value.\\n   */\\n  event MaxTokenIdUpdated(uint256 indexed maxTokenId);\\n  /**\\n   * @notice Emitted when a new NFT is minted.\\n   * @param creator The address of the collection owner at this time this NFT was minted.\\n   * @param tokenId The tokenId of the newly minted NFT.\\n   * @param indexedTokenCID The CID of the newly minted NFT, indexed to enable watching for mint events by the tokenCID.\\n   * @param tokenCID The actual CID of the newly minted NFT.\\n   */\\n  event Minted(address indexed creator, uint256 indexed tokenId, string indexed indexedTokenCID, string tokenCID);\\n  /**\\n   * @notice Emitted when the owner of an NFT is changed through account migration.\\n   * @param tokenId The tokenId of the NFT which was transferred.\\n   * @param originalAddress The address which was previously the owner.\\n   * @param newAddress The new address which is now the owner.\\n   */\\n  event NFTOwnerMigrated(uint256 indexed tokenId, address indexed originalAddress, address indexed newAddress);\\n  /**\\n   * @notice Emitted when the payment address for an NFT is changed through account migration.\\n   * @param tokenId The tokenId of the NFT which had the payment address changed.\\n   * @param originalAddress The original recipient address for royalties that is being migrated.\\n   * @param newAddress The new recipient address for royalties.\\n   * @param originalPaymentAddress The original payment address for royalty payments.\\n   * @param newPaymentAddress The new payment address used to split royalty payments.\\n   */\\n  event PaymentAddressMigrated(\\n    uint256 indexed tokenId,\\n    address indexed originalAddress,\\n    address indexed newAddress,\\n    address originalPaymentAddress,\\n    address newPaymentAddress\\n  );\\n  /**\\n   * @notice Emitted when this collection is self destructed by the owner.\\n   * @param owner The collection owner at the time this collection was self destructed.\\n   */\\n  event SelfDestruct(address indexed owner);\\n  /**\\n   * @notice Emitted when the payment address for creator royalties is set.\\n   * @param fromPaymentAddress The original address used for royalty payments.\\n   * @param toPaymentAddress The new address used for royalty payments.\\n   * @param tokenId The NFT which had the royalty payment address updated.\\n   */\\n  event TokenCreatorPaymentAddressSet(\\n    address indexed fromPaymentAddress,\\n    address indexed toPaymentAddress,\\n    uint256 indexed tokenId\\n  );\\n\\n  modifier onlyOwner() {\\n    require(msg.sender == owner, \\\"CollectionContract: Caller is not owner\\\");\\n    _;\\n  }\\n\\n  modifier onlyOperator() {\\n    require(collectionFactory.rolesContract().isOperator(msg.sender), \\\"CollectionContract: Caller is not an operator\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @notice Initialize the template's immutable variables.\\n   * @param _collectionFactory The factory which will be used to create collection contracts.\\n   */\\n  constructor(address _collectionFactory) {\\n    require(_collectionFactory.isContract(), \\\"CollectionContract: collectionFactory is not a contract\\\");\\n    collectionFactory = ICollectionFactory(_collectionFactory);\\n  }\\n\\n  /**\\n   * @notice Called by the factory on creation.\\n   * @param _creator The creator of this collection contract.\\n   * @param _name The name of this collection.\\n   * @param _symbol The symbol for this collection.\\n   */\\n  function initialize(\\n    address payable _creator,\\n    string memory _name,\\n    string memory _symbol\\n  ) external initializer {\\n    require(msg.sender == address(collectionFactory), \\\"CollectionContract: Collection must be created via the factory\\\");\\n\\n    __ERC721_init_unchained(_name, _symbol);\\n\\n    owner = _creator;\\n  }\\n\\n  /**\\n   * @notice Allows an NFT owner or creator and Foundation to work together in order to update the creator\\n   * to a new account and/or transfer NFTs to that account.\\n   * @param ownedTokenIds The tokenIds of the NFTs owned by the original address to be migrated to the new account.\\n   * @param originalAddress The original account address to be migrated.\\n   * @param newAddress The new address for the account.\\n   * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`\\n   * signed by the original account.\\n   * @dev This will gracefully skip any NFTs that have been burned or transferred.\\n   */\\n  function adminAccountMigration(\\n    uint256[] calldata ownedTokenIds,\\n    address originalAddress,\\n    address payable newAddress,\\n    bytes calldata signature\\n  ) external onlyOperator {\\n    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);\\n\\n    for (uint256 i = 0; i < ownedTokenIds.length; ++i) {\\n      uint256 tokenId = ownedTokenIds[i];\\n      // Check that the token exists and still is owned by the originalAddress\\n      // so that frontrunning a burn or transfer will not cause the entire tx to revert\\n      if (_exists(tokenId) && ownerOf(tokenId) == originalAddress) {\\n        _transfer(originalAddress, newAddress, tokenId);\\n        emit NFTOwnerMigrated(tokenId, originalAddress, newAddress);\\n      }\\n    }\\n\\n    if (owner == originalAddress) {\\n      owner = newAddress;\\n      emit CreatorMigrated(originalAddress, newAddress);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows a split recipient and Foundation to work together in order to update the payment address\\n   * to a new account.\\n   * @param paymentAddressTokenIds The token IDs for the NFTs to have their payment address migrated.\\n   * @param paymentAddressFactory The contract which was used to generate the payment address being migrated.\\n   * @param paymentAddressCallData The original call data used to generate the payment address being migrated.\\n   * @param addressLocationInCallData The position where the account to migrate begins in the call data.\\n   * @param originalAddress The original account address to be migrated.\\n   * @param newAddress The new address for the account.\\n   * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`\\n   * signed by the original account.\\n   */\\n  function adminAccountMigrationForPaymentAddresses(\\n    uint256[] calldata paymentAddressTokenIds,\\n    address paymentAddressFactory,\\n    bytes memory paymentAddressCallData,\\n    uint256 addressLocationInCallData,\\n    address originalAddress,\\n    address payable newAddress,\\n    bytes calldata signature\\n  ) external onlyOperator {\\n    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);\\n    _adminAccountRecoveryForPaymentAddresses(\\n      paymentAddressTokenIds,\\n      paymentAddressFactory,\\n      paymentAddressCallData,\\n      addressLocationInCallData,\\n      originalAddress,\\n      newAddress\\n    );\\n  }\\n\\n  /**\\n   * @notice Allows the creator to burn if they currently own the NFT.\\n   * @param tokenId The tokenId of the NFT to burn.\\n   */\\n  function burn(uint256 tokenId) public override onlyOwner {\\n    super.burn(tokenId);\\n  }\\n\\n  /**\\n   * @notice Allows the owner to mint an NFT defined by its metadata path.\\n   * @param tokenCID The CID of the NFT to mint.\\n   * @return tokenId The tokenId of the newly minted NFT.\\n   */\\n  function mint(string calldata tokenCID) external returns (uint256 tokenId) {\\n    tokenId = _mint(tokenCID);\\n  }\\n\\n  /**\\n   * @notice Allows the owner to mint and sets approval for all for the provided operator.\\n   * @dev This can be used by creators the first time they mint an NFT to save having to issue a separate approval\\n   * transaction before starting an auction.\\n   * @param tokenCID The CID of the NFT to mint.\\n   * @param operator The address to set as the operator for this collection contract.\\n   * @return tokenId The tokenId of the newly minted NFT.\\n   */\\n  function mintAndApprove(string calldata tokenCID, address operator) external returns (uint256 tokenId) {\\n    tokenId = _mint(tokenCID);\\n    setApprovalForAll(operator, true);\\n  }\\n\\n  /**\\n   * @notice Allows the owner to mint an NFT and have creator revenue/royalties sent to an alternate address.\\n   * @param tokenCID The CID of the NFT to mint.\\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\\n   * @return tokenId The tokenId of the newly minted NFT.\\n   */\\n  function mintWithCreatorPaymentAddress(string calldata tokenCID, address payable tokenCreatorPaymentAddress)\\n    public\\n    returns (uint256 tokenId)\\n  {\\n    require(tokenCreatorPaymentAddress != address(0), \\\"CollectionContract: tokenCreatorPaymentAddress is required\\\");\\n    tokenId = _mint(tokenCID);\\n    _setTokenCreatorPaymentAddress(tokenId, tokenCreatorPaymentAddress);\\n  }\\n\\n  /**\\n   * @notice Allows the owner to mint an NFT and have creator revenue/royalties sent to an alternate address.\\n   * Also sets approval for all for the provided operator.\\n   * @dev This can be used by creators the first time they mint an NFT to save having to issue a separate approval\\n   * transaction before starting an auction.\\n   * @param tokenCID The CID of the NFT to mint.\\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\\n   * @param operator The address to set as the operator for this collection contract.\\n   * @return tokenId The tokenId of the newly minted NFT.\\n   */\\n  function mintWithCreatorPaymentAddressAndApprove(\\n    string calldata tokenCID,\\n    address payable tokenCreatorPaymentAddress,\\n    address operator\\n  ) external returns (uint256 tokenId) {\\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\\n    setApprovalForAll(operator, true);\\n  }\\n\\n  /**\\n   * @notice Allows the owner to mint an NFT and have creator revenue/royalties sent to an alternate address\\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\\n   * @param tokenCID The CID of the NFT to mint.\\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\\n   * @param paymentAddressCallData The call details to sent to the factory provided.\\n   * @return tokenId The tokenId of the newly minted NFT.\\n   */\\n  function mintWithCreatorPaymentFactory(\\n    string calldata tokenCID,\\n    address paymentAddressFactory,\\n    bytes calldata paymentAddressCallData\\n  ) public returns (uint256 tokenId) {\\n    address payable tokenCreatorPaymentAddress = collectionFactory\\n      .proxyCallContract()\\n      .proxyCallAndReturnContractAddress(paymentAddressFactory, paymentAddressCallData);\\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\\n  }\\n\\n  /**\\n   * @notice Allows the owner to mint an NFT and have creator revenue/royalties sent to an alternate address\\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\\n   * Also sets approval for all for the provided operator.\\n   * @dev This can be used by creators the first time they mint an NFT to save having to issue a separate approval\\n   * transaction before starting an auction.\\n   * @param tokenCID The CID of the NFT to mint.\\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\\n   * @param paymentAddressCallData The call details to sent to the factory provided.\\n   * @param operator The address to set as the operator for this collection contract.\\n   * @return tokenId The tokenId of the newly minted NFT.\\n   */\\n  function mintWithCreatorPaymentFactoryAndApprove(\\n    string calldata tokenCID,\\n    address paymentAddressFactory,\\n    bytes calldata paymentAddressCallData,\\n    address operator\\n  ) external returns (uint256 tokenId) {\\n    tokenId = mintWithCreatorPaymentFactory(tokenCID, paymentAddressFactory, paymentAddressCallData);\\n    setApprovalForAll(operator, true);\\n  }\\n\\n  /**\\n   * @notice Allows the owner to assign a baseURI to use for the tokenURI instead of the default `ipfs://`.\\n   * @param baseURIOverride The new base URI to use for all NFTs in this collection.\\n   */\\n  function updateBaseURI(string calldata baseURIOverride) external onlyOwner {\\n    baseURI_ = baseURIOverride;\\n\\n    emit BaseURIUpdated(baseURIOverride);\\n  }\\n\\n  /**\\n   * @notice Allows the owner to set a max tokenID.\\n   * This provides a guarantee to collectors about the limit of this collection contract, if applicable.\\n   * @dev Once this value has been set, it may be decreased but can never be increased.\\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\\n   */\\n  function updateMaxTokenId(uint256 _maxTokenId) external onlyOwner {\\n    require(_maxTokenId != 0, \\\"CollectionContract: Max token ID may not be cleared\\\");\\n    require(maxTokenId == 0 || _maxTokenId < maxTokenId, \\\"CollectionContract: Max token ID may not increase\\\");\\n    require(latestTokenId + 1 <= _maxTokenId, \\\"CollectionContract: Max token ID must be greater than last mint\\\");\\n    maxTokenId = _maxTokenId;\\n\\n    emit MaxTokenIdUpdated(_maxTokenId);\\n  }\\n\\n  /**\\n   * @notice Allows the collection owner to destroy this contract only if\\n   * no NFTs have been minted yet.\\n   */\\n  function selfDestruct() external onlyOwner {\\n    require(totalSupply() == 0, \\\"CollectionContract: Any NFTs minted must be burned first\\\");\\n    emit SelfDestruct(msg.sender);\\n    selfdestruct(payable(msg.sender));\\n  }\\n\\n  /**\\n   * @dev Split into a second function to avoid stack too deep errors\\n   */\\n  function _adminAccountRecoveryForPaymentAddresses(\\n    uint256[] calldata paymentAddressTokenIds,\\n    address paymentAddressFactory,\\n    bytes memory paymentAddressCallData,\\n    uint256 addressLocationInCallData,\\n    address originalAddress,\\n    address payable newAddress\\n  ) private {\\n    // Call the factory and get the originalPaymentAddress\\n    address payable originalPaymentAddress = collectionFactory.proxyCallContract().proxyCallAndReturnContractAddress(\\n      paymentAddressFactory,\\n      paymentAddressCallData\\n    );\\n\\n    // Confirm the original address and swap with the new address\\n    paymentAddressCallData.replaceAtIf(addressLocationInCallData, originalAddress, newAddress);\\n\\n    // Call the factory and get the newPaymentAddress\\n    address payable newPaymentAddress = collectionFactory.proxyCallContract().proxyCallAndReturnContractAddress(\\n      paymentAddressFactory,\\n      paymentAddressCallData\\n    );\\n\\n    // For each token, confirm the expected payment address and then update to the new one\\n    unchecked {\\n      // The array length cannot overflow 256 bits.\\n      for (uint256 i = 0; i < paymentAddressTokenIds.length; ++i) {\\n        uint256 tokenId = paymentAddressTokenIds[i];\\n        require(\\n          tokenIdToCreatorPaymentAddress[tokenId] == originalPaymentAddress,\\n          \\\"CollectionContract: Payment address is not the expected value\\\"\\n        );\\n\\n        _setTokenCreatorPaymentAddress(tokenId, newPaymentAddress);\\n        emit PaymentAddressMigrated(tokenId, originalAddress, newAddress, originalPaymentAddress, newPaymentAddress);\\n      }\\n    }\\n  }\\n\\n  function _burn(uint256 tokenId) internal override {\\n    delete cidToMinted[_tokenCIDs[tokenId]];\\n    delete tokenIdToCreatorPaymentAddress[tokenId];\\n    delete _tokenCIDs[tokenId];\\n    unchecked {\\n      // Number of burned tokens cannot overflow 256 bits.\\n      ++burnCounter;\\n    }\\n    super._burn(tokenId);\\n  }\\n\\n  function _mint(string calldata tokenCID) private onlyOwner returns (uint256 tokenId) {\\n    require(bytes(tokenCID).length != 0, \\\"CollectionContract: tokenCID is required\\\");\\n    require(!cidToMinted[tokenCID], \\\"CollectionContract: NFT was already minted\\\");\\n    unchecked {\\n      // Number of tokens cannot overflow 256 bits.\\n      tokenId = ++latestTokenId;\\n      require(maxTokenId == 0 || tokenId <= maxTokenId, \\\"CollectionContract: Max token count has already been minted\\\");\\n      cidToMinted[tokenCID] = true;\\n      _tokenCIDs[tokenId] = tokenCID;\\n      _mint(msg.sender, tokenId);\\n      emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\\n    }\\n  }\\n\\n  /**\\n   * @dev Allow setting a different address to send payments to for both primary sale revenue\\n   * and secondary sales royalties.\\n   */\\n  function _setTokenCreatorPaymentAddress(uint256 tokenId, address payable tokenCreatorPaymentAddress) internal {\\n    emit TokenCreatorPaymentAddressSet(tokenIdToCreatorPaymentAddress[tokenId], tokenCreatorPaymentAddress, tokenId);\\n    tokenIdToCreatorPaymentAddress[tokenId] = tokenCreatorPaymentAddress;\\n  }\\n\\n  /**\\n   * @notice Get the base URI used for all NFTs in this collection.\\n   * @return uri The base URI.\\n   */\\n  function baseURI() external view returns (string memory uri) {\\n    uri = _baseURI();\\n  }\\n\\n  /**\\n   * @notice Returns an array of recipient addresses to which royalties for secondary sales should be sent.\\n   * The expected royalty amount is communicated with `getFeeBps`.\\n   * @param tokenId The tokenId of the NFT to get the royalty recipients for.\\n   * @return recipients An array of addresses to which royalties should be sent.\\n   */\\n  function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory recipients) {\\n    recipients = new address payable[](1);\\n    recipients[0] = getTokenCreatorPaymentAddress(tokenId);\\n  }\\n\\n  /**\\n   * @notice Returns an array of royalties to be sent for secondary sales in basis points.\\n   * The expected recipients is communicated with `getFeeRecipients`.\\n   * @dev The tokenId param is ignored since all NFTs return the same value.\\n   * @return feesInBasisPoints The array of fees to be sent to each recipient, in basis points.\\n   */\\n  function getFeeBps(\\n    uint256 /* tokenId */\\n  ) external pure returns (uint256[] memory feesInBasisPoints) {\\n    feesInBasisPoints = new uint256[](1);\\n    feesInBasisPoints[0] = ROYALTY_IN_BASIS_POINTS;\\n  }\\n\\n  /**\\n   * @notice Checks if the creator has already minted a given NFT using this collection contract.\\n   * @param tokenCID The CID to check for.\\n   * @return hasBeenMinted True if the creator has already minted an NFT with this CID.\\n   */\\n  function getHasMintedCID(string calldata tokenCID) external view returns (bool hasBeenMinted) {\\n    hasBeenMinted = cidToMinted[tokenCID];\\n  }\\n\\n  /**\\n   * @notice Returns an array of royalties to be sent for secondary sales.\\n   * @dev The data is the same as when calling getFeeRecipients and getFeeBps separately.\\n   * @param tokenId The tokenId of the NFT to get the royalties for.\\n   * @return recipients An array of addresses to which royalties should be sent.\\n   * @return feesInBasisPoints The array of fees to be sent to each recipient address.\\n   */\\n  function getRoyalties(uint256 tokenId)\\n    external\\n    view\\n    returns (address payable[] memory recipients, uint256[] memory feesInBasisPoints)\\n  {\\n    recipients = new address payable[](1);\\n    recipients[0] = getTokenCreatorPaymentAddress(tokenId);\\n    feesInBasisPoints = new uint256[](1);\\n    feesInBasisPoints[0] = ROYALTY_IN_BASIS_POINTS;\\n  }\\n\\n  /**\\n   * @notice Returns the desired payment address to be used for any transfers to the creator.\\n   * @dev The payment address may be assigned for each individual NFT, if not defined the collection owner is returned.\\n   * @param tokenId The tokenId of the NFT to get the royalties for.\\n   * @return tokenCreatorPaymentAddress The address to use for royalty payments for sales of this NFT.\\n   */\\n  function getTokenCreatorPaymentAddress(uint256 tokenId)\\n    public\\n    view\\n    returns (address payable tokenCreatorPaymentAddress)\\n  {\\n    tokenCreatorPaymentAddress = tokenIdToCreatorPaymentAddress[tokenId];\\n    if (tokenCreatorPaymentAddress == address(0)) {\\n      tokenCreatorPaymentAddress = owner;\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns the receiver and the amount to be sent for a secondary sale.\\n   * @param tokenId The tokenId of the NFT to get the royalty recipient and amount for.\\n   * @param salePrice The total price of the sale.\\n   * @return receiver The royalty recipient address for this sale.\\n   * @return royaltyAmount The total amount that should be sent to the `receiver`.\\n   */\\n  function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n    external\\n    view\\n    returns (address receiver, uint256 royaltyAmount)\\n  {\\n    receiver = getTokenCreatorPaymentAddress(tokenId);\\n    unchecked {\\n      royaltyAmount = salePrice / ROYALTY_RATIO;\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns the creator of this NFT collection.\\n   * @dev The tokenId param is ignored since all NFTs return the same value.\\n   * @return creator The creator of this collection.\\n   */\\n  function tokenCreator(\\n    uint256 /* tokenId */\\n  ) external view returns (address payable creator) {\\n    creator = owner;\\n  }\\n\\n  /**\\n   * @inheritdoc ERC165Upgradeable\\n   * @dev Checks the supported royalty interfaces.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public view override returns (bool interfaceSupported) {\\n    if (\\n      interfaceId == type(IRoyaltyInfo).interfaceId ||\\n      interfaceId == type(ITokenCreator).interfaceId ||\\n      interfaceId == type(IGetRoyalties).interfaceId ||\\n      interfaceId == type(IGetFees).interfaceId\\n    ) {\\n      interfaceSupported = true;\\n    } else {\\n      interfaceSupported = super.supportsInterface(interfaceId);\\n    }\\n  }\\n\\n  /**\\n   * @notice A distinct URI to the asset for a given NFT.\\n   * @param tokenId The tokenId of the NFT to get the URI for.\\n   * @return uri The URI for this NFT.\\n   */\\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\\n    require(_exists(tokenId), \\\"CollectionContract: URI query for nonexistent token\\\");\\n\\n    uri = string(abi.encodePacked(_baseURI(), _tokenCIDs[tokenId]));\\n  }\\n\\n  /**\\n   * @notice Count of NFTs tracked by this contract.\\n   * @dev From the ERC-721 enumerable standard.\\n   * @return supply The total number of NFTs still tracked by this contract.\\n   */\\n  function totalSupply() public view returns (uint256 supply) {\\n    unchecked {\\n      // Number of tokens is always >= burned tokens.\\n      supply = latestTokenId - burnCounter;\\n    }\\n  }\\n\\n  function _baseURI() internal view override returns (string memory) {\\n    if (bytes(baseURI_).length != 0) {\\n      return baseURI_;\\n    }\\n    return \\\"ipfs://\\\";\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Constant values shared across mixins.\\n */\\nabstract contract Constants {\\n  /**\\n   * @notice 100% in basis points.\\n   */\\n  uint256 internal constant BASIS_POINTS = 10000;\\n\\n  /**\\n   * @notice Cap the number of royalty recipients to 5.\\n   * @dev A cap is required to ensure gas costs are not too high when a sale is settled.\\n   */\\n  uint256 internal constant MAX_ROYALTY_RECIPIENTS_INDEX = 4;\\n\\n  /**\\n   * @notice The minimum increase of 10% required when making an offer or placing a bid.\\n   */\\n  uint256 internal constant MIN_PERCENT_INCREMENT_DENOMINATOR = BASIS_POINTS / 1000;\\n\\n  /**\\n   * @notice The gas limit used when making external read-only calls.\\n   * @dev This helps to ensure that external calls does not prevent the market from executing.\\n   */\\n  uint256 internal constant READ_ONLY_GAS_LIMIT = 40000;\\n\\n  /**\\n   * @notice The gas limit to send ETH to multiple recipients, enough for a 5-way split.\\n   */\\n  uint256 internal constant SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210000;\\n\\n  /**\\n   * @notice The gas limit to send ETH to a single recipient, enough for a contract with a simple receiver.\\n   */\\n  uint256 internal constant SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT = 20000;\\n}\\n\"\r\n    },\r\n    \"contracts/FETH.sol\": {\r\n      \"content\": \"/*\\n  \uff65\\n   *\u3000\u2605\\n      \uff65 \uff61\\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\\n\u200b\\n                      `                     .-:::::-.`              `-::---...```\\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\\n                                              `````\\n   *\u3000\\n      \uff65 \uff61\\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\\n\u3000\uff65\uff9f*\uff61\u2605\uff65\\n \u2606\u2234\uff61\u3000*\\n\uff65 \uff61\\n*/\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\nimport \\\"./libraries/LockedBalance.sol\\\";\\n\\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\\nerror FETH_Cannot_Deposit_To_Address_Zero();\\nerror FETH_Cannot_Deposit_To_FETH();\\nerror FETH_Cannot_Withdraw_To_Address_Zero();\\nerror FETH_Cannot_Withdraw_To_FETH();\\nerror FETH_Cannot_Withdraw_To_Market();\\nerror FETH_Escrow_Expired();\\nerror FETH_Escrow_Not_Found();\\nerror FETH_Expiration_Too_Far_In_Future();\\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\\nerror FETH_Insufficient_Allowance(uint256 amount);\\n/// @param amount The current available (unlocked) token count of this account.\\nerror FETH_Insufficient_Available_Funds(uint256 amount);\\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\\nerror FETH_Insufficient_Escrow(uint256 amount);\\nerror FETH_Invalid_Lockup_Duration();\\nerror FETH_Market_Must_Be_A_Contract();\\nerror FETH_Must_Deposit_Non_Zero_Amount();\\nerror FETH_Must_Lockup_Non_Zero_Amount();\\nerror FETH_No_Funds_To_Withdraw();\\nerror FETH_Only_FND_Market_Allowed();\\nerror FETH_Too_Much_ETH_Provided();\\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\\nerror FETH_Transfer_To_FETH_Not_Allowed();\\n\\n/**\\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\\n * @dev Locked balances are rounded up to the next hour.\\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \\\"bucket\\\".\\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\\n * to a DOA ownership or removing the permissions entirely.\\n */\\ncontract FETH {\\n  using AddressUpgradeable for address payable;\\n  using LockedBalance for LockedBalance.Lockups;\\n  using Math for uint256;\\n\\n  /// @notice Tracks an account's info.\\n  struct AccountInfo {\\n    /// @notice The number of tokens which have been unlocked already.\\n    uint96 freedBalance;\\n    /// @notice The first applicable lockup bucket for this account.\\n    uint32 lockupStartIndex;\\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\\n    LockedBalance.Lockups lockups;\\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\\n    mapping(address => uint256) allowance;\\n  }\\n\\n  /// @notice Stores per-account details.\\n  mapping(address => AccountInfo) private accountToInfo;\\n\\n  // Lockup configuration\\n  /// @notice The minimum lockup period in seconds.\\n  uint256 private immutable lockupDuration;\\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\\n  uint256 private immutable lockupInterval;\\n\\n  /// @notice The Foundation market contract with permissions to manage lockups.\\n  address payable private immutable foundationMarket;\\n\\n  // ERC-20 metadata fields\\n  /**\\n   * @notice The number of decimals the token uses.\\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\\n   * with this contract use whole amounts not considering decimals.\\n   * @return 18\\n   */\\n  uint8 public constant decimals = 18;\\n  /**\\n   * @notice The name of the token.\\n   * @return Foundation ETH\\n   */\\n  string public constant name = \\\"Foundation ETH\\\";\\n  /**\\n   * @notice The symbol of the token.\\n   * @return FETH\\n   */\\n  string public constant symbol = \\\"FETH\\\";\\n\\n  // ERC-20 events\\n  /**\\n   * @notice Emitted when the allowance for a spender account is updated.\\n   * @param from The account the spender is authorized to transact for.\\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\\n   */\\n  event Approval(address indexed from, address indexed spender, uint256 amount);\\n  /**\\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\\n   * @param from The account which is sending FETH tokens.\\n   * @param to The account which is receiving FETH tokens.\\n   * @param amount The number of FETH tokens which were sent.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n  // Custom events\\n  /**\\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\\n   * @param account The account which has access to the FETH after the `expiration`.\\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\\n   * @param amount The number of FETH tokens which where locked up.\\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\\n   * this may be lower than `amount` if available FETH was leveraged.\\n   */\\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\\n  /**\\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\\n   * @dev This event will not be emitted when lockups expire,\\n   * it's only for tokens which are unlocked before their expiry.\\n   * @param account The account which had locked FETH freed before expiration.\\n   * @param expiration The time this balance was originally scheduled to be unlocked.\\n   * @param amount The number of FETH tokens which were unlocked.\\n   */\\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\\n  /**\\n   * @notice Emitted when ETH is withdrawn from a user's account.\\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\\n   * @param from The account from which FETH was deducted in order to send the ETH.\\n   * @param to The address the ETH was sent to.\\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\\n   */\\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\\n\\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\\n  modifier onlyFoundationMarket() {\\n    if (msg.sender != foundationMarket) {\\n      revert FETH_Only_FND_Market_Allowed();\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @notice Set immutable variables for the implementation contract.\\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\\n   */\\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\\n    if (!_foundationMarket.isContract()) {\\n      revert FETH_Market_Must_Be_A_Contract();\\n    }\\n    foundationMarket = _foundationMarket;\\n    lockupDuration = _lockupDuration;\\n    lockupInterval = _lockupDuration / 24;\\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\\n      revert FETH_Invalid_Lockup_Duration();\\n    }\\n  }\\n\\n  /**\\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\\n   */\\n  receive() external payable {\\n    depositFor(msg.sender);\\n  }\\n\\n  /**\\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\\n   * We will add support for `increaseAllowance` in the future.\\n   * @param spender The address of the operator account that has approval to spend funds\\n   * from the `msg.sender`'s account.\\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\\n   * allowed to transact with.\\n   * @return success Always true.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool success) {\\n    accountToInfo[msg.sender].allowance[spender] = amount;\\n    emit Approval(msg.sender, spender, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\\n   * These tokens are not subject to any lockup period.\\n   */\\n  function deposit() external payable {\\n    depositFor(msg.sender);\\n  }\\n\\n  /**\\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\\n   * These tokens are not subject to any lockup period.\\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\\n   * @param account The account to credit with FETH tokens.\\n   */\\n  function depositFor(address account) public payable {\\n    if (msg.value == 0) {\\n      revert FETH_Must_Deposit_Non_Zero_Amount();\\n    } else if (account == address(0)) {\\n      revert FETH_Cannot_Deposit_To_Address_Zero();\\n    } else if (account == address(this)) {\\n      revert FETH_Cannot_Deposit_To_FETH();\\n    }\\n    AccountInfo storage accountInfo = accountToInfo[account];\\n    // ETH value cannot realistically overflow 96 bits.\\n    unchecked {\\n      accountInfo.freedBalance += uint96(msg.value);\\n    }\\n    emit Transfer(address(0), account, msg.value);\\n  }\\n\\n  /**\\n   * @notice Used by the market contract only:\\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\\n   * @dev Used by the market when an offer for an NFT is increased.\\n   * This may be for a single account (increasing their offer)\\n   * or two different accounts (outbidding someone elses offer).\\n   * @param unlockFrom The account whose lockup is to be removed.\\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\\n   * This will revert if the lockup has already expired.\\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\\n   * This will revert if the tokens were previously unlocked.\\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\\n   */\\n  function marketChangeLockup(\\n    address unlockFrom,\\n    uint256 unlockExpiration,\\n    uint256 unlockAmount,\\n    address lockupFor,\\n    uint256 lockupAmount\\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\\n    return _marketLockupFor(lockupFor, lockupAmount);\\n  }\\n\\n  /**\\n   * @notice Used by the market contract only:\\n   * Lockup an account's FETH tokens for 24-25 hours.\\n   * @dev Used by the market when a new offer for an NFT is made.\\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\\n   */\\n  function marketLockupFor(address account, uint256 amount)\\n    external\\n    payable\\n    onlyFoundationMarket\\n    returns (uint256 expiration)\\n  {\\n    return _marketLockupFor(account, amount);\\n  }\\n\\n  /**\\n   * @notice Used by the market contract only:\\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\\n   * @param account The account whose lockup is to be unlocked.\\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\\n   * This will revert if the lockup has already expired.\\n   * @param amount The number of tokens to be unlocked from `account`.\\n   * This will revert if the tokens were previously unlocked.\\n   */\\n  function marketUnlockFor(\\n    address account,\\n    uint256 expiration,\\n    uint256 amount\\n  ) external onlyFoundationMarket {\\n    _marketUnlockFor(account, expiration, amount);\\n  }\\n\\n  /**\\n   * @notice Used by the market contract only:\\n   * Removes tokens from the user's available balance and returns ETH to the caller.\\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\\n   * @param from The account whose available balance is to be withdrawn from.\\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\\n   * This will revert if the tokens were previously unlocked.\\n   */\\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\\n    _deductBalanceFrom(accountInfo, amount);\\n\\n    // With the external call after state changes, we do not need a nonReentrant guard\\n    payable(msg.sender).sendValue(amount);\\n\\n    emit ETHWithdrawn(from, msg.sender, amount);\\n  }\\n\\n  /**\\n   * @notice Used by the market contract only:\\n   * Removes a lockup from the user's account and then returns ETH to the caller.\\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\\n   * a sale when the user's offer is accepted.\\n   * @param account The account whose lockup is to be removed.\\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\\n   * This will revert if the lockup has already expired.\\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\\n   */\\n  function marketWithdrawLocked(\\n    address account,\\n    uint256 expiration,\\n    uint256 amount\\n  ) external onlyFoundationMarket {\\n    _removeFromLockedBalance(account, expiration, amount);\\n\\n    // With the external call after state changes, we do not need a nonReentrant guard\\n    payable(msg.sender).sendValue(amount);\\n\\n    emit ETHWithdrawn(account, msg.sender, amount);\\n  }\\n\\n  /**\\n   * @notice Transfers an amount from your account.\\n   * @param to The address of the account which the tokens are transferred from.\\n   * @param amount The number of FETH tokens to be transferred.\\n   * @return success Always true (reverts if insufficient funds).\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool success) {\\n    return transferFrom(msg.sender, to, amount);\\n  }\\n\\n  /**\\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\\n   * @param from The address from which the available tokens are transferred from.\\n   * @param to The address to which the tokens are to be transferred.\\n   * @param amount The number of FETH tokens to be transferred.\\n   * @return success Always true (reverts if insufficient funds or not approved).\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) public returns (bool success) {\\n    if (to == address(0)) {\\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\\n    } else if (to == address(this)) {\\n      revert FETH_Transfer_To_FETH_Not_Allowed();\\n    }\\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\\n    if (from != msg.sender) {\\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\\n    }\\n    _deductBalanceFrom(fromAccountInfo, amount);\\n    AccountInfo storage toAccountInfo = accountToInfo[to];\\n\\n    // Total ETH cannot realistically overflow 96 bits.\\n    unchecked {\\n      toAccountInfo.freedBalance += uint96(amount);\\n    }\\n\\n    emit Transfer(from, to, amount);\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Withdraw all tokens available in your account and receive ETH.\\n   */\\n  function withdrawAvailableBalance() external {\\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\\n    uint256 amount = accountInfo.freedBalance;\\n    if (amount == 0) {\\n      revert FETH_No_Funds_To_Withdraw();\\n    }\\n    delete accountInfo.freedBalance;\\n\\n    // With the external call after state changes, we do not need a nonReentrant guard\\n    payable(msg.sender).sendValue(amount);\\n\\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\\n  }\\n\\n  /**\\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\\n   * and send ETH to the destination address, if the `msg.sender` has approval.\\n   * @param from The address from which the available funds are to be withdrawn.\\n   * @param to The destination address for the ETH to be transferred to.\\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\\n   */\\n  function withdrawFrom(\\n    address from,\\n    address payable to,\\n    uint256 amount\\n  ) external {\\n    if (amount == 0) {\\n      revert FETH_No_Funds_To_Withdraw();\\n    } else if (to == address(0)) {\\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\\n    } else if (to == address(this)) {\\n      revert FETH_Cannot_Withdraw_To_FETH();\\n    } else if (to == address(foundationMarket)) {\\n      revert FETH_Cannot_Withdraw_To_Market();\\n    }\\n\\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\\n    if (from != msg.sender) {\\n      _deductAllowanceFrom(accountInfo, amount, from);\\n    }\\n    _deductBalanceFrom(accountInfo, amount);\\n\\n    // With the external call after state changes, we do not need a nonReentrant guard\\n    to.sendValue(amount);\\n\\n    emit ETHWithdrawn(from, to, amount);\\n  }\\n\\n  /**\\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\\n   */\\n  function _deductAllowanceFrom(\\n    AccountInfo storage accountInfo,\\n    uint256 amount,\\n    address from\\n  ) private {\\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\\n    if (spenderAllowance != type(uint256).max) {\\n      if (spenderAllowance < amount) {\\n        revert FETH_Insufficient_Allowance(spenderAllowance);\\n      }\\n      // The check above ensures allowance cannot underflow.\\n      unchecked {\\n        spenderAllowance -= amount;\\n      }\\n      accountInfo.allowance[msg.sender] = spenderAllowance;\\n      emit Approval(from, msg.sender, spenderAllowance);\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes an amount from the account's available FETH balance.\\n   */\\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\\n    uint96 freedBalance = accountInfo.freedBalance;\\n    // Free from escrow in order to consider any expired escrow balance\\n    if (freedBalance < amount) {\\n      revert FETH_Insufficient_Available_Funds(freedBalance);\\n    }\\n    // The check above ensures balance cannot underflow.\\n    unchecked {\\n      accountInfo.freedBalance = freedBalance - uint96(amount);\\n    }\\n  }\\n\\n  /**\\n   * @dev Moves expired escrow to the available balance.\\n   * Sets the next bucket that hasn't expired as the new start index.\\n   */\\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\\n    AccountInfo storage accountInfo = accountToInfo[account];\\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\\n\\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\\n      return accountInfo;\\n    }\\n\\n    while (true) {\\n      // Total ETH cannot realistically overflow 96 bits.\\n      unchecked {\\n        accountInfo.freedBalance += escrow.totalAmount;\\n        accountInfo.lockups.del(escrowIndex);\\n        // Escrow index cannot overflow 32 bits.\\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\\n      }\\n\\n      // If the next bucket is empty, the start index is set to the previous bucket\\n      if (escrow.expiration == 0) {\\n        break;\\n      }\\n\\n      // Escrow index cannot overflow 32 bits.\\n      unchecked {\\n        // Increment the escrow start index if the next bucket is not empty\\n        ++escrowIndex;\\n      }\\n\\n      // If the next bucket is expired, that's the new start index\\n      if (escrow.expiration >= block.timestamp) {\\n        break;\\n      }\\n    }\\n\\n    // Escrow index cannot overflow 32 bits.\\n    unchecked {\\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\\n    }\\n    return accountInfo;\\n  }\\n\\n  /**\\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\\n   */\\n  /* solhint-disable-next-line code-complexity */\\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\\n    if (account == address(0)) {\\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\\n    }\\n    if (amount == 0) {\\n      revert FETH_Must_Lockup_Non_Zero_Amount();\\n    }\\n\\n    // Block timestamp in seconds is small enough to never overflow\\n    unchecked {\\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\\n    }\\n\\n    // Update available escrow\\n    // Always free from escrow to ensure the max bucket count is <= 25\\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\\n    if (msg.value < amount) {\\n      unchecked {\\n        // The if check above prevents an underflow here\\n        _deductBalanceFrom(accountInfo, amount - msg.value);\\n      }\\n    } else if (msg.value != amount) {\\n      // There's no reason to send msg.value more than the amount being locked up\\n      revert FETH_Too_Much_ETH_Provided();\\n    }\\n\\n    // Add to locked escrow\\n    unchecked {\\n      // The number of buckets is always < 256 bits.\\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\\n        if (escrow.expiration == 0) {\\n          if (expiration > type(uint32).max) {\\n            revert FETH_Expiration_Too_Far_In_Future();\\n          }\\n          // Amount (ETH) will always be < 96 bits.\\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\\n          break;\\n        }\\n        if (escrow.expiration == expiration) {\\n          // Total ETH will always be < 96 bits.\\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\\n          break;\\n        }\\n      }\\n    }\\n\\n    emit BalanceLocked(account, expiration, amount, msg.value);\\n  }\\n\\n  /**\\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\\n   */\\n  function _marketUnlockFor(\\n    address account,\\n    uint256 expiration,\\n    uint256 amount\\n  ) private {\\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\\n    // Total ETH cannot realistically overflow 96 bits.\\n    unchecked {\\n      accountInfo.freedBalance += uint96(amount);\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\\n   */\\n  /* solhint-disable-next-line code-complexity */\\n  function _removeFromLockedBalance(\\n    address account,\\n    uint256 expiration,\\n    uint256 amount\\n  ) private returns (AccountInfo storage) {\\n    if (expiration < block.timestamp) {\\n      revert FETH_Escrow_Expired();\\n    }\\n\\n    AccountInfo storage accountInfo = accountToInfo[account];\\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\\n\\n    if (escrow.expiration == expiration) {\\n      // If removing from the first bucket, we may be able to delete it\\n      if (escrow.totalAmount == amount) {\\n        accountInfo.lockups.del(escrowIndex);\\n\\n        // Bump the escrow start index unless it's the last one\\n        unchecked {\\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\\n            // The number of escrow buckets will never overflow 32 bits.\\n            ++accountInfo.lockupStartIndex;\\n          }\\n        }\\n      } else {\\n        if (escrow.totalAmount < amount) {\\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\\n        }\\n        // The require above ensures balance will not underflow.\\n        unchecked {\\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\\n        }\\n      }\\n    } else {\\n      // Removing from the 2nd+ bucket\\n      while (true) {\\n        // The number of escrow buckets will never overflow 32 bits.\\n        unchecked {\\n          ++escrowIndex;\\n        }\\n        escrow = accountInfo.lockups.get(escrowIndex);\\n        if (escrow.expiration == expiration) {\\n          if (amount > escrow.totalAmount) {\\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\\n          }\\n          // The require above ensures balance will not underflow.\\n          unchecked {\\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\\n          }\\n          // We may have an entry with 0 totalAmount but expiration will be set\\n          break;\\n        }\\n        if (escrow.expiration == 0) {\\n          revert FETH_Escrow_Not_Found();\\n        }\\n      }\\n    }\\n\\n    emit BalanceUnlocked(account, expiration, amount);\\n    return accountInfo;\\n  }\\n\\n  /**\\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\\n   * @param account The owner of the funds.\\n   * @param operator The address with approval to spend from the `account`'s balance.\\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\\n   */\\n  function allowance(address account, address operator) external view returns (uint256 amount) {\\n    AccountInfo storage accountInfo = accountToInfo[account];\\n    amount = accountInfo.allowance[operator];\\n  }\\n\\n  /**\\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\\n   * @param account The account to query the available balance of.\\n   * @return balance The available balance of the account.\\n   */\\n  function balanceOf(address account) external view returns (uint256 balance) {\\n    AccountInfo storage accountInfo = accountToInfo[account];\\n    balance = accountInfo.freedBalance;\\n\\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\\n    unchecked {\\n      // Add expired lockups\\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\\n          break;\\n        }\\n        balance += escrow.totalAmount;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\\n   * @return market The Foundation market contract address.\\n   */\\n  function getFoundationMarket() external view returns (address market) {\\n    market = foundationMarket;\\n  }\\n\\n  /**\\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\\n   * @dev `expires.length` == `amounts.length`\\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\\n   * The results returned are sorted by expiry, with the earliest expiry date first.\\n   * @param account The account to query the locked balance of.\\n   * @return expiries The time at which each outstanding lockup bucket expires.\\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\\n   */\\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\\n    AccountInfo storage accountInfo = accountToInfo[account];\\n\\n    // Count lockups\\n    uint256 lockedCount;\\n    // The number of buckets is always < 256 bits.\\n    unchecked {\\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\\n        if (escrow.expiration == 0) {\\n          break;\\n        }\\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\\n          // Lockup count will never overflow 256 bits.\\n          ++lockedCount;\\n        }\\n      }\\n    }\\n\\n    // Allocate arrays\\n    expiries = new uint256[](lockedCount);\\n    amounts = new uint256[](lockedCount);\\n\\n    // Populate results\\n    uint256 i;\\n    // The number of buckets is always < 256 bits.\\n    unchecked {\\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\\n        if (escrow.expiration == 0) {\\n          break;\\n        }\\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\\n          expiries[i] = escrow.expiration;\\n          amounts[i] = escrow.totalAmount;\\n          ++i;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns the total balance of an account, including locked FETH tokens.\\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\\n   * @param account The account to query the total balance of.\\n   * @return balance The total FETH balance tracked for this account.\\n   */\\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\\n    AccountInfo storage accountInfo = accountToInfo[account];\\n    balance = accountInfo.freedBalance;\\n\\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\\n    unchecked {\\n      // Add all lockups\\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\\n        if (escrow.expiration == 0) {\\n          break;\\n        }\\n        balance += escrow.totalAmount;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns the total amount of ETH locked in this contract.\\n   * @return supply The total amount of ETH locked in this contract.\\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\\n   * but this is on-par with the WETH implementation and done for gas savings.\\n   */\\n  function totalSupply() external view returns (uint256 supply) {\\n    return address(this).balance;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ens/IENS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface for the main ENS contract\\n */\\ninterface IENS {\\n  function setSubnodeOwner(\\n    bytes32 node,\\n    bytes32 label,\\n    address owner\\n  ) external returns (bytes32);\\n\\n  function setResolver(bytes32 node, address resolver) external;\\n\\n  function owner(bytes32 node) external view returns (address);\\n\\n  function resolver(bytes32 node) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ens/IPublicResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface for the main ENS resolver contract.\\n */\\ninterface IPublicResolver {\\n  function setAddr(bytes32 node, address a) external;\\n\\n  function name(bytes32 node) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ens/IReverseRegistrar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface for the main ENS reverse registrar contract.\\n */\\ninterface IReverseRegistrar {\\n  function setName(string memory name) external;\\n\\n  function node(address addr) external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721Upgradeable.sol\\\";\\nimport \\\"./IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"./extensions/IERC721MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\\n    using AddressUpgradeable for address;\\n    using StringsUpgradeable for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC721_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return\\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[44] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/FoundationTreasuryNode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport \\\"../interfaces/IAdminRole.sol\\\";\\nimport \\\"../interfaces/IOperatorRole.sol\\\";\\n\\nerror FoundationTreasuryNode_Address_Is_Not_A_Contract();\\nerror FoundationTreasuryNode_Caller_Not_Admin();\\nerror FoundationTreasuryNode_Caller_Not_Operator();\\n\\n/**\\n * @title A mixin that stores a reference to the Foundation treasury contract.\\n * @notice The treasury collects fees and defines admin/operator roles.\\n */\\nabstract contract FoundationTreasuryNode is Initializable {\\n  using AddressUpgradeable for address payable;\\n\\n  /// @dev This value was replaced with an immutable version.\\n  address payable private __gap_was_treasury;\\n\\n  /// @notice The address of the treasury contract.\\n  address payable private immutable treasury;\\n\\n  /// @notice Requires the caller is a Foundation admin.\\n  modifier onlyFoundationAdmin() {\\n    if (!IAdminRole(treasury).isAdmin(msg.sender)) {\\n      revert FoundationTreasuryNode_Caller_Not_Admin();\\n    }\\n    _;\\n  }\\n\\n  /// @notice Requires the caller is a Foundation operator.\\n  modifier onlyFoundationOperator() {\\n    if (!IOperatorRole(treasury).isOperator(msg.sender)) {\\n      revert FoundationTreasuryNode_Caller_Not_Operator();\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @notice Set immutable variables for the implementation contract.\\n   * @dev Assigns the treasury contract address.\\n   */\\n  constructor(address payable _treasury) {\\n    if (!_treasury.isContract()) {\\n      revert FoundationTreasuryNode_Address_Is_Not_A_Contract();\\n    }\\n    treasury = _treasury;\\n  }\\n\\n  /**\\n   * @notice Gets the Foundation treasury contract.\\n   * @dev This call is used in the royalty registry contract.\\n   * @return treasuryAddress The address of the Foundation treasury contract.\\n   */\\n  function getFoundationTreasury() public view returns (address payable treasuryAddress) {\\n    return treasury;\\n  }\\n\\n  /**\\n   * @notice This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[2000] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/NFTMarketAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @title An abstraction layer for auctions.\\n * @dev This contract can be expanded with reusable calls and data as more auction types are added.\\n */\\nabstract contract NFTMarketAuction is Initializable {\\n  /**\\n   * @notice A global id for auctions of any type.\\n   */\\n  uint256 private nextAuctionId;\\n\\n  /**\\n   * @notice Called once to configure the contract after the initial proxy deployment.\\n   * @dev This sets the initial auction id to 1, making the first auction cheaper\\n   * and id 0 represents no auction found.\\n   */\\n  function _initializeNFTMarketAuction() internal onlyInitializing {\\n    nextAuctionId = 1;\\n  }\\n\\n  /**\\n   * @notice Returns id to assign to the next auction.\\n   */\\n  function _getNextAndIncrementAuctionId() internal returns (uint256) {\\n    // AuctionId cannot overflow 256 bits.\\n    unchecked {\\n      return nextAuctionId++;\\n    }\\n  }\\n\\n  /**\\n   * @notice This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[1000] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/NFTMarketBuyPrice.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"./NFTMarketCore.sol\\\";\\nimport \\\"./NFTMarketFees.sol\\\";\\n\\n/// @param buyPrice The current buy price set for this NFT.\\nerror NFTMarketBuyPrice_Cannot_Buy_At_Lower_Price(uint256 buyPrice);\\nerror NFTMarketBuyPrice_Cannot_Buy_Unset_Price();\\nerror NFTMarketBuyPrice_Cannot_Cancel_Unset_Price();\\n/// @param owner The current owner of this NFT.\\nerror NFTMarketBuyPrice_Only_Owner_Can_Cancel_Price(address owner);\\n/// @param owner The current owner of this NFT.\\nerror NFTMarketBuyPrice_Only_Owner_Can_Set_Price(address owner);\\nerror NFTMarketBuyPrice_Price_Already_Set();\\nerror NFTMarketBuyPrice_Price_Too_High();\\n/// @param seller The current owner of this NFT.\\nerror NFTMarketBuyPrice_Seller_Mismatch(address seller);\\n\\n/**\\n * @title Allows sellers to set a buy price of their NFTs that may be accepted and instantly transferred to the buyer.\\n * @notice NFTs with a buy price set are escrowed in the market contract.\\n */\\nabstract contract NFTMarketBuyPrice is NFTMarketCore, NFTMarketFees {\\n  using AddressUpgradeable for address payable;\\n\\n  /// @notice Stores the buy price details for a specific NFT.\\n  /// @dev The struct is packed into a single slot to optimize gas.\\n  struct BuyPrice {\\n    /// @notice The current owner of this NFT which set a buy price.\\n    /// @dev A zero price is acceptable so a non-zero address determines whether a price has been set.\\n    address payable seller;\\n    /// @notice The current buy price set for this NFT.\\n    uint96 price;\\n  }\\n\\n  /// @notice Stores the current buy price for each NFT.\\n  mapping(address => mapping(uint256 => BuyPrice)) private nftContractToTokenIdToBuyPrice;\\n\\n  /**\\n   * @notice Emitted when an NFT is bought by accepting the buy price,\\n   * indicating that the NFT has been transferred and revenue from the sale distributed.\\n   * @dev The total buy price that was accepted is `protocolFee` + `creatorFee` + `sellerRev`.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @param buyer The address of the collector that purchased the NFT using `buy`.\\n   * @param seller The address of the seller which originally set the buy price.\\n   * @param protocolFee The amount of ETH that was sent to Foundation for this sale.\\n   * @param creatorFee The amount of ETH that was sent to the creator for this sale.\\n   * @param sellerRev The amount of ETH that was sent to the owner for this sale.\\n   */\\n  event BuyPriceAccepted(\\n    address indexed nftContract,\\n    uint256 indexed tokenId,\\n    address indexed seller,\\n    address buyer,\\n    uint256 protocolFee,\\n    uint256 creatorFee,\\n    uint256 sellerRev\\n  );\\n  /**\\n   * @notice Emitted when the buy price is removed by the owner of an NFT.\\n   * @dev The NFT is transferred back to the owner unless it's still escrowed for another market tool,\\n   * e.g. listed for sale in an auction.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   */\\n  event BuyPriceCanceled(address indexed nftContract, uint256 indexed tokenId);\\n  /**\\n   * @notice Emitted when a buy price is invalidated due to other market activity.\\n   * @dev This occurs when the buy price is no longer eligible to be accepted,\\n   * e.g. when a bid is placed in an auction for this NFT.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   */\\n  event BuyPriceInvalidated(address indexed nftContract, uint256 indexed tokenId);\\n  /**\\n   * @notice Emitted when a buy price is set by the owner of an NFT.\\n   * @dev The NFT is transferred into the market contract for escrow unless it was already escrowed,\\n   * e.g. for auction listing.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @param seller The address of the NFT owner which set the buy price.\\n   * @param price The price of the NFT.\\n   */\\n  event BuyPriceSet(address indexed nftContract, uint256 indexed tokenId, address indexed seller, uint256 price);\\n\\n  /**\\n   * @notice Buy the NFT at the set buy price.\\n   * `msg.value` must be <= `maxPrice` and any delta will be taken from the account's available FETH balance.\\n   * @dev `maxPrice` protects the buyer in case a the price is increased but allows the transaction to continue\\n   * when the price is reduced (and any surplus funds provided are refunded).\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @param maxPrice The maximum price to pay for the NFT.\\n   */\\n  function buy(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 maxPrice\\n  ) external payable {\\n    buyV2(nftContract, tokenId, maxPrice, payable(0));\\n  }\\n\\n  /**\\n   * @notice Buy the NFT at the set buy price.\\n   * `msg.value` must be <= `maxPrice` and any delta will be taken from the account's available FETH balance.\\n   * @dev `maxPrice` protects the buyer in case a the price is increased but allows the transaction to continue\\n   * when the price is reduced (and any surplus funds provided are refunded).\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @param maxPrice The maximum price to pay for the NFT.\\n   * @param referrer The address of the referrer.\\n   */\\n  function buyV2(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 maxPrice,\\n    address payable referrer\\n  ) public payable {\\n    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];\\n    if (buyPrice.price > maxPrice) {\\n      revert NFTMarketBuyPrice_Cannot_Buy_At_Lower_Price(buyPrice.price);\\n    } else if (buyPrice.seller == address(0)) {\\n      revert NFTMarketBuyPrice_Cannot_Buy_Unset_Price();\\n    }\\n\\n    _buy(nftContract, tokenId, referrer);\\n  }\\n\\n  /**\\n   * @notice Removes the buy price set for an NFT.\\n   * @dev The NFT is transferred back to the owner unless it's still escrowed for another market tool,\\n   * e.g. listed for sale in an auction.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   */\\n  function cancelBuyPrice(address nftContract, uint256 tokenId) external nonReentrant {\\n    address seller = nftContractToTokenIdToBuyPrice[nftContract][tokenId].seller;\\n    if (seller == address(0)) {\\n      // This check is redundant with the next one, but done in order to provide a more clear error message.\\n      revert NFTMarketBuyPrice_Cannot_Cancel_Unset_Price();\\n    } else if (seller != msg.sender) {\\n      revert NFTMarketBuyPrice_Only_Owner_Can_Cancel_Price(seller);\\n    }\\n\\n    // Remove the buy price\\n    delete nftContractToTokenIdToBuyPrice[nftContract][tokenId];\\n\\n    // Transfer the NFT back to the owner if it is not listed in auction.\\n    _transferFromEscrowIfAvailable(nftContract, tokenId, msg.sender);\\n\\n    emit BuyPriceCanceled(nftContract, tokenId);\\n  }\\n\\n  /**\\n   * @notice Sets the buy price for an NFT and escrows it in the market contract.\\n   * A 0 price is acceptable and valid price you can set, enabling a giveaway to the first collector that calls `buy`.\\n   * @dev If there is an offer for this amount or higher, that will be accepted instead of setting a buy price.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @param price The price at which someone could buy this NFT.\\n   */\\n  function setBuyPrice(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 price\\n  ) external nonReentrant {\\n    // If there is a valid offer at this price or higher, accept that instead.\\n    if (_autoAcceptOffer(nftContract, tokenId, price)) {\\n      return;\\n    }\\n\\n    if (price > type(uint96).max) {\\n      // This ensures that no data is lost when storing the price as `uint96`.\\n      revert NFTMarketBuyPrice_Price_Too_High();\\n    }\\n\\n    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];\\n    address seller = buyPrice.seller;\\n\\n    if (buyPrice.price == price && seller != address(0)) {\\n      revert NFTMarketBuyPrice_Price_Already_Set();\\n    }\\n\\n    // Store the new price for this NFT.\\n    buyPrice.price = uint96(price);\\n\\n    if (seller == address(0)) {\\n      // Transfer the NFT into escrow, if it's already in escrow confirm the `msg.sender` is the owner.\\n      _transferToEscrow(nftContract, tokenId);\\n\\n      // The price was not previously set for this NFT, store the seller.\\n      buyPrice.seller = payable(msg.sender);\\n    } else if (seller != msg.sender) {\\n      // Buy price was previously set by a different user\\n      revert NFTMarketBuyPrice_Only_Owner_Can_Set_Price(seller);\\n    }\\n\\n    emit BuyPriceSet(nftContract, tokenId, msg.sender, price);\\n  }\\n\\n  /**\\n   * @notice If there is a buy price at this price or lower, accept that and return true.\\n   */\\n  function _autoAcceptBuyPrice(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 maxPrice\\n  ) internal override returns (bool) {\\n    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];\\n    if (buyPrice.seller == address(0) || buyPrice.price > maxPrice) {\\n      // No buy price was found, or the price is too high.\\n      return false;\\n    }\\n\\n    _buy(nftContract, tokenId, payable(0));\\n    return true;\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   * @dev Invalidates the buy price on a auction start, if one is found.\\n   */\\n  function _beforeAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {\\n    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];\\n    if (buyPrice.seller != address(0)) {\\n      // A buy price was set for this NFT, invalidate it.\\n      _invalidateBuyPrice(nftContract, tokenId);\\n    }\\n    super._beforeAuctionStarted(nftContract, tokenId);\\n  }\\n\\n  /**\\n   * @notice Process the purchase of an NFT at the current buy price.\\n   * @dev The caller must confirm that the seller != address(0) before calling this function.\\n   */\\n  function _buy(\\n    address nftContract,\\n    uint256 tokenId,\\n    address payable referrer\\n  ) private nonReentrant {\\n    BuyPrice memory buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];\\n\\n    // Remove the buy now price\\n    delete nftContractToTokenIdToBuyPrice[nftContract][tokenId];\\n\\n    // Cancel the buyer's offer if there is one in order to free up their FETH balance\\n    // even if they don't need the FETH for this specific purchase.\\n    _cancelSendersOffer(nftContract, tokenId);\\n\\n    if (buyPrice.price > msg.value) {\\n      // Withdraw additional ETH required from their available FETH balance.\\n\\n      unchecked {\\n        // The if above ensures delta will not underflow.\\n        uint256 delta = buyPrice.price - msg.value;\\n        // Withdraw ETH from the buyer's account in the FETH token contract,\\n        // making the ETH available for `_distributeFunds` below.\\n        feth.marketWithdrawFrom(msg.sender, delta);\\n      }\\n    } else if (buyPrice.price < msg.value) {\\n      // Return any surplus funds to the buyer.\\n\\n      unchecked {\\n        // The if above ensures this will not underflow\\n        payable(msg.sender).sendValue(msg.value - buyPrice.price);\\n      }\\n    }\\n\\n    // Transfer the NFT to the buyer.\\n    // The seller was already authorized when the buyPrice was set originally set.\\n    _transferFromEscrow(nftContract, tokenId, msg.sender, address(0));\\n\\n    // Distribute revenue for this sale.\\n    (uint256 protocolFee, uint256 creatorFee, uint256 sellerRev) = _distributeFunds(\\n      nftContract,\\n      tokenId,\\n      buyPrice.seller,\\n      buyPrice.price,\\n      referrer\\n    );\\n\\n    emit BuyPriceAccepted(nftContract, tokenId, buyPrice.seller, msg.sender, protocolFee, creatorFee, sellerRev);\\n  }\\n\\n  /**\\n   * @notice Clear a buy price and emit BuyPriceInvalidated.\\n   * @dev The caller must confirm the buy price is set before calling this function.\\n   */\\n  function _invalidateBuyPrice(address nftContract, uint256 tokenId) private {\\n    delete nftContractToTokenIdToBuyPrice[nftContract][tokenId];\\n    emit BuyPriceInvalidated(nftContract, tokenId);\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   * @dev Invalidates the buy price if one is found before transferring the NFT.\\n   * This will revert if there is a buy price set but the `authorizeSeller` is not the owner.\\n   */\\n  function _transferFromEscrow(\\n    address nftContract,\\n    uint256 tokenId,\\n    address recipient,\\n    address authorizeSeller\\n  ) internal virtual override {\\n    address seller = nftContractToTokenIdToBuyPrice[nftContract][tokenId].seller;\\n    if (seller != address(0)) {\\n      // A buy price was set for this NFT.\\n      // `authorizeSeller != address(0) &&` could be added when other mixins use this flow.\\n      // ATM that additional check would never return false.\\n      if (seller != authorizeSeller) {\\n        // When there is a buy price set, the `buyPrice.seller` is the owner of the NFT.\\n        revert NFTMarketBuyPrice_Seller_Mismatch(seller);\\n      }\\n      // The seller authorization has been confirmed.\\n      authorizeSeller = address(0);\\n\\n      // Invalidate the buy price as the NFT will no longer be in escrow.\\n      _invalidateBuyPrice(nftContract, tokenId);\\n    }\\n\\n    super._transferFromEscrow(nftContract, tokenId, recipient, authorizeSeller);\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   * @dev Checks if there is a buy price set, if not then allow the transfer to proceed.\\n   */\\n  function _transferFromEscrowIfAvailable(\\n    address nftContract,\\n    uint256 tokenId,\\n    address recipient\\n  ) internal virtual override {\\n    address seller = nftContractToTokenIdToBuyPrice[nftContract][tokenId].seller;\\n    if (seller == address(0)) {\\n      // A buy price has been set for this NFT so it should remain in escrow.\\n      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);\\n    }\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   * @dev Checks if the NFT is already in escrow for buy now.\\n   */\\n  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {\\n    address seller = nftContractToTokenIdToBuyPrice[nftContract][tokenId].seller;\\n    if (seller == address(0)) {\\n      // The NFT is not in escrow for buy now.\\n      super._transferToEscrow(nftContract, tokenId);\\n    } else if (seller != msg.sender) {\\n      // When there is a buy price set, the `seller` is the owner of the NFT.\\n      revert NFTMarketBuyPrice_Seller_Mismatch(seller);\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns the buy price details for an NFT if one is available.\\n   * @dev If no price is found, seller will be address(0) and price will be max uint256.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @return seller The address of the owner that listed a buy price for this NFT.\\n   * Returns `address(0)` if there is no buy price set for this NFT.\\n   * @return price The price of the NFT.\\n   * Returns `0` if there is no buy price set for this NFT.\\n   */\\n  function getBuyPrice(address nftContract, uint256 tokenId) external view returns (address seller, uint256 price) {\\n    seller = nftContractToTokenIdToBuyPrice[nftContract][tokenId].seller;\\n    if (seller == address(0)) {\\n      return (seller, type(uint256).max);\\n    }\\n    price = nftContractToTokenIdToBuyPrice[nftContract][tokenId].price;\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   * @dev Returns the seller if there is a buy price set for this NFT, otherwise\\n   * bubbles the call up for other considerations.\\n   */\\n  function _getSellerFor(address nftContract, uint256 tokenId)\\n    internal\\n    view\\n    virtual\\n    override\\n    returns (address payable seller)\\n  {\\n    seller = nftContractToTokenIdToBuyPrice[nftContract][tokenId].seller;\\n    if (seller == address(0)) {\\n      seller = super._getSellerFor(nftContract, tokenId);\\n    }\\n  }\\n\\n  /**\\n   * @notice This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[1000] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/NFTMarketCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\n\\nimport \\\"./Constants.sol\\\";\\n\\nimport \\\"../interfaces/IFethMarket.sol\\\";\\n\\nerror NFTMarketCore_FETH_Address_Is_Not_A_Contract();\\nerror NFTMarketCore_Only_FETH_Can_Transfer_ETH();\\nerror NFTMarketCore_Seller_Not_Found();\\n\\n/**\\n * @title A place for common modifiers and functions used by various NFTMarket mixins, if any.\\n * @dev This also leaves a gap which can be used to add a new mixin to the top of the inheritance tree.\\n */\\nabstract contract NFTMarketCore is Constants {\\n  using AddressUpgradeable for address;\\n\\n  /// @notice The FETH ERC-20 token for managing escrow and lockup.\\n  IFethMarket internal immutable feth;\\n\\n  constructor(address _feth) {\\n    if (!_feth.isContract()) {\\n      revert NFTMarketCore_FETH_Address_Is_Not_A_Contract();\\n    }\\n    feth = IFethMarket(_feth);\\n  }\\n\\n  /**\\n   * @notice Only used by FETH. Any direct transfer from users will revert.\\n   */\\n  receive() external payable {\\n    if (msg.sender != address(feth)) {\\n      revert NFTMarketCore_Only_FETH_Can_Transfer_ETH();\\n    }\\n  }\\n\\n  /**\\n   * @notice If there is a buy price at this amount or lower, accept that and return true.\\n   */\\n  function _autoAcceptBuyPrice(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 amount\\n  ) internal virtual returns (bool);\\n\\n  /**\\n   * @notice If there is a valid offer at the given price or higher, accept that and return true.\\n   */\\n  function _autoAcceptOffer(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 minAmount\\n  ) internal virtual returns (bool);\\n\\n  /**\\n   * @notice Notify implementors when an auction has received its first bid.\\n   * Once a bid is received the sale is guaranteed to the auction winner\\n   * and other sale mechanisms become unavailable.\\n   * @dev Implementors of this interface should update internal state to reflect an auction has been kicked off.\\n   */\\n  function _beforeAuctionStarted(\\n    address, /*nftContract*/\\n    uint256 /*tokenId*/ // solhint-disable-next-line no-empty-blocks\\n  ) internal virtual {\\n    // No-op\\n  }\\n\\n  /**\\n   * @notice Cancel the `msg.sender`'s offer if there is one, freeing up their FETH balance.\\n   * @dev This should be used when it does not make sense to keep the original offer around,\\n   * e.g. if a collector accepts a Buy Price then keeping the offer around is not necessary.\\n   */\\n  function _cancelSendersOffer(address nftContract, uint256 tokenId) internal virtual;\\n\\n  /**\\n   * @notice Transfers the NFT from escrow and clears any state tracking this escrowed NFT.\\n   * @param authorizeSeller The address of the seller pending authorization.\\n   * Once it's been authorized by one of the escrow managers, it should be set to address(0)\\n   * indicated that it's no longer pending authorization.\\n   */\\n  function _transferFromEscrow(\\n    address nftContract,\\n    uint256 tokenId,\\n    address recipient,\\n    address authorizeSeller\\n  ) internal virtual {\\n    if (authorizeSeller != address(0)) {\\n      revert NFTMarketCore_Seller_Not_Found();\\n    }\\n    IERC721(nftContract).transferFrom(address(this), recipient, tokenId);\\n  }\\n\\n  /**\\n   * @notice Transfers the NFT from escrow unless there is another reason for it to remain in escrow.\\n   */\\n  function _transferFromEscrowIfAvailable(\\n    address nftContract,\\n    uint256 tokenId,\\n    address recipient\\n  ) internal virtual {\\n    IERC721(nftContract).transferFrom(address(this), recipient, tokenId);\\n  }\\n\\n  /**\\n   * @notice Transfers an NFT into escrow,\\n   * if already there this requires the msg.sender is authorized to manage the sale of this NFT.\\n   */\\n  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual {\\n    IERC721(nftContract).transferFrom(msg.sender, address(this), tokenId);\\n  }\\n\\n  /**\\n   * @notice Gets the FETH contract used to escrow offer funds.\\n   * @return fethAddress The FETH contract address.\\n   */\\n  function getFethAddress() external view returns (address fethAddress) {\\n    fethAddress = address(feth);\\n  }\\n\\n  /**\\n   * @dev Determines the minimum amount when increasing an existing offer or bid.\\n   */\\n  function _getMinIncrement(uint256 currentAmount) internal pure returns (uint256) {\\n    uint256 minIncrement = currentAmount;\\n    unchecked {\\n      minIncrement /= MIN_PERCENT_INCREMENT_DENOMINATOR;\\n    }\\n    if (minIncrement == 0) {\\n      // Since minIncrement reduces from the currentAmount, this cannot overflow.\\n      // The next amount must be at least 1 wei greater than the current.\\n      return currentAmount + 1;\\n    }\\n\\n    return minIncrement + currentAmount;\\n  }\\n\\n  /**\\n   * @notice Checks who the seller for an NFT is, checking escrow or return the current owner if not in escrow.\\n   * @dev If the NFT did not have an escrowed seller to return, fall back to return the current owner.\\n   */\\n  function _getSellerFor(address nftContract, uint256 tokenId) internal view virtual returns (address payable seller) {\\n    seller = payable(IERC721(nftContract).ownerOf(tokenId));\\n  }\\n\\n  /**\\n   * @notice Checks if an escrowed NFT is currently in active auction.\\n   * @return Returns false if the auction has ended, even if it has not yet been settled.\\n   */\\n  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view virtual returns (bool);\\n\\n  /**\\n   * @notice This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   * @dev 50 slots were consumed by adding `ReentrancyGuard`.\\n   */\\n  uint256[950] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/NFTMarketCreators.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OZ/ERC165Checker.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"./Constants.sol\\\";\\n\\nimport \\\"../interfaces/IGetFees.sol\\\";\\nimport \\\"../interfaces/IGetRoyalties.sol\\\";\\nimport \\\"../interfaces/IOwnable.sol\\\";\\nimport \\\"../interfaces/IRoyaltyInfo.sol\\\";\\nimport \\\"../interfaces/ITokenCreator.sol\\\";\\nimport \\\"@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol\\\";\\n\\nerror NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();\\n\\n/**\\n * @title A mixin for associating creators to NFTs.\\n * @dev In the future this may store creators directly in order to support NFTs created on a different platform.\\n */\\nabstract contract NFTMarketCreators is\\n  Constants,\\n  ReentrancyGuardUpgradeable // Adding this unused mixin to help with linearization\\n{\\n  using OZERC165Checker for address;\\n\\n  IRoyaltyRegistry private immutable royaltyRegistry;\\n\\n  /**\\n   * @notice Configures the registry allowing for royalty overrides to be defined.\\n   * @param _royaltyRegistry The registry to use for royalty overrides.\\n   */\\n  constructor(address _royaltyRegistry) {\\n    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {\\n      revert NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();\\n    }\\n    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);\\n  }\\n\\n  /**\\n   * @notice Looks up the royalty payment configuration for a given NFT.\\n   * If more than 5 royalty recipients are defined, only the first 5 are sent royalties - the others are ignored.\\n   * The percents distributed will always be normalized to exactly 10%, when multiple recipients are defined\\n   * we use the values returned to determine how much of that 10% each recipient should get.\\n   * @dev This will check various royalty APIs on the NFT and the royalty override\\n   * if one was registered with the royalty registry. This aims to send royalties\\n   * in the manner requested by the NFT owner, regardless of where the NFT was minted.\\n   */\\n  // solhint-disable-next-line code-complexity\\n  function _getCreatorPaymentInfo(address nftContract, uint256 tokenId)\\n    internal\\n    view\\n    returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints)\\n  {\\n    // All NFTs implement 165 so we skip that check, individual interfaces should return false if 165 is not implemented\\n\\n    // 1st priority: ERC-2981\\n    if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {\\n      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\\n        address receiver,\\n        uint256 royaltyAmount\\n      ) {\\n        // Manifold contracts return (address(this), 0) when royalties are not defined\\n        // - so ignore results when the amount is 0\\n        if (royaltyAmount > 0) {\\n          recipients = new address payable[](1);\\n          recipients[0] = payable(receiver);\\n          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined\\n          return (recipients, splitPerRecipientInBasisPoints);\\n        }\\n      } catch // solhint-disable-next-line no-empty-blocks\\n      {\\n        // Fall through\\n      }\\n    }\\n\\n    // 2nd priority: getRoyalties\\n    if (nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {\\n      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\\n        address payable[] memory _recipients,\\n        uint256[] memory recipientBasisPoints\\n      ) {\\n        uint256 recipientLen = _recipients.length;\\n        if (recipientLen != 0 && recipientLen == recipientBasisPoints.length) {\\n          return (_recipients, recipientBasisPoints);\\n        }\\n      } catch // solhint-disable-next-line no-empty-blocks\\n      {\\n        // Fall through\\n      }\\n    }\\n\\n    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.\\n       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */\\n    // The registry requires overrides are not 0 and contracts when set.\\n    // If no override is set, the nftContract address is returned.\\n\\n    try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (\\n      address overrideContract\\n    ) {\\n      if (overrideContract != nftContract) {\\n        nftContract = overrideContract;\\n\\n        // The functions above are repeated here if an override is set.\\n\\n        // 3rd priority: ERC-2981 override\\n        if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {\\n          try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\\n            address receiver,\\n            uint256 /* royaltyAmount */\\n          ) {\\n            recipients = new address payable[](1);\\n            recipients[0] = payable(receiver);\\n            // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined\\n            return (recipients, splitPerRecipientInBasisPoints);\\n          } catch // solhint-disable-next-line no-empty-blocks\\n          {\\n            // Fall through\\n          }\\n        }\\n\\n        // 4th priority: getRoyalties override\\n        if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {\\n          try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\\n            address payable[] memory _recipients,\\n            uint256[] memory recipientBasisPoints\\n          ) {\\n            uint256 recipientLen = _recipients.length;\\n            if (recipientLen != 0 && recipientLen == recipientBasisPoints.length) {\\n              return (_recipients, recipientBasisPoints);\\n            }\\n          } catch // solhint-disable-next-line no-empty-blocks\\n          {\\n            // Fall through\\n          }\\n        }\\n      }\\n    } catch // solhint-disable-next-line no-empty-blocks\\n    {\\n      // Ignore out of gas errors and continue using the nftContract address\\n    }\\n\\n    // 5th priority: getFee* from contract or override\\n    if (nftContract.supportsERC165Interface(type(IGetFees).interfaceId)) {\\n      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\\n        address payable[] memory _recipients\\n      ) {\\n        uint256 recipientLen = _recipients.length;\\n        if (recipientLen != 0) {\\n          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\\n            uint256[] memory recipientBasisPoints\\n          ) {\\n            if (recipientLen == recipientBasisPoints.length) {\\n              return (_recipients, recipientBasisPoints);\\n            }\\n          } catch // solhint-disable-next-line no-empty-blocks\\n          {\\n            // Fall through\\n          }\\n        }\\n      } catch // solhint-disable-next-line no-empty-blocks\\n      {\\n        // Fall through\\n      }\\n    }\\n\\n    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override\\n    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\\n      address payable _creator\\n    ) {\\n      // Only pay the tokenCreator if there wasn't another royalty defined\\n      recipients = new address payable[](1);\\n      recipients[0] = _creator;\\n      // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined\\n      return (recipients, splitPerRecipientInBasisPoints);\\n    } catch // solhint-disable-next-line no-empty-blocks\\n    {\\n      // Fall through\\n    }\\n\\n    // 7th priority: owner from contract or override\\n    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {\\n      // Only pay the owner if there wasn't another royalty defined\\n      recipients = new address payable[](1);\\n      recipients[0] = payable(owner);\\n      // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined\\n      return (recipients, splitPerRecipientInBasisPoints);\\n    } catch // solhint-disable-next-line no-empty-blocks\\n    {\\n      // Fall through\\n    }\\n\\n    // If no valid payment address or creator is found, return 0 recipients\\n  }\\n\\n  /**\\n   * @notice Returns the address of the registry allowing for royalty configuration overrides.\\n   * @return registry The address of the royalty registry contract.\\n   */\\n  function getRoyaltyRegistry() public view returns (address registry) {\\n    return address(royaltyRegistry);\\n  }\\n\\n  /**\\n   * @notice This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   * @dev 500 slots were consumed with the addition of `SendValueWithFallbackWithdraw`.\\n   */\\n  uint256[500] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/NFTMarketFees.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./FoundationTreasuryNode.sol\\\";\\nimport \\\"./SendValueWithFallbackWithdraw.sol\\\";\\n\\n/**\\n * @title A mixin to distribute funds when an NFT is sold.\\n */\\nabstract contract NFTMarketFees is Constants, Initializable, FoundationTreasuryNode, SendValueWithFallbackWithdraw {\\n  /**\\n   * @dev Removing old unused variables in an upgrade safe way. Was:\\n   * uint256 private _primaryFoundationFeeBasisPoints;\\n   * uint256 private _secondaryFoundationFeeBasisPoints;\\n   * uint256 private _secondaryCreatorFeeBasisPoints;\\n   * mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;\\n   */\\n  uint256[4] private __gap_was_fees;\\n\\n  /// @notice The royalties sent to creator recipients on secondary sales.\\n  uint256 private constant CREATOR_ROYALTY_DENOMINATOR = BASIS_POINTS / 1000; // 10%\\n  /// @notice The fee collected by Foundation for sales facilitated by this market contract.\\n  uint256 private constant PROTOCOL_FEE_DENOMINATOR = BASIS_POINTS / 500; // 5%\\n  /// @notice The fee collected by the referrer for sales facilitated by this market contract.\\n  ///         This fee is deducted from the foundation fee (PROTOCOL_FEE_DENOMINATOR).\\n  uint256 private constant REFERRER_FEE_DENOMINATOR = BASIS_POINTS / 100; // 1% == 20% of FND Fee.\\n\\n  /**\\n   * @notice Emitted when a NFT sold with a referrer.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @param buyReferrer The account which received the buy referral incentive.\\n   * @param buyReferrerProtocolFee The portion of the protocol fee collected by the buy referrer.\\n   * @param buyReferrerSellerFee The portion of the owner revenue collected by the buy referrer (not implemented).\\n   * @param sellReferrer The account which received the sell referral incentive (not implemented).\\n   * @param sellReferrerProtocolFee The portion of the protocol fee collected by the sell referrer (not implemented).\\n   */\\n  event ReferralPaid(\\n    address indexed nftContract,\\n    uint256 indexed tokenId,\\n    address buyReferrer,\\n    uint256 buyReferrerProtocolFee,\\n    uint256 buyReferrerSellerFee,\\n    address sellReferrer,\\n    uint256 sellReferrerProtocolFee\\n  );\\n\\n  /**\\n   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.\\n   */\\n  // solhint-disable-next-line code-complexity\\n  function _distributeFunds(\\n    address nftContract,\\n    uint256 tokenId,\\n    address payable seller,\\n    uint256 price,\\n    address payable buyReferrer\\n  )\\n    internal\\n    returns (\\n      uint256 protocolFee,\\n      uint256 creatorFee,\\n      uint256 sellerRev\\n    )\\n  {\\n    address payable[] memory creatorRecipients;\\n    uint256[] memory creatorShares;\\n\\n    address payable sellerRevTo;\\n    uint256 buyReferrerProtocolFee;\\n    (\\n      protocolFee,\\n      creatorRecipients,\\n      creatorShares,\\n      creatorFee,\\n      sellerRevTo,\\n      sellerRev,\\n      buyReferrerProtocolFee\\n    ) = _getFees(nftContract, tokenId, seller, price, buyReferrer);\\n\\n    if (buyReferrerProtocolFee != 0) {\\n      // Use standard `send` to cap the gas and prevent consuming all available\\n      // gas to block a tx from completing successfully.\\n      // Fallsback to sending the referral fee to FND on failure.\\n      if (buyReferrer.send(buyReferrerProtocolFee)) {\\n        emit ReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerProtocolFee, 0, address(0), 0);\\n      } else {\\n        // If we are unable to pay the referrer than the money is returned to the original protocolFee.\\n        unchecked {\\n          protocolFee += buyReferrerProtocolFee;\\n          buyReferrerProtocolFee = 0;\\n        }\\n      }\\n    }\\n\\n    _sendValueWithFallbackWithdraw(getFoundationTreasury(), protocolFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\\n\\n    // Keep the full fee total in protocolFee for backwards compat with events so that sum of params == sale amount.\\n    unchecked {\\n      protocolFee += buyReferrerProtocolFee;\\n    }\\n\\n    if (creatorFee != 0) {\\n      if (creatorRecipients.length > 1) {\\n        uint256 maxCreatorIndex = creatorRecipients.length;\\n        unchecked {\\n          // maxCreatorIndex cannot underflow due to the if above\\n          --maxCreatorIndex;\\n        }\\n\\n        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {\\n          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;\\n        }\\n\\n        // Determine the total shares defined so it can be leveraged to distribute below\\n        uint256 totalShares;\\n        unchecked {\\n          // The array length cannot overflow 256 bits.\\n          for (uint256 i = 0; i <= maxCreatorIndex; ++i) {\\n            if (creatorShares[i] > BASIS_POINTS) {\\n              // If the numbers are >100% we ignore the fee recipients and pay just the first instead\\n              maxCreatorIndex = 0;\\n              break;\\n            }\\n            // The check above ensures totalShares wont overflow.\\n            totalShares += creatorShares[i];\\n          }\\n        }\\n        if (totalShares == 0) {\\n          maxCreatorIndex = 0;\\n        }\\n\\n        // Send payouts to each additional recipient if more than 1 was defined\\n        uint256 totalRoyaltiesDistributed;\\n        for (uint256 i = 1; i <= maxCreatorIndex; ) {\\n          uint256 royalty = (creatorFee * creatorShares[i]) / totalShares;\\n          totalRoyaltiesDistributed += royalty;\\n          _sendValueWithFallbackWithdraw(creatorRecipients[i], royalty, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);\\n          unchecked {\\n            ++i;\\n          }\\n        }\\n\\n        // Send the remainder to the 1st creator, rounding in their favor\\n        _sendValueWithFallbackWithdraw(\\n          creatorRecipients[0],\\n          creatorFee - totalRoyaltiesDistributed,\\n          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS\\n        );\\n      } else {\\n        _sendValueWithFallbackWithdraw(creatorRecipients[0], creatorFee, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);\\n      }\\n    }\\n    _sendValueWithFallbackWithdraw(sellerRevTo, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\\n  }\\n\\n  /**\\n   * @notice Returns how funds will be distributed for a sale at the given price point.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @param price The sale price to calculate the fees for.\\n   * @return protocolFee How much will be sent to the Foundation treasury.\\n   * @return creatorRev How much will be sent across all the `creatorRecipients` defined.\\n   * @return creatorRecipients The addresses of the recipients to receive a portion of the creator fee.\\n   * @return creatorShares The percentage of the creator fee to be distributed to each `creatorRecipient`.\\n   * If there is only one `creatorRecipient`, this may be an empty array.\\n   * Otherwise `creatorShares.length` == `creatorRecipients.length`.\\n   * @return sellerRev How much will be sent to the owner/seller of the NFT.\\n   * If the NFT is being sold by the creator, this may be 0 and the full revenue will appear as `creatorRev`.\\n   * @return owner The address of the owner of the NFT.\\n   * If `sellerRev` is 0, this may be `address(0)`.\\n   */\\n  function getFeesAndRecipients(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 price\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 protocolFee,\\n      uint256 creatorRev,\\n      address payable[] memory creatorRecipients,\\n      uint256[] memory creatorShares,\\n      uint256 sellerRev,\\n      address payable owner\\n    )\\n  {\\n    address payable seller = _getSellerFor(nftContract, tokenId);\\n    // foundationProtocolFee == the full protocolFee since no referrers are defined here.\\n    (protocolFee, creatorRecipients, creatorShares, creatorRev, owner, sellerRev, ) = _getFees(\\n      nftContract,\\n      tokenId,\\n      seller,\\n      price,\\n      address(0)\\n    );\\n  }\\n\\n  /**\\n   * @notice Calculates how funds should be distributed for the given sale details.\\n   * @dev When the NFT is being sold by the `tokenCreator`, all the seller revenue will\\n   * be split with the royalty recipients defined for that NFT.\\n   */\\n  function _getFees(\\n    address nftContract,\\n    uint256 tokenId,\\n    address payable seller,\\n    uint256 price,\\n    address buyReferrer\\n  )\\n    private\\n    view\\n    returns (\\n      uint256 foundationProtocolFee,\\n      address payable[] memory creatorRecipients,\\n      uint256[] memory creatorShares,\\n      uint256 creatorRev,\\n      address payable sellerRevTo,\\n      uint256 sellerRev,\\n      uint256 buyReferrerProtocolFee\\n    )\\n  {\\n    address creator;\\n    // lookup for tokenCreator\\n    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\\n      address payable _creator\\n    ) {\\n      creator = _creator;\\n    } catch // solhint-disable-next-line no-empty-blocks\\n    {\\n      // Fall through\\n    }\\n\\n    (creatorRecipients, creatorShares) = _getCreatorPaymentInfo(nftContract, tokenId);\\n\\n    // Calculate the Foundation fee\\n    unchecked {\\n      // SafeMath is not required when dividing by a non-zero constant.\\n      foundationProtocolFee = price / PROTOCOL_FEE_DENOMINATOR;\\n    }\\n\\n    if (creatorRecipients.length != 0) {\\n      if (seller == creator || (creatorRecipients.length == 1 && seller == creatorRecipients[0])) {\\n        // When sold by the creator, all revenue is split if applicable.\\n        unchecked {\\n          // protocolFee is always < price.\\n          creatorRev = price - foundationProtocolFee;\\n        }\\n      } else {\\n        // Rounding favors the owner first, then creator, and foundation last.\\n        unchecked {\\n          // SafeMath is not required when dividing by a non-zero constant.\\n          creatorRev = price / CREATOR_ROYALTY_DENOMINATOR;\\n        }\\n        sellerRevTo = seller;\\n        sellerRev = price - foundationProtocolFee - creatorRev;\\n      }\\n    } else {\\n      // No royalty recipients found.\\n      sellerRevTo = seller;\\n      unchecked {\\n        // protocolFee is always < price.\\n        sellerRev = price - foundationProtocolFee;\\n      }\\n    }\\n\\n    // Calculate the buy referrer fee if defined and not a party that already has a vested interest in this sale.\\n    // This is done after the sellerRev calculations as a simplification (using the full protocol fee above).\\n    if (buyReferrer != address(0) && buyReferrer != msg.sender && buyReferrer != seller && buyReferrer != creator) {\\n      buyReferrerProtocolFee = price / REFERRER_FEE_DENOMINATOR;\\n      foundationProtocolFee -= buyReferrerProtocolFee;\\n    }\\n  }\\n\\n  /**\\n   * @notice This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[1000] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/NFTMarketOffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"./FoundationTreasuryNode.sol\\\";\\nimport \\\"./NFTMarketCore.sol\\\";\\nimport \\\"./NFTMarketFees.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nerror NFTMarketOffer_Cannot_Be_Made_While_In_Auction();\\n/// @param currentOfferAmount The current highest offer available for this NFT.\\nerror NFTMarketOffer_Offer_Below_Min_Amount(uint256 currentOfferAmount);\\n/// @param expiry The time at which the offer had expired.\\nerror NFTMarketOffer_Offer_Expired(uint256 expiry);\\n/// @param currentOfferFrom The address of the collector which has made the current highest offer.\\nerror NFTMarketOffer_Offer_From_Does_Not_Match(address currentOfferFrom);\\n/// @param minOfferAmount The minimum amount that must be offered in order for it to be accepted.\\nerror NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(uint256 minOfferAmount);\\nerror NFTMarketOffer_Reason_Required();\\nerror NFTMarketOffer_Provided_Contract_And_TokenId_Count_Must_Match();\\n\\n/**\\n * @title Allows collectors to make an offer for an NFT, valid for 24-25 hours.\\n * @notice Funds are escrowed in the FETH ERC-20 token contract.\\n */\\nabstract contract NFTMarketOffer is FoundationTreasuryNode, NFTMarketCore, ReentrancyGuardUpgradeable, NFTMarketFees {\\n  using AddressUpgradeable for address;\\n\\n  /// @notice Stores offer details for a specific NFT.\\n  struct Offer {\\n    // Slot 1: When increasing an offer, only this slot is updated.\\n    /// @notice The expiration timestamp of when this offer expires.\\n    uint32 expiration;\\n    /// @notice The amount, in wei, of the highest offer.\\n    uint96 amount;\\n    // 128 bits are available in slot 1\\n\\n    // Slot 2: When the buyer changes, both slots need updating\\n    /// @notice The address of the collector who made this offer.\\n    address buyer;\\n  }\\n\\n  /// @notice Stores the highest offer for each NFT.\\n  mapping(address => mapping(uint256 => Offer)) private nftContractToIdToOffer;\\n\\n  /**\\n   * @notice Emitted when an offer is accepted,\\n   * indicating that the NFT has been transferred and revenue from the sale distributed.\\n   * @dev The accepted total offer amount is `protocolFee` + `creatorFee` + `sellerRev`.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @param buyer The address of the collector that made the offer which was accepted.\\n   * @param seller The address of the seller which accepted the offer.\\n   * @param protocolFee The amount of ETH that was sent to Foundation for this sale.\\n   * @param creatorFee The amount of ETH that was sent to the creator for this sale.\\n   * @param sellerRev The amount of ETH that was sent to the owner for this sale.\\n   */\\n  event OfferAccepted(\\n    address indexed nftContract,\\n    uint256 indexed tokenId,\\n    address indexed buyer,\\n    address seller,\\n    uint256 protocolFee,\\n    uint256 creatorFee,\\n    uint256 sellerRev\\n  );\\n  /**\\n   * @notice Emitted when an offer is canceled by a Foundation admin.\\n   * @dev This should only be used for extreme cases such as DMCA takedown requests.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @param reason The reason for the cancellation (a required field).\\n   */\\n  event OfferCanceledByAdmin(address indexed nftContract, uint256 indexed tokenId, string reason);\\n  /**\\n   * @notice Emitted when an offer is invalidated due to other market activity.\\n   * When this occurs, the collector which made the offer has their FETH balance unlocked\\n   * and the funds are available to place other offers or to be withdrawn.\\n   * @dev This occurs when the offer is no longer eligible to be accepted,\\n   * e.g. when a bid is placed in an auction for this NFT.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   */\\n  event OfferInvalidated(address indexed nftContract, uint256 indexed tokenId);\\n  /**\\n   * @notice Emitted when an offer is made.\\n   * @dev The `amount` of the offer is locked in the FETH ERC-20 contract, guaranteeing that the funds\\n   * remain available until the `expiration` date.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @param buyer The address of the collector that made the offer to buy this NFT.\\n   * @param amount The amount, in wei, of the offer.\\n   * @param expiration The expiration timestamp for the offer.\\n   */\\n  event OfferMade(\\n    address indexed nftContract,\\n    uint256 indexed tokenId,\\n    address indexed buyer,\\n    uint256 amount,\\n    uint256 expiration\\n  );\\n\\n  /**\\n   * @notice Accept the highest offer for an NFT.\\n   * @dev The offer must not be expired and the NFT owned + approved by the seller or\\n   * available in the market contract's escrow.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @param offerFrom The address of the collector that you wish to sell to.\\n   * If the current highest offer is not from this user, the transaction will revert.\\n   * This could happen if a last minute offer was made by another collector,\\n   * and would require the seller to try accepting again.\\n   * @param minAmount The minimum value of the highest offer for it to be accepted.\\n   * If the value is less than this amount, the transaction will revert.\\n   * This could happen if the original offer expires and is replaced with a smaller offer.\\n   */\\n  function acceptOffer(\\n    address nftContract,\\n    uint256 tokenId,\\n    address offerFrom,\\n    uint256 minAmount\\n  ) external nonReentrant {\\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\\n    // Validate offer expiry and amount\\n    if (offer.expiration < block.timestamp) {\\n      revert NFTMarketOffer_Offer_Expired(offer.expiration);\\n    } else if (offer.amount < minAmount) {\\n      revert NFTMarketOffer_Offer_Below_Min_Amount(offer.amount);\\n    }\\n    // Validate the buyer\\n    if (offer.buyer != offerFrom) {\\n      revert NFTMarketOffer_Offer_From_Does_Not_Match(offer.buyer);\\n    }\\n\\n    _acceptOffer(nftContract, tokenId);\\n  }\\n\\n  /**\\n   * @notice Allows Foundation to cancel offers.\\n   * This will unlock the funds in the FETH ERC-20 contract for the highest offer\\n   * and prevent the offer from being accepted.\\n   * @dev This should only be used for extreme cases such as DMCA takedown requests.\\n   * @param nftContracts The addresses of the NFT contracts to cancel. This must be the same length as `tokenIds`.\\n   * @param tokenIds The ids of the NFTs to cancel. This must be the same length as `nftContracts`.\\n   * @param reason The reason for the cancellation (a required field).\\n   */\\n  function adminCancelOffers(\\n    address[] calldata nftContracts,\\n    uint256[] calldata tokenIds,\\n    string calldata reason\\n  ) external onlyFoundationAdmin nonReentrant {\\n    if (bytes(reason).length == 0) {\\n      revert NFTMarketOffer_Reason_Required();\\n    }\\n    if (nftContracts.length != tokenIds.length) {\\n      revert NFTMarketOffer_Provided_Contract_And_TokenId_Count_Must_Match();\\n    }\\n\\n    // The array length cannot overflow 256 bits\\n    unchecked {\\n      for (uint256 i = 0; i < nftContracts.length; ++i) {\\n        Offer memory offer = nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];\\n        delete nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];\\n\\n        if (offer.expiration >= block.timestamp) {\\n          // Unlock from escrow and emit an event only if the offer is still active\\n          feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);\\n          emit OfferCanceledByAdmin(nftContracts[i], tokenIds[i], reason);\\n        }\\n        // Else continue on so the rest of the batch transaction can process successfully\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Make an offer for any NFT which is valid for 24-25 hours.\\n   * The funds will be locked in the FETH token contract and become available once the offer is outbid or has expired.\\n   * @dev An offer may be made for an NFT before it is minted, although we generally not recommend you do that.\\n   * If there is a buy price set at this price or lower, that will be accepted instead of making an offer.\\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @param amount The amount to offer for this NFT.\\n   * @return expiration The timestamp for when this offer will expire.\\n   * This is provided as a return value in case another contract would like to leverage this information,\\n   * user's should refer to the expiration in the `OfferMade` event log.\\n   * If the buy price is accepted instead, `0` is returned as the expiration since that's n/a.\\n   */\\n  function makeOffer(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 amount\\n  ) external payable returns (uint256 expiration) {\\n    // If there is a buy price set at this price or lower, accept that instead.\\n    if (_autoAcceptBuyPrice(nftContract, tokenId, amount)) {\\n      // If the buy price is accepted, `0` is returned as the expiration since that's n/a.\\n      return 0;\\n    }\\n\\n    if (_isInActiveAuction(nftContract, tokenId)) {\\n      revert NFTMarketOffer_Cannot_Be_Made_While_In_Auction();\\n    }\\n\\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\\n\\n    if (offer.expiration < block.timestamp) {\\n      // This is a new offer for the NFT (no other offer found or the previous offer expired)\\n\\n      // Lock the offer amount in FETH until the offer expires in 24-25 hours.\\n      expiration = feth.marketLockupFor{ value: msg.value }(msg.sender, amount);\\n    } else {\\n      // A previous offer exists and has not expired\\n\\n      uint256 minIncrement = _getMinIncrement(offer.amount);\\n      if (amount < minIncrement) {\\n        // A non-trivial increase in price is required to avoid sniping\\n        revert NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(minIncrement);\\n      }\\n\\n      // Unlock the previous offer so that the FETH tokens are available for other offers or to transfer / withdraw\\n      // and lock the new offer amount in FETH until the offer expires in 24-25 hours.\\n      expiration = feth.marketChangeLockup{ value: msg.value }(\\n        offer.buyer,\\n        offer.expiration,\\n        offer.amount,\\n        msg.sender,\\n        amount\\n      );\\n    }\\n\\n    // Record offer details\\n    offer.buyer = msg.sender;\\n    // The FETH contract guarantees that the expiration fits into 32 bits.\\n    offer.expiration = uint32(expiration);\\n    // `amount` is capped by the ETH provided, which cannot realistically overflow 96 bits.\\n    offer.amount = uint96(amount);\\n\\n    emit OfferMade(nftContract, tokenId, msg.sender, amount, expiration);\\n  }\\n\\n  /**\\n   * @notice Accept the highest offer for an NFT from the `msg.sender` account.\\n   * The NFT will be transferred to the buyer and revenue from the sale will be distributed.\\n   * @dev The caller must validate the expiry and amount before calling this helper.\\n   * This may invalidate other market tools, such as clearing the buy price if set.\\n   */\\n  function _acceptOffer(address nftContract, uint256 tokenId) private {\\n    Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];\\n\\n    // Remove offer\\n    delete nftContractToIdToOffer[nftContract][tokenId];\\n    // Withdraw ETH from the buyer's account in the FETH token contract.\\n    feth.marketWithdrawLocked(offer.buyer, offer.expiration, offer.amount);\\n\\n    // Transfer the NFT to the buyer.\\n    try\\n      IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId) // solhint-disable-next-line no-empty-blocks\\n    {\\n      // NFT was in the seller's wallet so the transfer is complete.\\n    } catch {\\n      // If the transfer fails then attempt to transfer from escrow instead.\\n      // This should revert if `msg.sender` is not the owner of this NFT.\\n      _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender);\\n    }\\n\\n    // Distribute revenue for this sale leveraging the ETH received from the FETH contract in the line above.\\n    (uint256 protocolFee, uint256 creatorFee, uint256 sellerRev) = _distributeFunds(\\n      nftContract,\\n      tokenId,\\n      payable(msg.sender),\\n      offer.amount,\\n      payable(0)\\n    );\\n\\n    emit OfferAccepted(nftContract, tokenId, offer.buyer, msg.sender, protocolFee, creatorFee, sellerRev);\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   * @dev Invalidates the highest offer when an auction is kicked off, if one is found.\\n   */\\n  function _beforeAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {\\n    _invalidateOffer(nftContract, tokenId);\\n    super._beforeAuctionStarted(nftContract, tokenId);\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   */\\n  function _autoAcceptOffer(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 minAmount\\n  ) internal override returns (bool) {\\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\\n    if (offer.expiration < block.timestamp || offer.amount < minAmount) {\\n      // No offer found, the most recent offer is now expired, or the highest offer is below the minimum amount.\\n      return false;\\n    }\\n\\n    _acceptOffer(nftContract, tokenId);\\n    return true;\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   */\\n  function _cancelSendersOffer(address nftContract, uint256 tokenId) internal override {\\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\\n    if (offer.buyer == msg.sender) {\\n      _invalidateOffer(nftContract, tokenId);\\n    }\\n  }\\n\\n  /**\\n   * @notice Invalidates the offer and frees ETH from escrow, if the offer has not already expired.\\n   * @dev Offers are not invalidated when the NFT is purchased by accepting the buy price unless it\\n   * was purchased by the same user.\\n   * The user which just purchased the NFT may have buyer's remorse and promptly decide they want a fast exit,\\n   * accepting a small loss to limit their exposure.\\n   */\\n  function _invalidateOffer(address nftContract, uint256 tokenId) private {\\n    if (nftContractToIdToOffer[nftContract][tokenId].expiration >= block.timestamp) {\\n      // An offer was found and it has not already expired\\n      Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];\\n\\n      // Remove offer\\n      delete nftContractToIdToOffer[nftContract][tokenId];\\n\\n      // Unlock the offer so that the FETH tokens are available for other offers or to transfer / withdraw\\n      feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);\\n\\n      emit OfferInvalidated(nftContract, tokenId);\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns the minimum amount a collector must offer for this NFT in order for the offer to be valid.\\n   * @dev Offers for this NFT which are less than this value will revert.\\n   * Once the previous offer has expired smaller offers can be made.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @return minimum The minimum amount that must be offered for this NFT.\\n   */\\n  function getMinOfferAmount(address nftContract, uint256 tokenId) external view returns (uint256 minimum) {\\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\\n    if (offer.expiration >= block.timestamp) {\\n      return _getMinIncrement(offer.amount);\\n    }\\n    // Absolute min is anything > 0\\n    return 1;\\n  }\\n\\n  /**\\n   * @notice Returns details about the current highest offer for an NFT.\\n   * @dev Default values are returned if there is no offer or the offer has expired.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @return buyer The address of the buyer that made the current highest offer.\\n   * Returns `address(0)` if there is no offer or the most recent offer has expired.\\n   * @return expiration The timestamp that the current highest offer expires.\\n   * Returns `0` if there is no offer or the most recent offer has expired.\\n   * @return amount The amount being offered for this NFT.\\n   * Returns `0` if there is no offer or the most recent offer has expired.\\n   */\\n  function getOffer(address nftContract, uint256 tokenId)\\n    external\\n    view\\n    returns (\\n      address buyer,\\n      uint256 expiration,\\n      uint256 amount\\n    )\\n  {\\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\\n    if (offer.expiration < block.timestamp) {\\n      // Offer not found or has expired\\n      return (address(0), 0, 0);\\n    }\\n\\n    // An offer was found and it has not yet expired.\\n    return (offer.buyer, offer.expiration, offer.amount);\\n  }\\n\\n  /**\\n   * @notice This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[1000] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/NFTMarketPrivateSale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\nimport \\\"./NFTMarketFees.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nerror NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();\\nerror NFTMarketPrivateSale_Signature_Canceled_Or_Already_Claimed();\\nerror NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();\\nerror NFTMarketPrivateSale_Sale_Expired();\\nerror NFTMarketPrivateSale_Signature_Verification_Failed();\\nerror NFTMarketPrivateSale_Too_Much_Value_Provided();\\n\\n/**\\n * @title Allows owners to offer an NFT for sale to a specific collector.\\n * @notice Private sales are authorized by the seller with an EIP-712 signature.\\n * @dev Private sale offers must be accepted by the buyer before they expire, typically in 24 hours.\\n */\\nabstract contract NFTMarketPrivateSale is NFTMarketFees {\\n  using AddressUpgradeable for address;\\n  using ECDSA for bytes32;\\n\\n  /// @dev This value was replaced with an immutable version.\\n  bytes32 private __gap_was_DOMAIN_SEPARATOR;\\n\\n  /// @notice Tracks if a private sale has already been used.\\n  /// @dev Maps nftContract -> tokenId -> buyer -> seller -> amount -> deadline -> invalidated.\\n  // solhint-disable-next-line max-line-length\\n  mapping(address => mapping(uint256 => mapping(address => mapping(address => mapping(uint256 => mapping(uint256 => bool))))))\\n    private privateSaleInvalidated;\\n\\n  /// @notice The domain used in EIP-712 signatures.\\n  /// @dev It is not a constant so that the chainId can be determined dynamically.\\n  /// If multiple classes use EIP-712 signatures in the future this can move to a shared file.\\n  bytes32 private immutable DOMAIN_SEPARATOR;\\n\\n  /// @notice The hash of the private sale method signature used for EIP-712 signatures.\\n  bytes32 private constant BUY_FROM_PRIVATE_SALE_TYPEHASH =\\n    keccak256(\\\"BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)\\\");\\n  /// @notice The name used in the EIP-712 domain.\\n  /// @dev If multiple classes use EIP-712 signatures in the future this can move to the shared constants file.\\n  string private constant NAME = \\\"FNDNFTMarket\\\";\\n\\n  /**\\n   * @notice Emitted when an NFT is sold in a private sale.\\n   * @dev The total amount of this sale is `protocolFee` + `creatorFee` + `sellerRev`.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The ID of the NFT.\\n   * @param seller The address of the seller.\\n   * @param buyer The address of the buyer.\\n   * @param protocolFee The amount of ETH that was sent to Foundation for this sale.\\n   * @param creatorFee The amount of ETH that was sent to the creator for this sale.\\n   * @param sellerRev The amount of ETH that was sent to the owner for this sale.\\n   * @param deadline When the private sale offer was set to expire.\\n   */\\n  event PrivateSaleFinalized(\\n    address indexed nftContract,\\n    uint256 indexed tokenId,\\n    address indexed seller,\\n    address buyer,\\n    uint256 protocolFee,\\n    uint256 creatorFee,\\n    uint256 sellerRev,\\n    uint256 deadline\\n  );\\n\\n  /**\\n   * @notice Configures the contract to accept EIP-712 signatures.\\n   * @param marketProxyAddress The address of the proxy contract which will be called when accepting a private sale.\\n   */\\n  constructor(address marketProxyAddress) {\\n    if (!marketProxyAddress.isContract()) {\\n      revert NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();\\n    }\\n    DOMAIN_SEPARATOR = keccak256(\\n      abi.encode(\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n        keccak256(bytes(NAME)),\\n        // Incrementing the version can be used to invalidate previously signed messages.\\n        keccak256(bytes(\\\"1\\\")),\\n        block.chainid,\\n        marketProxyAddress\\n      )\\n    );\\n  }\\n\\n  /**\\n   * @notice Buy an NFT from a private sale.\\n   * @dev This API is deprecated and will be removed in the future, `buyFromPrivateSaleFor` should be used instead.\\n   * The seller signs a message approving the sale and then the buyer calls this function\\n   * with the `msg.value` equal to the agreed upon price.\\n   * If the seller is no longer the `ownerOf` this NFT or has removed approval for this contract,\\n   * attempts to purchase from private sale will revert.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The ID of the NFT.\\n   * @param deadline The timestamp at which the offer to sell will expire.\\n   * @param v The v value of the EIP-712 signature.\\n   * @param r The r value of the EIP-712 signature.\\n   * @param s The s value of the EIP-712 signature.\\n   */\\n  function buyFromPrivateSale(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external payable {\\n    buyFromPrivateSaleFor(nftContract, tokenId, msg.value, deadline, v, r, s);\\n  }\\n\\n  /**\\n   * @notice Buy an NFT from a private sale.\\n   * @dev The seller signs a message approving the sale and then the buyer calls this function\\n   * with the `amount` equal to the agreed upon price.\\n   * If the seller is no longer the `ownerOf` this NFT or has removed approval for this contract,\\n   * attempts to purchase from private sale will revert.\\n   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The ID of the NFT.\\n   * @param amount The amount to buy for, if this is more than `msg.value` funds will be\\n   * withdrawn from your FETH balance.\\n   * @param deadline The timestamp at which the offer to sell will expire.\\n   * @param v The v value of the EIP-712 signature.\\n   * @param r The r value of the EIP-712 signature.\\n   * @param s The s value of the EIP-712 signature.\\n   */\\n  function buyFromPrivateSaleFor(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) public payable nonReentrant {\\n    // now + 2 days cannot overflow\\n    unchecked {\\n      if (deadline < block.timestamp) {\\n        // The signed message from the seller has expired.\\n        revert NFTMarketPrivateSale_Sale_Expired();\\n      } else if (deadline > block.timestamp + 2 days) {\\n        // Private sales typically expire in 24 hours, but 2 days is used here in order to ensure\\n        // that transactions do not fail due to a minor timezone error or similar during signing.\\n\\n        // This prevents malicious actors from requesting signatures that never expire.\\n        revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();\\n      }\\n    }\\n\\n    // Cancel the buyer's offer if there is one in order to free up their FETH balance\\n    // even if they don't need the FETH for this specific purchase.\\n    _cancelSendersOffer(address(nftContract), tokenId);\\n\\n    if (amount > msg.value) {\\n      // Withdraw additional ETH required from their available FETH balance.\\n\\n      unchecked {\\n        // The if above ensures delta will not underflow\\n        feth.marketWithdrawFrom(msg.sender, amount - msg.value);\\n      }\\n    } else if (amount < msg.value) {\\n      // The terms of the sale cannot change, so if too much ETH is sent then something went wrong.\\n      revert NFTMarketPrivateSale_Too_Much_Value_Provided();\\n    }\\n\\n    // The seller must have the NFT in their wallet when this function is called,\\n    // otherwise the signature verification below will fail.\\n    address payable seller = payable(IERC721(nftContract).ownerOf(tokenId));\\n\\n    // Ensure that the offer can only be accepted once.\\n    if (privateSaleInvalidated[nftContract][tokenId][msg.sender][seller][amount][deadline]) {\\n      revert NFTMarketPrivateSale_Signature_Canceled_Or_Already_Claimed();\\n    }\\n    privateSaleInvalidated[nftContract][tokenId][msg.sender][seller][amount][deadline] = true;\\n\\n    // Scoping this block to avoid a stack too deep error\\n    {\\n      bytes32 digest = keccak256(\\n        abi.encodePacked(\\n          \\\"\\\\x19\\\\x01\\\",\\n          DOMAIN_SEPARATOR,\\n          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))\\n        )\\n      );\\n\\n      // Revert if the signature is invalid, the terms are not as expected, or if the seller transferred the NFT.\\n      if (digest.recover(v, r, s) != seller) {\\n        revert NFTMarketPrivateSale_Signature_Verification_Failed();\\n      }\\n    }\\n\\n    // This should revert if the seller has not given the market contract approval.\\n    IERC721(nftContract).transferFrom(seller, msg.sender, tokenId);\\n\\n    // Distribute revenue for this sale.\\n    (uint256 protocolFee, uint256 creatorFee, uint256 sellerRev) = _distributeFunds(\\n      nftContract,\\n      tokenId,\\n      seller,\\n      amount,\\n      payable(address(0))\\n    );\\n\\n    emit PrivateSaleFinalized(nftContract, tokenId, seller, msg.sender, protocolFee, creatorFee, sellerRev, deadline);\\n  }\\n\\n  /**\\n   * @notice This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   * @dev 1 slot was consumed by privateSaleInvalidated.\\n   */\\n  uint256[999] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/NFTMarketReserveAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./FoundationTreasuryNode.sol\\\";\\nimport \\\"./NFTMarketAuction.sol\\\";\\nimport \\\"./NFTMarketCore.sol\\\";\\nimport \\\"./NFTMarketFees.sol\\\";\\nimport \\\"./SendValueWithFallbackWithdraw.sol\\\";\\n\\n/// @param auctionId The already listed auctionId for this NFT.\\nerror NFTMarketReserveAuction_Already_Listed(uint256 auctionId);\\n/// @param minAmount The minimum amount that must be bid in order for it to be accepted.\\nerror NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);\\nerror NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();\\n/// @param reservePrice The current reserve price.\\nerror NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);\\n/// @param endTime The timestamp at which the auction had ended.\\nerror NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);\\nerror NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();\\nerror NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();\\nerror NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();\\n/// @param endTime The timestamp at which the auction will end.\\nerror NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);\\nerror NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();\\nerror NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\\n/// @param maxDuration The maximum configuration for a duration of the auction, in seconds.\\nerror NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);\\n/// @param extensionDuration The extension duration, in seconds.\\nerror NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);\\nerror NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();\\n/// @param seller The current owner of the NFT.\\nerror NFTMarketReserveAuction_Not_Matching_Seller(address seller);\\n/// @param owner The current owner of the NFT.\\nerror NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);\\nerror NFTMarketReserveAuction_Price_Already_Set();\\nerror NFTMarketReserveAuction_Too_Much_Value_Provided();\\n\\n/**\\n * @title Allows the owner of an NFT to list it in auction.\\n * @notice NFTs in auction are escrowed in the market contract.\\n * @dev There is room to optimize the storage for auctions, significantly reducing gas costs.\\n * This may be done in the future, but for now it will remain as is in order to ease upgrade compatibility.\\n */\\nabstract contract NFTMarketReserveAuction is\\n  Constants,\\n  FoundationTreasuryNode,\\n  NFTMarketCore,\\n  ReentrancyGuardUpgradeable,\\n  SendValueWithFallbackWithdraw,\\n  NFTMarketFees,\\n  NFTMarketAuction\\n{\\n  /// @notice Stores the auction configuration for a specific NFT.\\n  struct ReserveAuction {\\n    /// @notice The address of the NFT contract.\\n    address nftContract;\\n    /// @notice The id of the NFT.\\n    uint256 tokenId;\\n    /// @notice The owner of the NFT which listed it in auction.\\n    address payable seller;\\n    /// @notice The duration for this auction.\\n    uint256 duration;\\n    /// @notice The extension window for this auction.\\n    uint256 extensionDuration;\\n    /// @notice The time at which this auction will not accept any new bids.\\n    /// @dev This is `0` until the first bid is placed.\\n    uint256 endTime;\\n    /// @notice The current highest bidder in this auction.\\n    /// @dev This is `address(0)` until the first bid is placed.\\n    address payable bidder;\\n    /// @notice The latest price of the NFT in this auction.\\n    /// @dev This is set to the reserve price, and then to the highest bid once the auction has started.\\n    uint256 amount;\\n  }\\n\\n  /// @notice The auction configuration for a specific auction id.\\n  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;\\n  /// @notice The auction id for a specific NFT.\\n  /// @dev This is deleted when an auction is finalized or canceled.\\n  mapping(uint256 => ReserveAuction) private auctionIdToAuction;\\n\\n  /**\\n   * @dev Removing old unused variables in an upgrade safe way. Was:\\n   * uint256 private __gap_was_minPercentIncrementInBasisPoints;\\n   * uint256 private __gap_was_maxBidIncrementRequirement;\\n   * uint256 private __gap_was_duration;\\n   * uint256 private __gap_was_extensionDuration;\\n   * uint256 private __gap_was_goLiveDate;\\n   */\\n  uint256[5] private __gap_was_config;\\n\\n  /// @notice How long an auction lasts for once the first bid has been received.\\n  uint256 private immutable DURATION;\\n\\n  /// @notice The window for auction extensions, any bid placed in the final 15 minutes\\n  /// of an auction will reset the time remaining to 15 minutes.\\n  uint256 private constant EXTENSION_DURATION = 15 minutes;\\n\\n  /// @notice Caps the max duration that may be configured so that overflows will not occur.\\n  uint256 private constant MAX_MAX_DURATION = 1000 days;\\n\\n  /**\\n   * @notice Emitted when a bid is placed.\\n   * @param auctionId The id of the auction this bid was for.\\n   * @param bidder The address of the bidder.\\n   * @param amount The amount of the bid.\\n   * @param endTime The new end time of the auction (which may have been set or extended by this bid).\\n   */\\n  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);\\n  /**\\n   * @notice Emitted when an auction is cancelled.\\n   * @dev This is only possible if the auction has not received any bids.\\n   * @param auctionId The id of the auction that was cancelled.\\n   */\\n  event ReserveAuctionCanceled(uint256 indexed auctionId);\\n  /**\\n   * @notice Emitted when an auction is canceled by a Foundation admin.\\n   * @dev When this occurs, the highest bidder (if there was a bid) is automatically refunded.\\n   * @param auctionId The id of the auction that was cancelled.\\n   * @param reason The reason for the cancellation.\\n   */\\n  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);\\n  /**\\n   * @notice Emitted when an NFT is listed for auction.\\n   * @param seller The address of the seller.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @param duration The duration of the auction (always 24-hours).\\n   * @param extensionDuration The duration of the auction extension window (always 15-minutes).\\n   * @param reservePrice The reserve price to kick off the auction.\\n   * @param auctionId The id of the auction that was created.\\n   */\\n  event ReserveAuctionCreated(\\n    address indexed seller,\\n    address indexed nftContract,\\n    uint256 indexed tokenId,\\n    uint256 duration,\\n    uint256 extensionDuration,\\n    uint256 reservePrice,\\n    uint256 auctionId\\n  );\\n  /**\\n   * @notice Emitted when an auction that has already ended is finalized,\\n   * indicating that the NFT has been transferred and revenue from the sale distributed.\\n   * @dev The amount of the highest bid / final sale price for this auction\\n   * is `protocolFee` + `creatorFee` + `sellerRev`.\\n   * @param auctionId The id of the auction that was finalized.\\n   * @param seller The address of the seller.\\n   * @param bidder The address of the highest bidder that won the NFT.\\n   * @param protocolFee The amount of ETH that was sent to Foundation for this sale.\\n   * @param creatorFee The amount of ETH that was sent to the creator for this sale.\\n   * @param sellerRev The amount of ETH that was sent to the owner for this sale.\\n   */\\n  event ReserveAuctionFinalized(\\n    uint256 indexed auctionId,\\n    address indexed seller,\\n    address indexed bidder,\\n    uint256 protocolFee,\\n    uint256 creatorFee,\\n    uint256 sellerRev\\n  );\\n  /**\\n   * @notice Emitted when an auction is invalidated due to other market activity.\\n   * @dev This occurs when the NFT is sold another way, such as with `buy` or `acceptOffer`.\\n   * @param auctionId The id of the auction that was invalidated.\\n   */\\n  event ReserveAuctionInvalidated(uint256 indexed auctionId);\\n  /**\\n   * @notice Emitted when the auction's reserve price is changed.\\n   * @dev This is only possible if the auction has not received any bids.\\n   * @param auctionId The id of the auction that was updated.\\n   * @param reservePrice The new reserve price for the auction.\\n   */\\n  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);\\n\\n  /// @notice Confirms that the reserve price is not zero.\\n  modifier onlyValidAuctionConfig(uint256 reservePrice) {\\n    if (reservePrice == 0) {\\n      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @notice Configures the duration for auctions.\\n   * @param duration The duration for auctions, in seconds.\\n   */\\n  constructor(uint256 duration) {\\n    if (duration > MAX_MAX_DURATION) {\\n      // This ensures that math in this file will not overflow due to a huge duration.\\n      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);\\n    }\\n    if (duration < EXTENSION_DURATION) {\\n      // The auction duration configuration must be greater than the extension window of 15 minutes\\n      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);\\n    }\\n    DURATION = duration;\\n  }\\n\\n  /**\\n   * @notice Allows Foundation to cancel an auction, refunding the bidder and returning the NFT to\\n   * the seller (if not active buy price set).\\n   * This should only be used for extreme cases such as DMCA takedown requests.\\n   * @param auctionId The id of the auction to cancel.\\n   * @param reason The reason for the cancellation (a required field).\\n   */\\n  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)\\n    external\\n    onlyFoundationAdmin\\n    nonReentrant\\n  {\\n    if (bytes(reason).length == 0) {\\n      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();\\n    }\\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\\n    if (auction.amount == 0) {\\n      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();\\n    }\\n\\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\\n    delete auctionIdToAuction[auctionId];\\n\\n    // Return the NFT to the owner.\\n    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);\\n\\n    if (auction.bidder != address(0)) {\\n      // Refund the highest bidder if any bids were placed in this auction.\\n      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\\n    }\\n\\n    emit ReserveAuctionCanceledByAdmin(auctionId, reason);\\n  }\\n\\n  /**\\n   * @notice If an auction has been created but has not yet received bids, it may be canceled by the seller.\\n   * @dev The NFT is transferred back to the owner unless there is still a buy price set.\\n   * @param auctionId The id of the auction to cancel.\\n   */\\n  function cancelReserveAuction(uint256 auctionId) external nonReentrant {\\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\\n    if (auction.seller != msg.sender) {\\n      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);\\n    }\\n    if (auction.endTime != 0) {\\n      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\\n    }\\n\\n    // Remove the auction.\\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\\n    delete auctionIdToAuction[auctionId];\\n\\n    // Transfer the NFT unless it still has a buy price set.\\n    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);\\n\\n    emit ReserveAuctionCanceled(auctionId);\\n  }\\n\\n  /**\\n   * @notice Creates an auction for the given NFT.\\n   * The NFT is held in escrow until the auction is finalized or canceled.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @param reservePrice The initial reserve price for the auction.\\n   */\\n  function createReserveAuction(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 reservePrice\\n  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {\\n    uint256 auctionId = _getNextAndIncrementAuctionId();\\n\\n    // If the `msg.sender` is not the owner of the NFT, transferring into escrow should fail.\\n    _transferToEscrow(nftContract, tokenId);\\n\\n    // This check must be after _transferToEscrow in case auto-settle was required\\n    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] != 0) {\\n      revert NFTMarketReserveAuction_Already_Listed(nftContractToTokenIdToAuctionId[nftContract][tokenId]);\\n    }\\n\\n    // Store the auction details\\n    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;\\n    auctionIdToAuction[auctionId] = ReserveAuction(\\n      nftContract,\\n      tokenId,\\n      payable(msg.sender),\\n      DURATION,\\n      EXTENSION_DURATION,\\n      0, // endTime is only known once the reserve price is met\\n      payable(0), // bidder is only known once a bid has been placed\\n      reservePrice\\n    );\\n\\n    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);\\n  }\\n\\n  /**\\n   * @notice Once the countdown has expired for an auction, anyone can settle the auction.\\n   * This will send the NFT to the highest bidder and distribute revenue for this sale.\\n   * @param auctionId The id of the auction to settle.\\n   */\\n  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {\\n    if (auctionIdToAuction[auctionId].endTime == 0) {\\n      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();\\n    }\\n    _finalizeReserveAuction({ auctionId: auctionId, keepInEscrow: false });\\n  }\\n\\n  /**\\n   * @notice Place a bid in an auction.\\n   * A bidder may place a bid which is at least the value defined by `getMinBidAmount`.\\n   * If this is the first bid on the auction, the countdown will begin.\\n   * If there is already an outstanding bid, the previous bidder will be refunded at this time\\n   * and if the bid is placed in the final moments of the auction, the countdown may be extended.\\n   * @dev This API is deprecated and will be removed in the future, `placeBidOf` should be used instead.\\n   * @param auctionId The id of the auction to bid on.\\n   */\\n  function placeBid(uint256 auctionId) external payable {\\n    placeBidOf(auctionId, msg.value);\\n  }\\n\\n  /**\\n   * @notice Place a bid in an auction.\\n   * A bidder may place a bid which is at least the amount defined by `getMinBidAmount`.\\n   * If this is the first bid on the auction, the countdown will begin.\\n   * If there is already an outstanding bid, the previous bidder will be refunded at this time\\n   * and if the bid is placed in the final moments of the auction, the countdown may be extended.\\n   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.\\n   * @param auctionId The id of the auction to bid on.\\n   * @param amount The amount to bid, if this is more than `msg.value` funds will be withdrawn from your FETH balance.\\n   */\\n  /* solhint-disable-next-line code-complexity */\\n  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {\\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\\n\\n    if (auction.amount == 0) {\\n      // No auction found\\n      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();\\n    } else if (amount < msg.value) {\\n      // The amount is specified by the bidder, so if too much ETH is sent then something went wrong.\\n      revert NFTMarketReserveAuction_Too_Much_Value_Provided();\\n    }\\n\\n    uint256 endTime = auction.endTime;\\n    if (endTime == 0) {\\n      // This is the first bid, kicking off the auction.\\n\\n      if (amount < auction.amount) {\\n        // The bid must be >= the reserve price.\\n        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);\\n      }\\n\\n      // Notify other market tools that an auction for this NFT has been kicked off.\\n      // The only state change before this call is potentially withdrawing funds from FETH.\\n      _beforeAuctionStarted(auction.nftContract, auction.tokenId);\\n\\n      // Store the bid details.\\n      auction.amount = amount;\\n      auction.bidder = payable(msg.sender);\\n\\n      // On the first bid, set the endTime to now + duration.\\n      unchecked {\\n        // Duration is always set to 24hrs so the below can't overflow.\\n        endTime = block.timestamp + DURATION;\\n      }\\n      auction.endTime = endTime;\\n    } else {\\n      if (endTime < block.timestamp) {\\n        // The auction has already ended.\\n        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(endTime);\\n      } else if (auction.bidder == msg.sender) {\\n        // We currently do not allow a bidder to increase their bid unless another user has outbid them first.\\n        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();\\n      } else {\\n        uint256 minIncrement = _getMinIncrement(auction.amount);\\n        if (amount < minIncrement) {\\n          // If this bid outbids another, it must be at least 10% greater than the last bid.\\n          revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(minIncrement);\\n        }\\n      }\\n\\n      // Cache and update bidder state\\n      uint256 originalAmount = auction.amount;\\n      address payable originalBidder = auction.bidder;\\n      auction.amount = amount;\\n      auction.bidder = payable(msg.sender);\\n\\n      unchecked {\\n        // When a bid outbids another, check to see if a time extension should apply.\\n        // We confirmed that the auction has not ended, so endTime is always >= the current timestamp.\\n        // Current time plus extension duration (always 15 mins) cannot overflow.\\n        uint256 endTimeWithExtension = block.timestamp + EXTENSION_DURATION;\\n        if (endTime < endTimeWithExtension) {\\n          endTime = endTimeWithExtension;\\n          auction.endTime = endTime;\\n        }\\n      }\\n\\n      // Refund the previous bidder\\n      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\\n    }\\n\\n    // Withdraw last in order to leverage freed FETH balance.\\n    if (amount > msg.value) {\\n      // Withdraw additional ETH required from their available FETH balance.\\n\\n      unchecked {\\n        // The if above ensures delta will not underflow.\\n        // Withdraw ETH from the buyer's account in the FETH token contract.\\n        feth.marketWithdrawFrom(msg.sender, amount - msg.value);\\n      }\\n    }\\n\\n    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, endTime);\\n  }\\n\\n  /**\\n   * @notice If an auction has been created but has not yet received bids, the reservePrice may be\\n   * changed by the seller.\\n   * @param auctionId The id of the auction to change.\\n   * @param reservePrice The new reserve price for this auction.\\n   */\\n  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {\\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\\n    if (auction.seller != msg.sender) {\\n      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);\\n    } else if (auction.endTime != 0) {\\n      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\\n    } else if (auction.amount == reservePrice) {\\n      revert NFTMarketReserveAuction_Price_Already_Set();\\n    }\\n\\n    // Update the current reserve price.\\n    auction.amount = reservePrice;\\n\\n    emit ReserveAuctionUpdated(auctionId, reservePrice);\\n  }\\n\\n  /**\\n   * @notice Settle an auction that has already ended.\\n   * This will send the NFT to the highest bidder and distribute revenue for this sale.\\n   * @param keepInEscrow If true, the NFT will be kept in escrow to save gas by avoiding\\n   * redundant transfers if the NFT should remain in escrow, such as when the new owner\\n   * sets a buy price or lists it in a new auction.\\n   */\\n  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {\\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\\n\\n    if (auction.endTime >= block.timestamp) {\\n      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);\\n    }\\n\\n    // Remove the auction.\\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\\n    delete auctionIdToAuction[auctionId];\\n\\n    if (!keepInEscrow) {\\n      // The seller was authorized when the auction was originally created\\n      super._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));\\n    }\\n\\n    // Distribute revenue for this sale.\\n    (uint256 protocolFee, uint256 creatorFee, uint256 sellerRev) = _distributeFunds(\\n      auction.nftContract,\\n      auction.tokenId,\\n      auction.seller,\\n      auction.amount,\\n      payable(0)\\n    );\\n\\n    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, protocolFee, creatorFee, sellerRev);\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   * @dev If an auction is found:\\n   *  - If the auction is over, it will settle the auction and confirm the new seller won the auction.\\n   *  - If the auction has not received a bid, it will invalidate the auction.\\n   *  - If the auction is in progress, this will revert.\\n   */\\n  function _transferFromEscrow(\\n    address nftContract,\\n    uint256 tokenId,\\n    address recipient,\\n    address authorizeSeller\\n  ) internal virtual override {\\n    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\\n    if (auctionId != 0) {\\n      ReserveAuction storage auction = auctionIdToAuction[auctionId];\\n      if (auction.endTime == 0) {\\n        // The auction has not received any bids yet so it may be invalided.\\n\\n        if (authorizeSeller != address(0) && auction.seller != authorizeSeller) {\\n          // The account trying to transfer the NFT is not the current owner.\\n          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);\\n        }\\n\\n        // Remove the auction.\\n        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];\\n        delete auctionIdToAuction[auctionId];\\n\\n        emit ReserveAuctionInvalidated(auctionId);\\n      } else {\\n        // If the auction has ended, the highest bidder will be the new owner\\n        // and if the auction is in progress, this will revert.\\n\\n        // `authorizeSeller != address(0)` does not apply here since an unsettled auction must go\\n        // through this path to know who the authorized seller should be.\\n        if (auction.bidder != authorizeSeller) {\\n          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);\\n        }\\n\\n        // Finalization will revert if the auction has not yet ended.\\n        _finalizeReserveAuction({ auctionId: auctionId, keepInEscrow: true });\\n      }\\n      // The seller authorization has been confirmed.\\n      authorizeSeller = address(0);\\n    }\\n\\n    super._transferFromEscrow(nftContract, tokenId, recipient, authorizeSeller);\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   * @dev Checks if there is an auction for this NFT before allowing the transfer to continue.\\n   */\\n  function _transferFromEscrowIfAvailable(\\n    address nftContract,\\n    uint256 tokenId,\\n    address recipient\\n  ) internal virtual override {\\n    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {\\n      // No auction was found\\n\\n      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);\\n    }\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   */\\n  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {\\n    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\\n    if (auctionId == 0) {\\n      // NFT is not in auction\\n      super._transferToEscrow(nftContract, tokenId);\\n      return;\\n    }\\n    // Using storage saves gas since most of the data is not needed\\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\\n    if (auction.endTime == 0) {\\n      // Reserve price set, confirm the seller is a match\\n      if (auction.seller != msg.sender) {\\n        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);\\n      }\\n    } else {\\n      // Auction in progress, confirm the highest bidder is a match\\n      if (auction.bidder != msg.sender) {\\n        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);\\n      }\\n\\n      // Finalize auction but leave NFT in escrow, reverts if the auction has not ended\\n      _finalizeReserveAuction({ auctionId: auctionId, keepInEscrow: true });\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns the minimum amount a bidder must spend to participate in an auction.\\n   * Bids must be greater than or equal to this value or they will revert.\\n   * @param auctionId The id of the auction to check.\\n   * @return minimum The minimum amount for a bid to be accepted.\\n   */\\n  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {\\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\\n    if (auction.endTime == 0) {\\n      return auction.amount;\\n    }\\n    return _getMinIncrement(auction.amount);\\n  }\\n\\n  /**\\n   * @notice Returns auction details for a given auctionId.\\n   * @param auctionId The id of the auction to lookup.\\n   * @return auction The auction details.\\n   */\\n  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {\\n    return auctionIdToAuction[auctionId];\\n  }\\n\\n  /**\\n   * @notice Returns the auctionId for a given NFT, or 0 if no auction is found.\\n   * @dev If an auction is canceled, it will not be returned. However the auction may be over and pending finalization.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @return auctionId The id of the auction, or 0 if no auction is found.\\n   */\\n  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {\\n    auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   * @dev Returns the seller that has the given NFT in escrow for an auction,\\n   * or bubbles the call up for other considerations.\\n   */\\n  function _getSellerFor(address nftContract, uint256 tokenId)\\n    internal\\n    view\\n    virtual\\n    override\\n    returns (address payable seller)\\n  {\\n    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;\\n    if (seller == address(0)) {\\n      seller = super._getSellerFor(nftContract, tokenId);\\n    }\\n  }\\n\\n  /**\\n   * @inheritdoc NFTMarketCore\\n   */\\n  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {\\n    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\\n    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;\\n  }\\n\\n  /**\\n   * @notice This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[1000] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/SendValueWithFallbackWithdraw.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"./FoundationTreasuryNode.sol\\\";\\nimport \\\"./NFTMarketCore.sol\\\";\\nimport \\\"./NFTMarketCreators.sol\\\";\\n\\nerror SendValueWithFallbackWithdraw_No_Funds_Available();\\n\\n/**\\n * @title A mixin for sending ETH with a fallback withdraw mechanism.\\n * @notice Attempt to send ETH and if the transfer fails or runs out of gas, store the balance\\n * in the FETH token contract for future withdrawal instead.\\n * @dev This mixin was recently switched to escrow funds in FETH.\\n * Once we have confirmed all pending balances have been withdrawn, we can remove the escrow tracking here.\\n */\\nabstract contract SendValueWithFallbackWithdraw is\\n  FoundationTreasuryNode,\\n  NFTMarketCore,\\n  ReentrancyGuardUpgradeable,\\n  NFTMarketCreators\\n{\\n  using AddressUpgradeable for address payable;\\n\\n  /// @dev Tracks the amount of ETH that is stored in escrow for future withdrawal.\\n  mapping(address => uint256) private __gap_was_pendingWithdrawals;\\n\\n  /**\\n   * @notice Emitted when escrowed funds are withdrawn to FETH.\\n   * @param user The account which has withdrawn ETH.\\n   * @param amount The amount of ETH which has been withdrawn.\\n   */\\n  event WithdrawalToFETH(address indexed user, uint256 amount);\\n\\n  /**\\n   * @dev Attempt to send a user or contract ETH and\\n   * if it fails store the amount owned for later withdrawal in FETH.\\n   */\\n  function _sendValueWithFallbackWithdraw(\\n    address payable user,\\n    uint256 amount,\\n    uint256 gasLimit\\n  ) internal {\\n    if (amount == 0) {\\n      return;\\n    }\\n    // Cap the gas to prevent consuming all available gas to block a tx from completing successfully\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, ) = user.call{ value: amount, gas: gasLimit }(\\\"\\\");\\n    if (!success) {\\n      // Store the funds that failed to send for the user in the FETH token\\n      feth.depositFor{ value: amount }(user);\\n      emit WithdrawalToFETH(user, amount);\\n    }\\n  }\\n\\n  /**\\n   * @notice This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[499] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAdminRole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Interface for AdminRole which wraps the default admin role from\\n * OpenZeppelin's AccessControl for easy integration.\\n */\\ninterface IAdminRole {\\n  function isAdmin(address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOperatorRole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Interface for OperatorRole which wraps a role from\\n * OpenZeppelin's AccessControl for easy integration.\\n */\\ninterface IOperatorRole {\\n  function isOperator(address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFethMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Interface for functions the market uses in FETH.\\n */\\ninterface IFethMarket {\\n  function depositFor(address account) external payable;\\n\\n  function marketLockupFor(address account, uint256 amount) external payable returns (uint256 expiration);\\n\\n  function marketWithdrawFrom(address from, uint256 amount) external;\\n\\n  function marketWithdrawLocked(\\n    address account,\\n    uint256 expiration,\\n    uint256 amount\\n  ) external;\\n\\n  function marketUnlockFor(\\n    address account,\\n    uint256 expiration,\\n    uint256 amount\\n  ) external;\\n\\n  function marketChangeLockup(\\n    address unlockFrom,\\n    uint256 unlockExpiration,\\n    uint256 unlockAmount,\\n    address depositFor,\\n    uint256 depositAmount\\n  ) external payable returns (uint256 expiration);\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/OZ/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.2.0/contracts/utils/introspection/ERC165.sol\\n * Modified to allow checking multiple interfaces w/o checking general 165 support.\\n */\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title Library to query ERC165 support.\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary OZERC165Checker {\\n  // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n  bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n  /**\\n   * @dev Returns true if `account` supports the {IERC165} interface,\\n   */\\n  function supportsERC165(address account) internal view returns (bool) {\\n    // Any contract that implements ERC165 must explicitly indicate support of\\n    // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n    return\\n      supportsERC165Interface(account, type(IERC165).interfaceId) &&\\n      !supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n  }\\n\\n  /**\\n   * @dev Returns true if `account` supports the interface defined by\\n   * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n   *\\n   * See {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n    // query support of both ERC165 as per the spec and support of _interfaceId\\n    return supportsERC165(account) && supportsERC165Interface(account, interfaceId);\\n  }\\n\\n  /**\\n   * @dev Returns a boolean array where each value corresponds to the\\n   * interfaces passed in and whether they're supported or not. This allows\\n   * you to batch check interfaces for a contract where your expectation\\n   * is that some interfaces may not be supported.\\n   *\\n   * See {IERC165-supportsInterface}.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function getSupportedInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool[] memory) {\\n    // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n    bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n    // query support of ERC165 itself\\n    if (supportsERC165(account)) {\\n      // query support of each interface in interfaceIds\\n      unchecked {\\n        for (uint256 i = 0; i < interfaceIds.length; ++i) {\\n          interfaceIdsSupported[i] = supportsERC165Interface(account, interfaceIds[i]);\\n        }\\n      }\\n    }\\n\\n    return interfaceIdsSupported;\\n  }\\n\\n  /**\\n   * @dev Returns true if `account` supports all the interfaces defined in\\n   * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n   *\\n   * Batch-querying can lead to gas savings by skipping repeated checks for\\n   * {IERC165} support.\\n   *\\n   * See {IERC165-supportsInterface}.\\n   */\\n  function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n    // query support of ERC165 itself\\n    if (!supportsERC165(account)) {\\n      return false;\\n    }\\n\\n    // query support of each interface in _interfaceIds\\n    unchecked {\\n      for (uint256 i = 0; i < interfaceIds.length; ++i) {\\n        if (!supportsERC165Interface(account, interfaceIds[i])) {\\n          return false;\\n        }\\n      }\\n    }\\n\\n    // all interfaces supported\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Query if a contract implements an interface, does not check ERC165 support\\n   * @param account The address of the contract to query for support of an interface\\n   * @param interfaceId The interface identifier, as specified in ERC-165\\n   * @return true if the contract at account indicates support of the interface with\\n   * identifier interfaceId, false otherwise\\n   * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n   * the behavior of this method is undefined. This precondition can be checked\\n   * with {supportsERC165}.\\n   * Interface identification is specified in ERC-165.\\n   */\\n  function supportsERC165Interface(address account, bytes4 interfaceId) internal view returns (bool) {\\n    bytes memory encodedParams = abi.encodeWithSelector(IERC165(account).supportsInterface.selector, interfaceId);\\n    (bool success, bytes memory result) = account.staticcall{ gas: 30000 }(encodedParams);\\n    if (result.length < 32) return false;\\n    return success && abi.decode(result, (bool));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGetFees.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice An interface for communicating fees to 3rd party marketplaces.\\n * @dev Originally implemented in mainnet contract 0x44d6e8933f8271abcf253c72f9ed7e0e4c0323b3\\n */\\ninterface IGetFees {\\n  function getFeeRecipients(uint256 id) external view returns (address payable[] memory);\\n\\n  function getFeeBps(uint256 id) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGetRoyalties.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface IGetRoyalties {\\n  function getRoyalties(uint256 tokenId)\\n    external\\n    view\\n    returns (address payable[] memory recipients, uint256[] memory feesInBasisPoints);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRoyaltyInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Interface for EIP-2981: NFT Royalty Standard.\\n * For more see: https://eips.ethereum.org/EIPS/eip-2981.\\n */\\ninterface IRoyaltyInfo {\\n  /// @notice Called with the sale price to determine how much royalty\\n  //          is owed and to whom.\\n  /// @param _tokenId - the NFT asset queried for royalty information\\n  /// @param _salePrice - the sale price of the NFT asset specified by _tokenId\\n  /// @return receiver - address of who should be sent the royalty payment\\n  /// @return royaltyAmount - the royalty payment amount for _salePrice\\n  function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\\n    external\\n    view\\n    returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface ITokenCreator {\\n  function tokenCreator(uint256 tokenId) external view returns (address payable);\\n}\\n\"\r\n    },\r\n    \"@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Royalty registry interface\\n */\\ninterface IRoyaltyRegistry is IERC165 {\\n\\n     event RoyaltyOverride(address owner, address tokenAddress, address royaltyAddress);\\n\\n    /**\\n     * Override the location of where to look up royalty information for a given token contract.\\n     * Allows for backwards compatibility and implementation of royalty logic for contracts that did not previously support them.\\n     * \\n     * @param tokenAddress    - The token address you wish to override\\n     * @param royaltyAddress  - The royalty override address\\n     */\\n    function setRoyaltyLookupAddress(address tokenAddress, address royaltyAddress) external;\\n\\n    /**\\n     * Returns royalty address location.  Returns the tokenAddress by default, or the override if it exists\\n     *\\n     * @param tokenAddress    - The token address you are looking up the royalty for\\n     */\\n    function getRoyaltyLookupAddress(address tokenAddress) external view returns(address);\\n\\n    /**\\n     * Whether or not the message sender can override the royalty address for the given token address\\n     *\\n     * @param tokenAddress    - The token address you are looking up the royalty for\\n     */\\n    function overrideAllowed(address tokenAddress) external view returns(bool);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Approve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC20Approve {\\n  function approve(address spender, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20IncreaseAllowance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC20IncreaseAllowance {\\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BytesLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nerror BytesLibrary_Expected_Address_Not_Found();\\n\\n/**\\n * @title A library for manipulation of byte arrays.\\n */\\nlibrary BytesLibrary {\\n  /**\\n   * @dev Replace the address at the given location in a byte array if the contents at that location\\n   * match the expected address.\\n   */\\n  function replaceAtIf(\\n    bytes memory data,\\n    uint256 startLocation,\\n    address expectedAddress,\\n    address newAddress\\n  ) internal pure {\\n    bytes memory expectedData = abi.encodePacked(expectedAddress);\\n    bytes memory newData = abi.encodePacked(newAddress);\\n    unchecked {\\n      // An address is 20 bytes long\\n      for (uint256 i = 0; i < 20; ++i) {\\n        uint256 dataLocation = startLocation + i;\\n        if (data[dataLocation] != expectedData[i]) {\\n          revert BytesLibrary_Expected_Address_Not_Found();\\n        }\\n        data[dataLocation] = newData[i];\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Checks if the call data starts with the given function signature.\\n   */\\n  function startsWith(bytes memory callData, bytes4 functionSig) internal pure returns (bool) {\\n    // A signature is 4 bytes long\\n    if (callData.length < 4) {\\n      return false;\\n    }\\n    unchecked {\\n      for (uint256 i = 0; i < 4; ++i) {\\n        if (callData[i] != functionSig[i]) {\\n          return false;\\n        }\\n      }\\n    }\\n\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICollectionContractInitializer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface ICollectionContractInitializer {\\n  function initialize(\\n    address payable _creator,\\n    string memory _name,\\n    string memory _symbol\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICollectionFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IRoles.sol\\\";\\nimport \\\"./IProxyCall.sol\\\";\\n\\ninterface ICollectionFactory {\\n  function rolesContract() external returns (IRoles);\\n\\n  function proxyCallContract() external returns (IProxyCall);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProxyCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface IProxyCall {\\n  function proxyCallAndReturnAddress(address externalContract, bytes memory callData)\\n    external\\n    returns (address payable result);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/AccountMigrationLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nerror AccountMigrationLibrary_Cannot_Migrate_Account_To_Itself();\\nerror AccountMigrationLibrary_Signature_Verification_Failed();\\n\\n/**\\n * @title A library which confirms account migration signatures.\\n * @notice Checks for a valid signature authorizing the migration of an account to a new address.\\n * @dev This is shared by both the NFT contracts and FNDNFTMarket, and the same signature authorizes both.\\n */\\nlibrary AccountMigrationLibrary {\\n  using ECDSA for bytes;\\n  using SignatureChecker for address;\\n  using Strings for uint256;\\n\\n  /**\\n   * @notice Confirms the msg.sender is a Foundation operator and that the signature provided is valid.\\n   * @param originalAddress The address of the account to be migrated.\\n   * @param newAddress The new address representing this account.\\n   * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`\\n   * signed by the original account.\\n   */\\n  function requireAuthorizedAccountMigration(\\n    address originalAddress,\\n    address newAddress,\\n    bytes calldata signature\\n  ) internal view {\\n    if (originalAddress == newAddress) {\\n      revert AccountMigrationLibrary_Cannot_Migrate_Account_To_Itself();\\n    }\\n    bytes32 hash = abi\\n      .encodePacked(\\\"I authorize Foundation to migrate my account to \\\", _toAsciiString(newAddress))\\n      .toEthSignedMessageHash();\\n    if (!originalAddress.isValidSignatureNow(hash, signature)) {\\n      revert AccountMigrationLibrary_Signature_Verification_Failed();\\n    }\\n  }\\n\\n  /**\\n   * @notice Converts an address into a string.\\n   * @dev From https://ethereum.stackexchange.com/questions/8346/convert-address-to-string\\n   */\\n  function _toAsciiString(address x) private pure returns (string memory) {\\n    unchecked {\\n      bytes memory s = new bytes(42);\\n      s[0] = \\\"0\\\";\\n      s[1] = \\\"x\\\";\\n      for (uint256 i = 0; i < 20; ++i) {\\n        bytes1 b = bytes1(uint8(uint256(uint160(x)) / (2**(8 * (19 - i)))));\\n        bytes1 hi = bytes1(uint8(b) / 16);\\n        bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n        s[2 * i + 2] = _char(hi);\\n        s[2 * i + 3] = _char(lo);\\n      }\\n      return string(s);\\n    }\\n  }\\n\\n  /**\\n   * @notice Converts a byte to a UTF-8 character.\\n   */\\n  function _char(bytes1 b) private pure returns (bytes1 c) {\\n    unchecked {\\n      if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n      else return bytes1(uint8(b) + 0x57);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ProxyCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"../interfaces/IProxyCall.sol\\\";\\n\\n/**\\n * @title A library which forwards arbitrary calls to an external contract to be processed.\\n * @dev This is used so that the from address of the calling contract does not have\\n * any special permissions (e.g. ERC-20 transfer).\\n */\\nlibrary ProxyCall {\\n  using AddressUpgradeable for address payable;\\n\\n  /**\\n   * @dev Used by other mixins to make external calls through the proxy contract.\\n   * This will fail if the proxyCall address is address(0).\\n   */\\n  function proxyCallAndReturnContractAddress(\\n    IProxyCall proxyCall,\\n    address externalContract,\\n    bytes memory callData\\n  ) internal returns (address payable result) {\\n    result = proxyCall.proxyCallAndReturnAddress(externalContract, callData);\\n    require(result.isContract(), \\\"ProxyCall: address returned is not a contract\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Interface for a contract which implements admin roles.\\n */\\ninterface IRoles {\\n  function isAdmin(address account) external view returns (bool);\\n\\n  function isOperator(address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../Address.sol\\\";\\nimport \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\\n        if (error == ECDSA.RecoverError.NoError && recovered == signer) {\\n            return true;\\n        }\\n\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\\n        );\\n        return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LockedBalance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Library that handles locked balances efficiently using bit packing.\\n */\\nlibrary LockedBalance {\\n  /// @dev Tracks an account's total lockup per expiration time.\\n  struct Lockup {\\n    uint32 expiration;\\n    uint96 totalAmount;\\n  }\\n\\n  struct Lockups {\\n    /// @dev Mapping from key to lockups.\\n    /// i) A key represents 2 lockups. The key for a lockup is `index / 2`.\\n    ///     For instance, elements with index 25 and 24 would map to the same key.\\n    /// ii) The `value` for the `key` is split into two 128bits which are used to store the metadata for a lockup.\\n    mapping(uint256 => uint256) lockups;\\n  }\\n\\n  // Masks used to split a uint256 into two equal pieces which represent two individual Lockups.\\n  uint256 private constant last128BitsMask = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  uint256 private constant first128BitsMask = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000;\\n\\n  // Masks used to retrieve or set the totalAmount value of a single Lockup.\\n  uint256 private constant firstAmountBitsMask = 0xFFFFFFFF000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  uint256 private constant secondAmountBitsMask = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000;\\n\\n  /**\\n   * @notice Clears the lockup at the index.\\n   */\\n  function del(Lockups storage lockups, uint256 index) internal {\\n    unchecked {\\n      if (index % 2 == 0) {\\n        index /= 2;\\n        lockups.lockups[index] = (lockups.lockups[index] & last128BitsMask);\\n      } else {\\n        index /= 2;\\n        lockups.lockups[index] = (lockups.lockups[index] & first128BitsMask);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Sets the Lockup at the provided index.\\n   */\\n  function set(\\n    Lockups storage lockups,\\n    uint256 index,\\n    uint256 expiration,\\n    uint256 totalAmount\\n  ) internal {\\n    unchecked {\\n      uint256 lockedBalanceBits = totalAmount | (expiration << 96);\\n      if (index % 2 == 0) {\\n        // set first 128 bits.\\n        index /= 2;\\n        lockups.lockups[index] = (lockups.lockups[index] & last128BitsMask) | (lockedBalanceBits << 128);\\n      } else {\\n        // set last 128 bits.\\n        index /= 2;\\n        lockups.lockups[index] = (lockups.lockups[index] & first128BitsMask) | lockedBalanceBits;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Sets only the totalAmount for a lockup at the index.\\n   */\\n  function setTotalAmount(\\n    Lockups storage lockups,\\n    uint256 index,\\n    uint256 totalAmount\\n  ) internal {\\n    unchecked {\\n      if (index % 2 == 0) {\\n        index /= 2;\\n        lockups.lockups[index] = (lockups.lockups[index] & firstAmountBitsMask) | (totalAmount << 128);\\n      } else {\\n        index /= 2;\\n        lockups.lockups[index] = (lockups.lockups[index] & secondAmountBitsMask) | totalAmount;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns the Lockup at the provided index.\\n   * @dev To get the lockup stored in the *first* 128 bits (first slot/lockup):\\n   *       - we remove the last 128 bits (done by >> 128)\\n   *      To get the lockup stored in the *last* 128 bits (second slot/lockup):\\n   *       - we take the last 128 bits (done by % (2**128))\\n   *      Once the lockup is obtained:\\n   *       - get `expiration` by peaking at the first 32 bits (done by >> 96)\\n   *       - get `totalAmount` by peaking at the last 96 bits (done by % (2**96))\\n   */\\n  function get(Lockups storage lockups, uint256 index) internal view returns (Lockup memory balance) {\\n    unchecked {\\n      uint256 lockupMetadata = lockups.lockups[index / 2];\\n      if (lockupMetadata == 0) {\\n        return balance;\\n      }\\n      uint128 lockedBalanceBits;\\n      if (index % 2 == 0) {\\n        // use first 128 bits.\\n        lockedBalanceBits = uint128(lockupMetadata >> 128);\\n      } else {\\n        // use last 128 bits.\\n        lockedBalanceBits = uint128(lockupMetadata % (2**128));\\n      }\\n      // unpack the bits to retrieve the Lockup.\\n      balance.expiration = uint32(lockedBalanceBits >> 96);\\n      balance.totalAmount = uint96(lockedBalanceBits % (2**96));\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1337\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_feth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ens\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableFethBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedFethBalance\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ensName\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"getFees\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"percentInBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct FNDMiddleware.FeeWithRecipient\",\"name\":\"protocol\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"percentInBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"internalType\":\"struct FNDMiddleware.Fee\",\"name\":\"creator\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"percentInBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct FNDMiddleware.FeeWithRecipient\",\"name\":\"owner\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"relativePercentInBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"absolutePercentInBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct FNDMiddleware.RevSplit[]\",\"name\":\"creatorRevSplit\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getNFTDetailString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getNFTDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isInEscrow\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"auctionBidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"auctionEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"offerBuyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerExpiration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"probeNFT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "FNDMiddleware", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1337", "ConstructorArguments": "000000000000000000000000cda72070e455bb31c7690a170224ce43623d0b6f00000000000000000000000049128cf8abe9071ee24540a296b5ded3f9d5044300000000000000000000000000000000000c2e074ec69a0dfb2997ba6c7d2e1e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}