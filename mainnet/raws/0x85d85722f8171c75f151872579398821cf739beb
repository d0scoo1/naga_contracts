{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.4;\n\ninterface ICodex {\n    function init(address vault) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address,\n        bytes32,\n        uint256\n    ) external;\n\n    function credit(address) external view returns (uint256);\n\n    function unbackedDebt(address) external view returns (uint256);\n\n    function balances(\n        address,\n        uint256,\n        address\n    ) external view returns (uint256);\n\n    function vaults(address vault)\n        external\n        view\n        returns (\n            uint256 totalNormalDebt,\n            uint256 rate,\n            uint256 debtCeiling,\n            uint256 debtFloor\n        );\n\n    function positions(\n        address vault,\n        uint256 tokenId,\n        address position\n    ) external view returns (uint256 collateral, uint256 normalDebt);\n\n    function globalDebt() external view returns (uint256);\n\n    function globalUnbackedDebt() external view returns (uint256);\n\n    function globalDebtCeiling() external view returns (uint256);\n\n    function delegates(address, address) external view returns (uint256);\n\n    function grantDelegate(address) external;\n\n    function revokeDelegate(address) external;\n\n    function modifyBalance(\n        address,\n        uint256,\n        address,\n        int256\n    ) external;\n\n    function transferBalance(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function transferCredit(\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function modifyCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function transferCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function confiscateCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function settleUnbackedDebt(uint256 debt) external;\n\n    function createUnbackedDebt(\n        address debtor,\n        address creditor,\n        uint256 debt\n    ) external;\n\n    function modifyRate(\n        address vault,\n        address creditor,\n        int256 rate\n    ) external;\n\n    function lock() external;\n}\ninterface IPriceFeed {\n    function peek() external returns (bytes32, bool);\n\n    function read() external view returns (bytes32);\n}\n\ninterface ICollybus {\n    function vaults(address) external view returns (uint128, uint128);\n\n    function spots(address) external view returns (uint256);\n\n    function rates(uint256) external view returns (uint256);\n\n    function rateIds(address, uint256) external view returns (uint256);\n\n    function redemptionPrice() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint128 data\n    ) external;\n\n    function setParam(\n        address vault,\n        uint256 tokenId,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function updateDiscountRate(uint256 rateId, uint256 rate) external;\n\n    function updateSpot(address token, uint256 spot) external;\n\n    function read(\n        address vault,\n        address underlier,\n        uint256 tokenId,\n        uint256 maturity,\n        bool net\n    ) external view returns (uint256 price);\n\n    function lock() external;\n}\n\ninterface IVault {\n    function codex() external view returns (ICodex);\n\n    function collybus() external view returns (ICollybus);\n\n    function token() external view returns (address);\n\n    function tokenScale() external view returns (uint256);\n\n    function underlierToken() external view returns (address);\n\n    function underlierScale() external view returns (uint256);\n\n    function vaultType() external view returns (bytes32);\n\n    function live() external view returns (uint256);\n\n    function lock() external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function maturity(uint256 tokenId) external returns (uint256);\n\n    function fairPrice(\n        uint256 tokenId,\n        bool net,\n        bool face\n    ) external view returns (uint256);\n\n    function enter(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n\n    function exit(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n}interface IGuarded {\n    function ANY_SIG() external view returns (bytes32);\n\n    function ANY_CALLER() external view returns (address);\n\n    function allowCaller(bytes32 sig, address who) external;\n\n    function blockCaller(bytes32 sig, address who) external;\n\n    function canCall(bytes32 sig, address who) external view returns (bool);\n}\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n\n\n/// @title Guarded\n/// @notice Mixin implementing an authentication scheme on a method level\nabstract contract Guarded is IGuarded {\n    /// ======== Custom Errors ======== ///\n\n    error Guarded__notRoot();\n    error Guarded__notGranted();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Wildcard for granting a caller to call every guarded method\n    bytes32 public constant override ANY_SIG = keccak256(\"ANY_SIG\");\n    /// @notice Wildcard for granting a caller to call every guarded method\n    address public constant override ANY_CALLER = address(uint160(uint256(bytes32(keccak256(\"ANY_CALLER\")))));\n\n    /// @notice Mapping storing who is granted to which method\n    /// @dev Method Signature => Caller => Bool\n    mapping(bytes32 => mapping(address => bool)) private _canCall;\n\n    /// ======== Events ======== ///\n\n    event AllowCaller(bytes32 sig, address who);\n    event BlockCaller(bytes32 sig, address who);\n\n    constructor() {\n        // set root\n        _setRoot(msg.sender);\n    }\n\n    /// ======== Auth ======== ///\n\n    modifier callerIsRoot() {\n        if (_canCall[ANY_SIG][msg.sender]) {\n            _;\n        } else revert Guarded__notRoot();\n    }\n\n    modifier checkCaller() {\n        if (canCall(msg.sig, msg.sender)) {\n            _;\n        } else revert Guarded__notGranted();\n    }\n\n    /// @notice Grant the right to call method `sig` to `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function allowCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = true;\n        emit AllowCaller(sig, who);\n    }\n\n    /// @notice Revoke the right to call method `sig` from `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should not be able to call `sig` anymore\n    function blockCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = false;\n        emit BlockCaller(sig, who);\n    }\n\n    /// @notice Returns if `who` can call `sig`\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function canCall(bytes32 sig, address who) public view override returns (bool) {\n        return (_canCall[sig][who] || _canCall[ANY_SIG][who] || _canCall[sig][ANY_CALLER]);\n    }\n\n    /// @notice Sets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be set as root\n    function _setRoot(address root) internal {\n        _canCall[ANY_SIG][root] = true;\n        emit AllowCaller(ANY_SIG, root);\n    }\n\n    /// @notice Unsets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be unset as root\n    function _unsetRoot(address root) internal {\n        _canCall[ANY_SIG][root] = false;\n        emit AllowCaller(ANY_SIG, root);\n    }\n}// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n\nuint256 constant MLN = 10**6;\nuint256 constant BLN = 10**9;\nuint256 constant WAD = 10**18;\nuint256 constant RAY = 10**18;\nuint256 constant RAD = 10**18;\n\n/* solhint-disable func-visibility, no-inline-assembly */\n\nerror Math__toInt256_overflow(uint256 x);\n\nfunction toInt256(uint256 x) pure returns (int256) {\n    if (x > uint256(type(int256).max)) revert Math__toInt256_overflow(x);\n    return int256(x);\n}\n\nfunction min(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x <= y ? x : y;\n    }\n}\n\nfunction max(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x >= y ? x : y;\n    }\n}\n\nerror Math__diff_overflow(uint256 x, uint256 y);\n\nfunction diff(uint256 x, uint256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) - int256(y);\n        if (!(int256(x) >= 0 && int256(y) >= 0)) revert Math__diff_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow(uint256 x, uint256 y);\n\nfunction add(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add_overflow(x, y);\n    }\n}\n\nerror Math__add48_overflow(uint256 x, uint256 y);\n\nfunction add48(uint48 x, uint48 y) pure returns (uint48 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add48_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow_signed(uint256 x, int256 y);\n\nfunction add(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x + uint256(y);\n        if (!(y >= 0 || z <= x)) revert Math__add_overflow_signed(x, y);\n        if (!(y <= 0 || z >= x)) revert Math__add_overflow_signed(x, y);\n    }\n}\n\nerror Math__sub_overflow(uint256 x, uint256 y);\n\nfunction sub(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x - y) > x) revert Math__sub_overflow(x, y);\n    }\n}\n\nerror Math__sub_overflow_signed(uint256 x, int256 y);\n\nfunction sub(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x - uint256(y);\n        if (!(y <= 0 || z <= x)) revert Math__sub_overflow_signed(x, y);\n        if (!(y >= 0 || z >= x)) revert Math__sub_overflow_signed(x, y);\n    }\n}\n\nerror Math__mul_overflow(uint256 x, uint256 y);\n\nfunction mul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (!(y == 0 || (z = x * y) / y == x)) revert Math__mul_overflow(x, y);\n    }\n}\n\nerror Math__mul_overflow_signed(uint256 x, int256 y);\n\nfunction mul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) * y;\n        if (int256(x) < 0) revert Math__mul_overflow_signed(x, y);\n        if (!(y == 0 || z / y == int256(x))) revert Math__mul_overflow_signed(x, y);\n    }\n}\n\nfunction wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, y) / WAD;\n    }\n}\n\nfunction wmul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = mul(x, y) / int256(WAD);\n    }\n}\n\nerror Math__div_overflow(uint256 x, uint256 y);\n\nfunction div(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (y == 0) revert Math__div_overflow(x, y);\n        return x / y;\n    }\n}\n\nfunction wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, WAD) / y;\n    }\n}\n\n// optimized version from dss PR #78\nfunction wpow(\n    uint256 x,\n    uint256 n,\n    uint256 b\n) pure returns (uint256 z) {\n    unchecked {\n        assembly {\n            switch n\n            case 0 {\n                z := b\n            }\n            default {\n                switch x\n                case 0 {\n                    z := 0\n                }\n                default {\n                    switch mod(n, 2)\n                    case 0 {\n                        z := b\n                    }\n                    default {\n                        z := x\n                    }\n                    let half := div(b, 2) // for rounding.\n                    for {\n                        n := div(n, 2)\n                    } n {\n                        n := div(n, 2)\n                    } {\n                        let xx := mul(x, x)\n                        if shr(128, x) {\n                            revert(0, 0)\n                        }\n                        let xxRound := add(xx, half)\n                        if lt(xxRound, xx) {\n                            revert(0, 0)\n                        }\n                        x := div(xxRound, b)\n                        if mod(n, 2) {\n                            let zx := mul(z, x)\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                                revert(0, 0)\n                            }\n                            let zxRound := add(zx, half)\n                            if lt(zxRound, zx) {\n                                revert(0, 0)\n                            }\n                            z := div(zxRound, b)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/* solhint-disable func-visibility, no-inline-assembly */\n/// @title Codex\n/// @notice `Codex` is responsible for the accounting of collateral and debt balances\n/// Uses Vat.sol from DSS (MakerDAO) / SafeEngine.sol from GEB (Reflexer Labs) as a blueprint\n/// Changes from Vat.sol / SafeEngine.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract Codex is Guarded, ICodex {\n    /// ======== Custom Errors ======== ///\n\n    error Codex__init_vaultAlreadyInit();\n    error Codex__setParam_notLive();\n    error Codex__setParam_unrecognizedParam();\n    error Codex__transferBalance_notAllowed();\n    error Codex__transferCredit_notAllowed();\n    error Codex__modifyCollateralAndDebt_notLive();\n    error Codex__modifyCollateralAndDebt_vaultNotInit();\n    error Codex__modifyCollateralAndDebt_ceilingExceeded();\n    error Codex__modifyCollateralAndDebt_notSafe();\n    error Codex__modifyCollateralAndDebt_notAllowedSender();\n    error Codex__modifyCollateralAndDebt_notAllowedCollateralizer();\n    error Codex__modifyCollateralAndDebt_notAllowedDebtor();\n    error Codex__modifyCollateralAndDebt_debtFloor();\n    error Codex__transferCollateralAndDebt_notAllowed();\n    error Codex__transferCollateralAndDebt_notSafeSrc();\n    error Codex__transferCollateralAndDebt_notSafeDst();\n    error Codex__transferCollateralAndDebt_debtFloorSrc();\n    error Codex__transferCollateralAndDebt_debtFloorDst();\n    error Codex__modifyRate_notLive();\n\n    /// ======== Storage ======== ///\n\n    // Vault Data\n    struct Vault {\n        // Total Normalised Debt in Vault [wad]\n        uint256 totalNormalDebt;\n        // Vault's Accumulation Rate [wad]\n        uint256 rate;\n        // Vault's Debt Ceiling [wad]\n        uint256 debtCeiling;\n        // Debt Floor for Positions corresponding to this Vault [wad]\n        uint256 debtFloor;\n    }\n    // Position Data\n    struct Position {\n        // Locked Collateral in Position [wad]\n        uint256 collateral;\n        // Normalised Debt (gross debt before rate is applied) generated by Position [wad]\n        uint256 normalDebt;\n    }\n\n    /// @notice Map of delegatees who can modify collateral, debt and credit on behalf of a delegator\n    /// @dev Delegator => Delegatee => hasDelegate\n    mapping(address => mapping(address => uint256)) public override delegates;\n    /// @notice Vaults\n    /// @dev Vault => Vault Data\n    mapping(address => Vault) public override vaults;\n    /// @notice Positions\n    /// @dev Vault => TokenId => Owner => Position\n    mapping(address => mapping(uint256 => mapping(address => Position))) public override positions;\n    /// @notice Token balances not put up for collateral in a Position\n    /// @dev Vault => TokenId => Owner => Balance [wad]\n    mapping(address => mapping(uint256 => mapping(address => uint256))) public override balances;\n    /// @notice Credit balances\n    /// @dev Account => Credit [wad]\n    mapping(address => uint256) public override credit;\n    /// @notice Unbacked Debt balances\n    /// @dev Account => Unbacked Debt [wad]\n    mapping(address => uint256) public override unbackedDebt;\n\n    /// @notice Global Debt (incl. rate) outstanding == Credit Issued [wad]\n    uint256 public override globalDebt;\n    /// @notice Global Unbacked Debt (incl. rate) oustanding == Total Credit [wad]\n    uint256 public override globalUnbackedDebt;\n    /// @notice Global Debt Ceiling [wad]\n    uint256 public override globalDebtCeiling;\n\n    /// @notice Boolean indicating if this contract is live (0 - not live, 1 - live)\n    uint256 public live;\n\n    /// ======== Events ======== ///\n    event Init(address indexed vault);\n    event SetParam(address indexed vault, bytes32 indexed param, uint256 data);\n    event GrantDelegate(address indexed delegator, address indexed delegatee);\n    event RevokeDelegate(address indexed delegator, address indexed delegatee);\n    event ModifyBalance(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        int256 amount,\n        uint256 balance\n    );\n    event TransferBalance(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed src,\n        address dst,\n        uint256 amount,\n        uint256 srcBalance,\n        uint256 dstBalance\n    );\n    event TransferCredit(\n        address indexed src,\n        address indexed dst,\n        uint256 amount,\n        uint256 srcCredit,\n        uint256 dstCredit\n    );\n    event ModifyCollateralAndDebt(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        address collateralizer,\n        address creditor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    );\n    event TransferCollateralAndDebt(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    );\n    event ConfiscateCollateralAndDebt(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    );\n    event SettleUnbackedDebt(address indexed debtor, uint256 debt);\n    event CreateUnbackedDebt(address indexed debtor, address indexed creditor, uint256 debt);\n    event ModifyRate(address indexed vault, address indexed creditor, int256 deltaRate);\n    event Lock();\n\n    constructor() Guarded() {\n        live = 1;\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Initializes a new Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    function init(address vault) external override checkCaller {\n        if (vaults[vault].rate != 0) revert Codex__init_vaultAlreadyInit();\n        vaults[vault].rate = WAD;\n        emit Init(vault);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (live == 0) revert Codex__setParam_notLive();\n        if (param == \"globalDebtCeiling\") globalDebtCeiling = data;\n        else revert Codex__setParam_unrecognizedParam();\n        emit SetParam(address(0), param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external override checkCaller {\n        if (live == 0) revert Codex__setParam_notLive();\n        if (param == \"debtCeiling\") vaults[vault].debtCeiling = data;\n        else if (param == \"debtFloor\") vaults[vault].debtFloor = data;\n        else revert Codex__setParam_unrecognizedParam();\n        emit SetParam(vault, param, data);\n    }\n\n    /// ======== Caller Delegation ======== ///\n\n    /// @notice Grants the delegatee the ability to modify collateral, debt and credit balances on behalf of the caller\n    /// @param delegatee Address of the delegatee\n    function grantDelegate(address delegatee) external override {\n        delegates[msg.sender][delegatee] = 1;\n        emit GrantDelegate(msg.sender, delegatee);\n    }\n\n    /// @notice Revokes the delegatee's ability to modify collateral, debt and credit balances on behalf of the caller\n    /// @param delegatee Address of the delegatee\n    function revokeDelegate(address delegatee) external override {\n        delegates[msg.sender][delegatee] = 0;\n        emit RevokeDelegate(msg.sender, delegatee);\n    }\n\n    /// @notice Checks the delegate\n    /// @param delegator Address of the delegator\n    /// @param delegatee Address of the delegatee\n    /// @return True if delegate is granted\n    function hasDelegate(address delegator, address delegatee) internal view returns (bool) {\n        return delegator == delegatee || delegates[delegator][delegatee] == 1;\n    }\n\n    /// ======== Credit and Token Balance Administration ======== ///\n\n    /// @notice Updates the token balance for a `user`\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param user Address of the user\n    /// @param amount Amount to add (positive) or subtract (negative) [wad]\n    function modifyBalance(\n        address vault,\n        uint256 tokenId,\n        address user,\n        int256 amount\n    ) external override checkCaller {\n        balances[vault][tokenId][user] = add(balances[vault][tokenId][user], amount);\n        emit ModifyBalance(vault, tokenId, user, amount, balances[vault][tokenId][user]);\n    }\n\n    /// @notice Transfer an `amount` of tokens from `src` to `dst`\n    /// @dev Sender has to be delegated by `src`\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param src From address\n    /// @param dst To address\n    /// @param amount Amount to be transferred [wad]\n    function transferBalance(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        uint256 amount\n    ) external override {\n        if (!hasDelegate(src, msg.sender)) revert Codex__transferBalance_notAllowed();\n        balances[vault][tokenId][src] = sub(balances[vault][tokenId][src], amount);\n        balances[vault][tokenId][dst] = add(balances[vault][tokenId][dst], amount);\n        emit TransferBalance(\n            vault,\n            tokenId,\n            src,\n            dst,\n            amount,\n            balances[vault][tokenId][src],\n            balances[vault][tokenId][dst]\n        );\n    }\n\n    /// @notice Transfer an `amount` of Credit from `src` to `dst`\n    /// @dev Sender has to be delegated by `src`\n    /// @param src From address\n    /// @param dst To address\n    /// @param amount Amount to be transferred [wad]\n    function transferCredit(\n        address src,\n        address dst,\n        uint256 amount\n    ) external override {\n        if (!hasDelegate(src, msg.sender)) revert Codex__transferCredit_notAllowed();\n        credit[src] = sub(credit[src], amount);\n        credit[dst] = add(credit[dst], amount);\n        emit TransferCredit(src, dst, amount, credit[src], credit[dst]);\n    }\n\n    /// ======== Position Administration ======== ///\n\n    /// @notice Modifies a Position's collateral and debt balances\n    /// @dev Checks that the global debt ceiling and the vault's debt ceiling have not been exceeded,\n    /// that the Position is still safe after the modification,\n    /// that the sender is delegated by the owner if the collateral-to-debt ratio decreased,\n    /// that the sender is delegated by the collateralizer if new collateral is put up,\n    /// that the sender is delegated by the creditor if debt is settled,\n    /// and that the vault debt floor is exceeded\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param user Address of the user\n    /// @param collateralizer Address of who puts up or receives the collateral delta\n    /// @param creditor Address of who provides or receives the credit delta for the debt delta\n    /// @param deltaCollateral Amount of collateral to put up (+) for or remove (-) from this Position [wad]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) on this Position [wad]\n    function modifyCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address creditor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external override {\n        // system is live\n        if (live == 0) revert Codex__modifyCollateralAndDebt_notLive();\n\n        Position memory p = positions[vault][tokenId][user];\n        Vault memory v = vaults[vault];\n        // vault has been initialised\n        if (v.rate == 0) revert Codex__modifyCollateralAndDebt_vaultNotInit();\n\n        p.collateral = add(p.collateral, deltaCollateral);\n        p.normalDebt = add(p.normalDebt, deltaNormalDebt);\n        v.totalNormalDebt = add(v.totalNormalDebt, deltaNormalDebt);\n\n        int256 deltaDebt = wmul(v.rate, deltaNormalDebt);\n        uint256 debt = wmul(v.rate, p.normalDebt);\n        globalDebt = add(globalDebt, deltaDebt);\n\n        // either debt has decreased, or debt ceilings are not exceeded\n        if (deltaNormalDebt > 0 && (wmul(v.totalNormalDebt, v.rate) > v.debtCeiling || globalDebt > globalDebtCeiling))\n            revert Codex__modifyCollateralAndDebt_ceilingExceeded();\n        // position is either less risky than before, or it is safe\n        if (\n            (deltaNormalDebt > 0 || deltaCollateral < 0) &&\n            debt > wmul(p.collateral, IVault(vault).fairPrice(tokenId, true, false))\n        ) revert Codex__modifyCollateralAndDebt_notSafe();\n\n        // position is either more safe, or the owner consents\n        if ((deltaNormalDebt > 0 || deltaCollateral < 0) && !hasDelegate(user, msg.sender))\n            revert Codex__modifyCollateralAndDebt_notAllowedSender();\n        // collateralizer consents if new collateral is put up\n        if (deltaCollateral > 0 && !hasDelegate(collateralizer, msg.sender))\n            revert Codex__modifyCollateralAndDebt_notAllowedCollateralizer();\n\n        // creditor consents if debt is settled with credit\n        if (deltaNormalDebt < 0 && !hasDelegate(creditor, msg.sender))\n            revert Codex__modifyCollateralAndDebt_notAllowedDebtor();\n\n        // position has no debt, or a non-dusty amount\n        if (p.normalDebt != 0 && debt < v.debtFloor) revert Codex__modifyCollateralAndDebt_debtFloor();\n\n        balances[vault][tokenId][collateralizer] = sub(balances[vault][tokenId][collateralizer], deltaCollateral);\n        credit[creditor] = add(credit[creditor], deltaDebt);\n\n        positions[vault][tokenId][user] = p;\n        vaults[vault] = v;\n\n        emit ModifyCollateralAndDebt(vault, tokenId, user, collateralizer, creditor, deltaCollateral, deltaNormalDebt);\n    }\n\n    /// @notice Transfers a Position's collateral and debt balances to another Position\n    /// @dev Checks that the sender is delegated by `src` and `dst` Position owners,\n    /// that the `src` and `dst` Positions are still safe after the transfer,\n    /// and that the `src` and `dst` Positions' debt exceed the vault's debt floor\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param src Address of the `src` Positions owner\n    /// @param dst Address of the `dst` Positions owner\n    /// @param deltaCollateral Amount of collateral to send to (+) or from (-) the `src` Position [wad]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to send to (+) or\n    /// from (-) the `dst` Position [wad]\n    function transferCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external override {\n        Position storage pSrc = positions[vault][tokenId][src];\n        Position storage pDst = positions[vault][tokenId][dst];\n        Vault storage v = vaults[vault];\n\n        pSrc.collateral = sub(pSrc.collateral, deltaCollateral);\n        pSrc.normalDebt = sub(pSrc.normalDebt, deltaNormalDebt);\n        pDst.collateral = add(pDst.collateral, deltaCollateral);\n        pDst.normalDebt = add(pDst.normalDebt, deltaNormalDebt);\n\n        uint256 debtSrc = wmul(pSrc.normalDebt, v.rate);\n        uint256 debtDst = wmul(pDst.normalDebt, v.rate);\n\n        // both sides consent\n        if (!hasDelegate(src, msg.sender) || !hasDelegate(dst, msg.sender))\n            revert Codex__transferCollateralAndDebt_notAllowed();\n\n        // both sides safe\n        if (debtSrc > wmul(pSrc.collateral, IVault(vault).fairPrice(tokenId, true, false)))\n            revert Codex__transferCollateralAndDebt_notSafeSrc();\n        if (debtDst > wmul(pDst.collateral, IVault(vault).fairPrice(tokenId, true, false)))\n            revert Codex__transferCollateralAndDebt_notSafeDst();\n\n        // both sides non-dusty\n        if (pSrc.normalDebt != 0 && debtSrc < v.debtFloor) revert Codex__transferCollateralAndDebt_debtFloorSrc();\n        if (pDst.normalDebt != 0 && debtDst < v.debtFloor) revert Codex__transferCollateralAndDebt_debtFloorDst();\n\n        emit TransferCollateralAndDebt(vault, tokenId, src, dst, deltaCollateral, deltaNormalDebt);\n    }\n\n    /// @notice Confiscates a Position's collateral and debt balances\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param user Address of the user\n    /// @param collateralizer Address of who puts up or receives the collateral delta\n    /// @param debtor Address of who provides or receives the debt delta\n    /// @param deltaCollateral Amount of collateral to put up (+) for or remove (-) from this Position [wad]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) on this Position [wad]\n    function confiscateCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external override checkCaller {\n        Position storage position = positions[vault][tokenId][user];\n        Vault storage v = vaults[vault];\n\n        position.collateral = add(position.collateral, deltaCollateral);\n        position.normalDebt = add(position.normalDebt, deltaNormalDebt);\n        v.totalNormalDebt = add(v.totalNormalDebt, deltaNormalDebt);\n\n        int256 deltaDebt = wmul(v.rate, deltaNormalDebt);\n\n        balances[vault][tokenId][collateralizer] = sub(balances[vault][tokenId][collateralizer], deltaCollateral);\n        unbackedDebt[debtor] = sub(unbackedDebt[debtor], deltaDebt);\n        globalUnbackedDebt = sub(globalUnbackedDebt, deltaDebt);\n\n        emit ConfiscateCollateralAndDebt(\n            vault,\n            tokenId,\n            user,\n            collateralizer,\n            debtor,\n            deltaCollateral,\n            deltaNormalDebt\n        );\n    }\n\n    /// ======== Unbacked Debt ======== ///\n\n    /// @notice Settles unbacked debt with the sender's credit\n    /// @dev Reverts if the sender does not have sufficient credit available to settle the debt\n    /// @param debt Amount of debt to settle [wawd]\n    function settleUnbackedDebt(uint256 debt) external override {\n        address debtor = msg.sender;\n        unbackedDebt[debtor] = sub(unbackedDebt[debtor], debt);\n        credit[debtor] = sub(credit[debtor], debt);\n        globalUnbackedDebt = sub(globalUnbackedDebt, debt);\n        globalDebt = sub(globalDebt, debt);\n        emit SettleUnbackedDebt(debtor, debt);\n    }\n\n    /// @notice Create unbacked debt / credit\n    /// @dev Sender has to be allowed to call this method\n    /// @param debtor Address of the account who takes the unbacked debt\n    /// @param creditor Address of the account who gets the credit\n    /// @param debt Amount of unbacked debt / credit to generate [wad]\n    function createUnbackedDebt(\n        address debtor,\n        address creditor,\n        uint256 debt\n    ) external override checkCaller {\n        unbackedDebt[debtor] = add(unbackedDebt[debtor], debt);\n        credit[creditor] = add(credit[creditor], debt);\n        globalUnbackedDebt = add(globalUnbackedDebt, debt);\n        globalDebt = add(globalDebt, debt);\n        emit CreateUnbackedDebt(debtor, creditor, debt);\n    }\n\n    /// ======== Debt Interest Rates ======== ///\n\n    /// @notice Updates the rate value and collects the accrued interest for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the vault\n    /// @param creditor Address of the account who gets the accrued interest\n    /// @param deltaRate Delta to increase (+) or decrease (-) the rate [percentage in wad]\n    function modifyRate(\n        address vault,\n        address creditor,\n        int256 deltaRate\n    ) external override checkCaller {\n        if (live == 0) revert Codex__modifyRate_notLive();\n        Vault storage v = vaults[vault];\n        v.rate = add(v.rate, deltaRate);\n        int256 wad = wmul(v.totalNormalDebt, deltaRate);\n        credit[creditor] = add(credit[creditor], wad);\n        globalDebt = add(globalDebt, wad);\n        emit ModifyRate(vault, creditor, deltaRate);\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Locks the contract\n    /// @dev Sender has to be allowed to call this method\n    function lock() external override checkCaller {\n        live = 0;\n        emit Lock();\n    }\n}// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\ninterface IDebtAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function tokenToSellBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function aer() external view returns (address);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(\n        address recipient,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock() external;\n\n    function cancelAuction(uint256 id) external;\n}\ninterface ISurplusAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(uint256 creditToSell, uint256 bid) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 creditToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock(uint256 credit) external;\n\n    function cancelAuction(uint256 id) external;\n}\n\ninterface IAer {\n    function codex() external view returns (ICodex);\n\n    function surplusAuction() external view returns (ISurplusAuction);\n\n    function debtAuction() external view returns (IDebtAuction);\n\n    function debtQueue(uint256) external view returns (uint256);\n\n    function queuedDebt() external view returns (uint256);\n\n    function debtOnAuction() external view returns (uint256);\n\n    function auctionDelay() external view returns (uint256);\n\n    function debtAuctionSellSize() external view returns (uint256);\n\n    function debtAuctionBidSize() external view returns (uint256);\n\n    function surplusAuctionSellSize() external view returns (uint256);\n\n    function surplusBuffer() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function queueDebt(uint256 debt) external;\n\n    function unqueueDebt(uint256 queuedAt) external;\n\n    function settleDebtWithSurplus(uint256 debt) external;\n\n    function settleAuctionedDebt(uint256 debt) external;\n\n    function startDebtAuction() external returns (uint256 auctionId);\n\n    function startSurplusAuction() external returns (uint256 auctionId);\n\n    function transferCredit(address to, uint256 credit) external;\n\n    function lock() external;\n}interface IPublican {\n    function vaults(address vault) external view returns (uint256, uint256);\n\n    function codex() external view returns (ICodex);\n\n    function aer() external view returns (IAer);\n\n    function baseInterest() external view returns (uint256);\n\n    function init(address vault) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function virtualRate(address vault) external returns (uint256 rate);\n\n    function collect(address vault) external returns (uint256 rate);\n}\n\n/// @title Publican\n/// @notice `Publican` is responsible for setting the debt interest rate and collecting interest\n/// Uses Jug.sol from DSS (MakerDAO) / TaxCollector.sol from GEB (Reflexer Labs) as a blueprint\n/// Changes from Jug.sol / TaxCollector.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - configuration by Vaults\ncontract Publican is Guarded, IPublican {\n    /// ======== Custom Errors ======== ///\n\n    error Publican__init_vaultAlreadyInit();\n    error Publican__setParam_notCollected();\n    error Publican__setParam_unrecognizedParam();\n    error Publican__collect_invalidBlockTimestamp();\n\n    /// ======== Storage ======== ///\n\n    // Vault specific configuration data\n    struct VaultConfig {\n        // Collateral-specific, per-second stability fee contribution [wad]\n        uint256 interestPerSecond;\n        // Time of last drip [unix epoch time]\n        uint256 lastCollected;\n    }\n\n    /// @notice Vault Configs\n    /// @dev Vault => Vault Config\n    mapping(address => VaultConfig) public override vaults;\n\n    /// @notice Codex\n    ICodex public immutable override codex;\n    /// @notice Aer\n    IAer public override aer;\n\n    /// @notice Global, per-second stability fee contribution [wad]\n    uint256 public override baseInterest;\n\n    /// ======== Events ======== ///\n    event Init(address indexed vault);\n    event SetParam(address indexed vault, bytes32 indexed param, uint256 data);\n    event SetParam(bytes32 indexed param, address indexed data);\n    event Collect(address indexed vault);\n\n    constructor(address codex_) Guarded() {\n        codex = ICodex(codex_);\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Initializes a new Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    function init(address vault) external override checkCaller {\n        VaultConfig storage v = vaults[vault];\n        if (v.interestPerSecond != 0) revert Publican__init_vaultAlreadyInit();\n        v.interestPerSecond = WAD;\n        v.lastCollected = block.timestamp;\n        emit Init(vault);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external override checkCaller {\n        if (block.timestamp != vaults[vault].lastCollected) revert Publican__setParam_notCollected();\n        if (param == \"interestPerSecond\") vaults[vault].interestPerSecond = data;\n        else revert Publican__setParam_unrecognizedParam();\n        emit SetParam(vault, param, data);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (param == \"baseInterest\") baseInterest = data;\n        else revert Publican__setParam_unrecognizedParam();\n        emit SetParam(address(0), param, data);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(bytes32 param, address data) external override checkCaller {\n        if (param == \"aer\") aer = IAer(data);\n        else revert Publican__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== Interest Rates ======== ///\n\n    /// @notice Returns the up to date rate (virtual rate) for a given vault as the rate stored in Codex\n    /// might be outdated\n    /// @param vault Address of the Vault\n    /// @return rate Virtual rate\n    function virtualRate(address vault) external view override returns (uint256 rate) {\n        (, uint256 prev, , ) = codex.vaults(vault);\n        if (block.timestamp < vaults[vault].lastCollected) return prev;\n        rate = wmul(\n            wpow(\n                add(baseInterest, vaults[vault].interestPerSecond),\n                sub(block.timestamp, vaults[vault].lastCollected),\n                WAD\n            ),\n            prev\n        );\n    }\n\n    /// @notice Collects accrued interest from all Position on a Vault by updating the Vault's rate\n    /// @param vault Address of the Vault\n    /// @return rate Set rate\n    function collect(address vault) public override returns (uint256 rate) {\n        if (block.timestamp < vaults[vault].lastCollected) revert Publican__collect_invalidBlockTimestamp();\n        (, uint256 prev, , ) = codex.vaults(vault);\n        rate = wmul(\n            wpow(\n                add(baseInterest, vaults[vault].interestPerSecond),\n                sub(block.timestamp, vaults[vault].lastCollected),\n                WAD\n            ),\n            prev\n        );\n        codex.modifyRate(vault, address(aer), diff(rate, prev));\n        vaults[vault].lastCollected = block.timestamp;\n        emit Collect(vault);\n    }\n\n    /// @notice Batches interest collection. See `collect(address vault)`.\n    /// @param vaults_ Array of Vault addresses\n    /// @return rates Set rates for each updated Vault\n    function collectMany(address[] memory vaults_) external returns (uint256[] memory) {\n        uint256[] memory rates = new uint256[](vaults_.length);\n        for (uint256 i = 0; i < vaults_.length; i++) {\n            rates[i] = collect(vaults_[i]);\n        }\n        return rates;\n    }\n}// Copyright (C) 2020-2021 Maker Ecosystem Growth Holdings, INC.\n\ninterface IPriceCalculator {\n    // 1st arg: initial price [wad]\n    // 2nd arg: seconds since auction start [seconds]\n    // returns: current auction price [wad]\n    function price(uint256, uint256) external view returns (uint256);\n}\n\n\n\ninterface ILimes {\n    function codex() external view returns (ICodex);\n\n    function aer() external view returns (IAer);\n\n    function vaults(address)\n        external\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function live() external view returns (uint256);\n\n    function globalMaxDebtOnAuction() external view returns (uint256);\n\n    function globalDebtOnAuction() external view returns (uint256);\n\n    function setParam(bytes32 param, address data) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        address collateralAuction\n    ) external;\n\n    function liquidationPenalty(address vault) external view returns (uint256);\n\n    function liquidate(\n        address vault,\n        uint256 tokenId,\n        address position,\n        address keeper\n    ) external returns (uint256 auctionId);\n\n    function liquidated(\n        address vault,\n        uint256 tokenId,\n        uint256 debt\n    ) external;\n\n    function lock() external;\n}\n\ninterface CollateralAuctionCallee {\n    function collateralAuctionCall(\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external;\n}\n\ninterface ICollateralAuction {\n    function vaults(address)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            ICollybus,\n            IPriceCalculator\n        );\n\n    function codex() external view returns (ICodex);\n\n    function limes() external view returns (ILimes);\n\n    function aer() external view returns (IAer);\n\n    function feeTip() external view returns (uint64);\n\n    function flatTip() external view returns (uint192);\n\n    function auctionCounter() external view returns (uint256);\n\n    function activeAuctions(uint256) external view returns (uint256);\n\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            address,\n            uint96,\n            uint256\n        );\n\n    function stopped() external view returns (uint256);\n\n    function init(address vault, address collybus) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        address data\n    ) external;\n\n    function startAuction(\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address keeper\n    ) external returns (uint256 auctionId);\n\n    function redoAuction(uint256 auctionId, address keeper) external;\n\n    function takeCollateral(\n        uint256 auctionId,\n        uint256 collateralAmount,\n        uint256 maxPrice,\n        address recipient,\n        bytes calldata data\n    ) external;\n\n    function count() external view returns (uint256);\n\n    function list() external view returns (uint256[] memory);\n\n    function getStatus(uint256 auctionId)\n        external\n        view\n        returns (\n            bool needsRedo,\n            uint256 price,\n            uint256 collateralToSell,\n            uint256 debt\n        );\n\n    function updateAuctionDebtFloor(address vault) external;\n\n    function cancelAuction(uint256 auctionId) external;\n}\n\n/// @title Limes\n/// @notice `Limes` is responsible for triggering liquidations of unsafe Positions and\n/// putting the Position's collateral up for auction\n/// Uses Dog.sol from DSS (MakerDAO) as a blueprint\n/// Changes from Dog.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract Limes is Guarded, ILimes {\n    /// ======== Custom Errors ======== ///\n\n    error Limes__setParam_liquidationPenaltyLtWad();\n    error Limes__setParam_unrecognizedParam();\n    error Limes__liquidate_notLive();\n    error Limes__liquidate_notUnsafe();\n    error Limes__liquidate_maxDebtOnAuction();\n    error Limes__liquidate_dustyAuctionFromPartialLiquidation();\n    error Limes__liquidate_nullAuction();\n    error Limes__liquidate_overflow();\n\n    /// ======== Storage ======== ///\n\n    // Vault specific configuration data\n    struct VaultConfig {\n        // Auction contract for collateral\n        address collateralAuction;\n        // Liquidation penalty [wad]\n        uint256 liquidationPenalty;\n        // Max credit needed to cover debt+fees of active auctions per vault [wad]\n        uint256 maxDebtOnAuction;\n        // Amount of credit needed to cover debt+fees for all active auctions per vault [wad]\n        uint256 debtOnAuction;\n    }\n\n    /// @notice Vault Configs\n    /// @dev Vault => Vault Config\n    mapping(address => VaultConfig) public override vaults;\n\n    /// @notice Codex\n    ICodex public immutable override codex;\n    /// @notice Aer\n    IAer public override aer;\n\n    /// @notice Max credit needed to cover debt+fees of active auctions [wad]\n    uint256 public override globalMaxDebtOnAuction;\n    /// @notice Amount of credit needed to cover debt+fees for all active auctions [wad]\n    uint256 public override globalDebtOnAuction;\n\n    /// @notice Boolean indicating if this contract is live (0 - not live, 1 - live)\n    uint256 public override live;\n\n    /// ======== Events ======== ///\n\n    event SetParam(bytes32 indexed param, uint256 data);\n    event SetParam(bytes32 indexed param, address data);\n    event SetParam(address indexed vault, bytes32 indexed param, uint256 data);\n    event SetParam(address indexed vault, bytes32 indexed param, address collateralAuction);\n\n    event Liquidate(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address position,\n        uint256 collateral,\n        uint256 normalDebt,\n        uint256 due,\n        address collateralAuction,\n        uint256 indexed auctionId\n    );\n    event Liquidated(address indexed vault, uint256 indexed tokenId, uint256 debt);\n    event Lock();\n\n    constructor(address codex_) Guarded() {\n        codex = ICodex(codex_);\n        live = 1;\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(bytes32 param, address data) external override checkCaller {\n        if (param == \"aer\") aer = IAer(data);\n        else revert Limes__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (param == \"globalMaxDebtOnAuction\") globalMaxDebtOnAuction = data;\n        else revert Limes__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external override checkCaller {\n        if (param == \"liquidationPenalty\") {\n            if (data < WAD) revert Limes__setParam_liquidationPenaltyLtWad();\n            vaults[vault].liquidationPenalty = data;\n        } else if (param == \"maxDebtOnAuction\") vaults[vault].maxDebtOnAuction = data;\n        else revert Limes__setParam_unrecognizedParam();\n        emit SetParam(vault, param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(\n        address vault,\n        bytes32 param,\n        address data\n    ) external override checkCaller {\n        if (param == \"collateralAuction\") {\n            vaults[vault].collateralAuction = data;\n        } else revert Limes__setParam_unrecognizedParam();\n        emit SetParam(vault, param, data);\n    }\n\n    /// ======== Liquidations ======== ///\n\n    /// @notice Direct access to the current liquidation penalty set for a Vault\n    /// @param vault Address of the Vault\n    /// @return liquidation penalty [wad]\n    function liquidationPenalty(address vault) external view override returns (uint256) {\n        return vaults[vault].liquidationPenalty;\n    }\n\n    /// @notice Liquidate a Position and start a Dutch auction to sell its collateral for credit.\n    /// @dev The third argument is the address that will receive the liquidation reward, if any.\n    /// The entire Position will be liquidated except when the target amount of credit to be raised in\n    /// the resulting auction (debt of Position + liquidation penalty) causes either globalDebtOnAuction to exceed\n    /// globalMaxDebtOnAuction or vault.debtOnAuction to exceed vault.maxDebtOnAuction by an economically\n    /// significant amount. In that case, a partial liquidation is performed to respect the global and per-vault limits\n    /// on outstanding credit target. The one exception is if the resulting auction would likely\n    /// have too little collateral to be of interest to Keepers (debt taken from Position < vault.debtFloor),\n    /// in which case the function reverts. Please refer to the code and comments within if more detail is desired.\n    /// @param vault Address of the Position's Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20) of the Position\n    /// @param position Address of the owner of the Position\n    /// @param keeper Address of the keeper who triggers the liquidation and receives the reward\n    /// @return auctionId Indentifier of the started auction\n    function liquidate(\n        address vault,\n        uint256 tokenId,\n        address position,\n        address keeper\n    ) external override returns (uint256 auctionId) {\n        if (live == 0) revert Limes__liquidate_notLive();\n\n        VaultConfig memory mvault = vaults[vault];\n        uint256 deltaNormalDebt;\n        uint256 rate;\n        uint256 debtFloor;\n        uint256 deltaCollateral;\n        unchecked {\n            {\n                (uint256 collateral, uint256 normalDebt) = codex.positions(vault, tokenId, position);\n                uint256 price = IVault(vault).fairPrice(tokenId, true, false);\n                (, rate, , debtFloor) = codex.vaults(vault);\n                if (price == 0 || mul(collateral, price) >= mul(normalDebt, rate)) revert Limes__liquidate_notUnsafe();\n\n                // Get the minimum value between:\n                // 1) Remaining space in the globalMaxDebtOnAuction\n                // 2) Remaining space in the vault.maxDebtOnAuction\n                if (!(globalMaxDebtOnAuction > globalDebtOnAuction && mvault.maxDebtOnAuction > mvault.debtOnAuction))\n                    revert Limes__liquidate_maxDebtOnAuction();\n\n                uint256 room = min(\n                    globalMaxDebtOnAuction - globalDebtOnAuction,\n                    mvault.maxDebtOnAuction - mvault.debtOnAuction\n                );\n\n                // normalize room by subtracting rate and liquidationPenalty\n                deltaNormalDebt = min(normalDebt, (((room * WAD) / rate) * WAD) / mvault.liquidationPenalty);\n\n                // Partial liquidation edge case logic\n                if (normalDebt > deltaNormalDebt) {\n                    if (wmul(normalDebt - deltaNormalDebt, rate) < debtFloor) {\n                        // If the leftover Position would be dusty, just liquidate it entirely.\n                        // This will result in at least one of v.debtOnAuction > v.maxDebtOnAuction or\n                        // globalDebtOnAuction > globalMaxDebtOnAuction becoming true. The amount of excess will\n                        // be bounded above by ceiling(v.debtFloor * v.liquidationPenalty / WAD). This deviation is\n                        // assumed to be small compared to both v.maxDebtOnAuction and globalMaxDebtOnAuction, so that\n                        // the extra amount of credit is not of economic concern.\n                        deltaNormalDebt = normalDebt;\n                    } else {\n                        // In a partial liquidation, the resulting auction should also be non-dusty.\n                        if (wmul(deltaNormalDebt, rate) < debtFloor)\n                            revert Limes__liquidate_dustyAuctionFromPartialLiquidation();\n                    }\n                }\n\n                deltaCollateral = mul(collateral, deltaNormalDebt) / normalDebt;\n            }\n        }\n\n        if (deltaCollateral == 0) revert Limes__liquidate_nullAuction();\n        if (!(deltaNormalDebt <= 2**255 && deltaCollateral <= 2**255)) revert Limes__liquidate_overflow();\n\n        codex.confiscateCollateralAndDebt(\n            vault,\n            tokenId,\n            position,\n            mvault.collateralAuction,\n            address(aer),\n            -int256(deltaCollateral),\n            -int256(deltaNormalDebt)\n        );\n\n        uint256 due = wmul(deltaNormalDebt, rate);\n        aer.queueDebt(due);\n\n        {\n            // Avoid stack too deep\n            // This calcuation will overflow if deltaNormalDebt*rate exceeds ~10^14\n            uint256 debt = wmul(due, mvault.liquidationPenalty);\n            globalDebtOnAuction = add(globalDebtOnAuction, debt);\n            vaults[vault].debtOnAuction = add(mvault.debtOnAuction, debt);\n\n            auctionId = ICollateralAuction(mvault.collateralAuction).startAuction({\n                debt: debt,\n                collateralToSell: deltaCollateral,\n                vault: vault,\n                tokenId: tokenId,\n                user: position,\n                keeper: keeper\n            });\n        }\n\n        emit Liquidate(\n            vault,\n            tokenId,\n            position,\n            deltaCollateral,\n            deltaNormalDebt,\n            due,\n            mvault.collateralAuction,\n            auctionId\n        );\n    }\n\n    /// @notice Marks the liquidated Position's debt as sold\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the liquidated Position's Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20) of the liquidated Position\n    /// @param debt Amount of debt sold\n    function liquidated(\n        address vault,\n        uint256 tokenId,\n        uint256 debt\n    ) external override checkCaller {\n        globalDebtOnAuction = sub(globalDebtOnAuction, debt);\n        vaults[vault].debtOnAuction = sub(vaults[vault].debtOnAuction, debt);\n        emit Liquidated(vault, tokenId, debt);\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Locks the contract\n    /// @dev Sender has to be allowed to call this method\n    function lock() external override checkCaller {\n        live = 0;\n        emit Lock();\n    }\n}/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y\u00f71e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)\u00f7denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n/// @title PRBMathUD60x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\n/// maximum values permitted by the Solidity type uint256.\nlibrary PRBMathUD60x18 {\n    /// @dev Half the SCALE number.\n    uint256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\n    uint256 internal constant LOG2_E = 1_442695040888963407;\n\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\n\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_WHOLE_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // The operations can never overflow.\n        unchecked {\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function ceil(uint256 x) internal pure returns (uint256 result) {\n        if (x > MAX_WHOLE_UD60x18) {\n            revert PRBMathUD60x18__CeilOverflow(x);\n        }\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"SCALE - remainder\" but faster.\n            let delta := sub(SCALE, remainder)\n\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\n            result := add(x, mul(delta, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\n    ///\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    ///\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDiv(x, SCALE, y);\n    }\n\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (uint256 result) {\n        result = 2_718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp(uint256 x) internal pure returns (uint256 result) {\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133_084258667509499441) {\n            revert PRBMathUD60x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            uint256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (x >= 192e18) {\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x192x64 = (x << 64) / SCALE;\n\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\n            result = PRBMath.exp2(x192x64);\n        }\n    }\n\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function floor(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\n            result := sub(x, mul(remainder, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x.\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\n    function frac(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            result := mod(x, SCALE)\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__FromUintOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\n    ///\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            uint256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathUD60x18__GmOverflow(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = PRBMath.sqrt(xy);\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding toward zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\n    function inv(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\n    function ln(uint256 x) internal pure returns (uint256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 196205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log10(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\n        // in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\n            default {\n                result := MAX_UD60x18\n            }\n        }\n\n        if (result == MAX_UD60x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3_321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\n    ///\n    /// Caveats:\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log2(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\n\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255 and SCALE is 1e18.\n            result = n * SCALE;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n        }\n    }\n\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\n    /// fixed-point number.\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDivFixedPoint(x, y);\n    }\n\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\n    function pi() internal pure returns (uint256 result) {\n        result = 3_141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : uint256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// Caveats:\n    /// - All from \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // Calculate the first iteration of the loop in advance.\n        result = y & 1 > 0 ? x : SCALE;\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        for (y >>= 1; y > 0; y >>= 1) {\n            x = PRBMath.mulDivFixedPoint(x, x);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (y & 1 > 0) {\n                result = PRBMath.mulDivFixedPoint(result, x);\n            }\n        }\n    }\n\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\n    function scale() internal pure returns (uint256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x must be less than MAX_UD60x18 / SCALE.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = PRBMath.sqrt(x * SCALE);\n        }\n    }\n\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n\n\n/// @title Collybus\n/// @notice `Collybus` stores a spot price and discount rate for every Vault / asset.\ncontract Collybus is Guarded, ICollybus {\n    /// ======== Custom Errors ======== ///\n\n    error Collybus__setParam_notLive();\n    error Collybus__setParam_unrecognizedParam();\n    error Collybus__updateSpot_notLive();\n    error Collybus__updateDiscountRate_notLive();\n    error Collybus__updateDiscountRate_invalidRateId();\n    error Collybus__updateDiscountRate_invalidRate();\n\n    using PRBMathUD60x18 for uint256;\n\n    /// ======== Storage ======== ///\n\n    struct VaultConfig {\n        // Liquidation ratio [wad]\n        uint128 liquidationRatio;\n        // Default fixed interest rate oracle system rateId\n        uint128 defaultRateId;\n    }\n\n    /// @notice Vault Configuration\n    /// @dev Vault => Vault Config\n    mapping(address => VaultConfig) public override vaults;\n    /// @notice Spot prices by token address\n    /// @dev Token address => spot price [wad]\n    mapping(address => uint256) public override spots;\n    /// @notice Fixed interest rate oracle system rateId\n    /// @dev RateId => Discount Rate [wad]\n    mapping(uint256 => uint256) public override rates;\n    // Fixed interest rate oracle system rateId for each TokenId\n    // Vault => TokenId => RateId\n    mapping(address => mapping(uint256 => uint256)) public override rateIds;\n\n    /// @notice Redemption Price of a Credit unit [wad]\n    uint256 public immutable override redemptionPrice;\n\n    /// @notice Boolean indicating if this contract is live (0 - not live, 1 - live)\n    uint256 public override live;\n\n    /// ======== Events ======== ///\n    event SetParam(bytes32 indexed param, uint256 data);\n    event SetParam(address indexed vault, bytes32 indexed param, uint256 data);\n    event SetParam(address indexed vault, uint256 indexed tokenId, bytes32 indexed param, uint256 data);\n    event UpdateSpot(address indexed token, uint256 spot);\n    event UpdateDiscountRate(uint256 indexed rateId, uint256 rate);\n    event Lock();\n\n    // TODO: why not making timeScale and redemption price function arguments?\n    constructor() Guarded() {\n        redemptionPrice = WAD; // 1.0\n        live = 1;\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (live == 0) revert Collybus__setParam_notLive();\n        if (param == \"live\") live = data;\n        else revert Collybus__setParam_unrecognizedParam();\n        emit SetParam(address(0), param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint128 data\n    ) external override checkCaller {\n        if (live == 0) revert Collybus__setParam_notLive();\n        if (param == \"liquidationRatio\") vaults[vault].liquidationRatio = data;\n        else if (param == \"defaultRateId\") vaults[vault].defaultRateId = data;\n        else revert Collybus__setParam_unrecognizedParam();\n        emit SetParam(vault, param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        uint256 tokenId,\n        bytes32 param,\n        uint256 data\n    ) external override checkCaller {\n        if (live == 0) revert Collybus__setParam_notLive();\n        if (param == \"rateId\") rateIds[vault][tokenId] = data;\n        else revert Collybus__setParam_unrecognizedParam();\n        emit SetParam(vault, tokenId, param, data);\n    }\n\n    /// ======== Spot Prices ======== ///\n\n    /// @notice Sets a token's spot price\n    /// @dev Sender has to be allowed to call this method\n    /// @param token Address of the token\n    /// @param spot Spot price [wad]\n    function updateSpot(address token, uint256 spot) external override checkCaller {\n        if (live == 0) revert Collybus__updateSpot_notLive();\n        spots[token] = spot;\n        emit UpdateSpot(token, spot);\n    }\n\n    /// ======== Discount Rate ======== ///\n\n    /// @notice Sets the discount rate by RateId\n    /// @param rateId RateId of the discount rate feed\n    /// @param rate Discount rate [wad]\n    function updateDiscountRate(uint256 rateId, uint256 rate) external override checkCaller {\n        if (live == 0) revert Collybus__updateDiscountRate_notLive();\n        if (rateId >= type(uint128).max) revert Collybus__updateDiscountRate_invalidRateId();\n        if (rate >= 2e10) revert Collybus__updateDiscountRate_invalidRate();\n        rates[rateId] = rate;\n        emit UpdateDiscountRate(rateId, rate);\n    }\n\n    /// @notice Returns the internal price for an asset\n    /// @dev\n    ///                 redemptionPrice\n    /// v = ----------------------------------------\n    ///                       (maturity - timestamp)\n    ///     (1 + discountRate)\n    ///\n    /// @param vault Address of the asset corresponding Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param maturity Maturity of the asset [unix timestamp in seconds]\n    /// @param net Boolean (true - with liquidation safety margin, false - without)\n    /// @return price Internal price [wad]\n    function read(\n        address vault,\n        address underlier,\n        uint256 tokenId,\n        uint256 maturity,\n        bool net\n    ) external view override returns (uint256 price) {\n        VaultConfig memory vaultConfig = vaults[vault];\n        // fetch applicable fixed interest rate oracle system rateId\n        uint256 rateId = rateIds[vault][tokenId];\n        if (rateId == uint256(0)) rateId = vaultConfig.defaultRateId; // if not set, use default rateId\n        // fetch discount rate\n        uint256 discountRate = rates[rateId];\n        // apply discount rate if discountRate > 0\n        if (discountRate != 0 && maturity > block.timestamp) {\n            uint256 rate = add(WAD, discountRate).powu(sub(maturity, block.timestamp));\n            price = wdiv(redemptionPrice, rate); // den. in Underlier\n        } else {\n            price = redemptionPrice; // den. in Underlier\n        }\n        price = wmul(price, spots[underlier]); // den. in USD\n        if (net) price = wdiv(price, vaultConfig.liquidationRatio); // with liquidation safety margin\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Locks the contract\n    /// @dev Sender has to be allowed to call this method\n    function lock() external override checkCaller {\n        live = 0;\n        emit Lock();\n    }\n}// Copyright (C) 2020-2021 Maker Ecosystem Growth Holdings, INC.\n\ninterface INoLossCollateralAuction {\n    function vaults(address)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            ICollybus,\n            IPriceCalculator\n        );\n\n    function codex() external view returns (ICodex);\n\n    function limes() external view returns (ILimes);\n\n    function aer() external view returns (IAer);\n\n    function feeTip() external view returns (uint64);\n\n    function flatTip() external view returns (uint192);\n\n    function auctionCounter() external view returns (uint256);\n\n    function activeAuctions(uint256) external view returns (uint256);\n\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            address,\n            uint96,\n            uint256\n        );\n\n    function stopped() external view returns (uint256);\n\n    function init(address vault, address collybus) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        address data\n    ) external;\n\n    function startAuction(\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address keeper\n    ) external returns (uint256 auctionId);\n\n    function redoAuction(uint256 auctionId, address keeper) external;\n\n    function takeCollateral(\n        uint256 auctionId,\n        uint256 collateralAmount,\n        uint256 maxPrice,\n        address recipient,\n        bytes calldata data\n    ) external;\n\n    function count() external view returns (uint256);\n\n    function list() external view returns (uint256[] memory);\n\n    function getStatus(uint256 auctionId)\n        external\n        view\n        returns (\n            bool needsRedo,\n            uint256 price,\n            uint256 collateralToSell,\n            uint256 debt\n        );\n\n    function updateAuctionDebtFloor(address vault) external;\n\n    function cancelAuction(uint256 auctionId) external;\n}\n\n/// @title NoLossCollateralAuction\n/// @notice Same as CollateralAuction but enforces a floor price of debt / collateral\n/// Uses Clip.sol from DSS (MakerDAO) as a blueprint\n/// Changes from Clip.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract NoLossCollateralAuction is Guarded, INoLossCollateralAuction {\n    /// ======== Custom Errors ======== ///\n\n    error NoLossCollateralAuction__init_vaultAlreadyInit();\n    error NoLossCollateralAuction__checkReentrancy_reentered();\n    error NoLossCollateralAuction__isStopped_stoppedIncorrect();\n    error NoLossCollateralAuction__setParam_unrecognizedParam();\n    error NoLossCollateralAuction__startAuction_zeroDebt();\n    error NoLossCollateralAuction__startAuction_zeroCollateralToSell();\n    error NoLossCollateralAuction__startAuction_zeroUser();\n    error NoLossCollateralAuction__startAuction_overflow();\n    error NoLossCollateralAuction__startAuction_zeroStartPrice();\n    error NoLossCollateralAuction__redoAuction_notRunningAuction();\n    error NoLossCollateralAuction__redoAuction_cannotReset();\n    error NoLossCollateralAuction__redoAuction_zeroStartPrice();\n    error NoLossCollateralAuction__takeCollateral_notRunningAuction();\n    error NoLossCollateralAuction__takeCollateral_needsReset();\n    error NoLossCollateralAuction__takeCollateral_tooExpensive();\n    error NoLossCollateralAuction__takeCollateral_noPartialPurchase();\n    error NoLossCollateralAuction__cancelAuction_notRunningAction();\n\n    /// ======== Storage ======== ///\n\n    // Vault specific configuration data\n    struct VaultConfig {\n        // Multiplicative factor to increase start price [wad]\n        uint256 multiplier;\n        // Time elapsed before auction reset [seconds]\n        uint256 maxAuctionDuration;\n        // Cache (v.debtFloor * v.liquidationPenalty) to prevent excessive SLOADs [wad]\n        uint256 auctionDebtFloor;\n        // Collateral price module\n        ICollybus collybus;\n        // Current price calculator\n        IPriceCalculator calculator;\n    }\n\n    /// @notice Vault Configs\n    /// @dev Vault => Vault Config\n    mapping(address => VaultConfig) public override vaults;\n\n    /// @notice Codex\n    ICodex public immutable override codex;\n    /// @notice Limes\n    ILimes public override limes;\n    /// @notice Aer (Recipient of credit raised in auctions)\n    IAer public override aer;\n    /// @notice Percentage of debt to mint from aer to incentivize keepers [wad]\n    uint64 public override feeTip;\n    /// @notice Flat fee to mint from aer to incentivize keepers [wad]\n    uint192 public override flatTip;\n    /// @notice Total auctions (includes past auctions)\n    uint256 public override auctionCounter;\n    /// @notice Array of active auction ids\n    uint256[] public override activeAuctions;\n\n    // Auction State\n    struct Auction {\n        // Index in activeAuctions array\n        uint256 index;\n        // Debt to sell == Credit to raise [wad]\n        uint256 debt;\n        // collateral to sell [wad]\n        uint256 collateralToSell;\n        // Vault of the liquidated Positions collateral\n        address vault;\n        // TokenId of the liquidated Positions collateral\n        uint256 tokenId;\n        // Owner of the liquidated Position\n        address user;\n        // Auction start time\n        uint96 startsAt;\n        // Starting price [wad]\n        uint256 startPrice;\n    }\n    /// @notice State of auctions\n    /// @dev AuctionId => Auction\n    mapping(uint256 => Auction) public override auctions;\n\n    // reentrancy guard\n    uint256 private entered;\n\n    /// @notice Circuit breaker level\n    /// Levels for circuit breaker\n    /// 0: no breaker\n    /// 1: no new startAuction()\n    /// 2: no new startAuction() or redoAuction()\n    /// 3: no new startAuction(), redoAuction(), or takeCollateral()\n    uint256 public override stopped = 0;\n\n    /// ======== Events ======== ///\n\n    event Init(address vault);\n\n    event SetParam(bytes32 indexed param, uint256 data);\n    event SetParam(bytes32 indexed param, address data);\n\n    event StartAuction(\n        uint256 indexed auctionId,\n        uint256 startPrice,\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address indexed keeper,\n        uint256 tip\n    );\n    event TakeCollateral(\n        uint256 indexed auctionId,\n        uint256 maxPrice,\n        uint256 price,\n        uint256 owe,\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address indexed user\n    );\n    event RedoAuction(\n        uint256 indexed auctionId,\n        uint256 startPrice,\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address indexed keeper,\n        uint256 tip\n    );\n\n    event StopAuction(uint256 auctionId);\n\n    event UpdateAuctionDebtFloor(address indexed vault, uint256 auctionDebtFloor);\n\n    constructor(address codex_, address limes_) Guarded() {\n        codex = ICodex(codex_);\n        limes = ILimes(limes_);\n    }\n\n    modifier checkReentrancy() {\n        if (entered == 0) {\n            entered = 1;\n            _;\n            entered = 0;\n        } else revert NoLossCollateralAuction__checkReentrancy_reentered();\n    }\n\n    modifier isStopped(uint256 level) {\n        if (stopped < level) {\n            _;\n        } else revert NoLossCollateralAuction__isStopped_stoppedIncorrect();\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Initializes a new Vault for which collateral can be auctioned off\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param collybus Address of the Collybus the Vault uses for pricing\n    function init(address vault, address collybus) external override checkCaller {\n        if (vaults[vault].calculator != IPriceCalculator(address(0)))\n            revert NoLossCollateralAuction__init_vaultAlreadyInit();\n        vaults[vault].multiplier = WAD;\n        vaults[vault].collybus = ICollybus(collybus);\n\n        emit Init(vault);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller checkReentrancy {\n        if (param == \"feeTip\")\n            feeTip = uint64(data); // Percentage of debt to incentivize (max: 2^64 - 1 => 18.xxx WAD = 18xx%)\n        else if (param == \"flatTip\")\n            flatTip = uint192(data); // Flat fee to incentivize keepers (max: 2^192 - 1 => 6.277T WAD)\n        else if (param == \"stopped\")\n            stopped = data; // Set breaker (0, 1, 2, or 3)\n        else revert NoLossCollateralAuction__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(bytes32 param, address data) external override checkCaller checkReentrancy {\n        if (param == \"limes\") limes = ILimes(data);\n        else if (param == \"aer\") aer = IAer(data);\n        else revert NoLossCollateralAuction__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external override checkCaller checkReentrancy {\n        if (param == \"multiplier\") vaults[vault].multiplier = data;\n        else if (param == \"maxAuctionDuration\")\n            vaults[vault].maxAuctionDuration = data; // Time elapsed before auction reset\n        else revert NoLossCollateralAuction__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(\n        address vault,\n        bytes32 param,\n        address data\n    ) external override checkCaller checkReentrancy {\n        if (param == \"collybus\") vaults[vault].collybus = ICollybus(data);\n        else if (param == \"calculator\") vaults[vault].calculator = IPriceCalculator(data);\n        else revert NoLossCollateralAuction__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== No Loss Collateral Auction ======== ///\n\n    // get price at maturity\n    function _getPrice(address vault, uint256 tokenId) internal view returns (uint256) {\n        return IVault(vault).fairPrice(tokenId, false, true);\n    }\n\n    /// @notice Starts a collateral auction\n    /// The start price `startPrice` is obtained as follows:\n    ///     startPrice = val * multiplier / redemptionPrice\n    /// Where `val` is the collateral's unitary value in USD, `multiplier` is a\n    /// multiplicative factor to increase the start price, and `redemptionPrice` is a reference per Credit.\n    /// @dev Sender has to be allowed to call this method\n    /// - trusts the caller to transfer collateral to the contract\n    /// - reverts if circuit breaker is set to 1 (no new auctions)\n    /// @param debt Amount of debt to sell / credit to buy [wad]\n    /// @param collateralToSell Amount of collateral to sell [wad]\n    /// @param vault Address of the collaterals Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20) of the collateral\n    /// @param user Address that will receive any leftover collateral\n    /// @param keeper Address that will receive incentives\n    /// @return auctionId Identifier of started auction\n    function startAuction(\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address keeper\n    ) external override checkCaller checkReentrancy isStopped(1) returns (uint256 auctionId) {\n        // Input validation\n        if (debt == 0) revert NoLossCollateralAuction__startAuction_zeroDebt();\n        if (collateralToSell == 0) revert NoLossCollateralAuction__startAuction_zeroCollateralToSell();\n        if (user == address(0)) revert NoLossCollateralAuction__startAuction_zeroUser();\n        unchecked {\n            auctionId = ++auctionCounter;\n        }\n        if (auctionId == 0) revert NoLossCollateralAuction__startAuction_overflow();\n\n        activeAuctions.push(auctionId);\n\n        auctions[auctionId].index = activeAuctions.length - 1;\n\n        auctions[auctionId].debt = debt;\n        auctions[auctionId].collateralToSell = collateralToSell;\n        auctions[auctionId].vault = vault;\n        auctions[auctionId].tokenId = tokenId;\n        auctions[auctionId].user = user;\n        auctions[auctionId].startsAt = uint96(block.timestamp);\n\n        uint256 startPrice;\n        startPrice = wmul(_getPrice(vault, tokenId), vaults[vault].multiplier);\n        if (startPrice <= 0) revert NoLossCollateralAuction__startAuction_zeroStartPrice();\n        auctions[auctionId].startPrice = startPrice;\n\n        // incentive to startAuction auction\n        uint256 _tip = flatTip;\n        uint256 _feeTip = feeTip;\n        uint256 tip;\n        if (_tip > 0 || _feeTip > 0) {\n            tip = add(_tip, wmul(debt, _feeTip));\n            codex.createUnbackedDebt(address(aer), keeper, tip);\n        }\n\n        emit StartAuction(auctionId, startPrice, debt, collateralToSell, vault, tokenId, user, keeper, tip);\n    }\n\n    /// @notice Resets an existing collateral auction\n    /// See `startAuction` above for an explanation of the computation of `startPrice`.\n    /// multiplicative factor to increase the start price, and `redemptionPrice` is a reference per Credit.\n    /// @dev Reverts if circuit breaker is set to 2 (no new auctions and no redos of auctions)\n    /// @param auctionId Id of the auction to reset\n    /// @param keeper Address that will receive incentives\n    function redoAuction(uint256 auctionId, address keeper) external override checkReentrancy isStopped(2) {\n        // Read auction data\n        Auction memory auction = auctions[auctionId];\n\n        if (auction.user == address(0)) revert NoLossCollateralAuction__redoAuction_notRunningAuction();\n\n        // Check that auction needs reset\n        // and compute current price [wad]\n        {\n            (bool done, ) = status(auction);\n            if (!done) revert NoLossCollateralAuction__redoAuction_cannotReset();\n        }\n\n        uint256 debt = auctions[auctionId].debt;\n        uint256 collateralToSell = auctions[auctionId].collateralToSell;\n        auctions[auctionId].startsAt = uint96(block.timestamp);\n\n        uint256 price = _getPrice(auction.vault, auction.tokenId);\n        uint256 startPrice = wmul(price, vaults[auction.vault].multiplier);\n        if (startPrice <= 0) revert NoLossCollateralAuction__redoAuction_zeroStartPrice();\n        auctions[auctionId].startPrice = startPrice;\n\n        // incentive to redoAuction auction\n        uint256 tip;\n        {\n            uint256 _tip = flatTip;\n            uint256 _feeTip = feeTip;\n            if (_tip > 0 || _feeTip > 0) {\n                uint256 _auctionDebtFloor = vaults[auction.vault].auctionDebtFloor;\n                if (debt >= _auctionDebtFloor && wmul(collateralToSell, price) >= _auctionDebtFloor) {\n                    tip = add(_tip, wmul(debt, _feeTip));\n                    codex.createUnbackedDebt(address(aer), keeper, tip);\n                }\n            }\n        }\n\n        emit RedoAuction(\n            auctionId,\n            startPrice,\n            debt,\n            collateralToSell,\n            auction.vault,\n            auction.tokenId,\n            auction.user,\n            keeper,\n            tip\n        );\n    }\n\n    /// @notice Buy up to `collateralAmount` of collateral from the auction indexed by `id`\n    ///\n    /// Auctions will not collect more Credit than their assigned Credit target,`debt`;\n    /// thus, if `collateralAmount` would cost more Credit than `debt` at the current price, the\n    /// amount of collateral purchased will instead be just enough to collect `debt` in Credit.\n    ///\n    /// To avoid partial purchases resulting in very small leftover auctions that will\n    /// never be cleared, any partial purchase must leave at least `CollateralAuction.auctionDebtFloor`\n    /// remaining Credit target. `auctionDebtFloor` is an asynchronously updated value equal to\n    /// (Codex.debtFloor * Limes.liquidationPenalty(vault) / WAD) where the values are understood to be determined\n    /// by whatever they were when CollateralAuction.updateAuctionDebtFloor() was last called. Purchase amounts\n    /// will be minimally decreased when necessary to respect this limit; i.e., if the\n    /// specified `collateralAmount` would leave `debt < auctionDebtFloor` but `debt > 0`, the amount actually\n    /// purchased will be such that `debt == auctionDebtFloor`.\n    ///\n    /// If `debt <= auctionDebtFloor`, partial purchases are no longer possible; that is, the remaining\n    /// collateral can only be purchased entirely, or not at all.\n    ///\n    /// Enforces a price floor of debt / collateral\n    ///\n    /// @dev Reverts if circuit breaker is set to 3 (no new auctions, no redos of auctions and no collateral buying)\n    /// @param auctionId Id of the auction to buy collateral from\n    /// @param collateralAmount Upper limit on amount of collateral to buy [wad]\n    /// @param maxPrice Maximum acceptable price (Credit / collateral) [wad]\n    /// @param recipient Receiver of collateral and external call address\n    /// @param data Data to pass in external call; if length 0, no call is done\n    function takeCollateral(\n        uint256 auctionId, // Auction id\n        uint256 collateralAmount, // Upper limit on amount of collateral to buy [wad]\n        uint256 maxPrice, // Maximum acceptable price (Credit / collateral) [wad]\n        address recipient, // Receiver of collateral and external call address\n        bytes calldata data // Data to pass in external call; if length 0, no call is done\n    ) external override checkReentrancy isStopped(3) {\n        Auction memory auction = auctions[auctionId];\n\n        if (auction.user == address(0)) revert NoLossCollateralAuction__takeCollateral_notRunningAuction();\n\n        uint256 price;\n        {\n            bool done;\n            (done, price) = status(auction);\n\n            // Check that auction doesn't need reset\n            if (done) revert NoLossCollateralAuction__takeCollateral_needsReset();\n            // Ensure price is acceptable to buyer\n            if (maxPrice < price) revert NoLossCollateralAuction__takeCollateral_tooExpensive();\n        }\n\n        uint256 collateralToSell = auction.collateralToSell;\n        uint256 debt = auction.debt;\n        uint256 owe;\n\n        unchecked {\n            {\n                // Purchase as much as possible, up to collateralAmount\n                // collateralSlice <= collateralToSell\n                uint256 collateralSlice = min(collateralToSell, collateralAmount);\n\n                // Credit needed to buy a collateralSlice of this auction\n                owe = wmul(collateralSlice, price);\n\n                // owe can be greater than debt and thus user would pay a premium to the recipient\n\n                if (owe < debt && collateralSlice < collateralToSell) {\n                    // If collateralSlice == collateralToSell => auction completed => debtFloor doesn't matter\n                    uint256 _auctionDebtFloor = vaults[auction.vault].auctionDebtFloor;\n                    if (debt - owe < _auctionDebtFloor) {\n                        // safe as owe < debt\n                        // If debt <= auctionDebtFloor, buyers have to take the entire collateralToSell.\n                        if (debt <= _auctionDebtFloor)\n                            revert NoLossCollateralAuction__takeCollateral_noPartialPurchase();\n                        // Adjust amount to pay\n                        owe = debt - _auctionDebtFloor; // owe' <= owe\n                        // Adjust collateralSlice\n                        // collateralSlice' = owe' / price < owe / price == collateralSlice < collateralToSell\n                        collateralSlice = wdiv(owe, price);\n                    }\n                }\n\n                // Calculate remaining collateralToSell after operation\n                collateralToSell = collateralToSell - collateralSlice;\n\n                // Send collateral to recipient\n                codex.transferBalance(auction.vault, auction.tokenId, address(this), recipient, collateralSlice);\n\n                // Do external call (if data is defined) but to be\n                // extremely careful we don't allow to do it to the two\n                // contracts which the CollateralAuction needs to be authorized\n                ILimes limes_ = limes;\n                if (data.length > 0 && recipient != address(codex) && recipient != address(limes_)) {\n                    CollateralAuctionCallee(recipient).collateralAuctionCall(msg.sender, owe, collateralSlice, data);\n                }\n\n                // Get Credit from caller\n                codex.transferCredit(msg.sender, address(aer), owe);\n\n                // Removes Credit out for liquidation from accumulator\n                // if all collateral has been sold or owe is larger than remaining debt\n                //  then just remove the remaining debt from the accumulator\n                limes_.liquidated(auction.vault, auction.tokenId, (collateralToSell == 0 || debt < owe) ? debt : owe);\n\n                // Calculate remaining debt after operation\n                debt = (owe < debt) ? debt - owe : 0; // safe since owe <= debt\n            }\n        }\n\n        if (collateralToSell == 0) {\n            _remove(auctionId);\n        } else if (debt == 0) {\n            codex.transferBalance(auction.vault, auction.tokenId, address(this), auction.user, collateralToSell);\n            _remove(auctionId);\n        } else {\n            auctions[auctionId].debt = debt;\n            auctions[auctionId].collateralToSell = collateralToSell;\n        }\n\n        emit TakeCollateral(\n            auctionId,\n            maxPrice,\n            price,\n            owe,\n            debt,\n            collateralToSell,\n            auction.vault,\n            auction.tokenId,\n            auction.user\n        );\n    }\n\n    // Removes an auction from the active auctions array\n    function _remove(uint256 auctionId) internal {\n        uint256 _move = activeAuctions[activeAuctions.length - 1];\n        if (auctionId != _move) {\n            uint256 _index = auctions[auctionId].index;\n            activeAuctions[_index] = _move;\n            auctions[_move].index = _index;\n        }\n        activeAuctions.pop();\n        delete auctions[auctionId];\n    }\n\n    /// @notice The number of active auctions\n    /// @return Number of active auctions\n    function count() external view override returns (uint256) {\n        return activeAuctions.length;\n    }\n\n    /// @notice Returns the entire array of active auctions\n    /// @return List of active auctions\n    function list() external view override returns (uint256[] memory) {\n        return activeAuctions;\n    }\n\n    /// @notice Externally returns boolean for if an auction needs a redo and also the current price\n    /// @param auctionId Id of the auction to get the status for\n    /// @return needsRedo If the auction needs a redo (max duration or max discount exceeded)\n    /// @return price Current price of the collateral determined by the calculator [wad]\n    /// @return collateralToSell Amount of collateral left to buy for credit [wad]\n    /// @return debt Amount of debt / credit to sell for collateral [wad]\n    function getStatus(uint256 auctionId)\n        external\n        view\n        override\n        returns (\n            bool needsRedo,\n            uint256 price,\n            uint256 collateralToSell,\n            uint256 debt\n        )\n    {\n        Auction memory auction = auctions[auctionId];\n\n        bool done;\n        (done, price) = status(auction);\n\n        needsRedo = auction.user != address(0) && done;\n        collateralToSell = auction.collateralToSell;\n        debt = auction.debt;\n    }\n\n    // Internally returns boolean for if an auction needs a redo\n    function status(Auction memory auction) internal view returns (bool done, uint256 price) {\n        uint256 floorPrice = wdiv(auction.debt, auction.collateralToSell);\n        price = max(\n            floorPrice,\n            vaults[auction.vault].calculator.price(auction.startPrice, sub(block.timestamp, auction.startsAt))\n        );\n        done = (sub(block.timestamp, auction.startsAt) > vaults[auction.vault].maxAuctionDuration ||\n            price == floorPrice);\n    }\n\n    /// @notice Public function to update the cached vault.debtFloor*vault.liquidationPenalty value\n    /// @param vault Address of the Vault for which to update the auctionDebtFloor variable\n    function updateAuctionDebtFloor(address vault) external override {\n        (, , , uint256 _debtFloor) = ICodex(codex).vaults(vault);\n        uint256 auctionDebtFloor = wmul(_debtFloor, limes.liquidationPenalty(vault));\n        vaults[vault].auctionDebtFloor = auctionDebtFloor;\n        emit UpdateAuctionDebtFloor(vault, auctionDebtFloor);\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Cancels an auction during shutdown or via governance action\n    /// @dev Sender has to be allowed to call this method\n    /// @param auctionId Id of the auction to cancel\n    function cancelAuction(uint256 auctionId) external override checkCaller checkReentrancy {\n        if (auctions[auctionId].user == address(0)) revert NoLossCollateralAuction__cancelAuction_notRunningAction();\n        address vault = auctions[auctionId].vault;\n        uint256 tokenId = auctions[auctionId].tokenId;\n        limes.liquidated(vault, tokenId, auctions[auctionId].debt);\n        codex.transferBalance(vault, tokenId, address(this), msg.sender, auctions[auctionId].collateralToSell);\n        _remove(auctionId);\n        emit StopAuction(auctionId);\n    }\n}// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n\n\n\n/// @title LinearDecrease\n/// @notice Implements a linear decreasing price curve for the collateral auction\n/// Uses LinearDecrease.sol from DSS (MakerDAO) as a blueprint\n/// Changes from LinearDecrease.sol /:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract LinearDecrease is Guarded, IPriceCalculator {\n    /// ======== Custom Errors ======== ///\n\n    error LinearDecrease__setParam_unrecognizedParam();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Seconds after auction start when the price reaches zero [seconds]\n    uint256 public duration;\n\n    /// ======== Events ======== ///\n\n    event SetParam(bytes32 indexed param, uint256 data);\n\n    constructor() Guarded() {}\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external checkCaller {\n        if (param == \"duration\") duration = data;\n        else revert LinearDecrease__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== Pricing ======== ///\n\n    /// @notice Price calculation when price is decreased linearly in proportion to time:\n    /// @dev `duration` The number of seconds after the start of the auction where the price will hit 0\n    /// Note the internal call to mul multiples by WAD, thereby ensuring that the wmul calculation\n    /// which utilizes startPrice and duration (WAD values) is also a WAD value.\n    /// @param startPrice: Initial price [wad]\n    /// @param time Current seconds since the start of the auction [seconds]\n    /// @return Returns y = startPrice * ((duration - time) / duration)\n    function price(uint256 startPrice, uint256 time) external view override returns (uint256) {\n        if (time >= duration) return 0;\n        return wmul(startPrice, wdiv(sub(duration, time), duration));\n    }\n}\n\n/// @title StairstepExponentialDecrease\n/// @notice Implements a stairstep like exponential decreasing price curve for the collateral auction\n/// Uses StairstepExponentialDecrease.sol from DSS (MakerDAO) as a blueprint\n/// Changes from StairstepExponentialDecrease.sol /:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract StairstepExponentialDecrease is Guarded, IPriceCalculator {\n    /// ======== Custom Errors ======== ///\n\n    error StairstepExponentialDecrease__setParam_factorGtWad();\n    error StairstepExponentialDecrease__setParam_unrecognizedParam();\n\n    /// ======== Storage ======== ///\n    /// @notice Length of time between price drops [seconds]\n    uint256 public step;\n    /// @notice Per-step multiplicative factor [wad]\n    uint256 public factor;\n\n    /// ======== Events ======== ///\n\n    event SetParam(bytes32 indexed param, uint256 data);\n\n    // `factor` and `step` values must be correctly set for this contract to return a valid price\n    constructor() Guarded() {}\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external checkCaller {\n        if (param == \"factor\") {\n            if (data > WAD) revert StairstepExponentialDecrease__setParam_factorGtWad();\n            factor = data;\n        } else if (param == \"step\") step = data;\n        else revert StairstepExponentialDecrease__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== Pricing ======== ///\n\n    /// @notice Price calculation when price is decreased stairstep like, exponential in proportion to time:\n    /// @dev `step` seconds between a price drop,\n    /// `factor` factor encodes the percentage to decrease per step.\n    ///   For efficiency, the values is set as (1 - (% value / 100)) * WAD\n    ///   So, for a 1% decrease per step, factor would be (1 - 0.01) * WAD\n    /// @param startPrice: Initial price [wad]\n    /// @param time Current seconds since the start of the auction [seconds]\n    /// @return Returns startPrice * (factor ^ time)\n    function price(uint256 startPrice, uint256 time) external view override returns (uint256) {\n        return wmul(startPrice, wpow(factor, time / step, WAD));\n    }\n}\n\n/// @title ExponentialDecrease\n/// @notice Implements a linear decreasing price curve for the collateral auction\n/// While an equivalent function can be obtained by setting step = 1 in StairstepExponentialDecrease,\n/// this continous (i.e. per-second) exponential decrease has be implemented as it is more gas-efficient\n/// than using the stairstep version with step = 1 (primarily due to 1 fewer SLOAD per price calculation).\n///\n/// Uses ExponentialDecrease.sol from DSS (MakerDAO) as a blueprint\n/// Changes from ExponentialDecrease.sol /:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract ExponentialDecrease is Guarded, IPriceCalculator {\n    /// ======== Custom Errors ======== ///\n\n    error ExponentialDecrease__setParam_factorGtWad();\n    error ExponentialDecrease__setParam_unrecognizedParam();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Per-second multiplicative factor [wad]\n    uint256 public factor;\n\n    /// ======== Events ======== ///\n\n    event SetParam(bytes32 indexed param, uint256 data);\n\n    // `factor` value must be correctly set for this contract to return a valid price\n    constructor() Guarded() {}\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external checkCaller {\n        if (param == \"factor\") {\n            if (data > WAD) revert ExponentialDecrease__setParam_factorGtWad();\n            factor = data;\n        } else revert ExponentialDecrease__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== Pricing ======== ///\n\n    /// @notice Price calculation when price is decreased exponentially in proportion to time:\n    /// @dev `factor`: factor encodes the percentage to decrease per second.\n    ///   For efficiency, the values is set as (1 - (% value / 100)) * WAD\n    ///   So, for a 1% decrease per second, factor would be (1 - 0.01) * WAD\n    /// @param startPrice: Initial price [wad]\n    /// @param time Current seconds since the start of the auction [seconds]\n    /// @return Returns startPrice * (factor ^ time)\n    function price(uint256 startPrice, uint256 time) external view override returns (uint256) {\n        return wmul(startPrice, wpow(factor, time, WAD));\n    }\n}\ncontract Delayed {\n    error Delayed__setParam_notDelayed();\n    error Delayed__delay_invalidEta();\n    error Delayed__execute_unknown();\n    error Delayed__execute_stillDelayed();\n    error Delayed__execute_executionError();\n\n    mapping(bytes32 => bool) public queue;\n    uint256 public delay;\n\n    event SetParam(bytes32 param, uint256 data);\n    event Queue(address target, bytes data, uint256 eta);\n    event Unqueue(address target, bytes data, uint256 eta);\n    event Execute(address target, bytes data, uint256 eta);\n\n    constructor(uint256 delay_) {\n        delay = delay_;\n        emit SetParam(\"delay\", delay_);\n    }\n\n    function _setParam(bytes32 param, uint256 data) internal {\n        if (param == \"delay\") delay = data;\n        emit SetParam(param, data);\n    }\n\n    function _delay(\n        address target,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        if (eta < block.timestamp + delay) revert Delayed__delay_invalidEta();\n        queue[keccak256(abi.encode(target, data, eta))] = true;\n        emit Queue(target, data, eta);\n    }\n\n    function _skip(\n        address target,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        queue[keccak256(abi.encode(target, data, eta))] = false;\n        emit Unqueue(target, data, eta);\n    }\n\n    function execute(\n        address target,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes memory out) {\n        bytes32 callHash = keccak256(abi.encode(target, data, eta));\n\n        if (!queue[callHash]) revert Delayed__execute_unknown();\n        if (block.timestamp < eta) revert Delayed__execute_stillDelayed();\n\n        queue[callHash] = false;\n\n        bool ok;\n        (ok, out) = target.call(data);\n        if (!ok) revert Delayed__execute_executionError();\n\n        emit Execute(target, data, eta);\n    }\n}interface IGuard {\n    function isGuard() external view returns (bool);\n}\n\nabstract contract BaseGuard is Delayed, IGuard {\n    /// ======== Custom Errors ======== ///\n\n    error BaseGuard__isSenatus_notSenatus();\n    error BaseGuard__isGuardian_notGuardian();\n    error BaseGuard__isDelayed_notSelf(address, address);\n    error BaseGuard__inRange_notInRange();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Address of the DAO\n    address public immutable senatus;\n    /// @notice Address of the guardian\n    address public guardian;\n\n    constructor(\n        address senatus_,\n        address guardian_,\n        uint256 delay\n    ) Delayed(delay) {\n        senatus = senatus_;\n        guardian = guardian_;\n    }\n\n    modifier isSenatus() {\n        if (msg.sender != senatus) revert BaseGuard__isSenatus_notSenatus();\n        _;\n    }\n\n    modifier isGuardian() {\n        if (msg.sender != guardian) revert BaseGuard__isGuardian_notGuardian();\n        _;\n    }\n\n    modifier isDelayed() {\n        if (msg.sender != address(this)) revert BaseGuard__isDelayed_notSelf(msg.sender, address(this));\n        _;\n    }\n\n    /// @notice Callback method which allows Guard to check if he has sufficient rights over the corresponding contract\n    /// @return bool True if he has sufficient rights\n    function isGuard() external view virtual override returns (bool);\n\n    /// @notice Updates the address of the guardian\n    /// @dev Can only be called by Senatus\n    /// @param guardian_ Address of the new guardian\n    function setGuardian(address guardian_) external isSenatus {\n        guardian = guardian_;\n    }\n\n    /// ======== Capabilities ======== ///\n\n    /// @notice Updates the time which has to elapse for certain parameter updates\n    /// @dev Can only be called by Senatus\n    /// @param delay Time which has to elapse before parameter can be updated [seconds]\n    function setDelay(uint256 delay) external isSenatus {\n        _setParam(\"delay\", delay);\n    }\n\n    /// @notice Schedule method call for methods which have to be delayed\n    /// @dev Can only be called by the guardian\n    /// @param data Call data\n    function schedule(bytes calldata data) external isGuardian {\n        _delay(address(this), data, block.timestamp + delay);\n    }\n\n    /// ======== Helper Methods ======== ///\n\n    /// @notice Checks if `value` is at least equal to `min_` or at most equal to `max`\n    /// @dev Revers if check failed\n    /// @param value Value to check\n    /// @param min_ Min. value for `value`\n    /// @param max Max. value for `value`\n    function _inRange(\n        uint256 value,\n        uint256 min_,\n        uint256 max\n    ) internal pure {\n        if (max < value || value < min_) revert BaseGuard__inRange_notInRange();\n    }\n}\ncontract PriceCalculatorFactory {\n    function newLinearDecrease(address owner) public returns (LinearDecrease priceCalculator) {\n        priceCalculator = new LinearDecrease();\n        priceCalculator.allowCaller(priceCalculator.ANY_SIG(), owner);\n        priceCalculator.blockCaller(priceCalculator.ANY_SIG(), address(this));\n    }\n\n    function newStairstepExponentialDecrease(address owner)\n        public\n        returns (StairstepExponentialDecrease priceCalculator)\n    {\n        priceCalculator = new StairstepExponentialDecrease();\n        priceCalculator.allowCaller(priceCalculator.ANY_SIG(), owner);\n        priceCalculator.blockCaller(priceCalculator.ANY_SIG(), address(this));\n    }\n\n    function newExponentialDecrease(address owner) public returns (ExponentialDecrease priceCalculator) {\n        priceCalculator = new ExponentialDecrease();\n        priceCalculator.allowCaller(priceCalculator.ANY_SIG(), owner);\n        priceCalculator.blockCaller(priceCalculator.ANY_SIG(), address(this));\n    }\n}\n\n/// @title VaultGuard\n/// @notice Contract which guards parameter updates for Vaults\ncontract VaultGuard is BaseGuard {\n    /// ======== Custom Errors ======== ///\n\n    error VaultGuard__isGuard_cantCall();\n    error VaultGuard__setVault_cantCall();\n\n    /// ======== Storage ======== ///\n\n    PriceCalculatorFactory public priceCalculatorFactory;\n\n    /// @notice Address of Codex\n    Codex public codex;\n    /// @notice Address of Publican\n    Publican public publican;\n    /// @notice Address of Limes\n    Limes public limes;\n    /// @notice Address of NoLossCollateralAuction\n    NoLossCollateralAuction public collateralAuction;\n    /// @notice Address of Collybus\n    Collybus public collybus;\n\n    constructor(\n        address senatus,\n        address guardian,\n        uint256 delay,\n        address codex_,\n        address publican_,\n        address limes_,\n        address collybus_,\n        address collateralAuction_,\n        address priceCalculatorFactory_\n    ) BaseGuard(senatus, guardian, delay) {\n        codex = Codex(codex_);\n        publican = Publican(publican_);\n        limes = Limes(limes_);\n        collybus = Collybus(collybus_);\n        collateralAuction = NoLossCollateralAuction(collateralAuction_);\n        priceCalculatorFactory = PriceCalculatorFactory(priceCalculatorFactory_);\n    }\n\n    /// @notice See `BaseGuard`\n    function isGuard() external view override returns (bool) {\n        if (\n            !codex.canCall(codex.ANY_SIG(), address(this)) ||\n            !publican.canCall(publican.ANY_SIG(), address(this)) ||\n            !limes.canCall(limes.ANY_SIG(), address(this)) ||\n            !collybus.canCall(collybus.ANY_SIG(), address(this)) ||\n            !collateralAuction.canCall(collateralAuction.ANY_SIG(), address(this))\n        ) revert VaultGuard__isGuard_cantCall();\n        return true;\n    }\n\n    /// ======== Capabilities ======== ///\n\n    /// @notice Sets the initial parameters for a Vault\n    /// @dev Can only be called by the guardian\n    /// @param vault Address of the vault to initialize\n    /// @param auctionGuard Address of the AuctionGuard\n    /// @param calculatorType PriceCalculator to use (LinearDecrease, StairstepExponentialDecrease, ExponentialDecrease)\n    /// @param debtCeiling See Codex\n    /// @param debtFloor See Codex\n    /// @param interestPerSecond See Publican\n    /// @param multiplier See CollateralAuction\n    /// @param maxAuctionDuration See CollateralAuction\n    /// @param liquidationRatio See Collybus\n    /// @param liquidationPenalty See Limes\n    /// @param maxDebtOnAuction See Limes\n    function setVault(\n        address vault,\n        address auctionGuard,\n        bytes32 calculatorType,\n        uint256 debtCeiling,\n        uint256 debtFloor,\n        uint256 interestPerSecond,\n        uint256 multiplier,\n        uint256 maxAuctionDuration,\n        uint128 liquidationRatio,\n        uint256 liquidationPenalty,\n        uint256 maxDebtOnAuction\n    ) public isGuardian {\n        if (!IGuarded(vault).canCall(IGuarded(vault).ANY_SIG(), address(this))) revert VaultGuard__setVault_cantCall();\n\n        // fails if vault is already initialized\n        codex.init(vault);\n        publican.init(vault);\n\n        codex.allowCaller(codex.modifyBalance.selector, vault);\n\n        // deploy new PriceCalculator\n        address calculator;\n        if (calculatorType == \"LinearDecrease\") {\n            LinearDecrease ld = priceCalculatorFactory.newLinearDecrease(address(this));\n            calculator = address(ld);\n            ld.setParam(\"duration\", maxAuctionDuration);\n            ld.allowCaller(ld.ANY_SIG(), auctionGuard);\n        } else if (calculatorType == \"StairstepExponentialDecrease\") {\n            StairstepExponentialDecrease sed = priceCalculatorFactory.newStairstepExponentialDecrease(address(this));\n            calculator = address(sed);\n            sed.setParam(\"duration\", maxAuctionDuration);\n            sed.allowCaller(sed.ANY_SIG(), auctionGuard);\n        } else if (calculatorType == \"ExponentialDecrease\") {\n            ExponentialDecrease ed = priceCalculatorFactory.newExponentialDecrease(address(this));\n            calculator = address(ed);\n            ed.setParam(\"duration\", maxAuctionDuration);\n            ed.allowCaller(ed.ANY_SIG(), auctionGuard);\n        }\n\n        // Internal references set up\n        limes.setParam(vault, \"collateralAuction\", address(collateralAuction));\n        collateralAuction.setParam(vault, \"calculator\", address(calculator));\n        collateralAuction.setParam(vault, \"collybus\", address(collybus));\n\n        // Config\n        codex.setParam(vault, \"debtCeiling\", debtCeiling);\n        codex.setParam(vault, \"debtFloor\", debtFloor);\n        publican.setParam(vault, \"interestPerSecond\", interestPerSecond);\n        collateralAuction.setParam(vault, \"multiplier\", multiplier);\n        collateralAuction.setParam(vault, \"maxAuctionDuration\", maxAuctionDuration);\n        collybus.setParam(vault, \"liquidationRatio\", liquidationRatio);\n\n        limes.setParam(vault, \"liquidationPenalty\", liquidationPenalty);\n        limes.setParam(vault, \"maxDebtOnAuction\", maxDebtOnAuction);\n\n        collateralAuction.updateAuctionDebtFloor(vault);\n    }\n\n    /// @notice Locks a Vault\n    /// @dev Can only be called by the guardian\n    /// @param vault Address of the vault to lock\n    function lockVault(address vault) public isGuardian {\n        codex.blockCaller(codex.modifyBalance.selector, vault);\n        IVault(vault).lock();\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"newExponentialDecrease\",\"outputs\":[{\"internalType\":\"contract ExponentialDecrease\",\"name\":\"priceCalculator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"newLinearDecrease\",\"outputs\":[{\"internalType\":\"contract LinearDecrease\",\"name\":\"priceCalculator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"newStairstepExponentialDecrease\",\"outputs\":[{\"internalType\":\"contract StairstepExponentialDecrease\",\"name\":\"priceCalculator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PriceCalculatorFactory", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "8000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}