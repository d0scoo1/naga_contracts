{"status": "1", "message": "OK", "result": [{"SourceCode": "/**\r\n * Dragonking is a blockchain game in which players may purchase dragons and knights of different levels and values.\r\n * Once every period of time the volcano erupts and wipes a few of them from the board. The value of the killed characters\r\n * gets distributed amongst all of the survivors. The dragon king receive a bigger share than the others.\r\n * In contrast to dragons, knights need to be teleported to the battlefield first with the use of teleport tokens.\r\n * Additionally, they may attack a dragon once per period.\r\n * Both character types can be protected from death up to three times.\r\n * Take a look at dragonking.io for more detailed information.\r\n * @author: Julia Altenried, Yuriy Kashnikov\r\n * */\r\n\r\npragma solidity ^ 0.4.17;\r\n\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\ncontract Ownable {\r\n address public owner;\r\n\r\n\r\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n /**\r\n  * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n  * account.\r\n  */\r\n function Ownable() public {\r\n   owner = msg.sender;\r\n }\r\n\r\n /**\r\n  * @dev Throws if called by any account other than the owner.\r\n  */\r\n modifier onlyOwner() {\r\n   require(msg.sender == owner);\r\n   _;\r\n }\r\n\r\n /**\r\n  * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n  * @param newOwner The address to transfer ownership to.\r\n  */\r\n function transferOwnership(address newOwner) public onlyOwner {\r\n   require(newOwner != address(0));\r\n   emit OwnershipTransferred(owner, newOwner);\r\n   owner = newOwner;\r\n }\r\n\r\n}\r\n\r\ncontract mortal is Ownable{\r\n\r\n function mortal() public {\r\n }\r\n\r\n function kill() internal {\r\n   selfdestruct(owner);\r\n }\r\n}\r\n\r\n\r\n\r\ncontract Token {\r\n function transferFrom(address _from, address _to, uint256 _value) public returns(bool success);\r\n}\r\n\r\ncontract DragonKing is mortal {\r\n\r\n struct Character {\r\n   uint8 characterType;\r\n   uint128 value;\r\n   address owner;\r\n }\r\n\r\n /** array holding ids of the curret characters*/\r\n uint32[] public ids;\r\n /** the id to be given to the next character **/\r\n uint32 public nextId;\r\n /** the id of the oldest character */\r\n uint32 public oldest;\r\n /** the character belonging to a given id */\r\n mapping(uint32 => Character) characters;\r\n /** teleported knights **/\r\n mapping(uint32 => bool) teleported;\r\n /** the cost of each character type */\r\n uint128[] public costs;\r\n /** the value of each character type (cost - fee), so it's not necessary to compute it each time*/\r\n uint128[] public values;\r\n /** the fee to be paid each time an character is bought in percent*/\r\n uint8 fee;\r\n /** the number of dragon types **/\r\n uint8 constant public numDragonTypes = 6;\r\n\r\n\r\n /** total number of characters in the game  */\r\n uint16 public numCharacters;\r\n /** The maximum of characters allowed in the game */\r\n uint16 public maxCharacters;\r\n /** number of characters per type */\r\n mapping(uint8 => uint16) public numCharactersXType;\r\n\r\n\r\n /** the amount of time that should pass since last eruption **/\r\n uint8 public eruptionThreshold;\r\n /** timestampt of the last eruption event **/\r\n uint256 public lastEruptionTimestamp;\r\n /** how many characters to kill in %, e.g. 20 will stand for 20%, should be < 100 **/\r\n uint8 public percentageToKill;\r\n\r\n /** knight cooldown. contains the timestamp of the earliest possible moment to start a fight */\r\n mapping(uint32 => uint) public cooldown;\r\n uint256 public constant CooldownThreshold = 1 days;\r\n\r\n /** the teleport token contract used to send knights to the game scene */\r\n Token teleportToken;\r\n /** the price for teleportation*/\r\n uint public teleportPrice;\r\n /** the neverdue token contract used to purchase protection from eruptions and fights */\r\n Token neverdieToken;\r\n /** the price for protection */\r\n uint public protectionPrice;\r\n /** tells the number of times a character is protected */\r\n mapping(uint32 => uint8) public protection;\r\n\r\n // MODIFIER\r\n\r\n /** is fired when new characters are purchased (who bought how many characters of which type?) */\r\n event NewPurchase(address player, uint8 characterType, uint8 amount, uint32 startId);\r\n /** is fired when a player leaves the game */\r\n event NewExit(address player, uint256 totalBalance, uint32[] removedCharacters);\r\n /** is fired when an eruption occurs */\r\n event NewEruption(uint32[] hitCharacters, uint128 value, uint128 gasCost);\r\n /** is fired when a single character is sold **/\r\n event NewSell(uint32 characterId, address player, uint256 value);\r\n /** is fired when a knight fights a dragon **/\r\n event NewFight(uint32 winnerID, uint32 loserID, uint256 value);\r\n /** is fired when a knight is teleported to the field **/\r\n event NewTeleport(uint32 characterId);\r\n /** is fired when a protection is purchased **/\r\n event NewProtection(uint32 characterId, uint8 lifes);\r\n\r\n /** initializes the contract parameters\t */\r\n function DragonKing(address teleportTokenAddress, address neverdieTokenAddress, uint8 eruptionThresholdInHours, uint8 percentageOfCharactersToKill, uint8 characterFee, uint16[] charactersCosts) public onlyOwner {\r\n   fee = characterFee;\r\n   for (uint8 i = 0; i < charactersCosts.length * 2; i++) {\r\n     costs.push(uint128(charactersCosts[i % numDragonTypes]) * 1 finney);\r\n     values.push(costs[i] - costs[i] / 100 * fee);\r\n   }\r\n   eruptionThreshold = eruptionThresholdInHours * 60 * 60; // convert to seconds\r\n   percentageToKill = percentageOfCharactersToKill;\r\n   maxCharacters = 600;\r\n   nextId = 1;\r\n   teleportToken = Token(teleportTokenAddress);\r\n   teleportPrice = 1;\r\n   neverdieToken = Token(neverdieTokenAddress);\r\n   protectionPrice = 1;\r\n }\r\n\r\n /**\r\n  * buys as many characters as possible with the transfered value of the given type\r\n  * @param characterType the type of the character\r\n  */\r\n function addCharacters(uint8 characterType) payable public {\r\n   uint8 amount = uint8(msg.value / costs[characterType]);\r\n   uint16 nchars = numCharacters;\r\n   if (characterType >= costs.length || msg.value < costs[characterType] || nchars + amount > maxCharacters) revert();\r\n   //if type exists, enough ether was transferred and there are less than maxCharacters characters in the game\r\n   bool isDragon = characterType < numDragonTypes;\r\n   uint32 nid = nextId;\r\n   if (isDragon) {\r\n     //dragons enter the game directly\r\n     for (uint8 i = 0; i < amount; i++) {\r\n       addCharacter(nid + i, nchars + i);\r\n       characters[nid + i] = Character(characterType, values[characterType], msg.sender);\r\n     }\r\n     numCharactersXType[characterType] += amount;\r\n     numCharacters += amount;\r\n   }\r\n   else {\r\n     for (uint8 j = 0; j < amount; j++) {\r\n       characters[nid + j] = Character(characterType, values[characterType], msg.sender);\r\n     }\r\n   }\r\n   nextId = nid + amount;\r\n   NewPurchase(msg.sender, characterType, amount, nid);\r\n }\r\n\r\n\r\n\r\n /**\r\n  * adds a single dragon of the given type to the ids array, which is used to iterate over all characters\r\n  * @param nId the id the character is about to receive\r\n  * @param nchars the number of characters currently in the game\r\n  */\r\n function addCharacter(uint32 nId, uint16 nchars) internal {\r\n   if (nchars < ids.length)\r\n     ids[nchars] = nId;\r\n   else\r\n     ids.push(nId);\r\n }\r\n\r\n /**\r\n  * leave the game.\r\n  * pays out the sender's balance and removes him and his characters from the game\r\n  * */\r\n function exit() public {\r\n   uint32[] memory removed = new uint32[](50);\r\n   uint8 count;\r\n   uint32 lastId;\r\n   uint playerBalance;\r\n   uint16 nchars = numCharacters;\r\n   for (uint16 i = 0; i < nchars; i++) {\r\n     if (characters[ids[i]].owner == msg.sender) {\r\n       //first delete all characters at the end of the array\r\n       while (nchars > 0 && characters[ids[nchars - 1]].owner == msg.sender) {\r\n         nchars--;\r\n         lastId = ids[nchars];\r\n         numCharactersXType[characters[lastId].characterType]--;\r\n         playerBalance += characters[lastId].value;\r\n         removed[count] = lastId;\r\n         count++;\r\n         if (lastId == oldest) oldest = 0;\r\n         delete characters[lastId];\r\n       }\r\n       //if the last character does not belong to the player, replace the players character by this last one\r\n       if (nchars > i + 1) {\r\n         playerBalance += characters[ids[i]].value;\r\n         removed[count] = ids[i];\r\n         count++;\r\n         nchars--;\r\n         replaceCharacter(i, nchars);\r\n       }\r\n     }\r\n   }\r\n   numCharacters = nchars;\r\n   NewExit(msg.sender, playerBalance, removed); //fire the event to notify the client\r\n   msg.sender.transfer(playerBalance);\r\n }\r\n\r\n /**\r\n  * Replaces the character with the given id with the last character in the array\r\n  * @param index the index of the character in the id array\r\n  * @param nchars the number of characters\r\n  * */\r\n function replaceCharacter(uint16 index, uint16 nchars) internal {\r\n   uint32 characterId = ids[index];\r\n   numCharactersXType[characters[characterId].characterType]--;\r\n   if (characterId == oldest) oldest = 0;\r\n   delete characters[characterId];\r\n   ids[index] = ids[nchars];\r\n   delete ids[nchars];\r\n }\r\n\r\n /**\r\n  * The volcano eruption can be triggered by anybody but only if enough time has passed since the last eription.\r\n  * The volcano hits up to a certain percentage of characters, but at least one.\r\n  * The percantage is specified in 'percentageToKill'\r\n  * */\r\n\r\n function triggerVolcanoEruption() public {\r\n   require(now >= lastEruptionTimestamp + eruptionThreshold);\r\n   require(numCharacters>0);\r\n   lastEruptionTimestamp = now;\r\n   uint128 pot;\r\n   uint128 value;\r\n   uint16 random;\r\n   uint32 nextHitId;\r\n   uint16 nchars = numCharacters;\r\n   uint32 howmany = nchars * percentageToKill / 100;\r\n   uint128 neededGas = 80000 + 10000 * uint32(nchars);\r\n   if(howmany == 0) howmany = 1;//hit at least 1\r\n   uint32[] memory hitCharacters = new uint32[](howmany);\r\n   for (uint8 i = 0; i < howmany; i++) {\r\n     random = uint16(generateRandomNumber(lastEruptionTimestamp + i) % nchars);\r\n     nextHitId = ids[random];\r\n     hitCharacters[i] = nextHitId;\r\n     value = hitCharacter(random, nchars);\r\n     if (value > 0) {\r\n       nchars--;\r\n     }\r\n     pot += value;\r\n   }\r\n   uint128 gasCost = uint128(neededGas * tx.gasprice);\r\n   numCharacters = nchars;\r\n   if (pot > gasCost){\r\n     distribute(pot - gasCost); //distribute the pot minus the oraclize gas costs\r\n     NewEruption(hitCharacters, pot - gasCost, gasCost);\r\n   }\r\n   else\r\n     NewEruption(hitCharacters, 0, gasCost);\r\n }\r\n\r\n\r\n /**\r\n  * A knight may attack a dragon, but not choose which one.\r\n  * The creature with the higher level wins. The level is determined by characterType % numDragonTypes.\r\n  * The value of the loser is transfered to the winner. In case of a the same level, the winner is chosen randomly.\r\n  * @param knightID the ID of the knight to perfrom the attack\r\n  * @param knightIndex the index of the knight in the ids-array. Just needed to save gas costs.\r\n  *\t\t\t\t\t  In case it's unknown or incorrect, the index is looked up in the array.\r\n  * */\r\n function fight(uint32 knightID, uint16 knightIndex) public {\r\n   if (knightID != ids[knightIndex])\r\n     knightID = getCharacterIndex(knightID);\r\n   Character storage knight = characters[knightID];\r\n   require(cooldown[knightID] + CooldownThreshold <= now);\r\n   require(knight.owner == msg.sender);\r\n   require(knight.characterType >= numDragonTypes);\r\n   uint16 dragonIndex = getRandomDragon(knightID);\r\n   assert(dragonIndex < maxCharacters);\r\n   uint32 dragonID = ids[dragonIndex];\r\n   Character storage dragon = characters[dragonID];\r\n   uint16 tieBreaker = uint16(now % 2);\r\n   uint128 value;\r\n   if (knight.characterType - numDragonTypes > dragon.characterType || (knight.characterType - numDragonTypes == dragon.characterType && tieBreaker == 0)) {\r\n     value = hitCharacter(dragonIndex, numCharacters);\r\n     if (value > 0) {\r\n       numCharacters--;\r\n     }\r\n     knight.value += value;\r\n     cooldown[knightID] = now;\r\n     if (oldest == 0) findOldest();\r\n     NewFight(knightID, dragonID, value);\r\n   }\r\n   else {\r\n     value = hitCharacter(knightIndex, numCharacters);\r\n     if (value > 0) {\r\n       numCharacters--;\r\n     }\r\n     dragon.value += value;\r\n     NewFight(dragonID, knightID, value);\r\n   }\r\n }\r\n\r\n /**\r\n  * pick a random dragon.\r\n  * @param nonce a nonce to make sure there's not always the same dragon chosen in a single block.\r\n  * @return the index of a random dragon\r\n  * */\r\n function getRandomDragon(uint256 nonce) internal view returns(uint16) {\r\n   uint16 randomIndex = uint16(generateRandomNumber(nonce) % numCharacters);\r\n   //use 7, 11 or 13 as step size. scales for up to 1000 characters\r\n   uint16 stepSize = numCharacters % 7 == 0 ? (numCharacters % 11 == 0 ? 13 : 11) : 7;\r\n   uint16 i = randomIndex;\r\n   //if the picked character is a knight or belongs to the sender, look at the character + stepSizes ahead in the array (modulo the total number)\r\n   //will at some point return to the startingPoint if no character is suited\r\n   do {\r\n     if (characters[ids[i]].characterType < numDragonTypes && characters[ids[i]].owner != msg.sender) return i;\r\n     i = (i + stepSize) % numCharacters;\r\n   } while (i != randomIndex);\r\n   return maxCharacters + 1; //there is none\r\n }\r\n\r\n /**\r\n  * generate a random number.\r\n  * @param nonce a nonce to make sure there's not always the same number returned in a single block.\r\n  * @return the random number\r\n  * */\r\n function generateRandomNumber(uint256 nonce) internal view returns(uint) {\r\n   return uint(keccak256(block.blockhash(block.number - 1), now, numCharacters, nonce));\r\n }\r\n\r\n /**\r\n  * Hits the character of the given type at the given index.\r\n  * @param index the index of the character\r\n  * @param nchars the number of characters\r\n  * @return the value gained from hitting the characters (zero is the character was protected)\r\n  * */\r\n function hitCharacter(uint16 index, uint16 nchars) internal returns(uint128 characterValue) {\r\n   uint32 id = ids[index];\r\n   if (protection[id] > 0) {\r\n     protection[id]--;\r\n     return 0;\r\n   }\r\n   characterValue = characters[ids[index]].value;\r\n   nchars--;\r\n   replaceCharacter(index, nchars);\r\n }\r\n\r\n /**\r\n  * finds the oldest character\r\n  * */\r\n function findOldest() public {\r\n   oldest = ids[0];\r\n   for (uint16 i = 1; i < numCharacters; i++) {\r\n     if (ids[i] < oldest && characters[ids[i]].characterType < numDragonTypes) //the oldest character has the lowest id -todo\r\n       oldest = ids[i];\r\n   }\r\n }\r\n\r\n /**\r\n * distributes the given amount among the surviving characters\r\n * @param totalAmount nthe amount to distribute\r\n */\r\n function distribute(uint128 totalAmount) internal {\r\n   //pay 10% to the oldest dragon\r\n   if (oldest == 0)\r\n     findOldest();\r\n   characters[oldest].value += totalAmount / 10;\r\n   uint128 amount = totalAmount / 10 * 9;\r\n   //distribute the rest according to their type\r\n   uint128 valueSum;\r\n   uint128[] memory shares = new uint128[](values.length);\r\n   for (uint8 v = 0; v < values.length; v++) {\r\n     if (numCharactersXType[v] > 0) valueSum += values[v];\r\n   }\r\n   for (uint8 m = 0; m < values.length; m++) {\r\n     if (numCharactersXType[m] > 0)\r\n       shares[m] = amount * values[m] / valueSum / numCharactersXType[m];\r\n   }\r\n   for (uint16 i = 0; i < numCharacters; i++) {\r\n     characters[ids[i]].value += shares[characters[ids[i]].characterType];\r\n   }\r\n }\r\n\r\n /**\r\n  * allows the owner to collect the accumulated fees\r\n  * sends the given amount to the owner's address if the amount does not exceed the\r\n  * fees (cannot touch the players' balances) minus 100 finney (ensure that oraclize fees can be paid)\r\n  * @param amount the amount to be collected\r\n  * */\r\n function collectFees(uint128 amount) public onlyOwner {\r\n   uint collectedFees = getFees();\r\n   if (amount + 100 finney < collectedFees) {\r\n     owner.transfer(amount);\r\n   }\r\n }\r\n\r\n /**\r\n  * pays out the players and kills the game.\r\n  * */\r\n function stop() public onlyOwner {\r\n   for (uint16 i = 0; i < numCharacters; i++) {\r\n     if (!characters[ids[i]].owner.send(characters[ids[i]].value)) revert();\r\n   }\r\n   kill();\r\n }\r\n\r\n /**\r\n  * sell the character of the given id\r\n  * throws an exception in case of a knight not yet teleported to the game\r\n  * @param characterId the id of the character\r\n  * */\r\n function sellCharacter(uint32 characterId) public {\r\n   require(msg.sender == characters[characterId].owner);\r\n   uint128 val = characters[characterId].value;\r\n   numCharacters--;\r\n   replaceCharacter(getCharacterIndex(characterId), numCharacters);\r\n   msg.sender.transfer(val);\r\n   NewSell(characterId, msg.sender, val);\r\n }\r\n\r\n /**\r\n  * receive approval to spend some tokens.\r\n  * used for teleport and protection.\r\n  * @param sender the sender address\r\n  * @param value the transferred value\r\n  * @param tokenContract the address of the token contract\r\n  * @param callData the data passed by the token contract\r\n  * */\r\n function receiveApproval(address sender, uint256 value, address tokenContract, bytes callData) public {\r\n   if (msg.sender == address(teleportToken)) {\r\n     require(value >= teleportPrice);\r\n     assert(teleportToken.transferFrom(sender, this, teleportPrice));\r\n     teleportKnight(toUint32(callData));\r\n   }\r\n   else if (msg.sender == address(neverdieToken)) {\r\n     uint32 id = toUint32(callData);\r\n     // user can purchase extra lifes only right after character purchaes\r\n     // in other words, user value should be equal the initial value\r\n     require(characters[id].value == values[characters[id].characterType]);\r\n\r\n     // calc how many lifes user can actually buy\r\n     // the formula is the following:\r\n     uint256 lifePrice = ((characters[id].characterType % numDragonTypes) + 1) * protectionPrice;\r\n     uint256 price = 0;\r\n     uint8 i = protection[id];\r\n     require(i <= 3);\r\n     for (i; i < 3 && value >= price + lifePrice * (i + 1); i++) {\r\n       price += lifePrice * (i + 1);\r\n     }\r\n     assert(neverdieToken.transferFrom(sender, this, price));\r\n     protectCharacter(id, i);\r\n   }\r\n   else\r\n     revert();\r\n }\r\n\r\n /**\r\n  * knights are only entering the game completely, when they are teleported to the scene\r\n  * @param id the character id\r\n  * */\r\n function teleportKnight(uint32 id) internal {\r\n   // ensure we do not teleport twice\r\n   require(teleported[id] == false);\r\n   teleported[id] = true;\r\n   Character storage knight = characters[id];\r\n   assert(knight.characterType >= numDragonTypes); //this also makes calls with non-existent ids fail\r\n   addCharacter(id, numCharacters);\r\n   numCharacters++;\r\n   numCharactersXType[knight.characterType]++;\r\n   NewTeleport(id);\r\n }\r\n\r\n /**\r\n  * adds protection to a character\r\n  * @param id the character id\r\n  * @param lifes the number of protections\r\n  * */\r\n function protectCharacter(uint32 id, uint8 lifes) internal {\r\n   protection[id] = lifes;\r\n   NewProtection(id, lifes);\r\n }\r\n\r\n\r\n /****************** GETTERS *************************/\r\n\r\n /**\r\n  * returns the character of the given id\r\n  * @param characterId the character id\r\n  * @return the type, value and owner of the character\r\n  * */\r\n function getCharacter(uint32 characterId) constant public returns(uint8, uint128, address) {\r\n   return (characters[characterId].characterType, characters[characterId].value, characters[characterId].owner);\r\n }\r\n\r\n /**\r\n  * returns the index of a character of the given id\r\n  * @param characterId the character id\r\n  * @return the character id\r\n  * */\r\n function getCharacterIndex(uint32 characterId) constant public returns(uint16) {\r\n   for (uint16 i = 0; i < ids.length; i++) {\r\n     if (ids[i] == characterId) {\r\n       return i;\r\n     }\r\n   }\r\n   revert();\r\n }\r\n\r\n /**\r\n  * returns 10 characters starting from a certain indey\r\n  * @param startIndex the index to start from\r\n  * @return 4 arrays containing the ids, types, values and owners of the characters\r\n  * */\r\n function get10Characters(uint16 startIndex) constant public returns(uint32[10] characterIds, uint8[10] types, uint128[10] values, address[10] owners) {\r\n   uint32 endIndex = startIndex + 10 > numCharacters ? numCharacters : startIndex + 10;\r\n   uint8 j = 0;\r\n   uint32 id;\r\n   for (uint16 i = startIndex; i < endIndex; i++) {\r\n     id = ids[i];\r\n     characterIds[j] = id;\r\n     types[j] = characters[id].characterType;\r\n     values[j] = characters[id].value;\r\n     owners[j] = characters[id].owner;\r\n     j++;\r\n   }\r\n\r\n }\r\n\r\n /**\r\n  * returns the number of dragons in the game\r\n  * @return the number of dragons\r\n  * */\r\n function getNumDragons() constant public returns(uint16 numDragons) {\r\n   for (uint8 i = 0; i < numDragonTypes; i++)\r\n     numDragons += numCharactersXType[i];\r\n }\r\n\r\n /**\r\n  * returns the number of knights in the game\r\n  * @return the number of knights\r\n  * */\r\n function getNumKnights() constant public returns(uint16 numKnights) {\r\n   for (uint8 i = numDragonTypes; i < costs.length; i++)\r\n     numKnights += numCharactersXType[i];\r\n }\r\n\r\n /**\r\n  * @return the accumulated fees\r\n  * */\r\n function getFees() constant public returns(uint) {\r\n   uint reserved = 0;\r\n   for (uint16 j = 0; j < numCharacters; j++)\r\n     reserved += characters[ids[j]].value;\r\n   return address(this).balance - reserved;\r\n }\r\n\r\n\r\n /****************** SETTERS *************************/\r\n\r\n /**\r\n  * sets the prices of the character types\r\n  * @param prices the prices in finney\r\n  * */\r\n function setPrices(uint16[] prices) public onlyOwner {\r\n   for (uint8 i = 0; i < prices.length * 2; i++) {\r\n     costs[i] = uint128(prices[i % numDragonTypes]) * 1 finney;\r\n     values[i] = costs[i] - costs[i] / 100 * fee;\r\n   }\r\n }\r\n\r\n /**\r\n  * sets the fee to charge on each purchase\r\n  * @param _fee the new fee\r\n  * */\r\n function setFee(uint8 _fee) public onlyOwner {\r\n   fee = _fee;\r\n }\r\n\r\n /**\r\n  * sets the maximum number of characters allowed in the game\r\n  * @param number the new maximum\r\n  * */\r\n function setMaxCharacters(uint16 number) public onlyOwner {\r\n   maxCharacters = number;\r\n }\r\n\r\n /**\r\n  * sets the teleport price\r\n  * @param price the price in tokens\r\n  * */\r\n function setTeleportPrice(uint price) public onlyOwner {\r\n   teleportPrice = price;\r\n }\r\n\r\n /**\r\n  * sets the protection price\r\n  * @param price the price in tokens\r\n  * */\r\n function setProtectionPrice(uint price) public onlyOwner {\r\n   protectionPrice = price;\r\n }\r\n\r\n\r\n /************* HELPERS ****************/\r\n\r\n /**\r\n  * only works for bytes of length < 32\r\n  * @param b the byte input\r\n  * @return the uint\r\n  * */\r\n function toUint32(bytes b) internal pure returns(uint32) {\r\n   bytes32 newB;\r\n   assembly {\r\n     newB: = mload(0x80)\r\n   }\r\n   return uint32(newB);\r\n }\r\n\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"characterId\",\"type\":\"uint32\"}],\"name\":\"sellCharacter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentageToKill\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"protectionPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerVolcanoEruption\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"collectFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"numCharactersXType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"characterId\",\"type\":\"uint32\"}],\"name\":\"getCharacter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint128\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setTeleportPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CooldownThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"costs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"characterId\",\"type\":\"uint32\"}],\"name\":\"getCharacterIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"values\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"startIndex\",\"type\":\"uint16\"}],\"name\":\"get10Characters\",\"outputs\":[{\"name\":\"characterIds\",\"type\":\"uint32[10]\"},{\"name\":\"types\",\"type\":\"uint8[10]\"},{\"name\":\"values\",\"type\":\"uint128[10]\"},{\"name\":\"owners\",\"type\":\"address[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teleportPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"protection\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"knightID\",\"type\":\"uint32\"},{\"name\":\"knightIndex\",\"type\":\"uint16\"}],\"name\":\"fight\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"prices\",\"type\":\"uint16[]\"}],\"name\":\"setPrices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"characterType\",\"type\":\"uint8\"}],\"name\":\"addCharacters\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumDragons\",\"outputs\":[{\"name\":\"numDragons\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCharacters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"tokenContract\",\"type\":\"address\"},{\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setProtectionPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eruptionThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"cooldown\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumKnights\",\"outputs\":[{\"name\":\"numKnights\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numDragonTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastEruptionTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint8\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numCharacters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"number\",\"type\":\"uint16\"}],\"name\":\"setMaxCharacters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"findOldest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"teleportTokenAddress\",\"type\":\"address\"},{\"name\":\"neverdieTokenAddress\",\"type\":\"address\"},{\"name\":\"eruptionThresholdInHours\",\"type\":\"uint8\"},{\"name\":\"percentageOfCharactersToKill\",\"type\":\"uint8\"},{\"name\":\"characterFee\",\"type\":\"uint8\"},{\"name\":\"charactersCosts\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"characterType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"startId\",\"type\":\"uint32\"}],\"name\":\"NewPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"removedCharacters\",\"type\":\"uint32[]\"}],\"name\":\"NewExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hitCharacters\",\"type\":\"uint32[]\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"gasCost\",\"type\":\"uint128\"}],\"name\":\"NewEruption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"characterId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winnerID\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"loserID\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewFight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"characterId\",\"type\":\"uint32\"}],\"name\":\"NewTeleport\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"characterId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"lifes\",\"type\":\"uint8\"}],\"name\":\"NewProtection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "DragonKing", "CompilerVersion": "v0.4.21+commit.dfe3193c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c596bd09d652827b0106292d3e378d5938df4b12000000000000000000000000a54ddc7b3cce7fc8b1e3fa0256d0db80d2c109700000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000003e8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://58d1dcd63d103281c3875cd410f2cf3d016e8adc85d08bf459d349f9e87c3526"}]}