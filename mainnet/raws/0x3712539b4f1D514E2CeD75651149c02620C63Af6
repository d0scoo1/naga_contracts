{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: NONE\n\npragma solidity 0.5.10;\n\n\n\n// Part: Address\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\n// Part: ICurvePool\n\n// legacy interface for this\ncontract ICurvePool {\n    function deposit(uint256 _amount) public;\n    function withdraw(uint256 _amount) public;\n    function earnReward(address[] memory yieldtokens) public;\n\n    function get_virtual_price() public view returns(uint256);\n    function get_lp_token_balance() public view returns(uint256);\n    function get_lp_token_addr() public view returns(address);\n\n    function setController(address, address) public;\n}\n\n// Part: IERC20\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// Part: Ownable\n\ncontract Ownable {\n    address private _contract_owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = msg.sender;\n        _contract_owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _contract_owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_contract_owner, newOwner);\n        _contract_owner = newOwner;\n    }\n}\n\n// Part: IController\n\ncontract IController is Ownable{\n    function deposit(uint256) public;\n    function withdraw(uint256) public;\n    function setVault(address) public;\n    function get_current_pool() public view returns(ICurvePool);\n}\n\n// Part: IVault\n\ncontract IVault is Ownable{\n    function changeController(address) public;\n}\n\n// File: Upgrader.sol\n\ncontract Upgrader is Ownable {\n    using Address for address;\n\n    address new_owner;\n    IVault vault;\n    IController old_controller;\n    IController new_controller;\n    ICurvePool new_pool;\n    ICurvePool old_pool;\n\n    constructor(address owner) public  {\n        transferOwnership(owner);\n    }\n\n    function prepare_upgrade(address _vault, address _old_controller, address _new_controller) public onlyOwner() {\n        vault = IVault(_vault.toPayable());\n        old_controller = IController(_old_controller.toPayable());\n        old_pool = old_controller.get_current_pool();\n        new_controller = IController(_new_controller.toPayable());\n        new_pool = new_controller.get_current_pool();\n        new_owner = this.owner();\n    }\n\n    event withdrawn(uint256 tt_amount);\n    event minted(uint256 lp_amount);\n    /**\n     * @notice make sure this is [vault, old_controller, new_controller, new pool]'s owner\n     */\n    function upgrade() public onlyOwner() {\n        IERC20 target_token = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n        \n        old_pool.setController(address(old_controller), address(this)); //actually set vault\n        old_controller.setVault(address(this));\n        // start withdraw\n        old_controller.withdraw(old_pool.get_lp_token_balance());\n\n        uint256 target_token_amount = target_token.balanceOf(address(this));\n        emit withdrawn(target_token_amount);\n\n        //@Here: all asset in this as USDC\n        new_pool.setController(address(new_controller), address(this));\n        new_controller.setVault(address(this));\n        target_token.transfer(address(new_pool), target_token_amount);\n        new_controller.deposit(target_token_amount);\n        emit minted(new_pool.get_lp_token_balance());\n        \n        // @Here: all asset in controller.pool as lp\n\n        // clean up\n        new_pool.setController(address(new_controller), address(vault));\n        new_controller.setVault(address(vault));\n        vault.changeController(address(new_controller));\n        // release owner ship\n        releaseOwnership(new_owner);\n    }\n\n    function releaseOwnership(address _owner) public onlyOwner() {\n        vault.transferOwnership(_owner);\n        new_controller.transferOwnership(_owner);\n        Ownable(address(new_pool)).transferOwnership(_owner);\n        old_controller.transferOwnership(_owner);\n        Ownable(address(old_pool)).transferOwnership(_owner);\n    }\n}\n", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"releaseOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_old_controller\",\"type\":\"address\"},{\"name\":\"_new_controller\",\"type\":\"address\"}],\"name\":\"prepare_upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tt_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"lp_amount\",\"type\":\"uint256\"}],\"name\":\"minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "Upgrader", "CompilerVersion": "v0.5.10+commit.5a6ea5b1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c3fd2bcb524af31963b3e3bb670f28ba14718244", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}