{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: contracts/utils/Ownable.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\ncontract Ownable {\n    address private _contract_owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = msg.sender;\n        _contract_owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _contract_owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_contract_owner, newOwner);\n        _contract_owner = newOwner;\n    }\n}\n\n// File: contracts/utils/SafeMath.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\nlibrary SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a, \"add\");\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a, \"sub\");\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b, \"mul\");\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0, \"div\");\n        c = a / b;\n    }\n}\n\n// File: contracts/utils/Address.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\n// File: contracts/utils/ReentrancyGuard.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\ncontract ReentrancyGuard {\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        _guardCounter = 1;\n    }\n\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n\n// File: contracts/erc20/IERC20.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface ERC20Property{\n  function name() external view returns (string memory);\n  function symbol() external view returns (string memory);\n  function decimals() external view returns (uint8);\n}\n\n// File: contracts/erc20/SafeERC20.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\n\n\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).safeAdd(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).safeSub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// File: contracts/core/Interfaces.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\ninterface IWETH {\n    function withdraw(uint256) external;\n}\ninterface IAAVE {\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 rateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    function getUserAccountData(address)\n        external\n        view\n        returns (\n            uint256 totalCollateralETH,\n            uint256 totalDebtETH,\n            uint256 availableBorrowsETH,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n}\n\ninterface ILido {\n    function submit(address) external payable;\n}\n\ninterface IBalancer {\n    function flashLoan(\n        address recipient,\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes calldata userData\n    ) external;\n}\n\ninterface IBalancerFee{\n    function getFlashLoanFeePercentage() external view returns (uint256);//18 decimal\n}\n\ninterface ICurve{\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns(uint256);\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns(uint256);\n}\n\n// File: contracts/core/EFLeverVault.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\n\n\n\n\n\n\ncontract TokenInterfaceERC20{\n  function destroyTokens(address _owner, uint _amount) public returns(bool);\n  function generateTokens(address _owner, uint _amount) public returns(bool);\n}\n\ncontract EFLeverVault is Ownable, ReentrancyGuard{\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n  using Address for address;\n\n  uint256 public constant ratio_base = 10000;\n\n  uint256 public mlr;\n  address payable public fee_pool;\n  address public ef_token;\n  uint256 public last_earn_block;\n\n  uint256 public block_rate;\n  uint256 last_volume;\n  uint256 last_st;\n  uint256 last_e;\n  uint256 temp;\n\n\n  address public aave = address(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\n  address public balancer = address(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n  address public balancer_fee = address(0xce88686553686DA562CE7Cea497CE749DA109f9F);\n  address public lido = address(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n  address public asteth = address(0x1982b2F5814301d4e9a8b0201555376e62F82428);\n  address public curve_pool = address(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022);\n  address public weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  bool public is_paused;\n\n  //@param _crv, means ETH if it's 0x0\n  constructor(address _ef_token) public {\n    ef_token = _ef_token;\n    mlr = 6750;\n    last_earn_block = block.number;\n  }\n\n  function receiveFlashLoan(\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        uint256[] memory feeAmounts,\n        bytes memory userData\n    ) public payable {\n        require(msg.sender == balancer, \"only flashloan vault\");\n\n        uint256 loan_amount = amounts[0];\n        uint256 fee_amount = feeAmounts[0];\n\n        if (keccak256(userData) == keccak256(\"0x1\")){\n          _deposit(loan_amount, fee_amount);\n        }\n        if (keccak256(userData) == keccak256(\"0x2\")){\n          _withdraw(loan_amount, fee_amount);\n        }\n    }\n\n  event CFFDeposit(address from, uint256 eth_amount, uint256 ef_amount, uint256 virtual_price);\n\n  function getFeeParam() public view returns(uint256){\n    return IBalancerFee(balancer_fee).getFlashLoanFeePercentage().safeDiv(1e14).safeAdd(ratio_base); //10000(1+fee/1e18) \n  }\n\n  function getCollecteral() public view returns(uint256){ //decimal 18\n    if (is_paused) return address(this).balance;\n    (uint256 c, , , , ,) = IAAVE(aave).getUserAccountData(address(this));\n    return c;\n  }\n  function getDebt() public view returns(uint256){ //decimal 18\n    ( , uint256 d, , , ,) = IAAVE(aave).getUserAccountData(address(this));\n    return d;\n  }\n  function getVolume() public view returns(uint256){\n    return getCollecteral().safeSub(getDebt());\n  }\n  function getVirtualPrice() public view returns(uint256){\n    if (IERC20(ef_token).totalSupply() == 0) {return 0;}\n    return getVolume().safeMul(1e18).safeDiv(IERC20(ef_token).totalSupply());\n  }\n\n  function deposit(uint256 _amount) public payable nonReentrant{\n    require(!is_paused, \"paused\");\n    require(_amount == msg.value, \"inconsist amount\");\n    require(_amount != 0, \"too small amount\");\n    \n    uint256 volume_before = getVolume();\n    if (volume_before < 1e9) {require(_amount >= 1e16, \"Too small initial amount\");}\n\n    uint256 fee_para = getFeeParam();\n    uint256 loan_amount = mlr.safeMul(_amount).safeDiv(fee_para.safeSub(mlr));//mx/(a-m)\n    uint256 fee_amount = loan_amount.safeMul(fee_para.safeSub(10000)).safeDiv(10000);\n\n    address[] memory tokens = new address[](1);\n    uint256[] memory amounts = new uint256[](1);\n      \n    bytes memory userData = \"0x1\";\n\n    tokens[0] = weth;\n    amounts[0] = loan_amount;\n    \n    IBalancer(balancer).flashLoan(address(this), tokens, amounts, userData);\n    uint256 ef_amount;\n    if ((volume_before < 1e9)){\n      ef_amount = _amount.safeSub(fee_amount);\n    }\n    else{\n      ef_amount = _amount.safeSub(fee_amount).safeMul(IERC20(ef_token).totalSupply()).safeDiv(volume_before);\n    }\n    TokenInterfaceERC20(ef_token).generateTokens(msg.sender, ef_amount);\n    emit CFFDeposit(msg.sender, _amount, ef_amount, getVirtualPrice());\n  }\n\n  function _deposit(uint256 amount, uint256 fee_amount) internal{\n    IWETH(weth).withdraw(amount);\n    ILido(lido).submit.value(address(this).balance)(address(this));\n\n    uint256 lido_bal = IERC20(lido).balanceOf(address(this));\n    if (IERC20(lido).allowance(address(this), aave) != 0) {IERC20(lido).safeApprove(aave, 0);}\n    IERC20(lido).safeApprove(aave, lido_bal);\n    IAAVE(aave).deposit(lido, lido_bal, address(this), 0);\n\n    uint256 to_repay = amount.safeAdd(fee_amount);\n    IAAVE(aave).borrow(weth, to_repay, 2, 0, address(this));\n    IERC20(weth).safeTransfer(balancer, to_repay);\n  }\n\n  event CFFWithdraw(address from, uint256 eth_amount, uint256 ef_amount, uint256 virtual_price);\n  function withdraw(uint256 _amount) public nonReentrant{\n    require(IERC20(ef_token).balanceOf(msg.sender) >= _amount, \"not enough balance\");\n    if (is_paused){\n      uint256 to_send = address(this).balance.safeMul(_amount).safeDiv(IERC20(ef_token).totalSupply());\n      (bool status, ) = msg.sender.call.value(to_send)(\"\");\n      require(status, \"transfer eth failed\");\n      TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount);\n      return;\n    }\n    uint256 loan_amount = getDebt().safeMul(_amount).safeDiv(IERC20(ef_token).totalSupply());\n    \n    address[] memory tokens = new address[](1);\n    uint256[] memory amounts = new uint256[](1);\n    bytes memory userData = \"0x2\";\n    tokens[0] = weth;\n    amounts[0] = loan_amount;\n    //uint256 user_eth_before = msg.sender.balance;\n    IBalancer(balancer).flashLoan(address(this), tokens, amounts, userData);\n\n    uint256 to_send = address(this).balance;\n    (bool status, ) = msg.sender.call.value(to_send)(\"\");\n    require(status, \"transfer eth failed\");\n\n    TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount);\n    emit CFFWithdraw(msg.sender, to_send, _amount, getVirtualPrice());\n  }\n  //1. rapay aave with flashloaned amount,    mx\n  //2. withdraw steth with current ltv,  x\n  //3. change all steths to eths,    x         \n  //4. repay flashloan.   pay amx, left x-amx eth\n  function _withdraw(uint256 amount, uint256 fee_amount) internal{\n    uint256 steth_amount = amount.safeMul(IERC20(asteth).balanceOf(address(this))).safeDiv(getDebt());\n    if (IERC20(weth).allowance(address(this), aave) != 0) {IERC20(weth).safeApprove(aave, 0);}\n    IERC20(weth).safeApprove(aave, amount);\n\n    IAAVE(aave).repay(weth, amount, 2, address(this));\n    IAAVE(aave).withdraw(lido, steth_amount, address(this));\n\n    if (IERC20(lido).allowance(address(this), curve_pool) != 0) {IERC20(lido).safeApprove(curve_pool, 0);}\n    IERC20(lido).safeApprove(curve_pool, steth_amount);\n    ICurve(curve_pool).exchange(1, 0, steth_amount, 0);\n\n    (bool status, ) = weth.call.value(amount.safeAdd(fee_amount))(\"\");\n    require(status, \"transfer eth failed\");\n    IERC20(weth).safeTransfer(balancer, amount.safeAdd(fee_amount));\n  }\n  event EFPause(uint256 eth_amount, uint256 virtual_price);\n  function pause() public onlyOwner{\n    require(!is_paused, \"paused\");\n    uint256 loan_amount = getDebt();\n    \n    address[] memory tokens = new address[](1);\n    uint256[] memory amounts = new uint256[](1);\n    bytes memory userData = \"0x2\";\n    tokens[0] = weth;\n    amounts[0] = loan_amount;\n    IBalancer(balancer).flashLoan(address(this), tokens, amounts, userData);\n    is_paused = true;\n    emit EFPause(address(this).balance, getVirtualPrice());\n  }\n\n  event EFRestart(uint256 eth_amount, uint256 virtual_price);\n  function restart() public onlyOwner{\n    require(is_paused, \"not pause\");\n\n    uint256 _amount = address(this).balance;\n    uint256 fee_para = getFeeParam();\n    uint256 loan_amount = mlr.safeMul(_amount).safeDiv(fee_para.safeSub(mlr));//mx/(a-m)\n\n    address[] memory tokens = new address[](1);\n    uint256[] memory amounts = new uint256[](1);\n    bytes memory userData = \"0x1\";\n    tokens[0] = weth;\n    amounts[0] = loan_amount;\n    IBalancer(balancer).flashLoan(address(this), tokens, amounts, userData);\n    is_paused = false;\n    emit EFRestart(_amount, getVirtualPrice());\n  }\n\n\n  event ActualLTVChanged(uint256 debt_before, uint256 collecteral_before, uint256 debt_after, uint256 collecteral_after);\n  function reduceActualLTV() public onlyOwner{\n    uint256 e = getDebt();\n    uint256 st = getCollecteral();    \n    require(e.safeMul(10000) > st.safeMul(mlr), \"no need to reduce\");\n    uint256 x = (e.safeMul(10000).safeSub(st.safeMul(mlr))).safeDiv(uint256(10000).safeSub(mlr));//x = (E-mST)/(1-m)\n\n    uint256 loan_amount = x.safeMul(getDebt()).safeDiv(getCollecteral());\n    address[] memory tokens = new address[](1);\n    uint256[] memory amounts = new uint256[](1);\n    bytes memory userData = \"0x2\";\n    tokens[0] = weth;\n    amounts[0] = loan_amount;\n    IBalancer(balancer).flashLoan(address(this), tokens, amounts, userData);\n\n    (bool status, ) = weth.call.value(address(this).balance)(\"\");\n    require(status, \"transfer eth failed\");\n    \n    if (IERC20(weth).allowance(address(this), aave) != 0) {IERC20(weth).safeApprove(aave, 0);}\n    IERC20(weth).safeApprove(aave, IERC20(weth).balanceOf(address(this)));\n    IAAVE(aave).repay(weth, IERC20(weth).balanceOf(address(this)), 2, address(this));\n    emit ActualLTVChanged(e, st, getDebt(), getCollecteral());\n  }\n\n  function raiseActualLTV(uint256 lt) public onlyOwner{//take lt = 7500\n    uint256 e = getDebt();\n    uint256 st = getCollecteral();    \n    require(e.safeMul(10000) < st.safeMul(mlr), \"no need to raise\");\n    uint256 x = st.safeMul(mlr).safeSub(e.safeMul(10000)).safeDiv(uint256(10000).safeSub(mlr));//x = (mST-E)/(1-m)\n    uint256 y = st.safeMul(lt).safeDiv(10000).safeSub(e).safeSub(1);\n    if (x > y) {x = y;}\n    IAAVE(aave).borrow(weth, x, 2, 0, address(this));\n    IWETH(weth).withdraw(IERC20(weth).balanceOf(address(this)));\n    ILido(lido).submit.value(address(this).balance)(address(this));\n\n    if (IERC20(lido).allowance(address(this), aave) != 0) {IERC20(lido).safeApprove(aave, 0);}\n    IERC20(lido).safeApprove(aave, IERC20(lido).balanceOf(address(this)));\n    IAAVE(aave).deposit(lido, IERC20(lido).balanceOf(address(this)), address(this), 0);\n\n    emit ActualLTVChanged(e, st, getDebt(), getCollecteral());\n  }\n  event EFEarnReward(uint256 eth_amount, uint256 ef_amount);\n  function earnReward() public onlyOwner{\n    if (fee_pool == address(0x0)) return;\n    uint256 len = block.number.safeSub(last_earn_block);\n    uint256 A = last_volume.safeMul(block_rate).safeMul(len).safeDiv(1e18);\n    uint256 B = getVolume().safeMul(block_rate).safeMul(len).safeDiv(1e18);\n \n    uint256 st_fee;\n    if (A <= B){\n      st_fee = A.safeAdd(B).safeDiv(2);\n    }\n    else{\n      st_fee = B;\n    }\n    st_fee = st_fee.safeSub(st_fee.safeMul(IERC20(ef_token).balanceOf(fee_pool)).safeDiv(IERC20(ef_token).totalSupply()));\n    uint256 ef_amount = st_fee.safeMul(IERC20(ef_token).totalSupply()).safeDiv(getVolume().safeSub(st_fee));\n    TokenInterfaceERC20(ef_token).generateTokens(fee_pool, ef_amount);\n    last_volume = getVolume();\n    last_earn_block = block.number;\n\n    emit EFEarnReward(st_fee, ef_amount);\n  }\n\n  event ChangeMaxLoanRate(uint256 old, uint256 _new);\n  function changeMaxLoanRate(uint256 _new) public onlyOwner{\n    uint256 old = mlr;\n    mlr = _new;\n    emit ChangeMaxLoanRate(old, _new);\n  }\n\n  event ChangeBlockRate(uint256 old, uint256 _new);\n  function changeBlockRate(uint256 _r) public onlyOwner{//18 decimal, 2102400 blocks in a year\n    uint256 old = block_rate;\n    block_rate = _r;\n    emit ChangeBlockRate(old, _r);\n  }\n\n  event ChangeFeePool(address old, address _new);\n  function changeFeePool(address payable _fp) public onlyOwner{\n    address old = fee_pool;\n    fee_pool = _fp;\n    emit ChangeFeePool(old, fee_pool);\n  }\n\n  function callWithData(address payable to, bytes memory data, uint256 amount)public payable onlyOwner{\n    (bool status, ) = to.call.value(amount)(data);\n    require(status, \"call failed\");\n  }\n\n  function delegateCallWithData(address payable to, bytes memory data)public payable onlyOwner{\n    (bool status, ) = to.delegatecall(data);\n    require(status, \"call failed\");\n  }\n\n\n  function() external payable{}\n  }\n\ncontract EFLeverVaultFactory{\n  event NewEFLeverVault(address addr);\n\n  function createEFLeverVault(address _ef_token) public returns(address){\n    EFLeverVault cf = new EFLeverVault(_ef_token);\n    cf.transferOwnership(msg.sender);\n    emit NewEFLeverVault(address(cf));\n    return address(cf);\n  }\n\n}\n", "ABI": "[{\"constant\":false,\"inputs\":[],\"name\":\"reduceActualLTV\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratio_base\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDebt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lido\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeeParam\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balancer_fee\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"asteth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCollecteral\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_r\",\"type\":\"uint256\"}],\"name\":\"changeBlockRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mlr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"last_earn_block\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"delegateCallWithData\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ef_token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"changeMaxLoanRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee_pool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aave\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curve_pool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"is_paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"callWithData\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fp\",\"type\":\"address\"}],\"name\":\"changeFeePool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVirtualPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balancer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"block_rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"feeAmounts\",\"type\":\"uint256[]\"},{\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"receiveFlashLoan\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lt\",\"type\":\"uint256\"}],\"name\":\"raiseActualLTV\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"earnReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ef_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ef_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"virtual_price\",\"type\":\"uint256\"}],\"name\":\"CFFDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ef_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"virtual_price\",\"type\":\"uint256\"}],\"name\":\"CFFWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"eth_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"virtual_price\",\"type\":\"uint256\"}],\"name\":\"EFPause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"eth_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"virtual_price\",\"type\":\"uint256\"}],\"name\":\"EFRestart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"debt_before\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"collecteral_before\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"debt_after\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"collecteral_after\",\"type\":\"uint256\"}],\"name\":\"ActualLTVChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"eth_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ef_amount\",\"type\":\"uint256\"}],\"name\":\"EFEarnReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"old\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"ChangeMaxLoanRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"old\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"ChangeBlockRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"old\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"ChangeFeePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "EFLeverVault", "CompilerVersion": "v0.5.10+commit.5a6ea5b1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e6e0ab5e9352202e99415bc0cb9a08a5072d7596", "EVMVersion": "Default", "Library": "SafeMath:071108ad85d7a766b41e0f5e5195537a8fc8e74d", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}