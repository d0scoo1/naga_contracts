{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"},\"ERC2981Base.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n* Author: Lambdalf the White\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport \\\"./IERC2981.sol\\\";\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\nabstract contract ERC2981Base is IERC165, IERC2981 {\\r\\n\\t// Errors\\r\\n\\terror IERC2981_INVALID_ROYALTIES();\\r\\n\\r\\n\\t// Royalty rate is stored out of 10,000 instead of a percentage to allow for\\r\\n\\t// up to two digits below the unit such as 2.5% or 1.25%.\\r\\n\\tuint256 private constant ROYALTY_BASE = 10000;\\r\\n\\r\\n\\t// Represents the percentage of royalties on each sale on secondary markets.\\r\\n\\t// Set to 0 to have no royalties.\\r\\n\\tuint256 private _royaltyRate;\\r\\n\\r\\n\\t// Address of the recipient of the royalties.\\r\\n\\taddress private _recipient;\\r\\n\\r\\n\\tfunction _initERC2981Base( address recipient_, uint256 royaltyRate_ ) internal {\\r\\n\\t\\t_setRoyaltyInfo( recipient_, royaltyRate_ );\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev See {IERC2981-royaltyInfo}.\\r\\n\\t* \\r\\n\\t* Note: This function should be overriden to revert on a query for non existent token.\\r\\n\\t*/\\r\\n\\tfunction royaltyInfo( uint256 tokenId_, uint256 salePrice_ ) public view virtual override returns ( address, uint256 ) {\\r\\n\\t\\tif ( salePrice_ == 0 || _royaltyRate == 0 ) {\\r\\n\\t\\t\\treturn ( _recipient, 0 );\\r\\n\\t\\t}\\r\\n\\t\\tuint256 _royaltyAmount_ = _royaltyRate * salePrice_ / ROYALTY_BASE;\\r\\n\\t\\treturn ( _recipient, _royaltyAmount_ );\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Sets the royalty rate to `royaltyRate_` and the royalty recipient to `recipient_`.\\r\\n\\t* \\r\\n\\t* Requirements: \\r\\n\\t* \\r\\n\\t* - `royaltyRate_` cannot be higher than `ROYALTY_BASE`;\\r\\n\\t*/\\r\\n\\tfunction _setRoyaltyInfo( address recipient_, uint256 royaltyRate_ ) internal virtual {\\r\\n\\t\\tif ( royaltyRate_ \\u003e ROYALTY_BASE ) {\\r\\n\\t\\t\\trevert IERC2981_INVALID_ROYALTIES();\\r\\n\\t\\t}\\r\\n\\t\\t_royaltyRate = royaltyRate_;\\r\\n\\t\\t_recipient = recipient_;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev See {IERC165-supportsInterface}.\\r\\n\\t*/\\r\\n\\tfunction supportsInterface( bytes4 interfaceId_ ) public view virtual override returns ( bool ) {\\r\\n\\t\\treturn \\r\\n\\t\\t\\tinterfaceId_ == type( IERC2981 ).interfaceId ||\\r\\n\\t\\t\\tinterfaceId_ == type( IERC165 ).interfaceId;\\r\\n\\t}\\r\\n}\\r\\n\"},\"ERC721Batch.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/**\\n* Author: Lambdalf the White\\n*/\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n* @dev Required interface of an ERC721 compliant contract.\\n*/\\nabstract contract ERC721Batch is Context, IERC721Metadata {\\n  /**\\n  * @dev See EIP2309 https://eips.ethereum.org/EIPS/eip-2309\\n  */\\n  event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\\n\\n  // Errors\\n  error IERC721_APPROVE_OWNER();\\n  error IERC721_APPROVE_CALLER();\\n  error IERC721_CALLER_NOT_APPROVED();\\n  error IERC721_NONEXISTANT_TOKEN();\\n  error IERC721_NULL_ADDRESS_BALANCE();\\n  error IERC721_NULL_ADDRESS_TRANSFER();\\n  error IERC721_NON_ERC721_RECEIVER();\\n\\n  // Token name\\n  string private _name;\\n\\n  // Token symbol\\n  string private _symbol;\\n\\n  // Token Base URI\\n  string private _baseURI;\\n\\n  // Token IDs\\n  uint256 private _numTokens;\\n\\n  // List of owner addresses\\n  mapping( uint256 =\\u003e address ) private _owners;\\n\\n  // Mapping from token ID to approved address\\n  mapping( uint256 =\\u003e address ) private _tokenApprovals;\\n\\n  // Mapping from owner to operator approvals\\n  mapping( address =\\u003e mapping( address =\\u003e bool ) ) private _operatorApprovals;\\n\\n  /**\\n  * @dev Ensures the token exist. \\n  * A token exists if it has been minted and is not owned by the null address.\\n  * \\n  * @param tokenId_ uint256 ID of the token to verify\\n  */\\n  modifier exists( uint256 tokenId_ ) {\\n    if ( ! _exists( tokenId_ ) ) {\\n      revert IERC721_NONEXISTANT_TOKEN();\\n    }\\n    _;\\n  }\\n\\n  /**\\n  * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n  */\\n  function _initERC721BatchMetadata( string memory name_, string memory symbol_ ) internal {\\n    _name   = name_;\\n    _symbol = symbol_;\\n  }\\n\\n  /**\\n  * @dev Mints `qty_` tokens into `to_`.\\n  * \\n  * This internal function can be used to perform token minting.\\n  * \\n  * Emits a {ConsecutiveTransfer} event.\\n  */\\n  function _mint( address to_, uint256 qty_ ) internal virtual {\\n    _owners[ _numTokens ] = to_;\\n    uint256 _lastToken_ = _numTokens + qty_ - 1;\\n    if ( _lastToken_ != _numTokens ) {\\n      _owners[ _lastToken_ ] = to_;\\n    }\\n    emit ConsecutiveTransfer( _numTokens, _lastToken_, address( 0 ), to_ );\\n    _numTokens = _lastToken_ + 1;\\n  }\\n\\n  /**\\n  * @dev Internal function used to set the base URI of the collection.\\n  */\\n  function _setBaseURI( string memory baseURI_ ) internal virtual {\\n    _baseURI = baseURI_;\\n  }\\n\\n  /**\\n  * @dev Transfers `tokenId_` from `from_` to `to_`.\\n  *\\n  * This internal function can be used to implement alternative mechanisms to perform \\n  * token transfer, such as signature-based, or token burning.\\n  * \\n  * Emits a {Transfer} event.\\n  */\\n  function _transfer( address from_, address to_, uint256 tokenId_ ) internal virtual {\\n    _tokenApprovals[ tokenId_ ] = address( 0 );\\n    uint256 _previousId_ = tokenId_ - 1;\\n    uint256 _nextId_     = tokenId_ + 1;\\n    bool _previousShouldUpdate_ = _exists( _previousId_ ) \\u0026\\u0026\\n                                  _owners[ _previousId_ ] == address( 0 );\\n    bool _nextShouldUpdate_ = _exists( _nextId_ ) \\u0026\\u0026\\n                              _owners[ _nextId_ ] == address( 0 );\\n\\n    if ( _previousShouldUpdate_ ) {\\n      _owners[ _previousId_ ] = from_;\\n    }\\n\\n    if ( _nextShouldUpdate_ ) {\\n      _owners[ _nextId_ ] = from_;\\n    }\\n\\n    _owners[ tokenId_ ] = to_;\\n\\n    emit Transfer( from_, to_, tokenId_ );\\n  }\\n\\n  /**\\n  * @dev See {IERC721-approve}.\\n  */\\n  function approve( address to_, uint256 tokenId_ ) external virtual exists( tokenId_ ) {\\n    address _operator_ = _msgSender();\\n    address _tokenOwner_ = _ownerOf( tokenId_ );\\n    bool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\\n\\n    if ( ! _isApproved_ ) {\\n      revert IERC721_CALLER_NOT_APPROVED();\\n    }\\n\\n    if ( to_ == _tokenOwner_ ) {\\n      revert IERC721_APPROVE_OWNER();\\n    }\\n\\n    _tokenApprovals[ tokenId_ ] = to_;\\n    emit Approval( _tokenOwner_, to_, tokenId_ );\\n  }\\n\\n  /**\\n  * @dev See {IERC721-safeTransferFrom}.\\n  * \\n  * Note: We can ignore `from_` as we can compare everything to the actual token owner, \\n  * but we cannot remove this parameter to stay in conformity with IERC721\\n  */\\n  function safeTransferFrom( address from_, address to_, uint256 tokenId_ ) external virtual exists( tokenId_ ) {\\n    address _operator_ = _msgSender();\\n    address _tokenOwner_ = _ownerOf( tokenId_ );\\n    bool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\\n\\n    if ( ! _isApproved_ ) {\\n      revert IERC721_CALLER_NOT_APPROVED();\\n    }\\n\\n    if ( to_ == address( 0 ) ) {\\n      revert IERC721_NULL_ADDRESS_TRANSFER();\\n    }\\n\\n    _transfer( _tokenOwner_, to_, tokenId_ );\\n\\n    if ( ! _checkOnERC721Received( _tokenOwner_, to_, tokenId_, \\\"\\\" ) ) {\\n      revert IERC721_NON_ERC721_RECEIVER();\\n    }\\n  }\\n\\n  /**\\n  * @dev See {IERC721-safeTransferFrom}.\\n  * \\n  * Note: We can ignore `from_` as we can compare everything to the actual token owner, \\n  * but we cannot remove this parameter to stay in conformity with IERC721\\n  */\\n  function safeTransferFrom( address from_, address to_, uint256 tokenId_, bytes calldata data_ ) external virtual exists( tokenId_ ) {\\n    address _operator_ = _msgSender();\\n    address _tokenOwner_ = _ownerOf( tokenId_ );\\n    bool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\\n\\n    if ( ! _isApproved_ ) {\\n      revert IERC721_CALLER_NOT_APPROVED();\\n    }\\n\\n    if ( to_ == address( 0 ) ) {\\n      revert IERC721_NULL_ADDRESS_TRANSFER();\\n    }\\n\\n    _transfer( _tokenOwner_, to_, tokenId_ );\\n\\n    if ( ! _checkOnERC721Received( _tokenOwner_, to_, tokenId_, data_ ) ) {\\n      revert IERC721_NON_ERC721_RECEIVER();\\n    }\\n  }\\n\\n  /**\\n  * @dev See {IERC721-setApprovalForAll}.\\n  */\\n  function setApprovalForAll( address operator_, bool approved_ ) public virtual override {\\n    address _account_ = _msgSender();\\n    if ( operator_ == _account_ ) {\\n      revert IERC721_APPROVE_CALLER();\\n    }\\n\\n    _operatorApprovals[ _account_ ][ operator_ ] = approved_;\\n    emit ApprovalForAll( _account_, operator_, approved_ );\\n  }\\n\\n  /**\\n  * @dev See {IERC721-transferFrom}.\\n  * \\n  * Note: We can ignore `from_` as we can compare everything to the actual token owner, \\n  * but we cannot remove this parameter to stay in conformity with IERC721\\n  */\\n  function transferFrom( address from_, address to_, uint256 tokenId_ ) external virtual exists( tokenId_ ) {\\n    address _operator_ = _msgSender();\\n    address _tokenOwner_ = _ownerOf( tokenId_ );\\n    bool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\\n\\n    if ( ! _isApproved_ ) {\\n      revert IERC721_CALLER_NOT_APPROVED();\\n    }\\n\\n    if ( to_ == address( 0 ) ) {\\n      revert IERC721_NULL_ADDRESS_TRANSFER();\\n    }\\n\\n    _transfer( _tokenOwner_, to_, tokenId_ );\\n  }\\n\\n  /**\\n  * @dev Internal function returning the number of tokens in `tokenOwner_`\\u0027s account.\\n  */\\n  function _balanceOf( address tokenOwner_ ) internal view virtual returns ( uint256 balance ) {\\n    if ( tokenOwner_ == address( 0 ) ) {\\n      return 0;\\n    }\\n\\n    uint256 _supplyMinted_ = _supplyMinted();\\n    uint256 _count_ = 0;\\n    address _currentTokenOwner_;\\n    for ( uint256 i; i \\u003c _supplyMinted_; i++ ) {\\n      if ( _exists( i ) ) {\\n        if ( _owners[ i ] != address( 0 ) ) {\\n          _currentTokenOwner_ = _owners[ i ];\\n        }\\n        if ( tokenOwner_ == _currentTokenOwner_ ) {\\n          _count_++;\\n        }\\n      }\\n    }\\n    return _count_;\\n  }\\n\\n  /**\\n  * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n  * The call is not executed if the target address is not a contract.\\n  *\\n  * @param from_ address representing the previous owner of the given token ID\\n  * @param to_ target address that will receive the tokens\\n  * @param tokenId_ uint256 ID of the token to be transferred\\n  * @param data_ bytes optional data to send along with the call\\n  * @return bool whether the call correctly returned the expected magic value\\n  */\\n  function _checkOnERC721Received( address from_, address to_, uint256 tokenId_, bytes memory data_ ) internal virtual returns ( bool ) {\\n    // This method relies on extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n    // \\n    // IMPORTANT\\n    // It is unsafe to assume that an address not flagged by this method\\n    // is an externally-owned account (EOA) and not a contract.\\n    //\\n    // Among others, the following types of addresses will not be flagged:\\n    //\\n    //  - an externally-owned account\\n    //  - a contract in construction\\n    //  - an address where a contract will be created\\n    //  - an address where a contract lived, but was destroyed\\n    uint256 _size_;\\n    assembly {\\n      _size_ := extcodesize( to_ )\\n    }\\n\\n    // If address is a contract, check that it is aware of how to handle ERC721 tokens\\n    if ( _size_ \\u003e 0 ) {\\n      try IERC721Receiver( to_ ).onERC721Received( _msgSender(), from_, tokenId_, data_ ) returns ( bytes4 retval ) {\\n        return retval == IERC721Receiver.onERC721Received.selector;\\n      }\\n      catch ( bytes memory reason ) {\\n        if ( reason.length == 0 ) {\\n          revert IERC721_NON_ERC721_RECEIVER();\\n        }\\n        else {\\n          assembly {\\n            revert( add( 32, reason ), mload( reason ) )\\n          }\\n        }\\n      }\\n    }\\n    else {\\n      return true;\\n    }\\n  }\\n\\n  /**\\n  * @dev Internal function returning whether a token exists. \\n  * A token exists if it has been minted and is not owned by the null address.\\n  * \\n  * @param tokenId_ uint256 ID of the token to verify\\n  * \\n  * @return bool whether the token exists\\n  */\\n  function _exists( uint256 tokenId_ ) internal view virtual returns ( bool ) {\\n    return tokenId_ \\u003c _numTokens;\\n  }\\n\\n  /**\\n  * @dev Internal function returning whether `operator_` is allowed \\n  * to manage tokens on behalf of `tokenOwner_`.\\n  * \\n  * @param tokenOwner_ address that owns tokens\\n  * @param operator_ address that tries to manage tokens\\n  * \\n  * @return bool whether `operator_` is allowed to handle the token\\n  */\\n  function _isApprovedForAll( address tokenOwner_, address operator_ ) internal view virtual returns ( bool ) {\\n    return _operatorApprovals[ tokenOwner_ ][ operator_ ];\\n  }\\n\\n  /**\\n  * @dev Internal function returning whether `operator_` is allowed to handle `tokenId_`\\n  * \\n  * Note: To avoid multiple checks for the same data, it is assumed that existence of `tokeId_` \\n  * has been verified prior via {_exists}\\n  * If it hasn\\u0027t been verified, this function might panic\\n  * \\n  * @param operator_ address that tries to handle the token\\n  * @param tokenId_ uint256 ID of the token to be handled\\n  * \\n  * @return bool whether `operator_` is allowed to handle the token\\n  */\\n  function _isApprovedOrOwner( address tokenOwner_, address operator_, uint256 tokenId_ ) internal view virtual returns ( bool ) {\\n    bool _isApproved_ = operator_ == tokenOwner_ ||\\n                        operator_ == _tokenApprovals[ tokenId_ ] ||\\n                        _isApprovedForAll( tokenOwner_, operator_ );\\n    return _isApproved_;\\n  }\\n\\n  /**\\n  * @dev Internal function returning the owner of the `tokenId_` token.\\n  * \\n  * @param tokenId_ uint256 ID of the token to verify\\n  * \\n  * @return address the address of the token owner\\n  */\\n  function _ownerOf( uint256 tokenId_ ) internal view virtual returns ( address ) {\\n    uint256 _tokenId_ = tokenId_;\\n    address _tokenOwner_ = _owners[ tokenId_ ];\\n    while ( _tokenOwner_ == address( 0 ) ) {\\n      _tokenId_ --;\\n      _tokenOwner_ = _owners[ _tokenId_ ];\\n    }\\n\\n    return _tokenOwner_;\\n  }\\n\\n  /**\\n  * @dev Internal function returning the total number of tokens minted\\n  * \\n  * @return uint256 the number of tokens that have been minted so far\\n  */\\n  function _supplyMinted() internal view virtual returns ( uint256 ) {\\n    return _numTokens;\\n  }\\n\\n  /**\\n  * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n  */\\n  function _toString( uint256 value ) internal pure returns ( string memory ) {\\n    // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n    if ( value == 0 ) {\\n      return \\\"0\\\";\\n    }\\n    uint256 temp = value;\\n    uint256 digits;\\n    while ( temp != 0 ) {\\n      digits ++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes( digits );\\n    while ( value != 0 ) {\\n      digits -= 1;\\n      buffer[ digits ] = bytes1( uint8( 48 + uint256( value % 10 ) ) );\\n      value /= 10;\\n    }\\n    return string( buffer );\\n  }\\n\\n  /**\\n  * @dev Returns the number of tokens in `tokenOwner_`\\u0027s account.\\n  */\\n  function balanceOf( address tokenOwner_ ) external view virtual returns ( uint256 balance ) {\\n    return _balanceOf( tokenOwner_ );\\n  }\\n\\n  /**\\n  * @dev Returns the account approved for `tokenId_` token.\\n  *\\n  * Requirements:\\n  *\\n  * - `tokenId_` must exist.\\n  */\\n  function getApproved( uint256 tokenId_ ) external view virtual exists( tokenId_ ) returns ( address operator ) {\\n    return _tokenApprovals[ tokenId_ ];\\n  }\\n\\n  /**\\n  * @dev Returns if the `operator_` is allowed to manage all of the assets of `tokenOwner_`.\\n  *\\n  * See {setApprovalForAll}\\n  */\\n  function isApprovedForAll( address tokenOwner_, address operator_ ) external view virtual returns ( bool ) {\\n    return _isApprovedForAll( tokenOwner_, operator_ );\\n  }\\n\\n  /**\\n  * @dev See {IERC721Metadata-name}.\\n  */\\n  function name() public view virtual override returns ( string memory ) {\\n    return _name;\\n  }\\n\\n  /**\\n  * @dev Returns the owner of the `tokenId_` token.\\n  *\\n  * Requirements:\\n  *\\n  * - `tokenId_` must exist.\\n  */\\n  function ownerOf( uint256 tokenId_ ) external view virtual exists( tokenId_ ) returns ( address owner ) {\\n    return _ownerOf( tokenId_ );\\n  }\\n\\n  /**\\n  * @dev See {IERC165-supportsInterface}.\\n  */\\n  function supportsInterface( bytes4 interfaceId_ ) public view virtual override returns ( bool ) {\\n    return \\n      interfaceId_ == type( IERC721Metadata ).interfaceId ||\\n      interfaceId_ == type( IERC721 ).interfaceId ||\\n      interfaceId_ == type( IERC165 ).interfaceId;\\n  }\\n\\n  /**\\n  * @dev See {IERC721Metadata-symbol}.\\n  */\\n  function symbol() public view virtual override returns ( string memory ) {\\n    return _symbol;\\n  }\\n\\n  /**\\n  * @dev See {IERC721Metadata-tokenURI}.\\n  */\\n  function tokenURI( uint256 tokenId_ ) public view virtual override exists( tokenId_ ) returns ( string memory ) {\\n    return bytes( _baseURI ).length \\u003e 0 ? string( abi.encodePacked( _baseURI, _toString( tokenId_ ) ) ) : _toString( tokenId_ );\\n  }\\n}\\n\"},\"ERC721BatchBurnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n* Author: Lambdalf the White\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport \\\"./ERC721Batch.sol\\\";\\r\\n\\r\\nabstract contract ERC721BatchBurnable is ERC721Batch {\\r\\n  // List of burned tokens\\r\\n  mapping( uint256 =\\u003e bool ) private _burned;\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Burns `tokenId_`.\\r\\n\\t*\\r\\n\\t* Requirements:\\r\\n\\t*\\r\\n\\t* - `tokenId_` must exist\\r\\n\\t* - The caller must own `tokenId_` or be an approved operator\\r\\n\\t*/\\r\\n\\tfunction burn( uint256 tokenId_ ) external exists( tokenId_ ) {\\r\\n    address _operator_ = _msgSender();\\r\\n    address _tokenOwner_ = _ownerOf( tokenId_ );\\r\\n    bool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\\r\\n\\r\\n    if ( ! _isApproved_ ) {\\r\\n      revert IERC721_CALLER_NOT_APPROVED();\\r\\n    }\\r\\n\\r\\n    _burned[ tokenId_ ] = true;\\r\\n\\t\\t_transfer( _tokenOwner_, address( 0 ), tokenId_ );\\r\\n\\t}\\r\\n\\r\\n  /**\\r\\n  * @dev Internal function returning whether a token exists. \\r\\n  * A token exists if it has been minted and is not owned by the null address.\\r\\n  * \\r\\n  * @param tokenId_ uint256 ID of the token to verify\\r\\n  * \\r\\n  * @return bool whether the token exists\\r\\n  */\\r\\n  function _exists( uint256 tokenId_ ) internal override view returns ( bool ) {\\r\\n    return ! _burned[ tokenId_ ] \\u0026\\u0026 super._exists( tokenId_ );\\r\\n  }\\r\\n}\\r\\n\"},\"IAdministrable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n* Author: Lambdalf the White\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.10;\\r\\nimport \\u0027./IOwnable.sol\\u0027;\\r\\n\\r\\n/**\\r\\n* @dev Contract module which provides a basic access control mechanism, where\\r\\n* there is an account (an owner) that can be granted exclusive access to\\r\\n* specific functions.\\r\\n*\\r\\n* By default, the owner account will be the one that deploys the contract. This\\r\\n* can later be changed with {transferOwnership}.\\r\\n*\\r\\n* This module is used through inheritance. It will make available the modifier\\r\\n* `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n* the owner.\\r\\n*/\\r\\nabstract contract IAdministrable is IOwnable {\\r\\n\\t// Errors\\r\\n\\terror IAdministrable_NOT_ADMIN();\\r\\n\\r\\n\\tbytes32 public constant ADMIN_ROLE = keccak256( \\\"ADMIN_ROLE\\\" );\\r\\n\\r\\n\\t// The list of admin addresses\\r\\n\\tmapping( address =\\u003e bool ) private _admin;\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Emitted when admin role is granted.\\r\\n\\t*/\\r\\n\\tevent RoleGranted( bytes32 indexed role, address indexed account, address indexed operator );\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Emitted when admin role is revoked or renounced.\\r\\n\\t*/\\r\\n\\tevent RoleRevoked( bytes32 indexed role, address indexed account, address indexed operator );\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Throws if called by any account that is not an admin.\\r\\n\\t*/\\r\\n\\tmodifier onlyAdmin() {\\r\\n\\t\\tif ( ! isAdmin( msg.sender ) ) {\\r\\n\\t\\t\\trevert IAdministrable_NOT_ADMIN();\\r\\n\\t\\t}\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Grants admin privileges to `account_`.\\r\\n\\t* Can only be called by the current owner.\\r\\n\\t*/\\r\\n\\tfunction grantAdmin( address account_ ) public virtual onlyOwner {\\r\\n\\t\\t_admin[ account_ ] = true;\\r\\n\\t\\temit RoleGranted( ADMIN_ROLE, account_, msg.sender );\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Renonce admin privileges.\\r\\n\\t* Can only be called by the current owner.\\r\\n\\t*/\\r\\n\\tfunction renounceAdmin() public virtual onlyAdmin {\\r\\n\\t\\tdelete _admin[ msg.sender ];\\r\\n\\t\\temit RoleRevoked( ADMIN_ROLE, msg.sender, msg.sender );\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Revokes admin privileges from `account_`.\\r\\n\\t* Can only be called by the current owner.\\r\\n\\t*/\\r\\n\\tfunction revokeAdmin( address account_ ) public virtual onlyOwner {\\r\\n\\t\\tdelete _admin[ account_ ];\\r\\n\\t\\temit RoleRevoked( ADMIN_ROLE, account_, msg.sender );\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Returns whether the address is an admin or not.\\r\\n\\t* The contract owner is always considered an admin.\\r\\n\\t*/\\r\\n\\tfunction isAdmin( address account_ ) public view virtual returns ( bool ) {\\r\\n\\t\\treturn account_ == owner() || _admin[ account_ ];\\r\\n\\t}\\r\\n}\\r\\n\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC2981.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.10;\\r\\n\\r\\ninterface IERC2981 {\\r\\n  /**\\r\\n  * @dev ERC165 bytes to add to interface array - set in parent contract\\r\\n  * implementing this standard\\r\\n  *\\r\\n  * bytes4(keccak256(\\\"royaltyInfo(uint256,uint256)\\\")) == 0x2a55205a\\r\\n  * bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\\r\\n  * _registerInterface(_INTERFACE_ID_ERC2981);\\r\\n  *\\r\\n  * @notice Called with the sale price to determine how much royalty\\r\\n  *           is owed and to whom.\\r\\n  * @param _tokenId - the NFT asset queried for royalty information\\r\\n  * @param _salePrice - the sale price of the NFT asset specified by _tokenId\\r\\n  * @return receiver - address of who should be sent the royalty payment\\r\\n  * @return royaltyAmount - the royalty payment amount for _salePrice\\r\\n  */\\r\\n  function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view returns (address receiver, uint256 royaltyAmount);\\r\\n}\\r\\n\"},\"IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n* @dev Required interface of an ERC721 compliant contract.\\n*/\\ninterface IERC721 is IERC165 {\\n  /**\\n  * @dev Emitted when `tokenId_` token is transferred from `from_` to `to_`.\\n  */\\n  event Transfer( address indexed from_, address indexed to_, uint256 indexed tokenId_ );\\n\\n  /**\\n  * @dev Emitted when `owner_` enables `approved_` to manage the `tokenId_` token.\\n  */\\n  event Approval( address indexed owner_, address indexed approved_, uint256 indexed tokenId_ );\\n\\n  /**\\n  * @dev Emitted when `owner_` enables or disables (`approved`) `operator_` to manage all of its assets.\\n  */\\n  event ApprovalForAll( address indexed owner_ , address indexed operator_ , bool approved_ );\\n\\n  /**\\n  * @dev Gives permission to `to_` to transfer `tokenId_` token to another account.\\n  * The approval is cleared when the token is transferred.\\n  *\\n  * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n  *\\n  * Requirements:\\n  *\\n  * - The caller must own the token or be an approved operator.\\n  * - `tokenId_` must exist.\\n  *\\n  * Emits an {Approval} event.\\n  */\\n  function approve( address to_, uint256 tokenId_ ) external;\\n\\n  /**\\n  * @dev Safely transfers `tokenId_` token from `from_` to `to_`, checking first that contract recipients\\n  * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n  *\\n  * Requirements:\\n  *\\n  * - `from_` cannot be the zero address.\\n  * - `to_` cannot be the zero address.\\n  * - `tokenId_` token must exist and be owned by `from_`.\\n  * - If the caller is not `from_`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n  * - If `to_` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n  *\\n  * Emits a {Transfer} event.\\n  */\\n  function safeTransferFrom( address from_, address to_, uint256 tokenI_d ) external;\\n\\n  /**\\n  * @dev Safely transfers `tokenId_` token from `from_` to `to_`.\\n  *\\n  * Requirements:\\n  *\\n  * - `from_` cannot be the zero address.\\n  * - `to_` cannot be the zero address.\\n  * - `tokenId_` token must exist and be owned by `from_`.\\n  * - If the caller is not `from_`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n  * - If `to_` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n  *\\n  * Emits a {Transfer} event.\\n  */\\n  function safeTransferFrom( address from_, address to_, uint256 tokenId_, bytes calldata data_ ) external;\\n\\n  /**\\n  * @dev Approve or remove `operator_` as an operator for the caller.\\n  * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n  *\\n  * Requirements:\\n  *\\n  * - The `operator_` cannot be the caller.\\n  *\\n  * Emits an {ApprovalForAll} event.\\n  */\\n  function setApprovalForAll( address operator_, bool approved_ ) external;\\n\\n  /**\\n  * @dev Transfers `tokenId_` token from `from_` to `to_`.\\n  *\\n  * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n  *\\n  * Requirements:\\n  *\\n  * - `from_` cannot be the zero address.\\n  * - `to_` cannot be the zero address.\\n  * - `tokenId_` token must be owned by `from_`.\\n  * - If the caller is not `from_`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n  *\\n  * Emits a {Transfer} event.\\n  */\\n  function transferFrom( address from_, address to_, uint256 tokenId_ ) external;\\n\\n  /**\\n  * @dev Returns the number of tokens in `tokenOwner_`\\u0027s account.\\n  */\\n  function balanceOf( address tokenOwner_ ) external view returns ( uint256 balance );\\n\\n  /**\\n  * @dev Returns the account approved for `tokenId_` token.\\n  *\\n  * Requirements:\\n  *\\n  * - `tokenId_` must exist.\\n  */\\n  function getApproved( uint256 tokenId_ ) external view returns ( address operator );\\n\\n  /**\\n  * @dev Returns if the `operator_` is allowed to manage all of the assets of `tokenOwner_`.\\n  *\\n  * See {setApprovalForAll}\\n  */\\n  function isApprovedForAll( address tokenOwner_, address operator_ ) external view returns ( bool );\\n\\n  /**\\n  * @dev Returns the owner of the `tokenId_` token.\\n  *\\n  * Requirements:\\n  *\\n  * - `tokenId_` must exist.\\n  */\\n  function ownerOf( uint256 tokenId_ ) external view returns ( address owner );\\n}\\n\"},\"IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"},\"IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"},\"IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n* Author: Lambdalf the White\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.10;\\r\\n\\r\\n/**\\r\\n* @dev Contract module which provides a basic access control mechanism, where\\r\\n* there is an account (an owner) that can be granted exclusive access to\\r\\n* specific functions.\\r\\n*\\r\\n* By default, the owner account will be the one that deploys the contract. This\\r\\n* can later be changed with {transferOwnership}.\\r\\n*\\r\\n* This module is used through inheritance. It will make available the modifier\\r\\n* `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n* the owner.\\r\\n*/\\r\\nabstract contract IOwnable {\\r\\n\\t// Errors\\r\\n\\terror IOwnable_NOT_OWNER();\\r\\n\\r\\n\\t// The owner of the contract\\r\\n\\taddress private _owner;\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Emitted when contract ownership changes.\\r\\n\\t*/\\r\\n\\tevent OwnershipTransferred( address indexed previousOwner, address indexed newOwner );\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Initializes the contract setting the deployer as the initial owner.\\r\\n\\t*/\\r\\n\\tfunction _initIOwnable( address owner_ ) internal {\\r\\n\\t\\t_owner = owner_;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Returns the address of the current owner.\\r\\n\\t*/\\r\\n\\tfunction owner() public view virtual returns ( address ) {\\r\\n\\t\\treturn _owner;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Throws if called by any account other than the owner.\\r\\n\\t*/\\r\\n\\tmodifier onlyOwner() {\\r\\n\\t\\tif ( owner() != msg.sender ) {\\r\\n\\t\\t\\trevert IOwnable_NOT_OWNER();\\r\\n\\t\\t}\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n\\t* Can only be called by the current owner.\\r\\n\\t*/\\r\\n\\tfunction transferOwnership( address newOwner_ ) public virtual onlyOwner {\\r\\n\\t\\taddress _oldOwner_ = _owner;\\r\\n\\t\\t_owner = newOwner_;\\r\\n\\t\\temit OwnershipTransferred( _oldOwner_, newOwner_ );\\r\\n\\t}\\r\\n}\\r\\n\"},\"IPausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n* Author: Lambdalf the White\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nabstract contract IPausable {\\r\\n\\t// Errors\\r\\n\\terror IPausable_SALE_NOT_CLOSED();\\r\\n\\terror IPausable_SALE_NOT_OPEN();\\r\\n\\terror IPausable_PRESALE_NOT_OPEN();\\r\\n\\r\\n\\t// Enum to represent the sale state, defaults to ``CLOSED``.\\r\\n\\tenum SaleState { CLOSED, PRESALE, SALE }\\r\\n\\r\\n\\t// The current state of the contract\\r\\n\\tSaleState public saleState;\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Emitted when the sale state changes\\r\\n\\t*/\\r\\n\\tevent SaleStateChanged( SaleState indexed previousState, SaleState indexed newState );\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Sale state can have one of 3 values, ``CLOSED``, ``PRESALE``, or ``SALE``.\\r\\n\\t*/\\r\\n\\tfunction _setSaleState( SaleState newState_ ) internal virtual {\\r\\n\\t\\tSaleState _previousState_ = saleState;\\r\\n\\t\\tsaleState = newState_;\\r\\n\\t\\temit SaleStateChanged( _previousState_, newState_ );\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Throws if sale state is not ``CLOSED``.\\r\\n\\t*/\\r\\n\\tmodifier saleClosed {\\r\\n\\t\\tif ( saleState != SaleState.CLOSED ) {\\r\\n\\t\\t\\trevert IPausable_SALE_NOT_CLOSED();\\r\\n\\t\\t}\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Throws if sale state is not ``SALE``.\\r\\n\\t*/\\r\\n\\tmodifier saleOpen {\\r\\n\\t\\tif ( saleState != SaleState.SALE ) {\\r\\n\\t\\t\\trevert IPausable_SALE_NOT_OPEN();\\r\\n\\t\\t}\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Throws if sale state is not ``PRESALE``.\\r\\n\\t*/\\r\\n\\tmodifier presaleOpen {\\r\\n\\t\\tif ( saleState != SaleState.PRESALE ) {\\r\\n\\t\\t\\trevert IPausable_PRESALE_NOT_OPEN();\\r\\n\\t\\t}\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n}\\r\\n\"},\"ITradable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n* Author: Lambdalf the White\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.10;\\r\\n\\r\\ncontract OwnableDelegateProxy {}\\r\\n\\r\\ncontract ProxyRegistry {\\r\\n\\tmapping( address =\\u003e OwnableDelegateProxy ) public proxies;\\r\\n}\\r\\n\\r\\nabstract contract ITradable {\\r\\n\\t// OpenSea proxy registry address\\r\\n\\taddress[] internal _proxyRegistries;\\r\\n\\r\\n\\tfunction _setProxyRegistry( address proxyRegistryAddress_ ) internal {\\r\\n\\t\\t_proxyRegistries.push( proxyRegistryAddress_ );\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Checks if `operator_` is the registered proxy for `tokenOwner_`.\\r\\n\\t* \\r\\n\\t* Note: Use this function to allow whitelisting of registered proxy.\\r\\n\\t*/\\r\\n\\tfunction _isRegisteredProxy( address tokenOwner_, address operator_ ) internal view returns ( bool ) {\\r\\n\\t\\tfor ( uint256 i; i \\u003c _proxyRegistries.length; i++ ) {\\r\\n\\t\\t\\tProxyRegistry _proxyRegistry_ = ProxyRegistry( _proxyRegistries[ i ] );\\r\\n\\t\\t\\tif ( address( _proxyRegistry_.proxies( tokenOwner_ ) ) == operator_ ) {\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n}\"},\"VF.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n* Author: Lambdalf the White\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport \\u0027./ERC721BatchBurnable.sol\\u0027;\\r\\nimport \\u0027./ERC2981Base.sol\\u0027;\\r\\nimport \\u0027./IAdministrable.sol\\u0027;\\r\\nimport \\u0027./IPausable.sol\\u0027;\\r\\nimport \\u0027./ITradable.sol\\u0027;\\r\\n\\r\\ncontract VF is ERC721BatchBurnable, ERC2981Base, IAdministrable, IPausable, ITradable {\\r\\n\\t// Events\\r\\n\\tevent PaymentSent( address indexed from, address indexed to, uint256 indexed amount );\\r\\n\\r\\n\\t// Errors\\r\\n\\terror VF_MAX_BATCH();\\r\\n\\terror VF_MAX_SUPPLY();\\r\\n\\terror VF_TRANSFER_FAIL();\\r\\n\\terror VF_INCORRECT_PRICE();\\r\\n\\terror VF_NO_ETHER_BALANCE();\\r\\n\\terror VF_WALLETS_MISMATCH();\\r\\n\\terror VF_INSUFFICIENT_KEY_BALANCE();\\r\\n\\terror VF_INSUFFICIENT_ETHER_BALANCE();\\r\\n\\r\\n\\t// Max supply\\r\\n\\tuint public immutable MAX_SUPPLY;\\r\\n\\r\\n\\t// Max TX\\r\\n\\tuint public immutable MAX_BATCH;\\r\\n\\r\\n\\t// Mint Price\\r\\n\\tuint public immutable MINT_PRICE;\\r\\n\\r\\n\\t// Team wallets\\r\\n\\taddress private constant COMMUNITY = 0x73DAdB28902A54d197D541E290a9F05Ed4e033e2; // 25%\\r\\n\\taddress private constant FOUNDERS  = 0x7E5541CEeb1C1B24Ca847F52f9505533F1c557e0; // 40%\\r\\n\\taddress private constant MCS       = 0x6Bc8c4Ef598218cbcB903efB9b711dA88C8f202b; // 35%\\r\\n\\r\\n\\tconstructor(\\r\\n\\t\\tuint256 royaltyRate_,\\r\\n\\t\\tuint256 maxSupply_,\\r\\n\\t\\tuint256 maxBatch_,\\r\\n\\t\\tuint256 mintPrice_,\\r\\n\\t\\tstring memory name_,\\r\\n\\t\\tstring memory symbol_,\\r\\n\\t\\tstring memory baseURI_\\r\\n\\t) {\\r\\n\\t\\t_initIOwnable( _msgSender() );\\r\\n\\t\\t_initERC2981Base( COMMUNITY, royaltyRate_ );\\r\\n\\t\\t_initERC721BatchMetadata( name_, symbol_ );\\r\\n\\t\\t_setBaseURI( baseURI_ );\\r\\n\\t\\tMAX_SUPPLY   = maxSupply_;\\r\\n\\t\\tMAX_BATCH    = maxBatch_;\\r\\n\\t\\tMINT_PRICE   = mintPrice_;\\r\\n\\t}\\r\\n\\r\\n\\tfunction mintSale( uint256 qty_ ) external payable saleOpen {\\r\\n\\t\\tif ( qty_ \\u003e MAX_BATCH ) {\\r\\n\\t\\t\\trevert VF_MAX_BATCH();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( qty_ + _supplyMinted() \\u003e MAX_SUPPLY ) {\\r\\n\\t\\t\\trevert VF_MAX_SUPPLY();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( qty_ * MINT_PRICE != msg.value ) {\\r\\n\\t\\t\\trevert VF_INCORRECT_PRICE();\\r\\n\\t\\t}\\r\\n\\t\\t_mint( _msgSender(), qty_ );\\r\\n\\t}\\r\\n\\r\\n\\tfunction withdraw() external onlyAdmin {\\r\\n\\t\\tuint256 _balance_ = address( this ).balance;\\r\\n\\t\\tif ( _balance_ == 0 ) {\\r\\n\\t\\t\\trevert VF_NO_ETHER_BALANCE();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tuint256 _communityShare_ = _balance_ * 250 / 1000;\\r\\n\\t\\tuint256 _foundersShare_  = _balance_ * 400 / 1000;\\r\\n\\t\\tuint256 _mcsShare_       = _balance_ * 350 / 1000;\\r\\n\\t\\t_sendValue( payable( COMMUNITY ), _communityShare_ );\\r\\n\\t\\t_sendValue( payable( FOUNDERS  ), _foundersShare_  );\\r\\n\\t\\t_sendValue( payable( MCS       ), _mcsShare_       );\\r\\n\\t}\\r\\n\\r\\n\\tfunction setSaleState( SaleState newState_ ) external onlyAdmin {\\r\\n\\t\\t_setSaleState( newState_ );\\r\\n\\t}\\r\\n\\r\\n\\tfunction setBaseURI( string memory baseURI_ ) external onlyOwner {\\r\\n\\t\\t_setBaseURI( baseURI_ );\\r\\n\\t}\\r\\n\\r\\n\\tfunction setProxyRegistry( address proxyRegistryAddress_ ) external onlyOwner {\\r\\n\\t\\t_setProxyRegistry( proxyRegistryAddress_ );\\r\\n\\t}\\r\\n\\r\\n\\tfunction setRoyaltyInfo( address recipient_, uint256 royaltyRate_ ) external onlyAdmin {\\r\\n\\t\\t_setRoyaltyInfo( recipient_, royaltyRate_ );\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Replacement for Solidity\\u0027s `transfer`: sends `amount_` wei to\\r\\n\\t* `recipient_`, forwarding all available gas and reverting on errors.\\r\\n\\t*\\r\\n\\t* https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n\\t* of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n\\t* imposed by `transfer`, making them unable to receive funds via\\r\\n\\t* `transfer`. {sendValue} removes this limitation.\\r\\n\\t*\\r\\n\\t* https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n\\t*\\r\\n\\t* IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n\\t* taken to not create reentrancy vulnerabilities. Consider using\\r\\n\\t* {ReentrancyGuard} or the\\r\\n\\t* https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n\\t*/\\r\\n\\tfunction _sendValue( address payable recipient_, uint256 amount_ ) internal {\\r\\n\\t\\tif ( address( this ).balance \\u003c amount_ ) {\\r\\n\\t\\t\\trevert VF_INSUFFICIENT_ETHER_BALANCE();\\r\\n\\t\\t}\\r\\n\\t\\t( bool _success_, ) = recipient_.call{ value: amount_ }( \\\"\\\" );\\r\\n\\t\\tif ( ! _success_ ) {\\r\\n\\t\\t\\trevert VF_TRANSFER_FAIL();\\r\\n\\t\\t}\\r\\n    emit PaymentSent( address( this ), recipient_, amount_ );\\r\\n\\t}\\r\\n\\r\\n\\tfunction supportsInterface( bytes4 interfaceId_ ) public view virtual override(ERC721Batch, ERC2981Base) returns ( bool ) {\\r\\n\\t\\treturn \\r\\n\\t\\t\\tinterfaceId_ == type( IERC2981 ).interfaceId ||\\r\\n\\t\\t\\tERC721Batch.supportsInterface( interfaceId_ );\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev See {IERC2981-royaltyInfo}.\\r\\n\\t* \\r\\n\\t* Note: This function should be overriden to revert on a query for non existent token.\\r\\n\\t*/\\r\\n\\tfunction royaltyInfo( uint256 tokenId_, uint256 salePrice_ ) public view virtual override exists( tokenId_ ) returns ( address, uint256 ) {\\r\\n\\t\\treturn super.royaltyInfo( tokenId_, salePrice_ );\\r\\n\\t}\\r\\n\\r\\n  function _isApprovedForAll( address tokenOwner_, address operator_ ) internal view virtual override returns ( bool ) {\\r\\n    return _isRegisteredProxy( tokenOwner_, operator_ ) ||\\r\\n    \\t\\t\\t super._isApprovedForAll( tokenOwner_, operator_ );\\r\\n  }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"royaltyRate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBatch_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPrice_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"IAdministrable_NOT_ADMIN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC2981_INVALID_ROYALTIES\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721_APPROVE_CALLER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721_APPROVE_OWNER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721_CALLER_NOT_APPROVED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721_NONEXISTANT_TOKEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721_NON_ERC721_RECEIVER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721_NULL_ADDRESS_BALANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721_NULL_ADDRESS_TRANSFER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IOwnable_NOT_OWNER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IPausable_PRESALE_NOT_OPEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IPausable_SALE_NOT_CLOSED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IPausable_SALE_NOT_OPEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VF_INCORRECT_PRICE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VF_INSUFFICIENT_ETHER_BALANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VF_INSUFFICIENT_KEY_BALANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VF_MAX_BATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VF_MAX_SUPPLY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VF_NO_ETHER_BALANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VF_TRANSFER_FAIL\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VF_WALLETS_MISMATCH\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved_\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum IPausable.SaleState\",\"name\":\"previousState\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"enum IPausable.SaleState\",\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"SaleStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BATCH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"grantAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"qty_\",\"type\":\"uint256\"}],\"name\":\"mintSale\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"revokeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice_\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleState\",\"outputs\":[{\"internalType\":\"enum IPausable.SaleState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved_\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxyRegistryAddress_\",\"type\":\"address\"}],\"name\":\"setProxyRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyRate_\",\"type\":\"uint256\"}],\"name\":\"setRoyaltyInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPausable.SaleState\",\"name\":\"newState_\",\"type\":\"uint8\"}],\"name\":\"setSaleState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId_\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "VF", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "8888", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000015b3000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000b1a2bc2ec5000000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000095665654669656e64730000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000456464e440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000236170692e7665656669656e64732e78797a2f6d657461646174613f746f6b656e49643d0000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://964fa782635bc32412c0cf2f0e8e1b2334a5b99bf0510aaee5e24e194796fda7"}]}