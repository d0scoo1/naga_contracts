{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"BigNumber.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nlibrary BigNumber {\\n    \\n    /*\\n     * BigNumber is defined as a struct named \\u0027instance\\u0027 to avoid naming conflicts.\\n     * DO NOT ALLOW INSTANTIATING THIS DIRECTLY - use the \\u0027_new\\u0027 functions defined below.\\n     * Hoping in future Solidity will allow visibility modifiers on structs..\\n     */\\n\\n    struct instance { \\n        bytes val;\\n        bool neg;\\n        uint bitlen;\\n    }\\n\\n    /** @dev _new: Create a new Bignumber instance.\\n      *            overloading allows caller to obtionally pass bitlen where it is known - as it is cheaper to do off-chain and verify on-chain. \\n      *            we assert input is in data structure as defined above, and that bitlen, if passed, is correct.\\n      *            \\u0027copy\\u0027 parameter indicates whether or not to copy the contents of val to a new location in memory (for example where you pass the contents of another variable\\u0027s value in)\\n      * parameter: bytes val - bignum value.\\n      * parameter: bool  neg - sign of value\\n      * parameter: uint bitlen - bit length of value\\n      * returns: instance r.\\n      */\\n    function _new(bytes memory val, bool neg, bool copy) internal view returns(instance memory r){ \\n        require(val.length % 32 == 0);\\n        if(!copy) {\\n          r.val = val;\\n        }\\n        else {\\n          // use identity at location 0x4 for cheap memcpy.\\n          // grab contents of val, load starting from memory end, update memory end pointer.\\n          bytes memory val_copy;\\n          assembly{\\n            let size := add(mload(val),0x20)\\n            let new_loc := mload(0x40)\\n            let success := staticcall(450, 0x4, val, size, new_loc, size) // (gas, address, in, insize, out, outsize)\\n            val_copy := new_loc //new bytes value\\n            mstore(0x40, add(new_loc,size)) //update freemem pointer\\n          }\\n          r.val = val_copy;\\n        }\\n        r.neg = neg;\\n        r.bitlen = get_bit_length(val);\\n    }\\n\\n    /** @dev Create a new Bignumber instance.\\n      *\\n      * parameter: bytes val - bignum value\\n      * parameter: bool  neg - sign of value\\n      * parameter: uint bitlen - bit length of value\\n      * returns: instance r.\\n      */\\n    function _new(bytes memory val, bool neg, uint bitlen) internal pure returns(instance memory r){\\n        uint val_msword; \\n        assembly {val_msword := mload(add(val,0x20))} //get msword of result\\n        require((val.length % 32 == 0) \\u0026\\u0026 (val_msword\\u003e\\u003e(bitlen%256)==1));\\n        r.val = val;\\n        r.neg = neg;\\n        r.bitlen = bitlen;\\n    }\\n    \\n    /** @dev prepare_add: Initially prepare bignum instances for addition operation; internally calls actual addition/subtraction, depending on inputs.\\n      *                   In order to do correct addition or subtraction we have to handle the sign.\\n      *                   This function discovers the sign of the result based on the inputs, and calls the correct operation.\\n      *\\n      * parameter: instance a - first instance\\n      * parameter: instance b - second instance\\n      * returns: instance r - addition of a \\u0026 b.\\n      */\\n    function prepare_add(instance memory a, instance memory b) internal pure returns(instance memory r) {\\n        instance memory zero = instance(hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\",false,0); \\n        if(a.bitlen==0 \\u0026\\u0026 b.bitlen==0) return zero;\\n        if(a.bitlen==0) return b;\\n        if(b.bitlen==0) return a;  \\n        bytes memory val;\\n        uint bitlen;\\n        int compare = cmp(a,b,false);\\n\\n        if(a.neg || b.neg){\\n            if(a.neg \\u0026\\u0026 b.neg){\\n                if(compare\\u003e=0) (val, bitlen) = bn_add(a.val,b.val,a.bitlen);\\n                else (val, bitlen) = bn_add(b.val,a.val,b.bitlen);\\n                r.neg = true;\\n            }\\n            else {\\n                if(compare==1){\\n                    (val, bitlen) = bn_sub(a.val,b.val);\\n                    r.neg = a.neg;\\n                }\\n                else if(compare==-1){\\n                    (val, bitlen) = bn_sub(b.val,a.val);\\n                    r.neg = !a.neg;\\n                }\\n                else return zero;//one pos and one neg, and same value.\\n            }\\n        }\\n        else{\\n            if(compare\\u003e=0){ //a\\u003e=b\\n                (val, bitlen) = bn_add(a.val,b.val,a.bitlen);\\n            }\\n            else {\\n                (val, bitlen) = bn_add(b.val,a.val,b.bitlen);\\n            }\\n            r.neg = false;\\n        }\\n\\n        r.val = val;\\n        r.bitlen = bitlen;\\n    }\\n\\n    /** @dev bn_add: takes two instance values and the bitlen of the max value, and adds them.\\n      *              This function is private and only callable from prepare_add: therefore the values may be of different sizes, \\n      *              in any order of size, and of different signs (handled in prepare_add).\\n      *              As values may be of different sizes, inputs are considered starting from the least significant words, working back. \\n      *              The function calculates the new bitlen (basically if bitlens are the same for max and min, max_bitlen++) and returns a new instance value.\\n      *\\n      * parameter: bytes max -  biggest value  (determined from prepare_add)\\n      * parameter: bytes min -  smallest value (determined from prepare_add)\\n      * parameter: uint max_bitlen -  bit length of max value.\\n      * returns: bytes result - max + min.\\n      * returns: uint - bit length of result.\\n      */\\n    function bn_add(bytes memory max, bytes memory min, uint max_bitlen) private pure returns (bytes memory, uint) {\\n        bytes memory result;\\n        assembly {\\n\\n            let result_start := msize()                                     // Get the highest available block of memory\\n            \\n            let uint_max := sub(0,1)                                        // uint max. achieved using uint underflow: 0xffff...ffff\\n\\n            let carry := 0\\n\\n            let max_ptr := add(max, mload(max))\\n            let min_ptr := add(min, mload(min))                             // point to last word of each byte array.\\n\\n            let result_ptr := add(add(result_start,0x20), mload(max))         // set result_ptr end.\\n\\n            for { let i := mload(max) } eq(eq(i,0),0) { i := sub(i, 0x20) } { // for(int i=max_length; i!=0; i-=32)\\n                let max_val := mload(max_ptr)                               // get next word for \\u0027max\\u0027\\n                switch gt(i,sub(mload(max),mload(min)))                         // if(i\\u003e(max_length-min_length)). while \\u0027min\\u0027 words are still available.\\n                    case 1{ \\n\\n                        let min_val := mload(min_ptr)                       //      get next word for \\u0027min\\u0027\\n        \\n                        mstore(result_ptr, add(add(max_val,min_val),carry)) //      result_word = max_word+min_word+carry\\n                    \\n                        switch gt(max_val, sub(uint_max,sub(min_val,carry)))     //      this switch block finds whether or not to set the carry bit for the next iteration.\\n                            case 1  { carry := 1 }\\n                            default {\\n                                switch and(eq(max_val,uint_max),or(gt(carry,0), gt(min_val,0)))\\n                                case 1 { carry := 1 }\\n                                default{ carry := 0 }\\n                            }\\n                            \\n                        min_ptr := sub(min_ptr,0x20)                       //       point to next \\u0027min\\u0027 word\\n                    }\\n                    default{                                               // else: remainder after \\u0027min\\u0027 words are complete.\\n                        mstore(result_ptr, add(max_val,carry))             //       result_word = max_word+carry\\n                        \\n                        switch and( eq(uint_max,max_val), eq(carry,1) )         //       this switch block finds whether or not to set the carry bit for the next iteration.\\n                            case 1  { carry := 1 }\\n                            default { carry := 0 }\\n                    }\\n                result_ptr := sub(result_ptr,0x20)                         // point to next \\u0027result\\u0027 word\\n                max_ptr := sub(max_ptr,0x20)                               // point to next \\u0027max\\u0027 word\\n            }\\n\\n            switch eq(carry,0) \\n                case 1{ result_start := add(result_start,0x20) }           // if carry is 0, increment result_start, ie. length word for result is now one word position ahead.\\n                default { mstore(result_ptr, 1) }                          // else if carry is 1, store 1; overflow has occured, so length word remains in the same position.\\n\\n            result := result_start                                         // point \\u0027result\\u0027 bytes value to the correct address in memory\\n            mstore(result,add(mload(max),mul(0x20,carry)))                   // store length of result. we are finished with the byte array.\\n            \\n            mstore(0x40, add(result,add(mload(result),0x20)))                // Update freemem pointer to point to new end of memory.\\n        }\\n        \\n        //we now calculate the result\\u0027s bit length.\\n        //with addition, if we assume that some a is at least equal to some b, then the resulting bit length will be a\\u0027s bit length or (a\\u0027s bit length)+1, depending on carry bit.\\n        //this is cheaper than calling get_bit_length.\\n        uint msword; \\n        assembly {msword := mload(add(result,0x20))}                          // get most significant word of result\\n        if(msword\\u003e\\u003e(max_bitlen % 256)==1 || msword==1) ++max_bitlen;          // if msword\\u0027s bit length is 1 greater than max_bitlen, OR overflow occured, new bitlen is max_bitlen+1. \\n        \\n        return (result, max_bitlen);\\n    }\\n\\n    \\n      /** @dev prepare_sub: Initially prepare bignum instances for addition operation; internally calls actual addition/subtraction, depending on inputs.\\n      *                   In order to do correct addition or subtraction we have to handle the sign.\\n      *                   This function discovers the sign of the result based on the inputs, and calls the correct operation.\\n      *\\n      * parameter: instance a - first instance\\n      * parameter: instance b - second instance\\n      * returns: instance r - a-b.\\n      */  \\n\\n    function prepare_sub(instance memory a, instance memory b) internal pure returns(instance memory r) {\\n        instance memory zero = instance(hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\",false,0); \\n        bytes memory val;\\n        int compare;\\n        uint bitlen;\\n        compare = cmp(a,b,false);\\n        if(a.neg || b.neg) {\\n            if(a.neg \\u0026\\u0026 b.neg){           \\n                if(compare == 1) { \\n                    (val,bitlen) = bn_sub(a.val,b.val); \\n                    r.neg = true;\\n                }\\n                else if(compare == -1) { \\n\\n                    (val,bitlen) = bn_sub(b.val,a.val); \\n                    r.neg = false;\\n                }\\n                else return zero;\\n            }\\n            else {\\n                if(compare \\u003e= 0) (val,bitlen) = bn_add(a.val,b.val,a.bitlen);\\n                else (val,bitlen) = bn_add(b.val,a.val,b.bitlen);\\n                \\n                r.neg = (a.neg) ? true : false;\\n            }\\n        }\\n        else {\\n            if(compare == 1) {\\n                (val,bitlen) = bn_sub(a.val,b.val);\\n                r.neg = false;\\n             }\\n            else if(compare == -1) { \\n                (val,bitlen) = bn_sub(b.val,a.val);\\n                r.neg = true;\\n            }\\n            else return zero; \\n        }\\n\\n        r.val = val;\\n        r.bitlen = bitlen;\\n    }\\n\\n\\n    /** @dev bn_sub: takes two instance values and subtracts them.\\n      *              This function is private and only callable from prepare_add: therefore the values may be of different sizes, \\n      *              in any order of size, and of different signs (handled in prepare_add).\\n      *              As values may be of different sizes, inputs are considered starting from the least significant words, working back. \\n      *              The function calculates the new bitlen (basically if bitlens are the same for max and min, max_bitlen++) and returns a new instance value.\\n      *\\n      * parameter: bytes max -  biggest value  (determined from prepare_add)\\n      * parameter: bytes min -  smallest value (determined from prepare_add)\\n      * parameter: uint max_bitlen -  bit length of max value.\\n      * returns: bytes result - max + min.\\n      * returns: uint - bit length of result.\\n      */\\n   function bn_sub(bytes memory max, bytes memory min) private pure returns (bytes memory, uint) {\\n        bytes memory result;\\n        uint carry = 0;\\n        assembly {\\n                \\n            let result_start := msize()                                         // Get the highest available block of memory\\n        \\n            let uint_max := sub(0,1)                                            // uint max. achieved using uint underflow: 0xffff...ffff\\n            let max_len := mload(max)\\n            let min_len := mload(min)                                           // load lengths of inputs\\n            \\n            let len_diff := sub(max_len,min_len)                                //get differences in lengths.\\n            \\n            let max_ptr := add(max, max_len)\\n            let min_ptr := add(min, min_len)                                    //go to end of arrays\\n            let result_ptr := add(result_start, max_len)                        //point to least significant result word.\\n            let memory_end := add(result_ptr,0x20)                              // save memory_end to update free memory pointer at the end.\\n            \\n            for { let i := max_len } eq(eq(i,0),0) { i := sub(i, 0x20) } {      // for(int i=max_length; i!=0; i-=32)\\n                let max_val := mload(max_ptr)                                   // get next word for \\u0027max\\u0027\\n                switch gt(i,len_diff)                                           // if(i\\u003e(max_length-min_length)). while \\u0027min\\u0027 words are still available.\\n                    case 1{ \\n                        let min_val := mload(min_ptr)                           //      get next word for \\u0027min\\u0027\\n        \\n                        mstore(result_ptr, sub(sub(max_val,min_val),carry))     //      result_word = (max_word-min_word)-carry\\n                    \\n                        switch or(lt(max_val, add(min_val,carry)), \\n                               and(eq(min_val,uint_max), eq(carry,1)))          //      this switch block finds whether or not to set the carry bit for the next iteration.\\n                            case 1  { carry := 1 }\\n                            default { carry := 0 }\\n                            \\n                        min_ptr := sub(min_ptr,0x20)                            //      point to next \\u0027result\\u0027 word\\n                    }\\n                    default{                                                    // else: remainder after \\u0027min\\u0027 words are complete.\\n\\n                        mstore(result_ptr, sub(max_val,carry))                  //      result_word = max_word-carry\\n                    \\n                        switch and( eq(max_val,0), eq(carry,1) )                //      this switch block finds whether or not to set the carry bit for the next iteration.\\n                            case 1  { carry := 1 }\\n                            default { carry := 0 }\\n\\n                    }\\n                result_ptr := sub(result_ptr,0x20)                              // point to next \\u0027result\\u0027 word\\n                max_ptr    := sub(max_ptr,0x20)                                 // point to next \\u0027max\\u0027 word\\n            }      \\n\\n            //the following code removes any leading words containing all zeroes in the result.\\n            result_ptr := add(result_ptr,0x20)                                                 \\n            for { }   eq(mload(result_ptr), 0) { result_ptr := add(result_ptr,0x20) } { //for(result_ptr+=32;; result==0; result_ptr+=32)\\n               result_start := add(result_start, 0x20)                                         // push up the start pointer for the result..\\n               max_len := sub(max_len,0x20)                                                    // and subtract a word (32 bytes) from the result length.\\n            } \\n\\n            result := result_start                                                              // point \\u0027result\\u0027 bytes value to the correct address in memory\\n            \\n            mstore(result,max_len)                                                              // store length of result. we are finished with the byte array.\\n            \\n            mstore(0x40, memory_end)                                                            // Update freemem pointer.\\n        }\\n\\n        \\n        uint new_bitlen = get_bit_length(result);                                                 //calculate the result\\u0027s bit length.\\n        \\n        return (result, new_bitlen);\\n    }\\n\\n\\n    /** @dev bn_mul: takes two instances and multiplys them. Order is irrelevant.\\n      *              multiplication achieved using modexp precompile:\\n      *                 (a * b) = (((a + b)**2 - (a - b)**2) / 4\\n      *              squaring is done in op_and_square function.\\n      *\\n      * parameter: instance a \\n      * parameter: instance b \\n      * returns: bytes res - a*b.\\n      */\\n    function bn_mul(instance memory a, instance memory b) internal view returns(instance memory res){\\n\\n        \\n        res = op_and_square(a,b,0);                                // add_and_square = (a+b)^2\\n\\n        //no need to do subtraction part of the equation if a == b; if so, it has no effect on final result.\\n        if(cmp(a,b,true)!=0){  \\n        \\n            instance memory sub_and_square = op_and_square(a,b,1); // sub_and_square = (a-b)^2\\n        \\n            res = prepare_sub(res,sub_and_square);                 // res = add_and_square - sub_and_square\\n        }\\n        res = right_shift(res, 2);                                 // res = res / 4\\n        \\n     }\\n\\n\\n    /** @dev op_and_square: takes two instances, performs operation \\u0027op\\u0027 on them, and squares the result.\\n      *                     bn_mul uses the multiplication by squaring method, ie. a*b == ((a+b)^2 - (a-b)^2)/4.\\n      *                     using modular exponentation precompile for squaring. this requires taking a special modulus value of the form:\\n      *                     modulus == \\u00271|(0*n)\\u0027, where n = 2 * bit length of (a \\u0027op\\u0027 b).\\n      *\\n      * parameter: instance a \\n      * parameter: instance b \\n      * parameter: int op \\n      * returns: bytes res - (a\\u0027op\\u0027b) ^ 2.\\n      */\\n    function op_and_square(instance memory a, instance memory b, int op) private view returns(instance memory res){\\n        instance memory two = instance(hex\\\"0000000000000000000000000000000000000000000000000000000000000002\\\",false,2);        \\n        \\n        uint mod_index = 0;\\n        uint first_word_modulus;\\n        bytes memory _modulus;\\n        \\n        res = (op == 0) ? prepare_add(a,b) : prepare_sub(a,b); //op == 0: add, op == 1: sub.\\n        uint res_bitlen = res.bitlen;\\n        assembly { mod_index := mul(res_bitlen,2) }\\n        first_word_modulus = uint(1) \\u003c\\u003c ((mod_index % 256)); //set bit in first modulus word.\\n        \\n        //we pass the minimum modulus value which would return JUST the squaring part of the calculation; therefore the value may be many words long.\\n        //This is done by:\\n        //  - storing total modulus byte length\\n        //  - storing first word of modulus with correct bit set\\n        //  - updating the free memory pointer to come after total length.\\n        _modulus = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\";\\n        assembly {\\n            mstore(_modulus, mul(add(div(mod_index,256),1),0x20))  //store length of modulus\\n            mstore(add(_modulus,0x20), first_word_modulus)         //set first modulus word\\n            mstore(0x40, add(_modulus, add(mload(_modulus),0x20))) //update freemem pointer to be modulus index + length\\n        }\\n\\n        //create modulus instance for modexp function\\n        instance memory modulus; \\n        modulus.val = _modulus;\\n        modulus.neg = false;\\n        modulus.bitlen = mod_index;\\n\\n        res = prepare_modexp(res,two,modulus); // ((a \\u0027op\\u0027 b) ^ 2 % modulus) == (a \\u0027op\\u0027 b) ^ 2.\\n    }\\n\\n\\n    /** @dev bn_div: takes three instances (a,b and result), and verifies that a/b == result.\\n      *              Verifying a bigint division operation is far cheaper than actually doing the computation. \\n      *              As this library is for verification of cryptographic schemes it makes more sense that this function be used in this way.\\n      *              (a/b = result) == (a = b * result)\\n      *              Integer division only; therefore:\\n      *                verify ((b*result) + (a % (b*result))) == a.\\n      *              eg. 17/7 == 2:\\n      *                verify  (7*2) + (17 % (7*2)) == 17.\\n      *              the function returns the \\u0027result\\u0027 param passed on successful validation. returning a bool on successful validation is an option, \\n      *              however it makes more sense in the context of the calling contract that it should return the result. \\n      *\\n      * parameter: instance a \\n      * parameter: instance b \\n      * parameter: instance result\\n      * returns: \\u0027result\\u0027 param. \\n      */\\n    function bn_div(instance memory a, instance memory b, instance memory result) internal view returns(instance memory){\\n\\n\\n        if(a.neg==true || b.neg==true){ //first handle sign.\\n            if (a.neg==true \\u0026\\u0026 b.neg==true) require(result.neg==false);\\n            else require(result.neg==true);\\n        } else require(result.neg==false);\\n        \\n        instance memory zero = instance(hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\",false,0);\\n\\n        require(!(cmp(b,zero,true)==0)); //require denominator to not be zero.\\n\\n        if(cmp(result,zero,true)==0){                //if result is 0:\\n            if(cmp(a,b,true)==-1) return result;     // return zero if a\\u003cb (numerator \\u003c denominator)\\n            else assert(false);                      // else fail.\\n        }      \\n\\n        instance memory fst = bn_mul(b,result); // do multiplication (b * result)\\n        if(cmp(fst,a,true)==0) return result;  // check if we already have a (ie. no remainder after division). if so, no mod necessary, and return result.\\n\\n        instance memory one = instance(hex\\\"0000000000000000000000000000000000000000000000000000000000000001\\\",false,1);\\n        instance memory snd = prepare_modexp(a,one,fst); //a mod (b*result)\\n\\n        require(cmp(prepare_add(fst,snd),a,true)==0); // ((b*result) + a % (b*result)) == a\\n\\n        return result;\\n    }\\n\\n\\n    function bn_mod(instance memory a, instance memory mod) internal view returns(instance memory res){\\n      instance memory one = instance(hex\\\"0000000000000000000000000000000000000000000000000000000000000001\\\",false,1);\\n      res = prepare_modexp(a,one,mod);\\n    }\\n\\n\\n    /** @dev prepare_modexp: takes base, exponent, and modulus, internally computes base^exponent % modulus, and creates new instance.\\n      *                      this function is overloaded: it assumes the exponent is positive. if not, the other method is used, whereby the inverse of the base is also passed.\\n      *\\n      * parameter: instance base \\n      * parameter: instance exponent\\n      * parameter: instance modulus\\n      * returns: instance result.\\n      */    \\n    function prepare_modexp(instance memory base, instance memory exponent, instance memory modulus) internal view returns(instance memory result) {\\n        require(exponent.neg==false); //if exponent is negative, other method with this same name should be used.\\n\\n        bytes memory _result = modexp(base.val,exponent.val,modulus.val);\\n        //get bitlen of result (TODO: optimise. we know bitlen is in the same byte as the modulus bitlen byte)\\n        uint bitlen;\\n        assembly { bitlen := mload(add(_result,0x20))}\\n        bitlen = get_word_length(bitlen) + (((_result.length/32)-1)*256); \\n\\n        result.val = _result;\\n        result.neg = (base.neg==false || base.neg \\u0026\\u0026 is_odd(exponent)==0) ? false : true; //TODO review this. \\n        result.bitlen = bitlen;\\n        return result;\\n     }\\n\\n    /** @dev prepare_modexp: takes base, base inverse, exponent, and modulus, asserts inverse(base)==base inverse, \\n      *                      internally computes base_inverse^exponent % modulus and creates new instance.\\n      *                      this function is overloaded: it assumes the exponent is negative. \\n      *                      if not, the other method is used, where the inverse of the base is not passed.\\n      *\\n      * parameter: instance base\\n      * parameter: instance base_inverse \\n      * parameter: instance exponent\\n      * parameter: instance modulus\\n      * returns: instance result.\\n      */ \\n     function prepare_modexp(instance memory base, instance memory base_inverse, instance memory exponent, instance memory modulus) internal view returns(instance memory result) {\\n        // base^-exp = (base^-1)^exp\\n        require(exponent.neg==true);\\n\\n        require(cmp(base_inverse, mod_inverse(base,modulus,base_inverse), true)==0); //assert base_inverse == inverse(base, modulus)\\n            \\n        exponent.neg = false; //make e positive\\n\\n        bytes memory _result = modexp(base_inverse.val,exponent.val,modulus.val);\\n        //get bitlen of result (TODO: optimise. we know bitlen is in the same byte as the modulus bitlen byte)\\n        uint bitlen;\\n        assembly { bitlen := mload(add(_result,0x20))}\\n        bitlen = get_word_length(bitlen) + (((_result.length/32)-1)*256); \\n        result.val = _result;\\n        result.neg = (base_inverse.neg==false || base.neg \\u0026\\u0026 is_odd(exponent)==0) ? false : true; //TODO review this. \\n        result.bitlen = bitlen;\\n        return result;\\n     }\\n \\n\\n    /** @dev modexp: Takes instance values for base, exp, mod and calls precompile for (_base^_exp)%^mod\\n      *              Wrapper for built-in modexp (contract 0x5) as described here - https://github.com/ethereum/EIPs/pull/198\\n      *\\n      * parameter: bytes base\\n      * parameter: bytes base_inverse \\n      * parameter: bytes exponent\\n      * returns: bytes ret.\\n      */\\n    function modexp(bytes memory _base, bytes memory _exp, bytes memory _mod) private view returns(bytes memory ret) {\\n        assembly {\\n            \\n            let bl := mload(_base)\\n            let el := mload(_exp)\\n            let ml := mload(_mod)\\n            \\n            \\n            let freemem := mload(0x40) // Free memory pointer is always stored at 0x40\\n            \\n            \\n            mstore(freemem, bl)         // arg[0] = base.length @ +0\\n            \\n            mstore(add(freemem,32), el) // arg[1] = exp.length @ +32\\n            \\n            mstore(add(freemem,64), ml) // arg[2] = mod.length @ +64\\n            \\n            // arg[3] = base.bits @ + 96\\n            // Use identity built-in (contract 0x4) as a cheap memcpy\\n            let success := staticcall(450, 0x4, add(_base,32), bl, add(freemem,96), bl)\\n            \\n            // arg[4] = exp.bits @ +96+base.length\\n            let size := add(96, bl)\\n            success := staticcall(450, 0x4, add(_exp,32), el, add(freemem,size), el)\\n            \\n            // arg[5] = mod.bits @ +96+base.length+exp.length\\n            size := add(size,el)\\n            success := staticcall(450, 0x4, add(_mod,32), ml, add(freemem,size), ml)\\n            \\n            switch success case 0 { invalid() } //fail where we haven\\u0027t enough gas to make the call\\n\\n            // Total size of input = 96+base.length+exp.length+mod.length\\n            size := add(size,ml)\\n            // Invoke contract 0x5, put return value right after mod.length, @ +96\\n            success := staticcall(sub(gas(), 1350), 0x5, freemem, size, add(96,freemem), ml)\\n\\n            switch success case 0 { invalid() } //fail where we haven\\u0027t enough gas to make the call\\n\\n            let length := ml\\n            let length_ptr := add(96,freemem)\\n\\n            ///the following code removes any leading words containing all zeroes in the result.\\n            //start_ptr := add(start_ptr,0x20)\\n            for { } eq ( eq(mload(length_ptr), 0), 1) { } {\\n               length_ptr := add(length_ptr, 0x20)        //push up the start pointer for the result..\\n               length := sub(length,0x20) //and subtract a word (32 bytes) from the result length.\\n            } \\n\\n            ret := sub(length_ptr,0x20)\\n            mstore(ret, length)\\n            \\n            // point to the location of the return value (length, bits)\\n            //assuming mod length is multiple of 32, return value is already in the right format.\\n            //function visibility is changed to internal to reflect this.\\n            //ret := add(64,freemem) \\n            \\n            mstore(0x40, add(add(96, freemem),ml)) //deallocate freemem pointer\\n        }        \\n    }\\n\\n\\n    /** @dev modmul: Takes instances for a, b, and modulus, and computes (a*b) % modulus\\n      *              We call bn_mul for the two input values, before calling modexp, passing exponent as 1.\\n      *              Sign is taken care of in sub-functions.\\n      *\\n      * parameter: instance a\\n      * parameter: instance b\\n      * parameter: instance modulus\\n      * returns: instance res.\\n      */\\n    function modmul(instance memory a, instance memory b, instance memory modulus) internal view returns(instance memory res){       \\n        res = bn_mod(bn_mul(a,b),modulus);       \\n    }\\n\\n\\n    /** @dev mod_inverse: Takes instances for base, modulus, and result, verifies (base*result)%modulus==1, and returns result.\\n      *                   Similar to bn_div, it\\u0027s far cheaper to verify an inverse operation on-chain than it is to calculate it, so we allow the user to pass their own result.\\n      *\\n      * parameter: instance base\\n      * parameter: instance modulus\\n      * parameter: instance user_result\\n      * returns: instance user_result.\\n      */\\n    function mod_inverse(instance memory base, instance memory modulus, instance memory user_result) internal view returns(instance memory){\\n        require(base.neg==false \\u0026\\u0026 modulus.neg==false); //assert positivity of inputs.\\n            \\n        /*\\n         * the following proves:\\n         * - user result passed is correct for values base and modulus\\n         * - modular inverse exists for values base and modulus.\\n         * otherwise it fails.\\n         */        \\n        instance memory one = instance(hex\\\"0000000000000000000000000000000000000000000000000000000000000001\\\",false,1);\\n        require(cmp(modmul(base, user_result, modulus),one,true)==0);\\n\\n        return user_result;\\n     }\\n\\n\\n    /** @dev is_odd: returns 1 if instance value is an odd number and 0 otherwise.\\n      *              \\n      * parameter: instance _in\\n      * returns: uint ret.\\n      */  \\n    function is_odd(instance memory _in) internal pure returns(uint ret){\\n        assembly{\\n            let in_ptr := add(mload(_in), mload(mload(_in))) //go to least significant word\\n            ret := mod(mload(in_ptr),2)                      //..and mod it with 2. \\n        }\\n    }\\n\\n\\n    /** @dev cmp: instance comparison. \\u0027signed\\u0027 parameter indiciates whether to consider the sign of the inputs.\\n      *           \\u0027trigger\\u0027 is used to decide this - \\n      *              if both negative, invert the result; \\n      *              if both positive (or signed==false), trigger has no effect;\\n      *              if differing signs, we return immediately based on input.\\n      *           returns -1 on a\\u003cb, 0 on a==b, 1 on a\\u003eb.\\n      *           \\n      * parameter: instance a\\n      * parameter: instance b\\n      * parameter: bool signed\\n      * returns: int.\\n      */\\n    function cmp(instance memory a, instance memory b, bool signed) internal pure returns(int){\\n        int trigger = 1;\\n        if(signed){\\n            if(a.neg \\u0026\\u0026 b.neg) trigger = -1;\\n            else if(a.neg==false \\u0026\\u0026 b.neg==true) return 1;\\n            else if(a.neg==true \\u0026\\u0026 b.neg==false) return -1;\\n        }\\n\\n        if(a.bitlen\\u003eb.bitlen) return  1*trigger;\\n        if(b.bitlen\\u003ea.bitlen) return -1*trigger;\\n\\n        uint a_ptr;\\n        uint b_ptr;\\n        uint a_word;\\n        uint b_word;\\n\\n        uint len = a.val.length; //bitlen is same so no need to check length.\\n\\n        assembly{\\n            a_ptr := add(mload(a),0x20) \\n            b_ptr := add(mload(b),0x20)\\n        }\\n\\n        for(uint i=0; i\\u003clen;i+=32){\\n            assembly{\\n                a_word := mload(add(a_ptr,i))\\n                b_word := mload(add(b_ptr,i))\\n            }\\n\\n            if(a_word\\u003eb_word) return 1*trigger;\\n            if(b_word\\u003ea_word) return -1*trigger;\\n\\n        }\\n\\n        return 0; //same value.\\n    }\\n\\n\\n    //*************** begin is_prime functions **********************************\\n\\n    //\\n    //TODO generalize for any size input - currently just works for 850-1300 bit primes\\n\\n    /** @dev is_prime: executes Miller-Rabin Primality Test to see whether input instance is prime or not.\\n      *                \\u0027randomness\\u0027 is expected to be provided \\n      *                TODO: 1. add Oraclize randomness generation code template to be added to calling contract.\\n      *                      2. generalize for any size input (ie. make constant size randomness array dynamic in some way).\\n      *           \\n      * parameter: instance a\\n      * parameter: instance[] randomness\\n      * returns: bool indicating primality.\\n      */\\n    function is_prime(instance memory a, instance[3] memory randomness) internal view returns (bool){\\n        instance memory  zero = instance(hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\",false,0); \\n        instance memory   one = instance(hex\\\"0000000000000000000000000000000000000000000000000000000000000001\\\",false,1); \\n        instance memory   two = instance(hex\\\"0000000000000000000000000000000000000000000000000000000000000002\\\",false,2); \\n\\n        if (cmp(a, one, true) != 1){ \\n            return false;\\n        } // if value is \\u003c= 1\\n                    \\n        // first look for small factors\\n        if (is_odd(a)==0) {\\n            return (cmp(a, two,true)==0); // if a is even: a is prime if and only if a == 2\\n        }\\n                 \\n        instance memory a1 = prepare_sub(a,one);\\n\\n        if(cmp(a1,zero,true)==0) return false;\\n        \\n        uint k = get_k(a1);\\n        instance memory a1_odd = _new(a1.val, a1.neg, true); \\n        a1_odd = right_shift(a1_odd, k);\\n\\n        int j;\\n        uint num_checks = prime_checks_for_size(a.bitlen);\\n        instance memory check;\\n        for (uint i = 0; i \\u003c num_checks; i++) {\\n            \\n            check = prepare_add(randomness[i], one);   \\n            // now 1 \\u003c= check \\u003c a.\\n\\n            j = witness(check, a, a1, a1_odd, k);\\n\\n            if(j==-1 || j==1) return false;\\n                \\n        }\\n\\n        //if we\\u0027ve got to here, a is likely a prime.\\n        return true;\\n    }\\n\\n    function get_k(instance memory a1) private pure returns (uint k){\\n        k = 0;\\n        uint mask=1;\\n        uint a1_ptr;\\n        uint val;\\n        assembly{ \\n            a1_ptr := add(mload(a1),mload(mload(a1))) // get address of least significant portion of a\\n            val := mload(a1_ptr)  //load it\\n        }\\n        \\n        //loop from least signifcant bits until we hit a set bit. increment k until this point.        \\n        for(bool bit_set = ((val \\u0026 mask) != 0); !bit_set; bit_set = ((val \\u0026 mask) != 0)){\\n            \\n            if(((k+1) % 256) == 0){ //get next word should k reach 256.\\n                a1_ptr -= 32;\\n                assembly {val := mload(a1_ptr)}\\n                mask = 1;\\n            }\\n            \\n            mask*=2; // set next bit (left shift)\\n            k++;     // increment k\\n        }\\n    } \\n\\n    function prime_checks_for_size(uint bit_size) private pure returns(uint checks){\\n\\n       checks = bit_size \\u003e= 1300 ?  2 :\\n                bit_size \\u003e=  850 ?  3 :\\n                bit_size \\u003e=  650 ?  4 :\\n                bit_size \\u003e=  550 ?  5 :\\n                bit_size \\u003e=  450 ?  6 :\\n                bit_size \\u003e=  400 ?  7 :\\n                bit_size \\u003e=  350 ?  8 :\\n                bit_size \\u003e=  300 ?  9 :\\n                bit_size \\u003e=  250 ? 12 :\\n                bit_size \\u003e=  200 ? 15 :\\n                bit_size \\u003e=  150 ? 18 :\\n                /* b \\u003e= 100 */ 27;\\n    }\\n\\n    \\n    function witness(instance memory w, instance memory a, instance memory a1, instance memory a1_odd, uint k) internal view returns (int){\\n        // returns -  0: likely prime, 1: composite number (definite non-prime).\\n        instance memory one = instance(hex\\\"0000000000000000000000000000000000000000000000000000000000000001\\\",false,1); \\n        instance memory two = instance(hex\\\"0000000000000000000000000000000000000000000000000000000000000002\\\",false,2); \\n\\n        w = prepare_modexp(w, a1_odd, a); // w := w^a1_odd mod a\\n\\n        if (cmp(w,one,true)==0) return 0; // probably prime.                \\n                           \\n        if (cmp(w, a1,true)==0) return 0; // w == -1 (mod a), \\u0027a\\u0027 is probably prime\\n                                 \\n         for (;k != 0; k=k-1) {\\n             w = prepare_modexp(w,two,a); // w := w^2 mod a\\n\\n             if (cmp(w,one,true)==0) return 1; // // \\u0027a\\u0027 is composite, otherwise a previous \\u0027w\\u0027 would have been == -1 (mod \\u0027a\\u0027)\\n                                    \\n             if (cmp(w, a1,true)==0) return 0; // w == -1 (mod a), \\u0027a\\u0027 is probably prime\\n                      \\n         }\\n        /*\\n         * If we get here, \\u0027w\\u0027 is the (a-1)/2-th power of the original \\u0027w\\u0027, and\\n         * it is neither -1 nor +1 -- so \\u0027a\\u0027 cannot be prime\\n         */\\n        return 1;\\n    }\\n\\n    // ******************************** end is_prime functions ************************************   \\n\\n    /** @dev right_shift: right shift instance \\u0027dividend\\u0027 by \\u0027value\\u0027 bits.\\n      *           \\n      * parameter: instance a\\n      * parameter: instance b\\n      * parameter: bool signed\\n      * returns: int.\\n      */\\n    function right_shift(instance memory dividend, uint value) internal pure returns(instance memory){\\n        //TODO use memcpy for cheap rightshift where input is multiple of 8 (byte size)\\n        bytes memory result;\\n        uint word_shifted;\\n        uint mask_shift = 256-value;\\n        uint mask;\\n        uint result_ptr;\\n        uint max;\\n        uint length = dividend.val.length;\\n\\n        assembly {\\n            max := sub(0,32)\\n            result_ptr := add(mload(dividend), length)   \\n        }\\n\\n        for(uint i= length-32; i\\u003cmax;i-=32){                 //for each word:\\n            assembly{\\n                word_shifted := mload(result_ptr)               //get next word\\n                switch eq(i,0)                               //if i==0:\\n                case 1 { mask := 0 }                         // handles msword: no mask needed.\\n                default { mask := mload(sub(result_ptr,0x20)) } // else get mask.\\n            }\\n            word_shifted \\u003e\\u003e= value;                            //right shift current by value\\n            mask \\u003c\\u003c= mask_shift;                               // left shift next significant word by mask_shift\\n            assembly{ mstore(result_ptr, or(word_shifted,mask)) } // store OR\\u0027d mask and shifted value in-place\\n            result_ptr-=32;                                       // point to next value.\\n        }\\n\\n        assembly{\\n            //the following code removes any leading words containing all zeroes in the result.\\n            result_ptr := add(result_ptr,0x20)\\n            for { }  eq(mload(result_ptr), 0) { } {\\n               result_ptr := add(result_ptr, 0x20) //push up the start pointer for the result..\\n               length  := sub(length,0x20) //and subtract a word (32 bytes) from the result length.\\n            }\\n            \\n            result := sub(result_ptr,0x20)\\n            mstore(result, length) \\n        }\\n        \\n        dividend.val = result;\\n        dividend.bitlen = dividend.bitlen-value;\\n        return dividend;\\n    }\\n\\n    function left_shift(instance memory a) internal pure returns(uint) {\\n      //TODO\\n    }\\n\\n\\n    /** @dev hash: sha3 hash a BigNumber instance.\\n      *            we hash each instance WITHOUT it\\u0027s first word - first word is a pointer to the start of the bytes value,\\n      *            and so is different for each struct.\\n      *             \\n      * parameter: instance a\\n      * returns: bytes32 hash.\\n      */\\n    function hash(instance memory a) internal pure returns(bytes32 _hash) {\\n        //amount of words to hash = all words of the value and three extra words: neg, bitlen \\u0026 value length.     \\n        assembly {\\n            _hash := keccak256( add(a,0x20), add (mload(mload(a)), 0x60 ) ) \\n        }\\n    }\\n\\n    /** @dev get_bit_length: get the bit length of an instance value input.\\n      *           \\n      * parameter: bytes a\\n      * returns: uint res.\\n      */\\n    function get_bit_length(bytes memory val) internal pure returns(uint res){\\n        uint msword; \\n        assembly {msword := mload(add(val,0x20))}          //get msword of result\\n        res = get_word_length(msword) + (val.length-32)*8; //get bitlen pf msword, add to size of remaining words.\\n    }\\n\\n    /** @dev get_word_length: get the word length of a uint input - ie. log2_256 (most significant bit of 256 bit value (one EVM word))\\n      *                       credit: Tjaden Hess @ ethereum.stackexchange             \\n      *           \\n      * parameter: uint x\\n      * returns: uint y.\\n      */\\n  function get_word_length(uint x) internal pure returns (uint y){\\n      uint arg = x;\\n      assembly {\\n          x := sub(x,1)\\n          x := or(x, div(x, 0x02))\\n          x := or(x, div(x, 0x04))\\n          x := or(x, div(x, 0x10))\\n          x := or(x, div(x, 0x100))\\n          x := or(x, div(x, 0x10000))\\n          x := or(x, div(x, 0x100000000))\\n          x := or(x, div(x, 0x10000000000000000))\\n          x := or(x, div(x, 0x100000000000000000000000000000000))\\n          x := add(x, 1)\\n          let m := mload(0x40)\\n          mstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\\n          mstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\\n          mstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\\n          mstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\\n          mstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\\n          mstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\\n          mstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\\n          mstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\\n          mstore(0x40, add(m, 0x100))\\n          let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\\n          let shift := 0x100000000000000000000000000000000000000000000000000000000000000\\n          let a := div(mul(x, magic), shift)\\n          y := div(mload(add(m,sub(255,a))), shift)\\n          y := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\\n      }  \\n      if(arg \\u0026 arg-1 == 0 \\u0026\\u0026 x!=0) ++y; //where x is a power of two, result needs to be incremented. we use the power of two trick here\\n    }\\n\\n}\\n\\n\"},\"FactoringChallenge.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./BigNumber.sol\\\";\\n\\ncontract FactoringChallenge {\\n    mapping(bytes32 =\\u003e uint256) public claims;\\n    address payable public winner;\\n    BigNumber.instance public product;\\n    uint256 public withdrawlDelay;\\n    event ChallengeSolved();\\n\\n    constructor(bytes memory _product, uint256 _withdrawlDelay) {\\n        product.val = _product;\\n        product.bitlen = BigNumber.get_bit_length(_product);\\n        product.neg = false;\\n        withdrawlDelay = _withdrawlDelay;\\n    }\\n\\n    function isOne(bytes calldata value) internal pure returns (bool) {\\n        for (uint256 i = 0; i \\u003c value.length - 1; i++) {\\n            if (value[i] != 0x00) {\\n                return false;\\n            }\\n        }\\n        return value[value.length - 1] == 0x01;\\n    }\\n\\n    function hasExcessPadding(bytes calldata value)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        require(value.length \\u003e= 32, \\\"Value has fewer than 32 bytes\\\");\\n        for (uint256 i = 0; i \\u003c 32; i++) {\\n            if (value[i] != 0x00) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function donate() external payable {\\n        require(winner == address(0), \\\"Challenge has been solved\\\");\\n    }\\n\\n    function submitClaim(bytes32 _hash) external {\\n        require(winner == address(0), \\\"Challenge has been solved\\\");\\n        claims[_hash] = block.number;\\n    }\\n\\n    function withdraw(bytes calldata _factor1, bytes calldata _factor2)\\n        external\\n    {\\n        require(winner == address(0), \\\"Challenge has been solved\\\");\\n        address payable claimant = payable(msg.sender);\\n\\n        require(!hasExcessPadding(_factor1), \\\"Excess padding\\\");\\n        require(!hasExcessPadding(_factor2), \\\"Excess padding\\\");\\n        require(!isOne(_factor1), \\\"Trivial factors\\\");\\n        require(!isOne(_factor2), \\\"Trivial factors\\\");\\n\\n        BigNumber.instance memory factor1 = BigNumber._new(\\n            _factor1,\\n            false,\\n            false\\n        );\\n        BigNumber.instance memory factor2 = BigNumber._new(\\n            _factor2,\\n            false,\\n            false\\n        );\\n\\n        bytes32 hash = keccak256(abi.encode(msg.sender, _factor1, _factor2));\\n        uint256 claimBlockNumber = claims[hash];\\n        require(claimBlockNumber \\u003e 0, \\\"Claim not found\\\");\\n        require(\\n            block.number - claimBlockNumber \\u003e withdrawlDelay,\\n            \\\"Not enough blocks mined since claim was submitted\\\"\\n        );\\n\\n        require(\\n            BigNumber.cmp(BigNumber.bn_mul(factor1, factor2), product, true) ==\\n                0,\\n            \\\"Invalid factors\\\"\\n        );\\n\\n        winner = claimant;\\n        emit ChallengeSolved();\\n\\n        (bool sent, ) = claimant.call{value: address(this).balance}(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether\\\");\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_product\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawlDelay\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ChallengeSolved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"claims\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"product\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"neg\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"bitlen\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"submitClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_factor1\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_factor2\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawlDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FactoringChallenge", "CompilerVersion": "v0.7.3+commit.9bfce1f6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000019f600000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000327aa1d8ca26c2297a03ad7f12a239875f0b741d8be2e203a75627a8fc179385641", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://df85bd6b89951440bc3773ff19fe914874f3949a821e297f787c17ab15c4c115"}]}