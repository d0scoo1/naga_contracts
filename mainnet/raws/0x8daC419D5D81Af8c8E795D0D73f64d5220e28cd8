{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/pools/balancer/BPool.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright Balancer, BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\nimport \\\"./BToken.sol\\\";\\nimport \\\"./BMath.sol\\\";\\nimport \\\"../../interfaces/IPool.sol\\\";\\nimport \\\"../../interfaces/ISideStaking.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\n\\n\\n/**\\n * @title BPool\\n *\\n * @dev Used by the (Ocean version) BFactory contract as a bytecode reference to\\n *      deploy new BPools.\\n *\\n * This contract is a friendly fork of Balancer [1]\\n *  [1] https://github.com/balancer-labs/balancer-core/contracts/.\\n\\n * All fees are expressed in wei.  Examples:\\n *  (1e17 = 10 % , 1e16 = 1% , 1e15 = 0.1%, 1e14 = 0.01%)\\n */\\ncontract BPool is BMath, BToken, IPool {\\n    using SafeERC20 for IERC20;\\n    struct Record {\\n        bool bound; // is token bound to pool\\n        uint256 index; // private\\n        uint256 denorm; // denormalized weight\\n        uint256 balance;\\n    }\\n\\n    event LOG_SWAP(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        uint256 tokenAmountIn,\\n        uint256 tokenAmountOut,\\n        uint256 timestamp,\\n        uint256 inBalance,\\n        uint256 outBalance,\\n        uint256 newSpotPrice\\n    );\\n\\n    event LOG_JOIN(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        uint256 tokenAmountIn,\\n        uint256 timestamp\\n    );\\n    event LOG_SETUP(\\n        address indexed caller,\\n        address indexed baseToken,\\n        uint256 baseTokenAmountIn,\\n        uint256 baseTokenWeight,\\n        address indexed datatoken,\\n        uint256 datatokenAmountIn,\\n        uint256 datatokenWeight\\n    );\\n\\n    event LOG_EXIT(\\n        address indexed caller,\\n        address indexed tokenOut,\\n        uint256 tokenAmountOut,\\n        uint256 timestamp\\n    );\\n\\n    event LOG_CALL(\\n        bytes4 indexed sig,\\n        address indexed caller,\\n        uint256 timestamp,\\n        bytes data\\n    );\\n\\n    event LOG_BPT(uint256 bptAmount);\\n    event LOG_BPT_SS(uint256 bptAmount); //emitted for SS contract\\n\\n    event OPCFee(\\n        address caller,\\n        address OPCWallet,\\n        address token,\\n        uint256 amount\\n    );\\n    event SwapFeeChanged(address caller, uint256 amount);\\n    event PublishMarketFee(\\n        address caller,\\n        address marketAddress,\\n        address token,\\n        uint256 amount\\n    );\\n    // emited for fees sent to consumeMarket\\n    event ConsumeMarketFee(address to, address token, uint256 amount);\\n    event SWAP_FEES(uint LPFeeAmount, uint oceanFeeAmount, uint marketFeeAmount,\\n        uint consumeMarketFeeAmount, address tokenFeeAddress);\\n    //emitted for every change done by publisherMarket\\n    event PublishMarketFeeChanged(address caller, address newMarketCollector, uint256 swapFee);\\n    event Gulped(address token, uint256 oldBalance, uint256 newBalance);\\n    modifier _lock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    modifier _viewlock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _;\\n    }\\n\\n    bool private _mutex;\\n\\n    address private _controller; // has CONTROL role\\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\\n\\n    //address public _publishMarketCollector;\\n    address public _publishMarketCollector;\\n    // `setSwapFee` and `finalize` require CONTROL\\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\\n    bool private _finalized;\\n\\n    address[] private _tokens;\\n    mapping(address => Record) private _records;\\n    uint256 private _totalWeight;\\n    ISideStaking ssContract;\\n\\n    //-----------------------------------------------------------------------\\n    //Proxy contract functionality: begin\\n    bool private initialized;\\n\\n    /**\\n     * @dev getId\\n     *      Return template id in case we need different ABIs. \\n     *      If you construct your own template, please make sure to change the hardcoded value\\n     */\\n    function getId() pure public returns (uint8) {\\n        return 1;\\n    }\\n\\n    function isInitialized() external view returns (bool) {\\n        return initialized;\\n    }\\n\\n    // Called prior to contract initialization (e.g creating new BPool instance)\\n    // Calls private _initialize function. Only if contract is not initialized.\\n    function initialize(\\n        address controller,\\n        address factory,\\n        uint256[] calldata swapFees,\\n        bool publicSwap,\\n        bool finalized,\\n        address[2] calldata tokens,\\n        address[1] calldata feeCollectors\\n    ) external returns (bool) {\\n        require(!initialized, \\\"ERR_ALREADY_INITIALIZED\\\");\\n        require(controller != address(0), \\\"ERR_INVALID_CONTROLLER_ADDRESS\\\");\\n        require(factory != address(0), \\\"ERR_INVALID_FACTORY_ADDRESS\\\");\\n        require(swapFees[0] >= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\n        require(swapFees[0] <= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n        require(swapFees[1] == 0 || swapFees[1]>= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\n        require(swapFees[1] <= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n        return\\n            _initialize(\\n                controller,\\n                factory,\\n                swapFees,\\n                publicSwap,\\n                finalized,\\n                tokens,\\n                feeCollectors\\n            );\\n    }\\n\\n    // Private function called on contract initialization.\\n    function _initialize(\\n        address controller,\\n        address factory,\\n        uint256[] memory swapFees,\\n        bool publicSwap,\\n        bool finalized,\\n        address[2] memory tokens,\\n        address[1] memory feeCollectors\\n    ) private returns (bool) {\\n        _controller = controller;\\n        router = factory;\\n        _swapFee = swapFees[0];\\n        emit SwapFeeChanged(msg.sender, _swapFee);\\n        _swapPublishMarketFee = swapFees[1];\\n        _publicSwap = publicSwap;\\n        _finalized = finalized;\\n        _datatokenAddress = tokens[0];\\n        _baseTokenAddress = tokens[1];\\n        _publishMarketCollector = feeCollectors[0];\\n        emit PublishMarketFeeChanged(msg.sender, _publishMarketCollector, _swapPublishMarketFee);\\n        initialized = true;\\n        ssContract = ISideStaking(_controller);\\n        return initialized;\\n    }\\n\\n    \\n    /**\\n     * @dev setup\\n     *      Initial setup of the pool\\n     *      Can be called only by the controller\\n     * @param datatokenAddress datatokenAddress\\n     * @param datatokenAmount how many datatokens in the initial reserve\\n     * @param datatokenWeight datatoken weight (hardcoded in deployer at 50%)\\n     * @param baseTokenAddress base token\\n     * @param baseTokenAmount how many basetokens in the initial reserve\\n     * @param baseTokenWeight base weight (hardcoded in deployer at 50%)\\n     */\\n    function setup(\\n        address datatokenAddress,\\n        uint256 datatokenAmount,\\n        uint256 datatokenWeight,\\n        address baseTokenAddress,\\n        uint256 baseTokenAmount,\\n        uint256 baseTokenWeight\\n    ) external _lock_ {\\n        require(msg.sender == _controller, \\\"ERR_INVALID_CONTROLLER\\\");\\n        require(\\n            datatokenAddress == _datatokenAddress,\\n            \\\"ERR_INVALID_DATATOKEN_ADDRESS\\\"\\n        );\\n        require(\\n            baseTokenAddress == _baseTokenAddress,\\n            \\\"ERR_INVALID_baseToken_ADDRESS\\\"\\n        );\\n        // other inputs will be validated prior\\n        // calling the below functions\\n        // bind datatoken\\n        bind(datatokenAddress, datatokenAmount, datatokenWeight);\\n        emit LOG_JOIN(\\n            msg.sender,\\n            datatokenAddress,\\n            datatokenAmount,\\n            block.timestamp\\n        );\\n\\n        // bind baseToken\\n        bind(baseTokenAddress, baseTokenAmount, baseTokenWeight);\\n        emit LOG_JOIN(\\n            msg.sender,\\n            baseTokenAddress,\\n            baseTokenAmount,\\n            block.timestamp\\n        );\\n        // finalize\\n        finalize();\\n        emit LOG_SETUP(\\n            msg.sender,\\n            baseTokenAddress,\\n            baseTokenAmount,\\n            baseTokenWeight,\\n            datatokenAddress,\\n            datatokenAmount,\\n            datatokenWeight\\n        );\\n    }\\n\\n    //Proxy contract functionality: end\\n    //-----------------------------------------------------------------------\\n    /**\\n     * @dev isPublicSwap\\n     *      Returns true if swapping is allowed\\n     */\\n    function isPublicSwap() external view returns (bool) {\\n        return _publicSwap;\\n    }\\n    /**\\n     * @dev isFinalized\\n     *      Returns true if pool is finalized\\n     */\\n    function isFinalized() external view returns (bool) {\\n        return _finalized;\\n    }\\n\\n    /**\\n     * @dev isBound\\n     *      Returns true if token is bound\\n     * @param t token to be checked\\n     */\\n    function isBound(address t) external view returns (bool) {\\n        return _records[t].bound;\\n    }\\n\\n    function _checkBound(address token) internal view {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n    }\\n\\n    /**\\n     * @dev getNumTokens\\n     *      Returns number of tokens bounded to pool\\n     */\\n    function getNumTokens() external view returns (uint256) {\\n        return _tokens.length;\\n    }\\n\\n    /**\\n     * @dev getCurrentTokens\\n     *      Returns tokens bounded to pool, before the pool is finalized\\n     */\\n    function getCurrentTokens()\\n        external\\n        view\\n        _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        return _tokens;\\n    }\\n\\n    /**\\n     * @dev getFinalTokens\\n     *      Returns tokens bounded to pool, after the pool was finalized\\n     */\\n    function getFinalTokens()\\n        public\\n        view\\n        _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        return _tokens;\\n    }\\n\\n    /**\\n     * @dev collectOPC\\n     *      Collects and send all OPC Fees to _opcCollector.\\n     *      This funtion can be called by anyone, because fees are being sent to _opcCollector\\n     */\\n    function collectOPC() external {\\n        address[] memory tokens = getFinalTokens();\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 amount = communityFees[tokens[i]];\\n            communityFees[tokens[i]] = 0;\\n            address _opcCollector = IFactoryRouter(router).getOPCCollector();\\n            emit OPCFee(msg.sender, _opcCollector, tokens[i], amount);\\n            IERC20(tokens[i]).safeTransfer(_opcCollector, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev getCurrentOPCFees\\n     *      Get the current amount of fees which can be withdrawned by OPC\\n     * @return address[] - array of tokens addresses\\n     *         uint256[] - array of amounts\\n     */\\n    function getCurrentOPCFees()\\n        public\\n        view\\n        returns (address[] memory, uint256[] memory)\\n    {\\n        address[] memory poolTokens = getFinalTokens();\\n        address[] memory tokens = new address[](poolTokens.length);\\n        uint256[] memory amounts = new uint256[](poolTokens.length);\\n        for (uint256 i = 0; i < poolTokens.length; i++) {\\n            tokens[i] = poolTokens[i];\\n            amounts[i] = communityFees[poolTokens[i]];\\n        }\\n        return (tokens, amounts);\\n    }\\n\\n    /**\\n     * @dev getCurrentMarketFees\\n     *      Get the current amount of fees which can be withdrawned by _publishMarketCollector\\n     * @return address[] - array of tokens addresses\\n     *         uint256[] - array of amounts\\n     */\\n    function getCurrentMarketFees()\\n        public\\n        view\\n        returns (address[] memory, uint256[] memory)\\n    {\\n        address[] memory poolTokens = getFinalTokens();\\n        address[] memory tokens = new address[](poolTokens.length);\\n        uint256[] memory amounts = new uint256[](poolTokens.length);\\n        for (uint256 i = 0; i < poolTokens.length; i++) {\\n            tokens[i] = poolTokens[i];\\n            amounts[i] = publishMarketFees[poolTokens[i]];\\n        }\\n        return (tokens, amounts);\\n    }\\n\\n    /**\\n     * @dev collectMarketFee\\n     *      Collects and send all Market Fees to _publishMarketCollector.\\n     *      This function can be called by anyone, because fees are being sent to _publishMarketCollector\\n     */\\n    function collectMarketFee() external {\\n        address[] memory tokens = getFinalTokens();\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 amount = publishMarketFees[tokens[i]];\\n            publishMarketFees[tokens[i]] = 0;\\n            emit PublishMarketFee(\\n                msg.sender,\\n                _publishMarketCollector,\\n                tokens[i],\\n                amount\\n            );\\n            IERC20(tokens[i]).safeTransfer(_publishMarketCollector, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev updatePublishMarketFee\\n     *      Set _newCollector as _publishMarketCollector\\n     * @param _newCollector new _publishMarketCollector\\n     * @param _newSwapFee new swapFee\\n     */\\n    function updatePublishMarketFee(address _newCollector, uint256 _newSwapFee) external {\\n        require(_publishMarketCollector == msg.sender, \\\"ONLY MARKET COLLECTOR\\\");\\n        require(_newCollector != address(0), \\\"Invalid _newCollector address\\\");\\n        require(_newSwapFee ==0 || _newSwapFee >= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\n        require(_newSwapFee <= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n        _publishMarketCollector = _newCollector;\\n        _swapPublishMarketFee = _newSwapFee;\\n        emit PublishMarketFeeChanged(msg.sender, _publishMarketCollector, _swapPublishMarketFee);\\n    }\\n\\n    /**\\n     * @dev getDenormalizedWeight\\n     *      Returns denormalized weight of a token\\n     * @param token token to be checked\\n     */\\n    function getDenormalizedWeight(address token)\\n        external\\n        view\\n        _viewlock_\\n        returns (uint256)\\n    {\\n        _checkBound(token);\\n        return _records[token].denorm;\\n    }\\n\\n     /**\\n     * @dev getTotalDenormalizedWeight\\n     *      Returns total denormalized weught of the pool\\n     */\\n    function getTotalDenormalizedWeight()\\n        external\\n        view\\n        _viewlock_\\n        returns (uint256)\\n    {\\n        return _totalWeight;\\n    }\\n\\n    /**\\n     * @dev getNormalizedWeight\\n     *      Returns normalized weight of a token\\n     * @param token token to be checked\\n     */\\n    \\n    function getNormalizedWeight(address token)\\n        external\\n        view\\n        _viewlock_\\n        returns (uint256)\\n    {\\n        _checkBound(token);\\n        uint256 denorm = _records[token].denorm;\\n        return bdiv(denorm, _totalWeight);\\n    }\\n\\n\\n    /**\\n     * @dev getBalance\\n     *      Returns the current token reserve amount\\n     * @param token token to be checked\\n     */\\n    function getBalance(address token)\\n        external\\n        view\\n        _viewlock_\\n        returns (uint256)\\n    {\\n        _checkBound(token);\\n        return _records[token].balance;\\n    }\\n\\n    /**\\n     * @dev getSwapFee\\n     *      Returns the current Liquidity Providers swap fee\\n     */\\n    function getSwapFee() external view returns (uint256) {\\n        return _swapFee;\\n    }\\n\\n    /**\\n     * @dev getMarketFee\\n     *      Returns the current fee of publishingMarket\\n     */\\n    function getMarketFee() external view returns (uint256) {\\n        return _swapPublishMarketFee;\\n    }\\n\\n    /**\\n     * @dev getController\\n     *      Returns the current controller address (ssBot)\\n     */\\n    function getController() external view returns (address) {\\n        return _controller;\\n    }\\n\\n    /**\\n     * @dev getDatatokenAddress\\n     *      Returns the current datatoken address\\n     */\\n    function getDatatokenAddress() external view returns (address) {\\n        return _datatokenAddress;\\n    }\\n\\n    /**\\n     * @dev getBaseTokenAddress\\n     *      Returns the current baseToken address\\n     */\\n    function getBaseTokenAddress() external view returns (address) {\\n        return _baseTokenAddress;\\n    }\\n\\n\\n    /**\\n     * @dev setSwapFee\\n     *      Allows controller to change the swapFee\\n     * @param swapFee new swap fee (max 1e17 = 10 % , 1e16 = 1% , 1e15 = 0.1%, 1e14 = 0.01%)\\n     */\\n    function setSwapFee(uint256 swapFee) public {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(swapFee >= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\n        require(swapFee <= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n        _swapFee = swapFee;\\n        emit SwapFeeChanged(msg.sender, swapFee);\\n    }\\n\\n    /**\\n     * @dev finalize\\n     *      Finalize pool. After this,new tokens cannot be bound\\n     */\\n    function finalize() internal {\\n        _finalized = true;\\n        _publicSwap = true;\\n\\n        _mintPoolShare(INIT_POOL_SUPPLY);\\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\\n    }\\n\\n    /**\\n     * @dev bind\\n     *      Bind a new token to the pool.\\n     * @param token token address\\n     * @param balance initial reserve\\n     * @param denorm denormalized weight\\n     */\\n    function bind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) internal {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(!_records[token].bound, \\\"ERR_IS_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        require(_tokens.length < MAX_BOUND_TOKENS, \\\"ERR_MAX_TOKENS\\\");\\n\\n        _records[token] = Record({\\n            bound: true,\\n            index: _tokens.length,\\n            denorm: 0, // balance and denorm will be validated\\n            balance: 0 // and set by `rebind`\\n        });\\n        _tokens.push(token);\\n        rebind(token, balance, denorm);\\n    }\\n\\n    /**\\n     * @dev rebind\\n     *      Update pool reserves & weight after a token bind\\n     * @param token token address\\n     * @param balance initial reserve\\n     * @param denorm denormalized weight\\n     */\\n    function rebind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) internal {\\n        require(denorm >= MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n        require(denorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n        require(balance >= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n\\n        // Adjust the denorm and totalWeight\\n        uint256 oldWeight = _records[token].denorm;\\n        if (denorm > oldWeight) {\\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\\n            require(_totalWeight <= MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n        } else if (denorm < oldWeight) {\\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\\n        }\\n        _records[token].denorm = denorm;\\n\\n        // Adjust the balance record and actual token balance\\n        uint256 oldBalance = _records[token].balance;\\n        _records[token].balance = balance;\\n        if (balance > oldBalance) {\\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\\n        } else if (balance < oldBalance) {\\n            // In this case liquidity is being withdrawn, we don't have EXIT_FEES\\n            uint256 tokenBalanceWithdrawn = bsub(oldBalance, balance);\\n            _pushUnderlying(\\n                token,\\n                msg.sender,\\n                tokenBalanceWithdrawn\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev getSpotPrice\\n     *      Return the spot price of swapping tokenIn to tokenOut\\n     * @param tokenIn in token\\n     * @param tokenOut out token\\n     * @param _consumeMarketSwapFee consume market swap fee \\n     */\\n    function getSpotPrice(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 _consumeMarketSwapFee\\n    ) external view _viewlock_ returns (uint256 spotPrice) {\\n        _checkBound(tokenIn);\\n        _checkBound(tokenOut);\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return\\n            calcSpotPrice(\\n                inRecord.balance,\\n                inRecord.denorm,\\n                outRecord.balance,\\n                outRecord.denorm,\\n                _consumeMarketSwapFee\\n            );\\n    }\\n\\n    // view function used for batch buy. useful for frontend\\n     /**\\n     * @dev getAmountInExactOut\\n     *      How many tokensIn do you need in order to get exact tokenAmountOut.\\n            Returns: tokenAmountIn, LPFee, opcFee , publishMarketSwapFee, consumeMarketSwapFee\\n     * @param tokenIn token to be swaped\\n     * @param tokenOut token to get\\n     * @param tokenAmountOut exact amount of tokenOut\\n     * @param _consumeMarketSwapFee consume market swap fee\\n     */\\n\\n    function getAmountInExactOut(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 tokenAmountOut,\\n        uint256 _consumeMarketSwapFee\\n    )\\n        external\\n        view\\n        returns (\\n            // _viewlock_\\n            uint256 tokenAmountIn, uint lpFeeAmount, \\n            uint oceanFeeAmount, \\n            uint publishMarketSwapFeeAmount,\\n            uint consumeMarketSwapFeeAmount\\n        )\\n    {\\n        _checkBound(tokenIn);\\n        _checkBound(tokenOut);\\n        uint256[4] memory data = [\\n            _records[tokenIn].balance,\\n            _records[tokenIn].denorm,\\n            _records[tokenOut].balance,\\n            _records[tokenOut].denorm\\n        ];\\n        uint tokenAmountInBalance;\\n        swapfees memory _swapfees;\\n        (tokenAmountIn, tokenAmountInBalance, _swapfees) =        \\n            calcInGivenOut(\\n                data,\\n                tokenAmountOut,\\n                // tokenIn,\\n                _consumeMarketSwapFee\\n            );\\n        return(tokenAmountIn, _swapfees.LPFee, _swapfees.oceanFeeAmount, \\n        _swapfees.publishMarketFeeAmount, _swapfees.consumeMarketFee);\\n\\n    }\\n\\n    // view function useful for frontend\\n    /**\\n     * @dev getAmountOutExactIn\\n     *      How many tokensOut you will get for a exact tokenAmountIn\\n            Returns: tokenAmountOut, LPFee, opcFee ,  publishMarketSwapFee, consumeMarketSwapFee\\n     * @param tokenIn token to be swaped\\n     * @param tokenOut token to get\\n     * @param tokenAmountOut exact amount of tokenOut\\n     * @param _consumeMarketSwapFee consume market swap fee\\n     */\\n    function getAmountOutExactIn(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 tokenAmountIn,\\n        uint256 _consumeMarketSwapFee\\n    )\\n        external\\n        view\\n        returns (\\n            //  _viewlock_\\n            uint256 tokenAmountOut,\\n            uint lpFeeAmount, \\n            uint oceanFeeAmount, \\n            uint publishMarketSwapFeeAmount,\\n            uint consumeMarketSwapFeeAmount\\n        )\\n    {\\n        _checkBound(tokenIn);\\n        _checkBound(tokenOut);\\n        uint256[4] memory data = [\\n            _records[tokenIn].balance,\\n            _records[tokenIn].denorm,\\n            _records[tokenOut].balance,\\n            _records[tokenOut].denorm\\n        ];\\n        uint balanceInToAdd;\\n        swapfees memory _swapfees;\\n         (tokenAmountOut, balanceInToAdd, _swapfees) =        \\n            calcOutGivenIn(\\n                data,\\n                tokenAmountIn,\\n               // tokenIn,\\n                _consumeMarketSwapFee\\n            );\\n        return(tokenAmountOut, _swapfees.LPFee, \\n        _swapfees.oceanFeeAmount, _swapfees.publishMarketFeeAmount, _swapfees.consumeMarketFee);\\n    }\\n\\n\\n    /**\\n     * @dev swapExactAmountIn\\n     *      Swaps an exact amount of tokensIn to get a mimum amount of tokenOut\\n     * @param tokenInOutMarket array of addreses: [tokenIn, tokenOut, consumeMarketFeeAddress]\\n     * @param amountsInOutMaxFee array of ints: [tokenAmountIn, minAmountOut, maxPrice, consumeMarketSwapFee]\\n     */\\n    function swapExactAmountIn(\\n        address[3] calldata tokenInOutMarket, \\n        uint256[4] calldata amountsInOutMaxFee\\n    ) external _lock_ returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(tokenInOutMarket[0] != tokenInOutMarket[1], 'Cannot swap same token');\\n        _checkBound(tokenInOutMarket[0]);\\n        _checkBound(tokenInOutMarket[1]);\\n        Record storage inRecord = _records[address(tokenInOutMarket[0])];\\n        Record storage outRecord = _records[address(tokenInOutMarket[1])];\\n        require(amountsInOutMaxFee[3] ==0 || amountsInOutMaxFee[3] >= MIN_FEE,'ConsumeSwapFee too low');\\n        require(amountsInOutMaxFee[3] <= MAX_FEE,'ConsumeSwapFee too high');\\n        require(\\n            amountsInOutMaxFee[0] <= bmul(inRecord.balance, MAX_IN_RATIO),\\n            \\\"ERR_MAX_IN_RATIO\\\"\\n        );\\n\\n        uint256 spotPriceBefore = calcSpotPrice(\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm,\\n            amountsInOutMaxFee[3]\\n        );\\n\\n        require(\\n            spotPriceBefore <= amountsInOutMaxFee[2],\\n            \\\"ERR_BAD_LIMIT_PRICE\\\"\\n        );\\n        uint256 balanceInToAdd;\\n        uint256[4] memory data = [\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm\\n        ];\\n        swapfees memory _swapfees;\\n        (tokenAmountOut, balanceInToAdd, _swapfees) = calcOutGivenIn(\\n            data,\\n            amountsInOutMaxFee[0],\\n           // tokenInOutMarket[0],\\n            amountsInOutMaxFee[3]\\n        );\\n        // update balances\\n        communityFees[tokenInOutMarket[0]] = badd(communityFees[tokenInOutMarket[0]],_swapfees.oceanFeeAmount);\\n        publishMarketFees[tokenInOutMarket[0]] = \\n        badd(publishMarketFees[tokenInOutMarket[0]],_swapfees.publishMarketFeeAmount);\\n        emit SWAP_FEES(_swapfees.LPFee, _swapfees.oceanFeeAmount,\\n        _swapfees.publishMarketFeeAmount,_swapfees.consumeMarketFee, tokenInOutMarket[0]);\\n        require(tokenAmountOut >= amountsInOutMaxFee[1], \\\"ERR_LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, balanceInToAdd);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm,\\n            amountsInOutMaxFee[3]\\n        );\\n\\n        require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\n        require(spotPriceAfter <= amountsInOutMaxFee[2], \\\"ERR_LIMIT_PRICE\\\");\\n\\n        require(\\n            spotPriceBefore <= bdiv(amountsInOutMaxFee[0], tokenAmountOut),\\n            \\\"ERR_MATH_APPROX\\\"\\n        );\\n\\n        emit LOG_SWAP(\\n            msg.sender,\\n            tokenInOutMarket[0],\\n            tokenInOutMarket[1],\\n            amountsInOutMaxFee[0],\\n            tokenAmountOut,\\n            block.timestamp,\\n            inRecord.balance,\\n            outRecord.balance,\\n            spotPriceAfter\\n\\n        );\\n\\n        _pullUnderlying(tokenInOutMarket[0], msg.sender, amountsInOutMaxFee[0]);\\n        uint256 consumeMarketFeeAmount = bsub(\\n            amountsInOutMaxFee[0],\\n            bmul(amountsInOutMaxFee[0], bsub(BONE, amountsInOutMaxFee[3]))\\n        );\\n        if (amountsInOutMaxFee[3] > 0) {\\n            IERC20(tokenInOutMarket[0]).safeTransfer(\\n                tokenInOutMarket[2],\\n                consumeMarketFeeAmount\\n            );\\n            emit ConsumeMarketFee(\\n                tokenInOutMarket[2],\\n                tokenInOutMarket[0],\\n                consumeMarketFeeAmount\\n            );\\n        }\\n        _pushUnderlying(tokenInOutMarket[1], msg.sender, tokenAmountOut);\\n\\n        return (tokenAmountOut, spotPriceAfter); //returning spot price 0 because there is no public spotPrice\\n    }\\n\\n\\n    /**\\n     * @dev swapExactAmountOut\\n     *      Swaps a maximum  maxAmountIn of tokensIn to get an exact amount of tokenOut\\n     * @param tokenInOutMarket array of addreses: [tokenIn, tokenOut, consumeMarketFeeAddress]\\n     * @param amountsInOutMaxFee array of ints: [maxAmountIn,tokenAmountOut,maxPrice, consumeMarketSwapFee]\\n     */\\n    function swapExactAmountOut(\\n        address[3] calldata tokenInOutMarket,\\n        uint256[4] calldata amountsInOutMaxFee\\n    ) external _lock_ returns (uint256 tokenAmountIn, uint256 spotPriceAfter) {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(tokenInOutMarket[0] != tokenInOutMarket[1], 'Cannot swap same token');\\n        require(amountsInOutMaxFee[3] ==0 || amountsInOutMaxFee[3] >= MIN_FEE,'ConsumeSwapFee too low');\\n        require(amountsInOutMaxFee[3] <= MAX_FEE,'ConsumeSwapFee too high');\\n        _checkBound(tokenInOutMarket[0]);\\n        _checkBound(tokenInOutMarket[1]);\\n        Record storage inRecord = _records[address(tokenInOutMarket[0])];\\n        Record storage outRecord = _records[address(tokenInOutMarket[1])];\\n\\n        require(\\n            amountsInOutMaxFee[1] <= bmul(outRecord.balance, MAX_OUT_RATIO),\\n            \\\"ERR_MAX_OUT_RATIO\\\"\\n        );\\n\\n        uint256 spotPriceBefore = calcSpotPrice(\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm,\\n            amountsInOutMaxFee[3]\\n        );\\n\\n        require(\\n            spotPriceBefore <= amountsInOutMaxFee[2],\\n            \\\"ERR_BAD_LIMIT_PRICE\\\"\\n        );\\n        // this is the amount we are going to register in balances\\n        // (only takes account of swapFee, not OPC and market fee,\\n        //in order to not affect price during following swaps, fee wtihdrawl etc)\\n        uint256 balanceToAdd;\\n        uint256[4] memory data = [\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm\\n        ];\\n        swapfees memory _swapfees;\\n        (tokenAmountIn, balanceToAdd,\\n        _swapfees) = calcInGivenOut(\\n            data,\\n            amountsInOutMaxFee[1],\\n            //tokenInOutMarket[0],\\n            amountsInOutMaxFee[3]\\n        );\\n        communityFees[tokenInOutMarket[0]] = badd(communityFees[tokenInOutMarket[0]],_swapfees.oceanFeeAmount);\\n        publishMarketFees[tokenInOutMarket[0]] \\n        = badd(publishMarketFees[tokenInOutMarket[0]],_swapfees.publishMarketFeeAmount);\\n        emit SWAP_FEES(_swapfees.LPFee, _swapfees.oceanFeeAmount,\\n        _swapfees.publishMarketFeeAmount,_swapfees.consumeMarketFee, tokenInOutMarket[0]);\\n        require(tokenAmountIn <= amountsInOutMaxFee[0], \\\"ERR_LIMIT_IN\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, balanceToAdd);\\n        outRecord.balance = bsub(outRecord.balance, amountsInOutMaxFee[1]);\\n\\n        spotPriceAfter = calcSpotPrice(\\n            inRecord.balance,\\n            inRecord.denorm,\\n            outRecord.balance,\\n            outRecord.denorm,\\n            amountsInOutMaxFee[3]\\n        );\\n\\n        require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\n        require(spotPriceAfter <= amountsInOutMaxFee[2], \\\"ERR_LIMIT_PRICE\\\");\\n        require(\\n            spotPriceBefore <= bdiv(tokenAmountIn, amountsInOutMaxFee[1]),\\n            \\\"ERR_MATH_APPROX\\\"\\n        );\\n\\n        emit LOG_SWAP(\\n            msg.sender,\\n            tokenInOutMarket[0],\\n            tokenInOutMarket[1],\\n            tokenAmountIn,\\n            amountsInOutMaxFee[1],\\n            block.timestamp,\\n            inRecord.balance,\\n            outRecord.balance,\\n            spotPriceAfter\\n        );\\n        _pullUnderlying(tokenInOutMarket[0], msg.sender, tokenAmountIn);\\n        uint256 consumeMarketFeeAmount = bsub(\\n            tokenAmountIn,\\n            bmul(tokenAmountIn, bsub(BONE, amountsInOutMaxFee[3]))\\n        );\\n        if (amountsInOutMaxFee[3] > 0) {\\n            IERC20(tokenInOutMarket[0]).safeTransfer(\\n                tokenInOutMarket[2],// market address\\n                consumeMarketFeeAmount\\n            );\\n            emit ConsumeMarketFee(\\n                tokenInOutMarket[2], // to (market address)\\n                tokenInOutMarket[0], // token\\n                consumeMarketFeeAmount\\n            );\\n        }\\n        _pushUnderlying(tokenInOutMarket[1], msg.sender, amountsInOutMaxFee[1]);\\n        return (tokenAmountIn, spotPriceAfter);\\n    }\\n\\n    /**\\n     * @dev joinswapExternAmountIn\\n     *      Single side add liquidity to the pool,\\n     *      expecting a minPoolAmountOut of shares for spending tokenAmountIn basetokens\\n     * @param tokenAmountIn exact number of base tokens to spend\\n     * @param minPoolAmountOut minimum of pool shares expectex\\n     */\\n    function joinswapExternAmountIn(\\n        uint256 tokenAmountIn,\\n        uint256 minPoolAmountOut\\n    ) external _lock_ returns (uint256 poolAmountOut) {\\n        //tokenIn = _baseTokenAddress;\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        _checkBound(_baseTokenAddress);\\n        require(\\n            tokenAmountIn <= bmul(_records[_baseTokenAddress].balance, MAX_IN_RATIO),\\n            \\\"ERR_MAX_IN_RATIO\\\"\\n        );\\n        //ask ssContract\\n        Record storage inRecord = _records[_baseTokenAddress];\\n\\n        poolAmountOut = calcPoolOutGivenSingleIn(\\n            inRecord.balance,\\n            _totalSupply,\\n            tokenAmountIn\\n        );\\n\\n        require(poolAmountOut >= minPoolAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n        emit LOG_JOIN(msg.sender, _baseTokenAddress, tokenAmountIn, block.timestamp);\\n        emit LOG_BPT(poolAmountOut);\\n\\n        \\n\\n        //ask the ssContract to stake as well\\n        //calculate how much should the 1ss stake\\n        Record storage ssInRecord = _records[_datatokenAddress];\\n        uint256 ssAmountIn = calcSingleInGivenPoolOut(\\n            ssInRecord.balance,\\n            _totalSupply,\\n            poolAmountOut\\n        );\\n        if (ssContract.canStake(_datatokenAddress, ssAmountIn)) {\\n            \\n            //call 1ss to approve\\n            ssContract.Stake(_datatokenAddress, ssAmountIn);\\n            // follow the same path\\n            ssInRecord.balance = badd(ssInRecord.balance, ssAmountIn);\\n            emit LOG_JOIN(\\n                _controller,\\n                _datatokenAddress,\\n                ssAmountIn,\\n                block.timestamp\\n            );\\n            emit LOG_BPT_SS(poolAmountOut);\\n            _mintPoolShare(poolAmountOut);\\n            _pushPoolShare(_controller, poolAmountOut);\\n            _pullUnderlying(_datatokenAddress, _controller, ssAmountIn);\\n            \\n        }\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n        _pullUnderlying(_baseTokenAddress, msg.sender, tokenAmountIn);\\n        return poolAmountOut;\\n    }\\n\\n    \\n    /**\\n     * @dev exitswapPoolAmountIn\\n     *      Single side remove liquidity from the pool,\\n     *      expecting a minAmountOut of basetokens for spending poolAmountIn pool shares\\n     * @param poolAmountIn exact number of pool shares to spend\\n     * @param minAmountOut minimum amount of basetokens expected\\n     */\\n    function exitswapPoolAmountIn(\\n        uint256 poolAmountIn,\\n        uint256 minAmountOut\\n    ) external _lock_ returns (uint256 tokenAmountOut) {\\n        //tokenOut = _baseTokenAddress;\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        _checkBound(_baseTokenAddress);\\n\\n        Record storage outRecord = _records[_baseTokenAddress];\\n\\n        tokenAmountOut = calcSingleOutGivenPoolIn(\\n            outRecord.balance,\\n            _totalSupply,\\n            poolAmountIn\\n        );\\n        require(tokenAmountOut >= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        require(\\n            tokenAmountOut <= bmul(_records[_baseTokenAddress].balance, MAX_OUT_RATIO),\\n            \\\"ERR_MAX_OUT_RATIO\\\"\\n        );\\n\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        //uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\\n        emit LOG_EXIT(msg.sender, _baseTokenAddress, tokenAmountOut, block.timestamp);\\n        emit LOG_BPT(poolAmountIn);\\n\\n        //ask the ssContract to unstake as well\\n        //calculate how much should the 1ss unstake\\n        \\n        if (\\n            ssContract.canUnStake(_datatokenAddress, poolAmountIn)\\n        ) {\\n            Record storage ssOutRecord = _records[_datatokenAddress];\\n            uint256 ssAmountOut = calcSingleOutGivenPoolIn(\\n                ssOutRecord.balance,\\n                _totalSupply,\\n                poolAmountIn\\n            );\\n\\n            ssOutRecord.balance = bsub(ssOutRecord.balance, ssAmountOut);\\n            //exitFee = bmul(poolAmountIn, EXIT_FEE);\\n            emit LOG_EXIT(\\n                _controller,\\n                _datatokenAddress,\\n                ssAmountOut,\\n                block.timestamp\\n            );\\n            _pullPoolShare(_controller, poolAmountIn);\\n            //_burnPoolShare(bsub(poolAmountIn, exitFee));\\n            _burnPoolShare(poolAmountIn);\\n            //_pushPoolShare(_factory, exitFee);\\n            _pushUnderlying(_datatokenAddress, _controller, ssAmountOut);\\n            //call unstake on 1ss to do cleanup on their side\\n            ssContract.UnStake(\\n                _datatokenAddress,\\n                ssAmountOut,\\n                poolAmountIn\\n            );\\n            emit LOG_BPT_SS(poolAmountIn);\\n        }\\n        \\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        //_burnPoolShare(bsub(poolAmountIn, exitFee));\\n        _burnPoolShare(poolAmountIn);\\n        //_pushPoolShare(_factory, exitFee);\\n        _pushUnderlying(_baseTokenAddress, msg.sender, tokenAmountOut);\\n        return tokenAmountOut;\\n    }\\n\\n    \\n\\n    /**\\n     * @dev calcSingleOutPoolIn\\n     *      Returns expected amount of tokenOut for removing exact poolAmountIn pool shares from the pool\\n     * @param tokenOut tokenOut\\n     * @param poolAmountIn amount of shares spent\\n     */\\n    function calcSingleOutPoolIn(address tokenOut, uint256 poolAmountIn)\\n        external\\n        view\\n        returns (uint256 tokenAmountOut)\\n    {\\n        Record memory outRecord = _records[tokenOut];\\n\\n        tokenAmountOut = calcSingleOutGivenPoolIn(\\n            outRecord.balance,\\n            _totalSupply,\\n            poolAmountIn\\n        );\\n\\n        return tokenAmountOut;\\n    }\\n\\n    /**\\n     * @dev calcPoolInSingleOut\\n     *      Returns number of poolshares needed to withdraw exact tokenAmountOut tokens\\n     * @param tokenOut tokenOut\\n     * @param tokenAmountOut expected amount of tokensOut\\n     */\\n    function calcPoolInSingleOut(address tokenOut, uint256 tokenAmountOut)\\n        external\\n        view\\n        returns (uint256 poolAmountIn)\\n    {\\n        Record memory outRecord = _records[tokenOut];\\n\\n        poolAmountIn = calcPoolInGivenSingleOut(\\n            outRecord.balance,\\n            _totalSupply,\\n            tokenAmountOut\\n        );\\n        return poolAmountIn;\\n    }\\n\\n    /**\\n     * @dev calcSingleInPoolOut\\n     *      Returns number of tokens to be staked to the pool in order to get an exact number of poolshares\\n     * @param tokenIn tokenIn\\n     * @param poolAmountOut expected amount of pool shares\\n     */\\n    function calcSingleInPoolOut(address tokenIn, uint256 poolAmountOut)\\n        external\\n        view\\n        returns (uint256 tokenAmountIn)\\n    {\\n        Record memory inRecord = _records[tokenIn];\\n\\n        tokenAmountIn = calcSingleInGivenPoolOut(\\n            inRecord.balance,\\n            _totalSupply,\\n            poolAmountOut\\n        );\\n\\n        return tokenAmountIn;\\n    }\\n\\n    /**\\n     * @dev calcPoolOutSingleIn\\n     *      Returns number of poolshares obtain by staking exact tokenAmountIn tokens\\n     * @param tokenIn tokenIn\\n     * @param tokenAmountIn exact number of tokens staked\\n     */\\n    function calcPoolOutSingleIn(address tokenIn, uint256 tokenAmountIn)\\n        external\\n        view\\n        returns (uint256 poolAmountOut)\\n    {\\n        Record memory inRecord = _records[tokenIn];\\n\\n        poolAmountOut = calcPoolOutGivenSingleIn(\\n            inRecord.balance,\\n            _totalSupply,\\n            tokenAmountIn\\n        );\\n\\n        return poolAmountOut;\\n    }\\n\\n\\n    // Internal functions below\\n\\n    // ==\\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\\n    // You must `_lock_` or otherwise ensure reentry-safety\\n    function _pullUnderlying(\\n        address erc20,\\n        address from,\\n        uint256 amount\\n    ) internal {\\n        uint256 balanceBefore = IERC20(erc20).balanceOf(address(this));\\n        IERC20(erc20).safeTransferFrom(from, address(this), amount);\\n        require(IERC20(erc20).balanceOf(address(this)) >= balanceBefore + amount,\\n                    \\\"Transfer amount is too low\\\");\\n        //require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    }\\n\\n    function _pushUnderlying(\\n        address erc20,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        IERC20(erc20).safeTransfer(to, amount);\\n        //require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    }\\n\\n    function _pullPoolShare(address from, uint256 amount) internal {\\n        _pull(from, amount);\\n    }\\n\\n    function _pushPoolShare(address to, uint256 amount) internal {\\n        _push(to, amount);\\n    }\\n\\n    function _mintPoolShare(uint256 amount) internal {\\n        _mint(amount);\\n    }\\n\\n    function _burnPoolShare(uint256 amount) internal {\\n        _burn(amount);\\n    }\\n\\n    // Absorb any tokens that have been sent to this contract into the pool\\n    function gulp(address token)\\n        external\\n        _lock_\\n    {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        uint256 oldBalance = _records[token].balance;\\n        _records[token].balance = IERC20(token).balanceOf(address(this));\\n        emit Gulped(token,oldBalance, _records[token].balance);\\n    }\\n}\"\r\n    },\r\n    \"contracts/pools/balancer/BToken.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.12;\\n// Copyright Balancer, BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\nimport './BNum.sol';\\n// import '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../interfaces/IERC20.sol';\\n// Highly opinionated token implementation\\n\\n// interface IERC20 {\\n//     event Approval(address indexed src, address indexed dst, uint amt);\\n//     event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n//     function totalSupply() external view returns (uint);\\n//     function balanceOf(address whom) external view returns (uint);\\n//     function allowance(address src, address dst) external view returns (uint);\\n\\n//     function approve(address dst, uint amt) external returns (bool);\\n//     function transfer(address dst, uint amt) external returns (bool);\\n//     function transferFrom(\\n//         address src, address dst, uint amt\\n//     ) external returns (bool);\\n// }\\n\\ncontract BTokenBase is BNum {\\n\\n    mapping(address => uint)                   internal _balance;\\n    mapping(address => mapping(address=>uint)) internal _allowance;\\n    uint internal _totalSupply;\\n\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function _mint(uint amt) internal {\\n        _balance[address(this)] = badd(_balance[address(this)], amt);\\n        _totalSupply = badd(_totalSupply, amt);\\n        emit Transfer(address(0), address(this), amt);\\n    }\\n\\n    function _burn(uint amt) internal {\\n        require(\\n            _balance[address(this)] >= amt, \\n            'ERR_INSUFFICIENT_BAL'\\n        );\\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\\n        _totalSupply = bsub(_totalSupply, amt);\\n        emit Transfer(address(this), address(0), amt);\\n    }\\n\\n    function _move(address src, address dst, uint amt) internal {\\n        require(_balance[src] >= amt, 'ERR_INSUFFICIENT_BAL');\\n        _balance[src] = bsub(_balance[src], amt);\\n        _balance[dst] = badd(_balance[dst], amt);\\n        emit Transfer(src, dst, amt);\\n    }\\n\\n    function _push(address to, uint amt) internal {\\n        _move(address(this), to, amt);\\n    }\\n\\n    function _pull(address from, uint amt) internal {\\n        _move(from, address(this), amt);\\n    }\\n}\\n\\ncontract BToken is BTokenBase {\\n\\n    function name() external view returns (string memory) {\\n        return 'Ocean Pool Token';\\n    }\\n\\n    function symbol() external view returns (string memory) {\\n        return 'OPT';\\n    }\\n\\n    function decimals() external view returns(uint8) {\\n        return 18;\\n    }\\n\\n    function allowance(address src, address dst) external view returns (uint256) {\\n        return _allowance[src][dst];\\n    }\\n\\n    function balanceOf(address whom) external view returns (uint) {\\n        return _balance[whom];\\n    }\\n\\n    function totalSupply() public view returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function approve(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = amt;\\n        emit Approval(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function increaseApproval(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\\n        uint oldValue = _allowance[msg.sender][dst];\\n        if (amt > oldValue) {\\n            _allowance[msg.sender][dst] = 0;\\n        } else {\\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\\n        }\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint amt) external returns (bool) {\\n        _move(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address src, \\n        address dst, \\n        uint amt\\n    ) \\n    external\\n    returns (bool) \\n    {\\n        require(\\n            msg.sender == src || amt <= _allowance[src][msg.sender], \\n            'ERR_BTOKEN_BAD_CALLER'\\n        );\\n        _move(src, dst, amt);\\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(int(-1)) ) {\\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\\n            emit Approval(src, msg.sender, _allowance[src][msg.sender]);\\n        }\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pools/balancer/BMath.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.12;\\n// Copyright Balancer, BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\nimport './BNum.sol';\\n\\n\\nimport \\\"../../interfaces/IFactoryRouter.sol\\\";\\n\\ncontract BMath is BConst, BNum {\\n\\n   // uint public _swapMarketFee;\\n    uint public _swapPublishMarketFee;\\n    uint internal _swapFee;\\n  \\n    address public router; // BFactory address to push token exitFee to\\n\\n    address internal _datatokenAddress; //datatoken address\\n    address internal _baseTokenAddress; //base token address\\n    mapping(address => uint) public communityFees;\\n\\n     mapping(address => uint) public publishMarketFees;\\n   // mapping(address => uint) public marketFees;\\n\\n\\n    function getOPCFee() public view returns (uint) {\\n        return IFactoryRouter(router).getOPCFee(_baseTokenAddress);\\n    }\\n    \\n    struct swapfees{\\n        uint256 LPFee;\\n        uint256 oceanFeeAmount;\\n        uint256 publishMarketFeeAmount;\\n        uint256 consumeMarketFee;\\n    }\\n    /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcSpotPrice(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint _swapMarketFee\\n    )\\n        internal view\\n        returns (uint spotPrice)\\n        \\n    {   \\n       \\n\\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n        uint ratio = bdiv(numer, denom);\\n        uint scale = bdiv(BONE, bsub(BONE, _swapFee+getOPCFee()+_swapPublishMarketFee+_swapMarketFee));\\n      \\n        return  (spotPrice = bmul(ratio, scale));\\n    }\\n\\n    \\n    //    data = [\\n    //         inRecord.balance,\\n    //         inRecord.denorm,\\n    //         outRecord.balance,\\n    //         outRecord.denorm\\n    //     ];\\n    function calcOutGivenIn(\\n        uint[4] memory data,\\n        uint tokenAmountIn,\\n        //address tokenInAddress,\\n        uint256 _consumeMarketSwapFee\\n\\n    )\\n        public view\\n        returns (uint tokenAmountOut, uint balanceInToAdd, swapfees memory _swapfees)\\n    {\\n        uint weightRatio = bdiv(data[1], data[3]);\\n\\n        _swapfees.oceanFeeAmount =  bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, getOPCFee())));\\n\\n        \\n        _swapfees.publishMarketFeeAmount =  bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, _swapPublishMarketFee)));\\n        \\n\\n        _swapfees.LPFee = bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, _swapFee)));\\n        _swapfees.consumeMarketFee = bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, _consumeMarketSwapFee)));\\n        uint totalFee =_swapFee+getOPCFee()+_swapPublishMarketFee+_consumeMarketSwapFee;\\n\\n        uint adjustedIn = bsub(BONE, totalFee);\\n        \\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n         \\n        uint y = bdiv(data[0], badd(data[0], adjustedIn));\\n        uint foo = bpow(y, weightRatio);\\n        uint bar = bsub(BONE, foo);\\n        \\n\\n        tokenAmountOut = bmul(data[2], bar);\\n       \\n        return (tokenAmountOut, bsub(tokenAmountIn,(_swapfees.oceanFeeAmount+_swapfees.publishMarketFeeAmount+_swapfees.consumeMarketFee)), _swapfees);\\n        \\n    }\\n\\n     \\n    function calcInGivenOut(\\n        uint[4] memory data,\\n        uint tokenAmountOut,\\n        uint _consumeMarketSwapFee\\n    )\\n        public view \\n        returns (uint tokenAmountIn, uint tokenAmountInBalance, swapfees memory _swapfees)\\n    {\\n        uint weightRatio = bdiv(data[3], data[1]);\\n        uint diff = bsub(data[2], tokenAmountOut);\\n        uint y = bdiv(data[2], diff);\\n        uint foo = bpow(y, weightRatio);\\n        foo = bsub(foo, BONE);\\n        uint totalFee =_swapFee+getOPCFee()+_consumeMarketSwapFee+_swapPublishMarketFee;\\n        \\n        \\n        tokenAmountIn = bdiv(bmul(data[0], foo), bsub(BONE, totalFee));\\n        _swapfees.oceanFeeAmount =  bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, getOPCFee())));\\n        \\n     \\n        _swapfees.publishMarketFeeAmount =  bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, _swapPublishMarketFee)));\\n\\n     \\n        _swapfees.LPFee = bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, _swapFee)));\\n        _swapfees.consumeMarketFee = bsub(tokenAmountIn, bmul(tokenAmountIn, bsub(BONE, _consumeMarketSwapFee)));\\n        \\n      \\n        tokenAmountInBalance = bsub(tokenAmountIn,(_swapfees.oceanFeeAmount+_swapfees.publishMarketFeeAmount+_swapfees.consumeMarketFee));\\n      \\n        \\n        return (tokenAmountIn, tokenAmountInBalance,_swapfees);\\n    }\\n\\n    function calcPoolOutGivenSingleIn(\\n        uint tokenBalanceIn,\\n        uint poolSupply,\\n        uint tokenAmountIn\\n       \\n    )\\n        internal pure\\n        returns (uint poolAmountOut)\\n    {\\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, BONE);\\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\n        uint poolRatio = bsub(tokenInRatio,BONE);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        require(newPoolSupply >= 2, 'ERR_TOKEN_AMOUNT_IN_TOO_LOW'); \\n        newPoolSupply = newPoolSupply/2;\\n        return newPoolSupply;\\n    }\\n\\n    function calcSingleInGivenPoolOut(\\n        uint tokenBalanceIn,\\n        uint poolSupply,\\n        uint poolAmountOut\\n    )\\n        internal pure\\n        returns (uint tokenAmountIn)\\n    {\\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n        uint tokenInRatio = bsub(poolRatio, BONE);\\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\n        require(newTokenBalanceIn >= 1, 'ERR_POOL_AMOUNT_OUT_TOO_LOW'); \\n        newTokenBalanceIn = newTokenBalanceIn * 2;\\n        return newTokenBalanceIn;\\n    }\\n\\n    function calcSingleOutGivenPoolIn(\\n        uint tokenSupply,\\n        uint poolSupply,\\n        uint poolAmountIn\\n    )\\n        internal pure\\n        returns (uint tokenAmountOut)\\n    {\\n        require(poolAmountIn >= 1, 'ERR_POOL_AMOUNT_IN_TOO_LOW'); \\n        poolAmountIn = poolAmountIn * 2;\\n        uint newPoolSupply = bsub(poolSupply, poolAmountIn);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n        uint tokenOutRatio = bsub(BONE,poolRatio);\\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenSupply);\\n        return newTokenBalanceOut;\\n    }\\n\\n    function calcPoolInGivenSingleOut(\\n        uint tokenBalanceOut,\\n        uint poolSupply,\\n        uint tokenAmountOut\\n    )\\n        internal pure\\n        returns (uint poolAmountIn)\\n    {\\n        uint newTokenBalanceOut = bsub(\\n            tokenBalanceOut, \\n            tokenAmountOut\\n        );\\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\n        uint poolRatio = bsub(BONE,tokenOutRatio);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        require(newPoolSupply >= 2, 'ERR_TOKEN_AMOUNT_OUT_TOO_LOW'); \\n        newPoolSupply = newPoolSupply/2;\\n        return newPoolSupply;\\n    }\\n\\n\\n    \\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.12;\\n// Copyright Balancer, BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface IPool {\\n    function getDatatokenAddress() external view returns (address);\\n\\n    function getBaseTokenAddress() external view returns (address);\\n\\n    function getController() external view returns (address);\\n\\n    function setup(\\n        address datatokenAddress,\\n        uint256 datatokenAmount,\\n        uint256 datatokennWeight,\\n        address baseTokenAddress,\\n        uint256 baseTokenAmount,\\n        uint256 baseTokenWeight\\n    ) external;\\n\\n    function swapExactAmountIn(\\n        address[3] calldata tokenInOutMarket, //[tokenIn,tokenOut,marketFeeAddress]\\n        uint256[4] calldata amountsInOutMaxFee //[tokenAmountIn,minAmountOut,maxPrice,_swapMarketFee]\\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n\\n    function swapExactAmountOut(\\n        address[3] calldata tokenInOutMarket, // [tokenIn,tokenOut,marketFeeAddress]\\n        uint256[4] calldata amountsInOutMaxFee // [maxAmountIn,tokenAmountOut,maxPrice,_swapMarketFee]\\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\\n\\n    function getAmountInExactOut(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 tokenAmountOut,\\n        uint256 _consumeMarketSwapFee\\n    ) external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n    function getAmountOutExactIn(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 tokenAmountIn,\\n        uint256 _consumeMarketSwapFee\\n    ) external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n    function setSwapFee(uint256 swapFee) external;\\n    function getId() pure external returns (uint8);\\n\\n    function exitswapPoolAmountIn(\\n        uint256 poolAmountIn,\\n        uint256 minAmountOut\\n    ) external returns (uint256 tokenAmountOut);\\n    \\n    function joinswapExternAmountIn(\\n        uint256 tokenAmountIn,\\n        uint256 minPoolAmountOut\\n    ) external returns (uint256 poolAmountOut);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISideStaking.sol\": {\r\n      \"content\": \"// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface ISideStaking {\\n\\n\\n    function newDatatokenCreated(\\n        address datatokenAddress,\\n        address baseTokenAddress,\\n        address poolAddress,\\n        address publisherAddress,\\n        uint256[] calldata ssParams\\n    ) external returns (bool);\\n\\n    function getDatatokenCirculatingSupply(address datatokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getPublisherAddress(address datatokenAddress)\\n        external\\n        view\\n        returns (address);\\n\\n    function getBaseTokenAddress(address datatokenAddress)\\n        external\\n        view\\n        returns (address);\\n\\n    function getPoolAddress(address datatokenAddress)\\n        external\\n        view\\n        returns (address);\\n\\n    function getBaseTokenBalance(address datatokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getDatatokenBalance(address datatokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getvestingEndBlock(address datatokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getvestingAmount(address datatokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getvestingLastBlock(address datatokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getvestingAmountSoFar(address datatokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n\\n\\n    function canStake(\\n        address datatokenAddress,\\n        uint256 amount\\n    ) external view returns (bool);\\n\\n    function Stake(\\n        address datatokenAddress,\\n        uint256 amount\\n    ) external;\\n\\n    function canUnStake(\\n        address datatokenAddress,\\n        uint256 amount\\n    ) external view returns (bool);\\n\\n    function UnStake(\\n        address datatokenAddress,\\n        uint256 amount,\\n        uint256 poolAmountIn\\n    ) external;\\n\\n    function getId() pure external returns (uint8);\\n\\n  \\n}\"\r\n    },\r\n    \"contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"./ERC721/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pools/balancer/BNum.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.12;\\n// Copyright Balancer, BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\nimport './BConst.sol';\\n\\ncontract BNum is BConst {\\n\\n    function btoi(uint a)\\n        internal pure \\n        returns (uint)\\n    {\\n        return a / BONE;\\n    }\\n\\n    function bfloor(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return btoi(a) * BONE;\\n    }\\n\\n    function badd(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c = a + b;\\n        require(c >= a, 'ERR_ADD_OVERFLOW');\\n        return c;\\n    }\\n\\n    function bsub(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        (uint c, bool flag) = bsubSign(a, b);\\n        require(!flag, 'ERR_SUB_UNDERFLOW');\\n        return c;\\n    }\\n\\n    function bsubSign(uint a, uint b)\\n        internal pure\\n        returns (uint, bool)\\n    {\\n        if (a >= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function bmul(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, 'ERR_MUL_OVERFLOW');\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 >= c0, 'ERR_MUL_OVERFLOW');\\n        uint c2 = c1 / BONE;\\n        return c2;\\n    }\\n\\n    function bdiv(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(b != 0, 'ERR_DIV_ZERO');\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, 'ERR_DIV_INTERNAL'); // bmul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 >= c0, 'ERR_DIV_INTERNAL'); //  badd require\\n        uint c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    // DSMath.wpow\\n    function bpowi(uint a, uint n)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint b = a;\\n        uint z = n % 2 != 0 ? b : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            b = bmul(b, b);\\n\\n            if (n % 2 != 0) {\\n                z = bmul(z, b);\\n            }\\n        }\\n        return z;\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n    // of approximation of b^0.w\\n    function bpow(uint base, uint exp)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(base >= MIN_BPOW_BASE, 'ERR_BPOW_BASE_TOO_LOW');\\n        require(base <= MAX_BPOW_BASE, 'ERR_BPOW_BASE_TOO_HIGH');\\n\\n        uint whole = bfloor(exp);\\n        uint remain = bsub(exp, whole);\\n\\n        uint wholePow = bpowi(base, btoi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n        return bmul(wholePow, partialResult);\\n    }\\n\\n    function bpowApprox(uint base, uint exp, uint precision)\\n        internal pure\\n        returns (uint)\\n    {\\n        // term 0:\\n        uint a = exp;\\n        (uint x, bool xneg) = bsubSign(base, BONE);\\n        uint term = BONE;\\n        uint sum = term;\\n        bool negative = false;\\n\\n\\n        // term(k) = numer / denom \\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term >= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n            term = bmul(term, bmul(c, x));\\n            term = bdiv(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = bsub(sum, term);\\n            } else {\\n                sum = badd(sum, term);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/pools/balancer/BConst.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.12;\\n// Copyright Balancer, BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ncontract BConst {\\n    uint public constant BONE              = 1e18;\\n\\n    uint public constant MIN_BOUND_TOKENS  = 2;\\n    uint public constant MAX_BOUND_TOKENS  = 2;\\n\\n    uint public constant MIN_FEE           = BONE / 1e4;\\n    uint public constant MAX_FEE           = BONE / 10;\\n    uint public constant EXIT_FEE          = 0;\\n\\n    uint public constant MIN_WEIGHT        = BONE;\\n    uint public constant MAX_WEIGHT        = BONE * 50;\\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\\n    uint public constant MIN_BALANCE       = BONE / 1e12;\\n\\n    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\\n\\n    uint public constant MIN_BPOW_BASE     = 1 wei;\\n    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\\n    uint public constant BPOW_PRECISION    = BONE / 1e10;\\n\\n    uint public constant MAX_IN_RATIO      = BONE / 2;\\n    uint public constant MAX_OUT_RATIO     = (BONE / 2) + 1 wei;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFactoryRouter.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface IFactoryRouter {\\n    function deployPool(\\n        address[2] calldata tokens, // [datatokenAddress, baseTokenAddress]\\n        uint256[] calldata ssParams,\\n        uint256[] calldata swapFees,\\n        address[] calldata addresses\\n    ) external returns (address);\\n\\n    function deployFixedRate(\\n        address fixedPriceAddress,\\n        address[] calldata addresses,\\n        uint256[] calldata uints\\n    ) external returns (bytes32 exchangeId);\\n\\n    function getOPCFee(address baseToken) external view returns (uint256);\\n    function getOPCFees() external view returns (uint256,uint256);\\n    function getOPCConsumeFee() external view returns (uint256);\\n    function getOPCProviderFee() external view returns (uint256);\\n\\n    function getMinVestingPeriod() external view returns (uint256);\\n    function deployDispenser(\\n        address _dispenser,\\n        address datatoken,\\n        uint256 maxTokens,\\n        uint256 maxBalance,\\n        address owner,\\n        address allowedSwapper\\n    ) external;\\n\\n    function isApprovedToken(address) external view returns(bool);\\n    function getApprovedTokens() external view returns(address[] memory);\\n    function isSSContract(address) external view returns(bool);\\n    function getSSContracts() external view returns(address[] memory);\\n    function isFixedRateContract(address) external view returns(bool);\\n    function getFixedRatesContracts() external view returns(address[] memory);\\n    function isDispenserContract(address) external view returns(bool);\\n    function getDispensersContracts() external view returns(address[] memory);\\n    function isPoolTemplate(address) external view returns(bool);\\n    function getPoolTemplates() external view returns(address[] memory);\\n\\n    struct Stakes {\\n        address poolAddress;\\n        uint256 tokenAmountIn;\\n        uint256 minPoolAmountOut;\\n    }\\n    function stakeBatch(Stakes[] calldata) external;\\n\\n    enum operationType {\\n        SwapExactIn,\\n        SwapExactOut,\\n        FixedRate,\\n        Dispenser\\n    }\\n\\n    struct Operations {\\n        bytes32 exchangeIds; // used for fixedRate or dispenser\\n        address source; // pool, dispenser or fixed rate address\\n        operationType operation; // type of operation: enum operationType\\n        address tokenIn; // token in address, only for pools\\n        uint256 amountsIn; // ExactAmount In for swapExactIn operation, maxAmount In for swapExactOut\\n        address tokenOut; // token out address, only for pools\\n        uint256 amountsOut; // minAmountOut for swapExactIn or exactAmountOut for swapExactOut\\n        uint256 maxPrice; // maxPrice, only for pools\\n        uint256 swapMarketFee;\\n        address marketFeeAddress;\\n    }\\n    function buyDTBatch(Operations[] calldata) external;\\n    function updateOPCCollector(address _opcCollector) external;\\n    function getOPCCollector() view external returns (address);\\n}\"\r\n    },\r\n    \"contracts/utils/ERC721/Address.sol\": {\r\n      \"content\": \"\\npragma solidity 0.8.12;\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n\\n}\\n\\n\\n// File @openzeppelin/contracts/utils/Context.sol@v4.0.0\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ConsumeMarketFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"Gulped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bptAmount\",\"type\":\"uint256\"}],\"name\":\"LOG_BPT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bptAmount\",\"type\":\"uint256\"}],\"name\":\"LOG_BPT_SS\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LOG_CALL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseTokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseTokenWeight\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"datatoken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"datatokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"datatokenWeight\",\"type\":\"uint256\"}],\"name\":\"LOG_SETUP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSpotPrice\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"OPCWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OPCFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PublishMarketFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMarketCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"PublishMarketFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"LPFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oceanFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"consumeMarketFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenFeeAddress\",\"type\":\"address\"}],\"name\":\"SWAP_FEES\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SwapFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BPOW_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXIT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INIT_POOL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_publishMarketCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapPublishMarketFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"data\",\"type\":\"uint256[4]\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_consumeMarketSwapFee\",\"type\":\"uint256\"}],\"name\":\"calcInGivenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountInBalance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"LPFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oceanFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publishMarketFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"consumeMarketFee\",\"type\":\"uint256\"}],\"internalType\":\"struct BMath.swapfees\",\"name\":\"_swapfees\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"data\",\"type\":\"uint256[4]\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_consumeMarketSwapFee\",\"type\":\"uint256\"}],\"name\":\"calcOutGivenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceInToAdd\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"LPFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oceanFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publishMarketFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"consumeMarketFee\",\"type\":\"uint256\"}],\"internalType\":\"struct BMath.swapfees\",\"name\":\"_swapfees\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"calcPoolInSingleOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"calcPoolOutSingleIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"name\":\"calcSingleInPoolOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"}],\"name\":\"calcSingleOutPoolIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectMarketFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectOPC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"communityFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"exitswapPoolAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_consumeMarketSwapFee\",\"type\":\"uint256\"}],\"name\":\"getAmountInExactOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oceanFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publishMarketSwapFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"consumeMarketSwapFeeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_consumeMarketSwapFee\",\"type\":\"uint256\"}],\"name\":\"getAmountOutExactIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oceanFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publishMarketSwapFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"consumeMarketSwapFeeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentMarketFees\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentOPCFees\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDatatokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFinalTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getId\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarketFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getNormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOPCFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_consumeMarketSwapFee\",\"type\":\"uint256\"}],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"gulp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"swapFees\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"publicSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"finalized\",\"type\":\"bool\"},{\"internalType\":\"address[2]\",\"name\":\"tokens\",\"type\":\"address[2]\"},{\"internalType\":\"address[1]\",\"name\":\"feeCollectors\",\"type\":\"address[1]\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"isBound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPublicSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPoolAmountOut\",\"type\":\"uint256\"}],\"name\":\"joinswapExternAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"publishMarketFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"datatokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"datatokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"datatokenWeight\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"baseTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseTokenWeight\",\"type\":\"uint256\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[3]\",\"name\":\"tokenInOutMarket\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[4]\",\"name\":\"amountsInOutMaxFee\",\"type\":\"uint256[4]\"}],\"name\":\"swapExactAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[3]\",\"name\":\"tokenInOutMarket\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[4]\",\"name\":\"amountsInOutMaxFee\",\"type\":\"uint256[4]\"}],\"name\":\"swapExactAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCollector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newSwapFee\",\"type\":\"uint256\"}],\"name\":\"updatePublishMarketFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BPool", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}