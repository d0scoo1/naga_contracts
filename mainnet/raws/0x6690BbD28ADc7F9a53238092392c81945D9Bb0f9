{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/market/controller/facets/MarketClerkFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport \\\"../../../interfaces/IMarketClerk.sol\\\";\\nimport \\\"../../diamond/DiamondLib.sol\\\";\\nimport \\\"../MarketControllerBase.sol\\\";\\nimport \\\"../MarketControllerLib.sol\\\";\\n\\n/**\\n * @title MarketClerkFacet\\n *\\n * @notice Manages consignments for the Seen.Haus contract suite.\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ncontract MarketClerkFacet is IMarketClerk, MarketControllerBase, ERC1155HolderUpgradeable, ERC721HolderUpgradeable {\\n\\n    /**\\n     * @dev Modifier to protect initializer function from being invoked twice.\\n     */\\n    modifier onlyUnInitialized() {\\n        MarketControllerLib.MarketControllerInitializers storage mci = MarketControllerLib.marketControllerInitializers();\\n        require(!mci.clerkFacet, \\\"Initializer: contract is already initialized\\\");\\n        mci.clerkFacet = true;\\n        _;\\n    }\\n\\n    /**\\n     * @notice Facet Initializer\\n     *\\n     * Register IMarketClerk,\\n     */\\n    function initialize()\\n    public\\n    onlyUnInitialized\\n    {\\n        DiamondLib.addSupportedInterface(type(IMarketClerk).interfaceId);\\n        DiamondLib.addSupportedInterface(type(IERC1155ReceiverUpgradeable).interfaceId);\\n        DiamondLib.addSupportedInterface(type(IERC721ReceiverUpgradeable).interfaceId);\\n    }\\n\\n    /**\\n     * @notice The nextConsignment getter\\n     * @dev does not increment counter\\n     */\\n    function getNextConsignment()\\n    external\\n    override\\n    view\\n    returns (uint256)\\n    {\\n        MarketControllerLib.MarketControllerStorage storage mcs = MarketControllerLib.marketControllerStorage();\\n        return mcs.nextConsignment;\\n    }\\n\\n    /**\\n     * @notice The consignment getter\\n     *\\n     * Reverts if consignment doesn't exist\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @return consignment - the consignment struct\\n     */\\n    function getConsignment(uint256 _consignmentId)\\n    public\\n    override\\n    view\\n    consignmentExists(_consignmentId)\\n    returns (Consignment memory consignment)\\n    {\\n        MarketControllerLib.MarketControllerStorage storage mcs = MarketControllerLib.marketControllerStorage();\\n        consignment = mcs.consignments[_consignmentId];\\n    }\\n\\n    /**\\n     * @notice Get the remaining supply of the given consignment.\\n     *\\n     * Reverts if consignment doesn't exist\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @return  uint256 - the remaining supply held by the MarketController\\n     */\\n    function getUnreleasedSupply(uint256 _consignmentId)\\n    public\\n    override\\n    view\\n    consignmentExists(_consignmentId)\\n    returns(uint256)\\n    {\\n        MarketControllerLib.MarketControllerStorage storage mcs = MarketControllerLib.marketControllerStorage();\\n        Consignment storage consignment = mcs.consignments[_consignmentId];\\n        return consignment.supply - consignment.releasedSupply;\\n    }\\n\\n    /**\\n     * @notice Get the consignor of the given consignment\\n     *\\n     * Reverts if consignment doesn't exist\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @return  address - the consignor's address\\n     */\\n    function getConsignor(uint256 _consignmentId)\\n    public\\n    override\\n    view\\n    consignmentExists(_consignmentId)\\n    returns(address)\\n    {\\n        MarketControllerLib.MarketControllerStorage storage mcs = MarketControllerLib.marketControllerStorage();\\n        return mcs.consignors[_consignmentId];\\n    }\\n\\n    /**\\n     * @notice Registers a new consignment for sale or auction.\\n     *\\n     * Emits a ConsignmentRegistered event.\\n     *\\n     * Reverts if:\\n     *  - Token is multi-token and supply hasn't been transferred to this contract\\n     *  - Token is not multi-token and contract doesn't implement ERC-721\\n     *  - Token is not multi-token and this contract is not owner of tokenId\\n     *  - Token is not multi-token and the supply is not 1\\n     *\\n     * @param _market - the market for the consignment. See {SeenTypes.Market}\\n     * @param _consignor - the address executing the consignment transaction\\n     * @param _seller - the seller of the consignment\\n     * @param _tokenAddress - the contract address issuing the NFT behind the consignment\\n     * @param _tokenId - the id of the token being consigned\\n     * @param _supply - the amount of the token being consigned\\n     *\\n     * @return consignment - the registered consignment\\n     */\\n    function registerConsignment(\\n        Market _market,\\n        address _consignor,\\n        address payable _seller,\\n        address _tokenAddress,\\n        uint256 _tokenId,\\n        uint256 _supply\\n    )\\n    external\\n    override\\n    onlyRole(MARKET_HANDLER)\\n    returns (Consignment memory consignment)\\n    {\\n        MarketControllerLib.MarketControllerStorage storage mcs = MarketControllerLib.marketControllerStorage();\\n\\n        // Check whether this is a multi token NFT\\n        bool multiToken = IERC165Upgradeable(_tokenAddress).supportsInterface(type(IERC1155Upgradeable).interfaceId);\\n\\n        // Ensure consigned asset has been transferred to this this contract\\n        if (multiToken)  {\\n\\n            // Ensure this contract has a balance of this token which is at least the value of the supply of the consignment\\n            // WARNING: In the case of a multiToken, do not rely on this as being a guarantee that the creator of this consignment has transferred a _supply of this token to this contract\\n            // This is not guaranteed, as in the context of a secondary market, somebody else might have transferred a value equal or greater than _supply to this contract\\n            // THEREFORE: ALWAYS MAKE SURE THAT THE SUPPLY OF CONSIGNMENT REGISTRATION IS TRANSFERRED TO THIS CONTRACT BEFORE CALLING registerConsignment\\n            require( IERC1155Upgradeable(_tokenAddress).balanceOf(address(this), _tokenId) >= _supply, \\\"MarketController must own token\\\" );\\n\\n        } else {\\n\\n            // Token must be a single token NFT\\n            require(IERC165Upgradeable(_tokenAddress).supportsInterface(type(IERC721Upgradeable).interfaceId), \\\"Invalid token type\\\");\\n\\n            // Ensure the consigned token has been transferred to this contract & that supply = 1\\n            // Rolled into a single require due to contract size\\n            require((IERC721Upgradeable(_tokenAddress).ownerOf(_tokenId) == (address(this))) && (_supply == 1), \\\"MarketController must own token & supply must be 1\\\");\\n\\n        }\\n\\n        // Get the id for the new consignment and increment counter\\n        uint256 id = mcs.nextConsignment++;\\n\\n        // Create and store the consignment\\n        consignment = Consignment(\\n            _market,\\n            MarketHandler.Unhandled,\\n            _seller,\\n            _tokenAddress,\\n            _tokenId,\\n            _supply,\\n            id,\\n            multiToken,\\n            false,\\n            0,\\n            0,\\n            0\\n        );\\n        mcs.consignments[id] = consignment;\\n\\n        // Associate the consignor\\n        mcs.consignors[id] = _consignor;\\n\\n        // Notify listeners of state change\\n        emit ConsignmentRegistered(_consignor, _seller, consignment);\\n    }\\n\\n    /**\\n     * @notice Update consignment to indicate it has been marketed\\n     *\\n     * Emits a ConsignmentMarketed event.\\n     *\\n     * Reverts if:\\n     *  - _marketHandler of value Unhandled is passed into this function. See {SeenTypes.MarketHandler}.\\n     *  - consignment has already been marketed (has a marketHandler other than Unhandled). See {SeenTypes.MarketHandler}.\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     */\\n    function marketConsignment(uint256 _consignmentId, MarketHandler _marketHandler)\\n    external\\n    override\\n    onlyRole(MARKET_HANDLER)\\n    consignmentExists(_consignmentId)\\n    {\\n        require(_marketHandler != MarketHandler.Unhandled, \\\"requires valid handler\\\");\\n\\n        MarketControllerLib.MarketControllerStorage storage mcs = MarketControllerLib.marketControllerStorage();\\n\\n        // Get the consignment into memory\\n        Consignment storage consignment = mcs.consignments[_consignmentId];\\n\\n        // A consignment can only be marketed once, should currently be Unhandled\\n        require(consignment.marketHandler == MarketHandler.Unhandled, \\\"Consignment already marketed\\\");\\n\\n        // Update the consignment\\n        consignment.marketHandler = _marketHandler;\\n\\n        // Consignor address\\n        address consignor = mcs.consignors[_consignmentId];\\n\\n        // Notify listeners of state change\\n        emit ConsignmentMarketed(consignor, consignment.seller, consignment.id);\\n    }\\n\\n    /**\\n     * @notice Release an amount of the consigned token balance to a given address\\n     *\\n     * Emits a ConsignmentReleased event.\\n     *\\n     * Reverts if:\\n     *  - caller is does not have MARKET_HANDLER role.\\n     *  - consignment doesn't exist\\n     *  - consignment has already been released\\n     *  - consignment is multi-token and supply is not adequate\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @param _amount - the amount of the consigned supply (must be 1 for ERC721 tokens)\\n     * @param _releaseTo - the address to transfer the consigned token balance to\\n     */\\n    function releaseConsignment(uint256 _consignmentId, uint256 _amount, address _releaseTo)\\n    external\\n    override\\n    onlyRole(MARKET_HANDLER)\\n    consignmentExists(_consignmentId)\\n    {\\n        MarketControllerLib.MarketControllerStorage storage mcs = MarketControllerLib.marketControllerStorage();\\n\\n        // Get the consignment into memory\\n        Consignment storage consignment = mcs.consignments[_consignmentId];\\n\\n        // Ensure the consignment has not been released\\n        require(!consignment.released, \\\"Consigned token already released\\\");\\n\\n        // Handle transfer, marking of consignment\\n        if (consignment.multiToken) {\\n\\n            // Get the current remaining consignment supply\\n            uint256 remainingSupply = consignment.supply - consignment.releasedSupply;\\n\\n            // Safety check\\n            require(_amount <= remainingSupply, \\\"Attempting to release more than is available to consignment\\\");\\n\\n            // Mark the consignment when the entire consignment supply has been released\\n            if (remainingSupply == _amount) consignment.released = true;\\n            consignment.releasedSupply = consignment.releasedSupply + _amount;\\n\\n            // Transfer a balance of the token from the MarketController to the recipient\\n            IERC1155Upgradeable(consignment.tokenAddress).safeTransferFrom(\\n                address(this),\\n                _releaseTo,\\n                consignment.tokenId,\\n                _amount,\\n                new bytes(0x0)\\n            );\\n\\n        } else {\\n\\n            // Mark the single-token consignment released\\n            consignment.released = true;\\n            consignment.releasedSupply = consignment.releasedSupply + _amount;\\n\\n            // Transfer the token from the MarketController to the recipient\\n            IERC721Upgradeable(consignment.tokenAddress).safeTransferFrom(\\n                address(this),\\n                _releaseTo,\\n                consignment.tokenId\\n            );\\n\\n        }\\n\\n        // Notify watchers about state change\\n        emit ConsignmentReleased(consignment.id, _amount, _releaseTo);\\n\\n    }\\n\\n    /**\\n     * @notice Clears the pending payout value of a consignment\\n     *\\n     * Emits a ConsignmentPayoutSet event.\\n     *\\n     * Reverts if:\\n     *  - caller is does not have MARKET_HANDLER role.\\n     *  - consignment doesn't exist\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @param _amount - the amount of that the consignment's pendingPayout must be set to\\n     */\\n    function setConsignmentPendingPayout(uint256 _consignmentId, uint256 _amount)\\n    external\\n    override\\n    onlyRole(MARKET_HANDLER)\\n    consignmentExists(_consignmentId)\\n    {\\n        MarketControllerLib.MarketControllerStorage storage mcs = MarketControllerLib.marketControllerStorage();\\n\\n        // Get the consignment into memory\\n        Consignment storage consignment = mcs.consignments[_consignmentId];\\n\\n        // Update pending payout\\n        consignment.pendingPayout = _amount;\\n\\n        // Notify watchers about state change\\n        emit ConsignmentPendingPayoutSet(consignment.id, _amount);\\n\\n    }\\n\\n    /**\\n     * @notice Set the type of Escrow Ticketer to be used for a consignment\\n     *\\n     * Default escrow ticketer is Ticketer.Lots. This only needs to be called\\n     * if overriding to Ticketer.Items for a given consignment.\\n     *\\n     * Emits a ConsignmentTicketerSet event.\\n     *\\n     * Reverts if consignment doesn't exist     *\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @param _ticketerType - the type of ticketer to use. See: {SeenTypes.Ticketer}\\n     */\\n    function setConsignmentTicketer(uint256 _consignmentId, Ticketer _ticketerType)\\n    external\\n    override\\n    onlyRole(ESCROW_AGENT)\\n    consignmentExists(_consignmentId)\\n    {\\n        MarketControllerLib.MarketControllerStorage storage mcs = MarketControllerLib.marketControllerStorage();\\n\\n        // Set the ticketer for the consignment if not different\\n        if (_ticketerType != mcs.consignmentTicketers[_consignmentId]) {\\n\\n            // Set the ticketer for the consignment\\n            mcs.consignmentTicketers[_consignmentId] = _ticketerType;\\n\\n            // Notify listeners of state change\\n            emit ConsignmentTicketerChanged(_consignmentId, _ticketerType);\\n\\n        }\\n    }\\n\\n    /**\\n     * @notice Set a custom fee percentage on a consignment (e.g. for \\\"official\\\" SEEN x Artist drops)\\n     *\\n     * Default escrow ticketer is Ticketer.Lots. This only needs to be called\\n     * if overriding to Ticketer.Items for a given consignment.\\n     *\\n     * Emits a ConsignmentFeeChanged event.\\n     *\\n     * Reverts if:\\n     * - consignment doesn't exist\\n     * - _customFeePercentageBasisPoints is more than 10000\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @param _customFeePercentageBasisPoints - the custom fee percentage basis points to use\\n     *\\n     * N.B. _customFeePercentageBasisPoints percentage value as an unsigned int by multiplying the percentage by 100:\\n     * e.g, 1.75% = 175, 100% = 10000\\n     */\\n    function setConsignmentCustomFee(uint256 _consignmentId, uint16 _customFeePercentageBasisPoints)\\n    external\\n    override\\n    onlyRole(ADMIN)\\n    {\\n\\n        MarketControllerLib.MarketControllerStorage storage mcs = MarketControllerLib.marketControllerStorage();\\n\\n        // Get the consignment into memory\\n        Consignment storage consignment = mcs.consignments[_consignmentId];\\n\\n        // Ensure the consignment exists, has not been released and that basis points don't exceed 10000\\n        // Rolled into one require due to contract size being near max\\n        require(!consignment.released && (_customFeePercentageBasisPoints <= 10000) && (_consignmentId < mcs.nextConsignment), \\\"Consignment released or nonexistent, or basisPoints over 10000\\\");\\n\\n        consignment.customFeePercentageBasisPoints = _customFeePercentageBasisPoints;\\n\\n        emit ConsignmentFeeChanged(consignment.id, _customFeePercentageBasisPoints);\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {\\n    function __ERC1155Holder_init() internal initializer {\\n        __ERC165_init_unchained();\\n        __ERC1155Receiver_init_unchained();\\n        __ERC1155Holder_init_unchained();\\n    }\\n\\n    function __ERC1155Holder_init_unchained() internal initializer {\\n    }\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\\n    function __ERC721Holder_init() internal initializer {\\n        __ERC721Holder_init_unchained();\\n    }\\n\\n    function __ERC721Holder_init_unchained() internal initializer {\\n    }\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMarketClerk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"../domain/SeenTypes.sol\\\";\\n\\n/**\\n * @title IMarketClerk\\n *\\n * @notice Manages consignments for the Seen.Haus contract suite.\\n *\\n * The ERC-165 identifier for this interface is: 0xec74481a\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ninterface IMarketClerk is IERC1155ReceiverUpgradeable, IERC721ReceiverUpgradeable {\\n\\n    /// Events\\n    event ConsignmentTicketerChanged(uint256 indexed consignmentId, SeenTypes.Ticketer indexed ticketerType);\\n    event ConsignmentFeeChanged(uint256 indexed consignmentId, uint16 customConsignmentFee);\\n    event ConsignmentPendingPayoutSet(uint256 indexed consignmentId, uint256 amount);\\n    event ConsignmentRegistered(address indexed consignor, address indexed seller, SeenTypes.Consignment consignment);\\n    event ConsignmentMarketed(address indexed consignor, address indexed seller, uint256 indexed consignmentId);\\n    event ConsignmentReleased(uint256 indexed consignmentId, uint256 amount, address releasedTo);\\n\\n    /**\\n     * @notice The nextConsignment getter\\n     */\\n    function getNextConsignment() external view returns (uint256);\\n\\n    /**\\n     * @notice The consignment getter\\n     */\\n    function getConsignment(uint256 _consignmentId) external view returns (SeenTypes.Consignment memory);\\n\\n    /**\\n     * @notice Get the remaining supply of the given consignment.\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @return uint256 - the remaining supply held by the MarketController\\n     */\\n    function getUnreleasedSupply(uint256 _consignmentId) external view returns(uint256);\\n\\n    /**\\n     * @notice Get the consignor of the given consignment\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @return  address - consigner's address\\n     */\\n    function getConsignor(uint256 _consignmentId) external view returns(address);\\n\\n    /**\\n     * @notice Registers a new consignment for sale or auction.\\n     *\\n     * Emits a ConsignmentRegistered event.\\n     *\\n     * @param _market - the market for the consignment. See {SeenTypes.Market}\\n     * @param _consignor - the address executing the consignment transaction\\n     * @param _seller - the seller of the consignment\\n     * @param _tokenAddress - the contract address issuing the NFT behind the consignment\\n     * @param _tokenId - the id of the token being consigned\\n     * @param _supply - the amount of the token being consigned\\n     *\\n     * @return Consignment - the registered consignment\\n     */\\n    function registerConsignment(\\n        SeenTypes.Market _market,\\n        address _consignor,\\n        address payable _seller,\\n        address _tokenAddress,\\n        uint256 _tokenId,\\n        uint256 _supply\\n    )\\n    external\\n    returns(SeenTypes.Consignment memory);\\n\\n    /**\\n      * @notice Update consignment to indicate it has been marketed\\n      *\\n      * Emits a ConsignmentMarketed event.\\n      *\\n      * Reverts if consignment has already been marketed.\\n      * A consignment is considered as marketed if it has a marketHandler other than Unhandled. See: {SeenTypes.MarketHandler}\\n      *\\n      * @param _consignmentId - the id of the consignment\\n      */\\n    function marketConsignment(uint256 _consignmentId, SeenTypes.MarketHandler _marketHandler) external;\\n\\n    /**\\n     * @notice Release the consigned item to a given address\\n     *\\n     * Emits a ConsignmentReleased event.\\n     *\\n     * Reverts if caller is does not have MARKET_HANDLER role.\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @param _amount - the amount of the consigned supply to release\\n     * @param _releaseTo - the address to transfer the consigned token balance to\\n     */\\n    function releaseConsignment(uint256 _consignmentId, uint256 _amount, address _releaseTo) external;\\n\\n    /**\\n     * @notice Clears the pending payout value of a consignment\\n     *\\n     * Emits a ConsignmentPayoutSet event.\\n     *\\n     * Reverts if:\\n     *  - caller is does not have MARKET_HANDLER role.\\n     *  - consignment doesn't exist\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @param _amount - the amount of that the consignment's pendingPayout must be set to\\n     */\\n    function setConsignmentPendingPayout(uint256 _consignmentId, uint256 _amount) external;\\n\\n    /**\\n     * @notice Set the type of Escrow Ticketer to be used for a consignment\\n     *\\n     * Default escrow ticketer is Ticketer.Lots. This only needs to be called\\n     * if overriding to Ticketer.Items for a given consignment.\\n     *\\n     * Emits a ConsignmentTicketerSet event.\\n     * Reverts if consignment is not registered.\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @param _ticketerType - the type of ticketer to use. See: {SeenTypes.Ticketer}\\n     */\\n    function setConsignmentTicketer(uint256 _consignmentId, SeenTypes.Ticketer _ticketerType) external;\\n\\n    /**\\n     * @notice Set a custom fee percentage on a consignment (e.g. for \\\"official\\\" SEEN x Artist drops)\\n     *\\n     * Default escrow ticketer is Ticketer.Lots. This only needs to be called\\n     * if overriding to Ticketer.Items for a given consignment.\\n     *\\n     * Emits a ConsignmentFeeChanged event.\\n     *\\n     * Reverts if consignment doesn't exist     *\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @param _customFeePercentageBasisPoints - the custom fee percentage basis points to use\\n     *\\n     * N.B. _customFeePercentageBasisPoints percentage value as an unsigned int by multiplying the percentage by 100:\\n     * e.g, 1.75% = 175, 100% = 10000\\n     */\\n    function setConsignmentCustomFee(uint256 _consignmentId, uint16 _customFeePercentageBasisPoints) external;\\n\\n}\"\r\n    },\r\n    \"contracts/market/diamond/DiamondLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IAccessControlUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\\\";\\nimport { IDiamondCut } from \\\"../../interfaces/IDiamondCut.sol\\\";\\n\\n/**\\n * @title DiamondLib\\n *\\n * @notice Diamond storage slot and supported interfaces\\n *\\n * @notice Based on Nick Mudge's gas-optimized diamond-2 reference,\\n * with modifications to support role-based access and management of\\n * supported interfaces.\\n *\\n * Reference Implementation  : https://github.com/mudgen/diamond-2-hardhat\\n * EIP-2535 Diamond Standard : https://eips.ethereum.org/EIPS/eip-2535\\n *\\n * N.B. Facet management functions from original `DiamondLib` were refactor/extracted\\n * to JewelerLib, since business facets also use this library for access control and\\n * managing supported interfaces.\\n *\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\nlibrary DiamondLib {\\n\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n\\n        // The Seen.Haus AccessController\\n        IAccessControlUpgradeable accessController;\\n\\n    }\\n\\n    /**\\n     * @notice Get the Diamond storage slot\\n     *\\n     * @return ds - Diamond storage slot cast to DiamondStorage\\n     */\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /**\\n     * @notice Add a supported interface to the Diamond\\n     *\\n     * @param _interfaceId - the interface to add\\n     */\\n    function addSupportedInterface(bytes4 _interfaceId) internal {\\n\\n        // Get the DiamondStorage struct\\n        DiamondStorage storage ds = diamondStorage();\\n\\n        // Flag the interfaces as supported\\n        ds.supportedInterfaces[_interfaceId] = true;\\n    }\\n\\n    /**\\n     * @notice Implementation of ERC-165 interface detection standard.\\n     *\\n     * @param _interfaceId - the sighash of the given interface\\n     */\\n    function supportsInterface(bytes4 _interfaceId) internal view returns (bool) {\\n\\n        // Get the DiamondStorage struct\\n        DiamondStorage storage ds = diamondStorage();\\n\\n        // Return the value\\n        return ds.supportedInterfaces[_interfaceId] || false;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/market/controller/MarketControllerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./MarketControllerLib.sol\\\";\\nimport \\\"../diamond/DiamondLib.sol\\\";\\nimport \\\"../../domain/SeenTypes.sol\\\";\\nimport \\\"../../domain/SeenConstants.sol\\\";\\n\\n/**\\n * @title MarketControllerBase\\n *\\n * @notice Provides domain and common modifiers to MarketController facets\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\nabstract contract MarketControllerBase is SeenTypes, SeenConstants {\\n\\n    /**\\n     * @dev Modifier that checks that the consignment exists\\n     *\\n     * Reverts if the consignment does not exist\\n     */\\n    modifier consignmentExists(uint256 _consignmentId) {\\n\\n        MarketControllerLib.MarketControllerStorage storage mcs = MarketControllerLib.marketControllerStorage();\\n\\n        // Make sure the consignment exists\\n        require(_consignmentId < mcs.nextConsignment, \\\"Consignment does not exist\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier that checks that the caller has a specific role.\\n     *\\n     * Reverts if caller doesn't have role.\\n     *\\n     * See: {AccessController.hasRole}\\n     */\\n    modifier onlyRole(bytes32 _role) {\\n        DiamondLib.DiamondStorage storage ds = DiamondLib.diamondStorage();\\n        require(ds.accessController.hasRole(_role, msg.sender), \\\"Caller doesn't have role\\\");\\n        _;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/market/controller/MarketControllerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../domain/SeenTypes.sol\\\";\\n\\n/**\\n * @title MarketControllerLib\\n *\\n * @dev Provides access to the the MarketController Storage and Intializer slots for MarketController facets\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\nlibrary MarketControllerLib {\\n\\n    bytes32 constant MARKET_CONTROLLER_STORAGE_POSITION = keccak256(\\\"seen.haus.market.controller.storage\\\");\\n    bytes32 constant MARKET_CONTROLLER_INITIALIZERS_POSITION = keccak256(\\\"seen.haus.market.controller.initializers\\\");\\n\\n    struct MarketControllerStorage {\\n\\n        // the address of the Seen.Haus NFT contract\\n        address nft;\\n\\n        // the address of the xSEEN ERC-20 Seen.Haus staking contract\\n        address payable staking;\\n\\n        // the address of the Seen.Haus multi-sig wallet\\n        address payable multisig;\\n\\n        // address of the Seen.Haus lots-based escrow ticketing contract\\n        address lotsTicketer;\\n\\n        // address of the Seen.Haus items-based escrow ticketing contract\\n        address itemsTicketer;\\n\\n        // the default escrow ticketer type to use for physical consignments unless overridden with setConsignmentTicketer\\n        SeenTypes.Ticketer defaultTicketerType;\\n\\n        // the minimum amount of xSEEN ERC-20 a caller must hold to participate in VIP events\\n        uint256 vipStakerAmount;\\n\\n        // the percentage that will be taken as a fee from the net of a Seen.Haus sale or auction\\n        uint16 primaryFeePercentage;         // 1.75% = 175, 100% = 10000\\n\\n        // the percentage that will be taken as a fee from the net of a Seen.Haus sale or auction (after royalties)\\n        uint16 secondaryFeePercentage;         // 1.75% = 175, 100% = 10000\\n\\n        // the maximum percentage of a Seen.Haus sale or auction that will be paid as a royalty\\n        uint16 maxRoyaltyPercentage;  // 1.75% = 175, 100% = 10000\\n\\n        // the minimum percentage a Seen.Haus auction bid must be above the previous bid to prevail\\n        uint16 outBidPercentage;      // 1.75% = 175, 100% = 10000\\n\\n        // next consignment id\\n        uint256 nextConsignment;\\n\\n        // whether or not external NFTs can be sold via secondary market\\n        bool allowExternalTokensOnSecondary;\\n\\n        // consignment id => consignment\\n        mapping(uint256 => SeenTypes.Consignment) consignments;\\n\\n        // consignmentId to consignor address\\n        mapping(uint256 => address) consignors;\\n\\n        // consignment id => ticketer type\\n        mapping(uint256 => SeenTypes.Ticketer) consignmentTicketers;\\n\\n        // escrow agent address => feeBasisPoints\\n        mapping(address => uint16) escrowAgentToFeeBasisPoints;\\n\\n    }\\n\\n    struct MarketControllerInitializers {\\n\\n        // MarketConfigFacet initialization state\\n        bool configFacet;\\n\\n        // MarketConfigFacet initialization state\\n        bool configAdditionalFacet;\\n\\n        // MarketClerkFacet initialization state\\n        bool clerkFacet;\\n\\n    }\\n\\n    function marketControllerStorage() internal pure returns (MarketControllerStorage storage mcs) {\\n        bytes32 position = MARKET_CONTROLLER_STORAGE_POSITION;\\n        assembly {\\n            mcs.slot := position\\n        }\\n    }\\n\\n    function marketControllerInitializers() internal pure returns (MarketControllerInitializers storage mci) {\\n        bytes32 position = MARKET_CONTROLLER_INITIALIZERS_POSITION;\\n        assembly {\\n            mci.slot := position\\n        }\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\\n    function __ERC1155Receiver_init() internal initializer {\\n        __ERC165_init_unchained();\\n        __ERC1155Receiver_init_unchained();\\n    }\\n\\n    function __ERC1155Receiver_init_unchained() internal initializer {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal initializer {\\n        __ERC165_init_unchained();\\n    }\\n\\n    function __ERC165_init_unchained() internal initializer {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/domain/SeenTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title SeenTypes\\n *\\n * @notice Enums and structs used by the Seen.Haus contract ecosystem.\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ncontract SeenTypes {\\n\\n    enum Market {\\n        Primary,\\n        Secondary\\n    }\\n\\n    enum MarketHandler {\\n        Unhandled,\\n        Auction,\\n        Sale\\n    }\\n\\n    enum Clock {\\n        Live,\\n        Trigger\\n    }\\n\\n    enum Audience {\\n        Open,\\n        Staker,\\n        VipStaker\\n    }\\n\\n    enum Outcome {\\n        Pending,\\n        Closed,\\n        Canceled\\n    }\\n\\n    enum State {\\n        Pending,\\n        Running,\\n        Ended\\n    }\\n\\n    enum Ticketer {\\n        Default,\\n        Lots,\\n        Items\\n    }\\n\\n    struct Token {\\n        address payable creator;\\n        uint16 royaltyPercentage;\\n        bool isPhysical;\\n        uint256 id;\\n        uint256 supply;\\n        string uri;\\n    }\\n\\n    struct Consignment {\\n        Market market;\\n        MarketHandler marketHandler;\\n        address payable seller;\\n        address tokenAddress;\\n        uint256 tokenId;\\n        uint256 supply;\\n        uint256 id;\\n        bool multiToken;\\n        bool released;\\n        uint256 releasedSupply;\\n        uint16 customFeePercentageBasisPoints;\\n        uint256 pendingPayout;\\n    }\\n\\n    struct Auction {\\n        address payable buyer;\\n        uint256 consignmentId;\\n        uint256 start;\\n        uint256 duration;\\n        uint256 reserve;\\n        uint256 bid;\\n        Clock clock;\\n        State state;\\n        Outcome outcome;\\n    }\\n\\n    struct Sale {\\n        uint256 consignmentId;\\n        uint256 start;\\n        uint256 price;\\n        uint256 perTxCap;\\n        State state;\\n        Outcome outcome;\\n    }\\n\\n    struct EscrowTicket {\\n        uint256 amount;\\n        uint256 consignmentId;\\n        uint256 id;\\n        string itemURI;\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IDiamondCut\\n *\\n * @notice Diamond Facet management\\n *\\n * Reference Implementation  : https://github.com/mudgen/diamond-2-hardhat\\n * EIP-2535 Diamond Standard : https://eips.ethereum.org/EIPS/eip-2535\\n *\\n * The ERC-165 identifier for this interface is: 0x1f931c1c\\n *\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n */\\ninterface IDiamondCut {\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    enum FacetCutAction {Add, Replace, Remove}\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /**\\n     * @notice Add/replace/remove any number of functions and\\n     * optionally execute a function with delegatecall\\n     *\\n     * _calldata is executed with delegatecall on _init\\n     *\\n     * @param _diamondCut Contains the facet addresses and function selectors\\n     * @param _init The address of the contract or facet to execute _calldata\\n     * @param _calldata A function call, including function selector and arguments\\n     */\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/domain/SeenConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title SeenConstants\\n *\\n * @notice Constants used by the Seen.Haus contract ecosystem.\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ncontract SeenConstants {\\n\\n    // Endpoint will serve dynamic metadata composed of ticket and ticketed item's info\\n    string internal constant ESCROW_TICKET_URI = \\\"https://api.seen.haus/ticket/metadata/\\\";\\n\\n    // Access Control Roles\\n    bytes32 internal constant ADMIN = keccak256(\\\"ADMIN\\\");                   // Deployer and any other admins as needed\\n    bytes32 internal constant SELLER = keccak256(\\\"SELLER\\\");                 // Approved sellers amd Seen.Haus reps\\n    bytes32 internal constant MINTER = keccak256(\\\"MINTER\\\");                 // Approved artists and Seen.Haus reps\\n    bytes32 internal constant ESCROW_AGENT = keccak256(\\\"ESCROW_AGENT\\\");     // Seen.Haus Physical Item Escrow Agent\\n    bytes32 internal constant MARKET_HANDLER = keccak256(\\\"MARKET_HANDLER\\\"); // Market Handler contracts\\n    bytes32 internal constant UPGRADER = keccak256(\\\"UPGRADER\\\");             // Performs contract upgrades\\n    bytes32 internal constant MULTISIG = keccak256(\\\"MULTISIG\\\");             // Admin role of MARKET_HANDLER & UPGRADER\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"consignmentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"customConsignmentFee\",\"type\":\"uint16\"}],\"name\":\"ConsignmentFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"consignor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"consignmentId\",\"type\":\"uint256\"}],\"name\":\"ConsignmentMarketed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"consignmentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ConsignmentPendingPayoutSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"consignor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum SeenTypes.Market\",\"name\":\"market\",\"type\":\"uint8\"},{\"internalType\":\"enum SeenTypes.MarketHandler\",\"name\":\"marketHandler\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"multiToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"released\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"releasedSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"customFeePercentageBasisPoints\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"pendingPayout\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct SeenTypes.Consignment\",\"name\":\"consignment\",\"type\":\"tuple\"}],\"name\":\"ConsignmentRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"consignmentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"releasedTo\",\"type\":\"address\"}],\"name\":\"ConsignmentReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"consignmentId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum SeenTypes.Ticketer\",\"name\":\"ticketerType\",\"type\":\"uint8\"}],\"name\":\"ConsignmentTicketerChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_consignmentId\",\"type\":\"uint256\"}],\"name\":\"getConsignment\",\"outputs\":[{\"components\":[{\"internalType\":\"enum SeenTypes.Market\",\"name\":\"market\",\"type\":\"uint8\"},{\"internalType\":\"enum SeenTypes.MarketHandler\",\"name\":\"marketHandler\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"multiToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"released\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"releasedSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"customFeePercentageBasisPoints\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"pendingPayout\",\"type\":\"uint256\"}],\"internalType\":\"struct SeenTypes.Consignment\",\"name\":\"consignment\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_consignmentId\",\"type\":\"uint256\"}],\"name\":\"getConsignor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextConsignment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_consignmentId\",\"type\":\"uint256\"}],\"name\":\"getUnreleasedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_consignmentId\",\"type\":\"uint256\"},{\"internalType\":\"enum SeenTypes.MarketHandler\",\"name\":\"_marketHandler\",\"type\":\"uint8\"}],\"name\":\"marketConsignment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum SeenTypes.Market\",\"name\":\"_market\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_consignor\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"}],\"name\":\"registerConsignment\",\"outputs\":[{\"components\":[{\"internalType\":\"enum SeenTypes.Market\",\"name\":\"market\",\"type\":\"uint8\"},{\"internalType\":\"enum SeenTypes.MarketHandler\",\"name\":\"marketHandler\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"multiToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"released\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"releasedSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"customFeePercentageBasisPoints\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"pendingPayout\",\"type\":\"uint256\"}],\"internalType\":\"struct SeenTypes.Consignment\",\"name\":\"consignment\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_consignmentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_releaseTo\",\"type\":\"address\"}],\"name\":\"releaseConsignment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_consignmentId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_customFeePercentageBasisPoints\",\"type\":\"uint16\"}],\"name\":\"setConsignmentCustomFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_consignmentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setConsignmentPendingPayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_consignmentId\",\"type\":\"uint256\"},{\"internalType\":\"enum SeenTypes.Ticketer\",\"name\":\"_ticketerType\",\"type\":\"uint8\"}],\"name\":\"setConsignmentTicketer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MarketClerkFacet", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}