{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: node_modules\\openzeppelin-solidity\\contracts\\utils\\Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\access\\Ownable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts\\impl\\impl2\\utils\\ReentrancyGuard.sol\r\n\r\n\r\n\r\npragma solidity 0.8.11;\r\n\r\n/// @notice Gas optimized reentrancy protection for smart contracts.\r\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\r\nabstract contract ReentrancyGuard {\r\n    uint256 private reentrancyStatus = 1;\r\n\r\n    modifier nonReentrant() {\r\n        require(reentrancyStatus == 1, \"REENTRANCY\");\r\n\r\n        reentrancyStatus = 2;\r\n\r\n        _;\r\n\r\n        reentrancyStatus = 1;\r\n    }\r\n}\r\n\r\n// File: contracts\\impl\\impl2\\markets\\MarketRegistry.sol\r\n\r\n\r\n\r\npragma solidity 0.8.11;\r\ncontract MarketRegistry is Ownable {\r\n\r\n    struct TradeDetails {\r\n        uint256 marketId;\r\n        uint256 value;\r\n        bytes tradeData;\r\n    }\r\n\r\n    struct Market {\r\n        address proxy;\r\n        bool isLib;\r\n        bool isActive;\r\n    }\r\n\r\n    Market[] public markets;\r\n\r\n    constructor(address[] memory proxies, bool[] memory isLibs) {\r\n        for (uint256 i = 0; i < proxies.length; i++) {\r\n            markets.push(Market(proxies[i], isLibs[i], true));\r\n        }\r\n    }\r\n\r\n    function addMarket(address proxy, bool isLib) external onlyOwner {\r\n        markets.push(Market(proxy, isLib, true));\r\n    }\r\n\r\n    function setMarketStatus(uint256 marketId, bool newStatus) external onlyOwner {\r\n        Market storage market = markets[marketId];\r\n        market.isActive = newStatus;\r\n    }\r\n\r\n    function setMarketProxy(uint256 marketId, address newProxy, bool isLib) external onlyOwner {\r\n        Market storage market = markets[marketId];\r\n        market.proxy = newProxy;\r\n        market.isLib = isLib;\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\punks\\ICryptoPunks.sol\r\n\r\n\r\n\r\npragma solidity 0.8.11;\r\n\r\ninterface ICryptoPunks {\r\n    function punkIndexToAddress(uint index) external view returns(address owner);\r\n    function offerPunkForSaleToAddress(uint punkIndex, uint minSalePriceInWei, address toAddress) external;\r\n    function buyPunk(uint punkIndex) external payable;\r\n    function transferPunk(address to, uint punkIndex) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\punks\\IWrappedPunk.sol\r\n\r\n\r\n\r\npragma solidity 0.8.11;\r\n\r\ninterface IWrappedPunk {\r\n    /**\r\n     * @dev Mints a wrapped punk\r\n     */\r\n    function mint(uint256 punkIndex) external;\r\n\r\n    /**\r\n     * @dev Burns a specific wrapped punk\r\n     */\r\n    function burn(uint256 punkIndex) external;\r\n    \r\n    /**\r\n     * @dev Registers proxy\r\n     */\r\n    function registerProxy() external;\r\n\r\n    /**\r\n     * @dev Gets proxy address\r\n     */\r\n    function proxyInfo(address user) external view returns (address);\r\n}\r\n\r\n// File: contracts\\interfaces\\mooncats\\IMoonCatsRescue.sol\r\n\r\n\r\n\r\npragma solidity 0.8.11;\r\n\r\ninterface IMoonCatsRescue {\r\n    function acceptAdoptionOffer(bytes5 catId) payable external;\r\n    function makeAdoptionOfferToAddress(bytes5 catId, uint price, address to) external;\r\n    function giveCat(bytes5 catId, address to) external;\r\n    function catOwners(bytes5 catId) external view returns(address);\r\n    function rescueOrder(uint256 rescueIndex) external view returns(bytes5 catId);\r\n}\r\n\r\n// File: contracts\\impl\\impl2\\SpecialTransferHelper.sol\r\n\r\n\r\n\r\npragma solidity 0.8.11;\r\ncontract SpecialTransferHelper is Context {\r\n\r\n    struct ERC721Details {\r\n        address tokenAddr;\r\n        address[] to;\r\n        uint256[] ids;\r\n    }\r\n\r\n    function _uintToBytes5(uint256 id)\r\n        internal\r\n        pure\r\n        returns (bytes5 slicedDataBytes5)\r\n    {\r\n        bytes memory _bytes = new bytes(32);\r\n        assembly {\r\n            mstore(add(_bytes, 32), id)\r\n        }\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // The first word of the slice result is potentially a partial\r\n            // word read from the original array. To read it, we calculate\r\n            // the length of that partial word and start copying that many\r\n            // bytes into the array. The first word we copy will start with\r\n            // data we don't care about, but the last `lengthmod` bytes will\r\n            // land at the beginning of the contents of the new array. When\r\n            // we're done copying, we overwrite the full first word with\r\n            // the actual length of the slice.\r\n            let lengthmod := and(5, 31)\r\n\r\n            // The multiplication in the next line is necessary\r\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n            // the following copy loop was copying the origin's length\r\n            // and then ending prematurely not copying everything it should.\r\n            let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n            let end := add(mc, 5)\r\n\r\n            for {\r\n                // The multiplication in the next line has the same exact purpose\r\n                // as the one above.\r\n                let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), 27)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            mstore(tempBytes, 5)\r\n\r\n            //update free-memory pointer\r\n            //allocating the array padded to 32 bytes like the compiler does now\r\n            mstore(0x40, and(add(mc, 31), not(31)))\r\n        }\r\n\r\n        assembly {\r\n            slicedDataBytes5 := mload(add(tempBytes, 32))\r\n        }\r\n    }\r\n\r\n\r\n    function _acceptMoonCat(ERC721Details memory erc721Details) internal {\r\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {\r\n            bytes5 catId = _uintToBytes5(erc721Details.ids[i]);\r\n            address owner = IMoonCatsRescue(erc721Details.tokenAddr).catOwners(catId);\r\n            require(owner == _msgSender(), \"_acceptMoonCat: invalid mooncat owner\");\r\n            IMoonCatsRescue(erc721Details.tokenAddr).acceptAdoptionOffer(catId);\r\n        }\r\n    }\r\n\r\n    function _transferMoonCat(ERC721Details memory erc721Details) internal {\r\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {\r\n            IMoonCatsRescue(erc721Details.tokenAddr).giveCat(_uintToBytes5(erc721Details.ids[i]), erc721Details.to[i]);\r\n        }\r\n    }\r\n\r\n    function _acceptCryptoPunk(ERC721Details memory erc721Details) internal {\r\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {    \r\n            address owner = ICryptoPunks(erc721Details.tokenAddr).punkIndexToAddress(erc721Details.ids[i]);\r\n            require(owner == _msgSender(), \"_acceptCryptoPunk: invalid punk owner\");\r\n            ICryptoPunks(erc721Details.tokenAddr).buyPunk(erc721Details.ids[i]);\r\n        }\r\n    }\r\n\r\n    function _transferCryptoPunk(ERC721Details memory erc721Details) internal {\r\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {\r\n            ICryptoPunks(erc721Details.tokenAddr).transferPunk(erc721Details.to[i], erc721Details.ids[i]);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\markets\\tokens\\IERC20.sol\r\n\r\n\r\n\r\npragma solidity 0.8.11;\r\n\r\ninterface IERC20 {\r\n    /**\r\n        * @dev Returns the amount of tokens owned by `account`.\r\n        */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n        * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n        *\r\n        * Returns a boolean value indicating whether the operation succeeded.\r\n        *\r\n        * Emits a {Transfer} event.\r\n        */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n}\r\n\r\n// File: contracts\\interfaces\\markets\\tokens\\IERC721.sol\r\n\r\n\r\n\r\npragma solidity 0.8.11;\r\n\r\ninterface IERC721 {\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;\r\n    \r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n    \r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n}\r\n\r\n// File: contracts\\interfaces\\markets\\tokens\\IERC1155.sol\r\n\r\n\r\n\r\npragma solidity 0.8.11;\r\ninterface IERC1155 {\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\r\n}\r\n\r\n// File: contracts\\impl\\impl2\\MintverseSwap.sol\r\n\r\n\r\n\r\npragma solidity 0.8.11;\r\ncontract MintverseSwap is SpecialTransferHelper, Ownable, ReentrancyGuard {\r\n\r\n    struct OpenseaTrades {\r\n        uint256 value;\r\n        bytes tradeData;\r\n    }\r\n\r\n    struct ERC20Details {\r\n        address[] tokenAddrs;\r\n        uint256[] amounts;\r\n    }\r\n\r\n    struct ERC1155Details {\r\n        address tokenAddr;\r\n        uint256[] ids;\r\n        uint256[] amounts;\r\n    }\r\n\r\n    struct ConverstionDetails {\r\n        bytes conversionData;\r\n    }\r\n\r\n    struct AffiliateDetails {\r\n        address affiliate;\r\n        bool isActive;\r\n    }\r\n\r\n    struct SponsoredMarket {\r\n        uint256 marketId;\r\n        bool isActive;\r\n    }\r\n\r\n    address public constant GOV = 0x7D0F2119A3de8fb35Fc6932C414478D67De620D2;\r\n    address public guardian;\r\n    address public converter;\r\n    address public punkProxy;\r\n    uint256 public baseFees;\r\n    bool public openForTrades;\r\n    bool public openForFreeTrades;\r\n    MarketRegistry public marketRegistry;\r\n    AffiliateDetails[] public affiliates;\r\n    SponsoredMarket[] public sponsoredMarkets;\r\n\r\n    modifier isOpenForTrades() {\r\n        require(openForTrades, \"trades not allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier isOpenForFreeTrades() {\r\n        require(openForFreeTrades, \"free trades not allowed\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _marketRegistry, address _converter, address _guardian) {\r\n        marketRegistry = MarketRegistry(_marketRegistry);\r\n        converter = _converter;\r\n        guardian = _guardian;\r\n        baseFees = 0;\r\n        openForTrades = true;\r\n        openForFreeTrades = true;\r\n        affiliates.push(AffiliateDetails(GOV, true));\r\n    }\r\n\r\n    function setUp() external onlyOwner {\r\n        // Create CryptoPunk Proxy\r\n        IWrappedPunk(0xb7F7F6C52F2e2fdb1963Eab30438024864c313F6).registerProxy();\r\n        punkProxy = IWrappedPunk(0xb7F7F6C52F2e2fdb1963Eab30438024864c313F6).proxyInfo(address(this));\r\n\r\n        // approve wrapped mooncats rescue to Acclimated\u200bMoonCats contract\r\n        IERC721(0x7C40c393DC0f283F318791d746d894DdD3693572).setApprovalForAll(0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69, true);\r\n    }\r\n\r\n    // @audit This function is used to approve specific tokens to specific market contracts with high volume.\r\n    // This is done in very rare cases for the gas optimization purposes. \r\n    function setOneTimeApproval(IERC20 token, address operator, uint256 amount) external onlyOwner {\r\n        token.approve(operator, amount);\r\n    }\r\n\r\n    function updateGuardian(address _guardian) external onlyOwner {\r\n        guardian = _guardian;\r\n    }\r\n\r\n    function addAffiliate(address _affiliate) external onlyOwner {\r\n        affiliates.push(AffiliateDetails(_affiliate, true));\r\n    }\r\n\r\n    function updateAffiliate(uint256 _affiliateIndex, address _affiliate, bool _IsActive) external onlyOwner {\r\n        affiliates[_affiliateIndex] = AffiliateDetails(_affiliate, _IsActive);\r\n    }\r\n\r\n    function addSponsoredMarket(uint256 _marketId) external onlyOwner {\r\n        sponsoredMarkets.push(SponsoredMarket(_marketId, true));\r\n    }\r\n\r\n    function updateSponsoredMarket(uint256 _marketIndex, uint256 _marketId, bool _isActive) external onlyOwner {\r\n        sponsoredMarkets[_marketIndex] = SponsoredMarket(_marketId, _isActive);\r\n    }\r\n\r\n    function setBaseFees(uint256 _baseFees) external onlyOwner {\r\n        baseFees = _baseFees;\r\n    }\r\n\r\n    function setOpenForTrades(bool _openForTrades) external onlyOwner {\r\n        openForTrades = _openForTrades;\r\n    }\r\n\r\n    function setOpenForFreeTrades(bool _openForFreeTrades) external onlyOwner {\r\n        openForFreeTrades = _openForFreeTrades;\r\n    }\r\n\r\n    // @audit we will setup a system that will monitor the contract for any leftover\r\n    // assets. In case any asset is leftover, the system should be able to trigger this\r\n    // function to close all the trades until the leftover assets are rescued.\r\n    function closeAllTrades() external {\r\n        require(_msgSender() == guardian);\r\n        openForTrades = false;\r\n        openForFreeTrades = false;\r\n    }\r\n\r\n    function setConverter(address _converter) external onlyOwner {\r\n        converter = _converter;\r\n    }\r\n\r\n    function setMarketRegistry(MarketRegistry _marketRegistry) external onlyOwner {\r\n        marketRegistry = _marketRegistry;\r\n    }\r\n\r\n    function _transferEth(address _to, uint256 _amount) internal {\r\n        bool callStatus;\r\n        assembly {\r\n            // Transfer the ETH and store if it succeeded or not.\r\n            callStatus := call(gas(), _to, _amount, 0, 0, 0, 0)\r\n        }\r\n        require(callStatus, \"_transferEth: Eth transfer failed\");\r\n    }\r\n\r\n    function _collectFee(uint256[2] memory feeDetails) internal {\r\n        require(feeDetails[1] >= baseFees, \"Insufficient fee\");\r\n        if (feeDetails[1] > 0) {\r\n            AffiliateDetails memory affiliateDetails = affiliates[feeDetails[0]];\r\n            affiliateDetails.isActive\r\n                ? _transferEth(affiliateDetails.affiliate, feeDetails[1])\r\n                : _transferEth(GOV, feeDetails[1]);\r\n        }\r\n    }\r\n\r\n    function _checkCallResult(bool _success) internal pure {\r\n        if (!_success) {\r\n            // Copy revert reason from call\r\n            assembly {\r\n                returndatacopy(0, 0, returndatasize())\r\n                revert(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    function _transferFromHelper(\r\n        ERC20Details memory erc20Details,\r\n        SpecialTransferHelper.ERC721Details[] memory erc721Details,\r\n        ERC1155Details[] memory erc1155Details\r\n    ) internal {\r\n        // transfer ERC20 tokens from the sender to this contract\r\n        for (uint256 i = 0; i < erc20Details.tokenAddrs.length; i++) {\r\n            erc20Details.tokenAddrs[i].call(abi.encodeWithSelector(0x23b872dd, msg.sender, address(this), erc20Details.amounts[i]));\r\n        }\r\n\r\n        // transfer ERC721 tokens from the sender to this contract\r\n        for (uint256 i = 0; i < erc721Details.length; i++) {\r\n            // accept CryptoPunks\r\n            if (erc721Details[i].tokenAddr == 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB) {\r\n                _acceptCryptoPunk(erc721Details[i]);\r\n            }\r\n            // accept Mooncat\r\n            else if (erc721Details[i].tokenAddr == 0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6) {\r\n                _acceptMoonCat(erc721Details[i]);\r\n            }\r\n            // default\r\n            else {\r\n                for (uint256 j = 0; j < erc721Details[i].ids.length; j++) {\r\n                    IERC721(erc721Details[i].tokenAddr).transferFrom(\r\n                        _msgSender(),\r\n                        address(this),\r\n                        erc721Details[i].ids[j]\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        // transfer ERC1155 tokens from the sender to this contract\r\n        for (uint256 i = 0; i < erc1155Details.length; i++) {\r\n            IERC1155(erc1155Details[i].tokenAddr).safeBatchTransferFrom(\r\n                _msgSender(),\r\n                address(this),\r\n                erc1155Details[i].ids,\r\n                erc1155Details[i].amounts,\r\n                \"\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function _conversionHelper(\r\n        ConverstionDetails[] memory _converstionDetails\r\n    ) internal {\r\n        for (uint256 i = 0; i < _converstionDetails.length; i++) {\r\n            // convert to desired asset\r\n            (bool success, ) = converter.delegatecall(_converstionDetails[i].conversionData);\r\n            // check if the call passed successfully\r\n            _checkCallResult(success);\r\n        }\r\n    }\r\n\r\n    function _trade(\r\n        MarketRegistry.TradeDetails[] memory _tradeDetails\r\n    ) internal {\r\n        for (uint256 i = 0; i < _tradeDetails.length; i++) {\r\n            // get market details\r\n            (address _proxy, bool _isLib, bool _isActive) = marketRegistry.markets(_tradeDetails[i].marketId);\r\n            // market should be active\r\n            require(_isActive, \"_trade: InActive Market\");\r\n            // execute trade\r\n            if (_proxy == 0x7Be8076f4EA4A4AD08075C2508e481d6C946D12b || _proxy == 0x7f268357A8c2552623316e2562D90e642bB538E5) {\r\n                _proxy.call{value:_tradeDetails[i].value}(_tradeDetails[i].tradeData);\r\n            } else {\r\n                (bool success, ) = _isLib\r\n                    ? _proxy.delegatecall(_tradeDetails[i].tradeData)\r\n                    : _proxy.call{value:_tradeDetails[i].value}(_tradeDetails[i].tradeData);\r\n                // check if the call passed successfully\r\n                _checkCallResult(success);\r\n            }\r\n        }\r\n    }\r\n\r\n    // function _tradeSponsored(\r\n    //     MarketRegistry.TradeDetails[] memory _tradeDetails,\r\n    //     uint256 sponsoredMarketId\r\n    // ) internal returns (bool isSponsored) {\r\n    //     for (uint256 i = 0; i < _tradeDetails.length; i++) {\r\n    //         // check if the trade is for the sponsored market\r\n    //         if (_tradeDetails[i].marketId == sponsoredMarketId) {\r\n    //             isSponsored = true;\r\n    //         }\r\n    //         // get market details\r\n    //         (address _proxy, bool _isLib, bool _isActive) = marketRegistry.markets(_tradeDetails[i].marketId);\r\n    //         // market should be active\r\n    //         require(_isActive, \"_trade: InActive Market\");\r\n    //         // execute trade\r\n    //         if (_proxy == 0x7Be8076f4EA4A4AD08075C2508e481d6C946D12b) {\r\n    //             _proxy.call{value:_tradeDetails[i].value}(_tradeDetails[i].tradeData);\r\n    //         } else {\r\n    //             (bool success, ) = _isLib\r\n    //                 ? _proxy.delegatecall(_tradeDetails[i].tradeData)\r\n    //                 : _proxy.call{value:_tradeDetails[i].value}(_tradeDetails[i].tradeData);\r\n    //             // check if the call passed successfully\r\n    //             _checkCallResult(success);\r\n    //         }\r\n    //     }\r\n    // }\r\n\r\n    function _returnDust(address[] memory _tokens) internal {\r\n        // return remaining ETH (if any)\r\n        assembly {\r\n            if gt(selfbalance(), 0) {\r\n                let callStatus := call(\r\n                    gas(),\r\n                    caller(),\r\n                    selfbalance(),\r\n                    0,\r\n                    0,\r\n                    0,\r\n                    0\r\n                )\r\n            }\r\n        }\r\n        // return remaining tokens (if any)\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            if (IERC20(_tokens[i]).balanceOf(address(this)) > 0) {\r\n                _tokens[i].call(abi.encodeWithSelector(0xa9059cbb, msg.sender, IERC20(_tokens[i]).balanceOf(address(this))));\r\n            }\r\n        }\r\n    }\r\n\r\n    function batchBuyFromOpenSea(\r\n        OpenseaTrades[] memory openseaTrades\r\n    ) payable external nonReentrant {\r\n        // execute trades\r\n        for (uint256 i = 0; i < openseaTrades.length; i++) {\r\n            // execute trade\r\n            address(0x7Be8076f4EA4A4AD08075C2508e481d6C946D12b).call{value:openseaTrades[i].value}(openseaTrades[i].tradeData);\r\n        }\r\n\r\n        // return remaining ETH (if any)\r\n        assembly {\r\n            if gt(selfbalance(), 0) {\r\n                let callStatus := call(\r\n                    gas(),\r\n                    caller(),\r\n                    selfbalance(),\r\n                    0,\r\n                    0,\r\n                    0,\r\n                    0\r\n                )\r\n            }\r\n        }\r\n    }\r\n    \r\n    function batchBuyWithETH(\r\n        MarketRegistry.TradeDetails[] memory tradeDetails\r\n    ) payable external nonReentrant {\r\n        // execute trades\r\n        _trade(tradeDetails);\r\n\r\n        // return remaining ETH (if any)\r\n        assembly {\r\n            if gt(selfbalance(), 0) {\r\n                let callStatus := call(\r\n                    gas(),\r\n                    caller(),\r\n                    selfbalance(),\r\n                    0,\r\n                    0,\r\n                    0,\r\n                    0\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    function batchBuyWithERC20s(\r\n        ERC20Details memory erc20Details,\r\n        MarketRegistry.TradeDetails[] memory tradeDetails,\r\n        ConverstionDetails[] memory converstionDetails,\r\n        address[] memory dustTokens\r\n    ) payable external nonReentrant {\r\n        // transfer ERC20 tokens from the sender to this contract\r\n        for (uint256 i = 0; i < erc20Details.tokenAddrs.length; i++) {\r\n            erc20Details.tokenAddrs[i].call(abi.encodeWithSelector(0x23b872dd, msg.sender, address(this), erc20Details.amounts[i]));\r\n        }\r\n\r\n        // Convert any assets if needed\r\n        _conversionHelper(converstionDetails);\r\n\r\n        // execute trades\r\n        _trade(tradeDetails);\r\n\r\n        // return dust tokens (if any)\r\n        _returnDust(dustTokens);\r\n    }\r\n\r\n    // swaps any combination of ERC-20/721/1155\r\n    // User needs to approve assets before invoking swap\r\n    // WARNING: DO NOT SEND TOKENS TO THIS FUNCTION DIRECTLY!!!\r\n    function multiAssetSwap(\r\n        ERC20Details memory erc20Details,\r\n        SpecialTransferHelper.ERC721Details[] memory erc721Details,\r\n        ERC1155Details[] memory erc1155Details,\r\n        ConverstionDetails[] memory converstionDetails,\r\n        MarketRegistry.TradeDetails[] memory tradeDetails,\r\n        address[] memory dustTokens,\r\n        uint256[2] memory feeDetails    // [affiliateIndex, ETH fee in Wei]\r\n    ) payable external isOpenForTrades nonReentrant {\r\n        // collect fees\r\n        _collectFee(feeDetails);\r\n\r\n        // transfer all tokens\r\n        _transferFromHelper(\r\n            erc20Details,\r\n            erc721Details,\r\n            erc1155Details\r\n        );\r\n\r\n        // Convert any assets if needed\r\n        _conversionHelper(converstionDetails);\r\n\r\n        // execute trades\r\n        _trade(tradeDetails);\r\n\r\n        // return dust tokens (if any)\r\n        _returnDust(dustTokens);\r\n    }\r\n\r\n    // Utility function that is used for free swaps for sponsored markets\r\n    // WARNING: DO NOT SEND TOKENS TO THIS FUNCTION DIRECTLY!!! \r\n    // function multiAssetSwapWithoutFee(\r\n    //     ERC20Details memory erc20Details,\r\n    //     SpecialTransferHelper.ERC721Details[] memory erc721Details,\r\n    //     ERC1155Details[] memory erc1155Details,\r\n    //     ConverstionDetails[] memory converstionDetails,\r\n    //     MarketRegistry.TradeDetails[] memory tradeDetails,\r\n    //     address[] memory dustTokens,\r\n    //     uint256 sponsoredMarketIndex\r\n    // ) payable external isOpenForFreeTrades nonReentrant {\r\n    //     // fetch the marketId of the sponsored market\r\n    //     SponsoredMarket memory sponsoredMarket = sponsoredMarkets[sponsoredMarketIndex];\r\n    //     // check if the market is active\r\n    //     require(sponsoredMarket.isActive, \"multiAssetSwapWithoutFee: InActive sponsored market\");\r\n// \r\n    //     // transfer all tokens\r\n    //     _transferFromHelper(\r\n    //         erc20Details,\r\n    //         erc721Details,\r\n    //         erc1155Details\r\n    //     );\r\n// \r\n    //     // Convert any assets if needed\r\n    //     _conversionHelper(converstionDetails);\r\n// \r\n    //     // execute trades\r\n    //     bool isSponsored = _tradeSponsored(tradeDetails, sponsoredMarket.marketId);\r\n// \r\n    //     // check if the trades include the sponsored market\r\n    //     require(isSponsored, \"multiAssetSwapWithoutFee: trades do not include sponsored market\");\r\n// \r\n    //     // return dust tokens (if any)\r\n    //     _returnDust(dustTokens);\r\n    // }\r\n\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes calldata\r\n    ) public virtual returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] calldata,\r\n        uint256[] calldata,\r\n        bytes calldata\r\n    ) public virtual returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external virtual returns (bytes4) {\r\n        return 0x150b7a02;\r\n    }\r\n\r\n    // Used by ERC721BasicToken.sol\r\n    function onERC721Received(\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external virtual returns (bytes4) {\r\n        return 0xf0b9e5ba;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        external\r\n        virtual\r\n        view\r\n        returns (bool)\r\n    {\r\n        return interfaceId == this.supportsInterface.selector;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    // Emergency function: In case any ETH get stuck in the contract unintentionally\r\n    // Only owner can retrieve the asset balance to a recipient address\r\n    function rescueETH(address recipient) onlyOwner external {\r\n        _transferEth(recipient, address(this).balance);\r\n    }\r\n\r\n    // Emergency function: In case any ERC20 tokens get stuck in the contract unintentionally\r\n    // Only owner can retrieve the asset balance to a recipient address\r\n    function rescueERC20(address asset, address recipient) onlyOwner external { \r\n        asset.call(abi.encodeWithSelector(0xa9059cbb, recipient, IERC20(asset).balanceOf(address(this))));\r\n    }\r\n\r\n    // Emergency function: In case any ERC721 tokens get stuck in the contract unintentionally\r\n    // Only owner can retrieve the asset balance to a recipient address\r\n    function rescueERC721(address asset, uint256[] calldata ids, address recipient) onlyOwner external {\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            IERC721(asset).transferFrom(address(this), recipient, ids[i]);\r\n        }\r\n    }\r\n\r\n    // Emergency function: In case any ERC1155 tokens get stuck in the contract unintentionally\r\n    // Only owner can retrieve the asset balance to a recipient address\r\n    function rescueERC1155(address asset, uint256[] calldata ids, uint256[] calldata amounts, address recipient) onlyOwner external {\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            IERC1155(asset).safeTransferFrom(address(this), recipient, ids[i], amounts[i], \"\");\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_converter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GOV\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_affiliate\",\"type\":\"address\"}],\"name\":\"addAffiliate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"}],\"name\":\"addSponsoredMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"affiliates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"internalType\":\"struct MintverseSwap.OpenseaTrades[]\",\"name\":\"openseaTrades\",\"type\":\"tuple[]\"}],\"name\":\"batchBuyFromOpenSea\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct MintverseSwap.ERC20Details\",\"name\":\"erc20Details\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"internalType\":\"struct MarketRegistry.TradeDetails[]\",\"name\":\"tradeDetails\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"conversionData\",\"type\":\"bytes\"}],\"internalType\":\"struct MintverseSwap.ConverstionDetails[]\",\"name\":\"converstionDetails\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"dustTokens\",\"type\":\"address[]\"}],\"name\":\"batchBuyWithERC20s\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"internalType\":\"struct MarketRegistry.TradeDetails[]\",\"name\":\"tradeDetails\",\"type\":\"tuple[]\"}],\"name\":\"batchBuyWithETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeAllTrades\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"converter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketRegistry\",\"outputs\":[{\"internalType\":\"contract MarketRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct MintverseSwap.ERC20Details\",\"name\":\"erc20Details\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"internalType\":\"struct SpecialTransferHelper.ERC721Details[]\",\"name\":\"erc721Details\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct MintverseSwap.ERC1155Details[]\",\"name\":\"erc1155Details\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"conversionData\",\"type\":\"bytes\"}],\"internalType\":\"struct MintverseSwap.ConverstionDetails[]\",\"name\":\"converstionDetails\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"internalType\":\"struct MarketRegistry.TradeDetails[]\",\"name\":\"tradeDetails\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"dustTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[2]\",\"name\":\"feeDetails\",\"type\":\"uint256[2]\"}],\"name\":\"multiAssetSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openForFreeTrades\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openForTrades\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"punkProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"rescueERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"rescueERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"rescueERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"rescueETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_baseFees\",\"type\":\"uint256\"}],\"name\":\"setBaseFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"setConverter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MarketRegistry\",\"name\":\"_marketRegistry\",\"type\":\"address\"}],\"name\":\"setMarketRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setOneTimeApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_openForFreeTrades\",\"type\":\"bool\"}],\"name\":\"setOpenForFreeTrades\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_openForTrades\",\"type\":\"bool\"}],\"name\":\"setOpenForTrades\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sponsoredMarkets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_affiliateIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_affiliate\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_IsActive\",\"type\":\"bool\"}],\"name\":\"updateAffiliate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"updateGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"updateSponsoredMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MintverseSwap", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055438737abea6766d70cbaea6d363ed619000c3000000000000000000000000097fb625482464eb51e8f65291515de1f685263370000000000000000000000007d0f2119a3de8fb35fc6932c414478d67de620d2", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ea4bade7f1f85e2610240c5db936cc4d73ef9e399a901232b78e73739cc4f8f7"}]}