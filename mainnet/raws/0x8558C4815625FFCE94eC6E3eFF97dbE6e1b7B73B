{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.16;\r\npragma experimental \"v0.5.0\";\r\npragma experimental \"ABIEncoderV2\";\r\n\r\n\r\nlibrary Bits {\r\n\r\n    uint constant internal ONE = uint(1);\r\n    uint constant internal ONES = uint(~0);\r\n\r\n    // Sets the bit at the given 'index' in 'self' to '1'.\r\n    // Returns the modified value.\r\n    function setBit(uint self, uint8 index) internal pure returns (uint) {\r\n        return self | ONE << index;\r\n    }\r\n\r\n    // Sets the bit at the given 'index' in 'self' to '0'.\r\n    // Returns the modified value.\r\n    function clearBit(uint self, uint8 index) internal pure returns (uint) {\r\n        return self & ~(ONE << index);\r\n    }\r\n\r\n    // Sets the bit at the given 'index' in 'self' to:\r\n    //  '1' - if the bit is '0'\r\n    //  '0' - if the bit is '1'\r\n    // Returns the modified value.\r\n    function toggleBit(uint self, uint8 index) internal pure returns (uint) {\r\n        return self ^ ONE << index;\r\n    }\r\n\r\n    // Get the value of the bit at the given 'index' in 'self'.\r\n    function bit(uint self, uint8 index) internal pure returns (uint8) {\r\n        return uint8(self >> index & 1);\r\n    }\r\n\r\n    // Check if the bit at the given 'index' in 'self' is set.\r\n    // Returns:\r\n    //  'true' - if the value of the bit is '1'\r\n    //  'false' - if the value of the bit is '0'\r\n    function bitSet(uint self, uint8 index) internal pure returns (bool) {\r\n        return self >> index & 1 == 1;\r\n    }\r\n\r\n    // Checks if the bit at the given 'index' in 'self' is equal to the corresponding\r\n    // bit in 'other'.\r\n    // Returns:\r\n    //  'true' - if both bits are '0' or both bits are '1'\r\n    //  'false' - otherwise\r\n    function bitEqual(uint self, uint other, uint8 index) internal pure returns (bool) {\r\n        return (self ^ other) >> index & 1 == 0;\r\n    }\r\n\r\n    // Get the bitwise NOT of the bit at the given 'index' in 'self'.\r\n    function bitNot(uint self, uint8 index) internal pure returns (uint8) {\r\n        return uint8(1 - (self >> index & 1));\r\n    }\r\n\r\n    // Computes the bitwise AND of the bit at the given 'index' in 'self', and the\r\n    // corresponding bit in 'other', and returns the value.\r\n    function bitAnd(uint self, uint other, uint8 index) internal pure returns (uint8) {\r\n        return uint8((self & other) >> index & 1);\r\n    }\r\n\r\n    // Computes the bitwise OR of the bit at the given 'index' in 'self', and the\r\n    // corresponding bit in 'other', and returns the value.\r\n    function bitOr(uint self, uint other, uint8 index) internal pure returns (uint8) {\r\n        return uint8((self | other) >> index & 1);\r\n    }\r\n\r\n    // Computes the bitwise XOR of the bit at the given 'index' in 'self', and the\r\n    // corresponding bit in 'other', and returns the value.\r\n    function bitXor(uint self, uint other, uint8 index) internal pure returns (uint8) {\r\n        return uint8((self ^ other) >> index & 1);\r\n    }\r\n\r\n    // Gets 'numBits' consecutive bits from 'self', starting from the bit at 'startIndex'.\r\n    // Returns the bits as a 'uint'.\r\n    // Requires that:\r\n    //  - '0 < numBits <= 256'\r\n    //  - 'startIndex < 256'\r\n    //  - 'numBits + startIndex <= 256'\r\n    function bits(uint self, uint8 startIndex, uint16 numBits) internal pure returns (uint) {\r\n        require(0 < numBits && startIndex < 256 && startIndex + numBits <= 256);\r\n        return self >> startIndex & ONES >> 256 - numBits;\r\n    }\r\n\r\n    // Computes the index of the highest bit set in 'self'.\r\n    // Returns the highest bit set as an 'uint8'.\r\n    // Requires that 'self != 0'.\r\n    function highestBitSet(uint self) internal pure returns (uint8 highest) {\r\n        require(self != 0);\r\n        uint val = self;\r\n        for (uint8 i = 128; i >= 1; i >>= 1) {\r\n            if (val & (ONE << i) - 1 << i != 0) {\r\n                highest += i;\r\n                val >>= i;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Computes the index of the lowest bit set in 'self'.\r\n    // Returns the lowest bit set as an 'uint8'.\r\n    // Requires that 'self != 0'.\r\n    function lowestBitSet(uint self) internal pure returns (uint8 lowest) {\r\n        require(self != 0);\r\n        uint val = self;\r\n        for (uint8 i = 128; i >= 1; i >>= 1) {\r\n            if (val & (ONE << i) - 1 == 0) {\r\n                lowest += i;\r\n                val >>= i;\r\n            }\r\n        }\r\n    }\r\n\r\n}", "ABI": "[]", "ContractName": "Bits", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}