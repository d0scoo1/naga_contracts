{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/external/actions/GovernanceAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../internal/valuation/ExchangeRate.sol\\\";\\r\\nimport \\\"../../internal/markets/CashGroup.sol\\\";\\r\\nimport \\\"../../internal/nToken/nTokenHandler.sol\\\";\\r\\nimport \\\"../../internal/nToken/nTokenSupply.sol\\\";\\r\\nimport \\\"../../internal/balances/TokenHandler.sol\\\";\\r\\nimport \\\"../../global/StorageLayoutV2.sol\\\";\\r\\nimport \\\"../../global/LibStorage.sol\\\";\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"../../proxy/utils/UUPSUpgradeable.sol\\\";\\r\\nimport \\\"../adapters/nTokenERC20Proxy.sol\\\";\\r\\nimport \\\"../../../interfaces/notional/IRewarder.sol\\\";\\r\\nimport \\\"../../../interfaces/notional/AssetRateAdapter.sol\\\";\\r\\nimport \\\"../../../interfaces/chainlink/AggregatorV2V3Interface.sol\\\";\\r\\nimport \\\"../../../interfaces/notional/NotionalGovernance.sol\\\";\\r\\nimport \\\"../../../interfaces/notional/nTokenERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\r\\n\\r\\n/// @notice Governance methods can only be called by the governance contract\\r\\ncontract GovernanceAction is StorageLayoutV2, NotionalGovernance, UUPSUpgradeable {\\r\\n    /// @dev Throws if called by any account other than the owner.\\r\\n    modifier onlyOwner() {\\r\\n        require(owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _checkValidCurrency(uint16 currencyId) internal view {\\r\\n        require(0 < currencyId && currencyId <= maxCurrencyId, \\\"Invalid currency id\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\\r\\n    /// Can only be invoked by the current `owner`.\\r\\n    /// @param newOwner Address of the new owner.\\r\\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\\r\\n    function transferOwnership(\\r\\n        address newOwner,\\r\\n        bool direct\\r\\n    ) external override onlyOwner {\\r\\n        if (direct) {\\r\\n            // Checks\\r\\n            require(newOwner != address(0), \\\"Ownable: zero address\\\");\\r\\n\\r\\n            // Effects\\r\\n            emit OwnershipTransferred(owner, newOwner);\\r\\n            owner = newOwner;\\r\\n            pendingOwner = address(0);\\r\\n        } else {\\r\\n            // Effects\\r\\n            pendingOwner = newOwner;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\\r\\n    function claimOwnership() external override {\\r\\n        address _pendingOwner = pendingOwner;\\r\\n\\r\\n        // Checks\\r\\n        require(msg.sender == _pendingOwner, \\\"Ownable: caller != pending owner\\\");\\r\\n\\r\\n        // Effects\\r\\n        emit OwnershipTransferred(owner, _pendingOwner);\\r\\n        owner = _pendingOwner;\\r\\n        pendingOwner = address(0);\\r\\n    }\\r\\n\\r\\n    /// @dev Only the owner may upgrade the contract, the pauseGuardian may downgrade the contract\\r\\n    /// to a predetermined router contract that provides read only access to the system.\\r\\n    function _authorizeUpgrade(address newImplementation) internal override {\\r\\n        require(\\r\\n            owner == msg.sender ||\\r\\n            (msg.sender == pauseGuardian && newImplementation == pauseRouter),\\r\\n            \\\"Unauthorized upgrade\\\"\\r\\n        );\\r\\n\\r\\n        // This is set temporarily during a downgrade to the pauseRouter so that the upgrade\\r\\n        // will pass _authorizeUpgrade on the pauseRouter during the UUPSUpgradeable rollback check\\r\\n        if (newImplementation == pauseRouter) rollbackRouterImplementation = _getImplementation();\\r\\n    }\\r\\n\\r\\n    /// @notice Sets a new pause router and guardian address.\\r\\n    function setPauseRouterAndGuardian(\\r\\n        address pauseRouter_,\\r\\n        address pauseGuardian_\\r\\n    ) external override onlyOwner {\\r\\n        pauseRouter = pauseRouter_;\\r\\n        pauseGuardian = pauseGuardian_;\\r\\n\\r\\n        emit PauseRouterAndGuardianUpdated(pauseRouter_, pauseGuardian_);\\r\\n    }\\r\\n\\r\\n    /// @notice Lists a new currency along with its exchange rate to ETH\\r\\n    /// @dev emit:ListCurrency emit:UpdateETHRate\\r\\n    /// @param assetToken the token parameters for the asset token\\r\\n    /// @param underlyingToken the underlying token (if asset token is an interest bearing wrapper)\\r\\n    /// @param rateOracle ETH to underlying rate oracle\\r\\n    /// @param mustInvert if the rate from the oracle needs to be inverted\\r\\n    /// @param buffer multiplier (>= 100) for negative balances when calculating free collateral\\r\\n    /// @param haircut multiplier (<= 100) for positive balances when calculating free collateral\\r\\n    /// @param liquidationDiscount multiplier (>= 100) for exchange rate when liquidating\\r\\n    /// @return the new currency id\\r\\n    function listCurrency(\\r\\n        TokenStorage calldata assetToken,\\r\\n        TokenStorage calldata underlyingToken,\\r\\n        AggregatorV2V3Interface rateOracle,\\r\\n        bool mustInvert,\\r\\n        uint8 buffer,\\r\\n        uint8 haircut,\\r\\n        uint8 liquidationDiscount\\r\\n    ) external override onlyOwner returns (uint16) {\\r\\n        uint16 currencyId = maxCurrencyId + 1;\\r\\n        // Set the new max currency id\\r\\n        maxCurrencyId = currencyId;\\r\\n        require(currencyId <= Constants.MAX_CURRENCIES, \\\"G: max currency overflow\\\");\\r\\n        // NOTE: this allows multiple asset tokens that have the same underlying. That is ok from a protocol\\r\\n        // perspective. For example, we may choose list cDAI, yDAI and aDAI as asset currencies and each can\\r\\n        // trade as different forms of fDAI.\\r\\n        require(\\r\\n            tokenAddressToCurrencyId[assetToken.tokenAddress] == 0,\\r\\n            \\\"G: duplicate token listing\\\"\\r\\n        );\\r\\n        tokenAddressToCurrencyId[assetToken.tokenAddress] = currencyId;\\r\\n\\r\\n        // Set the underlying first because the asset token may set an approval using the underlying\\r\\n        if (\\r\\n            underlyingToken.tokenAddress != address(0) ||\\r\\n            // Ether has a token address of zero\\r\\n            underlyingToken.tokenType == TokenType.Ether\\r\\n        ) {\\r\\n            // NOTE: set token will enforce the restriction that Ether can only be set once as the zero\\r\\n            // address. This sets the underlying token\\r\\n            TokenHandler.setToken(currencyId, true, underlyingToken);\\r\\n        }\\r\\n\\r\\n        // This sets the asset token\\r\\n        TokenHandler.setToken(currencyId, false, assetToken);\\r\\n\\r\\n        _updateETHRate(currencyId, rateOracle, mustInvert, buffer, haircut, liquidationDiscount);\\r\\n\\r\\n        emit ListCurrency(currencyId);\\r\\n\\r\\n        return currencyId;\\r\\n    }\\r\\n\\r\\n    /// @notice Sets a maximum balance on a given currency. Max collateral balance cannot be set on a\\r\\n    /// currency that is actively used in trading, this may cause issues with liquidation. Also, max\\r\\n    /// collateral balance is only set on asset tokens (not underlying tokens) because underlying tokens\\r\\n    /// are not held as contract balances.\\r\\n    /// @dev emit:UpdateMaxCollateralBalance\\r\\n    /// @param currencyId id of the currency to set the max collateral balance on\\r\\n    /// @param maxCollateralBalanceInternalPrecision amount of collateral balance that can be held\\r\\n    /// in this currency denominated in internal token precision\\r\\n    function updateMaxCollateralBalance(\\r\\n        uint16 currencyId,\\r\\n        uint72 maxCollateralBalanceInternalPrecision\\r\\n    ) external override onlyOwner {\\r\\n        _checkValidCurrency(currencyId);\\r\\n        // Cannot turn on max collateral balance for a currency that is trading\\r\\n        if (maxCollateralBalanceInternalPrecision > 0) require(CashGroup.getMaxMarketIndex(currencyId) == 0);\\r\\n        TokenHandler.setMaxCollateralBalance(currencyId, maxCollateralBalanceInternalPrecision);\\r\\n        emit UpdateMaxCollateralBalance(currencyId, maxCollateralBalanceInternalPrecision);\\r\\n    }\\r\\n\\r\\n    /// @notice Enables a cash group on a given currency so that it can have lend and borrow markets. Will\\r\\n    /// also deploy an nToken contract so that markets can be initialized.\\r\\n    /// @dev emit:UpdateCashGroup emit:UpdateAssetRate emit:DeployNToken\\r\\n    /// @param currencyId id of the currency to enable\\r\\n    /// @param assetRateOracle address of the rate oracle for converting interest bearing assets to\\r\\n    /// underlying values\\r\\n    /// @param cashGroup parameters for the cash group\\r\\n    /// @param underlyingName underlying token name for seeding nToken name\\r\\n    /// @param underlyingSymbol underlying token symbol for seeding nToken symbol (i.e. nDAI)\\r\\n    function enableCashGroup(\\r\\n        uint16 currencyId,\\r\\n        AssetRateAdapter assetRateOracle,\\r\\n        CashGroupSettings calldata cashGroup,\\r\\n        string calldata underlyingName,\\r\\n        string calldata underlyingSymbol\\r\\n    ) external override onlyOwner {\\r\\n        _checkValidCurrency(currencyId);\\r\\n        {\\r\\n            // Cannot enable fCash trading on a token with a max collateral balance\\r\\n            Token memory assetToken = TokenHandler.getAssetToken(currencyId);\\r\\n            Token memory underlyingToken = TokenHandler.getUnderlyingToken(currencyId);\\r\\n            require(\\r\\n                assetToken.maxCollateralBalance == 0 &&\\r\\n                underlyingToken.maxCollateralBalance == 0\\r\\n            ); // dev: cannot enable trading, collateral cap\\r\\n        }\\r\\n\\r\\n        _updateCashGroup(currencyId, cashGroup);\\r\\n        _updateAssetRate(currencyId, assetRateOracle);\\r\\n\\r\\n        // Creates the nToken erc20 proxy that routes back to the main contract\\r\\n        nTokenERC20Proxy proxy = new nTokenERC20Proxy(\\r\\n            nTokenERC20(address(this)),\\r\\n            currencyId,\\r\\n            underlyingName,\\r\\n            underlyingSymbol\\r\\n        );\\r\\n        nTokenHandler.setNTokenAddress(currencyId, address(proxy));\\r\\n        emit DeployNToken(currencyId, address(proxy));\\r\\n    }\\r\\n\\r\\n    /// @notice Updates the deposit parameters for an nToken\\r\\n    /// @dev emit:UpdateDepositParameters\\r\\n    /// @param currencyId the currency id that the nToken references\\r\\n    /// @param depositShares an array of values that represent the proportion of each deposit\\r\\n    /// that will go to a respective market, must add up to DEPOSIT_PERCENT_BASIS. For example,\\r\\n    /// 0.40e8, 0.40e8 and 0.20e8 will result in 40%, 40% and 20% deposited as liquidity into\\r\\n    /// the 3 month, 6 month and 1 year markets.\\r\\n    /// @param leverageThresholds an array of values denominated in RATE_PRECISION that mark the\\r\\n    /// highest proportion of fCash where the nToken will provide liquidity. Above this proportion,\\r\\n    /// the nToken will lend to the market instead to reduce the leverage in the market.\\r\\n    function updateDepositParameters(\\r\\n        uint16 currencyId,\\r\\n        uint32[] calldata depositShares,\\r\\n        uint32[] calldata leverageThresholds\\r\\n    ) external override onlyOwner {\\r\\n        _checkValidCurrency(currencyId);\\r\\n        nTokenHandler.setDepositParameters(currencyId, depositShares, leverageThresholds);\\r\\n        emit UpdateDepositParameters(currencyId);\\r\\n    }\\r\\n\\r\\n    /// @notice Updates the market initialization parameters for an nToken\\r\\n    /// @dev emit:UpdateInitializationParameters\\r\\n    /// @param currencyId the currency id that the nToken references\\r\\n    /// @param annualizedAnchorRates is a target interest rate that will be used to calculate a \\r\\n    /// rate anchor during initialize markets. This rate anchor will set the offset from the\\r\\n    /// x-axis where the liquidity curve will be initialized. This is used in combination with\\r\\n    /// previous market rates to determine the initial proportion where markets will be initialized\\r\\n    /// every quarter.\\r\\n    /// @param proportions used to combination with annualizedAnchorRate set the initial proportion when\\r\\n    /// a market is first initialized. This is required since there is no previous rate to reference.\\r\\n    function updateInitializationParameters(\\r\\n        uint16 currencyId,\\r\\n        uint32[] calldata annualizedAnchorRates,\\r\\n        uint32[] calldata proportions\\r\\n    ) external override onlyOwner {\\r\\n        _checkValidCurrency(currencyId);\\r\\n        nTokenHandler.setInitializationParameters(currencyId, annualizedAnchorRates, proportions);\\r\\n        emit UpdateInitializationParameters(currencyId);\\r\\n    }\\r\\n\\r\\n    /// @notice Updates the emission rate of incentives for a given currency\\r\\n    /// @dev emit:UpdateIncentiveEmissionRate\\r\\n    /// @param currencyId the currency id that the nToken references\\r\\n    /// @param newEmissionRate Target total incentives to emit for an nToken over an entire year\\r\\n    /// denominated in WHOLE TOKENS (i.e. setting this to 1 means 1e8 tokens). The rate will not be\\r\\n    /// exact due to multiplier effects and fluctuating token supply.\\r\\n    function updateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate)\\r\\n        external\\r\\n        override\\r\\n        onlyOwner\\r\\n    {\\r\\n        _checkValidCurrency(currencyId);\\r\\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\\r\\n        require(nTokenAddress != address(0), \\\"Invalid currency\\\");\\r\\n        // Sanity check that emissions rate is not specified in 1e8 terms.\\r\\n        require(newEmissionRate < Constants.INTERNAL_TOKEN_PRECISION, \\\"Invalid rate\\\");\\r\\n\\r\\n        nTokenSupply.setIncentiveEmissionRate(nTokenAddress, newEmissionRate, block.timestamp);\\r\\n        emit UpdateIncentiveEmissionRate(currencyId, newEmissionRate);\\r\\n    }\\r\\n\\r\\n    /// @notice Updates collateralization parameters for an nToken\\r\\n    /// @dev emit:UpdateTokenCollateralParameters\\r\\n    /// @param currencyId the currency id that the nToken references\\r\\n    /// @param residualPurchaseIncentive10BPS nTokens will have residual amounts of fCash at the end of each\\r\\n    /// quarter that are \\\"dead weight\\\" because they are at idiosyncratic maturities and do not contribute to\\r\\n    /// actively providing liquidity. This parameter will incentivize market participants to purchase these residuals\\r\\n    /// at a discount from the on chain oracle rate, denominated in 10 basis point increments. These residuals will\\r\\n    /// be added back into nToken balances and will be used to provide liquidity upon the next market initialization.\\r\\n    /// @param pvHaircutPercentage a percentage (< 100) that the present value of the nToken's assets will be valued\\r\\n    /// at for the purposes of free collateral, relevant when accounts hold nTokens as collateral against debts.\\r\\n    /// @param residualPurchaseTimeBufferHours an arbitrage opportunity is available by pushing markets in one direction\\r\\n    /// before quarterly settlement to generate large residual balances that can be purchased at a discount. The time buffer\\r\\n    /// here ensures that anyone attempting such an act would have to wait some number of hours (likely a few days) before\\r\\n    /// they could attempt to purchase residuals, ensuring that the market could realign to rates where the arbitrage is\\r\\n    /// no longer possible.\\r\\n    /// @param cashWithholdingBuffer10BPS nToken residuals may be negative fCash (debt), in this case cash is withheld to\\r\\n    /// transfer to accounts that take on the debt. This parameter denominates the discounted rate at which the cash will\\r\\n    /// be withheld at for this purpose.\\r\\n    /// @param liquidationHaircutPercentage a percentage of nToken present value (> pvHaircutPercentage and <= 100) at which\\r\\n    /// liquidators will purchase nTokens during liquidation\\r\\n    function updateTokenCollateralParameters(\\r\\n        uint16 currencyId,\\r\\n        uint8 residualPurchaseIncentive10BPS,\\r\\n        uint8 pvHaircutPercentage,\\r\\n        uint8 residualPurchaseTimeBufferHours,\\r\\n        uint8 cashWithholdingBuffer10BPS,\\r\\n        uint8 liquidationHaircutPercentage\\r\\n    ) external override onlyOwner {\\r\\n        _checkValidCurrency(currencyId);\\r\\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\\r\\n        require(nTokenAddress != address(0), \\\"Invalid currency\\\");\\r\\n\\r\\n        nTokenHandler.setNTokenCollateralParameters(\\r\\n            nTokenAddress,\\r\\n            residualPurchaseIncentive10BPS,\\r\\n            pvHaircutPercentage,\\r\\n            residualPurchaseTimeBufferHours,\\r\\n            cashWithholdingBuffer10BPS,\\r\\n            liquidationHaircutPercentage\\r\\n        );\\r\\n        emit UpdateTokenCollateralParameters(currencyId);\\r\\n    }\\r\\n\\r\\n    /// @notice Updates cash group parameters\\r\\n    /// @dev emit:UpdateCashGroup\\r\\n    /// @param currencyId id of the currency to enable\\r\\n    /// @param cashGroup new parameters for the cash group\\r\\n    function updateCashGroup(uint16 currencyId, CashGroupSettings calldata cashGroup)\\r\\n        external\\r\\n        override\\r\\n        onlyOwner\\r\\n    {\\r\\n        _checkValidCurrency(currencyId);\\r\\n        _updateCashGroup(currencyId, cashGroup);\\r\\n    }\\r\\n\\r\\n    /// @notice Updates asset rate oracle\\r\\n    /// @dev emit:UpdateAssetRate\\r\\n    /// @param currencyId id of the currency\\r\\n    /// @param rateOracle new rate oracle for the asset\\r\\n    function updateAssetRate(uint16 currencyId, AssetRateAdapter rateOracle) external override onlyOwner {\\r\\n        _checkValidCurrency(currencyId);\\r\\n        _updateAssetRate(currencyId, rateOracle);\\r\\n    }\\r\\n\\r\\n    /// @notice Updates ETH exchange rate or related parameters\\r\\n    /// @dev emit:UpdateETHRate\\r\\n    /// @param currencyId id of the currency\\r\\n    /// @param rateOracle new rate oracle for the asset\\r\\n    /// @param rateOracle ETH to underlying rate oracle\\r\\n    /// @param mustInvert if the rate from the oracle needs to be inverted\\r\\n    /// @param buffer multiplier (>= 100) for negative balances when calculating free collateral\\r\\n    /// @param haircut multiplier (<= 100) for positive balances when calculating free collateral\\r\\n    /// @param liquidationDiscount multiplier (>= 100) for exchange rate when liquidating\\r\\n    function updateETHRate(\\r\\n        uint16 currencyId,\\r\\n        AggregatorV2V3Interface rateOracle,\\r\\n        bool mustInvert,\\r\\n        uint8 buffer,\\r\\n        uint8 haircut,\\r\\n        uint8 liquidationDiscount\\r\\n    ) external override onlyOwner {\\r\\n        _checkValidCurrency(currencyId);\\r\\n        _updateETHRate(currencyId, rateOracle, mustInvert, buffer, haircut, liquidationDiscount);\\r\\n    }\\r\\n\\r\\n    /// @notice Sets a global transfer operator that can do authenticated ERC1155 transfers. This enables\\r\\n    /// OTC trading or other use cases such as layer 2 authenticated transfers.\\r\\n    /// @dev emit:UpdateGlobalTransferOperator\\r\\n    /// @param operator address of the operator\\r\\n    /// @param approved true if the operator is allowed to transfer globally\\r\\n    function updateGlobalTransferOperator(address operator, bool approved)\\r\\n        external\\r\\n        override\\r\\n        onlyOwner\\r\\n    {\\r\\n        // Sanity check to ensure that operator is a contract, not an EOA\\r\\n        require(Address.isContract(operator), \\\"Operator must be a contract\\\");\\r\\n\\r\\n        globalTransferOperator[operator] = approved;\\r\\n        emit UpdateGlobalTransferOperator(operator, approved);\\r\\n    }\\r\\n\\r\\n    /// @notice Approves contracts that can call `batchTradeActionWithCallback`. These contracts can\\r\\n    /// \\\"flash loan\\\" from Notional V2 and receive a callback before the free collateral check. Flash loans\\r\\n    /// via the Notional V2 liquidity pool are not very gas efficient so this is not generally available,\\r\\n    /// it can be used for migrating borrows into Notional V2 from other platforms.\\r\\n    /// @dev emit:UpdateAuthorizedCallbackContract\\r\\n    /// @param operator address of the contract\\r\\n    /// @param approved true if the contract is authorized\\r\\n    function updateAuthorizedCallbackContract(address operator, bool approved)\\r\\n        external\\r\\n        override\\r\\n        onlyOwner\\r\\n    {\\r\\n        // Sanity check to ensure that operator is a contract, not an EOA\\r\\n        require(Address.isContract(operator), \\\"Operator must be a contract\\\");\\r\\n        authorizedCallbackContract[operator] = approved;\\r\\n        emit UpdateAuthorizedCallbackContract(operator, approved);\\r\\n    }\\r\\n\\r\\n    /// @notice Sets a secondary incentive rewarder for a currency. This contract will\\r\\n    /// be called whenever an nToken balance changes and allows a secondary contract to\\r\\n    /// mint incentives to the account. This will override any previous rewarder, if set.\\r\\n    /// Will have no effect if there is no nToken corresponding to the currency id.\\r\\n    /// @dev emit:UpdateSecondaryIncentiveRewarder\\r\\n    /// @param currencyId currency id of the nToken\\r\\n    /// @param rewarder rewarder contract\\r\\n    function setSecondaryIncentiveRewarder(uint16 currencyId, IRewarder rewarder)\\r\\n        external\\r\\n        override\\r\\n        onlyOwner\\r\\n    {\\r\\n        _checkValidCurrency(currencyId);\\r\\n        require(Address.isContract(address(rewarder)), \\\"Rewarder must be a contract\\\");\\r\\n        nTokenHandler.setSecondaryRewarder(currencyId, rewarder);\\r\\n        emit UpdateSecondaryIncentiveRewarder(currencyId, address(rewarder));\\r\\n    }\\r\\n\\r\\n    /// @notice Updates the lending pool address used by AaveHandler\\r\\n    /// @dev emit:UpdateLendingPool\\r\\n    /// @param pool lending pool address\\r\\n    function setLendingPool(ILendingPool pool) external override onlyOwner {\\r\\n        LendingPoolStorage storage store = LibStorage.getLendingPool();\\r\\n        require(address(pool) != address(0) && address(store.lendingPool) == address(0), \\\"Invalid lending pool\\\");\\r\\n        store.lendingPool = pool;\\r\\n        emit UpdateLendingPool(address(pool));\\r\\n    }\\r\\n\\r\\n    function _updateCashGroup(uint16 currencyId, CashGroupSettings calldata cashGroup) internal {\\r\\n        CashGroup.setCashGroupStorage(currencyId, cashGroup);\\r\\n        emit UpdateCashGroup(currencyId);\\r\\n    }\\r\\n\\r\\n    function _updateAssetRate(uint16 currencyId, AssetRateAdapter rateOracle) internal {\\r\\n        // If rate oracle refers to address zero then do not apply any updates here, this means\\r\\n        // that a token is non mintable.\\r\\n        Token memory assetToken = TokenHandler.getAssetToken(currencyId);\\r\\n        if (address(rateOracle) == address(0)) {\\r\\n            // Sanity check that unset rate oracles are only for non mintable tokens\\r\\n            require(assetToken.tokenType == TokenType.NonMintable, \\\"G: invalid asset rate\\\");\\r\\n        } else {\\r\\n            // Sanity check that the rate oracle refers to the proper asset token\\r\\n            address token = AssetRateAdapter(rateOracle).token();\\r\\n            require(assetToken.tokenAddress == token, \\\"G: invalid rate oracle\\\");\\r\\n\\r\\n            uint8 underlyingDecimals;\\r\\n            if (currencyId == Constants.ETH_CURRENCY_ID) {\\r\\n                // If currencyId is one then this is referring to cETH and there is no underlying() to call\\r\\n                underlyingDecimals = Constants.ETH_DECIMAL_PLACES;\\r\\n            } else {\\r\\n                address underlyingTokenAddress = AssetRateAdapter(rateOracle).underlying();\\r\\n                Token memory underlyingToken = TokenHandler.getUnderlyingToken(currencyId);\\r\\n                // Sanity check to ensure that the asset rate adapter refers to the correct underlying\\r\\n                require(underlyingTokenAddress == underlyingToken.tokenAddress, \\\"G: invalid adapter\\\");\\r\\n                underlyingDecimals = ERC20(underlyingTokenAddress).decimals();\\r\\n            }\\r\\n\\r\\n            // Perform this check to ensure that decimal calculations don't overflow\\r\\n            require(underlyingDecimals <= Constants.MAX_DECIMAL_PLACES);\\r\\n            mapping(uint256 => AssetRateStorage) storage store = LibStorage.getAssetRateStorage();\\r\\n            store[currencyId] = AssetRateStorage({\\r\\n                rateOracle: rateOracle,\\r\\n                underlyingDecimalPlaces: underlyingDecimals\\r\\n            });\\r\\n\\r\\n            emit UpdateAssetRate(currencyId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _updateETHRate(\\r\\n        uint16 currencyId,\\r\\n        AggregatorV2V3Interface rateOracle,\\r\\n        bool mustInvert,\\r\\n        uint8 buffer,\\r\\n        uint8 haircut,\\r\\n        uint8 liquidationDiscount\\r\\n    ) internal {\\r\\n        uint8 rateDecimalPlaces;\\r\\n        if (currencyId == Constants.ETH_CURRENCY_ID) {\\r\\n            // ETH to ETH exchange rate is fixed at 1 and has no rate oracle\\r\\n            rateOracle = AggregatorV2V3Interface(address(0));\\r\\n            rateDecimalPlaces = Constants.ETH_DECIMAL_PLACES;\\r\\n        } else {\\r\\n            require(address(rateOracle) != address(0), \\\"G: zero rate oracle address\\\");\\r\\n            rateDecimalPlaces = rateOracle.decimals();\\r\\n        }\\r\\n        require(buffer >= Constants.PERCENTAGE_DECIMALS, \\\"G: buffer must be gte decimals\\\");\\r\\n        require(haircut <= Constants.PERCENTAGE_DECIMALS, \\\"G: buffer must be lte decimals\\\");\\r\\n        require(\\r\\n            liquidationDiscount > Constants.PERCENTAGE_DECIMALS,\\r\\n            \\\"G: discount must be gt decimals\\\"\\r\\n        );\\r\\n\\r\\n        // Perform this check to ensure that decimal calculations don't overflow\\r\\n        require(rateDecimalPlaces <= Constants.MAX_DECIMAL_PLACES);\\r\\n        mapping(uint256 => ETHRateStorage) storage store = LibStorage.getExchangeRateStorage();\\r\\n        store[currencyId] = ETHRateStorage({\\r\\n            rateOracle: rateOracle,\\r\\n            rateDecimalPlaces: rateDecimalPlaces,\\r\\n            mustInvert: mustInvert,\\r\\n            buffer: buffer,\\r\\n            haircut: haircut,\\r\\n            liquidationDiscount: liquidationDiscount\\r\\n        });\\r\\n\\r\\n        emit UpdateETHRate(currencyId);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/valuation/ExchangeRate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../balances/TokenHandler.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../../interfaces/chainlink/AggregatorV2V3Interface.sol\\\";\\r\\n\\r\\nlibrary ExchangeRate {\\r\\n    using SafeInt256 for int256;\\r\\n\\r\\n    /// @notice Converts a balance to ETH from a base currency. Buffers or haircuts are\\r\\n    /// always applied in this method.\\r\\n    /// @param er exchange rate object from base to ETH\\r\\n    /// @return the converted balance denominated in ETH with Constants.INTERNAL_TOKEN_PRECISION\\r\\n    function convertToETH(ETHRate memory er, int256 balance) internal pure returns (int256) {\\r\\n        int256 multiplier = balance > 0 ? er.haircut : er.buffer;\\r\\n\\r\\n        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals\\r\\n        // internalDecimals * rateDecimals * multiplier /  (rateDecimals * multiplierDecimals)\\r\\n        // Therefore the result is in ethDecimals\\r\\n        int256 result =\\r\\n            balance.mul(er.rate).mul(multiplier).div(Constants.PERCENTAGE_DECIMALS).div(\\r\\n                er.rateDecimals\\r\\n            );\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /// @notice Converts the balance denominated in ETH to the equivalent value in a base currency.\\r\\n    /// Buffers and haircuts ARE NOT applied in this method.\\r\\n    /// @param er exchange rate object from base to ETH\\r\\n    /// @param balance amount (denominated in ETH) to convert\\r\\n    function convertETHTo(ETHRate memory er, int256 balance) internal pure returns (int256) {\\r\\n        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals\\r\\n        // internalDecimals * rateDecimals / rateDecimals\\r\\n        int256 result = balance.mul(er.rateDecimals).div(er.rate);\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates the exchange rate between two currencies via ETH. Returns the rate denominated in\\r\\n    /// base exchange rate decimals: (baseRateDecimals * quoteRateDecimals) / quoteRateDecimals\\r\\n    /// @param baseER base exchange rate struct\\r\\n    /// @param quoteER quote exchange rate struct\\r\\n    function exchangeRate(ETHRate memory baseER, ETHRate memory quoteER)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256)\\r\\n    {\\r\\n        return baseER.rate.mul(quoteER.rateDecimals).div(quoteER.rate);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns an ETHRate object used to calculate free collateral\\r\\n    function buildExchangeRate(uint256 currencyId) internal view returns (ETHRate memory) {\\r\\n        mapping(uint256 => ETHRateStorage) storage store = LibStorage.getExchangeRateStorage();\\r\\n        ETHRateStorage storage ethStorage = store[currencyId];\\r\\n\\r\\n        int256 rateDecimals;\\r\\n        int256 rate;\\r\\n        if (currencyId == Constants.ETH_CURRENCY_ID) {\\r\\n            // ETH rates will just be 1e18, but will still have buffers, haircuts,\\r\\n            // and liquidation discounts\\r\\n            rateDecimals = Constants.ETH_DECIMALS;\\r\\n            rate = Constants.ETH_DECIMALS;\\r\\n        } else {\\r\\n            // prettier-ignore\\r\\n            (\\r\\n                /* roundId */,\\r\\n                rate,\\r\\n                /* uint256 startedAt */,\\r\\n                /* updatedAt */,\\r\\n                /* answeredInRound */\\r\\n            ) = ethStorage.rateOracle.latestRoundData();\\r\\n            require(rate > 0, \\\"Invalid rate\\\");\\r\\n\\r\\n            // No overflow, restricted on storage\\r\\n            rateDecimals = int256(10**ethStorage.rateDecimalPlaces);\\r\\n            if (ethStorage.mustInvert) {\\r\\n                rate = rateDecimals.mul(rateDecimals).div(rate);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return\\r\\n            ETHRate({\\r\\n                rateDecimals: rateDecimals,\\r\\n                rate: rate,\\r\\n                buffer: ethStorage.buffer,\\r\\n                haircut: ethStorage.haircut,\\r\\n                liquidationDiscount: ethStorage.liquidationDiscount\\r\\n            });\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/markets/CashGroup.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./Market.sol\\\";\\r\\nimport \\\"./AssetRate.sol\\\";\\r\\nimport \\\"./DateTime.sol\\\";\\r\\nimport \\\"../../global/LibStorage.sol\\\";\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary CashGroup {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeInt256 for int256;\\r\\n    using AssetRate for AssetRateParameters;\\r\\n    using Market for MarketParameters;\\r\\n\\r\\n    // Bit number references for each parameter in the 32 byte word (0-indexed)\\r\\n    uint256 private constant MARKET_INDEX_BIT = 31;\\r\\n    uint256 private constant RATE_ORACLE_TIME_WINDOW_BIT = 30;\\r\\n    uint256 private constant TOTAL_FEE_BIT = 29;\\r\\n    uint256 private constant RESERVE_FEE_SHARE_BIT = 28;\\r\\n    uint256 private constant DEBT_BUFFER_BIT = 27;\\r\\n    uint256 private constant FCASH_HAIRCUT_BIT = 26;\\r\\n    uint256 private constant SETTLEMENT_PENALTY_BIT = 25;\\r\\n    uint256 private constant LIQUIDATION_FCASH_HAIRCUT_BIT = 24;\\r\\n    uint256 private constant LIQUIDATION_DEBT_BUFFER_BIT = 23;\\r\\n    // 7 bytes allocated, one byte per market for the liquidity token haircut\\r\\n    uint256 private constant LIQUIDITY_TOKEN_HAIRCUT_FIRST_BIT = 22;\\r\\n    // 7 bytes allocated, one byte per market for the rate scalar\\r\\n    uint256 private constant RATE_SCALAR_FIRST_BIT = 15;\\r\\n\\r\\n    // Offsets for the bytes of the different parameters\\r\\n    uint256 private constant MARKET_INDEX = (31 - MARKET_INDEX_BIT) * 8;\\r\\n    uint256 private constant RATE_ORACLE_TIME_WINDOW = (31 - RATE_ORACLE_TIME_WINDOW_BIT) * 8;\\r\\n    uint256 private constant TOTAL_FEE = (31 - TOTAL_FEE_BIT) * 8;\\r\\n    uint256 private constant RESERVE_FEE_SHARE = (31 - RESERVE_FEE_SHARE_BIT) * 8;\\r\\n    uint256 private constant DEBT_BUFFER = (31 - DEBT_BUFFER_BIT) * 8;\\r\\n    uint256 private constant FCASH_HAIRCUT = (31 - FCASH_HAIRCUT_BIT) * 8;\\r\\n    uint256 private constant SETTLEMENT_PENALTY = (31 - SETTLEMENT_PENALTY_BIT) * 8;\\r\\n    uint256 private constant LIQUIDATION_FCASH_HAIRCUT = (31 - LIQUIDATION_FCASH_HAIRCUT_BIT) * 8;\\r\\n    uint256 private constant LIQUIDATION_DEBT_BUFFER = (31 - LIQUIDATION_DEBT_BUFFER_BIT) * 8;\\r\\n    uint256 private constant LIQUIDITY_TOKEN_HAIRCUT = (31 - LIQUIDITY_TOKEN_HAIRCUT_FIRST_BIT) * 8;\\r\\n    uint256 private constant RATE_SCALAR = (31 - RATE_SCALAR_FIRST_BIT) * 8;\\r\\n\\r\\n    /// @notice Returns the rate scalar scaled by time to maturity. The rate scalar multiplies\\r\\n    /// the ln() portion of the liquidity curve as an inverse so it increases with time to\\r\\n    /// maturity. The effect of the rate scalar on slippage must decrease with time to maturity.\\r\\n    function getRateScalar(\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        uint256 marketIndex,\\r\\n        uint256 timeToMaturity\\r\\n    ) internal pure returns (int256) {\\r\\n        require(1 <= marketIndex && marketIndex <= cashGroup.maxMarketIndex); // dev: invalid market index\\r\\n\\r\\n        uint256 offset = RATE_SCALAR + 8 * (marketIndex - 1);\\r\\n        int256 scalar = int256(uint8(uint256(cashGroup.data >> offset))) * Constants.RATE_PRECISION;\\r\\n        int256 rateScalar =\\r\\n            scalar.mul(int256(Constants.IMPLIED_RATE_TIME)).div(SafeInt256.toInt(timeToMaturity));\\r\\n\\r\\n        // Rate scalar is denominated in RATE_PRECISION, it is unlikely to underflow in the\\r\\n        // division above.\\r\\n        require(rateScalar > 0); // dev: rate scalar underflow\\r\\n        return rateScalar;\\r\\n    }\\r\\n\\r\\n    /// @notice Haircut on liquidity tokens to account for the risk associated with changes in the\\r\\n    /// proportion of cash to fCash within the pool. This is set as a percentage less than or equal to 100.\\r\\n    function getLiquidityHaircut(CashGroupParameters memory cashGroup, uint256 assetType)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint8)\\r\\n    {\\r\\n        require(\\r\\n            Constants.MIN_LIQUIDITY_TOKEN_INDEX <= assetType &&\\r\\n            assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX\\r\\n        ); // dev: liquidity haircut invalid asset type\\r\\n        uint256 offset =\\r\\n            LIQUIDITY_TOKEN_HAIRCUT + 8 * (assetType - Constants.MIN_LIQUIDITY_TOKEN_INDEX);\\r\\n        return uint8(uint256(cashGroup.data >> offset));\\r\\n    }\\r\\n\\r\\n    /// @notice Total trading fee denominated in RATE_PRECISION with basis point increments\\r\\n    function getTotalFee(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\r\\n        return uint256(uint8(uint256(cashGroup.data >> TOTAL_FEE))) * Constants.BASIS_POINT;\\r\\n    }\\r\\n\\r\\n    /// @notice Percentage of the total trading fee that goes to the reserve\\r\\n    function getReserveFeeShare(CashGroupParameters memory cashGroup)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256)\\r\\n    {\\r\\n        return uint8(uint256(cashGroup.data >> RESERVE_FEE_SHARE));\\r\\n    }\\r\\n\\r\\n    /// @notice fCash haircut for valuation denominated in rate precision with five basis point increments\\r\\n    function getfCashHaircut(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\r\\n        return\\r\\n            uint256(uint8(uint256(cashGroup.data >> FCASH_HAIRCUT))) * Constants.FIVE_BASIS_POINTS;\\r\\n    }\\r\\n\\r\\n    /// @notice fCash debt buffer for valuation denominated in rate precision with five basis point increments\\r\\n    function getDebtBuffer(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\r\\n        return uint256(uint8(uint256(cashGroup.data >> DEBT_BUFFER))) * Constants.FIVE_BASIS_POINTS;\\r\\n    }\\r\\n\\r\\n    /// @notice Time window factor for the rate oracle denominated in seconds with five minute increments.\\r\\n    function getRateOracleTimeWindow(CashGroupParameters memory cashGroup)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        // This is denominated in 5 minute increments in storage\\r\\n        return uint256(uint8(uint256(cashGroup.data >> RATE_ORACLE_TIME_WINDOW))) * Constants.FIVE_MINUTES;\\r\\n    }\\r\\n\\r\\n    /// @notice Penalty rate for settling cash debts denominated in basis points\\r\\n    function getSettlementPenalty(CashGroupParameters memory cashGroup)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            uint256(uint8(uint256(cashGroup.data >> SETTLEMENT_PENALTY))) * Constants.FIVE_BASIS_POINTS;\\r\\n    }\\r\\n\\r\\n    /// @notice Haircut for positive fCash during liquidation denominated rate precision\\r\\n    /// with five basis point increments\\r\\n    function getLiquidationfCashHaircut(CashGroupParameters memory cashGroup)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            uint256(uint8(uint256(cashGroup.data >> LIQUIDATION_FCASH_HAIRCUT))) * Constants.FIVE_BASIS_POINTS;\\r\\n    }\\r\\n\\r\\n    /// @notice Haircut for negative fCash during liquidation denominated rate precision\\r\\n    /// with five basis point increments\\r\\n    function getLiquidationDebtBuffer(CashGroupParameters memory cashGroup)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            uint256(uint8(uint256(cashGroup.data >> LIQUIDATION_DEBT_BUFFER))) * Constants.FIVE_BASIS_POINTS;\\r\\n    }\\r\\n\\r\\n    function loadMarket(\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        MarketParameters memory market,\\r\\n        uint256 marketIndex,\\r\\n        bool needsLiquidity,\\r\\n        uint256 blockTime\\r\\n    ) internal view {\\r\\n        require(1 <= marketIndex && marketIndex <= cashGroup.maxMarketIndex, \\\"Invalid market\\\");\\r\\n        uint256 maturity =\\r\\n            DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));\\r\\n\\r\\n        market.loadMarket(\\r\\n            cashGroup.currencyId,\\r\\n            maturity,\\r\\n            blockTime,\\r\\n            needsLiquidity,\\r\\n            getRateOracleTimeWindow(cashGroup)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the linear interpolation between two market rates. The formula is\\r\\n    /// slope = (longMarket.oracleRate - shortMarket.oracleRate) / (longMarket.maturity - shortMarket.maturity)\\r\\n    /// interpolatedRate = slope * (assetMaturity - shortMarket.maturity) + shortMarket.oracleRate\\r\\n    function interpolateOracleRate(\\r\\n        uint256 shortMaturity,\\r\\n        uint256 longMaturity,\\r\\n        uint256 shortRate,\\r\\n        uint256 longRate,\\r\\n        uint256 assetMaturity\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(shortMaturity < assetMaturity); // dev: cash group interpolation error, short maturity\\r\\n        require(assetMaturity < longMaturity); // dev: cash group interpolation error, long maturity\\r\\n\\r\\n        // It's possible that the rates are inverted where the short market rate > long market rate and\\r\\n        // we will get an underflow here so we check for that\\r\\n        if (longRate >= shortRate) {\\r\\n            return\\r\\n                (longRate - shortRate)\\r\\n                    .mul(assetMaturity - shortMaturity)\\r\\n                // No underflow here, checked above\\r\\n                    .div(longMaturity - shortMaturity)\\r\\n                    .add(shortRate);\\r\\n        } else {\\r\\n            // In this case the slope is negative so:\\r\\n            // interpolatedRate = shortMarket.oracleRate - slope * (assetMaturity - shortMarket.maturity)\\r\\n            // NOTE: this subtraction should never overflow, the linear interpolation between two points above zero\\r\\n            // cannot go below zero\\r\\n            return\\r\\n                shortRate.sub(\\r\\n                    // This is reversed to keep it it positive\\r\\n                    (shortRate - longRate)\\r\\n                        .mul(assetMaturity - shortMaturity)\\r\\n                    // No underflow here, checked above\\r\\n                        .div(longMaturity - shortMaturity)\\r\\n                );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Gets an oracle rate given any valid maturity.\\r\\n    function calculateOracleRate(\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime\\r\\n    ) internal view returns (uint256) {\\r\\n        (uint256 marketIndex, bool idiosyncratic) =\\r\\n            DateTime.getMarketIndex(cashGroup.maxMarketIndex, maturity, blockTime);\\r\\n        uint256 timeWindow = getRateOracleTimeWindow(cashGroup);\\r\\n\\r\\n        if (!idiosyncratic) {\\r\\n            return Market.getOracleRate(cashGroup.currencyId, maturity, timeWindow, blockTime);\\r\\n        } else {\\r\\n            uint256 referenceTime = DateTime.getReferenceTime(blockTime);\\r\\n            // DateTime.getMarketIndex returns the market that is past the maturity if idiosyncratic\\r\\n            uint256 longMaturity = referenceTime.add(DateTime.getTradedMarket(marketIndex));\\r\\n            uint256 longRate =\\r\\n                Market.getOracleRate(cashGroup.currencyId, longMaturity, timeWindow, blockTime);\\r\\n\\r\\n            uint256 shortMaturity;\\r\\n            uint256 shortRate;\\r\\n            if (marketIndex == 1) {\\r\\n                // In this case the short market is the annualized asset supply rate\\r\\n                shortMaturity = blockTime;\\r\\n                shortRate = cashGroup.assetRate.getSupplyRate();\\r\\n            } else {\\r\\n                // Minimum value for marketIndex here is 2\\r\\n                shortMaturity = referenceTime.add(DateTime.getTradedMarket(marketIndex - 1));\\r\\n\\r\\n                shortRate = Market.getOracleRate(\\r\\n                    cashGroup.currencyId,\\r\\n                    shortMaturity,\\r\\n                    timeWindow,\\r\\n                    blockTime\\r\\n                );\\r\\n            }\\r\\n\\r\\n            return interpolateOracleRate(shortMaturity, longMaturity, shortRate, longRate, maturity);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getCashGroupStorageBytes(uint256 currencyId) private view returns (bytes32 data) {\\r\\n        mapping(uint256 => bytes32) storage store = LibStorage.getCashGroupStorage();\\r\\n        return store[currencyId];\\r\\n    }\\r\\n\\r\\n    /// @dev Helper method for validating maturities in ERC1155Action\\r\\n    function getMaxMarketIndex(uint256 currencyId) internal view returns (uint8) {\\r\\n        bytes32 data = _getCashGroupStorageBytes(currencyId);\\r\\n        return uint8(data[MARKET_INDEX_BIT]);\\r\\n    }\\r\\n\\r\\n    /// @notice Checks all cash group settings for invalid values and sets them into storage\\r\\n    function setCashGroupStorage(uint256 currencyId, CashGroupSettings calldata cashGroup)\\r\\n        internal\\r\\n    {\\r\\n        // Due to the requirements of the yield curve we do not allow a cash group to have solely a 3 month market.\\r\\n        // The reason is that borrowers will not have a further maturity to roll from their 3 month fixed to a 6 month\\r\\n        // fixed. It also complicates the logic in the nToken initialization method. Additionally, we cannot have cash\\r\\n        // groups with 0 market index, it has no effect.\\r\\n        require(2 <= cashGroup.maxMarketIndex && cashGroup.maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX,\\r\\n            \\\"CG: invalid market index\\\"\\r\\n        );\\r\\n        require(\\r\\n            cashGroup.reserveFeeShare <= Constants.PERCENTAGE_DECIMALS,\\r\\n            \\\"CG: invalid reserve share\\\"\\r\\n        );\\r\\n        require(cashGroup.liquidityTokenHaircuts.length == cashGroup.maxMarketIndex);\\r\\n        require(cashGroup.rateScalars.length == cashGroup.maxMarketIndex);\\r\\n        // This is required so that fCash liquidation can proceed correctly\\r\\n        require(cashGroup.liquidationfCashHaircut5BPS < cashGroup.fCashHaircut5BPS);\\r\\n        require(cashGroup.liquidationDebtBuffer5BPS < cashGroup.debtBuffer5BPS);\\r\\n\\r\\n        // Market indexes cannot decrease or they will leave fCash assets stranded in the future with no valuation curve\\r\\n        uint8 previousMaxMarketIndex = getMaxMarketIndex(currencyId);\\r\\n        require(\\r\\n            previousMaxMarketIndex <= cashGroup.maxMarketIndex,\\r\\n            \\\"CG: market index cannot decrease\\\"\\r\\n        );\\r\\n\\r\\n        // Per cash group settings\\r\\n        bytes32 data =\\r\\n            (bytes32(uint256(cashGroup.maxMarketIndex)) |\\r\\n                (bytes32(uint256(cashGroup.rateOracleTimeWindow5Min)) << RATE_ORACLE_TIME_WINDOW) |\\r\\n                (bytes32(uint256(cashGroup.totalFeeBPS)) << TOTAL_FEE) |\\r\\n                (bytes32(uint256(cashGroup.reserveFeeShare)) << RESERVE_FEE_SHARE) |\\r\\n                (bytes32(uint256(cashGroup.debtBuffer5BPS)) << DEBT_BUFFER) |\\r\\n                (bytes32(uint256(cashGroup.fCashHaircut5BPS)) << FCASH_HAIRCUT) |\\r\\n                (bytes32(uint256(cashGroup.settlementPenaltyRate5BPS)) << SETTLEMENT_PENALTY) |\\r\\n                (bytes32(uint256(cashGroup.liquidationfCashHaircut5BPS)) <<\\r\\n                    LIQUIDATION_FCASH_HAIRCUT) |\\r\\n                (bytes32(uint256(cashGroup.liquidationDebtBuffer5BPS)) << LIQUIDATION_DEBT_BUFFER));\\r\\n\\r\\n        // Per market group settings\\r\\n        for (uint256 i = 0; i < cashGroup.liquidityTokenHaircuts.length; i++) {\\r\\n            require(\\r\\n                cashGroup.liquidityTokenHaircuts[i] <= Constants.PERCENTAGE_DECIMALS,\\r\\n                \\\"CG: invalid token haircut\\\"\\r\\n            );\\r\\n\\r\\n            data =\\r\\n                data |\\r\\n                (bytes32(uint256(cashGroup.liquidityTokenHaircuts[i])) <<\\r\\n                    (LIQUIDITY_TOKEN_HAIRCUT + i * 8));\\r\\n        }\\r\\n\\r\\n        for (uint256 i = 0; i < cashGroup.rateScalars.length; i++) {\\r\\n            // Causes a divide by zero error\\r\\n            require(cashGroup.rateScalars[i] != 0, \\\"CG: invalid rate scalar\\\");\\r\\n            data = data | (bytes32(uint256(cashGroup.rateScalars[i])) << (RATE_SCALAR + i * 8));\\r\\n        }\\r\\n\\r\\n        mapping(uint256 => bytes32) storage store = LibStorage.getCashGroupStorage();\\r\\n        store[currencyId] = data;\\r\\n    }\\r\\n\\r\\n    /// @notice Deserialize the cash group storage bytes into a user friendly object\\r\\n    function deserializeCashGroupStorage(uint256 currencyId)\\r\\n        internal\\r\\n        view\\r\\n        returns (CashGroupSettings memory)\\r\\n    {\\r\\n        bytes32 data = _getCashGroupStorageBytes(currencyId);\\r\\n        uint8 maxMarketIndex = uint8(data[MARKET_INDEX_BIT]);\\r\\n        uint8[] memory tokenHaircuts = new uint8[](uint256(maxMarketIndex));\\r\\n        uint8[] memory rateScalars = new uint8[](uint256(maxMarketIndex));\\r\\n\\r\\n        for (uint8 i = 0; i < maxMarketIndex; i++) {\\r\\n            tokenHaircuts[i] = uint8(data[LIQUIDITY_TOKEN_HAIRCUT_FIRST_BIT - i]);\\r\\n            rateScalars[i] = uint8(data[RATE_SCALAR_FIRST_BIT - i]);\\r\\n        }\\r\\n\\r\\n        return\\r\\n            CashGroupSettings({\\r\\n                maxMarketIndex: maxMarketIndex,\\r\\n                rateOracleTimeWindow5Min: uint8(data[RATE_ORACLE_TIME_WINDOW_BIT]),\\r\\n                totalFeeBPS: uint8(data[TOTAL_FEE_BIT]),\\r\\n                reserveFeeShare: uint8(data[RESERVE_FEE_SHARE_BIT]),\\r\\n                debtBuffer5BPS: uint8(data[DEBT_BUFFER_BIT]),\\r\\n                fCashHaircut5BPS: uint8(data[FCASH_HAIRCUT_BIT]),\\r\\n                settlementPenaltyRate5BPS: uint8(data[SETTLEMENT_PENALTY_BIT]),\\r\\n                liquidationfCashHaircut5BPS: uint8(data[LIQUIDATION_FCASH_HAIRCUT_BIT]),\\r\\n                liquidationDebtBuffer5BPS: uint8(data[LIQUIDATION_DEBT_BUFFER_BIT]),\\r\\n                liquidityTokenHaircuts: tokenHaircuts,\\r\\n                rateScalars: rateScalars\\r\\n            });\\r\\n    }\\r\\n\\r\\n    function _buildCashGroup(uint16 currencyId, AssetRateParameters memory assetRate)\\r\\n        private\\r\\n        view\\r\\n        returns (CashGroupParameters memory)\\r\\n    {\\r\\n        bytes32 data = _getCashGroupStorageBytes(currencyId);\\r\\n        uint256 maxMarketIndex = uint8(data[MARKET_INDEX_BIT]);\\r\\n\\r\\n        return\\r\\n            CashGroupParameters({\\r\\n                currencyId: currencyId,\\r\\n                maxMarketIndex: maxMarketIndex,\\r\\n                assetRate: assetRate,\\r\\n                data: data\\r\\n            });\\r\\n    }\\r\\n\\r\\n    /// @notice Builds a cash group using a view version of the asset rate\\r\\n    function buildCashGroupView(uint16 currencyId)\\r\\n        internal\\r\\n        view\\r\\n        returns (CashGroupParameters memory)\\r\\n    {\\r\\n        AssetRateParameters memory assetRate = AssetRate.buildAssetRateView(currencyId);\\r\\n        return _buildCashGroup(currencyId, assetRate);\\r\\n    }\\r\\n\\r\\n    /// @notice Builds a cash group using a stateful version of the asset rate\\r\\n    function buildCashGroupStateful(uint16 currencyId)\\r\\n        internal\\r\\n        returns (CashGroupParameters memory)\\r\\n    {\\r\\n        AssetRateParameters memory assetRate = AssetRate.buildAssetRateStateful(currencyId);\\r\\n        return _buildCashGroup(currencyId, assetRate);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/nToken/nTokenHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./nTokenSupply.sol\\\";\\r\\nimport \\\"../markets/CashGroup.sol\\\";\\r\\nimport \\\"../markets/AssetRate.sol\\\";\\r\\nimport \\\"../portfolio/PortfolioHandler.sol\\\";\\r\\nimport \\\"../balances/BalanceHandler.sol\\\";\\r\\nimport \\\"../../global/LibStorage.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary nTokenHandler {\\r\\n    using SafeInt256 for int256;\\r\\n\\r\\n    /// @dev Mirror of the value in LibStorage, solidity compiler does not allow assigning\\r\\n    /// two constants to each other.\\r\\n    uint256 private constant NUM_NTOKEN_MARKET_FACTORS = 14;\\r\\n\\r\\n    /// @notice Returns an account context object that is specific to nTokens.\\r\\n    function getNTokenContext(address tokenAddress)\\r\\n        internal\\r\\n        view\\r\\n        returns (\\r\\n            uint16 currencyId,\\r\\n            uint256 incentiveAnnualEmissionRate,\\r\\n            uint256 lastInitializedTime,\\r\\n            uint8 assetArrayLength,\\r\\n            bytes5 parameters\\r\\n        )\\r\\n    {\\r\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\r\\n        nTokenContext storage context = store[tokenAddress];\\r\\n\\r\\n        currencyId = context.currencyId;\\r\\n        incentiveAnnualEmissionRate = context.incentiveAnnualEmissionRate;\\r\\n        lastInitializedTime = context.lastInitializedTime;\\r\\n        assetArrayLength = context.assetArrayLength;\\r\\n        parameters = context.nTokenParameters;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the nToken token address for a given currency\\r\\n    function nTokenAddress(uint256 currencyId) internal view returns (address tokenAddress) {\\r\\n        mapping(uint256 => address) storage store = LibStorage.getNTokenAddressStorage();\\r\\n        return store[currencyId];\\r\\n    }\\r\\n\\r\\n    /// @notice Called by governance to set the nToken token address and its reverse lookup. Cannot be\\r\\n    /// reset once this is set.\\r\\n    function setNTokenAddress(uint16 currencyId, address tokenAddress) internal {\\r\\n        mapping(uint256 => address) storage addressStore = LibStorage.getNTokenAddressStorage();\\r\\n        require(addressStore[currencyId] == address(0), \\\"PT: token address exists\\\");\\r\\n\\r\\n        mapping(address => nTokenContext) storage contextStore = LibStorage.getNTokenContextStorage();\\r\\n        nTokenContext storage context = contextStore[tokenAddress];\\r\\n        require(context.currencyId == 0, \\\"PT: currency exists\\\");\\r\\n\\r\\n        // This will initialize all other context slots to zero\\r\\n        context.currencyId = currencyId;\\r\\n        addressStore[currencyId] = tokenAddress;\\r\\n    }\\r\\n\\r\\n    /// @notice Set nToken token collateral parameters\\r\\n    function setNTokenCollateralParameters(\\r\\n        address tokenAddress,\\r\\n        uint8 residualPurchaseIncentive10BPS,\\r\\n        uint8 pvHaircutPercentage,\\r\\n        uint8 residualPurchaseTimeBufferHours,\\r\\n        uint8 cashWithholdingBuffer10BPS,\\r\\n        uint8 liquidationHaircutPercentage\\r\\n    ) internal {\\r\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\r\\n        nTokenContext storage context = store[tokenAddress];\\r\\n\\r\\n        require(liquidationHaircutPercentage <= Constants.PERCENTAGE_DECIMALS, \\\"Invalid haircut\\\");\\r\\n        // The pv haircut percentage must be less than the liquidation percentage or else liquidators will not\\r\\n        // get profit for liquidating nToken.\\r\\n        require(pvHaircutPercentage < liquidationHaircutPercentage, \\\"Invalid pv haircut\\\");\\r\\n        // Ensure that the cash withholding buffer is greater than the residual purchase incentive or\\r\\n        // the nToken may not have enough cash to pay accounts to buy its negative ifCash\\r\\n        require(residualPurchaseIncentive10BPS <= cashWithholdingBuffer10BPS, \\\"Invalid discounts\\\");\\r\\n\\r\\n        bytes5 parameters =\\r\\n            (bytes5(uint40(residualPurchaseIncentive10BPS)) |\\r\\n            (bytes5(uint40(pvHaircutPercentage)) << 8) |\\r\\n            (bytes5(uint40(residualPurchaseTimeBufferHours)) << 16) |\\r\\n            (bytes5(uint40(cashWithholdingBuffer10BPS)) << 24) |\\r\\n            (bytes5(uint40(liquidationHaircutPercentage)) << 32));\\r\\n\\r\\n        // Set the parameters\\r\\n        context.nTokenParameters = parameters;\\r\\n    }\\r\\n\\r\\n    /// @notice Sets a secondary rewarder contract on an nToken so that incentives can come from a different\\r\\n    /// contract, aside from the native NOTE token incentives.\\r\\n    function setSecondaryRewarder(\\r\\n        uint16 currencyId,\\r\\n        IRewarder rewarder\\r\\n    ) internal {\\r\\n        address tokenAddress = nTokenAddress(currencyId);\\r\\n        // nToken must exist for a secondary rewarder\\r\\n        require(tokenAddress != address(0));\\r\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\r\\n        nTokenContext storage context = store[tokenAddress];\\r\\n\\r\\n        // Setting the rewarder to address(0) will disable it. We use a context setting here so that\\r\\n        // we can save a storage read before getting the rewarder\\r\\n        context.hasSecondaryRewarder = (address(rewarder) != address(0));\\r\\n        LibStorage.getSecondaryIncentiveRewarder()[tokenAddress] = rewarder;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the secondary rewarder if it is set\\r\\n    function getSecondaryRewarder(address tokenAddress) internal view returns (IRewarder) {\\r\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\r\\n        nTokenContext storage context = store[tokenAddress];\\r\\n        \\r\\n        if (context.hasSecondaryRewarder) {\\r\\n            return LibStorage.getSecondaryIncentiveRewarder()[tokenAddress];\\r\\n        } else {\\r\\n            return IRewarder(address(0));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setArrayLengthAndInitializedTime(\\r\\n        address tokenAddress,\\r\\n        uint8 arrayLength,\\r\\n        uint256 lastInitializedTime\\r\\n    ) internal {\\r\\n        require(lastInitializedTime >= 0 && uint256(lastInitializedTime) < type(uint32).max); // dev: next settle time overflow\\r\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\r\\n        nTokenContext storage context = store[tokenAddress];\\r\\n        context.lastInitializedTime = uint32(lastInitializedTime);\\r\\n        context.assetArrayLength = arrayLength;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the array of deposit shares and leverage thresholds for nTokens\\r\\n    function getDepositParameters(uint256 currencyId, uint256 maxMarketIndex)\\r\\n        internal\\r\\n        view\\r\\n        returns (int256[] memory depositShares, int256[] memory leverageThresholds)\\r\\n    {\\r\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenDepositStorage();\\r\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage depositParameters = store[currencyId];\\r\\n        (depositShares, leverageThresholds) = _getParameters(depositParameters, maxMarketIndex, false);\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the deposit parameters\\r\\n    /// @dev We pack the values in alternating between the two parameters into either one or two\\r\\n    // storage slots depending on the number of markets. This is to save storage reads when we use the parameters.\\r\\n    function setDepositParameters(\\r\\n        uint256 currencyId,\\r\\n        uint32[] calldata depositShares,\\r\\n        uint32[] calldata leverageThresholds\\r\\n    ) internal {\\r\\n        require(\\r\\n            depositShares.length <= Constants.MAX_TRADED_MARKET_INDEX,\\r\\n            \\\"PT: deposit share length\\\"\\r\\n        );\\r\\n        require(depositShares.length == leverageThresholds.length, \\\"PT: leverage share length\\\");\\r\\n\\r\\n        uint256 shareSum;\\r\\n        for (uint256 i; i < depositShares.length; i++) {\\r\\n            // This cannot overflow in uint 256 with 9 max slots\\r\\n            shareSum = shareSum + depositShares[i];\\r\\n            require(\\r\\n                leverageThresholds[i] > 0 && leverageThresholds[i] < Constants.RATE_PRECISION,\\r\\n                \\\"PT: leverage threshold\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // Total deposit share must add up to 100%\\r\\n        require(shareSum == uint256(Constants.DEPOSIT_PERCENT_BASIS), \\\"PT: deposit shares sum\\\");\\r\\n\\r\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenDepositStorage();\\r\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage depositParameters = store[currencyId];\\r\\n        _setParameters(depositParameters, depositShares, leverageThresholds);\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the initialization parameters for the markets, these are read only when markets\\r\\n    /// are initialized\\r\\n    function setInitializationParameters(\\r\\n        uint256 currencyId,\\r\\n        uint32[] calldata annualizedAnchorRates,\\r\\n        uint32[] calldata proportions\\r\\n    ) internal {\\r\\n        require(annualizedAnchorRates.length <= Constants.MAX_TRADED_MARKET_INDEX, \\\"PT: annualized anchor rates length\\\");\\r\\n        require(proportions.length == annualizedAnchorRates.length, \\\"PT: proportions length\\\");\\r\\n\\r\\n        for (uint256 i; i < proportions.length; i++) {\\r\\n            // Proportions must be between zero and the rate precision\\r\\n            require(annualizedAnchorRates[i] > 0, \\\"NT: anchor rate zero\\\");\\r\\n            require(\\r\\n                proportions[i] > 0 && proportions[i] < Constants.RATE_PRECISION,\\r\\n                \\\"PT: invalid proportion\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenInitStorage();\\r\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage initParameters = store[currencyId];\\r\\n        _setParameters(initParameters, annualizedAnchorRates, proportions);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the array of initialization parameters for a given currency.\\r\\n    function getInitializationParameters(uint256 currencyId, uint256 maxMarketIndex)\\r\\n        internal\\r\\n        view\\r\\n        returns (int256[] memory annualizedAnchorRates, int256[] memory proportions)\\r\\n    {\\r\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenInitStorage();\\r\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage initParameters = store[currencyId];\\r\\n        (annualizedAnchorRates, proportions) = _getParameters(initParameters, maxMarketIndex, true);\\r\\n    }\\r\\n\\r\\n    function _getParameters(\\r\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage slot,\\r\\n        uint256 maxMarketIndex,\\r\\n        bool noUnset\\r\\n    ) private view returns (int256[] memory, int256[] memory) {\\r\\n        uint256 index = 0;\\r\\n        int256[] memory array1 = new int256[](maxMarketIndex);\\r\\n        int256[] memory array2 = new int256[](maxMarketIndex);\\r\\n        for (uint256 i; i < maxMarketIndex; i++) {\\r\\n            array1[i] = slot[index];\\r\\n            index++;\\r\\n            array2[i] = slot[index];\\r\\n            index++;\\r\\n\\r\\n            if (noUnset) {\\r\\n                require(array1[i] > 0 && array2[i] > 0, \\\"PT: init value zero\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return (array1, array2);\\r\\n    }\\r\\n\\r\\n    function _setParameters(\\r\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage slot,\\r\\n        uint32[] calldata array1,\\r\\n        uint32[] calldata array2\\r\\n    ) private {\\r\\n        uint256 index = 0;\\r\\n        for (uint256 i = 0; i < array1.length; i++) {\\r\\n            slot[index] = array1[i];\\r\\n            index++;\\r\\n\\r\\n            slot[index] = array2[i];\\r\\n            index++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function loadNTokenPortfolioNoCashGroup(nTokenPortfolio memory nToken, uint16 currencyId)\\r\\n        internal\\r\\n        view\\r\\n    {\\r\\n        nToken.tokenAddress = nTokenAddress(currencyId);\\r\\n        // prettier-ignore\\r\\n        (\\r\\n            /* currencyId */,\\r\\n            /* incentiveRate */,\\r\\n            uint256 lastInitializedTime,\\r\\n            uint8 assetArrayLength,\\r\\n            bytes5 parameters\\r\\n        ) = getNTokenContext(nToken.tokenAddress);\\r\\n\\r\\n        // prettier-ignore\\r\\n        (\\r\\n            uint256 totalSupply,\\r\\n            /* accumulatedNOTEPerNToken */,\\r\\n            /* lastAccumulatedTime */\\r\\n        ) = nTokenSupply.getStoredNTokenSupplyFactors(nToken.tokenAddress);\\r\\n\\r\\n        nToken.lastInitializedTime = lastInitializedTime;\\r\\n        nToken.totalSupply = int256(totalSupply);\\r\\n        nToken.parameters = parameters;\\r\\n\\r\\n        nToken.portfolioState = PortfolioHandler.buildPortfolioState(\\r\\n            nToken.tokenAddress,\\r\\n            assetArrayLength,\\r\\n            0\\r\\n        );\\r\\n\\r\\n        // prettier-ignore\\r\\n        (\\r\\n            nToken.cashBalance,\\r\\n            /* nTokenBalance */,\\r\\n            /* lastClaimTime */,\\r\\n            /* accountIncentiveDebt */\\r\\n        ) = BalanceHandler.getBalanceStorage(nToken.tokenAddress, currencyId);\\r\\n    }\\r\\n\\r\\n    /// @notice Uses buildCashGroupStateful\\r\\n    function loadNTokenPortfolioStateful(nTokenPortfolio memory nToken, uint16 currencyId)\\r\\n        internal\\r\\n    {\\r\\n        loadNTokenPortfolioNoCashGroup(nToken, currencyId);\\r\\n        nToken.cashGroup = CashGroup.buildCashGroupStateful(currencyId);\\r\\n    }\\r\\n\\r\\n    /// @notice Uses buildCashGroupView\\r\\n    function loadNTokenPortfolioView(nTokenPortfolio memory nToken, uint16 currencyId)\\r\\n        internal\\r\\n        view\\r\\n    {\\r\\n        loadNTokenPortfolioNoCashGroup(nToken, currencyId);\\r\\n        nToken.cashGroup = CashGroup.buildCashGroupView(currencyId);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the next settle time for the nToken which is 1 quarter away\\r\\n    function getNextSettleTime(nTokenPortfolio memory nToken) internal pure returns (uint256) {\\r\\n        if (nToken.lastInitializedTime == 0) return 0;\\r\\n        return DateTime.getReferenceTime(nToken.lastInitializedTime) + Constants.QUARTER;\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/nToken/nTokenSupply.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./nTokenHandler.sol\\\";\\r\\nimport \\\"../../global/LibStorage.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary nTokenSupply {\\r\\n    using SafeInt256 for int256;\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /// @notice Retrieves stored nToken supply and related factors. Do not use accumulatedNOTEPerNToken for calculating\\r\\n    /// incentives! Use `getUpdatedAccumulatedNOTEPerNToken` instead.\\r\\n    function getStoredNTokenSupplyFactors(address tokenAddress)\\r\\n        internal\\r\\n        view\\r\\n        returns (\\r\\n            uint256 totalSupply,\\r\\n            uint256 accumulatedNOTEPerNToken,\\r\\n            uint256 lastAccumulatedTime\\r\\n        )\\r\\n    {\\r\\n        mapping(address => nTokenTotalSupplyStorage) storage store = LibStorage.getNTokenTotalSupplyStorage();\\r\\n        nTokenTotalSupplyStorage storage nTokenStorage = store[tokenAddress];\\r\\n        totalSupply = nTokenStorage.totalSupply;\\r\\n        // NOTE: DO NOT USE THIS RETURNED VALUE FOR CALCULATING INCENTIVES. The accumulatedNOTEPerNToken\\r\\n        // must be updated given the block time. Use `getUpdatedAccumulatedNOTEPerNToken` instead\\r\\n        accumulatedNOTEPerNToken = nTokenStorage.accumulatedNOTEPerNToken;\\r\\n        lastAccumulatedTime = nTokenStorage.lastAccumulatedTime;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the updated accumulated NOTE per nToken for calculating incentives\\r\\n    function getUpdatedAccumulatedNOTEPerNToken(address tokenAddress, uint256 blockTime)\\r\\n        internal view\\r\\n        returns (\\r\\n            uint256 totalSupply,\\r\\n            uint256 accumulatedNOTEPerNToken,\\r\\n            uint256 lastAccumulatedTime\\r\\n        )\\r\\n    {\\r\\n        (\\r\\n            totalSupply,\\r\\n            accumulatedNOTEPerNToken,\\r\\n            lastAccumulatedTime\\r\\n        ) = getStoredNTokenSupplyFactors(tokenAddress);\\r\\n\\r\\n        // nToken totalSupply is never allowed to drop to zero but we check this here to avoid\\r\\n        // divide by zero errors during initialization. Also ensure that lastAccumulatedTime is not\\r\\n        // zero to avoid a massive accumulation amount on initialization.\\r\\n        if (blockTime > lastAccumulatedTime && lastAccumulatedTime > 0 && totalSupply > 0) {\\r\\n            // prettier-ignore\\r\\n            (\\r\\n                /* currencyId */,\\r\\n                uint256 emissionRatePerYear,\\r\\n                /* initializedTime */,\\r\\n                /* assetArrayLength */,\\r\\n                /* parameters */\\r\\n            ) = nTokenHandler.getNTokenContext(tokenAddress);\\r\\n\\r\\n            uint256 additionalNOTEAccumulatedPerNToken = _calculateAdditionalNOTE(\\r\\n                // Emission rate is denominated in whole tokens, scale to 1e8 decimals here\\r\\n                emissionRatePerYear.mul(uint256(Constants.INTERNAL_TOKEN_PRECISION)),\\r\\n                // Time since last accumulation (overflow checked above)\\r\\n                blockTime - lastAccumulatedTime,\\r\\n                totalSupply\\r\\n            );\\r\\n\\r\\n            accumulatedNOTEPerNToken = accumulatedNOTEPerNToken.add(additionalNOTEAccumulatedPerNToken);\\r\\n            require(accumulatedNOTEPerNToken < type(uint128).max); // dev: accumulated NOTE overflow\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice additionalNOTEPerNToken accumulated since last accumulation time in 1e18 precision\\r\\n    function _calculateAdditionalNOTE(\\r\\n        uint256 emissionRatePerYear,\\r\\n        uint256 timeSinceLastAccumulation,\\r\\n        uint256 totalSupply\\r\\n    )\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        // If we use 18 decimal places as the accumulation precision then we will overflow uint128 when\\r\\n        // a single nToken has accumulated 3.4 x 10^20 NOTE tokens. This isn't possible since the max\\r\\n        // NOTE that can accumulate is 10^16 (100 million NOTE in 1e8 precision) so we should be safe\\r\\n        // using 18 decimal places and uint128 storage slot\\r\\n\\r\\n        // timeSinceLastAccumulation (SECONDS)\\r\\n        // accumulatedNOTEPerSharePrecision (1e18)\\r\\n        // emissionRatePerYear (INTERNAL_TOKEN_PRECISION)\\r\\n        // DIVIDE BY\\r\\n        // YEAR (SECONDS)\\r\\n        // totalSupply (INTERNAL_TOKEN_PRECISION)\\r\\n        return timeSinceLastAccumulation\\r\\n            .mul(Constants.INCENTIVE_ACCUMULATION_PRECISION)\\r\\n            .mul(emissionRatePerYear)\\r\\n            .div(Constants.YEAR)\\r\\n            // totalSupply > 0 is checked in the calling function\\r\\n            .div(totalSupply);\\r\\n    }\\r\\n\\r\\n    /// @notice Updates the nToken token supply amount when minting or redeeming.\\r\\n    /// @param tokenAddress address of the nToken\\r\\n    /// @param netChange positive or negative change to the total nToken supply\\r\\n    /// @param blockTime current block time\\r\\n    /// @return accumulatedNOTEPerNToken updated to the given block time\\r\\n    function changeNTokenSupply(\\r\\n        address tokenAddress,\\r\\n        int256 netChange,\\r\\n        uint256 blockTime\\r\\n    ) internal returns (uint256) {\\r\\n        (\\r\\n            uint256 totalSupply,\\r\\n            uint256 accumulatedNOTEPerNToken,\\r\\n            /* uint256 lastAccumulatedTime */\\r\\n        ) = getUpdatedAccumulatedNOTEPerNToken(tokenAddress, blockTime);\\r\\n\\r\\n        // Update storage variables\\r\\n        mapping(address => nTokenTotalSupplyStorage) storage store = LibStorage.getNTokenTotalSupplyStorage();\\r\\n        nTokenTotalSupplyStorage storage nTokenStorage = store[tokenAddress];\\r\\n\\r\\n        int256 newTotalSupply = int256(totalSupply).add(netChange);\\r\\n        // We allow newTotalSupply to equal zero here even though it is prevented from being redeemed down to\\r\\n        // exactly zero by other internal logic inside nTokenRedeem. This is meant to be purely an overflow check.\\r\\n        require(0 <= newTotalSupply && uint256(newTotalSupply) < type(uint96).max); // dev: nToken supply overflow\\r\\n\\r\\n        nTokenStorage.totalSupply = uint96(newTotalSupply);\\r\\n        // NOTE: overflow checked inside getUpdatedAccumulatedNOTEPerNToken so that behavior here mirrors what\\r\\n        // the user would see if querying the view function\\r\\n        nTokenStorage.accumulatedNOTEPerNToken = uint128(accumulatedNOTEPerNToken);\\r\\n\\r\\n        require(blockTime < type(uint32).max); // dev: block time overflow\\r\\n        nTokenStorage.lastAccumulatedTime = uint32(blockTime);\\r\\n\\r\\n        return accumulatedNOTEPerNToken;\\r\\n    }\\r\\n\\r\\n    /// @notice Called by governance to set the new emission rate\\r\\n    function setIncentiveEmissionRate(address tokenAddress, uint32 newEmissionsRate, uint256 blockTime) internal {\\r\\n        // Ensure that the accumulatedNOTEPerNToken updates to the current block time before we update the\\r\\n        // emission rate\\r\\n        changeNTokenSupply(tokenAddress, 0, blockTime);\\r\\n\\r\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\r\\n        nTokenContext storage context = store[tokenAddress];\\r\\n        context.incentiveAnnualEmissionRate = newEmissionsRate;\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/internal/balances/TokenHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../global/LibStorage.sol\\\";\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../../global/Deployments.sol\\\";\\r\\nimport \\\"./protocols/AaveHandler.sol\\\";\\r\\nimport \\\"./protocols/CompoundHandler.sol\\\";\\r\\nimport \\\"./protocols/GenericToken.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\n\\r\\n/// @notice Handles all external token transfers and events\\r\\nlibrary TokenHandler {\\r\\n    using SafeInt256 for int256;\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    function setMaxCollateralBalance(uint256 currencyId, uint72 maxCollateralBalance) internal {\\r\\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\\r\\n        TokenStorage storage tokenStorage = store[currencyId][false];\\r\\n        tokenStorage.maxCollateralBalance = maxCollateralBalance;\\r\\n    } \\r\\n\\r\\n    function getAssetToken(uint256 currencyId) internal view returns (Token memory) {\\r\\n        return _getToken(currencyId, false);\\r\\n    }\\r\\n\\r\\n    function getUnderlyingToken(uint256 currencyId) internal view returns (Token memory) {\\r\\n        return _getToken(currencyId, true);\\r\\n    }\\r\\n\\r\\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\\r\\n    /// the underlying token. (These may not always exist)\\r\\n    function _getToken(uint256 currencyId, bool underlying) private view returns (Token memory) {\\r\\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\\r\\n        TokenStorage storage tokenStorage = store[currencyId][underlying];\\r\\n\\r\\n        return\\r\\n            Token({\\r\\n                tokenAddress: tokenStorage.tokenAddress,\\r\\n                hasTransferFee: tokenStorage.hasTransferFee,\\r\\n                // No overflow, restricted on storage\\r\\n                decimals: int256(10**tokenStorage.decimalPlaces),\\r\\n                tokenType: tokenStorage.tokenType,\\r\\n                maxCollateralBalance: tokenStorage.maxCollateralBalance\\r\\n            });\\r\\n    }\\r\\n\\r\\n    /// @notice Sets a token for a currency id.\\r\\n    function setToken(\\r\\n        uint256 currencyId,\\r\\n        bool underlying,\\r\\n        TokenStorage memory tokenStorage\\r\\n    ) internal {\\r\\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\\r\\n\\r\\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\\r\\n            // Hardcoded parameters for ETH just to make sure we don't get it wrong.\\r\\n            TokenStorage storage ts = store[currencyId][true];\\r\\n            ts.tokenAddress = address(0);\\r\\n            ts.hasTransferFee = false;\\r\\n            ts.tokenType = TokenType.Ether;\\r\\n            ts.decimalPlaces = Constants.ETH_DECIMAL_PLACES;\\r\\n            ts.maxCollateralBalance = 0;\\r\\n\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Check token address\\r\\n        require(tokenStorage.tokenAddress != address(0), \\\"TH: address is zero\\\");\\r\\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\\r\\n        // then we should explicitly upgrade this method to allow for a token to be changed.\\r\\n        Token memory token = _getToken(currencyId, underlying);\\r\\n        require(\\r\\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\\r\\n            \\\"TH: token cannot be reset\\\"\\r\\n        );\\r\\n\\r\\n        require(0 < tokenStorage.decimalPlaces \\r\\n            && tokenStorage.decimalPlaces <= Constants.MAX_DECIMAL_PLACES, \\\"TH: invalid decimals\\\");\\r\\n\\r\\n        // Validate token type\\r\\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\\r\\n        if (underlying) {\\r\\n            // Underlying tokens cannot have max collateral balances, the contract only has a balance temporarily\\r\\n            // during mint and redeem actions.\\r\\n            require(tokenStorage.maxCollateralBalance == 0); // dev: underlying cannot have max collateral balance\\r\\n            require(tokenStorage.tokenType == TokenType.UnderlyingToken); // dev: underlying token inconsistent\\r\\n        } else {\\r\\n            require(tokenStorage.tokenType != TokenType.UnderlyingToken); // dev: underlying token inconsistent\\r\\n        }\\r\\n\\r\\n        if (tokenStorage.tokenType == TokenType.cToken || tokenStorage.tokenType == TokenType.aToken) {\\r\\n            // Set the approval for the underlying so that we can mint cTokens or aTokens\\r\\n            Token memory underlyingToken = getUnderlyingToken(currencyId);\\r\\n\\r\\n            // cTokens call transfer from the tokenAddress, but aTokens use the LendingPool\\r\\n            // to initiate all transfers\\r\\n            address approvalAddress = tokenStorage.tokenType == TokenType.cToken ?\\r\\n                tokenStorage.tokenAddress :\\r\\n                address(LibStorage.getLendingPool().lendingPool);\\r\\n\\r\\n            // ERC20 tokens should return true on success for an approval, but Tether\\r\\n            // does not return a value here so we use the NonStandard interface here to\\r\\n            // check that the approval was successful.\\r\\n            IEIP20NonStandard(underlyingToken.tokenAddress).approve(\\r\\n                approvalAddress,\\r\\n                type(uint256).max\\r\\n            );\\r\\n            GenericToken.checkReturnCode();\\r\\n        }\\r\\n\\r\\n        store[currencyId][underlying] = tokenStorage;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice If a token is mintable then will mint it. At this point we expect to have the underlying\\r\\n     * balance in the contract already.\\r\\n     * @param assetToken the asset token to mint\\r\\n     * @param underlyingAmountExternal the amount of underlying to transfer to the mintable token\\r\\n     * @return the amount of asset tokens minted, will always be a positive integer\\r\\n     */\\r\\n    function mint(Token memory assetToken, uint16 currencyId, uint256 underlyingAmountExternal) internal returns (int256) {\\r\\n        // aTokens return the principal plus interest value when calling the balanceOf selector. We cannot use this\\r\\n        // value in internal accounting since it will not allow individual users to accrue aToken interest. Use the\\r\\n        // scaledBalanceOf function call instead for internal accounting.\\r\\n        bytes4 balanceOfSelector = assetToken.tokenType == TokenType.aToken ?\\r\\n            AaveHandler.scaledBalanceOfSelector :\\r\\n            GenericToken.defaultBalanceOfSelector;\\r\\n        \\r\\n        uint256 startingBalance = GenericToken.checkBalanceViaSelector(assetToken.tokenAddress, address(this), balanceOfSelector);\\r\\n\\r\\n        if (assetToken.tokenType == TokenType.aToken) {\\r\\n            Token memory underlyingToken = getUnderlyingToken(currencyId);\\r\\n            AaveHandler.mint(underlyingToken, underlyingAmountExternal);\\r\\n        } else if (assetToken.tokenType == TokenType.cToken) {\\r\\n            CompoundHandler.mint(assetToken, underlyingAmountExternal);\\r\\n        } else if (assetToken.tokenType == TokenType.cETH) {\\r\\n            CompoundHandler.mintCETH(assetToken);\\r\\n        } else {\\r\\n            revert(); // dev: non mintable token\\r\\n        }\\r\\n\\r\\n        uint256 endingBalance = GenericToken.checkBalanceViaSelector(assetToken.tokenAddress, address(this), balanceOfSelector);\\r\\n        // This is the starting and ending balance in external precision\\r\\n        return SafeInt256.toInt(endingBalance.sub(startingBalance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice If a token is redeemable to underlying will redeem it and transfer the underlying balance\\r\\n     * to the account\\r\\n     * @param assetToken asset token to redeem\\r\\n     * @param currencyId the currency id of the token\\r\\n     * @param account account to transfer the underlying to\\r\\n     * @param assetAmountExternal the amount to transfer in asset token denomination and external precision\\r\\n     * @return the actual amount of underlying tokens transferred. this is used as a return value back to the\\r\\n     * user, is not used for internal accounting purposes\\r\\n     */\\r\\n    function redeem(\\r\\n        Token memory assetToken,\\r\\n        uint256 currencyId,\\r\\n        address account,\\r\\n        uint256 assetAmountExternal\\r\\n    ) internal returns (int256) {\\r\\n        uint256 transferAmount;\\r\\n        if (assetToken.tokenType == TokenType.cETH) {\\r\\n            transferAmount = CompoundHandler.redeemCETH(assetToken, account, assetAmountExternal);\\r\\n        } else {\\r\\n            Token memory underlyingToken = getUnderlyingToken(currencyId);\\r\\n            if (assetToken.tokenType == TokenType.aToken) {\\r\\n                transferAmount = AaveHandler.redeem(underlyingToken, account, assetAmountExternal);\\r\\n            } else if (assetToken.tokenType == TokenType.cToken) {\\r\\n                transferAmount = CompoundHandler.redeem(assetToken, underlyingToken, account, assetAmountExternal);\\r\\n            } else {\\r\\n                revert(); // dev: non redeemable token\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        // Use the negative value here to signify that assets have left the protocol\\r\\n        return SafeInt256.toInt(transferAmount).neg();\\r\\n    }\\r\\n\\r\\n    /// @notice Handles transfers into and out of the system denominated in the external token decimal\\r\\n    /// precision.\\r\\n    function transfer(\\r\\n        Token memory token,\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        int256 netTransferExternal\\r\\n    ) internal returns (int256 actualTransferExternal) {\\r\\n        // This will be true in all cases except for deposits where the token has transfer fees. For\\r\\n        // aTokens this value is set before convert from scaled balances to principal plus interest\\r\\n        actualTransferExternal = netTransferExternal;\\r\\n\\r\\n        if (token.tokenType == TokenType.aToken) {\\r\\n            Token memory underlyingToken = getUnderlyingToken(currencyId);\\r\\n            // aTokens need to be converted when we handle the transfer since the external balance format\\r\\n            // is not the same as the internal balance format that we use\\r\\n            netTransferExternal = AaveHandler.convertFromScaledBalanceExternal(\\r\\n                underlyingToken.tokenAddress,\\r\\n                netTransferExternal\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (netTransferExternal > 0) {\\r\\n            // Deposits must account for transfer fees.\\r\\n            int256 netDeposit = _deposit(token, account, uint256(netTransferExternal));\\r\\n            // If an aToken has a transfer fee this will still return a balance figure\\r\\n            // in scaledBalanceOf terms due to the selector\\r\\n            if (token.hasTransferFee) actualTransferExternal = netDeposit;\\r\\n        } else if (token.tokenType == TokenType.Ether) {\\r\\n            // netTransferExternal can only be negative or zero at this point\\r\\n            GenericToken.transferNativeTokenOut(account, uint256(netTransferExternal.neg()));\\r\\n        } else {\\r\\n            GenericToken.safeTransferOut(\\r\\n                token.tokenAddress,\\r\\n                account,\\r\\n                // netTransferExternal is zero or negative here\\r\\n                uint256(netTransferExternal.neg())\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Handles token deposits into Notional. If there is a transfer fee then we must\\r\\n    /// calculate the net balance after transfer. Amounts are denominated in the destination token's\\r\\n    /// precision.\\r\\n    function _deposit(\\r\\n        Token memory token,\\r\\n        address account,\\r\\n        uint256 amount\\r\\n    ) private returns (int256) {\\r\\n        uint256 startingBalance;\\r\\n        uint256 endingBalance;\\r\\n        bytes4 balanceOfSelector = token.tokenType == TokenType.aToken ?\\r\\n            AaveHandler.scaledBalanceOfSelector :\\r\\n            GenericToken.defaultBalanceOfSelector;\\r\\n\\r\\n        if (token.hasTransferFee) {\\r\\n            startingBalance = GenericToken.checkBalanceViaSelector(token.tokenAddress, address(this), balanceOfSelector);\\r\\n        }\\r\\n\\r\\n        GenericToken.safeTransferIn(token.tokenAddress, account, amount);\\r\\n\\r\\n        if (token.hasTransferFee || token.maxCollateralBalance > 0) {\\r\\n            // If aTokens have a max collateral balance then it will be applied against the scaledBalanceOf. This is probably\\r\\n            // the correct behavior because if collateral accrues interest over time we should not somehow go over the\\r\\n            // maxCollateralBalance due to the passage of time.\\r\\n            endingBalance = GenericToken.checkBalanceViaSelector(token.tokenAddress, address(this), balanceOfSelector);\\r\\n        }\\r\\n\\r\\n        if (token.maxCollateralBalance > 0) {\\r\\n            int256 internalPrecisionBalance = convertToInternal(token, SafeInt256.toInt(endingBalance));\\r\\n            // Max collateral balance is stored as uint72, no overflow\\r\\n            require(internalPrecisionBalance <= SafeInt256.toInt(token.maxCollateralBalance)); // dev: over max collateral balance\\r\\n        }\\r\\n\\r\\n        // Math is done in uint inside these statements and will revert on negative\\r\\n        if (token.hasTransferFee) {\\r\\n            return SafeInt256.toInt(endingBalance.sub(startingBalance));\\r\\n        } else {\\r\\n            return SafeInt256.toInt(amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {\\r\\n        // If token decimals > INTERNAL_TOKEN_PRECISION:\\r\\n        //  on deposit: resulting dust will accumulate to protocol\\r\\n        //  on withdraw: protocol may lose dust amount. However, withdraws are only calculated based\\r\\n        //    on a conversion from internal token precision to external token precision so therefore dust\\r\\n        //    amounts cannot be specified for withdraws.\\r\\n        // If token decimals < INTERNAL_TOKEN_PRECISION then this will add zeros to the\\r\\n        // end of amount and will not result in dust.\\r\\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\\r\\n        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);\\r\\n    }\\r\\n\\r\\n    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {\\r\\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\\r\\n        // If token decimals > INTERNAL_TOKEN_PRECISION then this will increase amount\\r\\n        // by adding a number of zeros to the end and will not result in dust.\\r\\n        // If token decimals < INTERNAL_TOKEN_PRECISION:\\r\\n        //  on deposit: Deposits are specified in external token precision and there is no loss of precision when\\r\\n        //      tokens are converted from external to internal precision\\r\\n        //  on withdraw: this calculation will round down such that the protocol retains the residual cash balance\\r\\n        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);\\r\\n    }\\r\\n\\r\\n    function transferIncentive(address account, uint256 tokensToTransfer) internal {\\r\\n        GenericToken.safeTransferOut(Deployments.NOTE_TOKEN_ADDRESS, account, tokensToTransfer);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/global/StorageLayoutV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./StorageLayoutV1.sol\\\";\\r\\n\\r\\ncontract StorageLayoutV2 is StorageLayoutV1 {\\r\\n    // Contract that manages the treasury and reserves\\r\\n    address internal treasuryManagerContract;\\r\\n\\r\\n    // Reserve buffers per currency, used in the TreasuryAction contract\\r\\n    mapping(uint256 => uint256) internal reserveBuffer;\\r\\n\\r\\n    // Pending owner used in the transfer ownership / claim ownership pattern\\r\\n    address internal pendingOwner;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/global/LibStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./Types.sol\\\";\\r\\nimport \\\"./Constants.sol\\\";\\r\\nimport \\\"../../interfaces/notional/IRewarder.sol\\\";\\r\\nimport \\\"../../interfaces/aave/ILendingPool.sol\\\";\\r\\n\\r\\nlibrary LibStorage {\\r\\n\\r\\n    /// @dev Offset for the initial slot in lib storage, gives us this number of storage slots\\r\\n    /// available in StorageLayoutV1 and all subsequent storage layouts that inherit from it.\\r\\n    uint256 private constant STORAGE_SLOT_BASE = 1000000;\\r\\n    /// @dev Set to MAX_TRADED_MARKET_INDEX * 2, Solidity does not allow assigning constants from imported values\\r\\n    uint256 private constant NUM_NTOKEN_MARKET_FACTORS = 14;\\r\\n    /// @dev Theoretical maximum for MAX_PORTFOLIO_ASSETS, however, we limit this to MAX_TRADED_MARKET_INDEX\\r\\n    /// in practice. It is possible to exceed that value during liquidation up to 14 potential assets.\\r\\n    uint256 private constant MAX_PORTFOLIO_ASSETS = 16;\\r\\n\\r\\n    /// @dev Storage IDs for storage buckets. Each id maps to an internal storage\\r\\n    /// slot used for a particular mapping\\r\\n    ///     WARNING: APPEND ONLY\\r\\n    enum StorageId {\\r\\n        Unused,\\r\\n        AccountStorage,\\r\\n        nTokenContext,\\r\\n        nTokenAddress,\\r\\n        nTokenDeposit,\\r\\n        nTokenInitialization,\\r\\n        Balance,\\r\\n        Token,\\r\\n        SettlementRate,\\r\\n        CashGroup,\\r\\n        Market,\\r\\n        AssetsBitmap,\\r\\n        ifCashBitmap,\\r\\n        PortfolioArray,\\r\\n        // WARNING: this nTokenTotalSupply storage object was used for a buggy version\\r\\n        // of the incentives calculation. It should only be used for accounts who have\\r\\n        // not claimed before the migration\\r\\n        nTokenTotalSupply_deprecated,\\r\\n        AssetRate,\\r\\n        ExchangeRate,\\r\\n        nTokenTotalSupply,\\r\\n        SecondaryIncentiveRewarder,\\r\\n        LendingPool\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from an account address to account context\\r\\n    function getAccountStorage() internal pure \\r\\n        returns (mapping(address => AccountContext) storage store) \\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.AccountStorage);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from an nToken address to nTokenContext\\r\\n    function getNTokenContextStorage() internal pure\\r\\n        returns (mapping(address => nTokenContext) storage store) \\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.nTokenContext);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from currency id to nTokenAddress\\r\\n    function getNTokenAddressStorage() internal pure\\r\\n        returns (mapping(uint256 => address) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.nTokenAddress);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from currency id to uint32 fixed length array of\\r\\n    /// deposit factors. Deposit shares and leverage thresholds are stored striped to\\r\\n    /// reduce the number of storage reads.\\r\\n    function getNTokenDepositStorage() internal pure\\r\\n        returns (mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.nTokenDeposit);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from currency id to fixed length array of initialization factors,\\r\\n    /// stored striped like deposit shares.\\r\\n    function getNTokenInitStorage() internal pure\\r\\n        returns (mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.nTokenInitialization);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from account to currencyId to it's balance storage for that currency\\r\\n    function getBalanceStorage() internal pure\\r\\n        returns (mapping(address => mapping(uint256 => BalanceStorage)) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.Balance);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from currency id to a boolean for underlying or asset token to\\r\\n    /// the TokenStorage\\r\\n    function getTokenStorage() internal pure\\r\\n        returns (mapping(uint256 => mapping(bool => TokenStorage)) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.Token);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from currency id to maturity to its corresponding SettlementRate\\r\\n    function getSettlementRateStorage() internal pure\\r\\n        returns (mapping(uint256 => mapping(uint256 => SettlementRateStorage)) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.SettlementRate);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from currency id to maturity to its tightly packed cash group parameters\\r\\n    function getCashGroupStorage() internal pure\\r\\n        returns (mapping(uint256 => bytes32) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.CashGroup);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from currency id to maturity to settlement date for a market\\r\\n    function getMarketStorage() internal pure\\r\\n        returns (mapping(uint256 => mapping(uint256 => mapping(uint256 => MarketStorage))) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.Market);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from account to currency id to its assets bitmap\\r\\n    function getAssetsBitmapStorage() internal pure\\r\\n        returns (mapping(address => mapping(uint256 => bytes32)) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.AssetsBitmap);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from account to currency id to its maturity to its corresponding ifCash balance\\r\\n    function getifCashBitmapStorage() internal pure\\r\\n        returns (mapping(address => mapping(uint256 => mapping(uint256 => ifCashStorage))) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.ifCashBitmap);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from account to its fixed length array of portfolio assets\\r\\n    function getPortfolioArrayStorage() internal pure\\r\\n        returns (mapping(address => PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS]) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.PortfolioArray);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    function getDeprecatedNTokenTotalSupplyStorage() internal pure\\r\\n        returns (mapping(address => nTokenTotalSupplyStorage_deprecated) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.nTokenTotalSupply_deprecated);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from nToken address to its total supply values\\r\\n    function getNTokenTotalSupplyStorage() internal pure\\r\\n        returns (mapping(address => nTokenTotalSupplyStorage) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.nTokenTotalSupply);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the exchange rate between an underlying currency and asset for trading\\r\\n    /// and free collateral. Mapping is from currency id to rate storage object.\\r\\n    function getAssetRateStorage() internal pure\\r\\n        returns (mapping(uint256 => AssetRateStorage) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.AssetRate);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the exchange rate between an underlying currency and ETH for free\\r\\n    /// collateral purposes. Mapping is from currency id to rate storage object.\\r\\n    function getExchangeRateStorage() internal pure\\r\\n        returns (mapping(uint256 => ETHRateStorage) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.ExchangeRate);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the address of a secondary incentive rewarder for an nToken if it exists\\r\\n    function getSecondaryIncentiveRewarder() internal pure\\r\\n        returns (mapping(address => IRewarder) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.SecondaryIncentiveRewarder);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the address of the lending pool\\r\\n    function getLendingPool() internal pure returns (LendingPoolStorage storage store) {\\r\\n        uint256 slot = _getStorageSlot(StorageId.LendingPool);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Get the storage slot given a storage ID.\\r\\n    /// @param storageId An entry in `StorageId`\\r\\n    /// @return slot The storage slot.\\r\\n    function _getStorageSlot(StorageId storageId)\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256 slot)\\r\\n    {\\r\\n        // This should never overflow with a reasonable `STORAGE_SLOT_EXP`\\r\\n        // because Solidity will do a range check on `storageId` during the cast.\\r\\n        return uint256(storageId) + STORAGE_SLOT_BASE;\\r\\n    }\\r\\n} \"\r\n    },\r\n    \"contracts/global/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../interfaces/chainlink/AggregatorV2V3Interface.sol\\\";\\r\\nimport \\\"../../interfaces/notional/AssetRateAdapter.sol\\\";\\r\\n\\r\\n/// @notice Different types of internal tokens\\r\\n///  - UnderlyingToken: underlying asset for a cToken (except for Ether)\\r\\n///  - cToken: Compound interest bearing token\\r\\n///  - cETH: Special handling for cETH tokens\\r\\n///  - Ether: the one and only\\r\\n///  - NonMintable: tokens that do not have an underlying (therefore not cTokens)\\r\\n///  - aToken: Aave interest bearing tokens\\r\\nenum TokenType {UnderlyingToken, cToken, cETH, Ether, NonMintable, aToken}\\r\\n\\r\\n/// @notice Specifies the different trade action types in the system. Each trade action type is\\r\\n/// encoded in a tightly packed bytes32 object. Trade action type is the first big endian byte of the\\r\\n/// 32 byte trade action object. The schemas for each trade action type are defined below.\\r\\nenum TradeActionType {\\r\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 minImpliedRate, uint120 unused)\\r\\n    Lend,\\r\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 maxImpliedRate, uint128 unused)\\r\\n    Borrow,\\r\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 assetCashAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\\r\\n    AddLiquidity,\\r\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 tokenAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\\r\\n    RemoveLiquidity,\\r\\n    // (uint8 TradeActionType, uint32 Maturity, int88 fCashResidualAmount, uint128 unused)\\r\\n    PurchaseNTokenResidual,\\r\\n    // (uint8 TradeActionType, address CounterpartyAddress, int88 fCashAmountToSettle)\\r\\n    SettleCashDebt\\r\\n}\\r\\n\\r\\n/// @notice Specifies different deposit actions that can occur during BalanceAction or BalanceActionWithTrades\\r\\nenum DepositActionType {\\r\\n    // No deposit action\\r\\n    None,\\r\\n    // Deposit asset cash, depositActionAmount is specified in asset cash external precision\\r\\n    DepositAsset,\\r\\n    // Deposit underlying tokens that are mintable to asset cash, depositActionAmount is specified in underlying token\\r\\n    // external precision\\r\\n    DepositUnderlying,\\r\\n    // Deposits specified asset cash external precision amount into an nToken and mints the corresponding amount of\\r\\n    // nTokens into the account\\r\\n    DepositAssetAndMintNToken,\\r\\n    // Deposits specified underlying in external precision, mints asset cash, and uses that asset cash to mint nTokens\\r\\n    DepositUnderlyingAndMintNToken,\\r\\n    // Redeems an nToken balance to asset cash. depositActionAmount is specified in nToken precision. Considered a deposit action\\r\\n    // because it deposits asset cash into an account. If there are fCash residuals that cannot be sold off, will revert.\\r\\n    RedeemNToken,\\r\\n    // Converts specified amount of asset cash balance already in Notional to nTokens. depositActionAmount is specified in\\r\\n    // Notional internal 8 decimal precision.\\r\\n    ConvertCashToNToken\\r\\n}\\r\\n\\r\\n/// @notice Used internally for PortfolioHandler state\\r\\nenum AssetStorageState {NoChange, Update, Delete, RevertIfStored}\\r\\n\\r\\n/****** Calldata objects ******/\\r\\n\\r\\n/// @notice Defines a balance action for batchAction\\r\\nstruct BalanceAction {\\r\\n    // Deposit action to take (if any)\\r\\n    DepositActionType actionType;\\r\\n    uint16 currencyId;\\r\\n    // Deposit action amount must correspond to the depositActionType, see documentation above.\\r\\n    uint256 depositActionAmount;\\r\\n    // Withdraw an amount of asset cash specified in Notional internal 8 decimal precision\\r\\n    uint256 withdrawAmountInternalPrecision;\\r\\n    // If set to true, will withdraw entire cash balance. Useful if there may be an unknown amount of asset cash\\r\\n    // residual left from trading.\\r\\n    bool withdrawEntireCashBalance;\\r\\n    // If set to true, will redeem asset cash to the underlying token on withdraw.\\r\\n    bool redeemToUnderlying;\\r\\n}\\r\\n\\r\\n/// @notice Defines a balance action with a set of trades to do as well\\r\\nstruct BalanceActionWithTrades {\\r\\n    DepositActionType actionType;\\r\\n    uint16 currencyId;\\r\\n    uint256 depositActionAmount;\\r\\n    uint256 withdrawAmountInternalPrecision;\\r\\n    bool withdrawEntireCashBalance;\\r\\n    bool redeemToUnderlying;\\r\\n    // Array of tightly packed 32 byte objects that represent trades. See TradeActionType documentation\\r\\n    bytes32[] trades;\\r\\n}\\r\\n\\r\\n/****** In memory objects ******/\\r\\n/// @notice Internal object that represents settled cash balances\\r\\nstruct SettleAmount {\\r\\n    uint256 currencyId;\\r\\n    int256 netCashChange;\\r\\n}\\r\\n\\r\\n/// @notice Internal object that represents a token\\r\\nstruct Token {\\r\\n    address tokenAddress;\\r\\n    bool hasTransferFee;\\r\\n    int256 decimals;\\r\\n    TokenType tokenType;\\r\\n    uint256 maxCollateralBalance;\\r\\n}\\r\\n\\r\\n/// @notice Internal object that represents an nToken portfolio\\r\\nstruct nTokenPortfolio {\\r\\n    CashGroupParameters cashGroup;\\r\\n    PortfolioState portfolioState;\\r\\n    int256 totalSupply;\\r\\n    int256 cashBalance;\\r\\n    uint256 lastInitializedTime;\\r\\n    bytes6 parameters;\\r\\n    address tokenAddress;\\r\\n}\\r\\n\\r\\n/// @notice Internal object used during liquidation\\r\\nstruct LiquidationFactors {\\r\\n    address account;\\r\\n    // Aggregate free collateral of the account denominated in ETH underlying, 8 decimal precision\\r\\n    int256 netETHValue;\\r\\n    // Amount of net local currency asset cash before haircuts and buffers available\\r\\n    int256 localAssetAvailable;\\r\\n    // Amount of net collateral currency asset cash before haircuts and buffers available\\r\\n    int256 collateralAssetAvailable;\\r\\n    // Haircut value of nToken holdings denominated in asset cash, will be local or collateral nTokens based\\r\\n    // on liquidation type\\r\\n    int256 nTokenHaircutAssetValue;\\r\\n    // nToken parameters for calculating liquidation amount\\r\\n    bytes6 nTokenParameters;\\r\\n    // ETH exchange rate from local currency to ETH\\r\\n    ETHRate localETHRate;\\r\\n    // ETH exchange rate from collateral currency to ETH\\r\\n    ETHRate collateralETHRate;\\r\\n    // Asset rate for the local currency, used in cross currency calculations to calculate local asset cash required\\r\\n    AssetRateParameters localAssetRate;\\r\\n    // Used during currency liquidations if the account has liquidity tokens\\r\\n    CashGroupParameters collateralCashGroup;\\r\\n    // Used during currency liquidations if it is only a calculation, defaults to false\\r\\n    bool isCalculation;\\r\\n}\\r\\n\\r\\n/// @notice Internal asset array portfolio state\\r\\nstruct PortfolioState {\\r\\n    // Array of currently stored assets\\r\\n    PortfolioAsset[] storedAssets;\\r\\n    // Array of new assets to add\\r\\n    PortfolioAsset[] newAssets;\\r\\n    uint256 lastNewAssetIndex;\\r\\n    // Holds the length of stored assets after accounting for deleted assets\\r\\n    uint256 storedAssetLength;\\r\\n}\\r\\n\\r\\n/// @notice In memory ETH exchange rate used during free collateral calculation.\\r\\nstruct ETHRate {\\r\\n    // The decimals (i.e. 10^rateDecimalPlaces) of the exchange rate, defined by the rate oracle\\r\\n    int256 rateDecimals;\\r\\n    // The exchange rate from base to ETH (if rate invert is required it is already done)\\r\\n    int256 rate;\\r\\n    // Amount of buffer as a multiple with a basis of 100 applied to negative balances.\\r\\n    int256 buffer;\\r\\n    // Amount of haircut as a multiple with a basis of 100 applied to positive balances\\r\\n    int256 haircut;\\r\\n    // Liquidation discount as a multiple with a basis of 100 applied to the exchange rate\\r\\n    // as an incentive given to liquidators.\\r\\n    int256 liquidationDiscount;\\r\\n}\\r\\n\\r\\n/// @notice Internal object used to handle balance state during a transaction\\r\\nstruct BalanceState {\\r\\n    uint16 currencyId;\\r\\n    // Cash balance stored in balance state at the beginning of the transaction\\r\\n    int256 storedCashBalance;\\r\\n    // nToken balance stored at the beginning of the transaction\\r\\n    int256 storedNTokenBalance;\\r\\n    // The net cash change as a result of asset settlement or trading\\r\\n    int256 netCashChange;\\r\\n    // Net asset transfers into or out of the account\\r\\n    int256 netAssetTransferInternalPrecision;\\r\\n    // Net token transfers into or out of the account\\r\\n    int256 netNTokenTransfer;\\r\\n    // Net token supply change from minting or redeeming\\r\\n    int256 netNTokenSupplyChange;\\r\\n    // The last time incentives were claimed for this currency\\r\\n    uint256 lastClaimTime;\\r\\n    // Accumulator for incentives that the account no longer has a claim over\\r\\n    uint256 accountIncentiveDebt;\\r\\n}\\r\\n\\r\\n/// @dev Asset rate used to convert between underlying cash and asset cash\\r\\nstruct AssetRateParameters {\\r\\n    // Address of the asset rate oracle\\r\\n    AssetRateAdapter rateOracle;\\r\\n    // The exchange rate from base to quote (if invert is required it is already done)\\r\\n    int256 rate;\\r\\n    // The decimals of the underlying, the rate converts to the underlying decimals\\r\\n    int256 underlyingDecimals;\\r\\n}\\r\\n\\r\\n/// @dev Cash group when loaded into memory\\r\\nstruct CashGroupParameters {\\r\\n    uint16 currencyId;\\r\\n    uint256 maxMarketIndex;\\r\\n    AssetRateParameters assetRate;\\r\\n    bytes32 data;\\r\\n}\\r\\n\\r\\n/// @dev A portfolio asset when loaded in memory\\r\\nstruct PortfolioAsset {\\r\\n    // Asset currency id\\r\\n    uint256 currencyId;\\r\\n    uint256 maturity;\\r\\n    // Asset type, fCash or liquidity token.\\r\\n    uint256 assetType;\\r\\n    // fCash amount or liquidity token amount\\r\\n    int256 notional;\\r\\n    // Used for managing portfolio asset state\\r\\n    uint256 storageSlot;\\r\\n    // The state of the asset for when it is written to storage\\r\\n    AssetStorageState storageState;\\r\\n}\\r\\n\\r\\n/// @dev Market object as represented in memory\\r\\nstruct MarketParameters {\\r\\n    bytes32 storageSlot;\\r\\n    uint256 maturity;\\r\\n    // Total amount of fCash available for purchase in the market.\\r\\n    int256 totalfCash;\\r\\n    // Total amount of cash available for purchase in the market.\\r\\n    int256 totalAssetCash;\\r\\n    // Total amount of liquidity tokens (representing a claim on liquidity) in the market.\\r\\n    int256 totalLiquidity;\\r\\n    // This is the previous annualized interest rate in RATE_PRECISION that the market traded\\r\\n    // at. This is used to calculate the rate anchor to smooth interest rates over time.\\r\\n    uint256 lastImpliedRate;\\r\\n    // Time lagged version of lastImpliedRate, used to value fCash assets at market rates while\\r\\n    // remaining resistent to flash loan attacks.\\r\\n    uint256 oracleRate;\\r\\n    // This is the timestamp of the previous trade\\r\\n    uint256 previousTradeTime;\\r\\n}\\r\\n\\r\\n/****** Storage objects ******/\\r\\n\\r\\n/// @dev Token object in storage:\\r\\n///  20 bytes for token address\\r\\n///  1 byte for hasTransferFee\\r\\n///  1 byte for tokenType\\r\\n///  1 byte for tokenDecimals\\r\\n///  9 bytes for maxCollateralBalance (may not always be set)\\r\\nstruct TokenStorage {\\r\\n    // Address of the token\\r\\n    address tokenAddress;\\r\\n    // Transfer fees will change token deposit behavior\\r\\n    bool hasTransferFee;\\r\\n    TokenType tokenType;\\r\\n    uint8 decimalPlaces;\\r\\n    // Upper limit on how much of this token the contract can hold at any time\\r\\n    uint72 maxCollateralBalance;\\r\\n}\\r\\n\\r\\n/// @dev Exchange rate object as it is represented in storage, total storage is 25 bytes.\\r\\nstruct ETHRateStorage {\\r\\n    // Address of the rate oracle\\r\\n    AggregatorV2V3Interface rateOracle;\\r\\n    // The decimal places of precision that the rate oracle uses\\r\\n    uint8 rateDecimalPlaces;\\r\\n    // True of the exchange rate must be inverted\\r\\n    bool mustInvert;\\r\\n    // NOTE: both of these governance values are set with BUFFER_DECIMALS precision\\r\\n    // Amount of buffer to apply to the exchange rate for negative balances.\\r\\n    uint8 buffer;\\r\\n    // Amount of haircut to apply to the exchange rate for positive balances\\r\\n    uint8 haircut;\\r\\n    // Liquidation discount in percentage point terms, 106 means a 6% discount\\r\\n    uint8 liquidationDiscount;\\r\\n}\\r\\n\\r\\n/// @dev Asset rate oracle object as it is represented in storage, total storage is 21 bytes.\\r\\nstruct AssetRateStorage {\\r\\n    // Address of the rate oracle\\r\\n    AssetRateAdapter rateOracle;\\r\\n    // The decimal places of the underlying asset\\r\\n    uint8 underlyingDecimalPlaces;\\r\\n}\\r\\n\\r\\n/// @dev Governance parameters for a cash group, total storage is 9 bytes + 7 bytes for liquidity token haircuts\\r\\n/// and 7 bytes for rate scalars, total of 23 bytes. Note that this is stored packed in the storage slot so there\\r\\n/// are no indexes stored for liquidityTokenHaircuts or rateScalars, maxMarketIndex is used instead to determine the\\r\\n/// length.\\r\\nstruct CashGroupSettings {\\r\\n    // Index of the AMMs on chain that will be made available. Idiosyncratic fCash\\r\\n    // that is dated less than the longest AMM will be tradable.\\r\\n    uint8 maxMarketIndex;\\r\\n    // Time window in 5 minute increments that the rate oracle will be averaged over\\r\\n    uint8 rateOracleTimeWindow5Min;\\r\\n    // Total fees per trade, specified in BPS\\r\\n    uint8 totalFeeBPS;\\r\\n    // Share of the fees given to the protocol, denominated in percentage\\r\\n    uint8 reserveFeeShare;\\r\\n    // Debt buffer specified in 5 BPS increments\\r\\n    uint8 debtBuffer5BPS;\\r\\n    // fCash haircut specified in 5 BPS increments\\r\\n    uint8 fCashHaircut5BPS;\\r\\n    // If an account has a negative cash balance, it can be settled by incurring debt at the 3 month market. This\\r\\n    // is the basis points for the penalty rate that will be added the current 3 month oracle rate.\\r\\n    uint8 settlementPenaltyRate5BPS;\\r\\n    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for\\r\\n    uint8 liquidationfCashHaircut5BPS;\\r\\n    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for\\r\\n    uint8 liquidationDebtBuffer5BPS;\\r\\n    // Liquidity token haircut applied to cash claims, specified as a percentage between 0 and 100\\r\\n    uint8[] liquidityTokenHaircuts;\\r\\n    // Rate scalar used to determine the slippage of the market\\r\\n    uint8[] rateScalars;\\r\\n}\\r\\n\\r\\n/// @dev Holds account level context information used to determine settlement and\\r\\n/// free collateral actions. Total storage is 28 bytes\\r\\nstruct AccountContext {\\r\\n    // Used to check when settlement must be triggered on an account\\r\\n    uint40 nextSettleTime;\\r\\n    // For lenders that never incur debt, we use this flag to skip the free collateral check.\\r\\n    bytes1 hasDebt;\\r\\n    // Length of the account's asset array\\r\\n    uint8 assetArrayLength;\\r\\n    // If this account has bitmaps set, this is the corresponding currency id\\r\\n    uint16 bitmapCurrencyId;\\r\\n    // 9 total active currencies possible (2 bytes each)\\r\\n    bytes18 activeCurrencies;\\r\\n}\\r\\n\\r\\n/// @dev Holds nToken context information mapped via the nToken address, total storage is\\r\\n/// 16 bytes\\r\\nstruct nTokenContext {\\r\\n    // Currency id that the nToken represents\\r\\n    uint16 currencyId;\\r\\n    // Annual incentive emission rate denominated in WHOLE TOKENS (multiply by \\r\\n    // INTERNAL_TOKEN_PRECISION to get the actual rate)\\r\\n    uint32 incentiveAnnualEmissionRate;\\r\\n    // The last block time at utc0 that the nToken was initialized at, zero if it\\r\\n    // has never been initialized\\r\\n    uint32 lastInitializedTime;\\r\\n    // Length of the asset array, refers to the number of liquidity tokens an nToken\\r\\n    // currently holds\\r\\n    uint8 assetArrayLength;\\r\\n    // Each byte is a specific nToken parameter\\r\\n    bytes5 nTokenParameters;\\r\\n    // Reserved bytes for future usage\\r\\n    bytes15 _unused;\\r\\n    // Set to true if a secondary rewarder is set\\r\\n    bool hasSecondaryRewarder;\\r\\n}\\r\\n\\r\\n/// @dev Holds account balance information, total storage 32 bytes\\r\\nstruct BalanceStorage {\\r\\n    // Number of nTokens held by the account\\r\\n    uint80 nTokenBalance;\\r\\n    // Last time the account claimed their nTokens\\r\\n    uint32 lastClaimTime;\\r\\n    // Incentives that the account no longer has a claim over\\r\\n    uint56 accountIncentiveDebt;\\r\\n    // Cash balance of the account\\r\\n    int88 cashBalance;\\r\\n}\\r\\n\\r\\n/// @dev Holds information about a settlement rate, total storage 25 bytes\\r\\nstruct SettlementRateStorage {\\r\\n    uint40 blockTime;\\r\\n    uint128 settlementRate;\\r\\n    uint8 underlyingDecimalPlaces;\\r\\n}\\r\\n\\r\\n/// @dev Holds information about a market, total storage is 42 bytes so this spans\\r\\n/// two storage words\\r\\nstruct MarketStorage {\\r\\n    // Total fCash in the market\\r\\n    uint80 totalfCash;\\r\\n    // Total asset cash in the market\\r\\n    uint80 totalAssetCash;\\r\\n    // Last annualized interest rate the market traded at\\r\\n    uint32 lastImpliedRate;\\r\\n    // Last recorded oracle rate for the market\\r\\n    uint32 oracleRate;\\r\\n    // Last time a trade was made\\r\\n    uint32 previousTradeTime;\\r\\n    // This is stored in slot + 1\\r\\n    uint80 totalLiquidity;\\r\\n}\\r\\n\\r\\nstruct ifCashStorage {\\r\\n    // Notional amount of fCash at the slot, limited to int128 to allow for\\r\\n    // future expansion\\r\\n    int128 notional;\\r\\n}\\r\\n\\r\\n/// @dev A single portfolio asset in storage, total storage of 19 bytes\\r\\nstruct PortfolioAssetStorage {\\r\\n    // Currency Id for the asset\\r\\n    uint16 currencyId;\\r\\n    // Maturity of the asset\\r\\n    uint40 maturity;\\r\\n    // Asset type (fCash or Liquidity Token marker)\\r\\n    uint8 assetType;\\r\\n    // Notional\\r\\n    int88 notional;\\r\\n}\\r\\n\\r\\n/// @dev nToken total supply factors for the nToken, includes factors related\\r\\n/// to claiming incentives, total storage 32 bytes. This is the deprecated version\\r\\nstruct nTokenTotalSupplyStorage_deprecated {\\r\\n    // Total supply of the nToken\\r\\n    uint96 totalSupply;\\r\\n    // Integral of the total supply used for calculating the average total supply\\r\\n    uint128 integralTotalSupply;\\r\\n    // Last timestamp the supply value changed, used for calculating the integralTotalSupply\\r\\n    uint32 lastSupplyChangeTime;\\r\\n}\\r\\n\\r\\n/// @dev nToken total supply factors for the nToken, includes factors related\\r\\n/// to claiming incentives, total storage 32 bytes.\\r\\nstruct nTokenTotalSupplyStorage {\\r\\n    // Total supply of the nToken\\r\\n    uint96 totalSupply;\\r\\n    // How many NOTE incentives should be issued per nToken in 1e18 precision\\r\\n    uint128 accumulatedNOTEPerNToken;\\r\\n    // Last timestamp when the accumulation happened\\r\\n    uint32 lastAccumulatedTime;\\r\\n}\\r\\n\\r\\n/// @dev Used in view methods to return account balances in a developer friendly manner\\r\\nstruct AccountBalance {\\r\\n    uint16 currencyId;\\r\\n    int256 cashBalance;\\r\\n    int256 nTokenBalance;\\r\\n    uint256 lastClaimTime;\\r\\n    uint256 accountIncentiveDebt;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"../ERC1967/ERC1967Upgrade.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\r\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\r\\n *\\r\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\r\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\r\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\r\\n *\\r\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\nabstract contract UUPSUpgradeable is ERC1967Upgrade {\\r\\n    /**\\r\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\r\\n     *\\r\\n     * Calls {_authorizeUpgrade}.\\r\\n     *\\r\\n     * Emits an {Upgraded} event.\\r\\n     */\\r\\n    function upgradeTo(address newImplementation) external virtual {\\r\\n        _authorizeUpgrade(newImplementation);\\r\\n        _upgradeToAndCallSecure(newImplementation, bytes(\\\"\\\"), false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\r\\n     * encoded in `data`.\\r\\n     *\\r\\n     * Calls {_authorizeUpgrade}.\\r\\n     *\\r\\n     * Emits an {Upgraded} event.\\r\\n     */\\r\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual {\\r\\n        _authorizeUpgrade(newImplementation);\\r\\n        _upgradeToAndCallSecure(newImplementation, data, true);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\r\\n     * {upgradeTo} and {upgradeToAndCall}.\\r\\n     *\\r\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\r\\n     *\\r\\n     * ```solidity\\r\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\r\\n     * ```\\r\\n     */\\r\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/external/adapters/nTokenERC20Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../../interfaces/notional/nTokenERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\n/// @notice ERC20 proxy for nToken contracts that forwards calls to the Router, all nToken\\r\\n/// balances and allowances are stored in at single address for gas efficiency. This contract\\r\\n/// is used simply for ERC20 compliance.\\r\\ncontract nTokenERC20Proxy is IERC20 {\\r\\n    /// @notice Will be \\\"nToken {Underlying Token}.name()\\\", therefore \\\"USD Coin\\\" will be\\r\\n    /// nToken USD Coin\\r\\n    string public name;\\r\\n\\r\\n    /// @notice Will be \\\"n{Underlying Token}.symbol()\\\", therefore \\\"USDC\\\" will be \\\"nUSDC\\\"\\r\\n    string public symbol;\\r\\n\\r\\n    /// @notice Inherits from Constants.INTERNAL_TOKEN_PRECISION\\r\\n    uint8 public constant decimals = 8;\\r\\n\\r\\n    /// @notice Address of the notional proxy\\r\\n    nTokenERC20 public immutable proxy;\\r\\n\\r\\n    /// @notice Currency id that this nToken refers to\\r\\n    uint16 public immutable currencyId;\\r\\n\\r\\n    constructor(\\r\\n        nTokenERC20 proxy_,\\r\\n        uint16 currencyId_,\\r\\n        string memory underlyingName_,\\r\\n        string memory underlyingSymbol_\\r\\n    ) {\\r\\n        proxy = proxy_;\\r\\n        currencyId = currencyId_;\\r\\n        name = string(abi.encodePacked(\\\"nToken \\\", underlyingName_));\\r\\n        symbol = string(abi.encodePacked(\\\"n\\\", underlyingSymbol_));\\r\\n    }\\r\\n\\r\\n    /// @notice Total number of tokens in circulation\\r\\n    function totalSupply() external view override returns (uint256) {\\r\\n        // Total supply is looked up via the token address\\r\\n        return proxy.nTokenTotalSupply(address(this));\\r\\n    }\\r\\n\\r\\n    /// @notice Get the number of tokens held by the `account`\\r\\n    /// @param account The address of the account to get the balance of\\r\\n    /// @return The number of tokens held\\r\\n    function balanceOf(address account) external view override returns (uint256) {\\r\\n        return proxy.nTokenBalanceOf(currencyId, account);\\r\\n    }\\r\\n\\r\\n    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\\r\\n    /// @param account The address of the account holding the funds\\r\\n    /// @param spender The address of the account spending the funds\\r\\n    /// @return The number of tokens approved\\r\\n    function allowance(address account, address spender) external view override returns (uint256) {\\r\\n        return proxy.nTokenTransferAllowance(currencyId, account, spender);\\r\\n    }\\r\\n\\r\\n    /// @notice Approve `spender` to transfer up to `amount` from `src`\\r\\n    /// @dev This will overwrite the approval amount for `spender`\\r\\n    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\r\\n    ///  emit:Approval\\r\\n    /// @param spender The address of the account which may transfer tokens\\r\\n    /// @param amount The number of tokens that are approved (2^256-1 means infinite)\\r\\n    /// @return Whether or not the approval succeeded\\r\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\r\\n        bool success = proxy.nTokenTransferApprove(currencyId, msg.sender, spender, amount);\\r\\n        // Emit approvals here so that they come from the correct contract address\\r\\n        if (success) emit Approval(msg.sender, spender, amount);\\r\\n        return success;\\r\\n    }\\r\\n\\r\\n    /// @notice Transfer `amount` tokens from `msg.sender` to `to`\\r\\n    /// @dev emit:Transfer\\r\\n    /// @param to The address of the destination account\\r\\n    /// @param amount The number of tokens to transfer\\r\\n    /// @return Whether or not the transfer succeeded\\r\\n    function transfer(address to, uint256 amount) external override returns (bool) {\\r\\n        bool success = proxy.nTokenTransfer(currencyId, msg.sender, to, amount);\\r\\n        // Emit transfer events here so they come from the correct contract\\r\\n        if (success) emit Transfer(msg.sender, to, amount);\\r\\n        return success;\\r\\n    }\\r\\n\\r\\n    /// @notice Transfer `amount` tokens from `from` to `to`\\r\\n    /// @dev emit:Transfer emit:Approval\\r\\n    /// @param from The address of the source account\\r\\n    /// @param to The address of the destination account\\r\\n    /// @param amount The number of tokens to transfer\\r\\n    /// @return Whether or not the transfer succeeded\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external override returns (bool) {\\r\\n        bool success =\\r\\n            proxy.nTokenTransferFrom(currencyId, msg.sender, from, to, amount);\\r\\n\\r\\n        // Emit transfer events here so they come from the correct contract\\r\\n        if (success) emit Transfer(from, to, amount);\\r\\n        return success;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the present value of the nToken's assets denominated in asset tokens\\r\\n    function getPresentValueAssetDenominated() external view returns (int256) {\\r\\n        return proxy.nTokenPresentValueAssetDenominated(currencyId);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the present value of the nToken's assets denominated in underlying\\r\\n    function getPresentValueUnderlyingDenominated() external view returns (int256) {\\r\\n        return proxy.nTokenPresentValueUnderlyingDenominated(currencyId);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"interfaces/notional/IRewarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface IRewarder {\\r\\n    function claimRewards(\\r\\n        address account,\\r\\n        uint16 currencyId,\\r\\n        uint256 nTokenBalanceBefore,\\r\\n        uint256 nTokenBalanceAfter,\\r\\n        int256  netNTokenSupplyChange,\\r\\n        uint256 NOTETokensClaimed\\r\\n    ) external;\\r\\n}\"\r\n    },\r\n    \"interfaces/notional/AssetRateAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-v3\\r\\npragma solidity >=0.7.0;\\r\\n\\r\\n/// @notice Used as a wrapper for tokens that are interest bearing for an\\r\\n/// underlying token. Follows the cToken interface, however, can be adapted\\r\\n/// for other interest bearing tokens.\\r\\ninterface AssetRateAdapter {\\r\\n    function token() external view returns (address);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function description() external view returns (string memory);\\r\\n\\r\\n    function version() external view returns (uint256);\\r\\n\\r\\n    function underlying() external view returns (address);\\r\\n\\r\\n    function getExchangeRateStateful() external returns (int256);\\r\\n\\r\\n    function getExchangeRateView() external view returns (int256);\\r\\n\\r\\n    function getAnnualizedSupplyRate() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.0;\\r\\n\\r\\nimport \\\"./AggregatorInterface.sol\\\";\\r\\nimport \\\"./AggregatorV3Interface.sol\\\";\\r\\n\\r\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\\r\\n{\\r\\n}\"\r\n    },\r\n    \"interfaces/notional/NotionalGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../contracts/global/Types.sol\\\";\\r\\nimport \\\"../../interfaces/chainlink/AggregatorV2V3Interface.sol\\\";\\r\\nimport \\\"../../interfaces/notional/NotionalGovernance.sol\\\";\\r\\nimport \\\"../../interfaces/notional/IRewarder.sol\\\";\\r\\nimport \\\"../../interfaces/aave/ILendingPool.sol\\\";\\r\\n\\r\\ninterface NotionalGovernance {\\r\\n    event ListCurrency(uint16 newCurrencyId);\\r\\n    event UpdateETHRate(uint16 currencyId);\\r\\n    event UpdateAssetRate(uint16 currencyId);\\r\\n    event UpdateCashGroup(uint16 currencyId);\\r\\n    event DeployNToken(uint16 currencyId, address nTokenAddress);\\r\\n    event UpdateDepositParameters(uint16 currencyId);\\r\\n    event UpdateInitializationParameters(uint16 currencyId);\\r\\n    event UpdateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate);\\r\\n    event UpdateTokenCollateralParameters(uint16 currencyId);\\r\\n    event UpdateGlobalTransferOperator(address operator, bool approved);\\r\\n    event UpdateAuthorizedCallbackContract(address operator, bool approved);\\r\\n    event UpdateMaxCollateralBalance(uint16 currencyId, uint72 maxCollateralBalance);\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    event PauseRouterAndGuardianUpdated(address indexed pauseRouter, address indexed pauseGuardian);\\r\\n    event UpdateSecondaryIncentiveRewarder(uint16 indexed currencyId, address rewarder);\\r\\n    event UpdateLendingPool(address pool);\\r\\n\\r\\n    function transferOwnership(address newOwner, bool direct) external;\\r\\n\\r\\n    function claimOwnership() external;\\r\\n\\r\\n    function setPauseRouterAndGuardian(address pauseRouter_, address pauseGuardian_) external;\\r\\n\\r\\n    function listCurrency(\\r\\n        TokenStorage calldata assetToken,\\r\\n        TokenStorage calldata underlyingToken,\\r\\n        AggregatorV2V3Interface rateOracle,\\r\\n        bool mustInvert,\\r\\n        uint8 buffer,\\r\\n        uint8 haircut,\\r\\n        uint8 liquidationDiscount\\r\\n    ) external returns (uint16 currencyId);\\r\\n\\r\\n    function updateMaxCollateralBalance(\\r\\n        uint16 currencyId,\\r\\n        uint72 maxCollateralBalanceInternalPrecision\\r\\n    ) external;\\r\\n\\r\\n    function enableCashGroup(\\r\\n        uint16 currencyId,\\r\\n        AssetRateAdapter assetRateOracle,\\r\\n        CashGroupSettings calldata cashGroup,\\r\\n        string calldata underlyingName,\\r\\n        string calldata underlyingSymbol\\r\\n    ) external;\\r\\n\\r\\n    function updateDepositParameters(\\r\\n        uint16 currencyId,\\r\\n        uint32[] calldata depositShares,\\r\\n        uint32[] calldata leverageThresholds\\r\\n    ) external;\\r\\n\\r\\n    function updateInitializationParameters(\\r\\n        uint16 currencyId,\\r\\n        uint32[] calldata annualizedAnchorRates,\\r\\n        uint32[] calldata proportions\\r\\n    ) external;\\r\\n\\r\\n    function updateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate) external;\\r\\n\\r\\n    function updateTokenCollateralParameters(\\r\\n        uint16 currencyId,\\r\\n        uint8 residualPurchaseIncentive10BPS,\\r\\n        uint8 pvHaircutPercentage,\\r\\n        uint8 residualPurchaseTimeBufferHours,\\r\\n        uint8 cashWithholdingBuffer10BPS,\\r\\n        uint8 liquidationHaircutPercentage\\r\\n    ) external;\\r\\n\\r\\n    function updateCashGroup(uint16 currencyId, CashGroupSettings calldata cashGroup) external;\\r\\n\\r\\n    function updateAssetRate(uint16 currencyId, AssetRateAdapter rateOracle) external;\\r\\n\\r\\n    function updateETHRate(\\r\\n        uint16 currencyId,\\r\\n        AggregatorV2V3Interface rateOracle,\\r\\n        bool mustInvert,\\r\\n        uint8 buffer,\\r\\n        uint8 haircut,\\r\\n        uint8 liquidationDiscount\\r\\n    ) external;\\r\\n\\r\\n    function updateGlobalTransferOperator(address operator, bool approved) external;\\r\\n\\r\\n    function updateAuthorizedCallbackContract(address operator, bool approved) external;\\r\\n\\r\\n    function setLendingPool(ILendingPool pool) external;\\r\\n\\r\\n    function setSecondaryIncentiveRewarder(uint16 currencyId, IRewarder rewarder) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"interfaces/notional/nTokenERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\ninterface nTokenERC20 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n\\r\\n    function nTokenTotalSupply(address nTokenAddress) external view returns (uint256);\\r\\n\\r\\n    function nTokenTransferAllowance(\\r\\n        uint16 currencyId,\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function nTokenBalanceOf(uint16 currencyId, address account) external view returns (uint256);\\r\\n\\r\\n    function nTokenTransferApprove(\\r\\n        uint16 currencyId,\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function nTokenTransfer(\\r\\n        uint16 currencyId,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function nTokenTransferFrom(\\r\\n        uint16 currencyId,\\r\\n        address spender,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function nTokenTransferApproveAll(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function nTokenClaimIncentives() external returns (uint256);\\r\\n\\r\\n    function nTokenPresentValueAssetDenominated(uint16 currencyId) external view returns (int256);\\r\\n\\r\\n    function nTokenPresentValueUnderlyingDenominated(uint16 currencyId)\\r\\n        external\\r\\n        view\\r\\n        returns (int256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/math/SafeInt256.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"../global/Constants.sol\\\";\\r\\n\\r\\nlibrary SafeInt256 {\\r\\n    int256 private constant _INT256_MIN = type(int256).min;\\r\\n\\r\\n    /// @dev Returns the multiplication of two signed integers, reverting on\\r\\n    /// overflow.\\r\\n\\r\\n    /// Counterpart to Solidity's `*` operator.\\r\\n\\r\\n    /// Requirements:\\r\\n\\r\\n    /// - Multiplication cannot overflow.\\r\\n\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\\r\\n        c = a * b;\\r\\n        if (a == -1) require (b == 0 || c / b == a);\\r\\n        else require (a == 0 || c / a == b);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the integer division of two signed integers. Reverts on\\r\\n    /// division by zero. The result is rounded towards zero.\\r\\n\\r\\n    /// Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n    /// `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n    /// uses an invalid opcode to revert (consuming all remaining gas).\\r\\n\\r\\n    /// Requirements:\\r\\n\\r\\n    /// - The divisor cannot be zero.\\r\\n\\r\\n    function div(int256 a, int256 b) internal pure returns (int256 c) {\\r\\n        require(!(b == -1 && a == _INT256_MIN)); // dev: int256 div overflow\\r\\n        // NOTE: solidity will automatically revert on divide by zero\\r\\n        c = a / b;\\r\\n    }\\r\\n\\r\\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\\r\\n        //  taken from uniswap v3\\r\\n        require((z = x - y) <= x == (y >= 0));\\r\\n    }\\r\\n\\r\\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\\r\\n        require((z = x + y) >= x == (y >= 0));\\r\\n    }\\r\\n\\r\\n    function neg(int256 x) internal pure returns (int256 y) {\\r\\n        return mul(-1, x);\\r\\n    }\\r\\n\\r\\n    function abs(int256 x) internal pure returns (int256) {\\r\\n        if (x < 0) return neg(x);\\r\\n        else return x;\\r\\n    }\\r\\n\\r\\n    function subNoNeg(int256 x, int256 y) internal pure returns (int256 z) {\\r\\n        z = sub(x, y);\\r\\n        require(z >= 0); // dev: int256 sub to negative\\r\\n\\r\\n        return z;\\r\\n    }\\r\\n\\r\\n    /// @dev Calculates x * RATE_PRECISION / y while checking overflows\\r\\n    function divInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\\r\\n        return div(mul(x, Constants.RATE_PRECISION), y);\\r\\n    }\\r\\n\\r\\n    /// @dev Calculates x * y / RATE_PRECISION while checking overflows\\r\\n    function mulInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\\r\\n        return div(mul(x, y), Constants.RATE_PRECISION);\\r\\n    }\\r\\n\\r\\n    function toUint(int256 x) internal pure returns (uint256) {\\r\\n        require(x >= 0);\\r\\n        return uint256(x);\\r\\n    }\\r\\n\\r\\n    function toInt(uint256 x) internal pure returns (int256) {\\r\\n        require (x <= uint256(type(int256).max)); // dev: toInt overflow\\r\\n        return int256(x);\\r\\n    }\\r\\n\\r\\n    function max(int256 x, int256 y) internal pure returns (int256) {\\r\\n        return x > y ? x : y;\\r\\n    }\\r\\n\\r\\n    function min(int256 x, int256 y) internal pure returns (int256) {\\r\\n        return x < y ? x : y;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/global/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/// @title All shared constants for the Notional system should be declared here.\\r\\nlibrary Constants {\\r\\n    uint8 internal constant CETH_DECIMAL_PLACES = 8;\\r\\n\\r\\n    // Token precision used for all internal balances, TokenHandler library ensures that we\\r\\n    // limit the dust amount caused by precision mismatches\\r\\n    int256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;\\r\\n    uint256 internal constant INCENTIVE_ACCUMULATION_PRECISION = 1e18;\\r\\n\\r\\n    // ETH will be initialized as the first currency\\r\\n    uint256 internal constant ETH_CURRENCY_ID = 1;\\r\\n    uint8 internal constant ETH_DECIMAL_PLACES = 18;\\r\\n    int256 internal constant ETH_DECIMALS = 1e18;\\r\\n    // Used to prevent overflow when converting decimal places to decimal precision values via\\r\\n    // 10**decimalPlaces. This is a safe value for int256 and uint256 variables. We apply this\\r\\n    // constraint when storing decimal places in governance.\\r\\n    uint256 internal constant MAX_DECIMAL_PLACES = 36;\\r\\n\\r\\n    // Address of the reserve account\\r\\n    address internal constant RESERVE = address(0);\\r\\n\\r\\n    // Most significant bit\\r\\n    bytes32 internal constant MSB =\\r\\n        0x8000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\r\\n    // Each bit set in this mask marks where an active market should be in the bitmap\\r\\n    // if the first bit refers to the reference time. Used to detect idiosyncratic\\r\\n    // fcash in the nToken accounts\\r\\n    bytes32 internal constant ACTIVE_MARKETS_MASK = (\\r\\n        MSB >> ( 90 - 1) | // 3 month\\r\\n        MSB >> (105 - 1) | // 6 month\\r\\n        MSB >> (135 - 1) | // 1 year\\r\\n        MSB >> (147 - 1) | // 2 year\\r\\n        MSB >> (183 - 1) | // 5 year\\r\\n        MSB >> (211 - 1) | // 10 year\\r\\n        MSB >> (251 - 1)   // 20 year\\r\\n    );\\r\\n\\r\\n    // Basis for percentages\\r\\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\\r\\n    // Max number of traded markets, also used as the maximum number of assets in a portfolio array\\r\\n    uint256 internal constant MAX_TRADED_MARKET_INDEX = 7;\\r\\n    // Max number of fCash assets in a bitmap, this is based on the gas costs of calculating free collateral\\r\\n    // for a bitmap portfolio\\r\\n    uint256 internal constant MAX_BITMAP_ASSETS = 20;\\r\\n    uint256 internal constant FIVE_MINUTES = 300;\\r\\n\\r\\n    // Internal date representations, note we use a 6/30/360 week/month/year convention here\\r\\n    uint256 internal constant DAY = 86400;\\r\\n    // We use six day weeks to ensure that all time references divide evenly\\r\\n    uint256 internal constant WEEK = DAY * 6;\\r\\n    uint256 internal constant MONTH = WEEK * 5;\\r\\n    uint256 internal constant QUARTER = MONTH * 3;\\r\\n    uint256 internal constant YEAR = QUARTER * 4;\\r\\n    \\r\\n    // These constants are used in DateTime.sol\\r\\n    uint256 internal constant DAYS_IN_WEEK = 6;\\r\\n    uint256 internal constant DAYS_IN_MONTH = 30;\\r\\n    uint256 internal constant DAYS_IN_QUARTER = 90;\\r\\n\\r\\n    // Offsets for each time chunk denominated in days\\r\\n    uint256 internal constant MAX_DAY_OFFSET = 90;\\r\\n    uint256 internal constant MAX_WEEK_OFFSET = 360;\\r\\n    uint256 internal constant MAX_MONTH_OFFSET = 2160;\\r\\n    uint256 internal constant MAX_QUARTER_OFFSET = 7650;\\r\\n\\r\\n    // Offsets for each time chunk denominated in bits\\r\\n    uint256 internal constant WEEK_BIT_OFFSET = 90;\\r\\n    uint256 internal constant MONTH_BIT_OFFSET = 135;\\r\\n    uint256 internal constant QUARTER_BIT_OFFSET = 195;\\r\\n\\r\\n    // This is a constant that represents the time period that all rates are normalized by, 360 days\\r\\n    uint256 internal constant IMPLIED_RATE_TIME = 360 * DAY;\\r\\n    // Number of decimal places that rates are stored in, equals 100%\\r\\n    int256 internal constant RATE_PRECISION = 1e9;\\r\\n    // One basis point in RATE_PRECISION terms\\r\\n    uint256 internal constant BASIS_POINT = uint256(RATE_PRECISION / 10000);\\r\\n    // Used to when calculating the amount to deleverage of a market when minting nTokens\\r\\n    uint256 internal constant DELEVERAGE_BUFFER = 300 * BASIS_POINT;\\r\\n    // Used for scaling cash group factors\\r\\n    uint256 internal constant FIVE_BASIS_POINTS = 5 * BASIS_POINT;\\r\\n    // Used for residual purchase incentive and cash withholding buffer\\r\\n    uint256 internal constant TEN_BASIS_POINTS = 10 * BASIS_POINT;\\r\\n\\r\\n    // This is the ABDK64x64 representation of RATE_PRECISION\\r\\n    // RATE_PRECISION_64x64 = ABDKMath64x64.fromUint(RATE_PRECISION)\\r\\n    int128 internal constant RATE_PRECISION_64x64 = 0x3b9aca000000000000000000;\\r\\n    int128 internal constant LOG_RATE_PRECISION_64x64 = 382276781265598821176;\\r\\n    // Limit the market proportion so that borrowing cannot hit extremely high interest rates\\r\\n    int256 internal constant MAX_MARKET_PROPORTION = RATE_PRECISION * 99 / 100;\\r\\n\\r\\n    uint8 internal constant FCASH_ASSET_TYPE = 1;\\r\\n    // Liquidity token asset types are 1 + marketIndex (where marketIndex is 1-indexed)\\r\\n    uint8 internal constant MIN_LIQUIDITY_TOKEN_INDEX = 2;\\r\\n    uint8 internal constant MAX_LIQUIDITY_TOKEN_INDEX = 8;\\r\\n\\r\\n    // Used for converting bool to bytes1, solidity does not have a native conversion\\r\\n    // method for this\\r\\n    bytes1 internal constant BOOL_FALSE = 0x00;\\r\\n    bytes1 internal constant BOOL_TRUE = 0x01;\\r\\n\\r\\n    // Account context flags\\r\\n    bytes1 internal constant HAS_ASSET_DEBT = 0x01;\\r\\n    bytes1 internal constant HAS_CASH_DEBT = 0x02;\\r\\n    bytes2 internal constant ACTIVE_IN_PORTFOLIO = 0x8000;\\r\\n    bytes2 internal constant ACTIVE_IN_BALANCES = 0x4000;\\r\\n    bytes2 internal constant UNMASK_FLAGS = 0x3FFF;\\r\\n    uint16 internal constant MAX_CURRENCIES = uint16(UNMASK_FLAGS);\\r\\n\\r\\n    // Equal to 100% of all deposit amounts for nToken liquidity across fCash markets.\\r\\n    int256 internal constant DEPOSIT_PERCENT_BASIS = 1e8;\\r\\n\\r\\n    // nToken Parameters: there are offsets in the nTokenParameters bytes6 variable returned\\r\\n    // in nTokenHandler. Each constant represents a position in the byte array.\\r\\n    uint8 internal constant LIQUIDATION_HAIRCUT_PERCENTAGE = 0;\\r\\n    uint8 internal constant CASH_WITHHOLDING_BUFFER = 1;\\r\\n    uint8 internal constant RESIDUAL_PURCHASE_TIME_BUFFER = 2;\\r\\n    uint8 internal constant PV_HAIRCUT_PERCENTAGE = 3;\\r\\n    uint8 internal constant RESIDUAL_PURCHASE_INCENTIVE = 4;\\r\\n\\r\\n    // Liquidation parameters\\r\\n    // Default percentage of collateral that a liquidator is allowed to liquidate, will be higher if the account\\r\\n    // requires more collateral to be liquidated\\r\\n    int256 internal constant DEFAULT_LIQUIDATION_PORTION = 40;\\r\\n    // Percentage of local liquidity token cash claim delivered to the liquidator for liquidating liquidity tokens\\r\\n    int256 internal constant TOKEN_REPO_INCENTIVE_PERCENT = 30;\\r\\n\\r\\n    // Pause Router liquidation enabled states\\r\\n    bytes1 internal constant LOCAL_CURRENCY_ENABLED = 0x01;\\r\\n    bytes1 internal constant COLLATERAL_CURRENCY_ENABLED = 0x02;\\r\\n    bytes1 internal constant LOCAL_FCASH_ENABLED = 0x04;\\r\\n    bytes1 internal constant CROSS_CURRENCY_FCASH_ENABLED = 0x08;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/global/Deployments.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/// @title Hardcoded deployed contracts are listed here. These are hardcoded to reduce\\r\\n/// gas costs for immutable addresses. They must be updated per environment that Notional\\r\\n/// is deployed to.\\r\\nlibrary Deployments {\\r\\n    address internal constant NOTE_TOKEN_ADDRESS = 0xCFEAead4947f0705A14ec42aC3D44129E1Ef3eD5;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/balances/protocols/AaveHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../../global/Types.sol\\\";\\r\\nimport \\\"../../../global/LibStorage.sol\\\";\\r\\nimport \\\"../../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../TokenHandler.sol\\\";\\r\\nimport \\\"../../../../interfaces/aave/IAToken.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary AaveHandler {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeInt256 for int256;\\r\\n    int256 internal constant RAY = 1e27;\\r\\n    int256 internal constant halfRAY = RAY / 2;\\r\\n\\r\\n    bytes4 internal constant scaledBalanceOfSelector = IAToken.scaledBalanceOf.selector;\\r\\n\\r\\n    /**\\r\\n     * @notice Mints an amount of aTokens corresponding to the the underlying.\\r\\n     * @param underlyingToken address of the underlying token to pass to Aave\\r\\n     * @param underlyingAmountExternal amount of underlying to deposit, in external precision\\r\\n     */\\r\\n    function mint(Token memory underlyingToken, uint256 underlyingAmountExternal) internal {\\r\\n        // In AaveV3 this method is renamed to supply() but deposit() is still available for\\r\\n        // backwards compatibility: https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/pool/Pool.sol#L755\\r\\n        // We use deposit here so that mainnet-fork tests against Aave v2 will pass.\\r\\n        LibStorage.getLendingPool().lendingPool.deposit(\\r\\n            underlyingToken.tokenAddress,\\r\\n            underlyingAmountExternal,\\r\\n            address(this),\\r\\n            0\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Redeems and sends an amount of aTokens to the specified account\\r\\n     * @param underlyingToken address of the underlying token to pass to Aave\\r\\n     * @param account account to receive the underlying\\r\\n     * @param assetAmountExternal amount of aTokens in scaledBalanceOf terms\\r\\n     */\\r\\n    function redeem(\\r\\n        Token memory underlyingToken,\\r\\n        address account,\\r\\n        uint256 assetAmountExternal\\r\\n    ) internal returns (uint256 underlyingAmountExternal) {\\r\\n        underlyingAmountExternal = convertFromScaledBalanceExternal(\\r\\n            underlyingToken.tokenAddress,\\r\\n            SafeInt256.toInt(assetAmountExternal)\\r\\n        ).toUint();\\r\\n        LibStorage.getLendingPool().lendingPool.withdraw(\\r\\n            underlyingToken.tokenAddress,\\r\\n            underlyingAmountExternal,\\r\\n            account\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Takes an assetAmountExternal (in this case is the Aave balanceOf representing principal plus interest)\\r\\n     * and returns another assetAmountExternal value which represents the Aave scaledBalanceOf (representing a proportional\\r\\n     * claim on Aave principal plus interest onto the future). This conversion ensures that depositors into Notional will\\r\\n     * receive future Aave interest.\\r\\n     * @dev There is no loss of precision within this function since it does the exact same calculation as Aave.\\r\\n     * @param currencyId is the currency id\\r\\n     * @param assetAmountExternal an Aave token amount representing principal plus interest supplied by the user. This must\\r\\n     * be positive in this function, this method is only called when depositing aTokens directly\\r\\n     * @return scaledAssetAmountExternal the Aave scaledBalanceOf equivalent. The decimal precision of this value will\\r\\n     * be in external precision.\\r\\n     */\\r\\n    function convertToScaledBalanceExternal(uint256 currencyId, int256 assetAmountExternal) internal view returns (int256) {\\r\\n        if (assetAmountExternal == 0) return 0;\\r\\n        require(assetAmountExternal > 0);\\r\\n\\r\\n        Token memory underlyingToken = TokenHandler.getUnderlyingToken(currencyId);\\r\\n        // We know that this value must be positive\\r\\n        int256 index = _getReserveNormalizedIncome(underlyingToken.tokenAddress);\\r\\n\\r\\n        // Mimic the WadRay math performed by Aave (but do it in int256 instead)\\r\\n        int256 halfIndex = index / 2;\\r\\n\\r\\n        // Overflow will occur when: (a * RAY + halfIndex) > int256.max\\r\\n        require(assetAmountExternal <= (type(int256).max - halfIndex) / RAY);\\r\\n\\r\\n        // if index is zero then this will revert\\r\\n        return (assetAmountExternal * RAY + halfIndex) / index;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Takes an assetAmountExternal (in this case is the internal scaledBalanceOf in external decimal precision)\\r\\n     * and returns another assetAmountExternal value which represents the Aave balanceOf representing the principal plus interest\\r\\n     * that will be transferred. This is required to maintain compatibility with Aave's ERC20 transfer functions.\\r\\n     * @dev There is no loss of precision because this does exactly what Aave's calculation would do\\r\\n     * @param underlyingToken token address of the underlying asset\\r\\n     * @param netScaledBalanceExternal an amount representing the scaledBalanceOf in external decimal precision calculated from\\r\\n     * Notional cash balances. This amount may be positive or negative depending on if assets are being deposited (positive) or\\r\\n     * withdrawn (negative).\\r\\n     * @return netBalanceExternal the Aave balanceOf equivalent as a signed integer\\r\\n     */\\r\\n    function convertFromScaledBalanceExternal(address underlyingToken, int256 netScaledBalanceExternal) internal view returns (int256 netBalanceExternal) {\\r\\n        if (netScaledBalanceExternal == 0) return 0;\\r\\n\\r\\n        // We know that this value must be positive\\r\\n        int256 index = _getReserveNormalizedIncome(underlyingToken);\\r\\n        // Use the absolute value here so that the halfRay rounding is applied correctly for negative values\\r\\n        int256 abs = netScaledBalanceExternal.abs();\\r\\n\\r\\n        // Mimic the WadRay math performed by Aave (but do it in int256 instead)\\r\\n\\r\\n        // Overflow will occur when: (abs * index + halfRay) > int256.max\\r\\n        // Here the first term is computed at compile time so it just does a division. If index is zero then\\r\\n        // solidity will revert.\\r\\n        require(abs <= (type(int256).max - halfRAY) / index);\\r\\n        int256 absScaled = (abs * index + halfRAY) / RAY;\\r\\n\\r\\n        return netScaledBalanceExternal > 0 ? absScaled : absScaled.neg();\\r\\n    }\\r\\n\\r\\n    /// @dev getReserveNormalizedIncome returns a uint256, so we know that the return value here is\\r\\n    /// always positive even though we are converting to a signed int\\r\\n    function _getReserveNormalizedIncome(address underlyingAsset) private view returns (int256) {\\r\\n        return\\r\\n            SafeInt256.toInt(\\r\\n                LibStorage.getLendingPool().lendingPool.getReserveNormalizedIncome(underlyingAsset)\\r\\n            );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/internal/balances/protocols/CompoundHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./GenericToken.sol\\\";\\r\\nimport \\\"../../../../interfaces/compound/CErc20Interface.sol\\\";\\r\\nimport \\\"../../../../interfaces/compound/CEtherInterface.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"../../../global/Types.sol\\\";\\r\\n\\r\\nlibrary CompoundHandler {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    // Return code for cTokens that represents no error\\r\\n    uint256 internal constant COMPOUND_RETURN_CODE_NO_ERROR = 0;\\r\\n\\r\\n    function mintCETH(Token memory token) internal {\\r\\n        // Reverts on error\\r\\n        CEtherInterface(token.tokenAddress).mint{value: msg.value}();\\r\\n    }\\r\\n\\r\\n    function mint(Token memory token, uint256 underlyingAmountExternal) internal returns (int256) {\\r\\n        uint256 success = CErc20Interface(token.tokenAddress).mint(underlyingAmountExternal);\\r\\n        require(success == COMPOUND_RETURN_CODE_NO_ERROR, \\\"Mint\\\");\\r\\n    }\\r\\n\\r\\n    function redeemCETH(\\r\\n        Token memory assetToken,\\r\\n        address account,\\r\\n        uint256 assetAmountExternal\\r\\n    ) internal returns (uint256 underlyingAmountExternal) {\\r\\n        // Although the contract should never end with any ETH or underlying token balances, we still do this\\r\\n        // starting and ending check in the case that tokens are accidentally sent to the contract address. They\\r\\n        // will not be sent to some lucky address in a windfall.\\r\\n        uint256 startingBalance = address(this).balance;\\r\\n\\r\\n        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);\\r\\n        require(success == COMPOUND_RETURN_CODE_NO_ERROR, \\\"Redeem\\\");\\r\\n\\r\\n        uint256 endingBalance = address(this).balance;\\r\\n\\r\\n        underlyingAmountExternal = endingBalance.sub(startingBalance);\\r\\n\\r\\n        // Withdraws the underlying amount out to the destination account\\r\\n        GenericToken.transferNativeTokenOut(account, underlyingAmountExternal);\\r\\n    }\\r\\n\\r\\n    function redeem(\\r\\n        Token memory assetToken,\\r\\n        Token memory underlyingToken,\\r\\n        address account,\\r\\n        uint256 assetAmountExternal\\r\\n    ) internal returns (uint256 underlyingAmountExternal) {\\r\\n        // Although the contract should never end with any ETH or underlying token balances, we still do this\\r\\n        // starting and ending check in the case that tokens are accidentally sent to the contract address. They\\r\\n        // will not be sent to some lucky address in a windfall.\\r\\n        uint256 startingBalance = GenericToken.checkBalanceViaSelector(underlyingToken.tokenAddress, address(this), GenericToken.defaultBalanceOfSelector);\\r\\n\\r\\n        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);\\r\\n        require(success == COMPOUND_RETURN_CODE_NO_ERROR, \\\"Redeem\\\");\\r\\n\\r\\n        uint256 endingBalance = GenericToken.checkBalanceViaSelector(underlyingToken.tokenAddress, address(this), GenericToken.defaultBalanceOfSelector);\\r\\n\\r\\n        underlyingAmountExternal = endingBalance.sub(startingBalance);\\r\\n\\r\\n        // Withdraws the underlying amount out to the destination account\\r\\n        GenericToken.safeTransferOut(underlyingToken.tokenAddress, account, underlyingAmountExternal);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/internal/balances/protocols/GenericToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"../../../../interfaces/IEIP20NonStandard.sol\\\";\\r\\n\\r\\nlibrary GenericToken {\\r\\n    bytes4 internal constant defaultBalanceOfSelector = IEIP20NonStandard.balanceOf.selector;\\r\\n\\r\\n    /**\\r\\n     * @dev Manually checks the balance of an account using the method selector. Reduces bytecode size and allows\\r\\n     * for overriding the balanceOf selector to use scaledBalanceOf for aTokens\\r\\n     */\\r\\n    function checkBalanceViaSelector(\\r\\n        address token,\\r\\n        address account,\\r\\n        bytes4 balanceOfSelector\\r\\n    ) internal returns (uint256 balance) {\\r\\n        (bool success, bytes memory returnData) = token.staticcall(abi.encodeWithSelector(balanceOfSelector, account));\\r\\n        require(success);\\r\\n        (balance) = abi.decode(returnData, (uint256));\\r\\n    }\\r\\n\\r\\n    function transferNativeTokenOut(\\r\\n        address account,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        // This does not work with contracts, but is reentrancy safe. If contracts want to withdraw underlying\\r\\n        // ETH they will have to withdraw the cETH token and then redeem it manually.\\r\\n        payable(account).transfer(amount);\\r\\n    }\\r\\n\\r\\n    function safeTransferOut(\\r\\n        address token,\\r\\n        address account,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        IEIP20NonStandard(token).transfer(account, amount);\\r\\n        checkReturnCode();\\r\\n    }\\r\\n\\r\\n    function safeTransferIn(\\r\\n        address token,\\r\\n        address account,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        IEIP20NonStandard(token).transferFrom(account, address(this), amount);\\r\\n        checkReturnCode();\\r\\n    }\\r\\n\\r\\n    function checkReturnCode() internal pure {\\r\\n        bool success;\\r\\n        uint256[1] memory result;\\r\\n        assembly {\\r\\n            switch returndatasize()\\r\\n                case 0 {\\r\\n                    // This is a non-standard ERC-20\\r\\n                    success := 1 // set success to true\\r\\n                }\\r\\n                case 32 {\\r\\n                    // This is a compliant ERC-20\\r\\n                    returndatacopy(result, 0, 32)\\r\\n                    success := mload(result) // Set `success = returndata` of external call\\r\\n                }\\r\\n                default {\\r\\n                    // This is an excessively non-compliant ERC-20, revert.\\r\\n                    revert(0, 0)\\r\\n                }\\r\\n        }\\r\\n\\r\\n        require(success, \\\"ERC20\\\");\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"interfaces/aave/ILendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nstruct LendingPoolStorage {\\r\\n  ILendingPool lendingPool;\\r\\n}\\r\\n\\r\\ninterface ILendingPool {\\r\\n\\r\\n  /**\\r\\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\r\\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\r\\n   * @param asset The address of the underlying asset to deposit\\r\\n   * @param amount The amount to be deposited\\r\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\r\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\r\\n   *   is a different wallet\\r\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\r\\n   *   0 if the action is executed directly by the user, without any middle-man\\r\\n   **/\\r\\n  function deposit(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    address onBehalfOf,\\r\\n    uint16 referralCode\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\r\\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\r\\n   * @param asset The address of the underlying asset to withdraw\\r\\n   * @param amount The underlying amount to be withdrawn\\r\\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\r\\n   * @param to Address that will receive the underlying, same as msg.sender if the user\\r\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\r\\n   *   different wallet\\r\\n   * @return The final amount withdrawn\\r\\n   **/\\r\\n  function withdraw(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    address to\\r\\n  ) external returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the normalized income normalized income of the reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The reserve's normalized income\\r\\n   */\\r\\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n   * @dev Returns the state and configuration of the reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The state of the reserve\\r\\n   **/\\r\\n  function getReserveData(address asset) external view returns (ReserveData memory);\\r\\n\\r\\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\r\\n  struct ReserveData {\\r\\n    //stores the reserve configuration\\r\\n    ReserveConfigurationMap configuration;\\r\\n    //the liquidity index. Expressed in ray\\r\\n    uint128 liquidityIndex;\\r\\n    //variable borrow index. Expressed in ray\\r\\n    uint128 variableBorrowIndex;\\r\\n    //the current supply rate. Expressed in ray\\r\\n    uint128 currentLiquidityRate;\\r\\n    //the current variable borrow rate. Expressed in ray\\r\\n    uint128 currentVariableBorrowRate;\\r\\n    //the current stable borrow rate. Expressed in ray\\r\\n    uint128 currentStableBorrowRate;\\r\\n    uint40 lastUpdateTimestamp;\\r\\n    //tokens addresses\\r\\n    address aTokenAddress;\\r\\n    address stableDebtTokenAddress;\\r\\n    address variableDebtTokenAddress;\\r\\n    //address of the interest rate strategy\\r\\n    address interestRateStrategyAddress;\\r\\n    //the id of the reserve. Represents the position in the list of the active reserves\\r\\n    uint8 id;\\r\\n  }\\r\\n\\r\\n  struct ReserveConfigurationMap {\\r\\n    //bit 0-15: LTV\\r\\n    //bit 16-31: Liq. threshold\\r\\n    //bit 32-47: Liq. bonus\\r\\n    //bit 48-55: Decimals\\r\\n    //bit 56: Reserve is active\\r\\n    //bit 57: reserve is frozen\\r\\n    //bit 58: borrowing is enabled\\r\\n    //bit 59: stable rate borrowing enabled\\r\\n    //bit 60-63: reserved\\r\\n    //bit 64-79: reserve factor\\r\\n    uint256 data;\\r\\n  }\\r\\n\\r\\n  struct UserConfigurationMap {\\r\\n    uint256 data;\\r\\n  }\\r\\n\\r\\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\\r\\n}\\r\\n\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.0;\\r\\n\\r\\ninterface AggregatorInterface {\\r\\n  function latestAnswer() external view returns (int256);\\r\\n  function latestTimestamp() external view returns (uint256);\\r\\n  function latestRound() external view returns (uint256);\\r\\n  function getAnswer(uint256 roundId) external view returns (int256);\\r\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\r\\n\\r\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\r\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\r\\n}\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.0;\\r\\n\\r\\ninterface AggregatorV3Interface {\\r\\n\\r\\n  function decimals() external view returns (uint8);\\r\\n  function description() external view returns (string memory);\\r\\n  function version() external view returns (uint256);\\r\\n\\r\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\r\\n  // if they do not have data to report, instead of returning unset values\\r\\n  // which could be misinterpreted as actual reported values.\\r\\n  function getRoundData(uint80 _roundId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n\\r\\n  function latestRoundData()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n\\r\\n}\"\r\n    },\r\n    \"interfaces/aave/IAToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IAToken {\\r\\n    /**\\r\\n    * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\\r\\n    * updated stored balance divided by the reserve's liquidity index at the moment of the update\\r\\n    * @param user The user whose balance is calculated\\r\\n    * @return The scaled balance of the user\\r\\n    **/\\r\\n    function scaledBalanceOf(address user) external view returns (uint256);\\r\\n\\r\\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n}\\r\\n\\r\\ninterface IScaledBalanceToken {\\r\\n    /**\\r\\n    * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\\r\\n    * updated stored balance divided by the reserve's liquidity index at the moment of the update\\r\\n    * @param user The user whose balance is calculated\\r\\n    * @return The scaled balance of the user\\r\\n    **/\\r\\n    function scaledBalanceOf(address user) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the scaled balance of the user and the scaled total supply.\\r\\n    * @param user The address of the user\\r\\n    * @return The scaled balance of the user\\r\\n    * @return The scaled balance and the scaled total supply\\r\\n    **/\\r\\n    function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\\r\\n    * @return The scaled total supply\\r\\n    **/\\r\\n    function scaledTotalSupply() external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IATokenFull is IScaledBalanceToken, IERC20 { \\r\\n    function decimals() external view returns (uint8);\\r\\n}\"\r\n    },\r\n    \"interfaces/compound/CErc20Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./CTokenInterface.sol\\\";\\r\\n\\r\\ninterface CErc20Interface {\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function mint(uint mintAmount) external returns (uint);\\r\\n    function redeem(uint redeemTokens) external returns (uint);\\r\\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\\r\\n    function borrow(uint borrowAmount) external returns (uint);\\r\\n    function repayBorrow(uint repayAmount) external returns (uint);\\r\\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\\r\\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"interfaces/compound/CEtherInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface CEtherInterface {\\r\\n    function mint() external payable;\\r\\n}\"\r\n    },\r\n    \"interfaces/IEIP20NonStandard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @title EIP20NonStandardInterface\\r\\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\r\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\r\\n */\\r\\ninterface IEIP20NonStandard {\\r\\n\\r\\n    /**\\r\\n     * @notice Get the total number of tokens in circulation\\r\\n     * @return The supply of tokens\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the balance of the specified address\\r\\n     * @param owner The address from which the balance will be retrieved\\r\\n     * @return balance\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    ///\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    ///\\r\\n\\r\\n    /**\\r\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\r\\n      * @param dst The address of the destination account\\r\\n      * @param amount The number of tokens to transfer\\r\\n      */\\r\\n    function transfer(address dst, uint256 amount) external;\\r\\n\\r\\n    ///\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    ///\\r\\n\\r\\n    /**\\r\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\r\\n      * @param src The address of the source account\\r\\n      * @param dst The address of the destination account\\r\\n      * @param amount The number of tokens to transfer\\r\\n      */\\r\\n    function transferFrom(address src, address dst, uint256 amount) external;\\r\\n\\r\\n    ///\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    /// !!! NOTICE !!! `approve` does not return a value, in violation of the ERC-20 specification\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    ///\\r\\n\\r\\n    /**\\r\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\r\\n      * @dev This will overwrite the approval amount for `spender`\\r\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\r\\n      * @param spender The address of the account which may transfer tokens\\r\\n      * @param amount The number of tokens that are approved\\r\\n      */\\r\\n    function approve(address spender, uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n      * @notice Get the current allowance from `owner` for `spender`\\r\\n      * @param owner The address of the account which owns the tokens to be spent\\r\\n      * @param spender The address of the account which may transfer tokens\\r\\n      * @return remaining The number of tokens allowed to be spent\\r\\n      */\\r\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n}\"\r\n    },\r\n    \"interfaces/compound/CTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface CTokenInterface {\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function underlying() external view returns (address);\\r\\n    function transfer(address dst, uint amount) external returns (bool);\\r\\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\\r\\n    function approve(address spender, uint amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function balanceOfUnderlying(address owner) external returns (uint);\\r\\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\\r\\n    function borrowRatePerBlock() external view returns (uint);\\r\\n    function supplyRatePerBlock() external view returns (uint);\\r\\n    function totalBorrowsCurrent() external returns (uint);\\r\\n    function borrowBalanceCurrent(address account) external returns (uint);\\r\\n    function borrowBalanceStored(address account) external view returns (uint);\\r\\n    function exchangeRateCurrent() external returns (uint);\\r\\n    function exchangeRateStored() external view returns (uint);\\r\\n    function getCash() external view returns (uint);\\r\\n    function accrueInterest() external returns (uint);\\r\\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/internal/markets/Market.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./AssetRate.sol\\\";\\r\\nimport \\\"./CashGroup.sol\\\";\\r\\nimport \\\"./DateTime.sol\\\";\\r\\nimport \\\"../balances/BalanceHandler.sol\\\";\\r\\nimport \\\"../../global/LibStorage.sol\\\";\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../math/ABDKMath64x64.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary Market {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeInt256 for int256;\\r\\n    using CashGroup for CashGroupParameters;\\r\\n    using AssetRate for AssetRateParameters;\\r\\n\\r\\n    // Max positive value for a ABDK64x64 integer\\r\\n    int256 private constant MAX64 = 0x7FFFFFFFFFFFFFFF;\\r\\n\\r\\n    /// @notice Add liquidity to a market, assuming that it is initialized. If not then\\r\\n    /// this method will revert and the market must be initialized first.\\r\\n    /// Return liquidityTokens and negative fCash to the portfolio\\r\\n    function addLiquidity(MarketParameters memory market, int256 assetCash)\\r\\n        internal\\r\\n        returns (int256 liquidityTokens, int256 fCash)\\r\\n    {\\r\\n        require(market.totalLiquidity > 0, \\\"M: zero liquidity\\\");\\r\\n        if (assetCash == 0) return (0, 0);\\r\\n        require(assetCash > 0); // dev: negative asset cash\\r\\n\\r\\n        liquidityTokens = market.totalLiquidity.mul(assetCash).div(market.totalAssetCash);\\r\\n        // No need to convert this to underlying, assetCash / totalAssetCash is a unitless proportion.\\r\\n        fCash = market.totalfCash.mul(assetCash).div(market.totalAssetCash);\\r\\n\\r\\n        market.totalLiquidity = market.totalLiquidity.add(liquidityTokens);\\r\\n        market.totalfCash = market.totalfCash.add(fCash);\\r\\n        market.totalAssetCash = market.totalAssetCash.add(assetCash);\\r\\n        _setMarketStorageForLiquidity(market);\\r\\n        // Flip the sign to represent the LP's net position\\r\\n        fCash = fCash.neg();\\r\\n    }\\r\\n\\r\\n    /// @notice Remove liquidity from a market, assuming that it is initialized.\\r\\n    /// Return assetCash and positive fCash to the portfolio\\r\\n    function removeLiquidity(MarketParameters memory market, int256 tokensToRemove)\\r\\n        internal\\r\\n        returns (int256 assetCash, int256 fCash)\\r\\n    {\\r\\n        if (tokensToRemove == 0) return (0, 0);\\r\\n        require(tokensToRemove > 0); // dev: negative tokens to remove\\r\\n\\r\\n        assetCash = market.totalAssetCash.mul(tokensToRemove).div(market.totalLiquidity);\\r\\n        fCash = market.totalfCash.mul(tokensToRemove).div(market.totalLiquidity);\\r\\n\\r\\n        market.totalLiquidity = market.totalLiquidity.subNoNeg(tokensToRemove);\\r\\n        market.totalfCash = market.totalfCash.subNoNeg(fCash);\\r\\n        market.totalAssetCash = market.totalAssetCash.subNoNeg(assetCash);\\r\\n\\r\\n        _setMarketStorageForLiquidity(market);\\r\\n    }\\r\\n\\r\\n    function executeTrade(\\r\\n        MarketParameters memory market,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        int256 fCashToAccount,\\r\\n        uint256 timeToMaturity,\\r\\n        uint256 marketIndex\\r\\n    ) internal returns (int256 netAssetCash) {\\r\\n        int256 netAssetCashToReserve;\\r\\n        (netAssetCash, netAssetCashToReserve) = calculateTrade(\\r\\n            market,\\r\\n            cashGroup,\\r\\n            fCashToAccount,\\r\\n            timeToMaturity,\\r\\n            marketIndex\\r\\n        );\\r\\n\\r\\n        MarketStorage storage marketStorage = _getMarketStoragePointer(market);\\r\\n        _setMarketStorage(\\r\\n            marketStorage,\\r\\n            market.totalfCash,\\r\\n            market.totalAssetCash,\\r\\n            market.lastImpliedRate,\\r\\n            market.oracleRate,\\r\\n            market.previousTradeTime\\r\\n        );\\r\\n        BalanceHandler.incrementFeeToReserve(cashGroup.currencyId, netAssetCashToReserve);\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates the asset cash amount the results from trading fCashToAccount with the market. A positive\\r\\n    /// fCashToAccount is equivalent of lending, a negative is borrowing. Updates the market state in memory.\\r\\n    /// @param market the current market state\\r\\n    /// @param cashGroup cash group configuration parameters\\r\\n    /// @param fCashToAccount the fCash amount that will be deposited into the user's portfolio. The net change\\r\\n    /// to the market is in the opposite direction.\\r\\n    /// @param timeToMaturity number of seconds until maturity\\r\\n    /// @return netAssetCash, netAssetCashToReserve\\r\\n    function calculateTrade(\\r\\n        MarketParameters memory market,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        int256 fCashToAccount,\\r\\n        uint256 timeToMaturity,\\r\\n        uint256 marketIndex\\r\\n    ) internal view returns (int256, int256) {\\r\\n        // We return false if there is not enough fCash to support this trade.\\r\\n        // if fCashToAccount > 0 and totalfCash - fCashToAccount <= 0 then the trade will fail\\r\\n        // if fCashToAccount < 0 and totalfCash > 0 then this will always pass\\r\\n        if (market.totalfCash <= fCashToAccount) return (0, 0);\\r\\n\\r\\n        // Calculates initial rate factors for the trade\\r\\n        (int256 rateScalar, int256 totalCashUnderlying, int256 rateAnchor) =\\r\\n            getExchangeRateFactors(market, cashGroup, timeToMaturity, marketIndex);\\r\\n\\r\\n        // Calculates the exchange rate from cash to fCash before any liquidity fees\\r\\n        // are applied\\r\\n        int256 preFeeExchangeRate;\\r\\n        {\\r\\n            bool success;\\r\\n            (preFeeExchangeRate, success) = _getExchangeRate(\\r\\n                market.totalfCash,\\r\\n                totalCashUnderlying,\\r\\n                rateScalar,\\r\\n                rateAnchor,\\r\\n                fCashToAccount\\r\\n            );\\r\\n            if (!success) return (0, 0);\\r\\n        }\\r\\n\\r\\n        // Given the exchange rate, returns the net cash amounts to apply to each of the\\r\\n        // three relevant balances.\\r\\n        (int256 netCashToAccount, int256 netCashToMarket, int256 netCashToReserve) =\\r\\n            _getNetCashAmountsUnderlying(\\r\\n                cashGroup,\\r\\n                preFeeExchangeRate,\\r\\n                fCashToAccount,\\r\\n                timeToMaturity\\r\\n            );\\r\\n        // Signifies a failed net cash amount calculation\\r\\n        if (netCashToAccount == 0) return (0, 0);\\r\\n\\r\\n        {\\r\\n            // Set the new implied interest rate after the trade has taken effect, this\\r\\n            // will be used to calculate the next trader's interest rate.\\r\\n            market.totalfCash = market.totalfCash.subNoNeg(fCashToAccount);\\r\\n            market.lastImpliedRate = getImpliedRate(\\r\\n                market.totalfCash,\\r\\n                totalCashUnderlying.add(netCashToMarket),\\r\\n                rateScalar,\\r\\n                rateAnchor,\\r\\n                timeToMaturity\\r\\n            );\\r\\n\\r\\n            // It's technically possible that the implied rate is actually exactly zero (or\\r\\n            // more accurately the natural log rounds down to zero) but we will still fail\\r\\n            // in this case. If this does happen we may assume that markets are not initialized.\\r\\n            if (market.lastImpliedRate == 0) return (0, 0);\\r\\n        }\\r\\n\\r\\n        return\\r\\n            _setNewMarketState(\\r\\n                market,\\r\\n                cashGroup.assetRate,\\r\\n                netCashToAccount,\\r\\n                netCashToMarket,\\r\\n                netCashToReserve\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @notice Returns factors for calculating exchange rates\\r\\n    /// @return\\r\\n    ///    rateScalar: a scalar value in rate precision that defines the slope of the line\\r\\n    ///    totalCashUnderlying: the converted asset cash to underlying cash for calculating\\r\\n    ///    the exchange rates for the trade\\r\\n    ///    rateAnchor: an offset from the x axis to maintain interest rate continuity over time\\r\\n    function getExchangeRateFactors(\\r\\n        MarketParameters memory market,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        uint256 timeToMaturity,\\r\\n        uint256 marketIndex\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (\\r\\n            int256,\\r\\n            int256,\\r\\n            int256\\r\\n        )\\r\\n    {\\r\\n        int256 rateScalar = cashGroup.getRateScalar(marketIndex, timeToMaturity);\\r\\n        int256 totalCashUnderlying = cashGroup.assetRate.convertToUnderlying(market.totalAssetCash);\\r\\n\\r\\n        // This would result in a divide by zero\\r\\n        if (market.totalfCash == 0 || totalCashUnderlying == 0) return (0, 0, 0);\\r\\n\\r\\n        // Get the rate anchor given the market state, this will establish the baseline for where\\r\\n        // the exchange rate is set.\\r\\n        int256 rateAnchor;\\r\\n        {\\r\\n            bool success;\\r\\n            (rateAnchor, success) = _getRateAnchor(\\r\\n                market.totalfCash,\\r\\n                market.lastImpliedRate,\\r\\n                totalCashUnderlying,\\r\\n                rateScalar,\\r\\n                timeToMaturity\\r\\n            );\\r\\n            if (!success) return (0, 0, 0);\\r\\n        }\\r\\n\\r\\n        return (rateScalar, totalCashUnderlying, rateAnchor);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns net asset cash amounts to the account, the market and the reserve\\r\\n    /// @return\\r\\n    ///     netCashToAccount: this is a positive or negative amount of cash change to the account\\r\\n    ///     netCashToMarket: this is a positive or negative amount of cash change in the market\\r\\n    //      netCashToReserve: this is always a positive amount of cash accrued to the reserve\\r\\n    function _getNetCashAmountsUnderlying(\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        int256 preFeeExchangeRate,\\r\\n        int256 fCashToAccount,\\r\\n        uint256 timeToMaturity\\r\\n    )\\r\\n        private\\r\\n        pure\\r\\n        returns (\\r\\n            int256,\\r\\n            int256,\\r\\n            int256\\r\\n        )\\r\\n    {\\r\\n        // Fees are specified in basis points which is an rate precision denomination. We convert this to\\r\\n        // an exchange rate denomination for the given time to maturity. (i.e. get e^(fee * t) and multiply\\r\\n        // or divide depending on the side of the trade).\\r\\n        // tradeExchangeRate = exp((tradeInterestRateNoFee +/- fee) * timeToMaturity)\\r\\n        // tradeExchangeRate = tradeExchangeRateNoFee (* or /) exp(fee * timeToMaturity)\\r\\n        // cash = fCash / exchangeRate, exchangeRate > 1\\r\\n        int256 preFeeCashToAccount =\\r\\n            fCashToAccount.divInRatePrecision(preFeeExchangeRate).neg();\\r\\n        int256 fee = getExchangeRateFromImpliedRate(cashGroup.getTotalFee(), timeToMaturity);\\r\\n\\r\\n        if (fCashToAccount > 0) {\\r\\n            // Lending\\r\\n            // Dividing reduces exchange rate, lending should receive less fCash for cash\\r\\n            int256 postFeeExchangeRate = preFeeExchangeRate.divInRatePrecision(fee);\\r\\n            // It's possible that the fee pushes exchange rates into negative territory. This is not possible\\r\\n            // when borrowing. If this happens then the trade has failed.\\r\\n            if (postFeeExchangeRate < Constants.RATE_PRECISION) return (0, 0, 0);\\r\\n\\r\\n            // cashToAccount = -(fCashToAccount / exchangeRate)\\r\\n            // postFeeExchangeRate = preFeeExchangeRate / feeExchangeRate\\r\\n            // preFeeCashToAccount = -(fCashToAccount / preFeeExchangeRate)\\r\\n            // postFeeCashToAccount = -(fCashToAccount / postFeeExchangeRate)\\r\\n            // netFee = preFeeCashToAccount - postFeeCashToAccount\\r\\n            // netFee = (fCashToAccount / postFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\\r\\n            // netFee = ((fCashToAccount * feeExchangeRate) / preFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\\r\\n            // netFee = (fCashToAccount / preFeeExchangeRate) * (feeExchangeRate - 1)\\r\\n            // netFee = -(preFeeCashToAccount) * (feeExchangeRate - 1)\\r\\n            // netFee = preFeeCashToAccount * (1 - feeExchangeRate)\\r\\n            // RATE_PRECISION - fee will be negative here, preFeeCashToAccount < 0, fee > 0\\r\\n            fee = preFeeCashToAccount.mulInRatePrecision(Constants.RATE_PRECISION.sub(fee));\\r\\n        } else {\\r\\n            // Borrowing\\r\\n            // cashToAccount = -(fCashToAccount / exchangeRate)\\r\\n            // postFeeExchangeRate = preFeeExchangeRate * feeExchangeRate\\r\\n\\r\\n            // netFee = preFeeCashToAccount - postFeeCashToAccount\\r\\n            // netFee = (fCashToAccount / postFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\\r\\n            // netFee = ((fCashToAccount / (feeExchangeRate * preFeeExchangeRate)) - (fCashToAccount / preFeeExchangeRate)\\r\\n            // netFee = (fCashToAccount / preFeeExchangeRate) * (1 / feeExchangeRate - 1)\\r\\n            // netFee = preFeeCashToAccount * ((1 - feeExchangeRate) / feeExchangeRate)\\r\\n            // NOTE: preFeeCashToAccount is negative in this branch so we negate it to ensure that fee is a positive number\\r\\n            // preFee * (1 - fee) / fee will be negative, use neg() to flip to positive\\r\\n            // RATE_PRECISION - fee will be negative\\r\\n            fee = preFeeCashToAccount.mul(Constants.RATE_PRECISION.sub(fee)).div(fee).neg();\\r\\n        }\\r\\n\\r\\n        int256 cashToReserve =\\r\\n            fee.mul(cashGroup.getReserveFeeShare()).div(Constants.PERCENTAGE_DECIMALS);\\r\\n\\r\\n        return (\\r\\n            // postFeeCashToAccount = preFeeCashToAccount - fee\\r\\n            preFeeCashToAccount.sub(fee),\\r\\n            // netCashToMarket = -(preFeeCashToAccount - fee + cashToReserve)\\r\\n            (preFeeCashToAccount.sub(fee).add(cashToReserve)).neg(),\\r\\n            cashToReserve\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the new market state\\r\\n    /// @return\\r\\n    ///     netAssetCashToAccount: the positive or negative change in asset cash to the account\\r\\n    ///     assetCashToReserve: the positive amount of cash that accrues to the reserve\\r\\n    function _setNewMarketState(\\r\\n        MarketParameters memory market,\\r\\n        AssetRateParameters memory assetRate,\\r\\n        int256 netCashToAccount,\\r\\n        int256 netCashToMarket,\\r\\n        int256 netCashToReserve\\r\\n    ) private view returns (int256, int256) {\\r\\n        int256 netAssetCashToMarket = assetRate.convertFromUnderlying(netCashToMarket);\\r\\n        // Set storage checks that total asset cash is above zero\\r\\n        market.totalAssetCash = market.totalAssetCash.add(netAssetCashToMarket);\\r\\n\\r\\n        // Sets the trade time for the next oracle update\\r\\n        market.previousTradeTime = block.timestamp;\\r\\n        int256 assetCashToReserve = assetRate.convertFromUnderlying(netCashToReserve);\\r\\n        int256 netAssetCashToAccount = assetRate.convertFromUnderlying(netCashToAccount);\\r\\n        return (netAssetCashToAccount, assetCashToReserve);\\r\\n    }\\r\\n\\r\\n    /// @notice Rate anchors update as the market gets closer to maturity. Rate anchors are not comparable\\r\\n    /// across time or markets but implied rates are. The goal here is to ensure that the implied rate\\r\\n    /// before and after the rate anchor update is the same. Therefore, the market will trade at the same implied\\r\\n    /// rate that it last traded at. If these anchors do not update then it opens up the opportunity for arbitrage\\r\\n    /// which will hurt the liquidity providers.\\r\\n    ///\\r\\n    /// The rate anchor will update as the market rolls down to maturity. The calculation is:\\r\\n    /// newExchangeRate = e^(lastImpliedRate * timeToMaturity / Constants.IMPLIED_RATE_TIME)\\r\\n    /// newAnchor = newExchangeRate - ln((proportion / (1 - proportion)) / rateScalar\\r\\n    ///\\r\\n    /// where:\\r\\n    /// lastImpliedRate = ln(exchangeRate') * (Constants.IMPLIED_RATE_TIME / timeToMaturity')\\r\\n    ///      (calculated when the last trade in the market was made)\\r\\n    /// @return the new rate anchor and a boolean that signifies success\\r\\n    function _getRateAnchor(\\r\\n        int256 totalfCash,\\r\\n        uint256 lastImpliedRate,\\r\\n        int256 totalCashUnderlying,\\r\\n        int256 rateScalar,\\r\\n        uint256 timeToMaturity\\r\\n    ) internal pure returns (int256, bool) {\\r\\n        // This is the exchange rate at the new time to maturity\\r\\n        int256 newExchangeRate = getExchangeRateFromImpliedRate(lastImpliedRate, timeToMaturity);\\r\\n        if (newExchangeRate < Constants.RATE_PRECISION) return (0, false);\\r\\n\\r\\n        int256 rateAnchor;\\r\\n        {\\r\\n            // totalfCash / (totalfCash + totalCashUnderlying)\\r\\n            int256 proportion =\\r\\n                totalfCash.divInRatePrecision(totalfCash.add(totalCashUnderlying));\\r\\n\\r\\n            (int256 lnProportion, bool success) = _logProportion(proportion);\\r\\n            if (!success) return (0, false);\\r\\n\\r\\n            // newExchangeRate - ln(proportion / (1 - proportion)) / rateScalar\\r\\n            rateAnchor = newExchangeRate.sub(lnProportion.divInRatePrecision(rateScalar));\\r\\n        }\\r\\n\\r\\n        return (rateAnchor, true);\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates the current market implied rate.\\r\\n    /// @return the implied rate and a bool that is true on success\\r\\n    function getImpliedRate(\\r\\n        int256 totalfCash,\\r\\n        int256 totalCashUnderlying,\\r\\n        int256 rateScalar,\\r\\n        int256 rateAnchor,\\r\\n        uint256 timeToMaturity\\r\\n    ) internal pure returns (uint256) {\\r\\n        // This will check for exchange rates < Constants.RATE_PRECISION\\r\\n        (int256 exchangeRate, bool success) =\\r\\n            _getExchangeRate(totalfCash, totalCashUnderlying, rateScalar, rateAnchor, 0);\\r\\n        if (!success) return 0;\\r\\n\\r\\n        // Uses continuous compounding to calculate the implied rate:\\r\\n        // ln(exchangeRate) * Constants.IMPLIED_RATE_TIME / timeToMaturity\\r\\n        int128 rate = ABDKMath64x64.fromInt(exchangeRate);\\r\\n        // Scales down to a floating point for LN\\r\\n        int128 rateScaled = ABDKMath64x64.div(rate, Constants.RATE_PRECISION_64x64);\\r\\n        // We will not have a negative log here because we check that exchangeRate > Constants.RATE_PRECISION\\r\\n        // inside getExchangeRate\\r\\n        int128 lnRateScaled = ABDKMath64x64.ln(rateScaled);\\r\\n        // Scales up to a fixed point\\r\\n        uint256 lnRate =\\r\\n            ABDKMath64x64.toUInt(ABDKMath64x64.mul(lnRateScaled, Constants.RATE_PRECISION_64x64));\\r\\n\\r\\n        // lnRate * IMPLIED_RATE_TIME / ttm\\r\\n        uint256 impliedRate = lnRate.mul(Constants.IMPLIED_RATE_TIME).div(timeToMaturity);\\r\\n\\r\\n        // Implied rates over 429% will overflow, this seems like a safe assumption\\r\\n        if (impliedRate > type(uint32).max) return 0;\\r\\n\\r\\n        return impliedRate;\\r\\n    }\\r\\n\\r\\n    /// @notice Converts an implied rate to an exchange rate given a time to maturity. The\\r\\n    /// formula is E = e^rt\\r\\n    function getExchangeRateFromImpliedRate(uint256 impliedRate, uint256 timeToMaturity)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256)\\r\\n    {\\r\\n        int128 expValue =\\r\\n            ABDKMath64x64.fromUInt(\\r\\n                impliedRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME)\\r\\n            );\\r\\n        int128 expValueScaled = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\\r\\n        int128 expResult = ABDKMath64x64.exp(expValueScaled);\\r\\n        int128 expResultScaled = ABDKMath64x64.mul(expResult, Constants.RATE_PRECISION_64x64);\\r\\n\\r\\n        return ABDKMath64x64.toInt(expResultScaled);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the exchange rate between fCash and cash for the given market\\r\\n    /// Calculates the following exchange rate:\\r\\n    ///     (1 / rateScalar) * ln(proportion / (1 - proportion)) + rateAnchor\\r\\n    /// where:\\r\\n    ///     proportion = totalfCash / (totalfCash + totalUnderlyingCash)\\r\\n    /// @dev has an underscore to denote as private but is marked internal for the mock\\r\\n    function _getExchangeRate(\\r\\n        int256 totalfCash,\\r\\n        int256 totalCashUnderlying,\\r\\n        int256 rateScalar,\\r\\n        int256 rateAnchor,\\r\\n        int256 fCashToAccount\\r\\n    ) internal pure returns (int256, bool) {\\r\\n        int256 numerator = totalfCash.subNoNeg(fCashToAccount);\\r\\n\\r\\n        // This is the proportion scaled by Constants.RATE_PRECISION\\r\\n        // (totalfCash + fCash) / (totalfCash + totalCashUnderlying)\\r\\n        int256 proportion =\\r\\n            numerator.divInRatePrecision(totalfCash.add(totalCashUnderlying));\\r\\n\\r\\n        // This limit is here to prevent the market from reaching extremely high interest rates via an\\r\\n        // excessively large proportion (high amounts of fCash relative to cash).\\r\\n        // Market proportion can only increase via borrowing (fCash is added to the market and cash is\\r\\n        // removed). Over time, the returns from asset cash will slightly decrease the proportion (the\\r\\n        // value of cash underlying in the market must be monotonically increasing). Therefore it is not\\r\\n        // possible for the proportion to go over max market proportion unless borrowing occurs.\\r\\n        if (proportion > Constants.MAX_MARKET_PROPORTION) return (0, false);\\r\\n\\r\\n        (int256 lnProportion, bool success) = _logProportion(proportion);\\r\\n        if (!success) return (0, false);\\r\\n\\r\\n        // lnProportion / rateScalar + rateAnchor\\r\\n        int256 rate = lnProportion.divInRatePrecision(rateScalar).add(rateAnchor);\\r\\n        // Do not succeed if interest rates fall below 1\\r\\n        if (rate < Constants.RATE_PRECISION) {\\r\\n            return (0, false);\\r\\n        } else {\\r\\n            return (rate, true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev This method calculates the log of the proportion inside the logit function which is\\r\\n    /// defined as ln(proportion / (1 - proportion)). Special handling here is required to deal with\\r\\n    /// fixed point precision and the ABDK library.\\r\\n    function _logProportion(int256 proportion) internal pure returns (int256, bool) {\\r\\n        // This will result in divide by zero, short circuit\\r\\n        if (proportion == Constants.RATE_PRECISION) return (0, false);\\r\\n\\r\\n        // Convert proportion to what is used inside the logit function (p / (1-p))\\r\\n        int256 logitP = proportion.divInRatePrecision(Constants.RATE_PRECISION.sub(proportion));\\r\\n\\r\\n        // ABDK does not handle log of numbers that are less than 1, in order to get the right value\\r\\n        // scaled by RATE_PRECISION we use the log identity:\\r\\n        // (ln(logitP / RATE_PRECISION)) * RATE_PRECISION = (ln(logitP) - ln(RATE_PRECISION)) * RATE_PRECISION\\r\\n        int128 abdkProportion = ABDKMath64x64.fromInt(logitP);\\r\\n        // Here, abdk will revert due to negative log so abort\\r\\n        if (abdkProportion <= 0) return (0, false);\\r\\n        int256 result =\\r\\n            ABDKMath64x64.toInt(\\r\\n                ABDKMath64x64.mul(\\r\\n                    ABDKMath64x64.sub(\\r\\n                        ABDKMath64x64.ln(abdkProportion),\\r\\n                        Constants.LOG_RATE_PRECISION_64x64\\r\\n                    ),\\r\\n                    Constants.RATE_PRECISION_64x64\\r\\n                )\\r\\n            );\\r\\n\\r\\n        return (result, true);\\r\\n    }\\r\\n\\r\\n    /// @notice Oracle rate protects against short term price manipulation. Time window will be set to a value\\r\\n    /// on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example,\\r\\n    /// a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates.\\r\\n    /// Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then\\r\\n    /// be liquidated.\\r\\n    ///\\r\\n    /// Oracle rates are calculated when the market is loaded from storage.\\r\\n    ///\\r\\n    /// The oracle rate is a lagged weighted average over a short term price window. If we are past\\r\\n    /// the short term window then we just set the rate to the lastImpliedRate, otherwise we take the\\r\\n    /// weighted average:\\r\\n    ///     lastImpliedRatePreTrade * (currentTs - previousTs) / timeWindow +\\r\\n    ///         oracleRatePrevious * (1 - (currentTs - previousTs) / timeWindow)\\r\\n    function _updateRateOracle(\\r\\n        uint256 previousTradeTime,\\r\\n        uint256 lastImpliedRate,\\r\\n        uint256 oracleRate,\\r\\n        uint256 rateOracleTimeWindow,\\r\\n        uint256 blockTime\\r\\n    ) private pure returns (uint256) {\\r\\n        require(rateOracleTimeWindow > 0); // dev: update rate oracle, time window zero\\r\\n\\r\\n        // This can occur when using a view function get to a market state in the past\\r\\n        if (previousTradeTime > blockTime) return lastImpliedRate;\\r\\n\\r\\n        uint256 timeDiff = blockTime.sub(previousTradeTime);\\r\\n        if (timeDiff > rateOracleTimeWindow) {\\r\\n            // If past the time window just return the lastImpliedRate\\r\\n            return lastImpliedRate;\\r\\n        }\\r\\n\\r\\n        // (currentTs - previousTs) / timeWindow\\r\\n        uint256 lastTradeWeight =\\r\\n            timeDiff.mul(uint256(Constants.RATE_PRECISION)).div(rateOracleTimeWindow);\\r\\n\\r\\n        // 1 - (currentTs - previousTs) / timeWindow\\r\\n        uint256 oracleWeight = uint256(Constants.RATE_PRECISION).sub(lastTradeWeight);\\r\\n\\r\\n        uint256 newOracleRate =\\r\\n            (lastImpliedRate.mul(lastTradeWeight).add(oracleRate.mul(oracleWeight))).div(\\r\\n                uint256(Constants.RATE_PRECISION)\\r\\n            );\\r\\n\\r\\n        return newOracleRate;\\r\\n    }\\r\\n\\r\\n    function getOracleRate(\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 rateOracleTimeWindow,\\r\\n        uint256 blockTime\\r\\n    ) internal view returns (uint256) {\\r\\n        mapping(uint256 => mapping(uint256 => \\r\\n            mapping(uint256 => MarketStorage))) storage store = LibStorage.getMarketStorage();\\r\\n        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;\\r\\n        MarketStorage storage marketStorage = store[currencyId][maturity][settlementDate];\\r\\n\\r\\n        uint256 lastImpliedRate = marketStorage.lastImpliedRate;\\r\\n        uint256 oracleRate = marketStorage.oracleRate;\\r\\n        uint256 previousTradeTime = marketStorage.previousTradeTime;\\r\\n\\r\\n        // If the oracle rate is set to zero this can only be because the markets have past their settlement\\r\\n        // date but the new set of markets has not yet been initialized. This means that accounts cannot be liquidated\\r\\n        // during this time, but market initialization can be called by anyone so the actual time that this condition\\r\\n        // exists for should be quite short.\\r\\n        require(oracleRate > 0, \\\"Market not initialized\\\");\\r\\n\\r\\n        return\\r\\n            _updateRateOracle(\\r\\n                previousTradeTime,\\r\\n                lastImpliedRate,\\r\\n                oracleRate,\\r\\n                rateOracleTimeWindow,\\r\\n                blockTime\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @notice Reads a market object directly from storage. `loadMarket` should be called instead of this method\\r\\n    /// which ensures that the rate oracle is set properly.\\r\\n    function _loadMarketStorage(\\r\\n        MarketParameters memory market,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        bool needsLiquidity,\\r\\n        uint256 settlementDate\\r\\n    ) private view {\\r\\n        // Market object always uses the most current reference time as the settlement date\\r\\n        mapping(uint256 => mapping(uint256 => \\r\\n            mapping(uint256 => MarketStorage))) storage store = LibStorage.getMarketStorage();\\r\\n        MarketStorage storage marketStorage = store[currencyId][maturity][settlementDate];\\r\\n        bytes32 slot;\\r\\n        assembly {\\r\\n            slot := marketStorage.slot\\r\\n        }\\r\\n\\r\\n        market.storageSlot = slot;\\r\\n        market.maturity = maturity;\\r\\n        market.totalfCash = marketStorage.totalfCash;\\r\\n        market.totalAssetCash = marketStorage.totalAssetCash;\\r\\n        market.lastImpliedRate = marketStorage.lastImpliedRate;\\r\\n        market.oracleRate = marketStorage.oracleRate;\\r\\n        market.previousTradeTime = marketStorage.previousTradeTime;\\r\\n\\r\\n        if (needsLiquidity) {\\r\\n            market.totalLiquidity = marketStorage.totalLiquidity;\\r\\n        } else {\\r\\n            market.totalLiquidity = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getMarketStoragePointer(\\r\\n        MarketParameters memory market\\r\\n    ) private pure returns (MarketStorage storage marketStorage) {\\r\\n        bytes32 slot = market.storageSlot;\\r\\n        assembly {\\r\\n            marketStorage.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _setMarketStorageForLiquidity(MarketParameters memory market) internal {\\r\\n        MarketStorage storage marketStorage = _getMarketStoragePointer(market);\\r\\n        // Oracle rate does not change on liquidity\\r\\n        uint32 storedOracleRate = marketStorage.oracleRate;\\r\\n\\r\\n        _setMarketStorage(\\r\\n            marketStorage,\\r\\n            market.totalfCash,\\r\\n            market.totalAssetCash,\\r\\n            market.lastImpliedRate,\\r\\n            storedOracleRate,\\r\\n            market.previousTradeTime\\r\\n        );\\r\\n\\r\\n        _setTotalLiquidity(marketStorage, market.totalLiquidity);\\r\\n    }\\r\\n\\r\\n    function setMarketStorageForInitialize(\\r\\n        MarketParameters memory market,\\r\\n        uint256 currencyId,\\r\\n        uint256 settlementDate\\r\\n    ) internal {\\r\\n        // On initialization we have not yet calculated the storage slot so we get it here.\\r\\n        mapping(uint256 => mapping(uint256 => \\r\\n            mapping(uint256 => MarketStorage))) storage store = LibStorage.getMarketStorage();\\r\\n        MarketStorage storage marketStorage = store[currencyId][market.maturity][settlementDate];\\r\\n\\r\\n        _setMarketStorage(\\r\\n            marketStorage,\\r\\n            market.totalfCash,\\r\\n            market.totalAssetCash,\\r\\n            market.lastImpliedRate,\\r\\n            market.oracleRate,\\r\\n            market.previousTradeTime\\r\\n        );\\r\\n\\r\\n        _setTotalLiquidity(marketStorage, market.totalLiquidity);\\r\\n    }\\r\\n\\r\\n    function _setTotalLiquidity(\\r\\n        MarketStorage storage marketStorage,\\r\\n        int256 totalLiquidity\\r\\n    ) internal {\\r\\n        require(totalLiquidity >= 0 && totalLiquidity <= type(uint80).max); // dev: market storage totalLiquidity overflow\\r\\n        marketStorage.totalLiquidity = uint80(totalLiquidity);\\r\\n    }\\r\\n\\r\\n    function _setMarketStorage(\\r\\n        MarketStorage storage marketStorage,\\r\\n        int256 totalfCash,\\r\\n        int256 totalAssetCash,\\r\\n        uint256 lastImpliedRate,\\r\\n        uint256 oracleRate,\\r\\n        uint256 previousTradeTime\\r\\n    ) private {\\r\\n        require(totalfCash >= 0 && totalfCash <= type(uint80).max); // dev: storage totalfCash overflow\\r\\n        require(totalAssetCash >= 0 && totalAssetCash <= type(uint80).max); // dev: storage totalAssetCash overflow\\r\\n        require(0 < lastImpliedRate && lastImpliedRate <= type(uint32).max); // dev: storage lastImpliedRate overflow\\r\\n        require(0 < oracleRate && oracleRate <= type(uint32).max); // dev: storage oracleRate overflow\\r\\n        require(0 <= previousTradeTime && previousTradeTime <= type(uint32).max); // dev: storage previous trade time overflow\\r\\n\\r\\n        marketStorage.totalfCash = uint80(totalfCash);\\r\\n        marketStorage.totalAssetCash = uint80(totalAssetCash);\\r\\n        marketStorage.lastImpliedRate = uint32(lastImpliedRate);\\r\\n        marketStorage.oracleRate = uint32(oracleRate);\\r\\n        marketStorage.previousTradeTime = uint32(previousTradeTime);\\r\\n    }\\r\\n\\r\\n    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately.\\r\\n    function loadMarket(\\r\\n        MarketParameters memory market,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime,\\r\\n        bool needsLiquidity,\\r\\n        uint256 rateOracleTimeWindow\\r\\n    ) internal view {\\r\\n        // Always reference the current settlement date\\r\\n        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;\\r\\n        loadMarketWithSettlementDate(\\r\\n            market,\\r\\n            currencyId,\\r\\n            maturity,\\r\\n            blockTime,\\r\\n            needsLiquidity,\\r\\n            rateOracleTimeWindow,\\r\\n            settlementDate\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately, this\\r\\n    /// is mainly used in the InitializeMarketAction contract.\\r\\n    function loadMarketWithSettlementDate(\\r\\n        MarketParameters memory market,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime,\\r\\n        bool needsLiquidity,\\r\\n        uint256 rateOracleTimeWindow,\\r\\n        uint256 settlementDate\\r\\n    ) internal view {\\r\\n        _loadMarketStorage(market, currencyId, maturity, needsLiquidity, settlementDate);\\r\\n\\r\\n        market.oracleRate = _updateRateOracle(\\r\\n            market.previousTradeTime,\\r\\n            market.lastImpliedRate,\\r\\n            market.oracleRate,\\r\\n            rateOracleTimeWindow,\\r\\n            blockTime\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function loadSettlementMarket(\\r\\n        MarketParameters memory market,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 settlementDate\\r\\n    ) internal view {\\r\\n        _loadMarketStorage(market, currencyId, maturity, true, settlementDate);\\r\\n    }\\r\\n\\r\\n    /// Uses Newton's method to converge on an fCash amount given the amount of\\r\\n    /// cash. The relation between cash and fcash is:\\r\\n    /// cashAmount * exchangeRate * fee + fCash = 0\\r\\n    /// where exchangeRate(fCash) = (rateScalar ^ -1) * ln(p / (1 - p)) + rateAnchor\\r\\n    ///       p = (totalfCash - fCash) / (totalfCash + totalCash)\\r\\n    ///       if cashAmount < 0: fee = feeRate ^ -1\\r\\n    ///       if cashAmount > 0: fee = feeRate\\r\\n    ///\\r\\n    /// Newton's method is:\\r\\n    /// fCash_(n+1) = fCash_n - f(fCash) / f'(fCash)\\r\\n    ///\\r\\n    /// f(fCash) = cashAmount * exchangeRate(fCash) * fee + fCash\\r\\n    ///\\r\\n    ///                                    (totalfCash + totalCash)\\r\\n    /// exchangeRate'(fCash) = -  ------------------------------------------\\r\\n    ///                           (totalfCash - fCash) * (totalCash + fCash)\\r\\n    ///\\r\\n    /// https://www.wolframalpha.com/input/?i=ln%28%28%28a-x%29%2F%28a%2Bb%29%29%2F%281-%28a-x%29%2F%28a%2Bb%29%29%29\\r\\n    ///\\r\\n    ///                     (cashAmount * fee) * (totalfCash + totalCash)\\r\\n    /// f'(fCash) = 1 - ------------------------------------------------------\\r\\n    ///                 rateScalar * (totalfCash - fCash) * (totalCash + fCash)\\r\\n    ///\\r\\n    /// NOTE: each iteration costs about 11.3k so this is only done via a view function.\\r\\n    function getfCashGivenCashAmount(\\r\\n        int256 totalfCash,\\r\\n        int256 netCashToAccount,\\r\\n        int256 totalCashUnderlying,\\r\\n        int256 rateScalar,\\r\\n        int256 rateAnchor,\\r\\n        int256 feeRate,\\r\\n        int256 maxDelta\\r\\n    ) internal pure returns (int256) {\\r\\n        require(maxDelta >= 0);\\r\\n        int256 fCashChangeToAccountGuess = netCashToAccount.mulInRatePrecision(rateAnchor).neg();\\r\\n        for (uint8 i = 0; i < 250; i++) {\\r\\n            (int256 exchangeRate, bool success) =\\r\\n                _getExchangeRate(\\r\\n                    totalfCash,\\r\\n                    totalCashUnderlying,\\r\\n                    rateScalar,\\r\\n                    rateAnchor,\\r\\n                    fCashChangeToAccountGuess\\r\\n                );\\r\\n\\r\\n            require(success); // dev: invalid exchange rate\\r\\n            int256 delta =\\r\\n                _calculateDelta(\\r\\n                    netCashToAccount,\\r\\n                    totalfCash,\\r\\n                    totalCashUnderlying,\\r\\n                    rateScalar,\\r\\n                    fCashChangeToAccountGuess,\\r\\n                    exchangeRate,\\r\\n                    feeRate\\r\\n                );\\r\\n\\r\\n            if (delta.abs() <= maxDelta) return fCashChangeToAccountGuess;\\r\\n            fCashChangeToAccountGuess = fCashChangeToAccountGuess.sub(delta);\\r\\n        }\\r\\n\\r\\n        revert(\\\"No convergence\\\");\\r\\n    }\\r\\n\\r\\n    /// @dev Calculates: f(fCash) / f'(fCash)\\r\\n    /// f(fCash) = cashAmount * exchangeRate * fee + fCash\\r\\n    ///                     (cashAmount * fee) * (totalfCash + totalCash)\\r\\n    /// f'(fCash) = 1 - ------------------------------------------------------\\r\\n    ///                 rateScalar * (totalfCash - fCash) * (totalCash + fCash)\\r\\n    function _calculateDelta(\\r\\n        int256 cashAmount,\\r\\n        int256 totalfCash,\\r\\n        int256 totalCashUnderlying,\\r\\n        int256 rateScalar,\\r\\n        int256 fCashGuess,\\r\\n        int256 exchangeRate,\\r\\n        int256 feeRate\\r\\n    ) private pure returns (int256) {\\r\\n        int256 derivative;\\r\\n        // rateScalar * (totalfCash - fCash) * (totalCash + fCash)\\r\\n        // Precision: TOKEN_PRECISION ^ 2\\r\\n        int256 denominator =\\r\\n            rateScalar.mulInRatePrecision(\\r\\n                (totalfCash.sub(fCashGuess)).mul(totalCashUnderlying.add(fCashGuess))\\r\\n            );\\r\\n\\r\\n        if (fCashGuess > 0) {\\r\\n            // Lending\\r\\n            exchangeRate = exchangeRate.divInRatePrecision(feeRate);\\r\\n            require(exchangeRate >= Constants.RATE_PRECISION); // dev: rate underflow\\r\\n\\r\\n            // (cashAmount / fee) * (totalfCash + totalCash)\\r\\n            // Precision: TOKEN_PRECISION ^ 2\\r\\n            derivative = cashAmount\\r\\n                .mul(totalfCash.add(totalCashUnderlying))\\r\\n                .divInRatePrecision(feeRate);\\r\\n        } else {\\r\\n            // Borrowing\\r\\n            exchangeRate = exchangeRate.mulInRatePrecision(feeRate);\\r\\n            require(exchangeRate >= Constants.RATE_PRECISION); // dev: rate underflow\\r\\n\\r\\n            // (cashAmount * fee) * (totalfCash + totalCash)\\r\\n            // Precision: TOKEN_PRECISION ^ 2\\r\\n            derivative = cashAmount.mulInRatePrecision(\\r\\n                feeRate.mul(totalfCash.add(totalCashUnderlying))\\r\\n            );\\r\\n        }\\r\\n        // 1 - numerator / denominator\\r\\n        // Precision: TOKEN_PRECISION\\r\\n        derivative = Constants.INTERNAL_TOKEN_PRECISION.sub(derivative.div(denominator));\\r\\n\\r\\n        // f(fCash) = cashAmount * exchangeRate * fee + fCash\\r\\n        // NOTE: exchangeRate at this point already has the fee taken into account\\r\\n        int256 numerator = cashAmount.mulInRatePrecision(exchangeRate);\\r\\n        numerator = numerator.add(fCashGuess);\\r\\n\\r\\n        // f(fCash) / f'(fCash), note that they are both denominated as cashAmount so use TOKEN_PRECISION\\r\\n        // here instead of RATE_PRECISION\\r\\n        return numerator.mul(Constants.INTERNAL_TOKEN_PRECISION).div(derivative);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/markets/AssetRate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"../../global/LibStorage.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../../interfaces/notional/AssetRateAdapter.sol\\\";\\r\\n\\r\\nlibrary AssetRate {\\r\\n    using SafeInt256 for int256;\\r\\n    event SetSettlementRate(uint256 indexed currencyId, uint256 indexed maturity, uint128 rate);\\r\\n\\r\\n    // Asset rates are in 1e18 decimals (cToken exchange rates), internal balances\\r\\n    // are in 1e8 decimals. Therefore we leave this as 1e18 / 1e8 = 1e10\\r\\n    int256 private constant ASSET_RATE_DECIMAL_DIFFERENCE = 1e10;\\r\\n\\r\\n    /// @notice Converts an internal asset cash value to its underlying token value.\\r\\n    /// @param ar exchange rate object between asset and underlying\\r\\n    /// @param assetBalance amount to convert to underlying\\r\\n    function convertToUnderlying(AssetRateParameters memory ar, int256 assetBalance)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256)\\r\\n    {\\r\\n        // Calculation here represents:\\r\\n        // rate * balance * internalPrecision / rateDecimals * underlyingPrecision\\r\\n        int256 underlyingBalance = ar.rate\\r\\n            .mul(assetBalance)\\r\\n            .div(ASSET_RATE_DECIMAL_DIFFERENCE)\\r\\n            .div(ar.underlyingDecimals);\\r\\n\\r\\n        return underlyingBalance;\\r\\n    }\\r\\n\\r\\n    /// @notice Converts an internal underlying cash value to its asset cash value\\r\\n    /// @param ar exchange rate object between asset and underlying\\r\\n    /// @param underlyingBalance amount to convert to asset cash, denominated in internal token precision\\r\\n    function convertFromUnderlying(AssetRateParameters memory ar, int256 underlyingBalance)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256)\\r\\n    {\\r\\n        // Calculation here represents:\\r\\n        // rateDecimals * balance * underlyingPrecision / rate * internalPrecision\\r\\n        int256 assetBalance = underlyingBalance\\r\\n            .mul(ASSET_RATE_DECIMAL_DIFFERENCE)\\r\\n            .mul(ar.underlyingDecimals)\\r\\n            .div(ar.rate);\\r\\n\\r\\n        return assetBalance;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the current per block supply rate, is used when calculating oracle rates\\r\\n    /// for idiosyncratic fCash with a shorter duration than the 3 month maturity.\\r\\n    function getSupplyRate(AssetRateParameters memory ar) internal view returns (uint256) {\\r\\n        // If the rate oracle is not set, the asset is not interest bearing and has an oracle rate of zero.\\r\\n        if (address(ar.rateOracle) == address(0)) return 0;\\r\\n\\r\\n        uint256 rate = ar.rateOracle.getAnnualizedSupplyRate();\\r\\n        // Zero supply rate is valid since this is an interest rate, we do not divide by\\r\\n        // the supply rate so we do not get div by zero errors.\\r\\n        require(rate >= 0); // dev: invalid supply rate\\r\\n\\r\\n        return rate;\\r\\n    }\\r\\n\\r\\n    function _getAssetRateStorage(uint256 currencyId)\\r\\n        private\\r\\n        view\\r\\n        returns (AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces)\\r\\n    {\\r\\n        mapping(uint256 => AssetRateStorage) storage store = LibStorage.getAssetRateStorage();\\r\\n        AssetRateStorage storage ar = store[currencyId];\\r\\n        rateOracle = AssetRateAdapter(ar.rateOracle);\\r\\n        underlyingDecimalPlaces = ar.underlyingDecimalPlaces;\\r\\n    }\\r\\n\\r\\n    /// @notice Gets an asset rate using a view function, does not accrue interest so the\\r\\n    /// exchange rate will not be up to date. Should only be used for non-stateful methods\\r\\n    function _getAssetRateView(uint256 currencyId)\\r\\n        private\\r\\n        view\\r\\n        returns (\\r\\n            int256,\\r\\n            AssetRateAdapter,\\r\\n            uint8\\r\\n        )\\r\\n    {\\r\\n        (AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) = _getAssetRateStorage(currencyId);\\r\\n\\r\\n        int256 rate;\\r\\n        if (address(rateOracle) == address(0)) {\\r\\n            // If no rate oracle is set, then set this to the identity\\r\\n            rate = ASSET_RATE_DECIMAL_DIFFERENCE;\\r\\n            // This will get raised to 10^x and return 1, will not end up with div by zero\\r\\n            underlyingDecimalPlaces = 0;\\r\\n        } else {\\r\\n            rate = rateOracle.getExchangeRateView();\\r\\n            require(rate > 0); // dev: invalid exchange rate\\r\\n        }\\r\\n\\r\\n        return (rate, rateOracle, underlyingDecimalPlaces);\\r\\n    }\\r\\n\\r\\n    /// @notice Gets an asset rate using a stateful function, accrues interest so the\\r\\n    /// exchange rate will be up to date for the current block.\\r\\n    function _getAssetRateStateful(uint256 currencyId)\\r\\n        private\\r\\n        returns (\\r\\n            int256,\\r\\n            AssetRateAdapter,\\r\\n            uint8\\r\\n        )\\r\\n    {\\r\\n        (AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) = _getAssetRateStorage(currencyId);\\r\\n\\r\\n        int256 rate;\\r\\n        if (address(rateOracle) == address(0)) {\\r\\n            // If no rate oracle is set, then set this to the identity\\r\\n            rate = ASSET_RATE_DECIMAL_DIFFERENCE;\\r\\n            // This will get raised to 10^x and return 1, will not end up with div by zero\\r\\n            underlyingDecimalPlaces = 0;\\r\\n        } else {\\r\\n            rate = rateOracle.getExchangeRateStateful();\\r\\n            require(rate > 0); // dev: invalid exchange rate\\r\\n        }\\r\\n\\r\\n        return (rate, rateOracle, underlyingDecimalPlaces);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns an asset rate object using the view method\\r\\n    function buildAssetRateView(uint256 currencyId)\\r\\n        internal\\r\\n        view\\r\\n        returns (AssetRateParameters memory)\\r\\n    {\\r\\n        (int256 rate, AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) =\\r\\n            _getAssetRateView(currencyId);\\r\\n\\r\\n        return\\r\\n            AssetRateParameters({\\r\\n                rateOracle: rateOracle,\\r\\n                rate: rate,\\r\\n                // No overflow, restricted on storage\\r\\n                underlyingDecimals: int256(10**underlyingDecimalPlaces)\\r\\n            });\\r\\n    }\\r\\n\\r\\n    /// @notice Returns an asset rate object using the stateful method\\r\\n    function buildAssetRateStateful(uint256 currencyId)\\r\\n        internal\\r\\n        returns (AssetRateParameters memory)\\r\\n    {\\r\\n        (int256 rate, AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) =\\r\\n            _getAssetRateStateful(currencyId);\\r\\n\\r\\n        return\\r\\n            AssetRateParameters({\\r\\n                rateOracle: rateOracle,\\r\\n                rate: rate,\\r\\n                // No overflow, restricted on storage\\r\\n                underlyingDecimals: int256(10**underlyingDecimalPlaces)\\r\\n            });\\r\\n    }\\r\\n\\r\\n    /// @dev Gets a settlement rate object\\r\\n    function _getSettlementRateStorage(uint256 currencyId, uint256 maturity)\\r\\n        private\\r\\n        view\\r\\n        returns (\\r\\n            int256 settlementRate,\\r\\n            uint8 underlyingDecimalPlaces\\r\\n        )\\r\\n    {\\r\\n        mapping(uint256 => mapping(uint256 => SettlementRateStorage)) storage store = LibStorage.getSettlementRateStorage();\\r\\n        SettlementRateStorage storage rateStorage = store[currencyId][maturity];\\r\\n        settlementRate = rateStorage.settlementRate;\\r\\n        underlyingDecimalPlaces = rateStorage.underlyingDecimalPlaces;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns a settlement rate object using the view method\\r\\n    function buildSettlementRateView(uint256 currencyId, uint256 maturity)\\r\\n        internal\\r\\n        view\\r\\n        returns (AssetRateParameters memory)\\r\\n    {\\r\\n        // prettier-ignore\\r\\n        (\\r\\n            int256 settlementRate,\\r\\n            uint8 underlyingDecimalPlaces\\r\\n        ) = _getSettlementRateStorage(currencyId, maturity);\\r\\n\\r\\n        // Asset exchange rates cannot be zero\\r\\n        if (settlementRate == 0) {\\r\\n            // If settlement rate has not been set then we need to fetch it\\r\\n            // prettier-ignore\\r\\n            (\\r\\n                settlementRate,\\r\\n                /* address */,\\r\\n                underlyingDecimalPlaces\\r\\n            ) = _getAssetRateView(currencyId);\\r\\n        }\\r\\n\\r\\n        return AssetRateParameters(\\r\\n            AssetRateAdapter(address(0)),\\r\\n            settlementRate,\\r\\n            // No overflow, restricted on storage\\r\\n            int256(10**underlyingDecimalPlaces)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Returns a settlement rate object and sets the rate if it has not been set yet\\r\\n    function buildSettlementRateStateful(\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime\\r\\n    ) internal returns (AssetRateParameters memory) {\\r\\n        (int256 settlementRate, uint8 underlyingDecimalPlaces) =\\r\\n            _getSettlementRateStorage(currencyId, maturity);\\r\\n\\r\\n        if (settlementRate == 0) {\\r\\n            // Settlement rate has not yet been set, set it in this branch\\r\\n            AssetRateAdapter rateOracle;\\r\\n            // If rate oracle == 0 then this will return the identity settlement rate\\r\\n            // prettier-ignore\\r\\n            (\\r\\n                settlementRate,\\r\\n                rateOracle,\\r\\n                underlyingDecimalPlaces\\r\\n            ) = _getAssetRateStateful(currencyId);\\r\\n\\r\\n            if (address(rateOracle) != address(0)) {\\r\\n                mapping(uint256 => mapping(uint256 => SettlementRateStorage)) storage store = LibStorage.getSettlementRateStorage();\\r\\n                // Only need to set settlement rates when the rate oracle is set (meaning the asset token has\\r\\n                // a conversion rate to an underlying). If not set then the asset cash always settles to underlying at a 1-1\\r\\n                // rate since they are the same.\\r\\n                require(0 < blockTime && maturity <= blockTime && blockTime <= type(uint40).max); // dev: settlement rate timestamp overflow\\r\\n                require(0 < settlementRate && settlementRate <= type(uint128).max); // dev: settlement rate overflow\\r\\n\\r\\n                SettlementRateStorage storage rateStorage = store[currencyId][maturity];\\r\\n                rateStorage.blockTime = uint40(blockTime);\\r\\n                rateStorage.settlementRate = uint128(settlementRate);\\r\\n                rateStorage.underlyingDecimalPlaces = underlyingDecimalPlaces;\\r\\n                emit SetSettlementRate(currencyId, maturity, uint128(settlementRate));\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return AssetRateParameters(\\r\\n            AssetRateAdapter(address(0)),\\r\\n            settlementRate,\\r\\n            // No overflow, restricted on storage\\r\\n            int256(10**underlyingDecimalPlaces)\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/markets/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary DateTime {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /// @notice Returns the current reference time which is how all the AMM dates are calculated.\\r\\n    function getReferenceTime(uint256 blockTime) internal pure returns (uint256) {\\r\\n        require(blockTime >= Constants.QUARTER);\\r\\n        return blockTime - (blockTime % Constants.QUARTER);\\r\\n    }\\r\\n\\r\\n    /// @notice Truncates a date to midnight UTC time\\r\\n    function getTimeUTC0(uint256 time) internal pure returns (uint256) {\\r\\n        require(time >= Constants.DAY);\\r\\n        return time - (time % Constants.DAY);\\r\\n    }\\r\\n\\r\\n    /// @notice These are the predetermined market offsets for trading\\r\\n    /// @dev Markets are 1-indexed because the 0 index means that no markets are listed for the cash group.\\r\\n    function getTradedMarket(uint256 index) internal pure returns (uint256) {\\r\\n        if (index == 1) return Constants.QUARTER;\\r\\n        if (index == 2) return 2 * Constants.QUARTER;\\r\\n        if (index == 3) return Constants.YEAR;\\r\\n        if (index == 4) return 2 * Constants.YEAR;\\r\\n        if (index == 5) return 5 * Constants.YEAR;\\r\\n        if (index == 6) return 10 * Constants.YEAR;\\r\\n        if (index == 7) return 20 * Constants.YEAR;\\r\\n\\r\\n        revert(\\\"Invalid index\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Determines if the maturity falls on one of the valid on chain market dates.\\r\\n    function isValidMarketMaturity(\\r\\n        uint256 maxMarketIndex,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime\\r\\n    ) internal pure returns (bool) {\\r\\n        require(maxMarketIndex > 0, \\\"CG: no markets listed\\\");\\r\\n        require(maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX, \\\"CG: market index bound\\\");\\r\\n\\r\\n        if (maturity % Constants.QUARTER != 0) return false;\\r\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\r\\n\\r\\n        for (uint256 i = 1; i <= maxMarketIndex; i++) {\\r\\n            if (maturity == tRef.add(DateTime.getTradedMarket(i))) return true;\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /// @notice Determines if an idiosyncratic maturity is valid and returns the bit reference that is the case.\\r\\n    function isValidMaturity(\\r\\n        uint256 maxMarketIndex,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime\\r\\n    ) internal pure returns (bool) {\\r\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\r\\n        uint256 maxMaturity = tRef.add(DateTime.getTradedMarket(maxMarketIndex));\\r\\n        // Cannot trade past max maturity\\r\\n        if (maturity > maxMaturity) return false;\\r\\n\\r\\n        // prettier-ignore\\r\\n        (/* */, bool isValid) = DateTime.getBitNumFromMaturity(blockTime, maturity);\\r\\n        return isValid;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the market index for a given maturity, if the maturity is idiosyncratic\\r\\n    /// will return the nearest market index that is larger than the maturity.\\r\\n    /// @return uint marketIndex, bool isIdiosyncratic\\r\\n    function getMarketIndex(\\r\\n        uint256 maxMarketIndex,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime\\r\\n    ) internal pure returns (uint256, bool) {\\r\\n        require(maxMarketIndex > 0, \\\"CG: no markets listed\\\");\\r\\n        require(maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX, \\\"CG: market index bound\\\");\\r\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\r\\n\\r\\n        for (uint256 i = 1; i <= maxMarketIndex; i++) {\\r\\n            uint256 marketMaturity = tRef.add(DateTime.getTradedMarket(i));\\r\\n            // If market matches then is not idiosyncratic\\r\\n            if (marketMaturity == maturity) return (i, false);\\r\\n            // Returns the market that is immediately greater than the maturity\\r\\n            if (marketMaturity > maturity) return (i, true);\\r\\n        }\\r\\n\\r\\n        revert(\\\"CG: no market found\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Given a bit number and the reference time of the first bit, returns the bit number\\r\\n    /// of a given maturity.\\r\\n    /// @return bitNum and a true or false if the maturity falls on the exact bit\\r\\n    function getBitNumFromMaturity(uint256 blockTime, uint256 maturity)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256, bool)\\r\\n    {\\r\\n        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);\\r\\n\\r\\n        // Maturities must always divide days evenly\\r\\n        if (maturity % Constants.DAY != 0) return (0, false);\\r\\n        // Maturity cannot be in the past\\r\\n        if (blockTimeUTC0 >= maturity) return (0, false);\\r\\n\\r\\n        // Overflow check done above\\r\\n        // daysOffset has no remainders, checked above\\r\\n        uint256 daysOffset = (maturity - blockTimeUTC0) / Constants.DAY;\\r\\n\\r\\n        // These if statements need to fall through to the next one\\r\\n        if (daysOffset <= Constants.MAX_DAY_OFFSET) {\\r\\n            return (daysOffset, true);\\r\\n        } else if (daysOffset <= Constants.MAX_WEEK_OFFSET) {\\r\\n            // (daysOffset - MAX_DAY_OFFSET) is the days overflow into the week portion, must be > 0\\r\\n            // (blockTimeUTC0 % WEEK) / DAY is the offset into the week portion\\r\\n            // This returns the offset from the previous max offset in days\\r\\n            uint256 offsetInDays =\\r\\n                daysOffset -\\r\\n                    Constants.MAX_DAY_OFFSET +\\r\\n                    (blockTimeUTC0 % Constants.WEEK) /\\r\\n                    Constants.DAY;\\r\\n            \\r\\n            return (\\r\\n                // This converts the offset in days to its corresponding bit position, truncating down\\r\\n                // if it does not divide evenly into DAYS_IN_WEEK\\r\\n                Constants.WEEK_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_WEEK,\\r\\n                (offsetInDays % Constants.DAYS_IN_WEEK) == 0\\r\\n            );\\r\\n        } else if (daysOffset <= Constants.MAX_MONTH_OFFSET) {\\r\\n            uint256 offsetInDays =\\r\\n                daysOffset -\\r\\n                    Constants.MAX_WEEK_OFFSET +\\r\\n                    (blockTimeUTC0 % Constants.MONTH) /\\r\\n                    Constants.DAY;\\r\\n\\r\\n            return (\\r\\n                Constants.MONTH_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_MONTH,\\r\\n                (offsetInDays % Constants.DAYS_IN_MONTH) == 0\\r\\n            );\\r\\n        } else if (daysOffset <= Constants.MAX_QUARTER_OFFSET) {\\r\\n            uint256 offsetInDays =\\r\\n                daysOffset -\\r\\n                    Constants.MAX_MONTH_OFFSET +\\r\\n                    (blockTimeUTC0 % Constants.QUARTER) /\\r\\n                    Constants.DAY;\\r\\n\\r\\n            return (\\r\\n                Constants.QUARTER_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_QUARTER,\\r\\n                (offsetInDays % Constants.DAYS_IN_QUARTER) == 0\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // This is the maximum 1-indexed bit num, it is never valid because it is beyond the 20\\r\\n        // year max maturity\\r\\n        return (256, false);\\r\\n    }\\r\\n\\r\\n    /// @notice Given a bit number and a block time returns the maturity that the bit number\\r\\n    /// should reference. Bit numbers are one indexed.\\r\\n    function getMaturityFromBitNum(uint256 blockTime, uint256 bitNum)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        require(bitNum != 0); // dev: cash group get maturity from bit num is zero\\r\\n        require(bitNum <= 256); // dev: cash group get maturity from bit num overflow\\r\\n        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);\\r\\n        uint256 firstBit;\\r\\n\\r\\n        if (bitNum <= Constants.WEEK_BIT_OFFSET) {\\r\\n            return blockTimeUTC0 + bitNum * Constants.DAY;\\r\\n        } else if (bitNum <= Constants.MONTH_BIT_OFFSET) {\\r\\n            firstBit =\\r\\n                blockTimeUTC0 +\\r\\n                Constants.MAX_DAY_OFFSET * Constants.DAY -\\r\\n                // This backs up to the day that is divisible by a week\\r\\n                (blockTimeUTC0 % Constants.WEEK);\\r\\n            return firstBit + (bitNum - Constants.WEEK_BIT_OFFSET) * Constants.WEEK;\\r\\n        } else if (bitNum <= Constants.QUARTER_BIT_OFFSET) {\\r\\n            firstBit =\\r\\n                blockTimeUTC0 +\\r\\n                Constants.MAX_WEEK_OFFSET * Constants.DAY -\\r\\n                (blockTimeUTC0 % Constants.MONTH);\\r\\n            return firstBit + (bitNum - Constants.MONTH_BIT_OFFSET) * Constants.MONTH;\\r\\n        } else {\\r\\n            firstBit =\\r\\n                blockTimeUTC0 +\\r\\n                Constants.MAX_MONTH_OFFSET * Constants.DAY -\\r\\n                (blockTimeUTC0 % Constants.QUARTER);\\r\\n            return firstBit + (bitNum - Constants.QUARTER_BIT_OFFSET) * Constants.QUARTER;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/balances/BalanceHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./Incentives.sol\\\";\\r\\nimport \\\"./TokenHandler.sol\\\";\\r\\nimport \\\"../AccountContextHandler.sol\\\";\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../math/FloatingPoint56.sol\\\";\\r\\n\\r\\nlibrary BalanceHandler {\\r\\n    using SafeInt256 for int256;\\r\\n    using TokenHandler for Token;\\r\\n    using AssetRate for AssetRateParameters;\\r\\n    using AccountContextHandler for AccountContext;\\r\\n\\r\\n    /// @notice Emitted when a cash balance changes\\r\\n    event CashBalanceChange(address indexed account, uint16 indexed currencyId, int256 netCashChange);\\r\\n    /// @notice Emitted when nToken supply changes (not the same as transfers)\\r\\n    event nTokenSupplyChange(address indexed account, uint16 indexed currencyId, int256 tokenSupplyChange);\\r\\n    /// @notice Emitted when reserve fees are accrued\\r\\n    event ReserveFeeAccrued(uint16 indexed currencyId, int256 fee);\\r\\n    /// @notice Emitted when reserve balance is updated\\r\\n    event ReserveBalanceUpdated(uint16 indexed currencyId, int256 newBalance);\\r\\n    /// @notice Emitted when reserve balance is harvested\\r\\n    event ExcessReserveBalanceHarvested(uint16 indexed currencyId, int256 harvestAmount);\\r\\n\\r\\n    /// @notice Deposits asset tokens into an account\\r\\n    /// @dev Handles two special cases when depositing tokens into an account.\\r\\n    ///  - If a token has transfer fees then the amount specified does not equal the amount that the contract\\r\\n    ///    will receive. Complete the deposit here rather than in finalize so that the contract has the correct\\r\\n    ///    balance to work with.\\r\\n    ///  - Force a transfer before finalize to allow a different account to deposit into an account\\r\\n    /// @return assetAmountInternal which is the converted asset amount accounting for transfer fees\\r\\n    function depositAssetToken(\\r\\n        BalanceState memory balanceState,\\r\\n        address account,\\r\\n        int256 assetAmountExternal,\\r\\n        bool forceTransfer\\r\\n    ) internal returns (int256 assetAmountInternal) {\\r\\n        if (assetAmountExternal == 0) return 0;\\r\\n        require(assetAmountExternal > 0); // dev: deposit asset token amount negative\\r\\n        Token memory token = TokenHandler.getAssetToken(balanceState.currencyId);\\r\\n        if (token.tokenType == TokenType.aToken) {\\r\\n            // Handles special accounting requirements for aTokens\\r\\n            assetAmountExternal = AaveHandler.convertToScaledBalanceExternal(\\r\\n                balanceState.currencyId,\\r\\n                assetAmountExternal\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // Force transfer is used to complete the transfer before going to finalize\\r\\n        if (token.hasTransferFee || forceTransfer) {\\r\\n            // If the token has a transfer fee the deposit amount may not equal the actual amount\\r\\n            // that the contract will receive. We handle the deposit here and then update the netCashChange\\r\\n            // accordingly which is denominated in internal precision.\\r\\n            int256 assetAmountExternalPrecisionFinal = token.transfer(account, balanceState.currencyId, assetAmountExternal);\\r\\n            // Convert the external precision to internal, it's possible that we lose dust amounts here but\\r\\n            // this is unavoidable because we do not know how transfer fees are calculated.\\r\\n            assetAmountInternal = token.convertToInternal(assetAmountExternalPrecisionFinal);\\r\\n            // Transfer has been called\\r\\n            balanceState.netCashChange = balanceState.netCashChange.add(assetAmountInternal);\\r\\n\\r\\n            return assetAmountInternal;\\r\\n        } else {\\r\\n            assetAmountInternal = token.convertToInternal(assetAmountExternal);\\r\\n            // Otherwise add the asset amount here. It may be net off later and we want to only do\\r\\n            // a single transfer during the finalize method. Use internal precision to ensure that internal accounting\\r\\n            // and external account remain in sync.\\r\\n            // Transfer will be deferred\\r\\n            balanceState.netAssetTransferInternalPrecision = balanceState\\r\\n                .netAssetTransferInternalPrecision\\r\\n                .add(assetAmountInternal);\\r\\n\\r\\n            // Returns the converted assetAmountExternal to the internal amount\\r\\n            return assetAmountInternal;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Handle deposits of the underlying token\\r\\n    /// @dev In this case we must wrap the underlying token into an asset token, ensuring that we do not end up\\r\\n    /// with any underlying tokens left as dust on the contract.\\r\\n    function depositUnderlyingToken(\\r\\n        BalanceState memory balanceState,\\r\\n        address account,\\r\\n        int256 underlyingAmountExternal\\r\\n    ) internal returns (int256) {\\r\\n        if (underlyingAmountExternal == 0) return 0;\\r\\n        require(underlyingAmountExternal > 0); // dev: deposit underlying token negative\\r\\n\\r\\n        Token memory underlyingToken = TokenHandler.getUnderlyingToken(balanceState.currencyId);\\r\\n        // This is the exact amount of underlying tokens the account has in external precision.\\r\\n        if (underlyingToken.tokenType == TokenType.Ether) {\\r\\n            // Underflow checked above\\r\\n            require(uint256(underlyingAmountExternal) == msg.value, \\\"ETH Balance\\\");\\r\\n        } else {\\r\\n            underlyingAmountExternal = underlyingToken.transfer(account, balanceState.currencyId, underlyingAmountExternal);\\r\\n        }\\r\\n\\r\\n        Token memory assetToken = TokenHandler.getAssetToken(balanceState.currencyId);\\r\\n        int256 assetTokensReceivedExternalPrecision =\\r\\n            assetToken.mint(balanceState.currencyId, SafeInt256.toUint(underlyingAmountExternal));\\r\\n\\r\\n        // cTokens match INTERNAL_TOKEN_PRECISION so this will short circuit but we leave this here in case a different\\r\\n        // type of asset token is listed in the future. It's possible if those tokens have a different precision dust may\\r\\n        // accrue but that is not relevant now.\\r\\n        int256 assetTokensReceivedInternal =\\r\\n            assetToken.convertToInternal(assetTokensReceivedExternalPrecision);\\r\\n        // Transfer / mint has taken effect\\r\\n        balanceState.netCashChange = balanceState.netCashChange.add(assetTokensReceivedInternal);\\r\\n\\r\\n        return assetTokensReceivedInternal;\\r\\n    }\\r\\n\\r\\n    /// @notice Finalizes an account's balances, handling any transfer logic required\\r\\n    /// @dev This method SHOULD NOT be used for nToken accounts, for that use setBalanceStorageForNToken\\r\\n    /// as the nToken is limited in what types of balances it can hold.\\r\\n    function finalize(\\r\\n        BalanceState memory balanceState,\\r\\n        address account,\\r\\n        AccountContext memory accountContext,\\r\\n        bool redeemToUnderlying\\r\\n    ) internal returns (int256 transferAmountExternal) {\\r\\n        bool mustUpdate;\\r\\n        if (balanceState.netNTokenTransfer < 0) {\\r\\n            require(\\r\\n                balanceState.storedNTokenBalance\\r\\n                    .add(balanceState.netNTokenSupplyChange)\\r\\n                    .add(balanceState.netNTokenTransfer) >= 0,\\r\\n                \\\"Neg nToken\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (balanceState.netAssetTransferInternalPrecision < 0) {\\r\\n            require(\\r\\n                balanceState.storedCashBalance\\r\\n                    .add(balanceState.netCashChange)\\r\\n                    .add(balanceState.netAssetTransferInternalPrecision) >= 0,\\r\\n                \\\"Neg Cash\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // Transfer amount is checked inside finalize transfers in case when converting to external we\\r\\n        // round down to zero. This returns the actual net transfer in internal precision as well.\\r\\n        (\\r\\n            transferAmountExternal,\\r\\n            balanceState.netAssetTransferInternalPrecision\\r\\n        ) = _finalizeTransfers(balanceState, account, redeemToUnderlying);\\r\\n        // No changes to total cash after this point\\r\\n        int256 totalCashChange = balanceState.netCashChange.add(balanceState.netAssetTransferInternalPrecision);\\r\\n\\r\\n        if (totalCashChange != 0) {\\r\\n            balanceState.storedCashBalance = balanceState.storedCashBalance.add(totalCashChange);\\r\\n            mustUpdate = true;\\r\\n\\r\\n            emit CashBalanceChange(\\r\\n                account,\\r\\n                uint16(balanceState.currencyId),\\r\\n                totalCashChange\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (balanceState.netNTokenTransfer != 0 || balanceState.netNTokenSupplyChange != 0) {\\r\\n            // Final nToken balance is used to calculate the account incentive debt\\r\\n            int256 finalNTokenBalance = balanceState.storedNTokenBalance\\r\\n                .add(balanceState.netNTokenTransfer)\\r\\n                .add(balanceState.netNTokenSupplyChange);\\r\\n\\r\\n            // The toUint() call here will ensure that nToken balances never become negative\\r\\n            Incentives.claimIncentives(balanceState, account, finalNTokenBalance.toUint());\\r\\n\\r\\n            balanceState.storedNTokenBalance = finalNTokenBalance;\\r\\n\\r\\n            if (balanceState.netNTokenSupplyChange != 0) {\\r\\n                emit nTokenSupplyChange(\\r\\n                    account,\\r\\n                    uint16(balanceState.currencyId),\\r\\n                    balanceState.netNTokenSupplyChange\\r\\n                );\\r\\n            }\\r\\n\\r\\n            mustUpdate = true;\\r\\n        }\\r\\n\\r\\n        if (mustUpdate) {\\r\\n            _setBalanceStorage(\\r\\n                account,\\r\\n                balanceState.currencyId,\\r\\n                balanceState.storedCashBalance,\\r\\n                balanceState.storedNTokenBalance,\\r\\n                balanceState.lastClaimTime,\\r\\n                balanceState.accountIncentiveDebt\\r\\n            );\\r\\n        }\\r\\n\\r\\n        accountContext.setActiveCurrency(\\r\\n            balanceState.currencyId,\\r\\n            // Set active currency to true if either balance is non-zero\\r\\n            balanceState.storedCashBalance != 0 || balanceState.storedNTokenBalance != 0,\\r\\n            Constants.ACTIVE_IN_BALANCES\\r\\n        );\\r\\n\\r\\n        if (balanceState.storedCashBalance < 0) {\\r\\n            // NOTE: HAS_CASH_DEBT cannot be extinguished except by a free collateral check where all balances\\r\\n            // are examined\\r\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the amount transferred in underlying or asset terms depending on how redeem to underlying\\r\\n    /// is specified.\\r\\n    function _finalizeTransfers(\\r\\n        BalanceState memory balanceState,\\r\\n        address account,\\r\\n        bool redeemToUnderlying\\r\\n    ) private returns (int256 actualTransferAmountExternal, int256 assetTransferAmountInternal) {\\r\\n        Token memory assetToken = TokenHandler.getAssetToken(balanceState.currencyId);\\r\\n        // Dust accrual to the protocol is possible if the token decimals is less than internal token precision.\\r\\n        // See the comments in TokenHandler.convertToExternal and TokenHandler.convertToInternal\\r\\n        int256 assetTransferAmountExternal =\\r\\n            assetToken.convertToExternal(balanceState.netAssetTransferInternalPrecision);\\r\\n\\r\\n        if (assetTransferAmountExternal == 0) {\\r\\n            return (0, 0);\\r\\n        } else if (redeemToUnderlying && assetTransferAmountExternal < 0) {\\r\\n            // We only do the redeem to underlying if the asset transfer amount is less than zero. If it is greater than\\r\\n            // zero then we will do a normal transfer instead.\\r\\n\\r\\n            // We use the internal amount here and then scale it to the external amount so that there is\\r\\n            // no loss of precision between our internal accounting and the external account. In this case\\r\\n            // there will be no dust accrual in underlying tokens since we will transfer the exact amount\\r\\n            // of underlying that was received.\\r\\n\\r\\n            actualTransferAmountExternal = assetToken.redeem(\\r\\n                balanceState.currencyId,\\r\\n                account,\\r\\n                // No overflow, checked above\\r\\n                uint256(assetTransferAmountExternal.neg())\\r\\n            );\\r\\n\\r\\n            // In this case we're transferring underlying tokens, we want to convert the internal\\r\\n            // asset transfer amount to store in cash balances\\r\\n            assetTransferAmountInternal = assetToken.convertToInternal(assetTransferAmountExternal);\\r\\n        } else {\\r\\n            // NOTE: in the case of aTokens assetTransferAmountExternal is the scaledBalanceOf in external precision, it\\r\\n            // will be converted to balanceOf denomination inside transfer\\r\\n            actualTransferAmountExternal = assetToken.transfer(account, balanceState.currencyId, assetTransferAmountExternal);\\r\\n            // Convert the actual transferred amount\\r\\n            assetTransferAmountInternal = assetToken.convertToInternal(actualTransferAmountExternal);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Special method for settling negative current cash debts. This occurs when an account\\r\\n    /// has a negative fCash balance settle to cash. A settler may come and force the account to borrow\\r\\n    /// at the prevailing 3 month rate\\r\\n    /// @dev Use this method to avoid any nToken and transfer logic in finalize which is unnecessary.\\r\\n    function setBalanceStorageForSettleCashDebt(\\r\\n        address account,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        int256 amountToSettleAsset,\\r\\n        AccountContext memory accountContext\\r\\n    ) internal returns (int256) {\\r\\n        require(amountToSettleAsset >= 0); // dev: amount to settle negative\\r\\n        (int256 cashBalance, int256 nTokenBalance, uint256 lastClaimTime, uint256 accountIncentiveDebt) =\\r\\n            getBalanceStorage(account, cashGroup.currencyId);\\r\\n\\r\\n        // Prevents settlement of positive balances\\r\\n        require(cashBalance < 0, \\\"Invalid settle balance\\\");\\r\\n        if (amountToSettleAsset == 0) {\\r\\n            // Symbolizes that the entire debt should be settled\\r\\n            amountToSettleAsset = cashBalance.neg();\\r\\n            cashBalance = 0;\\r\\n        } else {\\r\\n            // A partial settlement of the debt\\r\\n            require(amountToSettleAsset <= cashBalance.neg(), \\\"Invalid amount to settle\\\");\\r\\n            cashBalance = cashBalance.add(amountToSettleAsset);\\r\\n        }\\r\\n\\r\\n        // NOTE: we do not update HAS_CASH_DEBT here because it is possible that the other balances\\r\\n        // also have cash debts\\r\\n        if (cashBalance == 0 && nTokenBalance == 0) {\\r\\n            accountContext.setActiveCurrency(\\r\\n                cashGroup.currencyId,\\r\\n                false,\\r\\n                Constants.ACTIVE_IN_BALANCES\\r\\n            );\\r\\n        }\\r\\n\\r\\n        _setBalanceStorage(\\r\\n            account,\\r\\n            cashGroup.currencyId,\\r\\n            cashBalance,\\r\\n            nTokenBalance,\\r\\n            lastClaimTime,\\r\\n            accountIncentiveDebt\\r\\n        );\\r\\n\\r\\n        // Emit the event here, we do not call finalize\\r\\n        emit CashBalanceChange(account, cashGroup.currencyId, amountToSettleAsset);\\r\\n\\r\\n        return amountToSettleAsset;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice A special balance storage method for fCash liquidation to reduce the bytecode size.\\r\\n     */\\r\\n    function setBalanceStorageForfCashLiquidation(\\r\\n        address account,\\r\\n        AccountContext memory accountContext,\\r\\n        uint16 currencyId,\\r\\n        int256 netCashChange\\r\\n    ) internal {\\r\\n        (int256 cashBalance, int256 nTokenBalance, uint256 lastClaimTime, uint256 accountIncentiveDebt) =\\r\\n            getBalanceStorage(account, currencyId);\\r\\n\\r\\n        int256 newCashBalance = cashBalance.add(netCashChange);\\r\\n        // If a cash balance is negative already we cannot put an account further into debt. In this case\\r\\n        // the netCashChange must be positive so that it is coming out of debt.\\r\\n        if (newCashBalance < 0) {\\r\\n            require(netCashChange > 0, \\\"Neg Cash\\\");\\r\\n            // NOTE: HAS_CASH_DEBT cannot be extinguished except by a free collateral check\\r\\n            // where all balances are examined. In this case the has cash debt flag should\\r\\n            // already be set (cash balances cannot get more negative) but we do it again\\r\\n            // here just to be safe.\\r\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\\r\\n        }\\r\\n\\r\\n        bool isActive = newCashBalance != 0 || nTokenBalance != 0;\\r\\n        accountContext.setActiveCurrency(currencyId, isActive, Constants.ACTIVE_IN_BALANCES);\\r\\n\\r\\n        // Emit the event here, we do not call finalize\\r\\n        emit CashBalanceChange(account, currencyId, netCashChange);\\r\\n\\r\\n        _setBalanceStorage(\\r\\n            account,\\r\\n            currencyId,\\r\\n            newCashBalance,\\r\\n            nTokenBalance,\\r\\n            lastClaimTime,\\r\\n            accountIncentiveDebt\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Helper method for settling the output of the SettleAssets method\\r\\n    function finalizeSettleAmounts(\\r\\n        address account,\\r\\n        AccountContext memory accountContext,\\r\\n        SettleAmount[] memory settleAmounts\\r\\n    ) internal {\\r\\n        for (uint256 i = 0; i < settleAmounts.length; i++) {\\r\\n            SettleAmount memory amt = settleAmounts[i];\\r\\n            if (amt.netCashChange == 0) continue;\\r\\n\\r\\n            (\\r\\n                int256 cashBalance,\\r\\n                int256 nTokenBalance,\\r\\n                uint256 lastClaimTime,\\r\\n                uint256 accountIncentiveDebt\\r\\n            ) = getBalanceStorage(account, amt.currencyId);\\r\\n\\r\\n            cashBalance = cashBalance.add(amt.netCashChange);\\r\\n            accountContext.setActiveCurrency(\\r\\n                amt.currencyId,\\r\\n                cashBalance != 0 || nTokenBalance != 0,\\r\\n                Constants.ACTIVE_IN_BALANCES\\r\\n            );\\r\\n\\r\\n            if (cashBalance < 0) {\\r\\n                accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\\r\\n            }\\r\\n\\r\\n            emit CashBalanceChange(\\r\\n                account,\\r\\n                uint16(amt.currencyId),\\r\\n                amt.netCashChange\\r\\n            );\\r\\n\\r\\n            _setBalanceStorage(\\r\\n                account,\\r\\n                amt.currencyId,\\r\\n                cashBalance,\\r\\n                nTokenBalance,\\r\\n                lastClaimTime,\\r\\n                accountIncentiveDebt\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Special method for setting balance storage for nToken\\r\\n    function setBalanceStorageForNToken(\\r\\n        address nTokenAddress,\\r\\n        uint256 currencyId,\\r\\n        int256 cashBalance\\r\\n    ) internal {\\r\\n        require(cashBalance >= 0); // dev: invalid nToken cash balance\\r\\n        _setBalanceStorage(nTokenAddress, currencyId, cashBalance, 0, 0, 0);\\r\\n    }\\r\\n\\r\\n    /// @notice increments fees to the reserve\\r\\n    function incrementFeeToReserve(uint256 currencyId, int256 fee) internal {\\r\\n        require(fee >= 0); // dev: invalid fee\\r\\n        // prettier-ignore\\r\\n        (int256 totalReserve, /* */, /* */, /* */) = getBalanceStorage(Constants.RESERVE, currencyId);\\r\\n        totalReserve = totalReserve.add(fee);\\r\\n        _setBalanceStorage(Constants.RESERVE, currencyId, totalReserve, 0, 0, 0);\\r\\n        emit ReserveFeeAccrued(uint16(currencyId), fee);\\r\\n    }\\r\\n\\r\\n    /// @notice harvests excess reserve balance\\r\\n    function harvestExcessReserveBalance(uint16 currencyId, int256 reserve, int256 assetInternalRedeemAmount) internal {\\r\\n        // parameters are validated by the caller\\r\\n        reserve = reserve.subNoNeg(assetInternalRedeemAmount);\\r\\n        _setBalanceStorage(Constants.RESERVE, currencyId, reserve, 0, 0, 0);\\r\\n        emit ExcessReserveBalanceHarvested(currencyId, assetInternalRedeemAmount);\\r\\n    }\\r\\n\\r\\n    /// @notice sets the reserve balance, see TreasuryAction.setReserveCashBalance\\r\\n    function setReserveCashBalance(uint16 currencyId, int256 newBalance) internal {\\r\\n        require(newBalance >= 0); // dev: invalid balance\\r\\n        _setBalanceStorage(Constants.RESERVE, currencyId, newBalance, 0, 0, 0);\\r\\n        emit ReserveBalanceUpdated(currencyId, newBalance);\\r\\n    }\\r\\n\\r\\n    /// @notice Sets internal balance storage.\\r\\n    function _setBalanceStorage(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        int256 cashBalance,\\r\\n        int256 nTokenBalance,\\r\\n        uint256 lastClaimTime,\\r\\n        uint256 accountIncentiveDebt\\r\\n    ) private {\\r\\n        mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage();\\r\\n        BalanceStorage storage balanceStorage = store[account][currencyId];\\r\\n\\r\\n        require(cashBalance >= type(int88).min && cashBalance <= type(int88).max); // dev: stored cash balance overflow\\r\\n        // Allows for 12 quadrillion nToken balance in 1e8 decimals before overflow\\r\\n        require(nTokenBalance >= 0 && nTokenBalance <= type(uint80).max); // dev: stored nToken balance overflow\\r\\n\\r\\n        if (lastClaimTime == 0) {\\r\\n            // In this case the account has migrated and we set the accountIncentiveDebt\\r\\n            // The maximum NOTE supply is 100_000_000e8 (1e16) which is less than 2^56 (7.2e16) so we should never\\r\\n            // encounter an overflow for accountIncentiveDebt\\r\\n            require(accountIncentiveDebt <= type(uint56).max); // dev: account incentive debt overflow\\r\\n            balanceStorage.accountIncentiveDebt = uint56(accountIncentiveDebt);\\r\\n        } else {\\r\\n            // In this case the last claim time has not changed and we do not update the last integral supply\\r\\n            // (stored in the accountIncentiveDebt position)\\r\\n            require(lastClaimTime == balanceStorage.lastClaimTime);\\r\\n        }\\r\\n\\r\\n        balanceStorage.lastClaimTime = uint32(lastClaimTime);\\r\\n        balanceStorage.nTokenBalance = uint80(nTokenBalance);\\r\\n        balanceStorage.cashBalance = int88(cashBalance);\\r\\n    }\\r\\n\\r\\n    /// @notice Gets internal balance storage, nTokens are stored alongside cash balances\\r\\n    function getBalanceStorage(address account, uint256 currencyId)\\r\\n        internal\\r\\n        view\\r\\n        returns (\\r\\n            int256 cashBalance,\\r\\n            int256 nTokenBalance,\\r\\n            uint256 lastClaimTime,\\r\\n            uint256 accountIncentiveDebt\\r\\n        )\\r\\n    {\\r\\n        mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage();\\r\\n        BalanceStorage storage balanceStorage = store[account][currencyId];\\r\\n\\r\\n        nTokenBalance = balanceStorage.nTokenBalance;\\r\\n        lastClaimTime = balanceStorage.lastClaimTime;\\r\\n        if (lastClaimTime > 0) {\\r\\n            // NOTE: this is only necessary to support the deprecated integral supply values, which are stored\\r\\n            // in the accountIncentiveDebt slot\\r\\n            accountIncentiveDebt = FloatingPoint56.unpackFrom56Bits(balanceStorage.accountIncentiveDebt);\\r\\n        } else {\\r\\n            accountIncentiveDebt = balanceStorage.accountIncentiveDebt;\\r\\n        }\\r\\n        cashBalance = balanceStorage.cashBalance;\\r\\n    }\\r\\n\\r\\n    /// @notice Loads a balance state memory object\\r\\n    /// @dev Balance state objects occupy a lot of memory slots, so this method allows\\r\\n    /// us to reuse them if possible\\r\\n    function loadBalanceState(\\r\\n        BalanceState memory balanceState,\\r\\n        address account,\\r\\n        uint16 currencyId,\\r\\n        AccountContext memory accountContext\\r\\n    ) internal view {\\r\\n        require(0 < currencyId && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id\\r\\n        balanceState.currencyId = currencyId;\\r\\n\\r\\n        if (accountContext.isActiveInBalances(currencyId)) {\\r\\n            (\\r\\n                balanceState.storedCashBalance,\\r\\n                balanceState.storedNTokenBalance,\\r\\n                balanceState.lastClaimTime,\\r\\n                balanceState.accountIncentiveDebt\\r\\n            ) = getBalanceStorage(account, currencyId);\\r\\n        } else {\\r\\n            balanceState.storedCashBalance = 0;\\r\\n            balanceState.storedNTokenBalance = 0;\\r\\n            balanceState.lastClaimTime = 0;\\r\\n            balanceState.accountIncentiveDebt = 0;\\r\\n        }\\r\\n\\r\\n        balanceState.netCashChange = 0;\\r\\n        balanceState.netAssetTransferInternalPrecision = 0;\\r\\n        balanceState.netNTokenTransfer = 0;\\r\\n        balanceState.netNTokenSupplyChange = 0;\\r\\n    }\\r\\n\\r\\n    /// @notice Used when manually claiming incentives in nTokenAction. Also sets the balance state\\r\\n    /// to storage to update the accountIncentiveDebt. lastClaimTime will be set to zero as accounts\\r\\n    /// are migrated to the new incentive calculation\\r\\n    function claimIncentivesManual(BalanceState memory balanceState, address account)\\r\\n        internal\\r\\n        returns (uint256 incentivesClaimed)\\r\\n    {\\r\\n        incentivesClaimed = Incentives.claimIncentives(\\r\\n            balanceState,\\r\\n            account,\\r\\n            balanceState.storedNTokenBalance.toUint()\\r\\n        );\\r\\n\\r\\n        _setBalanceStorage(\\r\\n            account,\\r\\n            balanceState.currencyId,\\r\\n            balanceState.storedCashBalance,\\r\\n            balanceState.storedNTokenBalance,\\r\\n            balanceState.lastClaimTime,\\r\\n            balanceState.accountIncentiveDebt\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/math/ABDKMath64x64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-4-Clause\\r\\n/*\\r\\n * ABDK Math 64.64 Smart Contract Library.  Copyright \u00a9 2019 by ABDK Consulting.\\r\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\r\\n */\\r\\npragma solidity ^0.5.0 || ^0.6.0 || ^0.7.0;\\r\\n\\r\\n/**\\r\\n * Smart contract library of mathematical functions operating with signed\\r\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\r\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\r\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\r\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\r\\n * represented by int128 type holding only the numerator.\\r\\n */\\r\\nlibrary ABDKMath64x64 {\\r\\n  /*\\r\\n   * Minimum value signed 64.64-bit fixed point number may have. \\r\\n   */\\r\\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\r\\n\\r\\n  /*\\r\\n   * Maximum value signed 64.64-bit fixed point number may have. \\r\\n   */\\r\\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n  /**\\r\\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\r\\n   * number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function fromInt (int256 x) internal pure returns (int128) {\\r\\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\r\\n    return int128 (x << 64);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\\r\\n   * rounding down.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64-bit integer number\\r\\n   */\\r\\n  function toInt (int128 x) internal pure returns (int64) {\\r\\n    return int64 (x >> 64);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\r\\n   * number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function fromUInt (uint256 x) internal pure returns (int128) {\\r\\n    require (x <= 0x7FFFFFFFFFFFFFFF);\\r\\n    return int128 (x << 64);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\r\\n   * number rounding down.  Revert on underflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return unsigned 64-bit integer number\\r\\n   */\\r\\n  function toUInt (int128 x) internal pure returns (uint64) {\\r\\n    require (x >= 0);\\r\\n    return uint64 (x >> 64);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\r\\n   * number rounding down.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 128.128-bin fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function from128x128 (int256 x) internal pure returns (int128) {\\r\\n    int256 result = x >> 64;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\r\\n   * number.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 128.128 fixed point number\\r\\n   */\\r\\n  function to128x128 (int128 x) internal pure returns (int256) {\\r\\n    return int256 (x) << 64;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x + y.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function add (int128 x, int128 y) internal pure returns (int128) {\\r\\n    int256 result = int256(x) + y;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x - y.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function sub (int128 x, int128 y) internal pure returns (int128) {\\r\\n    int256 result = int256(x) - y;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x * y rounding down.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function mul (int128 x, int128 y) internal pure returns (int128) {\\r\\n    int256 result = int256(x) * y >> 64;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\r\\n   * number and y is signed 256-bit integer number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64 fixed point number\\r\\n   * @param y signed 256-bit integer number\\r\\n   * @return signed 256-bit integer number\\r\\n   */\\r\\n  function muli (int128 x, int256 y) internal pure returns (int256) {\\r\\n    if (x == MIN_64x64) {\\r\\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\r\\n        y <= 0x1000000000000000000000000000000000000000000000000);\\r\\n      return -y << 63;\\r\\n    } else {\\r\\n      bool negativeResult = false;\\r\\n      if (x < 0) {\\r\\n        x = -x;\\r\\n        negativeResult = true;\\r\\n      }\\r\\n      if (y < 0) {\\r\\n        y = -y; // We rely on overflow behavior here\\r\\n        negativeResult = !negativeResult;\\r\\n      }\\r\\n      uint256 absoluteResult = mulu (x, uint256 (y));\\r\\n      if (negativeResult) {\\r\\n        require (absoluteResult <=\\r\\n          0x8000000000000000000000000000000000000000000000000000000000000000);\\r\\n        return -int256 (absoluteResult); // We rely on overflow behavior here\\r\\n      } else {\\r\\n        require (absoluteResult <=\\r\\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n        return int256 (absoluteResult);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\r\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64 fixed point number\\r\\n   * @param y unsigned 256-bit integer number\\r\\n   * @return unsigned 256-bit integer number\\r\\n   */\\r\\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\\r\\n    if (y == 0) return 0;\\r\\n\\r\\n    require (x >= 0);\\r\\n\\r\\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\r\\n    uint256 hi = uint256 (x) * (y >> 128);\\r\\n\\r\\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n    hi <<= 64;\\r\\n\\r\\n    require (hi <=\\r\\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\r\\n    return hi + lo;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\r\\n   * zero.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function div (int128 x, int128 y) internal pure returns (int128) {\\r\\n    require (y != 0);\\r\\n    int256 result = (int256 (x) << 64) / y;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\r\\n   * integer numbers.  Revert on overflow or when y is zero.\\r\\n   *\\r\\n   * @param x signed 256-bit integer number\\r\\n   * @param y signed 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function divi (int256 x, int256 y) internal pure returns (int128) {\\r\\n    require (y != 0);\\r\\n\\r\\n    bool negativeResult = false;\\r\\n    if (x < 0) {\\r\\n      x = -x; // We rely on overflow behavior here\\r\\n      negativeResult = true;\\r\\n    }\\r\\n    if (y < 0) {\\r\\n      y = -y; // We rely on overflow behavior here\\r\\n      negativeResult = !negativeResult;\\r\\n    }\\r\\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\\r\\n    if (negativeResult) {\\r\\n      require (absoluteResult <= 0x80000000000000000000000000000000);\\r\\n      return -int128 (absoluteResult); // We rely on overflow behavior here\\r\\n    } else {\\r\\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n      return int128 (absoluteResult); // We rely on overflow behavior here\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\r\\n   * integer numbers.  Revert on overflow or when y is zero.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @param y unsigned 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\\r\\n    require (y != 0);\\r\\n    uint128 result = divuu (x, y);\\r\\n    require (result <= uint128 (MAX_64x64));\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate -x.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function neg (int128 x) internal pure returns (int128) {\\r\\n    require (x != MIN_64x64);\\r\\n    return -x;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate |x|.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function abs (int128 x) internal pure returns (int128) {\\r\\n    require (x != MIN_64x64);\\r\\n    return x < 0 ? -x : x;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\r\\n   * zero.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function inv (int128 x) internal pure returns (int128) {\\r\\n    require (x != 0);\\r\\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function avg (int128 x, int128 y) internal pure returns (int128) {\\r\\n    return int128 ((int256 (x) + int256 (y)) >> 1);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\r\\n   * Revert on overflow or in case x * y is negative.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\\r\\n    int256 m = int256 (x) * int256 (y);\\r\\n    require (m >= 0);\\r\\n    require (m <\\r\\n        0x4000000000000000000000000000000000000000000000000000000000000000);\\r\\n    return int128 (sqrtu (uint256 (m)));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\r\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y uint256 value\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\\r\\n    bool negative = x < 0 && y & 1 == 1;\\r\\n\\r\\n    uint256 absX = uint128 (x < 0 ? -x : x);\\r\\n    uint256 absResult;\\r\\n    absResult = 0x100000000000000000000000000000000;\\r\\n\\r\\n    if (absX <= 0x10000000000000000) {\\r\\n      absX <<= 63;\\r\\n      while (y != 0) {\\r\\n        if (y & 0x1 != 0) {\\r\\n          absResult = absResult * absX >> 127;\\r\\n        }\\r\\n        absX = absX * absX >> 127;\\r\\n\\r\\n        if (y & 0x2 != 0) {\\r\\n          absResult = absResult * absX >> 127;\\r\\n        }\\r\\n        absX = absX * absX >> 127;\\r\\n\\r\\n        if (y & 0x4 != 0) {\\r\\n          absResult = absResult * absX >> 127;\\r\\n        }\\r\\n        absX = absX * absX >> 127;\\r\\n\\r\\n        if (y & 0x8 != 0) {\\r\\n          absResult = absResult * absX >> 127;\\r\\n        }\\r\\n        absX = absX * absX >> 127;\\r\\n\\r\\n        y >>= 4;\\r\\n      }\\r\\n\\r\\n      absResult >>= 64;\\r\\n    } else {\\r\\n      uint256 absXShift = 63;\\r\\n      if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\\r\\n      if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\\r\\n      if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\\r\\n      if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\\r\\n      if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\\r\\n      if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\\r\\n\\r\\n      uint256 resultShift = 0;\\r\\n      while (y != 0) {\\r\\n        require (absXShift < 64);\\r\\n\\r\\n        if (y & 0x1 != 0) {\\r\\n          absResult = absResult * absX >> 127;\\r\\n          resultShift += absXShift;\\r\\n          if (absResult > 0x100000000000000000000000000000000) {\\r\\n            absResult >>= 1;\\r\\n            resultShift += 1;\\r\\n          }\\r\\n        }\\r\\n        absX = absX * absX >> 127;\\r\\n        absXShift <<= 1;\\r\\n        if (absX >= 0x100000000000000000000000000000000) {\\r\\n            absX >>= 1;\\r\\n            absXShift += 1;\\r\\n        }\\r\\n\\r\\n        y >>= 1;\\r\\n      }\\r\\n\\r\\n      require (resultShift < 64);\\r\\n      absResult >>= 64 - resultShift;\\r\\n    }\\r\\n    int256 result = negative ? -int256 (absResult) : int256 (absResult);\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function sqrt (int128 x) internal pure returns (int128) {\\r\\n    require (x >= 0);\\r\\n    return int128 (sqrtu (uint256 (x) << 64));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate binary logarithm of x.  Revert if x <= 0.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function log_2 (int128 x) internal pure returns (int128) {\\r\\n    require (x > 0);\\r\\n\\r\\n    int256 msb = 0;\\r\\n    int256 xc = x;\\r\\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\r\\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\r\\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\r\\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\\r\\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\\r\\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\\r\\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\r\\n\\r\\n    int256 result = msb - 64 << 64;\\r\\n    uint256 ux = uint256 (x) << uint256 (127 - msb);\\r\\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\r\\n      ux *= ux;\\r\\n      uint256 b = ux >> 255;\\r\\n      ux >>= 127 + b;\\r\\n      result += bit * int256 (b);\\r\\n    }\\r\\n\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate natural logarithm of x.  Revert if x <= 0.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function ln (int128 x) internal pure returns (int128) {\\r\\n    require (x > 0);\\r\\n\\r\\n    return int128 (\\r\\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate binary exponent of x.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function exp_2 (int128 x) internal pure returns (int128) {\\r\\n    require (x < 0x400000000000000000); // Overflow\\r\\n\\r\\n    if (x < -0x400000000000000000) return 0; // Underflow\\r\\n\\r\\n    uint256 result = 0x80000000000000000000000000000000;\\r\\n\\r\\n    if (x & 0x8000000000000000 > 0)\\r\\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\r\\n    if (x & 0x4000000000000000 > 0)\\r\\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\r\\n    if (x & 0x2000000000000000 > 0)\\r\\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\r\\n    if (x & 0x1000000000000000 > 0)\\r\\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\r\\n    if (x & 0x800000000000000 > 0)\\r\\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\r\\n    if (x & 0x400000000000000 > 0)\\r\\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\r\\n    if (x & 0x200000000000000 > 0)\\r\\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\r\\n    if (x & 0x100000000000000 > 0)\\r\\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\r\\n    if (x & 0x80000000000000 > 0)\\r\\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\r\\n    if (x & 0x40000000000000 > 0)\\r\\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\r\\n    if (x & 0x20000000000000 > 0)\\r\\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\r\\n    if (x & 0x10000000000000 > 0)\\r\\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\r\\n    if (x & 0x8000000000000 > 0)\\r\\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\r\\n    if (x & 0x4000000000000 > 0)\\r\\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\r\\n    if (x & 0x2000000000000 > 0)\\r\\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\\r\\n    if (x & 0x1000000000000 > 0)\\r\\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\r\\n    if (x & 0x800000000000 > 0)\\r\\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\r\\n    if (x & 0x400000000000 > 0)\\r\\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\r\\n    if (x & 0x200000000000 > 0)\\r\\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\r\\n    if (x & 0x100000000000 > 0)\\r\\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\r\\n    if (x & 0x80000000000 > 0)\\r\\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\r\\n    if (x & 0x40000000000 > 0)\\r\\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\r\\n    if (x & 0x20000000000 > 0)\\r\\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\r\\n    if (x & 0x10000000000 > 0)\\r\\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\r\\n    if (x & 0x8000000000 > 0)\\r\\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\r\\n    if (x & 0x4000000000 > 0)\\r\\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\r\\n    if (x & 0x2000000000 > 0)\\r\\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\r\\n    if (x & 0x1000000000 > 0)\\r\\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\r\\n    if (x & 0x800000000 > 0)\\r\\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\r\\n    if (x & 0x400000000 > 0)\\r\\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\r\\n    if (x & 0x200000000 > 0)\\r\\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\r\\n    if (x & 0x100000000 > 0)\\r\\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\r\\n    if (x & 0x80000000 > 0)\\r\\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\r\\n    if (x & 0x40000000 > 0)\\r\\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\r\\n    if (x & 0x20000000 > 0)\\r\\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\r\\n    if (x & 0x10000000 > 0)\\r\\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\r\\n    if (x & 0x8000000 > 0)\\r\\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\r\\n    if (x & 0x4000000 > 0)\\r\\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\r\\n    if (x & 0x2000000 > 0)\\r\\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\r\\n    if (x & 0x1000000 > 0)\\r\\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\r\\n    if (x & 0x800000 > 0)\\r\\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\r\\n    if (x & 0x400000 > 0)\\r\\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\\r\\n    if (x & 0x200000 > 0)\\r\\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\\r\\n    if (x & 0x100000 > 0)\\r\\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\\r\\n    if (x & 0x80000 > 0)\\r\\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\r\\n    if (x & 0x40000 > 0)\\r\\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\r\\n    if (x & 0x20000 > 0)\\r\\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\r\\n    if (x & 0x10000 > 0)\\r\\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\r\\n    if (x & 0x8000 > 0)\\r\\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\r\\n    if (x & 0x4000 > 0)\\r\\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\r\\n    if (x & 0x2000 > 0)\\r\\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\\r\\n    if (x & 0x1000 > 0)\\r\\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\r\\n    if (x & 0x800 > 0)\\r\\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\r\\n    if (x & 0x400 > 0)\\r\\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\\r\\n    if (x & 0x200 > 0)\\r\\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\r\\n    if (x & 0x100 > 0)\\r\\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\\r\\n    if (x & 0x80 > 0)\\r\\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\r\\n    if (x & 0x40 > 0)\\r\\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\r\\n    if (x & 0x20 > 0)\\r\\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\\r\\n    if (x & 0x10 > 0)\\r\\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\r\\n    if (x & 0x8 > 0)\\r\\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\r\\n    if (x & 0x4 > 0)\\r\\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\r\\n    if (x & 0x2 > 0)\\r\\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\\r\\n    if (x & 0x1 > 0)\\r\\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\\r\\n\\r\\n    result >>= uint256 (63 - (x >> 64));\\r\\n    require (result <= uint256 (MAX_64x64));\\r\\n\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate natural exponent of x.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function exp (int128 x) internal pure returns (int128) {\\r\\n    require (x < 0x400000000000000000); // Overflow\\r\\n\\r\\n    if (x < -0x400000000000000000) return 0; // Underflow\\r\\n\\r\\n    return exp_2 (\\r\\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\r\\n   * integer numbers.  Revert on overflow or when y is zero.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @param y unsigned 256-bit integer number\\r\\n   * @return unsigned 64.64-bit fixed point number\\r\\n   */\\r\\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\\r\\n    require (y != 0);\\r\\n\\r\\n    uint256 result;\\r\\n\\r\\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\r\\n      result = (x << 64) / y;\\r\\n    else {\\r\\n      uint256 msb = 192;\\r\\n      uint256 xc = x >> 192;\\r\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\r\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\r\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\r\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\r\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\r\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\r\\n\\r\\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\\r\\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n\\r\\n      uint256 hi = result * (y >> 128);\\r\\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n\\r\\n      uint256 xh = x >> 192;\\r\\n      uint256 xl = x << 64;\\r\\n\\r\\n      if (xl < lo) xh -= 1;\\r\\n      xl -= lo; // We rely on overflow behavior here\\r\\n      lo = hi << 128;\\r\\n      if (xl < lo) xh -= 1;\\r\\n      xl -= lo; // We rely on overflow behavior here\\r\\n\\r\\n      assert (xh == hi >> 128);\\r\\n\\r\\n      result += xl / y;\\r\\n    }\\r\\n\\r\\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n    return uint128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\r\\n   * number.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @return unsigned 128-bit integer number\\r\\n   */\\r\\n  function sqrtu (uint256 x) private pure returns (uint128) {\\r\\n    if (x == 0) return 0;\\r\\n    else {\\r\\n      uint256 xx = x;\\r\\n      uint256 r = 1;\\r\\n      if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\\r\\n      if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\\r\\n      if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\\r\\n      if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\\r\\n      if (xx >= 0x100) { xx >>= 8; r <<= 4; }\\r\\n      if (xx >= 0x10) { xx >>= 4; r <<= 2; }\\r\\n      if (xx >= 0x8) { r <<= 1; }\\r\\n      r = (r + x / r) >> 1;\\r\\n      r = (r + x / r) >> 1;\\r\\n      r = (r + x / r) >> 1;\\r\\n      r = (r + x / r) >> 1;\\r\\n      r = (r + x / r) >> 1;\\r\\n      r = (r + x / r) >> 1;\\r\\n      r = (r + x / r) >> 1; // Seven iterations should be enough\\r\\n      uint256 r1 = x / r;\\r\\n      return uint128 (r < r1 ? r : r1);\\r\\n    }\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"contracts/internal/balances/Incentives.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./TokenHandler.sol\\\";\\r\\nimport \\\"../nToken/nTokenHandler.sol\\\";\\r\\nimport \\\"../nToken/nTokenSupply.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../external/MigrateIncentives.sol\\\";\\r\\nimport \\\"../../../interfaces/notional/IRewarder.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary Incentives {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeInt256 for int256;\\r\\n\\r\\n    /// @notice Calculates the total incentives to claim including those claimed under the previous\\r\\n    /// less accurate calculation. Once an account is migrated it will only claim incentives under\\r\\n    /// the more accurate regime\\r\\n    function calculateIncentivesToClaim(\\r\\n        BalanceState memory balanceState,\\r\\n        address tokenAddress,\\r\\n        uint256 accumulatedNOTEPerNToken,\\r\\n        uint256 finalNTokenBalance\\r\\n    ) internal view returns (uint256 incentivesToClaim) {\\r\\n        if (balanceState.lastClaimTime > 0) {\\r\\n            // If lastClaimTime is set then the account had incentives under the\\r\\n            // previous regime. Will calculate the final amount of incentives to claim here\\r\\n            // under the previous regime.\\r\\n            incentivesToClaim = MigrateIncentives.migrateAccountFromPreviousCalculation(\\r\\n                tokenAddress,\\r\\n                balanceState.storedNTokenBalance.toUint(),\\r\\n                balanceState.lastClaimTime,\\r\\n                // In this case the accountIncentiveDebt is stored as lastClaimIntegralSupply under\\r\\n                // the old calculation\\r\\n                balanceState.accountIncentiveDebt\\r\\n            );\\r\\n\\r\\n            // This marks the account as migrated and lastClaimTime will no longer be used\\r\\n            balanceState.lastClaimTime = 0;\\r\\n            // This value will be set immediately after this, set this to zero so that the calculation\\r\\n            // establishes a new baseline.\\r\\n            balanceState.accountIncentiveDebt = 0;\\r\\n        }\\r\\n\\r\\n        // If an account was migrated then they have no accountIncentivesDebt and should accumulate\\r\\n        // incentives based on their share since the new regime calculation started.\\r\\n        // If an account is just initiating their nToken balance then storedNTokenBalance will be zero\\r\\n        // and they will have no incentives to claim.\\r\\n        // This calculation uses storedNTokenBalance which is the balance of the account up until this point,\\r\\n        // this is important to ensure that the account does not claim for nTokens that they will mint or\\r\\n        // redeem on a going forward basis.\\r\\n\\r\\n        // The calculation below has the following precision:\\r\\n        //   storedNTokenBalance (INTERNAL_TOKEN_PRECISION)\\r\\n        //   MUL accumulatedNOTEPerNToken (INCENTIVE_ACCUMULATION_PRECISION)\\r\\n        //   DIV INCENTIVE_ACCUMULATION_PRECISION\\r\\n        //  = INTERNAL_TOKEN_PRECISION - (accountIncentivesDebt) INTERNAL_TOKEN_PRECISION\\r\\n        incentivesToClaim = incentivesToClaim.add(\\r\\n            balanceState.storedNTokenBalance.toUint()\\r\\n                .mul(accumulatedNOTEPerNToken)\\r\\n                .div(Constants.INCENTIVE_ACCUMULATION_PRECISION)\\r\\n                .sub(balanceState.accountIncentiveDebt)\\r\\n        );\\r\\n\\r\\n        // Update accountIncentivesDebt denominated in INTERNAL_TOKEN_PRECISION which marks the portion\\r\\n        // of the accumulatedNOTE that the account no longer has a claim over. Use the finalNTokenBalance\\r\\n        // here instead of storedNTokenBalance to mark the overall incentives claim that the account\\r\\n        // does not have a claim over. We do not aggregate this value with the previous accountIncentiveDebt\\r\\n        // because accumulatedNOTEPerNToken is already an aggregated value.\\r\\n\\r\\n        // The calculation below has the following precision:\\r\\n        //   finalNTokenBalance (INTERNAL_TOKEN_PRECISION)\\r\\n        //   MUL accumulatedNOTEPerNToken (INCENTIVE_ACCUMULATION_PRECISION)\\r\\n        //   DIV INCENTIVE_ACCUMULATION_PRECISION\\r\\n        //   = INTERNAL_TOKEN_PRECISION\\r\\n        balanceState.accountIncentiveDebt = finalNTokenBalance\\r\\n            .mul(accumulatedNOTEPerNToken)\\r\\n            .div(Constants.INCENTIVE_ACCUMULATION_PRECISION);\\r\\n    }\\r\\n\\r\\n    /// @notice Incentives must be claimed every time nToken balance changes.\\r\\n    /// @dev BalanceState.accountIncentiveDebt is updated in place here\\r\\n    function claimIncentives(\\r\\n        BalanceState memory balanceState,\\r\\n        address account,\\r\\n        uint256 finalNTokenBalance\\r\\n    ) internal returns (uint256 incentivesToClaim) {\\r\\n        uint256 blockTime = block.timestamp;\\r\\n        address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);\\r\\n        // This will updated the nToken storage and return what the accumulatedNOTEPerNToken\\r\\n        // is up until this current block time in 1e18 precision\\r\\n        uint256 accumulatedNOTEPerNToken = nTokenSupply.changeNTokenSupply(\\r\\n            tokenAddress,\\r\\n            balanceState.netNTokenSupplyChange,\\r\\n            blockTime\\r\\n        );\\r\\n\\r\\n        incentivesToClaim = calculateIncentivesToClaim(\\r\\n            balanceState,\\r\\n            tokenAddress,\\r\\n            accumulatedNOTEPerNToken,\\r\\n            finalNTokenBalance\\r\\n        );\\r\\n\\r\\n        // If a secondary incentive rewarder is set, then call it\\r\\n        IRewarder rewarder = nTokenHandler.getSecondaryRewarder(tokenAddress);\\r\\n        if (address(rewarder) != address(0)) {\\r\\n            rewarder.claimRewards(\\r\\n                account,\\r\\n                balanceState.currencyId,\\r\\n                // When this method is called from finalize, the storedNTokenBalance has not\\r\\n                // been updated to finalNTokenBalance yet so this is the balance before the change.\\r\\n                balanceState.storedNTokenBalance.toUint(),\\r\\n                finalNTokenBalance,\\r\\n                // When the rewarder is called, totalSupply has been updated already so may need to\\r\\n                // adjust its calculation using the net supply change figure here. Supply change\\r\\n                // may be zero when nTokens are transferred.\\r\\n                balanceState.netNTokenSupplyChange,\\r\\n                incentivesToClaim\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (incentivesToClaim > 0) TokenHandler.transferIncentive(account, incentivesToClaim);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/AccountContextHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../global/LibStorage.sol\\\";\\r\\nimport \\\"./balances/BalanceHandler.sol\\\";\\r\\nimport \\\"./portfolio/BitmapAssetsHandler.sol\\\";\\r\\nimport \\\"./portfolio/PortfolioHandler.sol\\\";\\r\\n\\r\\nlibrary AccountContextHandler {\\r\\n    using PortfolioHandler for PortfolioState;\\r\\n\\r\\n    bytes18 private constant TURN_OFF_PORTFOLIO_FLAGS = 0x7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF;\\r\\n    event AccountContextUpdate(address indexed account);\\r\\n\\r\\n    /// @notice Returns the account context of a given account\\r\\n    function getAccountContext(address account) internal view returns (AccountContext memory) {\\r\\n        mapping(address => AccountContext) storage store = LibStorage.getAccountStorage();\\r\\n        return store[account];\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the account context of a given account\\r\\n    function setAccountContext(AccountContext memory accountContext, address account) internal {\\r\\n        mapping(address => AccountContext) storage store = LibStorage.getAccountStorage();\\r\\n        store[account] = accountContext;\\r\\n        emit AccountContextUpdate(account);\\r\\n    }\\r\\n\\r\\n    function isBitmapEnabled(AccountContext memory accountContext) internal pure returns (bool) {\\r\\n        return accountContext.bitmapCurrencyId != 0;\\r\\n    }\\r\\n\\r\\n    /// @notice Enables a bitmap type portfolio for an account. A bitmap type portfolio allows\\r\\n    /// an account to hold more fCash than a normal portfolio, except only in a single currency.\\r\\n    /// Once enabled, it cannot be disabled or changed. An account can only enable a bitmap if\\r\\n    /// it has no assets or debt so that we ensure no assets are left stranded.\\r\\n    /// @param accountContext refers to the account where the bitmap will be enabled\\r\\n    /// @param currencyId the id of the currency to enable\\r\\n    /// @param blockTime the current block time to set the next settle time\\r\\n    function enableBitmapForAccount(\\r\\n        AccountContext memory accountContext,\\r\\n        uint16 currencyId,\\r\\n        uint256 blockTime\\r\\n    ) internal view {\\r\\n        require(!isBitmapEnabled(accountContext), \\\"Cannot change bitmap\\\");\\r\\n        require(0 < currencyId && currencyId <= Constants.MAX_CURRENCIES, \\\"Invalid currency id\\\");\\r\\n\\r\\n        // Account cannot have assets or debts\\r\\n        require(accountContext.assetArrayLength == 0, \\\"Cannot have assets\\\");\\r\\n        require(accountContext.hasDebt == 0x00, \\\"Cannot have debt\\\");\\r\\n\\r\\n        // Ensure that the active currency is set to false in the array so that there is no double\\r\\n        // counting during FreeCollateral\\r\\n        setActiveCurrency(accountContext, currencyId, false, Constants.ACTIVE_IN_BALANCES);\\r\\n        accountContext.bitmapCurrencyId = currencyId;\\r\\n\\r\\n        // Setting this is required to initialize the assets bitmap\\r\\n        uint256 nextSettleTime = DateTime.getTimeUTC0(blockTime);\\r\\n        require(nextSettleTime < type(uint40).max); // dev: blockTime overflow\\r\\n        accountContext.nextSettleTime = uint40(nextSettleTime);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns true if the context needs to settle\\r\\n    function mustSettleAssets(AccountContext memory accountContext) internal view returns (bool) {\\r\\n        uint256 blockTime = block.timestamp;\\r\\n\\r\\n        if (isBitmapEnabled(accountContext)) {\\r\\n            // nextSettleTime will be set to utc0 after settlement so we\\r\\n            // settle if this is strictly less than utc0\\r\\n            return accountContext.nextSettleTime < DateTime.getTimeUTC0(blockTime);\\r\\n        } else {\\r\\n            // 0 value occurs on an uninitialized account\\r\\n            // Assets mature exactly on the blockTime (not one second past) so in this\\r\\n            // case we settle on the block timestamp\\r\\n            return 0 < accountContext.nextSettleTime && accountContext.nextSettleTime <= blockTime;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Checks if a currency id (uint16 max) is in the 9 slots in the account\\r\\n    /// context active currencies list.\\r\\n    /// @dev NOTE: this may be more efficient as a binary search since we know that the array\\r\\n    /// is sorted\\r\\n    function isActiveInBalances(AccountContext memory accountContext, uint256 currencyId)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool)\\r\\n    {\\r\\n        require(currencyId != 0 && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id\\r\\n        bytes18 currencies = accountContext.activeCurrencies;\\r\\n\\r\\n        if (accountContext.bitmapCurrencyId == currencyId) return true;\\r\\n\\r\\n        while (currencies != 0x00) {\\r\\n            uint256 cid = uint16(bytes2(currencies) & Constants.UNMASK_FLAGS);\\r\\n            if (cid == currencyId) {\\r\\n                // Currency found, return if it is active in balances or not\\r\\n                return bytes2(currencies) & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES;\\r\\n            }\\r\\n\\r\\n            currencies = currencies << 16;\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /// @notice Iterates through the active currency list and removes, inserts or does nothing\\r\\n    /// to ensure that the active currency list is an ordered byte array of uint16 currency ids\\r\\n    /// that refer to the currencies that an account is active in.\\r\\n    ///\\r\\n    /// This is called to ensure that currencies are active when the account has a non zero cash balance,\\r\\n    /// a non zero nToken balance or a portfolio asset.\\r\\n    function setActiveCurrency(\\r\\n        AccountContext memory accountContext,\\r\\n        uint256 currencyId,\\r\\n        bool isActive,\\r\\n        bytes2 flags\\r\\n    ) internal pure {\\r\\n        require(0 < currencyId && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id\\r\\n\\r\\n        // If the bitmapped currency is already set then return here. Turning off the bitmap currency\\r\\n        // id requires other logical handling so we will do it elsewhere.\\r\\n        if (isActive && accountContext.bitmapCurrencyId == currencyId) return;\\r\\n\\r\\n        bytes18 prefix;\\r\\n        bytes18 suffix = accountContext.activeCurrencies;\\r\\n        uint256 shifts;\\r\\n\\r\\n        /// There are six possible outcomes from this search:\\r\\n        /// 1. The currency id is in the list\\r\\n        ///      - it must be set to active, do nothing\\r\\n        ///      - it must be set to inactive, shift suffix and concatenate\\r\\n        /// 2. The current id is greater than the one in the search:\\r\\n        ///      - it must be set to active, append to prefix and then concatenate the suffix,\\r\\n        ///        ensure that we do not lose the last 2 bytes if set.\\r\\n        ///      - it must be set to inactive, it is not in the list, do nothing\\r\\n        /// 3. Reached the end of the list:\\r\\n        ///      - it must be set to active, check that the last two bytes are not set and then\\r\\n        ///        append to the prefix\\r\\n        ///      - it must be set to inactive, do nothing\\r\\n        while (suffix != 0x00) {\\r\\n            uint256 cid = uint256(uint16(bytes2(suffix) & Constants.UNMASK_FLAGS));\\r\\n            // if matches and isActive then return, already in list\\r\\n            if (cid == currencyId && isActive) {\\r\\n                // set flag and return\\r\\n                accountContext.activeCurrencies =\\r\\n                    accountContext.activeCurrencies |\\r\\n                    (bytes18(flags) >> (shifts * 16));\\r\\n                return;\\r\\n            }\\r\\n\\r\\n            // if matches and not active then shift suffix to remove\\r\\n            if (cid == currencyId && !isActive) {\\r\\n                // turn off flag, if both flags are off then remove\\r\\n                suffix = suffix & ~bytes18(flags);\\r\\n                if (bytes2(suffix) & ~Constants.UNMASK_FLAGS == 0x0000) suffix = suffix << 16;\\r\\n                accountContext.activeCurrencies = prefix | (suffix >> (shifts * 16));\\r\\n                return;\\r\\n            }\\r\\n\\r\\n            // if greater than and isActive then insert into prefix\\r\\n            if (cid > currencyId && isActive) {\\r\\n                prefix = prefix | (bytes18(bytes2(uint16(currencyId)) | flags) >> (shifts * 16));\\r\\n                // check that the total length is not greater than 9, meaning that the last\\r\\n                // two bytes of the active currencies array should be zero\\r\\n                require((accountContext.activeCurrencies << 128) == 0x00); // dev: AC: too many currencies\\r\\n\\r\\n                // append the suffix\\r\\n                accountContext.activeCurrencies = prefix | (suffix >> ((shifts + 1) * 16));\\r\\n                return;\\r\\n            }\\r\\n\\r\\n            // if past the point of the currency id and not active, not in list\\r\\n            if (cid > currencyId && !isActive) return;\\r\\n\\r\\n            prefix = prefix | (bytes18(bytes2(suffix)) >> (shifts * 16));\\r\\n            suffix = suffix << 16;\\r\\n            shifts += 1;\\r\\n        }\\r\\n\\r\\n        // If reached this point and not active then return\\r\\n        if (!isActive) return;\\r\\n\\r\\n        // if end and isActive then insert into suffix, check max length\\r\\n        require(shifts < 9); // dev: AC: too many currencies\\r\\n        accountContext.activeCurrencies =\\r\\n            prefix |\\r\\n            (bytes18(bytes2(uint16(currencyId)) | flags) >> (shifts * 16));\\r\\n    }\\r\\n\\r\\n    function _clearPortfolioActiveFlags(bytes18 activeCurrencies) internal pure returns (bytes18) {\\r\\n        bytes18 result;\\r\\n        // This is required to clear the suffix as we append below\\r\\n        bytes18 suffix = activeCurrencies & TURN_OFF_PORTFOLIO_FLAGS;\\r\\n        uint256 shifts;\\r\\n\\r\\n        // This loop will append all currencies that are active in balances into the result.\\r\\n        while (suffix != 0x00) {\\r\\n            if (bytes2(suffix) & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES) {\\r\\n                // If any flags are active, then append.\\r\\n                result = result | (bytes18(bytes2(suffix)) >> shifts);\\r\\n                shifts += 16;\\r\\n            }\\r\\n            suffix = suffix << 16;\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /// @notice Stores a portfolio array and updates the account context information, this method should\\r\\n    /// be used whenever updating a portfolio array except in the case of nTokens\\r\\n    function storeAssetsAndUpdateContext(\\r\\n        AccountContext memory accountContext,\\r\\n        address account,\\r\\n        PortfolioState memory portfolioState,\\r\\n        bool isLiquidation\\r\\n    ) internal {\\r\\n        // Each of these parameters is recalculated based on the entire array of assets in store assets,\\r\\n        // regardless of whether or not they have been updated.\\r\\n        (bool hasDebt, bytes32 portfolioCurrencies, uint8 assetArrayLength, uint40 nextSettleTime) =\\r\\n            portfolioState.storeAssets(account);\\r\\n        accountContext.nextSettleTime = nextSettleTime;\\r\\n        require(mustSettleAssets(accountContext) == false); // dev: cannot store matured assets\\r\\n        accountContext.assetArrayLength = assetArrayLength;\\r\\n\\r\\n        // During liquidation it is possible for an array to go over the max amount of assets allowed due to\\r\\n        // liquidity tokens being withdrawn into fCash.\\r\\n        if (!isLiquidation) {\\r\\n            require(assetArrayLength <= uint8(Constants.MAX_TRADED_MARKET_INDEX)); // dev: max assets allowed\\r\\n        }\\r\\n\\r\\n        // Sets the hasDebt flag properly based on whether or not portfolio has asset debt, meaning\\r\\n        // a negative fCash balance.\\r\\n        if (hasDebt) {\\r\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;\\r\\n        } else {\\r\\n            // Turns off the ASSET_DEBT flag\\r\\n            accountContext.hasDebt = accountContext.hasDebt & ~Constants.HAS_ASSET_DEBT;\\r\\n        }\\r\\n\\r\\n        // Clear the active portfolio active flags and they will be recalculated in the next step\\r\\n        accountContext.activeCurrencies = _clearPortfolioActiveFlags(accountContext.activeCurrencies);\\r\\n\\r\\n        uint256 lastCurrency;\\r\\n        while (portfolioCurrencies != 0) {\\r\\n            // Portfolio currencies will not have flags, it is just an byte array of all the currencies found\\r\\n            // in a portfolio. They are appended in a sorted order so we can compare to the previous currency\\r\\n            // and only set it if they are different.\\r\\n            uint256 currencyId = uint16(bytes2(portfolioCurrencies));\\r\\n            if (currencyId != lastCurrency) {\\r\\n                setActiveCurrency(accountContext, currencyId, true, Constants.ACTIVE_IN_PORTFOLIO);\\r\\n            }\\r\\n            lastCurrency = currencyId;\\r\\n\\r\\n            portfolioCurrencies = portfolioCurrencies << 16;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/math/FloatingPoint56.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./Bitmap.sol\\\";\\r\\n\\r\\n/**\\r\\n * Packs an uint value into a \\\"floating point\\\" storage slot. Used for storing\\r\\n * lastClaimIntegralSupply values in balance storage. For these values, we don't need\\r\\n * to maintain exact precision but we don't want to be limited by storage size overflows.\\r\\n *\\r\\n * A floating point value is defined by the 48 most significant bits and an 8 bit number\\r\\n * of bit shifts required to restore its precision. The unpacked value will always be less\\r\\n * than the packed value with a maximum absolute loss of precision of (2 ** bitShift) - 1.\\r\\n */\\r\\nlibrary FloatingPoint56 {\\r\\n\\r\\n    function packTo56Bits(uint256 value) internal pure returns (uint56) {\\r\\n        uint256 bitShift;\\r\\n        // If the value is over the uint48 max value then we will shift it down\\r\\n        // given the index of the most significant bit. We store this bit shift \\r\\n        // in the least significant byte of the 56 bit slot available.\\r\\n        if (value > type(uint48).max) bitShift = (Bitmap.getMSB(value) - 47);\\r\\n\\r\\n        uint256 shiftedValue = value >> bitShift;\\r\\n        return uint56((shiftedValue << 8) | bitShift);\\r\\n    }\\r\\n\\r\\n    function unpackFrom56Bits(uint256 value) internal pure returns (uint256) {\\r\\n        // The least significant 8 bits will be the amount to bit shift\\r\\n        uint256 bitShift = uint256(uint8(value));\\r\\n        return ((value >> 8) << bitShift);\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/external/MigrateIncentives.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../global/LibStorage.sol\\\";\\r\\nimport \\\"../internal/nToken/nTokenHandler.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice Deployed library for migration of incentives from the old (inaccurate) calculation\\r\\n * to a newer, more accurate calculation based on SushiSwap MasterChef math. The more accurate\\r\\n * calculation is inside `Incentives.sol` and this library holds the legacy calculation. System\\r\\n * migration code can be found in `MigrateIncentivesFix.sol`\\r\\n */\\r\\nlibrary MigrateIncentives {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /// @notice Calculates the claimable incentives for a particular nToken and account in the\\r\\n    /// previous regime. This should only ever be called ONCE for an account / currency combination\\r\\n    /// to get the incentives accrued up until the migration date.\\r\\n    function migrateAccountFromPreviousCalculation(\\r\\n        address tokenAddress,\\r\\n        uint256 nTokenBalance,\\r\\n        uint256 lastClaimTime,\\r\\n        uint256 lastClaimIntegralSupply\\r\\n    ) external view returns (uint256) {\\r\\n        (\\r\\n            uint256 finalEmissionRatePerYear,\\r\\n            uint256 finalTotalIntegralSupply,\\r\\n            uint256 finalMigrationTime\\r\\n        ) = _getMigratedIncentiveValues(tokenAddress);\\r\\n\\r\\n        // This if statement should never be true but we return 0 just in case\\r\\n        if (lastClaimTime == 0 || lastClaimTime >= finalMigrationTime) return 0;\\r\\n\\r\\n        // No overflow here, checked above. All incentives are claimed up until finalMigrationTime\\r\\n        // using the finalTotalIntegralSupply. Both these values are set on migration and will not\\r\\n        // change.\\r\\n        uint256 timeSinceMigration = finalMigrationTime - lastClaimTime;\\r\\n\\r\\n        // (timeSinceMigration * INTERNAL_TOKEN_PRECISION * finalEmissionRatePerYear) / YEAR\\r\\n        uint256 incentiveRate =\\r\\n            timeSinceMigration\\r\\n                .mul(uint256(Constants.INTERNAL_TOKEN_PRECISION))\\r\\n                // Migration emission rate is stored as is, denominated in whole tokens\\r\\n                .mul(finalEmissionRatePerYear).mul(uint256(Constants.INTERNAL_TOKEN_PRECISION))\\r\\n                .div(Constants.YEAR);\\r\\n\\r\\n        // Returns the average supply using the integral of the total supply.\\r\\n        uint256 avgTotalSupply = finalTotalIntegralSupply.sub(lastClaimIntegralSupply).div(timeSinceMigration);\\r\\n        if (avgTotalSupply == 0) return 0;\\r\\n\\r\\n        uint256 incentivesToClaim = nTokenBalance.mul(incentiveRate).div(avgTotalSupply);\\r\\n        // incentiveRate has a decimal basis of 1e16 so divide by token precision to reduce to 1e8\\r\\n        incentivesToClaim = incentivesToClaim.div(uint256(Constants.INTERNAL_TOKEN_PRECISION));\\r\\n\\r\\n        return incentivesToClaim;\\r\\n    }\\r\\n\\r\\n    function _getMigratedIncentiveValues(\\r\\n        address tokenAddress\\r\\n    ) private view returns (\\r\\n        uint256 finalEmissionRatePerYear,\\r\\n        uint256 finalTotalIntegralSupply,\\r\\n        uint256 finalMigrationTime\\r\\n    ) {\\r\\n        mapping(address => nTokenTotalSupplyStorage_deprecated) storage store = LibStorage.getDeprecatedNTokenTotalSupplyStorage();\\r\\n        nTokenTotalSupplyStorage_deprecated storage d_nTokenStorage = store[tokenAddress];\\r\\n\\r\\n        // The total supply value is overridden as emissionRatePerYear during the initialization\\r\\n        finalEmissionRatePerYear = d_nTokenStorage.totalSupply;\\r\\n        finalTotalIntegralSupply = d_nTokenStorage.integralTotalSupply;\\r\\n        finalMigrationTime = d_nTokenStorage.lastSupplyChangeTime;\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/internal/portfolio/PortfolioHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./TransferAssets.sol\\\";\\r\\nimport \\\"../valuation/AssetHandler.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../global/LibStorage.sol\\\";\\r\\n\\r\\n/// @notice Handles the management of an array of assets including reading from storage, inserting\\r\\n/// updating, deleting and writing back to storage.\\r\\nlibrary PortfolioHandler {\\r\\n    using SafeInt256 for int256;\\r\\n    using AssetHandler for PortfolioAsset;\\r\\n\\r\\n    // Mirror of LibStorage.MAX_PORTFOLIO_ASSETS\\r\\n    uint256 private constant MAX_PORTFOLIO_ASSETS = 16;\\r\\n\\r\\n    /// @notice Primarily used by the TransferAssets library\\r\\n    function addMultipleAssets(PortfolioState memory portfolioState, PortfolioAsset[] memory assets)\\r\\n        internal\\r\\n        pure\\r\\n    {\\r\\n        for (uint256 i = 0; i < assets.length; i++) {\\r\\n            PortfolioAsset memory asset = assets[i];\\r\\n            if (asset.notional == 0) continue;\\r\\n\\r\\n            addAsset(\\r\\n                portfolioState,\\r\\n                asset.currencyId,\\r\\n                asset.maturity,\\r\\n                asset.assetType,\\r\\n                asset.notional\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _mergeAssetIntoArray(\\r\\n        PortfolioAsset[] memory assetArray,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 assetType,\\r\\n        int256 notional\\r\\n    ) private pure returns (bool) {\\r\\n        for (uint256 i = 0; i < assetArray.length; i++) {\\r\\n            PortfolioAsset memory asset = assetArray[i];\\r\\n            if (\\r\\n                asset.assetType != assetType ||\\r\\n                asset.currencyId != currencyId ||\\r\\n                asset.maturity != maturity\\r\\n            ) continue;\\r\\n\\r\\n            // Either of these storage states mean that some error in logic has occurred, we cannot\\r\\n            // store this portfolio\\r\\n            require(\\r\\n                asset.storageState != AssetStorageState.Delete &&\\r\\n                asset.storageState != AssetStorageState.RevertIfStored\\r\\n            ); // dev: portfolio handler deleted storage\\r\\n\\r\\n            int256 newNotional = asset.notional.add(notional);\\r\\n            // Liquidity tokens cannot be reduced below zero.\\r\\n            if (AssetHandler.isLiquidityToken(assetType)) {\\r\\n                require(newNotional >= 0); // dev: portfolio handler negative liquidity token balance\\r\\n            }\\r\\n\\r\\n            require(newNotional >= type(int88).min && newNotional <= type(int88).max); // dev: portfolio handler notional overflow\\r\\n\\r\\n            asset.notional = newNotional;\\r\\n            asset.storageState = AssetStorageState.Update;\\r\\n\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /// @notice Adds an asset to a portfolio state in memory (does not write to storage)\\r\\n    /// @dev Ensures that only one version of an asset exists in a portfolio (i.e. does not allow two fCash assets of the same maturity\\r\\n    /// to exist in a single portfolio). Also ensures that liquidity tokens do not have a negative notional.\\r\\n    function addAsset(\\r\\n        PortfolioState memory portfolioState,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 assetType,\\r\\n        int256 notional\\r\\n    ) internal pure {\\r\\n        if (\\r\\n            // Will return true if merged\\r\\n            _mergeAssetIntoArray(\\r\\n                portfolioState.storedAssets,\\r\\n                currencyId,\\r\\n                maturity,\\r\\n                assetType,\\r\\n                notional\\r\\n            )\\r\\n        ) return;\\r\\n\\r\\n        if (portfolioState.lastNewAssetIndex > 0) {\\r\\n            bool merged = _mergeAssetIntoArray(\\r\\n                portfolioState.newAssets,\\r\\n                currencyId,\\r\\n                maturity,\\r\\n                assetType,\\r\\n                notional\\r\\n            );\\r\\n            if (merged) return;\\r\\n        }\\r\\n\\r\\n        // At this point if we have not merged the asset then append to the array\\r\\n        // Cannot remove liquidity that the portfolio does not have\\r\\n        if (AssetHandler.isLiquidityToken(assetType)) {\\r\\n            require(notional >= 0); // dev: portfolio handler negative liquidity token balance\\r\\n        }\\r\\n        require(notional >= type(int88).min && notional <= type(int88).max); // dev: portfolio handler notional overflow\\r\\n\\r\\n        // Need to provision a new array at this point\\r\\n        if (portfolioState.lastNewAssetIndex == portfolioState.newAssets.length) {\\r\\n            portfolioState.newAssets = _extendNewAssetArray(portfolioState.newAssets);\\r\\n        }\\r\\n\\r\\n        // Otherwise add to the new assets array. It should not be possible to add matching assets in a single transaction, we will\\r\\n        // check this again when we write to storage. Assigning to memory directly here, do not allocate new memory via struct.\\r\\n        PortfolioAsset memory newAsset = portfolioState.newAssets[portfolioState.lastNewAssetIndex];\\r\\n        newAsset.currencyId = currencyId;\\r\\n        newAsset.maturity = maturity;\\r\\n        newAsset.assetType = assetType;\\r\\n        newAsset.notional = notional;\\r\\n        newAsset.storageState = AssetStorageState.NoChange;\\r\\n        portfolioState.lastNewAssetIndex += 1;\\r\\n    }\\r\\n\\r\\n    /// @dev Extends the new asset array if it is not large enough, this is likely to get a bit expensive if we do\\r\\n    /// it too much\\r\\n    function _extendNewAssetArray(PortfolioAsset[] memory newAssets)\\r\\n        private\\r\\n        pure\\r\\n        returns (PortfolioAsset[] memory)\\r\\n    {\\r\\n        // Double the size of the new asset array every time we have to extend to reduce the number of times\\r\\n        // that we have to extend it. This will go: 0, 1, 2, 4, 8 (probably stops there).\\r\\n        uint256 newLength = newAssets.length == 0 ? 1 : newAssets.length * 2;\\r\\n        PortfolioAsset[] memory extendedArray = new PortfolioAsset[](newLength);\\r\\n        for (uint256 i = 0; i < newAssets.length; i++) {\\r\\n            extendedArray[i] = newAssets[i];\\r\\n        }\\r\\n\\r\\n        return extendedArray;\\r\\n    }\\r\\n\\r\\n    /// @notice Takes a portfolio state and writes it to storage.\\r\\n    /// @dev This method should only be called directly by the nToken. Account updates to portfolios should happen via\\r\\n    /// the storeAssetsAndUpdateContext call in the AccountContextHandler.sol library.\\r\\n    /// @return updated variables to update the account context with\\r\\n    ///     hasDebt: whether or not the portfolio has negative fCash assets\\r\\n    ///     portfolioActiveCurrencies: a byte32 word with all the currencies in the portfolio\\r\\n    ///     uint8: the length of the storage array\\r\\n    ///     uint40: the new nextSettleTime for the portfolio\\r\\n    function storeAssets(PortfolioState memory portfolioState, address account)\\r\\n        internal\\r\\n        returns (\\r\\n            bool,\\r\\n            bytes32,\\r\\n            uint8,\\r\\n            uint40\\r\\n        )\\r\\n    {\\r\\n        bool hasDebt;\\r\\n        // NOTE: cannot have more than 16 assets or this byte object will overflow. Max assets is\\r\\n        // set to 7 and the worst case during liquidation would be 7 liquidity tokens that generate\\r\\n        // 7 additional fCash assets for a total of 14 assets. Although even in this case all assets\\r\\n        // would be of the same currency so it would not change the end result of the active currency\\r\\n        // calculation.\\r\\n        bytes32 portfolioActiveCurrencies;\\r\\n        uint256 nextSettleTime;\\r\\n\\r\\n        for (uint256 i = 0; i < portfolioState.storedAssets.length; i++) {\\r\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\r\\n            // NOTE: this is to prevent the storage of assets that have been modified in the AssetHandler\\r\\n            // during valuation.\\r\\n            require(asset.storageState != AssetStorageState.RevertIfStored);\\r\\n\\r\\n            // Mark any zero notional assets as deleted\\r\\n            if (asset.storageState != AssetStorageState.Delete && asset.notional == 0) {\\r\\n                deleteAsset(portfolioState, i);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // First delete assets from asset storage to maintain asset storage indexes\\r\\n        for (uint256 i = 0; i < portfolioState.storedAssets.length; i++) {\\r\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\r\\n\\r\\n            if (asset.storageState == AssetStorageState.Delete) {\\r\\n                // Delete asset from storage\\r\\n                uint256 currentSlot = asset.storageSlot;\\r\\n                assembly {\\r\\n                    sstore(currentSlot, 0x00)\\r\\n                }\\r\\n            } else {\\r\\n                if (asset.storageState == AssetStorageState.Update) {\\r\\n                    PortfolioAssetStorage storage assetStorage;\\r\\n                    uint256 currentSlot = asset.storageSlot;\\r\\n                    assembly {\\r\\n                        assetStorage.slot := currentSlot\\r\\n                    }\\r\\n\\r\\n                    _storeAsset(asset, assetStorage);\\r\\n                }\\r\\n\\r\\n                // Update portfolio context for every asset that is in storage, whether it is\\r\\n                // updated in storage or not.\\r\\n                (hasDebt, portfolioActiveCurrencies, nextSettleTime) = _updatePortfolioContext(\\r\\n                    asset,\\r\\n                    hasDebt,\\r\\n                    portfolioActiveCurrencies,\\r\\n                    nextSettleTime\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Add new assets\\r\\n        uint256 assetStorageLength = portfolioState.storedAssetLength;\\r\\n        mapping(address => \\r\\n            PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS]) storage store = LibStorage.getPortfolioArrayStorage();\\r\\n        PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS] storage storageArray = store[account];\\r\\n        for (uint256 i = 0; i < portfolioState.newAssets.length; i++) {\\r\\n            PortfolioAsset memory asset = portfolioState.newAssets[i];\\r\\n            if (asset.notional == 0) continue;\\r\\n            require(\\r\\n                asset.storageState != AssetStorageState.Delete &&\\r\\n                asset.storageState != AssetStorageState.RevertIfStored\\r\\n            ); // dev: store assets deleted storage\\r\\n\\r\\n            (hasDebt, portfolioActiveCurrencies, nextSettleTime) = _updatePortfolioContext(\\r\\n                asset,\\r\\n                hasDebt,\\r\\n                portfolioActiveCurrencies,\\r\\n                nextSettleTime\\r\\n            );\\r\\n\\r\\n            _storeAsset(asset, storageArray[assetStorageLength]);\\r\\n            assetStorageLength += 1;\\r\\n        }\\r\\n\\r\\n        // 16 is the maximum number of assets or portfolio active currencies will overflow at 32 bytes with\\r\\n        // 2 bytes per currency\\r\\n        require(assetStorageLength <= 16 && nextSettleTime <= type(uint40).max); // dev: portfolio return value overflow\\r\\n        return (\\r\\n            hasDebt,\\r\\n            portfolioActiveCurrencies,\\r\\n            uint8(assetStorageLength),\\r\\n            uint40(nextSettleTime)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Updates context information during the store assets method\\r\\n    function _updatePortfolioContext(\\r\\n        PortfolioAsset memory asset,\\r\\n        bool hasDebt,\\r\\n        bytes32 portfolioActiveCurrencies,\\r\\n        uint256 nextSettleTime\\r\\n    )\\r\\n        private\\r\\n        pure\\r\\n        returns (\\r\\n            bool,\\r\\n            bytes32,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        uint256 settlementDate = asset.getSettlementDate();\\r\\n        // Tis will set it to the minimum settlement date\\r\\n        if (nextSettleTime == 0 || nextSettleTime > settlementDate) {\\r\\n            nextSettleTime = settlementDate;\\r\\n        }\\r\\n        hasDebt = hasDebt || asset.notional < 0;\\r\\n\\r\\n        require(uint16(uint256(portfolioActiveCurrencies)) == 0); // dev: portfolio active currencies overflow\\r\\n        portfolioActiveCurrencies = (portfolioActiveCurrencies >> 16) | (bytes32(asset.currencyId) << 240);\\r\\n\\r\\n        return (hasDebt, portfolioActiveCurrencies, nextSettleTime);\\r\\n    }\\r\\n\\r\\n    /// @dev Encodes assets for storage\\r\\n    function _storeAsset(\\r\\n        PortfolioAsset memory asset,\\r\\n        PortfolioAssetStorage storage assetStorage\\r\\n    ) internal {\\r\\n        require(0 < asset.currencyId && asset.currencyId <= Constants.MAX_CURRENCIES); // dev: encode asset currency id overflow\\r\\n        require(0 < asset.maturity && asset.maturity <= type(uint40).max); // dev: encode asset maturity overflow\\r\\n        require(0 < asset.assetType && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); // dev: encode asset type invalid\\r\\n        require(type(int88).min <= asset.notional && asset.notional <= type(int88).max); // dev: encode asset notional overflow\\r\\n\\r\\n        assetStorage.currencyId = uint16(asset.currencyId);\\r\\n        assetStorage.maturity = uint40(asset.maturity);\\r\\n        assetStorage.assetType = uint8(asset.assetType);\\r\\n        assetStorage.notional = int88(asset.notional);\\r\\n    }\\r\\n\\r\\n    /// @notice Deletes an asset from a portfolio\\r\\n    /// @dev This method should only be called during settlement, assets can only be removed from a portfolio before settlement\\r\\n    /// by adding the offsetting negative position\\r\\n    function deleteAsset(PortfolioState memory portfolioState, uint256 index) internal pure {\\r\\n        require(index < portfolioState.storedAssets.length); // dev: stored assets bounds\\r\\n        require(portfolioState.storedAssetLength > 0); // dev: stored assets length is zero\\r\\n        PortfolioAsset memory assetToDelete = portfolioState.storedAssets[index];\\r\\n        require(\\r\\n            assetToDelete.storageState != AssetStorageState.Delete &&\\r\\n            assetToDelete.storageState != AssetStorageState.RevertIfStored\\r\\n        ); // dev: cannot delete asset\\r\\n\\r\\n        portfolioState.storedAssetLength -= 1;\\r\\n\\r\\n        uint256 maxActiveSlotIndex;\\r\\n        uint256 maxActiveSlot;\\r\\n        // The max active slot is the last storage slot where an asset exists, it's not clear where this will be in the\\r\\n        // array so we search for it here.\\r\\n        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\\r\\n            PortfolioAsset memory a = portfolioState.storedAssets[i];\\r\\n            if (a.storageSlot > maxActiveSlot && a.storageState != AssetStorageState.Delete) {\\r\\n                maxActiveSlot = a.storageSlot;\\r\\n                maxActiveSlotIndex = i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (index == maxActiveSlotIndex) {\\r\\n            // In this case we are deleting the asset with the max storage slot so no swap is necessary.\\r\\n            assetToDelete.storageState = AssetStorageState.Delete;\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Swap the storage slots of the deleted asset with the last non-deleted asset in the array. Mark them accordingly\\r\\n        // so that when we call store assets they will be updated appropriately\\r\\n        PortfolioAsset memory assetToSwap = portfolioState.storedAssets[maxActiveSlotIndex];\\r\\n        (\\r\\n            assetToSwap.storageSlot,\\r\\n            assetToDelete.storageSlot\\r\\n        ) = (\\r\\n            assetToDelete.storageSlot,\\r\\n            assetToSwap.storageSlot\\r\\n        );\\r\\n        assetToSwap.storageState = AssetStorageState.Update;\\r\\n        assetToDelete.storageState = AssetStorageState.Delete;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns a portfolio array, will be sorted\\r\\n    function getSortedPortfolio(address account, uint8 assetArrayLength)\\r\\n        internal\\r\\n        view\\r\\n        returns (PortfolioAsset[] memory)\\r\\n    {\\r\\n        PortfolioAsset[] memory assets = _loadAssetArray(account, assetArrayLength);\\r\\n        // No sorting required for length of 1\\r\\n        if (assets.length <= 1) return assets;\\r\\n\\r\\n        _sortInPlace(assets);\\r\\n        return assets;\\r\\n    }\\r\\n\\r\\n    /// @notice Builds a portfolio array from storage. The new assets hint parameter will\\r\\n    /// be used to provision a new array for the new assets. This will increase gas efficiency\\r\\n    /// so that we don't have to make copies when we extend the array.\\r\\n    function buildPortfolioState(\\r\\n        address account,\\r\\n        uint8 assetArrayLength,\\r\\n        uint256 newAssetsHint\\r\\n    ) internal view returns (PortfolioState memory) {\\r\\n        PortfolioState memory state;\\r\\n        if (assetArrayLength == 0) return state;\\r\\n\\r\\n        state.storedAssets = getSortedPortfolio(account, assetArrayLength);\\r\\n        state.storedAssetLength = assetArrayLength;\\r\\n        state.newAssets = new PortfolioAsset[](newAssetsHint);\\r\\n\\r\\n        return state;\\r\\n    }\\r\\n\\r\\n    function _sortInPlace(PortfolioAsset[] memory assets) private pure {\\r\\n        uint256 length = assets.length;\\r\\n        uint256[] memory ids = new uint256[](length);\\r\\n        for (uint256 k; k < length; k++) {\\r\\n            PortfolioAsset memory asset = assets[k];\\r\\n            // Prepopulate the ids to calculate just once\\r\\n            ids[k] = TransferAssets.encodeAssetId(asset.currencyId, asset.maturity, asset.assetType);\\r\\n        }\\r\\n\\r\\n        // Uses insertion sort \\r\\n        uint256 i = 1;\\r\\n        while (i < length) {\\r\\n            uint256 j = i;\\r\\n            while (j > 0 && ids[j - 1] > ids[j]) {\\r\\n                // Swap j - 1 and j\\r\\n                (ids[j - 1], ids[j]) = (ids[j], ids[j - 1]);\\r\\n                (assets[j - 1], assets[j]) = (assets[j], assets[j - 1]);\\r\\n                j--;\\r\\n            }\\r\\n            i++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _loadAssetArray(address account, uint8 length)\\r\\n        private\\r\\n        view\\r\\n        returns (PortfolioAsset[] memory)\\r\\n    {\\r\\n        // This will overflow the storage pointer\\r\\n        require(length <= MAX_PORTFOLIO_ASSETS);\\r\\n\\r\\n        mapping(address => \\r\\n            PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS]) storage store = LibStorage.getPortfolioArrayStorage();\\r\\n        PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS] storage storageArray = store[account];\\r\\n        PortfolioAsset[] memory assets = new PortfolioAsset[](length);\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            PortfolioAssetStorage storage assetStorage = storageArray[i];\\r\\n            PortfolioAsset memory asset = assets[i];\\r\\n            uint256 slot;\\r\\n            assembly {\\r\\n                slot := assetStorage.slot\\r\\n            }\\r\\n\\r\\n            asset.currencyId = assetStorage.currencyId;\\r\\n            asset.maturity = assetStorage.maturity;\\r\\n            asset.assetType = assetStorage.assetType;\\r\\n            asset.notional = assetStorage.notional;\\r\\n            asset.storageSlot = slot;\\r\\n        }\\r\\n\\r\\n        return assets;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/portfolio/TransferAssets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./PortfolioHandler.sol\\\";\\r\\nimport \\\"./BitmapAssetsHandler.sol\\\";\\r\\nimport \\\"../AccountContextHandler.sol\\\";\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\n\\r\\n/// @notice Helper library for transferring assets from one portfolio to another\\r\\nlibrary TransferAssets {\\r\\n    using AccountContextHandler for AccountContext;\\r\\n    using PortfolioHandler for PortfolioState;\\r\\n    using SafeInt256 for int256;\\r\\n\\r\\n    /// @notice Decodes asset ids\\r\\n    function decodeAssetId(uint256 id)\\r\\n        internal\\r\\n        pure\\r\\n        returns (\\r\\n            uint256 currencyId,\\r\\n            uint256 maturity,\\r\\n            uint256 assetType\\r\\n        )\\r\\n    {\\r\\n        assetType = uint8(id);\\r\\n        maturity = uint40(id >> 8);\\r\\n        currencyId = uint16(id >> 48);\\r\\n    }\\r\\n\\r\\n    /// @notice Encodes asset ids\\r\\n    function encodeAssetId(\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 assetType\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(currencyId <= Constants.MAX_CURRENCIES);\\r\\n        require(maturity <= type(uint40).max);\\r\\n        require(assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX);\\r\\n\\r\\n        return\\r\\n            uint256(\\r\\n                (bytes32(uint256(uint16(currencyId))) << 48) |\\r\\n                    (bytes32(uint256(uint40(maturity))) << 8) |\\r\\n                    bytes32(uint256(uint8(assetType)))\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @dev Used to flip the sign of assets to decrement the `from` account that is sending assets\\r\\n    function invertNotionalAmountsInPlace(PortfolioAsset[] memory assets) internal pure {\\r\\n        for (uint256 i; i < assets.length; i++) {\\r\\n            assets[i].notional = assets[i].notional.neg();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Useful method for hiding the logic of updating an account. WARNING: the account\\r\\n    /// context returned from this method may not be the same memory location as the account\\r\\n    /// context provided if the account is settled.\\r\\n    function placeAssetsInAccount(\\r\\n        address account,\\r\\n        AccountContext memory accountContext,\\r\\n        PortfolioAsset[] memory assets\\r\\n    ) internal returns (AccountContext memory) {\\r\\n        // If an account has assets that require settlement then placing assets inside it\\r\\n        // may cause issues.\\r\\n        require(!accountContext.mustSettleAssets(), \\\"Account must settle\\\");\\r\\n\\r\\n        if (accountContext.isBitmapEnabled()) {\\r\\n            // Adds fCash assets into the account and finalized storage\\r\\n            BitmapAssetsHandler.addMultipleifCashAssets(account, accountContext, assets);\\r\\n        } else {\\r\\n            PortfolioState memory portfolioState = PortfolioHandler.buildPortfolioState(\\r\\n                account,\\r\\n                accountContext.assetArrayLength,\\r\\n                assets.length\\r\\n            );\\r\\n            // This will add assets in memory\\r\\n            portfolioState.addMultipleAssets(assets);\\r\\n            // This will store assets and update the account context in memory\\r\\n            accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);\\r\\n        }\\r\\n\\r\\n        return accountContext;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/valuation/AssetHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../markets/CashGroup.sol\\\";\\r\\nimport \\\"../markets/AssetRate.sol\\\";\\r\\nimport \\\"../markets/DateTime.sol\\\";\\r\\nimport \\\"../portfolio/PortfolioHandler.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../math/ABDKMath64x64.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary AssetHandler {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeInt256 for int256;\\r\\n    using CashGroup for CashGroupParameters;\\r\\n    using AssetRate for AssetRateParameters;\\r\\n\\r\\n    function isLiquidityToken(uint256 assetType) internal pure returns (bool) {\\r\\n        return\\r\\n            assetType >= Constants.MIN_LIQUIDITY_TOKEN_INDEX &&\\r\\n            assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX;\\r\\n    }\\r\\n\\r\\n    /// @notice Liquidity tokens settle every 90 days (not at the designated maturity). This method\\r\\n    /// calculates the settlement date for any PortfolioAsset.\\r\\n    function getSettlementDate(PortfolioAsset memory asset) internal pure returns (uint256) {\\r\\n        require(asset.assetType > 0 && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); // dev: settlement date invalid asset type\\r\\n        // 3 month tokens and fCash tokens settle at maturity\\r\\n        if (asset.assetType <= Constants.MIN_LIQUIDITY_TOKEN_INDEX) return asset.maturity;\\r\\n\\r\\n        uint256 marketLength = DateTime.getTradedMarket(asset.assetType - 1);\\r\\n        // Liquidity tokens settle at tRef + 90 days. The formula to get a maturity is:\\r\\n        // maturity = tRef + marketLength\\r\\n        // Here we calculate:\\r\\n        // tRef = (maturity - marketLength) + 90 days\\r\\n        return asset.maturity.sub(marketLength).add(Constants.QUARTER);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the continuously compounded discount rate given an oracle rate and a time to maturity.\\r\\n    /// The formula is: e^(-rate * timeToMaturity).\\r\\n    function getDiscountFactor(uint256 timeToMaturity, uint256 oracleRate)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256)\\r\\n    {\\r\\n        int128 expValue =\\r\\n            ABDKMath64x64.fromUInt(oracleRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME));\\r\\n        expValue = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\\r\\n        expValue = ABDKMath64x64.exp(ABDKMath64x64.neg(expValue));\\r\\n        expValue = ABDKMath64x64.mul(expValue, Constants.RATE_PRECISION_64x64);\\r\\n        int256 discountFactor = ABDKMath64x64.toInt(expValue);\\r\\n\\r\\n        return discountFactor;\\r\\n    }\\r\\n\\r\\n    /// @notice Present value of an fCash asset without any risk adjustments.\\r\\n    function getPresentfCashValue(\\r\\n        int256 notional,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime,\\r\\n        uint256 oracleRate\\r\\n    ) internal pure returns (int256) {\\r\\n        if (notional == 0) return 0;\\r\\n\\r\\n        // NOTE: this will revert if maturity < blockTime. That is the correct behavior because we cannot\\r\\n        // discount matured assets.\\r\\n        uint256 timeToMaturity = maturity.sub(blockTime);\\r\\n        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);\\r\\n\\r\\n        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor\\r\\n        return notional.mulInRatePrecision(discountFactor);\\r\\n    }\\r\\n\\r\\n    /// @notice Present value of an fCash asset with risk adjustments. Positive fCash value will be discounted more\\r\\n    /// heavily than the oracle rate given and vice versa for negative fCash.\\r\\n    function getRiskAdjustedPresentfCashValue(\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        int256 notional,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime,\\r\\n        uint256 oracleRate\\r\\n    ) internal pure returns (int256) {\\r\\n        if (notional == 0) return 0;\\r\\n        // NOTE: this will revert if maturity < blockTime. That is the correct behavior because we cannot\\r\\n        // discount matured assets.\\r\\n        uint256 timeToMaturity = maturity.sub(blockTime);\\r\\n\\r\\n        int256 discountFactor;\\r\\n        if (notional > 0) {\\r\\n            // If fCash is positive then discounting by a higher rate will result in a smaller\\r\\n            // discount factor (e ^ -x), meaning a lower positive fCash value.\\r\\n            discountFactor = getDiscountFactor(\\r\\n                timeToMaturity,\\r\\n                oracleRate.add(cashGroup.getfCashHaircut())\\r\\n            );\\r\\n        } else {\\r\\n            uint256 debtBuffer = cashGroup.getDebtBuffer();\\r\\n            // If the adjustment exceeds the oracle rate we floor the value of the fCash\\r\\n            // at the notional value. We don't want to require the account to hold more than\\r\\n            // absolutely required.\\r\\n            if (debtBuffer >= oracleRate) return notional;\\r\\n\\r\\n            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);\\r\\n        }\\r\\n\\r\\n        require(discountFactor <= Constants.RATE_PRECISION); // dev: get risk adjusted pv, invalid discount factor\\r\\n        return notional.mulInRatePrecision(discountFactor);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the non haircut claims on cash and fCash by the liquidity token.\\r\\n    function getCashClaims(PortfolioAsset memory token, MarketParameters memory market)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256 assetCash, int256 fCash)\\r\\n    {\\r\\n        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset, get cash claims\\r\\n\\r\\n        assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);\\r\\n        fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the haircut claims on cash and fCash\\r\\n    function getHaircutCashClaims(\\r\\n        PortfolioAsset memory token,\\r\\n        MarketParameters memory market,\\r\\n        CashGroupParameters memory cashGroup\\r\\n    ) internal pure returns (int256 assetCash, int256 fCash) {\\r\\n        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset get haircut cash claims\\r\\n\\r\\n        require(token.currencyId == cashGroup.currencyId); // dev: haircut cash claims, currency id mismatch\\r\\n        // This won't overflow, the liquidity token haircut is stored as an uint8\\r\\n        int256 haircut = int256(cashGroup.getLiquidityHaircut(token.assetType));\\r\\n\\r\\n        assetCash =\\r\\n            _calcToken(market.totalAssetCash, token.notional, haircut, market.totalLiquidity);\\r\\n\\r\\n        fCash =\\r\\n            _calcToken(market.totalfCash, token.notional, haircut, market.totalLiquidity);\\r\\n\\r\\n        return (assetCash, fCash);\\r\\n    }\\r\\n\\r\\n    /// @dev This is here to clean up the stack in getHaircutCashClaims\\r\\n    function _calcToken(\\r\\n        int256 numerator,\\r\\n        int256 tokens,\\r\\n        int256 haircut,\\r\\n        int256 liquidity\\r\\n    ) private pure returns (int256) {\\r\\n        return numerator.mul(tokens).mul(haircut).div(Constants.PERCENTAGE_DECIMALS).div(liquidity);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the asset cash claim and the present value of the fCash asset (if it exists)\\r\\n    function getLiquidityTokenValue(\\r\\n        uint256 index,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        MarketParameters memory market,\\r\\n        PortfolioAsset[] memory assets,\\r\\n        uint256 blockTime,\\r\\n        bool riskAdjusted\\r\\n    ) internal view returns (int256, int256) {\\r\\n        PortfolioAsset memory liquidityToken = assets[index];\\r\\n\\r\\n        {\\r\\n            (uint256 marketIndex, bool idiosyncratic) =\\r\\n                DateTime.getMarketIndex(\\r\\n                    cashGroup.maxMarketIndex,\\r\\n                    liquidityToken.maturity,\\r\\n                    blockTime\\r\\n                );\\r\\n            // Liquidity tokens can never be idiosyncratic\\r\\n            require(!idiosyncratic); // dev: idiosyncratic liquidity token\\r\\n\\r\\n            // This market will always be initialized, if a liquidity token exists that means the\\r\\n            // market has some liquidity in it.\\r\\n            cashGroup.loadMarket(market, marketIndex, true, blockTime);\\r\\n        }\\r\\n\\r\\n        int256 assetCashClaim;\\r\\n        int256 fCashClaim;\\r\\n        if (riskAdjusted) {\\r\\n            (assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);\\r\\n        } else {\\r\\n            (assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);\\r\\n        }\\r\\n\\r\\n        // Find the matching fCash asset and net off the value, assumes that the portfolio is sorted and\\r\\n        // in that case we know the previous asset will be the matching fCash asset\\r\\n        if (index > 0) {\\r\\n            PortfolioAsset memory maybefCash = assets[index - 1];\\r\\n            if (\\r\\n                maybefCash.assetType == Constants.FCASH_ASSET_TYPE &&\\r\\n                maybefCash.currencyId == liquidityToken.currencyId &&\\r\\n                maybefCash.maturity == liquidityToken.maturity\\r\\n            ) {\\r\\n                // Net off the fCashClaim here and we will discount it to present value in the second pass.\\r\\n                // WARNING: this modifies the portfolio in memory and therefore we cannot store this portfolio!\\r\\n                maybefCash.notional = maybefCash.notional.add(fCashClaim);\\r\\n                // This state will prevent the fCash asset from being stored.\\r\\n                maybefCash.storageState = AssetStorageState.RevertIfStored;\\r\\n                return (assetCashClaim, 0);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // If not matching fCash asset found then get the pv directly\\r\\n        if (riskAdjusted) {\\r\\n            int256 pv =\\r\\n                getRiskAdjustedPresentfCashValue(\\r\\n                    cashGroup,\\r\\n                    fCashClaim,\\r\\n                    liquidityToken.maturity,\\r\\n                    blockTime,\\r\\n                    market.oracleRate\\r\\n                );\\r\\n\\r\\n            return (assetCashClaim, pv);\\r\\n        } else {\\r\\n            int256 pv =\\r\\n                getPresentfCashValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);\\r\\n\\r\\n            return (assetCashClaim, pv);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns present value of all assets in the cash group as asset cash and the updated\\r\\n    /// portfolio index where the function has ended.\\r\\n    /// @return the value of the cash group in asset cash\\r\\n    function getNetCashGroupValue(\\r\\n        PortfolioAsset[] memory assets,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        MarketParameters memory market,\\r\\n        uint256 blockTime,\\r\\n        uint256 portfolioIndex\\r\\n    ) internal view returns (int256, uint256) {\\r\\n        int256 presentValueAsset;\\r\\n        int256 presentValueUnderlying;\\r\\n\\r\\n        // First calculate value of liquidity tokens because we need to net off fCash value\\r\\n        // before discounting to present value\\r\\n        for (uint256 i = portfolioIndex; i < assets.length; i++) {\\r\\n            if (!isLiquidityToken(assets[i].assetType)) continue;\\r\\n            if (assets[i].currencyId != cashGroup.currencyId) break;\\r\\n\\r\\n            (int256 assetCashClaim, int256 pv) =\\r\\n                getLiquidityTokenValue(\\r\\n                    i,\\r\\n                    cashGroup,\\r\\n                    market,\\r\\n                    assets,\\r\\n                    blockTime,\\r\\n                    true // risk adjusted\\r\\n                );\\r\\n\\r\\n            presentValueAsset = presentValueAsset.add(assetCashClaim);\\r\\n            presentValueUnderlying = presentValueUnderlying.add(pv);\\r\\n        }\\r\\n\\r\\n        uint256 j = portfolioIndex;\\r\\n        for (; j < assets.length; j++) {\\r\\n            PortfolioAsset memory a = assets[j];\\r\\n            if (a.assetType != Constants.FCASH_ASSET_TYPE) continue;\\r\\n            // If we hit a different currency id then we've accounted for all assets in this currency\\r\\n            // j will mark the index where we don't have this currency anymore\\r\\n            if (a.currencyId != cashGroup.currencyId) break;\\r\\n\\r\\n            uint256 oracleRate = cashGroup.calculateOracleRate(a.maturity, blockTime);\\r\\n\\r\\n            int256 pv =\\r\\n                getRiskAdjustedPresentfCashValue(\\r\\n                    cashGroup,\\r\\n                    a.notional,\\r\\n                    a.maturity,\\r\\n                    blockTime,\\r\\n                    oracleRate\\r\\n                );\\r\\n            presentValueUnderlying = presentValueUnderlying.add(pv);\\r\\n        }\\r\\n\\r\\n        presentValueAsset = presentValueAsset.add(\\r\\n            cashGroup.assetRate.convertFromUnderlying(presentValueUnderlying)\\r\\n        );\\r\\n\\r\\n        return (presentValueAsset, j);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/portfolio/BitmapAssetsHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../AccountContextHandler.sol\\\";\\r\\nimport \\\"../markets/CashGroup.sol\\\";\\r\\nimport \\\"../valuation/AssetHandler.sol\\\";\\r\\nimport \\\"../../math/Bitmap.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../global/LibStorage.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary BitmapAssetsHandler {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeInt256 for int256;\\r\\n    using Bitmap for bytes32;\\r\\n    using CashGroup for CashGroupParameters;\\r\\n    using AccountContextHandler for AccountContext;\\r\\n\\r\\n    function getAssetsBitmap(address account, uint256 currencyId) internal view returns (bytes32 assetsBitmap) {\\r\\n        mapping(address => mapping(uint256 => bytes32)) storage store = LibStorage.getAssetsBitmapStorage();\\r\\n        return store[account][currencyId];\\r\\n    }\\r\\n\\r\\n    function setAssetsBitmap(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        bytes32 assetsBitmap\\r\\n    ) internal {\\r\\n        require(assetsBitmap.totalBitsSet() <= Constants.MAX_BITMAP_ASSETS, \\\"Over max assets\\\");\\r\\n        mapping(address => mapping(uint256 => bytes32)) storage store = LibStorage.getAssetsBitmapStorage();\\r\\n        store[account][currencyId] = assetsBitmap;\\r\\n    }\\r\\n\\r\\n    function getifCashNotional(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity\\r\\n    ) internal view returns (int256 notional) {\\r\\n        mapping(address => mapping(uint256 =>\\r\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\r\\n        return store[account][currencyId][maturity].notional;\\r\\n    }\\r\\n\\r\\n    /// @notice Adds multiple assets to a bitmap portfolio\\r\\n    function addMultipleifCashAssets(\\r\\n        address account,\\r\\n        AccountContext memory accountContext,\\r\\n        PortfolioAsset[] memory assets\\r\\n    ) internal {\\r\\n        require(accountContext.isBitmapEnabled()); // dev: bitmap currency not set\\r\\n        uint256 currencyId = accountContext.bitmapCurrencyId;\\r\\n\\r\\n        for (uint256 i; i < assets.length; i++) {\\r\\n            PortfolioAsset memory asset = assets[i];\\r\\n            if (asset.notional == 0) continue;\\r\\n\\r\\n            require(asset.currencyId == currencyId); // dev: invalid asset in set ifcash assets\\r\\n            require(asset.assetType == Constants.FCASH_ASSET_TYPE); // dev: invalid asset in set ifcash assets\\r\\n            int256 finalNotional;\\r\\n\\r\\n            finalNotional = addifCashAsset(\\r\\n                account,\\r\\n                currencyId,\\r\\n                asset.maturity,\\r\\n                accountContext.nextSettleTime,\\r\\n                asset.notional\\r\\n            );\\r\\n\\r\\n            if (finalNotional < 0)\\r\\n                accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Add an ifCash asset in the bitmap and mapping. Updates the bitmap in memory\\r\\n    /// but not in storage.\\r\\n    /// @return the updated assets bitmap and the final notional amount\\r\\n    function addifCashAsset(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 nextSettleTime,\\r\\n        int256 notional\\r\\n    ) internal returns (int256) {\\r\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\r\\n        mapping(address => mapping(uint256 =>\\r\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\r\\n        ifCashStorage storage fCashSlot = store[account][currencyId][maturity];\\r\\n        (uint256 bitNum, bool isExact) = DateTime.getBitNumFromMaturity(nextSettleTime, maturity);\\r\\n        require(isExact); // dev: invalid maturity in set ifcash asset\\r\\n\\r\\n        if (assetsBitmap.isBitSet(bitNum)) {\\r\\n            // Bit is set so we read and update the notional amount\\r\\n            int256 finalNotional = notional.add(fCashSlot.notional);\\r\\n            require(type(int128).min <= finalNotional && finalNotional <= type(int128).max); // dev: bitmap notional overflow\\r\\n            fCashSlot.notional = int128(finalNotional);\\r\\n\\r\\n            // If the new notional is zero then turn off the bit\\r\\n            if (finalNotional == 0) {\\r\\n                assetsBitmap = assetsBitmap.setBit(bitNum, false);\\r\\n            }\\r\\n\\r\\n            setAssetsBitmap(account, currencyId, assetsBitmap);\\r\\n            return finalNotional;\\r\\n        }\\r\\n\\r\\n        if (notional != 0) {\\r\\n            // Bit is not set so we turn it on and update the mapping directly, no read required.\\r\\n            require(type(int128).min <= notional && notional <= type(int128).max); // dev: bitmap notional overflow\\r\\n            fCashSlot.notional = int128(notional);\\r\\n\\r\\n            assetsBitmap = assetsBitmap.setBit(bitNum, true);\\r\\n            setAssetsBitmap(account, currencyId, assetsBitmap);\\r\\n        }\\r\\n\\r\\n        return notional;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the present value of an asset\\r\\n    function getPresentValue(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        bool riskAdjusted\\r\\n    ) internal view returns (int256) {\\r\\n        int256 notional = getifCashNotional(account, currencyId, maturity);\\r\\n\\r\\n        // In this case the asset has matured and the total value is just the notional amount\\r\\n        if (maturity <= blockTime) {\\r\\n            return notional;\\r\\n        } else {\\r\\n            uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);\\r\\n            if (riskAdjusted) {\\r\\n                return AssetHandler.getRiskAdjustedPresentfCashValue(\\r\\n                    cashGroup,\\r\\n                    notional,\\r\\n                    maturity,\\r\\n                    blockTime,\\r\\n                    oracleRate\\r\\n                );\\r\\n            } else {\\r\\n                return AssetHandler.getPresentfCashValue(\\r\\n                    notional,\\r\\n                    maturity,\\r\\n                    blockTime,\\r\\n                    oracleRate\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getNetPresentValueFromBitmap(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        uint256 nextSettleTime,\\r\\n        uint256 blockTime,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        bool riskAdjusted,\\r\\n        bytes32 assetsBitmap\\r\\n    ) internal view returns (int256 totalValueUnderlying, bool hasDebt) {\\r\\n        uint256 bitNum = assetsBitmap.getNextBitNum();\\r\\n\\r\\n        while (bitNum != 0) {\\r\\n            uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);\\r\\n            int256 pv = getPresentValue(\\r\\n                account,\\r\\n                currencyId,\\r\\n                maturity,\\r\\n                blockTime,\\r\\n                cashGroup,\\r\\n                riskAdjusted\\r\\n            );\\r\\n            totalValueUnderlying = totalValueUnderlying.add(pv);\\r\\n\\r\\n            if (pv < 0) hasDebt = true;\\r\\n\\r\\n            // Turn off the bit and look for the next one\\r\\n            assetsBitmap = assetsBitmap.setBit(bitNum, false);\\r\\n            bitNum = assetsBitmap.getNextBitNum();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Get the net present value of all the ifCash assets\\r\\n    function getifCashNetPresentValue(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        uint256 nextSettleTime,\\r\\n        uint256 blockTime,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        bool riskAdjusted\\r\\n    ) internal view returns (int256 totalValueUnderlying, bool hasDebt) {\\r\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\r\\n        return getNetPresentValueFromBitmap(\\r\\n            account,\\r\\n            currencyId,\\r\\n            nextSettleTime,\\r\\n            blockTime,\\r\\n            cashGroup,\\r\\n            riskAdjusted,\\r\\n            assetsBitmap\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the ifCash assets as an array\\r\\n    function getifCashArray(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        uint256 nextSettleTime\\r\\n    ) internal view returns (PortfolioAsset[] memory) {\\r\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\r\\n        uint256 index = assetsBitmap.totalBitsSet();\\r\\n        PortfolioAsset[] memory assets = new PortfolioAsset[](index);\\r\\n        index = 0;\\r\\n\\r\\n        uint256 bitNum = assetsBitmap.getNextBitNum();\\r\\n        while (bitNum != 0) {\\r\\n            uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);\\r\\n            int256 notional = getifCashNotional(account, currencyId, maturity);\\r\\n\\r\\n            PortfolioAsset memory asset = assets[index];\\r\\n            asset.currencyId = currencyId;\\r\\n            asset.maturity = maturity;\\r\\n            asset.assetType = Constants.FCASH_ASSET_TYPE;\\r\\n            asset.notional = notional;\\r\\n            index += 1;\\r\\n\\r\\n            // Turn off the bit and look for the next one\\r\\n            assetsBitmap = assetsBitmap.setBit(bitNum, false);\\r\\n            bitNum = assetsBitmap.getNextBitNum();\\r\\n        }\\r\\n\\r\\n        return assets;\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/math/Bitmap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../global/Types.sol\\\";\\r\\nimport \\\"../global/Constants.sol\\\";\\r\\n\\r\\n/// @notice Helper methods for bitmaps, they are big-endian and 1-indexed.\\r\\nlibrary Bitmap {\\r\\n\\r\\n    /// @notice Set a bit on or off in a bitmap, index is 1-indexed\\r\\n    function setBit(\\r\\n        bytes32 bitmap,\\r\\n        uint256 index,\\r\\n        bool setOn\\r\\n    ) internal pure returns (bytes32) {\\r\\n        require(index >= 1 && index <= 256); // dev: set bit index bounds\\r\\n\\r\\n        if (setOn) {\\r\\n            return bitmap | (Constants.MSB >> (index - 1));\\r\\n        } else {\\r\\n            return bitmap & ~(Constants.MSB >> (index - 1));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Check if a bit is set\\r\\n    function isBitSet(bytes32 bitmap, uint256 index) internal pure returns (bool) {\\r\\n        require(index >= 1 && index <= 256); // dev: set bit index bounds\\r\\n        return ((bitmap << (index - 1)) & Constants.MSB) == Constants.MSB;\\r\\n    }\\r\\n\\r\\n    /// @notice Count the total bits set\\r\\n    function totalBitsSet(bytes32 bitmap) internal pure returns (uint256) {\\r\\n        uint256 x = uint256(bitmap);\\r\\n        x = (x & 0x5555555555555555555555555555555555555555555555555555555555555555) + (x >> 1 & 0x5555555555555555555555555555555555555555555555555555555555555555);\\r\\n        x = (x & 0x3333333333333333333333333333333333333333333333333333333333333333) + (x >> 2 & 0x3333333333333333333333333333333333333333333333333333333333333333);\\r\\n        x = (x & 0x0707070707070707070707070707070707070707070707070707070707070707) + (x >> 4);\\r\\n        x = (x & 0x000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F) + (x >> 8 & 0x000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F);\\r\\n        x = x + (x >> 16);\\r\\n        x = x + (x >> 32);\\r\\n        x = x  + (x >> 64);\\r\\n        return (x & 0xFF) + (x >> 128 & 0xFF);\\r\\n    }\\r\\n\\r\\n    // Does a binary search over x to get the position of the most significant bit\\r\\n    function getMSB(uint256 x) internal pure returns (uint256 msb) {\\r\\n        // If x == 0 then there is no MSB and this method will return zero. That would\\r\\n        // be the same as the return value when x == 1 (MSB is zero indexed), so instead\\r\\n        // we have this require here to ensure that the values don't get mixed up.\\r\\n        require(x != 0); // dev: get msb zero value\\r\\n        if (x >= 0x100000000000000000000000000000000) {\\r\\n            x >>= 128;\\r\\n            msb += 128;\\r\\n        }\\r\\n        if (x >= 0x10000000000000000) {\\r\\n            x >>= 64;\\r\\n            msb += 64;\\r\\n        }\\r\\n        if (x >= 0x100000000) {\\r\\n            x >>= 32;\\r\\n            msb += 32;\\r\\n        }\\r\\n        if (x >= 0x10000) {\\r\\n            x >>= 16;\\r\\n            msb += 16;\\r\\n        }\\r\\n        if (x >= 0x100) {\\r\\n            x >>= 8;\\r\\n            msb += 8;\\r\\n        }\\r\\n        if (x >= 0x10) {\\r\\n            x >>= 4;\\r\\n            msb += 4;\\r\\n        }\\r\\n        if (x >= 0x4) {\\r\\n            x >>= 2;\\r\\n            msb += 2;\\r\\n        }\\r\\n        if (x >= 0x2) msb += 1; // No need to shift xc anymore\\r\\n    }\\r\\n\\r\\n    /// @dev getMSB returns a zero indexed bit number where zero is the first bit counting\\r\\n    /// from the right (little endian). Asset Bitmaps are counted from the left (big endian)\\r\\n    /// and one indexed.\\r\\n    function getNextBitNum(bytes32 bitmap) internal pure returns (uint256 bitNum) {\\r\\n        // Short circuit the search if bitmap is all zeros\\r\\n        if (bitmap == 0x00) return 0;\\r\\n\\r\\n        return 255 - getMSB(uint256(bitmap)) + 1;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/global/StorageLayoutV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./Types.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice Storage layout for the system. Do not change this file once deployed, future storage\\r\\n * layouts must inherit this and increment the version number.\\r\\n */\\r\\ncontract StorageLayoutV1 {\\r\\n    // The current maximum currency id\\r\\n    uint16 internal maxCurrencyId;\\r\\n    // Sets the state of liquidations being enabled during a paused state. Each of the four lower\\r\\n    // bits can be turned on to represent one of the liquidation types being enabled.\\r\\n    bytes1 internal liquidationEnabledState;\\r\\n    // Set to true once the system has been initialized\\r\\n    bool internal hasInitialized;\\r\\n\\r\\n    /* Authentication Mappings */\\r\\n    // This is set to the timelock contract to execute governance functions\\r\\n    address public owner;\\r\\n    // This is set to an address of a router that can only call governance actions\\r\\n    address public pauseRouter;\\r\\n    // This is set to an address of a router that can only call governance actions\\r\\n    address public pauseGuardian;\\r\\n    // On upgrades this is set in the case that the pause router is used to pass the rollback check\\r\\n    address internal rollbackRouterImplementation;\\r\\n\\r\\n    // A blanket allowance for a spender to transfer any of an account's nTokens. This would allow a user\\r\\n    // to set an allowance on all nTokens for a particular integrating contract system.\\r\\n    // owner => spender => transferAllowance\\r\\n    mapping(address => mapping(address => uint256)) internal nTokenWhitelist;\\r\\n    // Individual transfer allowances for nTokens used for ERC20\\r\\n    // owner => spender => currencyId => transferAllowance\\r\\n    mapping(address => mapping(address => mapping(uint16 => uint256))) internal nTokenAllowance;\\r\\n\\r\\n    // Transfer operators\\r\\n    // Mapping from a global ERC1155 transfer operator contract to an approval value for it\\r\\n    mapping(address => bool) internal globalTransferOperator;\\r\\n    // Mapping from an account => operator => approval status for that operator. This is a specific\\r\\n    // approval between two addresses for ERC1155 transfers.\\r\\n    mapping(address => mapping(address => bool)) internal accountAuthorizedTransferOperator;\\r\\n    // Approval for a specific contract to use the `batchBalanceAndTradeActionWithCallback` method in\\r\\n    // BatchAction.sol, can only be set by governance\\r\\n    mapping(address => bool) internal authorizedCallbackContract;\\r\\n\\r\\n    // Reverse mapping from token addresses to currency ids, only used for referencing in views\\r\\n    // and checking for duplicate token listings.\\r\\n    mapping(address => uint16) internal tokenAddressToCurrencyId;\\r\\n\\r\\n    // Reentrancy guard\\r\\n    uint256 internal reentrancyStatus;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.3.2 (proxy/ERC1967/ERC1967Upgrade.sol)\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"../beacon/IBeacon.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\r\\nimport \\\"../utils/StorageSlot.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev This abstract contract provides getters and event emitting update functions for\\r\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n *\\r\\n */\\r\\nabstract contract ERC1967Upgrade {\\r\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\r\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\r\\n\\r\\n    /**\\r\\n     * @dev Storage slot with the address of the current implementation.\\r\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\r\\n     * validated in the constructor.\\r\\n     */\\r\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the implementation is upgraded.\\r\\n     */\\r\\n    event Upgraded(address indexed implementation);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current implementation address.\\r\\n     */\\r\\n    function _getImplementation() internal view returns (address) {\\r\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\r\\n     */\\r\\n    function _setImplementation(address newImplementation) private {\\r\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\r\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Perform implementation upgrade\\r\\n     *\\r\\n     * Emits an {Upgraded} event.\\r\\n     */\\r\\n    function _upgradeTo(address newImplementation) internal {\\r\\n        _setImplementation(newImplementation);\\r\\n        emit Upgraded(newImplementation);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Perform implementation upgrade with additional setup call.\\r\\n     *\\r\\n     * Emits an {Upgraded} event.\\r\\n     */\\r\\n    function _upgradeToAndCall(\\r\\n        address newImplementation,\\r\\n        bytes memory data,\\r\\n        bool forceCall\\r\\n    ) internal {\\r\\n        _upgradeTo(newImplementation);\\r\\n        if (data.length > 0 || forceCall) {\\r\\n            Address.functionDelegateCall(newImplementation, data);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\r\\n     *\\r\\n     * Emits an {Upgraded} event.\\r\\n     */\\r\\n    function _upgradeToAndCallSecure(\\r\\n        address newImplementation,\\r\\n        bytes memory data,\\r\\n        bool forceCall\\r\\n    ) internal {\\r\\n        address oldImplementation = _getImplementation();\\r\\n\\r\\n        // Initial upgrade and setup call\\r\\n        _setImplementation(newImplementation);\\r\\n        if (data.length > 0 || forceCall) {\\r\\n            Address.functionDelegateCall(newImplementation, data);\\r\\n        }\\r\\n\\r\\n        // Perform rollback test if not already in progress\\r\\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\\r\\n        if (!rollbackTesting.value) {\\r\\n            // Trigger rollback using upgradeTo from the new implementation\\r\\n            rollbackTesting.value = true;\\r\\n            Address.functionDelegateCall(\\r\\n                newImplementation,\\r\\n                abi.encodeWithSignature(\\\"upgradeTo(address)\\\", oldImplementation)\\r\\n            );\\r\\n            rollbackTesting.value = false;\\r\\n            // Check rollback was effective\\r\\n            require(oldImplementation == _getImplementation(), \\\"ERC1967Upgrade: upgrade breaks further upgrades\\\");\\r\\n            // Finally reset to the new implementation and log the upgrade\\r\\n            _upgradeTo(newImplementation);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Storage slot with the admin of the contract.\\r\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\r\\n     * validated in the constructor.\\r\\n     */\\r\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the admin account has changed.\\r\\n     */\\r\\n    event AdminChanged(address previousAdmin, address newAdmin);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current admin.\\r\\n     */\\r\\n    function _getAdmin() internal view returns (address) {\\r\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Stores a new address in the EIP1967 admin slot.\\r\\n     */\\r\\n    function _setAdmin(address newAdmin) private {\\r\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\r\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Changes the admin of the proxy.\\r\\n     *\\r\\n     * Emits an {AdminChanged} event.\\r\\n     */\\r\\n    function _changeAdmin(address newAdmin) internal {\\r\\n        emit AdminChanged(_getAdmin(), newAdmin);\\r\\n        _setAdmin(newAdmin);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\r\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\r\\n     */\\r\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the beacon is upgraded.\\r\\n     */\\r\\n    event BeaconUpgraded(address indexed beacon);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current beacon.\\r\\n     */\\r\\n    function _getBeacon() internal view returns (address) {\\r\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\r\\n     */\\r\\n    function _setBeacon(address newBeacon) private {\\r\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\r\\n        require(\\r\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\r\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\r\\n        );\\r\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\r\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\r\\n     *\\r\\n     * Emits a {BeaconUpgraded} event.\\r\\n     */\\r\\n    function _upgradeBeaconToAndCall(\\r\\n        address newBeacon,\\r\\n        bytes memory data,\\r\\n        bool forceCall\\r\\n    ) internal {\\r\\n        _setBeacon(newBeacon);\\r\\n        emit BeaconUpgraded(newBeacon);\\r\\n        if (data.length > 0 || forceCall) {\\r\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.3.2 (proxy/beacon/IBeacon.sol)\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\r\\n */\\r\\ninterface IBeacon {\\r\\n    /**\\r\\n     * @dev Must return an address that can be used as a delegate call target.\\r\\n     *\\r\\n     * {BeaconProxy} will check that this address is a contract.\\r\\n     */\\r\\n    function implementation() external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/proxy/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev Library for reading and writing primitive types to specific storage slots.\\r\\n *\\r\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\r\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\r\\n *\\r\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\r\\n *\\r\\n * Example usage to set ERC1967 implementation slot:\\r\\n * ```\\r\\n * contract ERC1967 {\\r\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n *\\r\\n *     function _getImplementation() internal view returns (address) {\\r\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\r\\n *     }\\r\\n *\\r\\n *     function _setImplementation(address newImplementation) internal {\\r\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\r\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\r\\n *     }\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\r\\n */\\r\\nlibrary StorageSlot {\\r\\n    struct AddressSlot {\\r\\n        address value;\\r\\n    }\\r\\n\\r\\n    struct BooleanSlot {\\r\\n        bool value;\\r\\n    }\\r\\n\\r\\n    struct Bytes32Slot {\\r\\n        bytes32 value;\\r\\n    }\\r\\n\\r\\n    struct Uint256Slot {\\r\\n        uint256 value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nTokenAddress\",\"type\":\"address\"}],\"name\":\"DeployNToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newCurrencyId\",\"type\":\"uint16\"}],\"name\":\"ListCurrency\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pauseRouter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pauseGuardian\",\"type\":\"address\"}],\"name\":\"PauseRouterAndGuardianUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"}],\"name\":\"UpdateAssetRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"UpdateAuthorizedCallbackContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"}],\"name\":\"UpdateCashGroup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"}],\"name\":\"UpdateDepositParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"}],\"name\":\"UpdateETHRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"UpdateGlobalTransferOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newEmissionRate\",\"type\":\"uint32\"}],\"name\":\"UpdateIncentiveEmissionRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"}],\"name\":\"UpdateInitializationParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"UpdateLendingPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint72\",\"name\":\"maxCollateralBalance\",\"type\":\"uint72\"}],\"name\":\"UpdateMaxCollateralBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewarder\",\"type\":\"address\"}],\"name\":\"UpdateSecondaryIncentiveRewarder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"}],\"name\":\"UpdateTokenCollateralParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"contract AssetRateAdapter\",\"name\":\"assetRateOracle\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"maxMarketIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rateOracleTimeWindow5Min\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalFeeBPS\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"reserveFeeShare\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"debtBuffer5BPS\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fCashHaircut5BPS\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"settlementPenaltyRate5BPS\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidationfCashHaircut5BPS\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidationDebtBuffer5BPS\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"liquidityTokenHaircuts\",\"type\":\"uint8[]\"},{\"internalType\":\"uint8[]\",\"name\":\"rateScalars\",\"type\":\"uint8[]\"}],\"internalType\":\"struct CashGroupSettings\",\"name\":\"cashGroup\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"underlyingName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol\",\"type\":\"string\"}],\"name\":\"enableCashGroup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasTransferFee\",\"type\":\"bool\"},{\"internalType\":\"enum TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"decimalPlaces\",\"type\":\"uint8\"},{\"internalType\":\"uint72\",\"name\":\"maxCollateralBalance\",\"type\":\"uint72\"}],\"internalType\":\"struct TokenStorage\",\"name\":\"assetToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasTransferFee\",\"type\":\"bool\"},{\"internalType\":\"enum TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"decimalPlaces\",\"type\":\"uint8\"},{\"internalType\":\"uint72\",\"name\":\"maxCollateralBalance\",\"type\":\"uint72\"}],\"internalType\":\"struct TokenStorage\",\"name\":\"underlyingToken\",\"type\":\"tuple\"},{\"internalType\":\"contract AggregatorV2V3Interface\",\"name\":\"rateOracle\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"mustInvert\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"buffer\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"haircut\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidationDiscount\",\"type\":\"uint8\"}],\"name\":\"listCurrency\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseGuardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILendingPool\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"setLendingPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pauseRouter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pauseGuardian_\",\"type\":\"address\"}],\"name\":\"setPauseRouterAndGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"contract IRewarder\",\"name\":\"rewarder\",\"type\":\"address\"}],\"name\":\"setSecondaryIncentiveRewarder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"contract AssetRateAdapter\",\"name\":\"rateOracle\",\"type\":\"address\"}],\"name\":\"updateAssetRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"updateAuthorizedCallbackContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"maxMarketIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rateOracleTimeWindow5Min\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalFeeBPS\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"reserveFeeShare\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"debtBuffer5BPS\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fCashHaircut5BPS\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"settlementPenaltyRate5BPS\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidationfCashHaircut5BPS\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidationDebtBuffer5BPS\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"liquidityTokenHaircuts\",\"type\":\"uint8[]\"},{\"internalType\":\"uint8[]\",\"name\":\"rateScalars\",\"type\":\"uint8[]\"}],\"internalType\":\"struct CashGroupSettings\",\"name\":\"cashGroup\",\"type\":\"tuple\"}],\"name\":\"updateCashGroup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"uint32[]\",\"name\":\"depositShares\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32[]\",\"name\":\"leverageThresholds\",\"type\":\"uint32[]\"}],\"name\":\"updateDepositParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"contract AggregatorV2V3Interface\",\"name\":\"rateOracle\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"mustInvert\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"buffer\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"haircut\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidationDiscount\",\"type\":\"uint8\"}],\"name\":\"updateETHRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"updateGlobalTransferOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"newEmissionRate\",\"type\":\"uint32\"}],\"name\":\"updateIncentiveEmissionRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"uint32[]\",\"name\":\"annualizedAnchorRates\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"}],\"name\":\"updateInitializationParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"uint72\",\"name\":\"maxCollateralBalanceInternalPrecision\",\"type\":\"uint72\"}],\"name\":\"updateMaxCollateralBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"residualPurchaseIncentive10BPS\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"pvHaircutPercentage\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"residualPurchaseTimeBufferHours\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"cashWithholdingBuffer10BPS\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidationHaircutPercentage\",\"type\":\"uint8\"}],\"name\":\"updateTokenCollateralParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "GovernanceAction", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}