{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\",\r\n          \"stackAllocation\": true\r\n        }\r\n      },\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DenOfAlgol.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"./interfaces/IShatteredEON.sol\\\";\\nimport \\\"./interfaces/IImperialGuild.sol\\\";\\nimport \\\"./interfaces/IRAW.sol\\\";\\nimport \\\"./interfaces/IColonist.sol\\\";\\nimport \\\"./interfaces/IPirates.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\ncontract DenOfAlgol is Pausable {\\n    uint8 public onosiaLiquorId;\\n    // shard Ids\\n    uint256 public spearId;\\n    uint256 public templeId;\\n    uint256 public riotId;\\n    uint256 public phantomId;\\n\\n    // activate shard minting \\n    bool public shardsActive;\\n    // address => used in allowing system communication between contracts\\n    mapping(address => bool) private admins;\\n    //owner\\n    address public auth;\\n    // reference to raw resource contract\\n    address public EON;\\n\\n    uint256 public spearPriceEon;\\n    uint256 public templePriceEon;\\n    uint256 public riotPriceEon;\\n    uint256 public phantomPriceEon;\\n    uint256 public onosiaPriceEon;\\n\\n    \\n    IRAW public RAW;\\n    // reference to refined EON for minting and burning\\n    IPirates public pirateNFT;\\n    // reference to the colonist NFT collection\\n    IColonist public colonistNFT;\\n    // reference to the ImperialGuild collection\\n    IImperialGuild public imperialGuild;\\n    //reference to main game logic\\n    IShatteredEON public shattered;\\n\\n    constructor() {\\n        _pause();\\n        auth = msg.sender;\\n        admins[msg.sender] = true;\\n    }\\n\\n    modifier noCheaters() {\\n        uint256 size = 0;\\n        address acc = msg.sender;\\n        assembly {\\n            size := extcodesize(acc)\\n        }\\n\\n        require(\\n            admins[msg.sender] || (msg.sender == tx.origin && size == 0),\\n            \\\"you're trying to cheat!\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == auth);\\n        _;\\n    }\\n\\n    /** CRITICAL TO SETUP */\\n    modifier requireContractsSet() {\\n        require(\\n            address(RAW) != address(0) &&\\n                address(EON) != address(0) &&\\n                address(pirateNFT) != address(0) &&\\n                address(colonistNFT) != address(0) &&\\n                address(imperialGuild) != address(0) &&\\n                address(shattered) != address(0),\\n            \\\"Contracts not set\\\"\\n        );\\n        _;\\n    }\\n\\n    function setContracts(\\n        address _RAW,\\n        address _EON,\\n        address _pirateNFT,\\n        address _colonistNFT,\\n        address _imperialGuild,\\n        address _shatteredEON\\n    ) external onlyOwner {\\n        RAW = IRAW(_RAW);\\n        EON = _EON;\\n        pirateNFT = IPirates(_pirateNFT);\\n        colonistNFT = IColonist(_colonistNFT);\\n        imperialGuild = IImperialGuild(_imperialGuild);\\n        shattered = IShatteredEON(_shatteredEON);\\n    }\\n\\n    // $rEON or EON exchange amount handled within ImperialGuild contract\\n    // Will fail if sender doesn't have enough $rEON or $EON or does not\\n    // provide the required sacrafices,\\n    // Transfer does not need approved,\\n    // as there is established trust between this contract and the ImperialGuild contract\\n\\n    function buySpear(bool RAWPayment) external whenNotPaused noCheaters {\\n        require(shardsActive = true, \\\"Shard minting not available yet\\\");\\n        require(tx.origin == msg.sender, \\\"Only EOA\\\");\\n        if (RAWPayment) {\\n            imperialGuild.mint(spearId, 1, 1, msg.sender);\\n        } else {\\n            require(ERC20(EON).balanceOf(msg.sender) >= spearPriceEon, \\\"Not enough EON\\\");\\n            imperialGuild.mint(spearId, 0, 1, msg.sender);\\n        }\\n    }\\n\\n    function buyTemple(bool RAWPayment) external whenNotPaused noCheaters {\\n        require(shardsActive = true, \\\"Shard minting not available yet\\\");\\n        require(tx.origin == msg.sender, \\\"Only EOA\\\");\\n        if (RAWPayment) {\\n            imperialGuild.mint(templeId, 1, 1, msg.sender);\\n        } else {\\n            require(ERC20(EON).balanceOf(msg.sender) >= templePriceEon, \\\"Not enough EON\\\");\\n            imperialGuild.mint(templeId, 0, 1, msg.sender);\\n        }\\n    }\\n\\n    function makeOnosiaLiquor(uint16 qty, bool RAWPayment)\\n        external\\n        whenNotPaused\\n        noCheaters\\n    {\\n        require(tx.origin == msg.sender);\\n        require(onosiaLiquorId > 0, \\\"wrong tokenId\\\");\\n        if (RAWPayment) {\\n            imperialGuild.mint(onosiaLiquorId, 1, qty, msg.sender);\\n        } else {\\n            require(ERC20(EON).balanceOf(msg.sender) >= (onosiaPriceEon * qty), \\\"Not enough EON\\\");\\n            imperialGuild.mint(onosiaLiquorId, 0, qty, msg.sender);\\n        }\\n    }\\n\\n    function buyRiot(uint256 colonistId, bool RAWPayment)\\n        external\\n        whenNotPaused\\n        noCheaters\\n    {\\n        require(shardsActive = true, \\\"Shard minting not available yet\\\");\\n        require(tx.origin == msg.sender);\\n        // Must check this, as getTokenTraits will be allowed since this contract is an admin\\n        if (RAWPayment) {\\n            // This will check if origin is the owner of the token\\n            colonistNFT.burn(colonistId);\\n            imperialGuild.mint(riotId, 1, 1, msg.sender);\\n        } else {\\n            // check origin of owner of token\\n            require(ERC20(EON).balanceOf(msg.sender) >= riotPriceEon, \\\"Not enough EON\\\");\\n            colonistNFT.burn(colonistId);\\n            imperialGuild.mint(riotId, 0, 1, msg.sender);\\n        }\\n    }\\n\\n    function buyPhantom(\\n        uint256 colonistId,\\n        uint256 pirateId,\\n        bool RAWPayment\\n    ) external whenNotPaused noCheaters {\\n        require(shardsActive = true, \\\"Shard minting not available yet\\\");\\n        require(tx.origin == msg.sender);\\n        // Must check this, as getTokenTraits will be allowed since this contract is an admin\\n        if (RAWPayment) {\\n            // check origin of tokens owner\\n            colonistNFT.burn(colonistId);\\n            pirateNFT.burn(pirateId);\\n            imperialGuild.mint(phantomId, 1, 1, msg.sender);\\n        } else {\\n            require(ERC20(EON).balanceOf(msg.sender) >= phantomPriceEon , \\\"Not enough EON\\\");\\n            // check origin of token owner\\n            colonistNFT.burn(colonistId);\\n            pirateNFT.burn(pirateId);\\n            imperialGuild.mint(phantomId, 0, 1, msg.sender);\\n        }\\n    }\\n\\n    function setOnosiaLiquorId(uint8 id) external onlyOwner {\\n        onosiaLiquorId = id;\\n    }\\n\\n    function setShardIds(\\n        uint256 spear,\\n        uint256 temple,\\n        uint256 riot,\\n        uint256 phantom\\n    ) external onlyOwner {\\n        spearId = spear;\\n        templeId = temple;\\n        riotId = riot;\\n        phantomId = phantom;\\n    }\\n\\n    function setEonPrices(\\n        uint256 _spearPriceEon,\\n        uint256 _templePriceEon,\\n        uint256 _riotPriceEon,\\n        uint256 _phantomPriceEon,\\n        uint256 _onosiaLiquorPriceEon\\n    ) external onlyOwner {\\n        spearPriceEon = _spearPriceEon;\\n        templePriceEon = _templePriceEon;\\n        riotPriceEon = _riotPriceEon;\\n        phantomPriceEon = _phantomPriceEon;\\n        onosiaPriceEon = _onosiaLiquorPriceEon;\\n    }\\n\\n    /**\\n     * enables owner to pause / unpause contract\\n     */\\n    function setPaused(bool _paused) external requireContractsSet onlyOwner {\\n        if (_paused) _pause();\\n        else _unpause();\\n    }\\n\\n    /**\\n     * enables an address to mint / burn\\n     * @param addr the address to enable\\n     */\\n    function addAdmin(address addr) external onlyOwner {\\n        admins[addr] = true;\\n    }\\n\\n    function toggleShardMinting(bool _shardsActive) external onlyOwner {\\n        shardsActive = _shardsActive;\\n    }\\n\\n    /**\\n     * disables an address from minting / burning\\n     * @param addr the address to disable\\n     */\\n    function removeAdmin(address addr) external onlyOwner {\\n        admins[addr] = false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\n            \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n        );\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max)\\n            allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(\\n                        abi.encode(\\n                            PERMIT_TYPEHASH,\\n                            owner,\\n                            spender,\\n                            value,\\n                            nonces[owner]++,\\n                            deadline\\n                        )\\n                    )\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(\\n                recoveredAddress != address(0) && recoveredAddress == owner,\\n                \\\"INVALID_SIGNER\\\"\\n            );\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return\\n            block.chainid == INITIAL_CHAIN_ID\\n                ? INITIAL_DOMAIN_SEPARATOR\\n                : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\n                        \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                    ),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IColonist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IColonist {\\r\\n    // struct to store each Colonist's traits\\r\\n    struct Colonist {\\r\\n        bool isColonist;\\r\\n        uint8 background;\\r\\n        uint8 body;\\r\\n        uint8 shirt;\\r\\n        uint8 jacket;\\r\\n        uint8 jaw;\\r\\n        uint8 eyes;\\r\\n        uint8 hair;\\r\\n        uint8 held;\\r\\n        uint8 gen;\\r\\n    }\\r\\n\\r\\n    struct HColonist {\\r\\n        uint8 Legendary;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function isOwner(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function minted() external returns (uint16);\\r\\n\\r\\n    function totalCir() external returns (uint256);\\r\\n\\r\\n    function _mintColonist(address recipient, uint256 seed) external;\\r\\n\\r\\n    function _mintToHonors(address recipient, uint256 seed) external;\\r\\n\\r\\n    function _mintHonors(address recipient, uint8 id) external;\\r\\n\\r\\n    function burn(uint256 tokenId) external;\\r\\n\\r\\n    function getMaxTokens() external view returns (uint256);\\r\\n\\r\\n    function getPaidTokens() external view returns (uint256);\\r\\n\\r\\n    function getTokenTraitsColonist(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (Colonist memory);\\r\\n\\r\\n    function getTokenTraitsHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (HColonist memory);\\r\\n\\r\\n    function tokenNameByIndex(uint256 index)\\r\\n        external\\r\\n        view\\r\\n        returns (string memory);\\r\\n\\r\\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\\r\\n\\r\\n    function nameColonist(uint256 tokenId, string memory newName) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IImperialGuild.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IImperialGuild {\\r\\n\\r\\n    function getBalance(\\r\\n        address account,\\r\\n        uint256 id\\r\\n    ) external returns(uint256);\\r\\n\\r\\n    function mint(\\r\\n        uint256 typeId,\\r\\n        uint256 paymentId,\\r\\n        uint16 qty,\\r\\n        address recipient\\r\\n    ) external;\\r\\n\\r\\n    function burn(\\r\\n        uint256 typeId,\\r\\n        uint16 qty,\\r\\n        address burnFrom\\r\\n    ) external;\\r\\n\\r\\n    function handlePayment(uint256 amount) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPirates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPirates {\\r\\n    // struct to store each Colonist's traits\\r\\n    struct Pirate {\\r\\n        bool isPirate;\\r\\n        uint8 sky;\\r\\n        uint8 cockpit;\\r\\n        uint8 base;\\r\\n        uint8 engine;\\r\\n        uint8 nose;\\r\\n        uint8 wing;\\r\\n        uint8 weapon1;\\r\\n        uint8 weapon2;\\r\\n        uint8 rank;\\r\\n    }\\r\\n\\r\\n    struct HPirates {\\r\\n        uint8 Legendary;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) external;\\r\\n\\r\\n    function minted() external returns (uint16);\\r\\n\\r\\n    function piratesMinted() external returns (uint16);\\r\\n\\r\\n    function isOwner(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function _mintPirate(address recipient, uint256 seed) external;\\r\\n\\r\\n    function burn(uint256 tokenId) external;\\r\\n\\r\\n    function getTokenTraitsPirate(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (Pirate memory);\\r\\n\\r\\n    function getTokenTraitsHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (HPirates memory);\\r\\n\\r\\n    function tokenNameByIndex(uint256 index)\\r\\n        external\\r\\n        view\\r\\n        returns (string memory);\\r\\n    \\r\\n    function isHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function updateOriginAccess(uint16[] memory tokenIds) external;\\r\\n\\r\\n    function getTokenWriteBlock(uint256 tokenId) \\r\\n    external \\r\\n    view  \\r\\n    returns(uint64);\\r\\n\\r\\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\\r\\n\\r\\n    function namePirate(uint256 tokenId, string memory newName) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IRAW.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\npragma solidity ^0.8.0;\\n\\ninterface IRAW {\\n\\n    function updateOriginAccess(address user) external;\\n\\n\\n    function balanceOf(\\n        address account,\\n        uint256 id\\n    ) external returns(uint256);\\n\\n    function mint(\\n        uint256 typeId,\\n        uint256 qty,\\n        address recipient\\n    ) external;\\n\\n    function burn(\\n        uint256 typeId,\\n        uint256 qty,\\n        address burnFrom\\n    ) external;\\n\\n    function updateMintBurns(\\n        uint256 typeId,\\n        uint256 mintQty,\\n        uint256 burnQty\\n    ) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IShatteredEON.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IShatteredEON {}\\r\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EON\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RAW\",\"outputs\":[{\"internalType\":\"contract IRAW\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"colonistId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pirateId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"RAWPayment\",\"type\":\"bool\"}],\"name\":\"buyPhantom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"colonistId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"RAWPayment\",\"type\":\"bool\"}],\"name\":\"buyRiot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"RAWPayment\",\"type\":\"bool\"}],\"name\":\"buySpear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"RAWPayment\",\"type\":\"bool\"}],\"name\":\"buyTemple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"colonistNFT\",\"outputs\":[{\"internalType\":\"contract IColonist\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"imperialGuild\",\"outputs\":[{\"internalType\":\"contract IImperialGuild\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"qty\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"RAWPayment\",\"type\":\"bool\"}],\"name\":\"makeOnosiaLiquor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onosiaLiquorId\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onosiaPriceEon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"phantomId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"phantomPriceEon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pirateNFT\",\"outputs\":[{\"internalType\":\"contract IPirates\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"riotId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"riotPriceEon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_RAW\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_EON\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pirateNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_colonistNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_imperialGuild\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_shatteredEON\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_spearPriceEon\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_templePriceEon\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_riotPriceEon\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_phantomPriceEon\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_onosiaLiquorPriceEon\",\"type\":\"uint256\"}],\"name\":\"setEonPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"setOnosiaLiquorId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"spear\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"temple\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"riot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"phantom\",\"type\":\"uint256\"}],\"name\":\"setShardIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shardsActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shattered\",\"outputs\":[{\"internalType\":\"contract IShatteredEON\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spearId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spearPriceEon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"templeId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"templePriceEon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_shardsActive\",\"type\":\"bool\"}],\"name\":\"toggleShardMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DenOfAlgol", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}