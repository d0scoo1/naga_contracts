{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"IInitiator.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IHustlerActions {\\n    struct SetMetadata {\\n        bytes4 color;\\n        bytes4 background;\\n        bytes2 options;\\n        uint8[4] viewbox;\\n        uint8[4] body;\\n        uint8[10] order;\\n        bytes2 mask;\\n        string name;\\n    }\\n}\\n\\ninterface IInitiator {\\n    function mintFromDopeTo(\\n        uint256 id,\\n        address to,\\n        IHustlerActions.SetMetadata calldata meta,\\n        bytes memory data,\\n        uint32 gasLimit\\n    ) external;\\n\\n    function cost() external returns (uint256);\\n}\\n\"},\"Initiator.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {IWyvernExchange} from \\\"./IWyvernExchange.sol\\\";\\nimport {IInitiator, IHustlerActions} from \\\"./IInitiator.sol\\\";\\nimport {ISwapRouter} from \\\"./ISwapRouter.sol\\\";\\nimport {IQuoter} from \\\"./IQuoter.sol\\\";\\n\\ninterface ERC721 {\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n}\\n\\ninterface ERC20 {\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function balanceOf(address account) external returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n}\\n\\ncontract Initiator {\\n    ISwapRouter private constant uniswapRouter =\\n        ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\\n    IQuoter private constant quoter =\\n        IQuoter(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\\n\\n    IInitiator private constant initiator =\\n        IInitiator(0x7aa8e897d712CFB9C7cb6B37634A1C4d21181c8B);\\n    IWyvernExchange private constant wyvern =\\n        IWyvernExchange(0x7Be8076f4EA4A4AD08075C2508e481d6C946D12b);\\n\\n    ERC721 private constant DOPE =\\n        ERC721(0x8707276DF042E89669d69A177d3DA7dC78bd8723);\\n    address private immutable WETH9 =\\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    ERC20 private immutable PAPER =\\n        ERC20(0x7aE1D57b58fA6411F32948314BadD83583eE0e8C);\\n    uint24 private immutable fee = 10000;\\n\\n    struct Order {\\n        address maker;\\n        uint8 vs;\\n        bytes32[2] rss;\\n        uint256 fee;\\n        uint256 price;\\n        uint256 expiration;\\n        uint256 listing;\\n        uint256 salt;\\n        bytes calldataSell;\\n        bytes calldataBuy;\\n    }\\n\\n    constructor() {\\n        PAPER.approve(address(initiator), type(uint256).max);\\n    }\\n\\n    function buy(uint256 openseaEth, Order calldata order) internal {\\n        wyvern.atomicMatch_{value: openseaEth}(\\n            [\\n                address(wyvern),\\n                address(this),\\n                order.maker,\\n                0x0000000000000000000000000000000000000000,\\n                address(DOPE),\\n                0x0000000000000000000000000000000000000000,\\n                0x0000000000000000000000000000000000000000,\\n                address(wyvern),\\n                order.maker,\\n                0x0000000000000000000000000000000000000000,\\n                0x5b3256965e7C3cF26E11FCAf296DfC8807C01073,\\n                address(DOPE),\\n                0x0000000000000000000000000000000000000000,\\n                0x0000000000000000000000000000000000000000\\n            ],\\n            [\\n                order.fee, // makerRelayerFee\\n                0, // takerRelayerFee\\n                0, // makerProtocolFee\\n                0, // takerProtocolFee\\n                order.price, // basePrice\\n                0, // Auction extra parameter\\n                0, // listingTime\\n                0, // expirationTime\\n                0, // salt\\n                order.fee,\\n                0,\\n                0,\\n                0,\\n                order.price,\\n                0,\\n                order.listing,\\n                order.expiration,\\n                order.salt\\n            ],\\n            [1, 0, 0, 0, 1, 1, 0, 0],\\n            order.calldataBuy,\\n            order.calldataSell,\\n            hex\\\"00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\\",\\n            hex\\\"000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000000000\\\",\\n            \\\"\\\",\\n            \\\"\\\",\\n            [0, order.vs],\\n            [bytes32(0x0), 0x0, order.rss[0], order.rss[1], 0x0]\\n        );\\n    }\\n\\n    function initiate(\\n        Order calldata order,\\n        uint256 id,\\n        IHustlerActions.SetMetadata calldata meta,\\n        address to,\\n        uint256 openseaEth,\\n        uint256 paperEth,\\n        uint256 paperOut,\\n        uint256 deadline\\n    ) external payable {\\n        buy(openseaEth, order);\\n        swap(paperEth, paperOut, deadline);\\n        initiator.mintFromDopeTo(id, to, meta, \\\"\\\", 1e6 + 1);\\n        DOPE.safeTransferFrom(address(this), msg.sender, id);\\n        PAPER.transfer(msg.sender, PAPER.balanceOf(address(this)));\\n\\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\\\"\\\");\\n        require(success, \\\"refund failed\\\");\\n    }\\n\\n    function swap(\\n        uint256 eth,\\n        uint256 out,\\n        uint256 deadline\\n    ) internal {\\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\\n            .ExactInputSingleParams(\\n                WETH9,\\n                address(PAPER),\\n                fee,\\n                address(this),\\n                deadline,\\n                eth,\\n                out,\\n                0\\n            );\\n\\n        uniswapRouter.exactInputSingle{value: eth}(params);\\n        uniswapRouter.refundETH();\\n    }\\n\\n    function estimate(uint256 paper) external payable returns (uint256) {\\n        return\\n            quoter.quoteExactOutputSingle(WETH9, address(PAPER), fee, paper, 0);\\n    }\\n\\n    receive() external payable {}\\n}\\n\"},\"IQuoter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity \\u003e=0.7.5;\\npragma abicoder v2;\\n\\n/// @title Quoter Interface\\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\\ninterface IQuoter {\\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\\n    /// @param amountIn The amount of the first token to swap\\n    /// @return amountOut The amount of the last token that would be received\\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountIn The desired input amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountOut The amount of `tokenOut` that would be received\\n    function quoteExactInputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\\n    /// @param amountOut The amount of the last token to receive\\n    /// @return amountIn The amount of first token required to be paid\\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\\n\\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountOut The desired output amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\\n    function quoteExactOutputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountOut,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountIn);\\n}\\n\"},\"ISwapRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity \\u003e=0.7.5;\\npragma abicoder v2;\\n\\nimport \\\"./IUniswapV3SwapCallback.sol\\\";\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountIn);\\n\\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\\n    /// that use ether for the input amount\\n    function refundETH() external payable;\\n}\\n\"},\"IUniswapV3SwapCallback.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity \\u003e=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\"},\"IWyvernExchange.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IWyvernExchange {\\n    function atomicMatch_(\\n        address[14] memory addrs,\\n        uint256[18] memory uints,\\n        uint8[8] memory feeMethodsSidesKindsHowToCalls,\\n        bytes memory calldataBuy,\\n        bytes memory calldataSell,\\n        bytes memory replacementPatternBuy,\\n        bytes memory replacementPatternSell,\\n        bytes memory staticExtradataBuy,\\n        bytes memory staticExtradataSell,\\n        uint8[2] memory vs,\\n        bytes32[5] memory rssMetadata\\n    ) external payable;\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"paper\",\"type\":\"uint256\"}],\"name\":\"estimate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"vs\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[2]\",\"name\":\"rss\",\"type\":\"bytes32[2]\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"calldataSell\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"calldataBuy\",\"type\":\"bytes\"}],\"internalType\":\"struct Initiator.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"color\",\"type\":\"bytes4\"},{\"internalType\":\"bytes4\",\"name\":\"background\",\"type\":\"bytes4\"},{\"internalType\":\"bytes2\",\"name\":\"options\",\"type\":\"bytes2\"},{\"internalType\":\"uint8[4]\",\"name\":\"viewbox\",\"type\":\"uint8[4]\"},{\"internalType\":\"uint8[4]\",\"name\":\"body\",\"type\":\"uint8[4]\"},{\"internalType\":\"uint8[10]\",\"name\":\"order\",\"type\":\"uint8[10]\"},{\"internalType\":\"bytes2\",\"name\":\"mask\",\"type\":\"bytes2\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct IHustlerActions.SetMetadata\",\"name\":\"meta\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"openseaEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paperEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paperOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"initiate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Initiator", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3fdd406351d1bb56e69553c64ad62d33ec99131006e1f189f749036eb62b2c1d"}]}