{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n}\r\n\r\nlibrary UniswapV2Library {\r\n    using SafeMath for uint256;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB)\r\n        internal\r\n        pure\r\n        returns (address token0, address token1)\r\n    {\r\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\r\n        (token0, token1) = tokenA < tokenB\r\n            ? (tokenA, tokenB)\r\n            : (tokenB, tokenA);\r\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(\r\n        address targetPair,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\r\n        (address token0, ) = sortTokens(tokenA, tokenB);\r\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(targetPair)\r\n            .getReserves();\r\n        (reserveA, reserveB) = tokenA == token0\r\n            ? (reserve0, reserve1)\r\n            : (reserve1, reserve0);\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\r\n        require(\r\n            reserveIn > 0 && reserveOut > 0,\r\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        uint256 amountInWithFee = amountIn.mul(997);\r\n        uint256 numerator = amountInWithFee.mul(reserveOut);\r\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountIn) {\r\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        require(\r\n            reserveIn > 0 && reserveOut > 0,\r\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(\r\n        address targetPair,\r\n        uint256 amountIn,\r\n        address[2] memory path\r\n    ) internal view returns (uint256[2] memory amounts) {\r\n        amounts[0] = amountIn;\r\n        (uint256 reserveIn, uint256 reserveOut) = getReserves(\r\n            targetPair,\r\n            path[0],\r\n            path[1]\r\n        );\r\n        amounts[1] = getAmountOut(amounts[0], reserveIn, reserveOut);\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(\r\n        address targetPair,\r\n        uint256 amountOut,\r\n        address[2] memory path\r\n    ) internal view returns (uint256[2] memory amounts) {\r\n        amounts[1] = amountOut;\r\n        (uint256 reserveIn, uint256 reserveOut) = getReserves(\r\n            targetPair,\r\n            path[1],\r\n            path[0]\r\n        );\r\n        amounts[0] = getAmountIn(amounts[1], reserveIn, reserveOut);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n}\r\n\r\ninterface IWETH {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function withdraw(uint256) external;\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB)\r\n        external\r\n        view\r\n        returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Callee {\r\n    function uniswapV2Call(\r\n        address sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ncontract FlashLoaner is IUniswapV2Callee {\r\n    address immutable SushiFactory;\r\n    address immutable UniswapFactory;\r\n    address immutable WETH;\r\n    address immutable Owner;\r\n\r\n    event Withdraw(address token, uint256 amount);\r\n    event Earn(uint256 earnValue);\r\n    event Deposit(address sender, uint256 amount);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == Owner, \"Only owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        SushiFactory = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac;\r\n        UniswapFactory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n        WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n        Owner = msg.sender;\r\n    }\r\n\r\n    struct GasCost {\r\n        uint256 gasLimit;\r\n        uint256 gasPrice;\r\n    }\r\n\r\n    function decodeGasCost(bytes memory data)\r\n        public\r\n        pure\r\n        returns (GasCost memory)\r\n    {\r\n        return abi.decode(data, (GasCost));\r\n    }\r\n\r\n    function uniswapV2Call(\r\n        address _sender,\r\n        uint256 _amount0,\r\n        uint256 _amount1,\r\n        bytes calldata _data\r\n    ) external {\r\n        // only loan token, to swap weth and withdraw to eth\r\n        require(_amount0 == 0 || _amount1 == 0);\r\n        address[2] memory path;\r\n        address token0 = IUniswapV2Pair(msg.sender).token0();\r\n        address token1 = IUniswapV2Pair(msg.sender).token1();\r\n\r\n        // path[1] always is weth\r\n        path[0] = _amount0 == 0 ? token1 : token0;\r\n        path[1] = _amount0 == 0 ? token0 : token1;\r\n        require(path[1] == WETH, \"uniswapV2Call:path[1] must equals weth\");\r\n        uint256 amountToken = _amount0 == 0 ? _amount1 : _amount0;\r\n        address targetPair;\r\n        if (IUniswapV2Pair(msg.sender).factory() == SushiFactory) {\r\n            targetPair = IUniswapV2Factory(UniswapFactory).getPair(\r\n                token0,\r\n                token1\r\n            );\r\n        } else {\r\n            targetPair = IUniswapV2Factory(SushiFactory).getPair(\r\n                token0,\r\n                token1\r\n            );\r\n        }\r\n        uint256 amountReceived = swapExactTokensForTokens(\r\n            targetPair,\r\n            amountToken,\r\n            0,\r\n            path,\r\n            address(this)\r\n        )[1];\r\n\r\n        // no need for require() check, if amount required is not sent sushiRouter will revert\r\n        uint256 amountRequired = UniswapV2Library.getAmountsIn(\r\n            msg.sender,\r\n            amountToken,\r\n            path\r\n        )[0];\r\n\r\n        GasCost memory gasCost = decodeGasCost(_data);\r\n        uint256 earnValue = amountReceived -\r\n            amountRequired -\r\n            gasCost.gasLimit *\r\n            gasCost.gasPrice;\r\n\r\n        require(earnValue > 0, \"Revert: Not earn!\");\r\n\r\n        IERC20(path[1]).transfer(msg.sender, amountRequired);\r\n        IWETH(WETH).withdraw(IWETH(WETH).balanceOf(address(this)));\r\n        payable(_sender).transfer(address(this).balance);\r\n        emit Earn(\r\n            earnValue\r\n        );\r\n    }\r\n\r\n    function withdrawToken(address token, uint256 amount) public onlyOwner {\r\n        IERC20(token).transfer(msg.sender, amount);\r\n        emit Withdraw(token, amount);\r\n    }\r\n\r\n    function withdraw(uint256 amount) public onlyOwner {\r\n        payable(msg.sender).transfer(amount);\r\n        emit Withdraw(address(0), amount);\r\n    }\r\n\r\n    function swapExactTokensForTokens(\r\n        address targetPair,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[2] memory path,\r\n        address to\r\n    ) internal returns (uint256[2] memory amounts) {\r\n        amounts = UniswapV2Library.getAmountsOut(targetPair, amountIn, path);\r\n        require(\r\n            amounts[amounts.length - 1] >= amountOutMin,\r\n            \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\r\n        );\r\n        IERC20(path[0]).transfer(targetPair, amounts[0]);\r\n        _swap(targetPair, amounts, path, to);\r\n    }\r\n\r\n    // **** SWAP ****\r\n    function _swap(\r\n        address targetPair,\r\n        uint256[2] memory amounts,\r\n        address[2] memory path,\r\n        address to\r\n    ) internal virtual {\r\n        (address token0, ) = UniswapV2Library.sortTokens(path[0], path[1]);\r\n        uint256 amountOut = amounts[1];\r\n        (uint256 amount0Out, uint256 amount1Out) = path[0] == token0\r\n            ? (uint256(0), amountOut)\r\n            : (amountOut, uint256(0));\r\n        IUniswapV2Pair(targetPair).swap(\r\n            amount0Out,\r\n            amount1Out,\r\n            to,\r\n            new bytes(0)\r\n        );\r\n    }\r\n\r\n    fallback() external payable {\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earnValue\",\"type\":\"uint256\"}],\"name\":\"Earn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"decodeGasCost\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct FlashLoaner.GasCost\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"uniswapV2Call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FlashLoaner", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a58a20d92feb98d42538eb1d1910077af08e9d863f12ed3d2b22297e3cd75484"}]}