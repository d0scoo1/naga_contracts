{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Censor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @creator: Pak\\n/// @author: manifold.xyz\\n\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n//                                                                                                                        //\\n//                                                                                                                        //\\n//       ,ad8888ba,   88888888888  888b      88   ad88888ba     ,ad8888ba,    88888888ba   88888888888  88888888ba,       //\\n//      d8\\\"'    `\\\"8b  88           8888b     88  d8\\\"     \\\"8b   d8\\\"'    `\\\"8b   88      \\\"8b  88           88      `\\\"8b      //\\n//  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  //\\n//  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  //\\n//  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  //\\n//  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  //\\n//      Y8a.    .a8P  88           88     `8888  Y8a     a8P   Y8a.    .a8P   88     `8b   88           88      .a8P      //\\n//       `\\\"Y8888Y\\\"'   88888888888  88      `888   \\\"Y88888P\\\"     `\\\"Y8888Y\\\"'    88      `8b  88888888888  88888888Y\\\"'       //\\n//                                                                                                                        //\\n//                                                                                                                        //\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\ncontract Censor {\\n\\n    using Strings for uint256;\\n    \\n    string constant private _MESSAGE_TAG = '<MESSAGE>';\\n    string[] private _imageParts;\\n\\n    constructor() {\\n        _imageParts.push(\\\"<svg xmlns='http://www.w3.org/2000/svg' width='1000' height='1000' viewBox='0 0 1000 1000'>\\\");\\n            _imageParts.push(\\\"<style>@font-face {font-family: 'C';src: \\\");\\n            _imageParts.push(\\\"url('data:font/woff2;charset=utf-8;base64,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') format('woff2');\\\");\\n            _imageParts.push(\\\"font-weight: 500; font-style: normal; font-display: swap;}\\\");\\n            _imageParts.push(\\\".f { width: 100%; height: 100%; }\\\");\\n            _imageParts.push(\\\".b { fill: whitesmoke; }\\\");\\n            _imageParts.push(\\\".a { animation: o 2s ease-out forwards; }\\\");\\n            _imageParts.push(\\\"@keyframes o { 10% { opacity: 1; } 100% { opacity: 0; } }\\\");\\n            _imageParts.push(\\\"tspan { fill: black; font-family: 'C'; font-size: 70px; text-transform: uppercase; text-anchor: middle; }\\\");\\n            _imageParts.push(\\\"</style>\\\");\\n            _imageParts.push(\\\"<rect class='b f' />\\\");\\n            _imageParts.push(_MESSAGE_TAG);\\n            _imageParts.push(\\\"<rect class='b f a' />\\\");\\n        _imageParts.push(\\\"</svg>\\\");\\n    }\\n\\n    function metadata(uint256 tokenId, string memory message, uint256 value) external view returns(string memory) {\\n        return string(abi.encodePacked('data:application/json;utf8,{\\\"name\\\":\\\"Censored #',tokenId.toString(),'\\\", \\\"description\\\":\\\"',_toUpperCase(message),'\\\", \\\"created_by\\\":\\\"Pak\\\", \\\"image\\\":\\\"data:image/svg+xml;utf8,',\\n            svg(tokenId, message, value),\\n            '\\\",\\\"attributes\\\":[{\\\"trait_type\\\":\\\"Censored\\\",\\\"value\\\":\\\"True\\\"},{\\\"trait_type\\\":\\\"Initial Price\\\",\\\"value\\\":',_valueString(value),'}]}'));\\n    }\\n\\n    function _toUpperCase(string memory message) private pure returns (string memory) {\\n        bytes memory messageBytes = bytes(message);\\n        bytes memory upperMessageBytes = new bytes(messageBytes.length);\\n        for (uint i = 0; i < messageBytes.length; i++) {\\n            bytes1 char = messageBytes[i];\\n            if (char >= 0x61 && char <= 0x7A) {\\n                // So we add 32 to make it lowercase\\n                upperMessageBytes[i] = bytes1(uint8(char) - 32);\\n            } else {\\n                upperMessageBytes[i] = char;\\n            }\\n        }\\n        return string(upperMessageBytes);\\n    }\\n\\n    function _renderLines(string memory message) private pure returns (string memory) {\\n        // Allocate memory for max number of lines (7) at 18 characters each (126)\\n        bytes memory lineBytes = new bytes(126);\\n        uint8[] memory lineLengths = new uint8[](7);\\n        \\n        // Compute line count\\n        bytes memory messageBytes = bytes(message);\\n        uint8 wordLength;\\n        uint8 lineLength;\\n        uint8 lineIndex;\\n        uint256 messageLastIndex = messageBytes.length-1;\\n        for (uint i = 0; i <= messageLastIndex; i++) {\\n            bytes1 char = messageBytes[i];\\n            if (i == 0 || char != 0x20 || i == messageLastIndex) {\\n                wordLength += 1;\\n            }\\n            if (char == 0x20 || i == messageLastIndex) {\\n                // Check line length is < 18 after adding new word\\n                if ((lineLength == 0 && lineLength + wordLength <= 18) || (lineLength + wordLength <= 17)) {\\n                    // Add into the current lineBytes\\n                    uint256 lineBytesOffset = lineIndex*18;\\n                    if (lineLength > 0) {\\n                       // Additional word, add a space\\n                       lineBytes[lineBytesOffset+lineLength] = 0x20;\\n                       lineLength += 1;\\n                    }\\n                    for (uint j = 0; j < wordLength; j++) {\\n                        lineBytes[lineBytesOffset+lineLength+j] = messageBytes[(i == messageLastIndex ? 1 : 0)+i-wordLength+j];\\n                    }\\n                    lineLength += wordLength;\\n                    lineLengths[lineIndex] = lineLength;\\n                } else {\\n                    // Word plus existing line length over max\\n                    if (wordLength > 18) {\\n                        if (lineLength > 0) {\\n                            // Move to new line if there have already been words added to this line\\n                            lineIndex += 1;\\n                            lineLength = 0;\\n                        }\\n                        uint256 lineBytesOffset = lineIndex*18;\\n                        for (uint j = 0; j < wordLength; j++) {\\n                            lineLength += 1;\\n                            lineBytes[lineBytesOffset+(j % 18)] = messageBytes[(i == messageLastIndex ? 1 : 0)+i-wordLength+j];\\n                            if (j > 0 && j % 18 == 17) {\\n                                // New line every 18 characters\\n                                lineLengths[lineIndex] = lineLength;\\n                                lineIndex += 1;\\n                                lineLength = 0;\\n                                lineBytesOffset = lineIndex*18;\\n                            }\\n                        }\\n                        lineLengths[lineIndex] = lineLength;\\n                    } else {\\n                        // New line\\n                        lineIndex += 1;\\n                        uint256 lineBytesOffset = lineIndex*18;\\n                        for (uint j = 0; j < wordLength; j++) {\\n                            lineBytes[lineBytesOffset+j] = messageBytes[(i == messageLastIndex ? 1 : 0)+i-wordLength+j];\\n                        }\\n                        lineLength = wordLength;\\n                        lineLengths[lineIndex] = lineLength;\\n                    }\\n                }\\n                wordLength = 0;\\n            }\\n        }\\n\\n        string memory lines;\\n        string memory strikeouts;\\n        uint8 lineCount;\\n        for (uint i = 0; i <= lineIndex; i++) {\\n            uint256 lineBytesOffset = i*18;\\n            if (lineLengths[i] > 0) {\\n               lineCount += 1;\\n               bytes memory line = new bytes(lineLengths[i]);\\n               bytes memory strikeout = new bytes(lineLengths[i]);\\n               for (uint j = 0; j < lineLengths[i]; j++) {\\n                   line[j] = lineBytes[lineBytesOffset+j];\\n                   strikeout[j] = 0x2D;\\n               }\\n               if (i == 0) {\\n                   lines = string(abi.encodePacked(lines,\\\"<tspan x='500'>\\\",line,\\\"</tspan>\\\"));\\n                   strikeouts = string(abi.encodePacked(strikeouts,\\\"<tspan x='500'>\\\",strikeout,\\\"</tspan>\\\"));\\n               } else {\\n                   lines = string(abi.encodePacked(lines,\\\"<tspan x='500' dy='1em'>\\\",line,\\\"</tspan>\\\"));\\n                   strikeouts = string(abi.encodePacked(strikeouts,\\\"<tspan x='500' dy='1em'>\\\",strikeout,\\\"</tspan>\\\"));\\n               }\\n            }\\n        }\\n        return string(abi.encodePacked(\\\"<svg y='\\\",(560-uint256(lineCount)*35).toString(),\\\"' overflow='visible'><text>\\\",lines,\\\"</text><text>\\\",strikeouts,\\\"</text></svg>\\\"));\\n    }\\n\\n    function _valueString(uint256 value) private pure returns (string memory) {\\n        uint256 eth = value/10**18;\\n        uint256 decimal4 = value/10**14 - eth*10**4;\\n        return string(abi.encodePacked(eth.toString(), '.', _decimal4ToString(decimal4)));\\n    }\\n\\n    function _decimal4ToString(uint256 decimal4) private pure returns (string memory) {\\n        bytes memory decimal4Characters = new bytes(4);\\n        for (uint i = 0; i < 4; i++) {\\n            decimal4Characters[3 - i] = bytes1(uint8(0x30 + decimal4 % 10));\\n            decimal4 /= 10;\\n        }\\n        return string(abi.encodePacked(decimal4Characters));\\n    }\\n\\n    function svg(uint256, string memory message, uint256) public view returns(string memory) {\\n        bytes memory byteString;\\n        for (uint i = 0; i < _imageParts.length; i++) {\\n            if (_checkTag(_imageParts[i], _MESSAGE_TAG)) {\\n                byteString = abi.encodePacked(byteString, _renderLines(message));\\n            } else {\\n                byteString = abi.encodePacked(byteString, _imageParts[i]);\\n            }\\n        }\\n        return string(byteString);\\n    }\\n\\n    function _checkTag(string storage a, string memory b) private pure returns (bool) {\\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"metadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"svg\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Censor", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}