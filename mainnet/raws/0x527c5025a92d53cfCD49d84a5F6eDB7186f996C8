{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/thirdparty/ECDH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n/*\\n    Modifications Copyright (C) 2018 SKALE Labs\\n    ec.sol by @jbaylina under GPL-3.0 License\\n*/\\n/** @file ECDH.sol\\n * @author Jordi Baylina (@jbaylina)\\n * @date 2016\\n */\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"@skalenetwork/skale-manager-interfaces/thirdparty/IECDH.sol\\\";\\n\\n\\n/**\\n * @title ECDH\\n * @dev This contract performs Elliptic-curve Diffie-Hellman key exchange to\\n * support the DKG process.\\n */\\ncontract ECDH is IECDH {\\n\\n    uint256 constant private _GX = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\\n    uint256 constant private _GY = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\\n    uint256 constant private _N  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\\n    uint256 constant private _A  = 0;\\n\\n    function publicKey(uint256 privKey) external pure override returns (uint256 qx, uint256 qy) {\\n        uint256 x;\\n        uint256 y;\\n        uint256 z;\\n        (x, y, z) = ecMul(\\n            privKey,\\n            _GX,\\n            _GY,\\n            1\\n        );\\n        z = inverse(z);\\n        qx = mulmod(x, z, _N);\\n        qy = mulmod(y, z, _N);\\n    }\\n\\n    function deriveKey(\\n        uint256 privKey,\\n        uint256 pubX,\\n        uint256 pubY\\n    )\\n        external\\n        pure\\n        override\\n        returns (uint256 qx, uint256 qy)\\n    {\\n        uint256 x;\\n        uint256 y;\\n        uint256 z;\\n        (x, y, z) = ecMul(\\n            privKey,\\n            pubX,\\n            pubY,\\n            1\\n        );\\n        z = inverse(z);\\n        qx = mulmod(x, z, _N);\\n        qy = mulmod(y, z, _N);\\n    }\\n\\n    function jAdd(\\n        uint256 x1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 z2\\n    )\\n        public\\n        pure\\n        override\\n        returns (uint256 x3, uint256 z3)\\n    {\\n        (x3, z3) = (addmod(mulmod(z2, x1, _N), mulmod(x2, z1, _N), _N), mulmod(z1, z2, _N));\\n    }\\n\\n    function jSub(\\n        uint256 x1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 z2\\n    )\\n        public\\n        pure\\n        override\\n        returns (uint256 x3, uint256 z3)\\n    {\\n        (x3, z3) = (addmod(mulmod(z2, x1, _N), mulmod(_N - x2, z1, _N), _N), mulmod(z1, z2, _N));\\n    }\\n\\n    function jMul(\\n        uint256 x1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 z2\\n    )\\n        public\\n        pure\\n        override\\n        returns (uint256 x3, uint256 z3)\\n    {\\n        (x3, z3) = (mulmod(x1, x2, _N), mulmod(z1, z2, _N));\\n    }\\n\\n    function jDiv(\\n        uint256 x1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 z2\\n    )\\n        public\\n        pure\\n        override\\n        returns (uint256 x3, uint256 z3)\\n    {\\n        (x3, z3) = (mulmod(x1, z2, _N), mulmod(z1, x2, _N));\\n    }\\n\\n    function inverse(uint256 a) public pure override returns (uint256 invA) {\\n        require(a > 0 && a < _N, \\\"Input is incorrect\\\");\\n        uint256 t = 0;\\n        uint256 newT = 1;\\n        uint256 r = _N;\\n        uint256 newR = a;\\n        uint256 q;\\n        while (newR != 0) {\\n            q = r / newR;\\n            (t, newT) = (newT, addmod(t, (_N - mulmod(q, newT, _N)), _N));\\n            (r, newR) = (newR, r % newR);\\n        }\\n        return t;\\n    }\\n\\n    function ecAdd(\\n        uint256 x1,\\n        uint256 y1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 y2,\\n        uint256 z2\\n    )\\n        public\\n        pure\\n        override\\n        returns (uint256 x3, uint256 y3, uint256 z3)\\n    {\\n        uint256 ln;\\n        uint256 lz;\\n        uint256 da;\\n        uint256 db;\\n        // we use (0 0 1) as zero point, z always equal 1\\n        if ((x1 == 0) && (y1 == 0)) {\\n            return (x2, y2, z2);\\n        }\\n\\n        // we use (0 0 1) as zero point, z always equal 1\\n        if ((x2 == 0) && (y2 == 0)) {\\n            return (x1, y1, z1);\\n        }\\n\\n        if ((x1 == x2) && (y1 == y2)) {\\n            (ln, lz) = jMul(x1, z1, x1, z1);\\n            (ln, lz) = jMul(ln,lz,3,1);\\n            (ln, lz) = jAdd(ln,lz,_A,1);\\n            (da, db) = jMul(y1,z1,2,1);\\n        } else {\\n            (ln, lz) = jSub(y2,z2,y1,z1);\\n            (da, db) = jSub(x2,z2,x1,z1);\\n        }\\n        (ln, lz) = jDiv(ln,lz,da,db);\\n\\n        (x3, da) = jMul(ln,lz,ln,lz);\\n        (x3, da) = jSub(x3,da,x1,z1);\\n        (x3, da) = jSub(x3,da,x2,z2);\\n\\n        (y3, db) = jSub(x1,z1,x3,da);\\n        (y3, db) = jMul(y3,db,ln,lz);\\n        (y3, db) = jSub(y3,db,y1,z1);\\n\\n        if (da != db) {\\n            x3 = mulmod(x3, db, _N);\\n            y3 = mulmod(y3, da, _N);\\n            z3 = mulmod(da, db, _N);\\n        } else {\\n            z3 = da;\\n        }\\n    }\\n\\n    function ecDouble(\\n        uint256 x1,\\n        uint256 y1,\\n        uint256 z1\\n    )\\n        public\\n        pure\\n        override\\n        returns (uint256 x3, uint256 y3, uint256 z3)\\n    {\\n        (x3, y3, z3) = ecAdd(\\n            x1,\\n            y1,\\n            z1,\\n            x1,\\n            y1,\\n            z1\\n        );\\n    }\\n\\n    function ecMul(\\n        uint256 d,\\n        uint256 x1,\\n        uint256 y1,\\n        uint256 z1\\n    )\\n        public\\n        pure\\n        override\\n        returns (uint256 x3, uint256 y3, uint256 z3)\\n    {\\n        uint256 remaining = d;\\n        uint256 px = x1;\\n        uint256 py = y1;\\n        uint256 pz = z1;\\n        uint256 acx = 0;\\n        uint256 acy = 0;\\n        uint256 acz = 1;\\n\\n        if (d == 0) {\\n            return (0, 0, 1);\\n        }\\n\\n        while (remaining != 0) {\\n            if ((remaining & 1) != 0) {\\n                (acx, acy, acz) = ecAdd(\\n                    acx,\\n                    acy,\\n                    acz,\\n                    px,\\n                    py,\\n                    pz\\n                );\\n            }\\n            remaining = remaining / 2;\\n            (px, py, pz) = ecDouble(px, py, pz);\\n        }\\n\\n        (x3, y3, z3) = (acx, acy, acz);\\n    }\\n}\\n\"\r\n    },\r\n    \"@skalenetwork/skale-manager-interfaces/thirdparty/IECDH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\n/*\\n    IECDH.sol - SKALE Manager\\n    Copyright (C) 2018-Present SKALE Labs\\n    @author Artem Payvin\\n\\n    SKALE Manager is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU Affero General Public License as published\\n    by the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n    SKALE Manager is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU Affero General Public License for more details.\\n\\n    You should have received a copy of the GNU Affero General Public License\\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\\n*/\\n\\npragma solidity >=0.6.10 <0.9.0;\\n\\ninterface IECDH {\\n    function publicKey(uint256 privKey) external pure returns (uint256 qx, uint256 qy);\\n    function deriveKey(\\n        uint256 privKey,\\n        uint256 pubX,\\n        uint256 pubY\\n    )\\n        external\\n        pure\\n        returns (uint256 qx, uint256 qy);\\n    function jAdd(\\n        uint256 x1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 z2\\n    )\\n        external\\n        pure\\n        returns (uint256 x3, uint256 z3);\\n    function jSub(\\n        uint256 x1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 z2\\n    )\\n        external\\n        pure\\n        returns (uint256 x3, uint256 z3);\\n    function jMul(\\n        uint256 x1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 z2\\n    )\\n        external\\n        pure\\n        returns (uint256 x3, uint256 z3);\\n    function jDiv(\\n        uint256 x1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 z2\\n    )\\n        external\\n        pure\\n        returns (uint256 x3, uint256 z3);\\n    function inverse(uint256 a) external pure returns (uint256 invA);\\n    function ecAdd(\\n        uint256 x1,\\n        uint256 y1,\\n        uint256 z1,\\n        uint256 x2,\\n        uint256 y2,\\n        uint256 z2\\n    )\\n        external\\n        pure\\n        returns (uint256 x3, uint256 y3, uint256 z3);\\n    function ecDouble(\\n        uint256 x1,\\n        uint256 y1,\\n        uint256 z1\\n    )\\n        external\\n        pure\\n        returns (uint256 x3, uint256 y3, uint256 z3);\\n    function ecMul(\\n        uint256 d,\\n        uint256 x1,\\n        uint256 y1,\\n        uint256 z1\\n    )\\n        external\\n        pure\\n        returns (uint256 x3, uint256 y3, uint256 z3);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"privKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubY\",\"type\":\"uint256\"}],\"name\":\"deriveKey\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"qx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qy\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z2\",\"type\":\"uint256\"}],\"name\":\"ecAdd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"x3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z3\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z1\",\"type\":\"uint256\"}],\"name\":\"ecDouble\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"x3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z3\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z1\",\"type\":\"uint256\"}],\"name\":\"ecMul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"x3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z3\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"inverse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"invA\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z2\",\"type\":\"uint256\"}],\"name\":\"jAdd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"x3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z3\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z2\",\"type\":\"uint256\"}],\"name\":\"jDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"x3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z3\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z2\",\"type\":\"uint256\"}],\"name\":\"jMul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"x3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z3\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z2\",\"type\":\"uint256\"}],\"name\":\"jSub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"x3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z3\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"privKey\",\"type\":\"uint256\"}],\"name\":\"publicKey\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"qx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qy\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "ECDH", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}