{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/Pausable.sol\r\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in paused state.\r\n     */\r\n    constructor() {\r\n        _paused = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Strings.sol\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: IManifoldERC721Edition.sol\r\n/// @author: manifold.xyz\r\n/**\r\n * Manifold ERC721 Edition Controller interface\r\n */\r\ninterface IManifoldERC721Edition {\r\n\r\n    event SeriesCreated(address caller, address creator, uint256 series, uint256 maxSupply);\r\n\r\n    /**\r\n     * @dev Create a new series.  Returns the series id.\r\n     */\r\n    function createSeries(address creator, uint256 maxSupply, string calldata prefix) external returns(uint256);\r\n\r\n    /**\r\n     * @dev Get the latest series created.\r\n     */\r\n    function latestSeries(address creator) external view returns(uint256);\r\n\r\n    /**\r\n     * @dev Set the token uri prefix\r\n     */\r\n    function setTokenURIPrefix(address creator, uint256 series, string calldata prefix) external;\r\n    \r\n    /**\r\n     * @dev Mint NFTs to a single recipient\r\n     */\r\n    function mintGLFXfightingcancer(address creator, address recipient) external payable;\r\n\r\n    /**\r\n     * @dev Total supply of editions\r\n     */\r\n    function totalSupply(address creator, uint256 series) external view returns(uint256);\r\n\r\n    /**\r\n     * @dev Max supply of editions\r\n     */\r\n    function maxSupply(address creator, uint256 series) external view returns(uint256);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @manifoldxyz/creator-core-solidity/contracts/extensions/ICreatorExtensionTokenURI.sol\r\n/// @author: manifold.xyz\r\n\r\n/**\r\n * @dev Implement this if you want your extension to have overloadable URI's\r\n */\r\ninterface ICreatorExtensionTokenURI is IERC165 {\r\n\r\n    /**\r\n     * Get the uri for a given creator/tokenId\r\n     */\r\n    function tokenURI(address creator, uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File: @manifoldxyz/creator-core-solidity/contracts/extensions/CreatorExtension.sol\r\n/// @author: manifold.xyz\r\n/**\r\n * @dev Base creator extension variables\r\n */\r\nabstract contract CreatorExtension is ERC165 {\r\n\r\n    /**\r\n     * @dev Legacy extension interface identifiers\r\n     *\r\n     * {IERC165-supportsInterface} needs to return 'true' for this interface\r\n     * in order backwards compatible with older creator contracts\r\n     */\r\n    bytes4 constant internal LEGACY_EXTENSION_INTERFACE = 0x7005caad;\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165) returns (bool) {\r\n        return interfaceId == LEGACY_EXTENSION_INTERFACE\r\n            || super.supportsInterface(interfaceId);\r\n    }\r\n    \r\n}\r\n\r\n// File: @manifoldxyz/creator-core-solidity/contracts/core/ICreatorCore.sol\r\n/// @author: manifold.xyz\r\n/**\r\n * @dev Core creator interface\r\n */\r\ninterface ICreatorCore is IERC165 {\r\n\r\n    event ExtensionRegistered(address indexed extension, address indexed sender);\r\n    event ExtensionUnregistered(address indexed extension, address indexed sender);\r\n    event ExtensionBlacklisted(address indexed extension, address indexed sender);\r\n    event MintPermissionsUpdated(address indexed extension, address indexed permissions, address indexed sender);\r\n    event RoyaltiesUpdated(uint256 indexed tokenId, address payable[] receivers, uint256[] basisPoints);\r\n    event DefaultRoyaltiesUpdated(address payable[] receivers, uint256[] basisPoints);\r\n    event ExtensionRoyaltiesUpdated(address indexed extension, address payable[] receivers, uint256[] basisPoints);\r\n    event ExtensionApproveTransferUpdated(address indexed extension, bool enabled);\r\n\r\n    /**\r\n     * @dev gets address of all extensions\r\n     */\r\n    function getExtensions() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev add an extension.  Can only be called by contract owner or admin.\r\n     * extension address must point to a contract implementing ICreatorExtension.\r\n     * Returns True if newly added, False if already added.\r\n     */\r\n    function registerExtension(address extension, string calldata baseURI) external;\r\n\r\n    /**\r\n     * @dev add an extension.  Can only be called by contract owner or admin.\r\n     * extension address must point to a contract implementing ICreatorExtension.\r\n     * Returns True if newly added, False if already added.\r\n     */\r\n    function registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) external;\r\n\r\n    /**\r\n     * @dev add an extension.  Can only be called by contract owner or admin.\r\n     * Returns True if removed, False if already removed.\r\n     */\r\n    function unregisterExtension(address extension) external;\r\n\r\n    /**\r\n     * @dev blacklist an extension.  Can only be called by contract owner or admin.\r\n     * This function will destroy all ability to reference the metadata of any tokens created\r\n     * by the specified extension. It will also unregister the extension if needed.\r\n     * Returns True if removed, False if already removed.\r\n     */\r\n    function blacklistExtension(address extension) external;\r\n\r\n    /**\r\n     * @dev set the baseTokenURI of an extension.  Can only be called by extension.\r\n     */\r\n    function setBaseTokenURIExtension(string calldata uri) external;\r\n\r\n    /**\r\n     * @dev set the baseTokenURI of an extension.  Can only be called by extension.\r\n     * For tokens with no uri configured, tokenURI will return \"uri+tokenId\"\r\n     */\r\n    function setBaseTokenURIExtension(string calldata uri, bool identical) external;\r\n\r\n    /**\r\n     * @dev set the common prefix of an extension.  Can only be called by extension.\r\n     * If configured, and a token has a uri set, tokenURI will return \"prefixURI+tokenURI\"\r\n     * Useful if you want to use ipfs/arweave\r\n     */\r\n    function setTokenURIPrefixExtension(string calldata prefix) external;\r\n\r\n    /**\r\n     * @dev set the tokenURI of a token extension.  Can only be called by extension that minted token.\r\n     */\r\n    function setTokenURIExtension(uint256 tokenId, string calldata uri) external;\r\n\r\n    /**\r\n     * @dev set the tokenURI of a token extension for multiple tokens.  Can only be called by extension that minted token.\r\n     */\r\n    function setTokenURIExtension(uint256[] memory tokenId, string[] calldata uri) external;\r\n\r\n    /**\r\n     * @dev set the baseTokenURI for tokens with no extension.  Can only be called by owner/admin.\r\n     * For tokens with no uri configured, tokenURI will return \"uri+tokenId\"\r\n     */\r\n    function setBaseTokenURI(string calldata uri) external;\r\n\r\n    /**\r\n     * @dev set the common prefix for tokens with no extension.  Can only be called by owner/admin.\r\n     * If configured, and a token has a uri set, tokenURI will return \"prefixURI+tokenURI\"\r\n     * Useful if you want to use ipfs/arweave\r\n     */\r\n    function setTokenURIPrefix(string calldata prefix) external;\r\n\r\n    /**\r\n     * @dev set the tokenURI of a token with no extension.  Can only be called by owner/admin.\r\n     */\r\n    function setTokenURI(uint256 tokenId, string calldata uri) external;\r\n\r\n    /**\r\n     * @dev set the tokenURI of multiple tokens with no extension.  Can only be called by owner/admin.\r\n     */\r\n    function setTokenURI(uint256[] memory tokenIds, string[] calldata uris) external;\r\n\r\n    /**\r\n     * @dev set a permissions contract for an extension.  Used to control minting.\r\n     */\r\n    function setMintPermissions(address extension, address permissions) external;\r\n\r\n    /**\r\n     * @dev Configure so transfers of tokens created by the caller (must be extension) gets approval\r\n     * from the extension before transferring\r\n     */\r\n    function setApproveTransferExtension(bool enabled) external;\r\n\r\n    /**\r\n     * @dev get the extension of a given token\r\n     */\r\n    function tokenExtension(uint256 tokenId) external view returns (address);\r\n\r\n    /**\r\n     * @dev Set default royalties\r\n     */\r\n    function setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) external;\r\n\r\n    /**\r\n     * @dev Set royalties of a token\r\n     */\r\n    function setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) external;\r\n\r\n    /**\r\n     * @dev Set royalties of an extension\r\n     */\r\n    function setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) external;\r\n\r\n    /**\r\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\r\n     */\r\n    function getRoyalties(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\r\n    \r\n    // Royalty support for various other standards\r\n    function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory);\r\n    function getFeeBps(uint256 tokenId) external view returns (uint[] memory);\r\n    function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\r\n    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);\r\n\r\n}\r\n\r\n// File: @manifoldxyz/creator-core-solidity/contracts/core/IERC721CreatorCore.sol\r\n/// @author: manifold.xyz\r\n/**\r\n * @dev Core ERC721 creator interface\r\n */\r\ninterface IERC721CreatorCore is ICreatorCore {\r\n\r\n    /**\r\n     * @dev mint a token with no extension. Can only be called by an admin.\r\n     * Returns tokenId minted\r\n     */\r\n    function mintBase(address to) external returns (uint256);\r\n\r\n    /**\r\n     * @dev mint a token with no extension. Can only be called by an admin.\r\n     * Returns tokenId minted\r\n     */\r\n    function mintBase(address to, string calldata uri) external returns (uint256);\r\n\r\n    /**\r\n     * @dev batch mint a token with no extension. Can only be called by an admin.\r\n     * Returns tokenId minted\r\n     */\r\n    function mintBaseBatch(address to, uint16 count) external returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev batch mint a token with no extension. Can only be called by an admin.\r\n     * Returns tokenId minted\r\n     */\r\n    function mintBaseBatch(address to, string[] calldata uris) external returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev mint a token. Can only be called by a registered extension.\r\n     * Returns tokenId minted\r\n     */\r\n    function mintExtension(address to) external returns (uint256);\r\n\r\n    /**\r\n     * @dev mint a token. Can only be called by a registered extension.\r\n     * Returns tokenId minted\r\n     */\r\n    function mintExtension(address to, string calldata uri) external returns (uint256);\r\n\r\n    /**\r\n     * @dev batch mint a token. Can only be called by a registered extension.\r\n     * Returns tokenIds minted\r\n     */\r\n    function mintExtensionBatch(address to, uint16 count) external returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev batch mint a token. Can only be called by a registered extension.\r\n     * Returns tokenId minted\r\n     */\r\n    function mintExtensionBatch(address to, string[] calldata uris) external returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev burn a token. Can only be called by token owner or approved address.\r\n     * On burn, calls back to the registered extension's onBurn method\r\n     */\r\n    function burn(uint256 tokenId) external;\r\n\r\n}\r\n\r\n// File: @manifoldxyz/libraries-solidity/contracts/access/IAdminControl.sol\r\n/// @author: manifold.xyz\r\n/**\r\n * @dev Interface for admin control\r\n */\r\ninterface IAdminControl is IERC165 {\r\n\r\n    event AdminApproved(address indexed account, address indexed sender);\r\n    event AdminRevoked(address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev gets address of all admins\r\n     */\r\n    function getAdmins() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev add an admin.  Can only be called by contract owner.\r\n     */\r\n    function approveAdmin(address admin) external;\r\n\r\n    /**\r\n     * @dev remove an admin.  Can only be called by contract owner.\r\n     */\r\n    function revokeAdmin(address admin) external;\r\n\r\n    /**\r\n     * @dev checks whether or not given address is an admin\r\n     * Returns True if they are\r\n     */\r\n    function isAdmin(address admin) external view returns (bool);\r\n\r\n}\r\n\r\n// File: glfxFightingCancer.sol\r\n////////////////////////////////////////////////\r\n//                                            //\r\n//    \u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2591\u2591\u2588\u2591\u2591\u2588\u2591\u2584\u2580\u2580\u2584\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2580\u2591\u2591\u2588\u2580\u2584\u2591\u2588\u2580\u2580    //\r\n//    \u2591\u2592\u2588\u2591\u2584\u2584\u2591\u2588\u2591\u2591\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2588\u2580\u2580\u2588\u2591\u2591\u2588\u2580\u2591\u2588\u2591\u2591\u2591\u2580\u2580\u2584    //\r\n//    \u2591\u2592\u2588\u2584\u2584\u2580\u2591\u2580\u2580\u2591\u2584\u2584\u2584\u2580\u2591\u2588\u2591\u2591\u2591\u2591\u2580\u2591\u2591\u2580\u2591\u2580\u2580\u2580\u2591\u2580\u2580\u2580\u2591\u2580\u2580\u2580    //\r\n//              Special Edition:              //\r\n//              Fighting Cancer               //\r\n//           by rDan @ Glyphics.eth           //\r\n//////////////////////////////////////////////// \r\ncontract glfxFightingCancer is CreatorExtension, ICreatorExtensionTokenURI, IManifoldERC721Edition, Pausable, ReentrancyGuard {\r\n    using Strings for uint256;\r\n\r\n    struct IndexRange {\r\n        uint256 startIndex;\r\n        uint256 count;\r\n    }\r\n\r\n    uint256 public mintRate = 0.0333 ether;\r\n\r\n    mapping(address => mapping(uint256 => string)) _tokenPrefix;\r\n    mapping(address => mapping(uint256 => uint256)) _maxSupply;\r\n    mapping(address => mapping(uint256 => uint256)) _totalSupply;\r\n    mapping(address => mapping(uint256 => IndexRange[])) _indexRanges;\r\n    mapping(address => uint256) _currentSeries;\r\n    \r\n    /**\r\n     * @dev Only allows approved admins to call the specified function\r\n     */\r\n    modifier creatorAdminRequired(address creator) {\r\n        require(creator == 0x50a874E9333B8Bd0aE30aDBC2c91d10dDcc57B17,\"Contract not authorized.\");\r\n        require(IAdminControl(creator).isAdmin(msg.sender), \"Must be owner or admin of creator contract.\");\r\n        _;\r\n    }\r\n    \r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(CreatorExtension, IERC165) returns (bool) {\r\n        return interfaceId == type(ICreatorExtensionTokenURI).interfaceId || interfaceId == type(IManifoldERC721Edition).interfaceId ||\r\n               CreatorExtension.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IManifoldERC721Edition-totalSupply}.\r\n     */\r\n    function totalSupply(address creator, uint256 series) external view override returns(uint256) {\r\n        return _totalSupply[creator][series];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IManifoldERC721Edition-maxSupply}.\r\n     */\r\n    function maxSupply(address creator, uint256 series) external view override returns(uint256) {\r\n        return _maxSupply[creator][series];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IManifoldERC721Edition-createSeries}.\r\n     */\r\n    function createSeries(address creator, uint256 maxSupply_, string calldata prefix) external override creatorAdminRequired(creator) returns(uint256) {\r\n        _currentSeries[creator] += 1;\r\n        uint256 series = _currentSeries[creator];\r\n        _maxSupply[creator][series] = maxSupply_;\r\n        _tokenPrefix[creator][series] = prefix;\r\n        emit SeriesCreated(msg.sender, creator, series, maxSupply_);\r\n        return series;\r\n    }\r\n\r\n    function pause(address creator) public creatorAdminRequired(creator) {\r\n        _pause();\r\n    }\r\n    function pause() internal {\r\n        _pause();\r\n    }\r\n\r\n    function unpause(address creator) public creatorAdminRequired(creator) {\r\n        _unpause();\r\n    }\r\n    function unpause() internal {\r\n        _unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev See {IManifoldERC721Edition-latestSeries}.\r\n     */\r\n    function latestSeries(address creator) external view override returns(uint256) {\r\n        return _currentSeries[creator];\r\n    }\r\n\r\n    /**\r\n     * See {IManifoldERC721Edition-setTokenURIPrefix}.\r\n     */\r\n    function setTokenURIPrefix(address creator, uint256 series, string calldata prefix) external override creatorAdminRequired(creator) {\r\n        require(series > 0 && series <= 1, \"Invalid series\");\r\n        _tokenPrefix[creator][series] = prefix;\r\n    }\r\n    \r\n    /**\r\n     * @dev See {ICreatorExtensionTokenURI-tokenURI}.\r\n     */\r\n    function tokenURI(address creator, uint256 tokenId) external view override returns (string memory) {\r\n        (uint256 series, uint256 index) = _tokenSeriesAndIndex(creator, tokenId);\r\n        return string(abi.encodePacked(_tokenPrefix[creator][series], (index+1).toString(), \".json\"));\r\n    }\r\n    \r\n    /**\r\n     * @dev See {IManifoldERC721Edition-mint}.\r\n     */\r\n    function mintGLFXfightingcancer(address creator, address recipient) external whenNotPaused payable override nonReentrant {\r\n        require(msg.value >= mintRate, \"Sorry, not enough ether.\");\r\n        uint256 selectedSeries = 1;\r\n        uint256[] memory tokenIds = IERC721CreatorCore(creator).mintExtensionBatch(recipient, 1);\r\n        _updateIndexRanges(creator, selectedSeries, tokenIds[0], 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Update the index ranges, which is used to figure out the index from a tokenId\r\n     */\r\n    function _updateIndexRanges(address creator, uint256 series, uint256 startIndex, uint256 count) internal {\r\n        IndexRange[] storage indexRanges = _indexRanges[creator][series];\r\n        if (indexRanges.length == 0) {\r\n           indexRanges.push(IndexRange(startIndex, count));\r\n        } else {\r\n          IndexRange storage lastIndexRange = indexRanges[indexRanges.length-1];\r\n          if ((lastIndexRange.startIndex + lastIndexRange.count) == startIndex) {\r\n             lastIndexRange.count += count;\r\n          } else {\r\n            indexRanges.push(IndexRange(startIndex, count));\r\n          }\r\n        }\r\n        _totalSupply[creator][series] += count;\r\n    }\r\n\r\n    /**\r\n     * @dev Index from tokenId\r\n     */\r\n    function _tokenSeriesAndIndex(address creator, uint256 tokenId) internal view returns(uint256, uint256) {\r\n        require(_currentSeries[creator] > 0, \"Invalid token\");\r\n        for (uint series=1; series <= _currentSeries[creator]; series++) {\r\n            IndexRange[] memory indexRanges = _indexRanges[creator][series];\r\n            uint256 offset;\r\n            for (uint i = 0; i < indexRanges.length; i++) {\r\n                IndexRange memory currentIndex = indexRanges[i];\r\n                if (tokenId < currentIndex.startIndex) break;\r\n                if (tokenId >= currentIndex.startIndex && tokenId < currentIndex.startIndex + currentIndex.count) {\r\n                   return (series, tokenId - currentIndex.startIndex + offset);\r\n                }\r\n                offset += currentIndex.count;\r\n            }\r\n        }\r\n        revert(\"Invalid token\");\r\n    }\r\n    \r\n    function withdraw(address creator) public creatorAdminRequired(creator){\r\n        require(address(this).balance > 0, \"Balance is 0\");\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"series\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"}],\"name\":\"SeriesCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"prefix\",\"type\":\"string\"}],\"name\":\"createSeries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"latestSeries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"series\",\"type\":\"uint256\"}],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mintGLFXfightingcancer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"series\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"prefix\",\"type\":\"string\"}],\"name\":\"setTokenURIPrefix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"series\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "glfxFightingCancer", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bf20297adaed2e928253057e84d621900fbed3b51a9627f3151be7a43ef3fb7c"}]}