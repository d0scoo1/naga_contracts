{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\npragma abicoder v2;\r\n\r\n\r\ncontract DeadPool {\r\n\r\n\r\n    /* Types */\r\n\r\n    enum eventStatus{open, finished, closed}\r\n    enum bidStatus{open, closed}\r\n\r\n    struct bid {\r\n        uint id;\r\n        uint256 name;\r\n        address[] whoBet;\r\n        uint amountReceived;\r\n        bidStatus status;\r\n    }\r\n\r\n    struct betEvent {\r\n        uint id;\r\n        bytes32 name;\r\n        address creator;\r\n        address arbitrator;\r\n        uint256 winner;\r\n        uint arbitratorFee;\r\n        uint minBid; // value in wei\r\n        uint maxBid; // value in wei\r\n        bid[] bids;\r\n        bet[] bets;\r\n        eventStatus status;\r\n    }\r\n\r\n    struct bet {\r\n        address person;\r\n        uint256 bidName;\r\n        uint amount;\r\n        uint256 timestamp;\r\n    }\r\n\r\n\r\n    /* Storage */\r\n\r\n    address public owner;\r\n\r\n    mapping(address => betEvent[]) public betEvents;\r\n    mapping(address => uint) public pendingWithdrawals;\r\n\r\n\r\n    /* Events */\r\n\r\n    //    event eventCreated(uint id, address creator);\r\n    //    event betMade(uint value, uint id);\r\n    //    event eventStatusChanged(uint status);\r\n    //    event withdrawalDone(uint amount);\r\n\r\n\r\n    /* Modifiers */\r\n\r\n    modifier onlyOwner(){\r\n        if (msg.sender == owner) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyOpen(address creator, uint eventId){\r\n        if (betEvents[creator][eventId].status == eventStatus.open) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyFinished(address creator, uint eventId){\r\n        if (betEvents[creator][eventId].status == eventStatus.finished) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyArbitrator(address creator, uint eventId){\r\n        if (msg.sender == betEvents[creator][eventId].arbitrator) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyOpenAndArbitrator(address creator, uint eventId){\r\n        if (betEvents[creator][eventId].status == eventStatus.open && msg.sender == betEvents[creator][eventId].arbitrator) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyFinishedAndArbitrator(address creator, uint eventId){\r\n        if (betEvents[creator][eventId].status == eventStatus.finished && msg.sender == betEvents[creator][eventId].arbitrator) {\r\n            _;\r\n        }\r\n    }\r\n\r\n\r\n    /* Methods */\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    fallback() external payable {\r\n        // custom function code\r\n    }\r\n\r\n    receive() external payable {\r\n        // custom function code\r\n    }\r\n\r\n    bid public newBid;\r\n    betEvent public newEvent;\r\n    bet public newBet;\r\n\r\n    function createEvent(address arbitrator, bytes32 name, uint fee, uint minBid, uint maxBid) external\r\n    onlyOwner {\r\n        require(fee < 100, \"Fee must be lower than 100.\");\r\n        /* check whether event with such name already exist */\r\n        bool found = false;\r\n        for (uint x = 0; x < betEvents[msg.sender].length; x++) {\r\n            if (betEvents[msg.sender][x].name == name) {\r\n                found = true;\r\n            }\r\n        }\r\n        require(!found, \"Event with same name already exists.\");\r\n        uint newId = betEvents[msg.sender].length;\r\n        newEvent.id = newId;\r\n        newEvent.name = name;\r\n        newEvent.arbitrator = arbitrator;\r\n        newEvent.status = eventStatus.open;\r\n        newEvent.creator = msg.sender;\r\n        newEvent.minBid = minBid;\r\n        newEvent.maxBid = maxBid;\r\n        newEvent.arbitratorFee = fee;\r\n        betEvents[msg.sender].push(newEvent);\r\n        //        emit eventCreated(newId, msg.sender);\r\n    }\r\n\r\n    function finishEvent(address creator, uint eventId) external\r\n    onlyOpenAndArbitrator(creator, eventId) {\r\n        betEvents[creator][eventId].status = eventStatus.finished;\r\n        //        emit eventStatusChanged(1);\r\n    }\r\n\r\n    function _addBid(address creator, uint eventId, uint256 bidName) private\r\n    onlyOpen(creator, eventId) {\r\n        uint newBidId = 0;\r\n        bool found = findBid(creator, eventId, bidName);\r\n        if (!found) {\r\n            newBidId = betEvents[creator][eventId].bids.length;\r\n            newBid.id = newBidId;\r\n            newBid.name = bidName;\r\n            newBid.status = bidStatus.open;\r\n            betEvents[creator][eventId].bids.push(newBid);\r\n        }\r\n    }\r\n\r\n    function addBid(address creator, uint eventId, uint256 bidName) external\r\n    onlyOpen(creator, eventId) {\r\n        _addBid(creator, eventId, bidName);\r\n    }\r\n\r\n    function addBids(address creator, uint eventId, uint256[] calldata bidNames) external\r\n    onlyOpen(creator, eventId) {\r\n        for (uint i = 0; i < bidNames.length; i++) {\r\n            _addBid(creator, eventId, bidNames[i]);\r\n        }\r\n    }\r\n\r\n    function _closeBid(address creator, uint eventId, uint256 bidName) private\r\n    onlyOpenAndArbitrator(creator, eventId) {\r\n        for (uint i = 0; i < betEvents[creator][eventId].bids.length; i++) {\r\n            if (betEvents[creator][eventId].bids[i].name == bidName) {\r\n                betEvents[creator][eventId].bids[i].status = bidStatus.closed;\r\n            }\r\n        }\r\n    }\r\n\r\n    function closeBid(address creator, uint eventId, uint256 bidName) external\r\n    onlyOpenAndArbitrator(creator, eventId) {\r\n        _closeBid(creator, eventId, bidName);\r\n    }\r\n\r\n    function closeBids(address creator, uint eventId, uint256[] calldata bidNames) external\r\n    onlyOpenAndArbitrator(creator, eventId) {\r\n        for (uint i = 0; i < bidNames.length; i++) {\r\n            _closeBid(creator, eventId, bidNames[i]);\r\n        }\r\n    }\r\n\r\n    // function openBid(address creator, uint eventId, bytes32 bidName) external\r\n    // onlyOpen(creator, eventId) onlyArbitrator(creator, eventId) {\r\n    //     for (uint i = 0; i < betEvents[creator][eventId].bids.length; i++) {\r\n    //         if (betEvents[creator][eventId].bids[i].name == bidName) {\r\n    //             betEvents[creator][eventId].bids[i].status = bidStatus.open;\r\n    //         }\r\n    //     }\r\n    // }\r\n\r\n    function makeBet(address creator, uint eventId, uint256 bidName) public payable\r\n    onlyOpen(creator, eventId) {\r\n        uint256 minDate = (block.timestamp / (60 * 60 * 24) + 1) * (60 * 60 * 24);\r\n        require(bidName >= minDate, \"Bid must be more than today.\");\r\n        /* check whether bid with given name actually exists */\r\n        bool found = findBid(creator, eventId, bidName);\r\n        if (!found) {\r\n            this.addBid(creator, eventId, bidName);\r\n        }\r\n        for (uint i = 0; i < betEvents[creator][eventId].bids.length; i++) {\r\n            if (betEvents[creator][eventId].bids[i].name == bidName) {\r\n                bid storage foundBid = betEvents[creator][eventId].bids[i];\r\n                found = true;\r\n                require(foundBid.status == bidStatus.open, \"Bid is closed.\");\r\n                //check for minimal amount\r\n                if (betEvents[creator][eventId].minBid > 0) {\r\n                    require(msg.value >= betEvents[creator][eventId].minBid, \"Min amount error.\");\r\n                }\r\n                //check for maximal amount\r\n                if (betEvents[creator][eventId].maxBid > 0) {\r\n                    require(msg.value <= betEvents[creator][eventId].maxBid, \"Max amount error.\");\r\n                }\r\n                foundBid.whoBet.push(msg.sender);\r\n                foundBid.amountReceived += msg.value;\r\n                newBet.person = msg.sender;\r\n                newBet.amount = msg.value;\r\n                newBet.bidName = bidName;\r\n                newBet.timestamp = block.timestamp;\r\n                betEvents[creator][eventId].bets.push(newBet);\r\n                //                emit betMade(msg.value, newBetId);\r\n            }\r\n\r\n        }\r\n        require(found, \"Bid not found.\");\r\n    }\r\n\r\n    function determineWinner(address creator, uint eventId, uint256 bidName) external\r\n    onlyFinishedAndArbitrator(creator, eventId) {\r\n        require(findBid(creator, eventId, bidName));\r\n        betEvent storage cEvent = betEvents[creator][eventId];\r\n        cEvent.winner = bidName;\r\n        uint amountLost;\r\n        uint amountWon;\r\n        uint lostBetsLen;\r\n        /* Calculating amount of all won and lost bets */\r\n        for (uint x = 0; x < cEvent.bets.length; x++) {\r\n            uint betAmount = cEvent.bets[x].amount;\r\n            if (cEvent.bets[x].bidName == cEvent.winner) {\r\n                amountWon += betAmount;\r\n                pendingWithdrawals[cEvent.bets[x].person] += betAmount;\r\n            } else {\r\n                lostBetsLen++;\r\n                amountLost += betAmount;\r\n            }\r\n        }\r\n        uint arbitratorAmount = amountLost / 100 * cEvent.arbitratorFee;\r\n        pendingWithdrawals[cEvent.arbitrator] += arbitratorAmount;\r\n        amountLost -= arbitratorAmount;\r\n        /* If we do have win bets */\r\n        if (amountWon > 0) {\r\n            for (uint x = 0; x < cEvent.bets.length; x++) {\r\n                if (cEvent.bets[x].bidName == cEvent.winner) {\r\n                    uint wonBetPercentage = percent(cEvent.bets[x].amount, amountWon, 2);\r\n                    pendingWithdrawals[cEvent.bets[x].person] += (amountLost / 100) * wonBetPercentage;\r\n                }\r\n            }\r\n        } else {\r\n            /* If we don't have any bets won, we pay all the funds back except arbitrator fee */\r\n            for (uint x = 0; x < cEvent.bets.length; x++) {\r\n                pendingWithdrawals[cEvent.bets[x].person] += cEvent.bets[x].amount - ((cEvent.bets[x].amount / 100) * cEvent.arbitratorFee);\r\n            }\r\n        }\r\n        cEvent.status = eventStatus.closed;\r\n        //        emit eventStatusChanged(2);\r\n    }\r\n\r\n    function withdraw(address payable person) private {\r\n        uint amount = pendingWithdrawals[person];\r\n        pendingWithdrawals[person] = 0;\r\n        person.transfer(amount);\r\n        //        emit withdrawalDone(amount);\r\n    }\r\n\r\n    function requestWithdraw() external {\r\n        require(pendingWithdrawals[msg.sender] != 0, \"No withdrawal available.\");\r\n        withdraw(payable(msg.sender));\r\n    }\r\n\r\n    function findBid(address creator, uint eventId, uint256 bidName) private view returns (bool){\r\n        for (uint i = 0; i < betEvents[creator][eventId].bids.length; i++) {\r\n            if (betEvents[creator][eventId].bids[i].name == bidName) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function percent(uint numerator, uint denominator, uint precision) public pure returns (uint quotient) {\r\n        // caution, check safe-to-multiply here\r\n        uint _numerator = numerator * 10 ** (precision + 1);\r\n        // with rounding of last digit\r\n        uint _quotient = ((_numerator / denominator) + 5) / 10;\r\n        return (_quotient);\r\n    }\r\n\r\n    function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\r\n        uint8 i = 0;\r\n        while (i < 32 && _bytes32[i] != 0) {\r\n            i++;\r\n        }\r\n        bytes memory bytesArray = new bytes(i);\r\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\r\n            bytesArray[i] = _bytes32[i];\r\n        }\r\n        return string(bytesArray);\r\n    }\r\n\r\n\r\n    /* Getters */\r\n\r\n    function getBetEvents(address creator) external view returns (betEvent[] memory){\r\n        return betEvents[creator];\r\n    }\r\n    //\r\n    //    function getBetEvent(address creator, uint eventId) external view returns (betEvent memory){\r\n    //        return betEvents[creator][eventId];\r\n    //    }\r\n    //\r\n    //    function getBidsNum(address creator, uint eventId) external view returns (uint){\r\n    //        return betEvents[creator][eventId].bids.length;\r\n    //    }\r\n    //\r\n    function getBids(address creator, uint eventId) external view returns (bid[] memory){\r\n        return betEvents[creator][eventId].bids;\r\n    }\r\n    //\r\n    //    function getBid(address creator, uint eventId, uint bidId) external view returns (uint, bytes32, uint){\r\n    //        bid storage foundBid = betEvents[creator][eventId].bids[bidId];\r\n    //        return (foundBid.id, foundBid.name, foundBid.amountReceived);\r\n    //    }\r\n    //\r\n    //    function getBetsNums(address creator, uint eventId) external view returns (uint){\r\n    //        return betEvents[creator][eventId].bets.length;\r\n    //    }\r\n    //\r\n    //    function getWhoBet(address creator, uint eventId, uint bidId) external view returns (address[] memory){\r\n    //        return betEvents[creator][eventId].bids[bidId].whoBet;\r\n    //    }\r\n    //\r\n    function getBets(address creator, uint eventId) external view returns (bet[] memory){\r\n        return betEvents[creator][eventId].bets;\r\n    }\r\n    //\r\n    //    function getBet(address creator, uint eventId, uint betId) external view returns (address, bytes32, uint){\r\n    //        bet storage foundBet = betEvents[creator][eventId].bets[betId];\r\n    //        return (foundBet.person, foundBet.bidName, foundBet.amount);\r\n    //    }\r\n    //\r\n    //    function getEventId(address creator, bytes32 eventName) external view returns (uint, bool){\r\n    //        for (uint i = 0; i < betEvents[creator].length; i++) {\r\n    //            if (betEvents[creator][i].name == eventName) {\r\n    //                return (betEvents[creator][i].id, true);\r\n    //            }\r\n    //        }\r\n    //        return (0, false);\r\n    //    }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidName\",\"type\":\"uint256\"}],\"name\":\"addBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"bidNames\",\"type\":\"uint256[]\"}],\"name\":\"addBids\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betEvents\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"winner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arbitratorFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBid\",\"type\":\"uint256\"},{\"internalType\":\"enum DeadPool.eventStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_bytes32\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidName\",\"type\":\"uint256\"}],\"name\":\"closeBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"bidNames\",\"type\":\"uint256[]\"}],\"name\":\"closeBids\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBid\",\"type\":\"uint256\"}],\"name\":\"createEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidName\",\"type\":\"uint256\"}],\"name\":\"determineWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"}],\"name\":\"finishEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"getBetEvents\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"winner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arbitratorFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBid\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"name\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"whoBet\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"},{\"internalType\":\"enum DeadPool.bidStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct DeadPool.bid[]\",\"name\":\"bids\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"person\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bidName\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct DeadPool.bet[]\",\"name\":\"bets\",\"type\":\"tuple[]\"},{\"internalType\":\"enum DeadPool.eventStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct DeadPool.betEvent[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"}],\"name\":\"getBets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"person\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bidName\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct DeadPool.bet[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"}],\"name\":\"getBids\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"name\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"whoBet\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"},{\"internalType\":\"enum DeadPool.bidStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct DeadPool.bid[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidName\",\"type\":\"uint256\"}],\"name\":\"makeBet\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newBet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"person\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bidName\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newBid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"name\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"},{\"internalType\":\"enum DeadPool.bidStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newEvent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"winner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arbitratorFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBid\",\"type\":\"uint256\"},{\"internalType\":\"enum DeadPool.eventStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingWithdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"precision\",\"type\":\"uint256\"}],\"name\":\"percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quotient\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DeadPool", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://299125e14020b22c5ef41740b84da7cf32f8760c1115aca55272e54bc476601c"}]}