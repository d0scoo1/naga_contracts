{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/v8/Market.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./access/TwoStageOwnable.sol\\\";\\nimport \\\"./utils/StringUtils.sol\\\";\\nimport \\\"./interfaces/INFT.sol\\\";\\nimport \\\"./interfaces/IMarket.sol\\\";\\n\\ncontract NFTMarket is IMarket, ReentrancyGuard, TwoStageOwnable, ChainlinkClient {\\n    using Chainlink for Chainlink.Request;\\n    using StringUtils for string;\\n\\n    uint256 constant HUNDRED_PERCENT = 10000;\\n    address constant ZERO_ADDRESS = address(0);\\n\\n    uint256 private _itemIds;\\n    uint256 private _feeOracle;\\n    uint256 private _lastItemId;\\n    address private _nupayWalletAddress;\\n    address private _operator;\\n    address private _oracle;\\n    bytes32 private _jobId;\\n    string private _urlRequest;\\n    bool private _initialized;\\n    bool private _stopped;\\n    IMarket private _fromMarket;\\n    IMarket private _toMarket;\\n    IERC20 private _linkToken;\\n    INFT private _nftContract;\\n\\n    mapping(uint256 => MarketItem) private _idToMarketItem;\\n    // idToken => idMarketItems[]\\n    mapping(uint256 => uint256[]) private _idTokenToIdMarketItems;\\n    // Request id => Market item id\\n    mapping(bytes32 => uint256) private _reqIds;\\n    // TokenId => MarketId\\n    mapping(uint256 => uint256) private _idTokenToMarket;\\n\\n    function bytes32ToString(bytes32 _bytes32) private pure returns (string memory) {\\n        uint8 i = 0;\\n        while (i < 32 && _bytes32[i] != 0) {\\n            i++;\\n        }\\n        bytes memory bytesArray = new bytes(i);\\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\\n            bytesArray[i] = _bytes32[i];\\n        }\\n        return string(bytesArray);\\n    }\\n\\n    function fetchAllMarketItems(uint256 skip, uint256 limit) external view returns (MarketItem[] memory marketItems) {\\n        if (skip > _itemIds) return marketItems;\\n        uint256 to = skip + limit;\\n        if (_itemIds < to) to = _itemIds;\\n        uint256 length = to - skip;\\n        marketItems = new MarketItem[](length);\\n        MarketItem[] memory previousMarketItems;\\n        if (_lastItemId > 0 && skip <= _lastItemId) {\\n            previousMarketItems = _fromMarket.fetchAllMarketItems(skip, limit);\\n        }\\n        uint256 previousLength = previousMarketItems.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            marketItems[i] = i < previousLength ? previousMarketItems[i] : _idToMarketItem[skip + i + 1];\\n        }\\n    }\\n\\n    function fetchMarketItemsByTokenId(\\n        uint256 tokenId,\\n        uint256 skip,\\n        uint256 limit\\n    ) external view returns (MarketItem[] memory marketItems) {\\n        uint256[] memory marketItemsByTokenId = _idTokenToIdMarketItems[tokenId];\\n        uint256 marketItemsLength = marketItemsByTokenIdLength(tokenId);\\n        if (skip >= marketItemsLength) return marketItems;\\n        uint256 to = skip + limit;\\n        if (marketItemsLength < to) to = marketItemsLength;\\n        uint256 length = to - skip;\\n        marketItems = new MarketItem[](length);\\n        MarketItem[] memory previousMarketItems;\\n        if (_lastItemId > 0 && skip <= _lastItemId) {\\n            previousMarketItems = _fromMarket.fetchMarketItemsByTokenId(tokenId, skip, limit);\\n        }\\n        uint256 previousLength = previousMarketItems.length;\\n        uint256 pad = 0;\\n        for (uint256 i = 0; i < length; i++) {\\n            if (i < previousLength) {\\n                marketItems[i] = previousMarketItems[i];\\n                pad = i + 1;\\n            } else {\\n                marketItems[i] = _idToMarketItem[marketItemsByTokenId[i - pad]];\\n            }\\n        }\\n    }\\n\\n    function fetchSpecificMarketItem(uint256 itemId) public view returns (MarketItem memory marketItem) {\\n        marketItem = (_lastItemId > 0 && itemId <= _lastItemId)\\n            ? _fromMarket.fetchSpecificMarketItem(itemId)\\n            : _idToMarketItem[itemId];\\n    }\\n\\n    function feeOracle() external view returns (uint256) {\\n        return _feeOracle;\\n    }\\n\\n    function fromMarket() external view returns (address) {\\n        return address(_fromMarket);\\n    }\\n\\n    function toMarket() external view override returns (address) {\\n        return address(_toMarket);\\n    }\\n\\n    function initialized() external view returns (bool) {\\n        return _initialized;\\n    }\\n\\n    function idTokenToMarket(uint256 tokenId) public view returns (uint256 itemId) {\\n        itemId = (_idTokenToMarket[tokenId] == 0 && _lastItemId > 0)\\n            ? _fromMarket.idTokenToMarket(tokenId)\\n            : _idTokenToMarket[tokenId];\\n    }\\n\\n    function itemIds() external view returns (uint256) {\\n        return _itemIds;\\n    }\\n\\n    function lastItemId() external view returns (uint256) {\\n        return _lastItemId;\\n    }\\n\\n    function linkToken() external view returns (address) {\\n        return address(_linkToken);\\n    }\\n\\n    function marketItemsByTokenIdLength(uint256 tokenId) public view returns (uint256 length) {\\n        if (address(_fromMarket) != ZERO_ADDRESS) {\\n            length = _fromMarket.marketItemsByTokenIdLength(tokenId);\\n        }\\n        length += _idTokenToIdMarketItems[tokenId].length;\\n    }\\n\\n    function nftContract() external view returns (address) {\\n        return address(_nftContract);\\n    }\\n\\n    function nupayWalletAddress() external view returns (address) {\\n        return _nupayWalletAddress;\\n    }\\n\\n    function operator() external view returns (address) {\\n        return _operator;\\n    }\\n\\n    function oracle() external view returns (address, bytes32) {\\n        return (_oracle, _jobId);\\n    }\\n\\n    function reqIds(bytes32 reqId) external view returns (uint256) {\\n        return _reqIds[reqId];\\n    }\\n\\n    function stopped() external view returns (bool) {\\n        return _stopped;\\n    }\\n\\n    function urlRequest() external view returns (string memory) {\\n        return _urlRequest;\\n    }\\n\\n    event Received(address sender, uint256 value);\\n    event AssetsDistributed(uint256 itemId);\\n    event AssetsForciblyDistributed(uint256 itemId);\\n    event DealResolved(uint256 itemId);\\n    event DealRejected(uint256 itemId);\\n    event Initialized(address market);\\n    event MarketItemCreated(address indexed seller, uint256 itemId, uint256 tokenId, uint256 price);\\n    event MarketSaleCreated(address indexed buyer, uint256 itemId);\\n    event Migrated(address market);\\n    event FeeSetted(uint256 fee);\\n    event NftContractSetted(address nftContract);\\n    event NupayWalletSetted(address nupayWallet);\\n    event OracleSetted(address oracleContract, bytes32 jobId);\\n    event MarketItemSaved(MarketItem item);\\n    event UrlRequestSetted(string url);\\n    event TokenIdToMarketSetted(uint256 tokenId, uint256 itemId, bool remove);\\n    event OperatorSetted(address operator);\\n\\n    constructor(\\n        address owner_,\\n        string memory urlRequest_,\\n        address linkToken_,\\n        address nupayWalletAddress_,\\n        address operator_,\\n        address oracle_,\\n        bytes32 jobId_,\\n        uint256 feeOracle_\\n    ) TwoStageOwnable(owner_) {\\n        require(owner_ != ZERO_ADDRESS, \\\"Owner is zero address\\\");\\n        require(linkToken_ != ZERO_ADDRESS, \\\"Link token is zero address\\\");\\n        require(nupayWalletAddress_ != ZERO_ADDRESS, \\\"Nupay wallet is zero address\\\");\\n        require(operator_ != ZERO_ADDRESS, \\\"Operator is zero address\\\");\\n        require(oracle_ != ZERO_ADDRESS, \\\"Oracle is zero address\\\");\\n        setChainlinkToken(linkToken_);\\n        _linkToken = IERC20(linkToken_);\\n        _urlRequest = urlRequest_;\\n        _nupayWalletAddress = nupayWalletAddress_;\\n        _operator = operator_;\\n        _oracle = oracle_;\\n        _jobId = jobId_;\\n        _feeOracle = feeOracle_;\\n    }\\n\\n    receive() external payable {\\n        emit Received(msg.sender, msg.value);\\n    }\\n\\n    function createMarketItem(uint256 tokenId, uint256 price) external whenNotStopped returns (bool) {\\n        require(_initialized, \\\"Not initialized\\\");\\n        _itemIds++;\\n        address seller = msg.sender;\\n        require(seller == _nftContract.ownerOf(tokenId), \\\"Seller not owner tokenId\\\");\\n        require(idTokenToMarket(tokenId) == 0, \\\"Order with this tokenId exists\\\");\\n        MarketItem storage marketItem = _idToMarketItem[_itemIds];\\n        marketItem.itemId = _itemIds;\\n        marketItem.tokenId = tokenId;\\n        marketItem.seller = payable(seller);\\n        marketItem.price = price;\\n        _idTokenToIdMarketItems[tokenId].push(_itemIds);\\n        _setTokenIdToMarket(tokenId, _itemIds, false);\\n        emit MarketItemCreated(seller, _itemIds, tokenId, price);\\n        return true;\\n    }\\n\\n    function createMarketSale(uint256 itemId) external payable whenNotStopped nonReentrant returns (bool) {\\n        require(itemId > 0 && itemId <= _itemIds, \\\"Market item not exist\\\");\\n        MarketItem memory item = fetchSpecificMarketItem(itemId);\\n        address caller = msg.sender;\\n        require(caller != item.seller, \\\"Caller is seller\\\");\\n        require(msg.value == item.price, \\\"Insufficient amount\\\");\\n        require(!item.sold, \\\"Item already paid\\\");\\n        item.owner = payable(caller);\\n        item.sold = true;\\n        _saveMarketItem(item);\\n        emit MarketSaleCreated(caller, itemId);\\n        return true;\\n    }\\n\\n    function forceDistributeAssets(\\n        uint256 itemId,\\n        uint256 comission,\\n        uint256 shareMinter,\\n        bool isPremium\\n    ) external onlyOperator whenNotStopped returns (bool) {\\n        require(itemId > 0 && itemId <= _itemIds, \\\"Market item not exist\\\");\\n        MarketItem memory item = fetchSpecificMarketItem(itemId);\\n        require(item.isResolved, \\\"Payment not resolved\\\");\\n        require(!item.isRejected, \\\"Payment has been rejected\\\");\\n        item.commission = comission;\\n        item.isPremium = isPremium;\\n        _saveMarketItem(item);\\n        _setTokenIdToMarket(item.tokenId, itemId, true);\\n        _distributeAssets(itemId, shareMinter);\\n        emit AssetsForciblyDistributed(itemId);\\n        return true;\\n    }\\n\\n    function initialize(address market) external whenNotStopped onlyOwner returns (bool) {\\n        require(!_initialized, \\\"Already initialized\\\");\\n        if (market == ZERO_ADDRESS) {\\n            _initialized = true;\\n            return true;\\n        }\\n        IMarket marketContract = IMarket(market);\\n        require(address(marketContract.toMarket()) == address(this), \\\"Migration not for this contract\\\");\\n        _fromMarket = marketContract;\\n        _itemIds = marketContract.itemIds();\\n        _lastItemId = _itemIds;\\n        _nftContract.unpause();\\n        _initialized = true;\\n        emit Initialized(market);\\n        return _initialized;\\n    }\\n\\n    function migrateTo(address market) external onlyOwner returns (bool) {\\n        address this_ = address(this);\\n        require(market != ZERO_ADDRESS, \\\"Market is zero address\\\");\\n        require(address(_toMarket) == ZERO_ADDRESS, \\\"Contract already migrated\\\");\\n        _stopped = true;\\n        _nftContract.pause();\\n        _nftContract.setMarket(market);\\n        uint256 balanceLinkToken = _linkToken.balanceOf(this_);\\n        if (this_.balance > 0) payable(market).transfer(this_.balance);\\n        if (balanceLinkToken > 0) _linkToken.transfer(market, balanceLinkToken);\\n        _toMarket = IMarket(market);\\n        emit Migrated(market);\\n        return true;\\n    }\\n\\n    function rejectDeal(uint256 itemId, uint256 fee) external onlyOperator whenNotStopped nonReentrant returns (bool) {\\n        require(_itemIds >= itemId, \\\"Market item not exist\\\");\\n        MarketItem memory item = fetchSpecificMarketItem(itemId);\\n        uint256 price = item.price;\\n        require(!item.isResolved, \\\"Payment has been resolved\\\");\\n        require(!item.isRejected, \\\"Payment has been rejected\\\");\\n        require(!item.isDistributeAssets, \\\"Payment has been distributed\\\");\\n        require(price > fee, \\\"Too large fee\\\");\\n        if (!item.sold) {\\n            item.isRejected = true;\\n            _saveMarketItem(item);\\n            _setTokenIdToMarket(item.tokenId, itemId, true);\\n            emit DealRejected(itemId);\\n            return true;\\n        }\\n        uint256 refundValue = price - fee;\\n        item.owner.transfer(refundValue);\\n        payable(_nupayWalletAddress).transfer(fee);\\n        item.owner = payable(ZERO_ADDRESS);\\n        item.isRejected = true;\\n        _saveMarketItem(item);\\n        _setTokenIdToMarket(item.tokenId, itemId, true);\\n        emit DealRejected(itemId);\\n        return true;\\n    }\\n\\n    function resolveDeal(\\n        uint256 tokenId,\\n        address sender,\\n        address recipient\\n    ) external whenNotStopped returns (bool) {\\n        require(msg.sender == address(_nftContract), \\\"Invalid sender\\\");\\n        uint256 itemId = idTokenToMarket(tokenId);\\n        MarketItem memory item = fetchSpecificMarketItem(itemId);\\n        if (itemId == 0 || item.seller != sender) return true;\\n        if (item.seller == sender && item.owner != recipient) return false;\\n        require(!item.isResolved, \\\"Payment has been resolved\\\");\\n        _doRequest(_urlRequest.concatStrUint(tokenId), itemId);\\n        item.isResolved = true;\\n        _saveMarketItem(item);\\n        emit DealResolved(itemId);\\n        return true;\\n    }\\n\\n    function setFeeOracle(uint256 fee) external onlyOperator returns (bool) {\\n        _feeOracle = fee;\\n        emit FeeSetted(fee);\\n        return true;\\n    }\\n\\n    function setNftContract(address nft) external onlyOperator returns (bool) {\\n        require(nft != ZERO_ADDRESS, \\\"Contract is zero address\\\");\\n        _nftContract = INFT(nft);\\n        emit NftContractSetted(nft);\\n        return true;\\n    }\\n\\n    function setNupayWalletAddress(address nupayWallet) external onlyOperator returns (bool) {\\n        require(nupayWallet != ZERO_ADDRESS, \\\"Wallet is zero address\\\");\\n        _nupayWalletAddress = nupayWallet;\\n        emit NupayWalletSetted(nupayWallet);\\n        return true;\\n    }\\n\\n    function setOperator(address newOperator) external onlyOwner returns (bool) {\\n        require(newOperator != ZERO_ADDRESS, \\\"Operator is zero address\\\");\\n        _operator = newOperator;\\n        emit OperatorSetted(newOperator);\\n        return true;\\n    }\\n\\n    function setOracle(address oracleContract, bytes32 jobId) external onlyOperator returns (bool) {\\n        require(oracleContract != ZERO_ADDRESS, \\\"Oracle is zero address\\\");\\n        _oracle = oracleContract;\\n        _jobId = jobId;\\n        emit OracleSetted(oracleContract, jobId);\\n        return true;\\n    }\\n\\n    function setUrlRequest(string memory url) external onlyOperator returns (bool) {\\n        _urlRequest = url;\\n        emit UrlRequestSetted(url);\\n        return true;\\n    }\\n\\n    function saveMarketItem(MarketItem memory item) external returns (bool) {\\n        require(msg.sender == address(_toMarket), \\\"Invalid sender\\\");\\n        _saveMarketItem(item);\\n        emit MarketItemSaved(item);\\n        return true;\\n    }\\n\\n    function setTokenIdToMarket(\\n        uint256 tokenId,\\n        uint256 itemId,\\n        bool remove\\n    ) external returns (bool) {\\n        require(msg.sender == address(_toMarket), \\\"Invalid sender\\\");\\n        _setTokenIdToMarket(tokenId, itemId, remove);\\n        emit TokenIdToMarketSetted(tokenId, itemId, remove);\\n        return true;\\n    }\\n\\n    function fulfill(bytes32 requestId, bytes32 commission)\\n        public\\n        whenNotStopped\\n        recordChainlinkFulfillment(requestId)\\n    {\\n        uint256 itemId = _reqIds[requestId];\\n        MarketItem memory item = fetchSpecificMarketItem(itemId);\\n        require(_itemIds >= itemId, \\\"Market item not exist\\\");\\n        require(!item.isRejected, \\\"Payment has been rejected\\\");\\n        string[] memory splitArr = bytes32ToString(commission).split(\\\"|\\\");\\n        uint256 minterShare = splitArr[2].st2num();\\n        item.commission = splitArr[0].st2num();\\n        if (splitArr[1].compareTo(\\\"premium\\\")) {\\n            item.isPremium = true;\\n        } else {\\n            item.isPremium = false;\\n        }\\n        _saveMarketItem(item);\\n        _distributeAssets(itemId, minterShare);\\n    }\\n\\n    function _distributeAssets(uint256 itemId, uint256 feeMinter) private nonReentrant {\\n        MarketItem memory item = fetchSpecificMarketItem(itemId);\\n        require(!item.isDistributeAssets, \\\"Assets already allocated\\\");\\n        require(feeMinter < HUNDRED_PERCENT, \\\"Fee exceeded\\\");\\n        require(item.commission < HUNDRED_PERCENT, \\\"Fee exceeded\\\");\\n        address minter = _nftContract.creatorToken(item.tokenId);\\n        uint256 totalSent = item.price;\\n        uint256 commission = item.commission;\\n        uint256 minterShare = (totalSent * feeMinter) / HUNDRED_PERCENT;\\n        uint256 ourShare = 0;\\n        uint256 sellerShare = 0;\\n        if (item.isPremium == true) {\\n            ourShare = totalSent - minterShare;\\n        } else {\\n            ourShare = (totalSent * commission) / HUNDRED_PERCENT;\\n            sellerShare = totalSent - ourShare - minterShare;\\n            item.seller.transfer(sellerShare);\\n        }\\n        if (ourShare > 0) payable(_nupayWalletAddress).transfer(ourShare);\\n        if (minterShare > 0) payable(minter).transfer(minterShare);\\n        item.isDistributeAssets = true;\\n        _saveMarketItem(item);\\n        _setTokenIdToMarket(item.tokenId, itemId, true);\\n        emit AssetsDistributed(itemId);\\n    }\\n\\n    function _doRequest(string memory url, uint256 itemId) private {\\n        Chainlink.Request memory req = buildChainlinkRequest(_jobId, address(this), this.fulfill.selector);\\n        req.add(\\\"get\\\", url);\\n        req.add(\\\"path\\\", \\\"result\\\");\\n        bytes32 requestId = sendChainlinkRequestTo(_oracle, req, _feeOracle);\\n        _reqIds[requestId] = itemId;\\n    }\\n\\n    function _saveMarketItem(MarketItem memory item) private {\\n        if (item.itemId > 0 && item.itemId <= _lastItemId) {\\n            _fromMarket.saveMarketItem(item);\\n        } else {\\n            _idToMarketItem[item.itemId] = item;\\n        }\\n    }\\n\\n    function _setTokenIdToMarket(\\n        uint256 tokenId,\\n        uint256 itemId,\\n        bool remove\\n    ) private {\\n        if (itemId > 0 && itemId <= _lastItemId) {\\n            _fromMarket.setTokenIdToMarket(tokenId, itemId, remove);\\n        } else if (remove) {\\n            delete _idTokenToMarket[tokenId];\\n        } else {\\n            _idTokenToMarket[tokenId] = itemId;\\n        }\\n    }\\n\\n    modifier whenNotStopped() {\\n        require(!_stopped, \\\"Contract stopped\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(msg.sender == _operator, \\\"Not operator\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/v8/utils/StringUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nlibrary StringUtils {\\n    /**\\n     * Concat (High gas cost)\\n     *\\n     * Appends two strings together and returns a new value\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string which will be the concatenated\\n     *              prefix\\n     * @param _value The value to be the concatenated suffix\\n     * @return string The resulting string from combinging the base and value\\n     */\\n    function concat(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n        assert(_valueBytes.length > 0);\\n        string memory _tmpValue = new string(\\n            _baseBytes.length + _valueBytes.length\\n        );\\n        bytes memory _newValue = bytes(_tmpValue);\\n        uint256 i;\\n        uint256 j;\\n        for (i = 0; i < _baseBytes.length; i++) {\\n            _newValue[j++] = _baseBytes[i];\\n        }\\n        for (i = 0; i < _valueBytes.length; i++) {\\n            _newValue[j++] = _valueBytes[i];\\n        }\\n        return string(_newValue);\\n    }\\n\\n    /**\\n     * Index Of\\n     *\\n     * Locates and returns the position of a character within a string\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string acting as the haystack to be\\n     *              searched\\n     * @param _value The needle to search for, at present this is currently\\n     *               limited to one character\\n     * @return int The position of the needle starting from 0 and returning -1\\n     *             in the case of no matches found\\n     */\\n    function indexOf(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        return _indexOf(_base, _value, 0);\\n    }\\n\\n    /**\\n     * Index Of\\n     *\\n     * Locates and returns the position of a character within a string starting\\n     * from a defined offset\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string acting as the haystack to be\\n     *              searched\\n     * @param _value The needle to search for, at present this is currently\\n     *               limited to one character\\n     * @param _offset The starting point to start searching from which can start\\n     *                from 0, but must not exceed the length of the string\\n     * @return int The position of the needle starting from 0 and returning -1\\n     *             in the case of no matches found\\n     */\\n    function _indexOf(\\n        string memory _base,\\n        string memory _value,\\n        uint256 _offset\\n    ) internal pure returns (int256) {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n        assert(_valueBytes.length == 1);\\n        for (uint256 i = _offset; i < _baseBytes.length; i++) {\\n            if (_baseBytes[i] == _valueBytes[0]) {\\n                return int256(i);\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    /**\\n     * Length\\n     *\\n     * Returns the length of the specified string\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string to be measured\\n     * @return uint The length of the passed string\\n     */\\n    function length(string memory _base) internal pure returns (uint256) {\\n        bytes memory _baseBytes = bytes(_base);\\n        return _baseBytes.length;\\n    }\\n\\n    /**\\n     * Sub String\\n     *\\n     * Extracts the beginning part of a string based on the desired length\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string that will be used for\\n     *              extracting the sub string from\\n     * @param _length The length of the sub string to be extracted from the base\\n     * @return string The extracted sub string\\n     */\\n    function substring(string memory _base, int256 _length)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return _substring(_base, _length, 0);\\n    }\\n\\n    /**\\n     * Sub String\\n     *\\n     * Extracts the part of a string based on the desired length and offset. The\\n     * offset and length must not exceed the lenth of the base string.\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string that will be used for\\n     *              extracting the sub string from\\n     * @param _length The length of the sub string to be extracted from the base\\n     * @param _offset The starting point to extract the sub string from\\n     * @return string The extracted sub string\\n     */\\n    function _substring(\\n        string memory _base,\\n        int256 _length,\\n        int256 _offset\\n    ) internal pure returns (string memory) {\\n        bytes memory _baseBytes = bytes(_base);\\n        assert(uint256(_offset + _length) <= _baseBytes.length);\\n        string memory _tmp = new string(uint256(_length));\\n        bytes memory _tmpBytes = bytes(_tmp);\\n        uint256 j = 0;\\n        for (\\n            uint256 i = uint256(_offset);\\n            i < uint256(_offset + _length);\\n            i++\\n        ) {\\n            _tmpBytes[j++] = _baseBytes[i];\\n        }\\n        return string(_tmpBytes);\\n    }\\n\\n    /**\\n     * String Split (Very high gas cost)\\n     *\\n     * Splits a string into an array of strings based off the delimiter value.\\n     * Please note this can be quite a gas expensive function due to the use of\\n     * storage so only use if really required.\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *               otherwise this is the string value to be split.\\n     * @param _value The delimiter to split the string on which must be a single\\n     *               character\\n     *\\n     */\\n    function split(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (string[] memory splitArr)\\n    {\\n        bytes memory _baseBytes = bytes(_base);\\n        uint256 _offset = 0;\\n        uint256 _splitsCount = 1;\\n        while (_offset < _baseBytes.length - 1) {\\n            int256 _limit = _indexOf(_base, _value, _offset);\\n            if (_limit == -1) break;\\n            else {\\n                _splitsCount++;\\n                _offset = uint256(_limit) + 1;\\n            }\\n        }\\n        splitArr = new string[](_splitsCount);\\n        _offset = 0;\\n        _splitsCount = 0;\\n        while (_offset < _baseBytes.length - 1) {\\n            int256 _limit = _indexOf(_base, _value, _offset);\\n            if (_limit == -1) {\\n                _limit = int256(_baseBytes.length);\\n            }\\n            string memory _tmp = new string(uint256(_limit) - _offset);\\n            bytes memory _tmpBytes = bytes(_tmp);\\n            uint256 j = 0;\\n            for (uint256 i = _offset; i < uint256(_limit); i++) {\\n                _tmpBytes[j++] = _baseBytes[i];\\n            }\\n            _offset = uint256(_limit) + 1;\\n            splitArr[_splitsCount++] = string(_tmpBytes);\\n        }\\n        return splitArr;\\n    }\\n\\n    /**\\n     * Compare To\\n     *\\n     * Compares the characters of two strings, to ensure that they have an\\n     * identical footprint\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *               otherwise this is the string base to compare against\\n     * @param _value The string the base is being compared to\\n     */\\n    function compareTo(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (bool success)\\n    {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n        if (_baseBytes.length == _valueBytes.length) {\\n            success = keccak256(_baseBytes) == keccak256(_valueBytes);\\n        }\\n    }\\n\\n    /**\\n     * Compare To Ignore Case (High gas cost)\\n     *\\n     * Compares the characters of two strings, converting them to the same case\\n     * where applicable to alphabetic characters to distinguish if the values\\n     * match.\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *               otherwise this is the string base to compare against\\n     * @param _value The string the base is being compared to\\n     * @return bool Simply notates if the two string have an equivalent value\\n     *              discarding case\\n     */\\n    function compareToIgnoreCase(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n        if (_baseBytes.length != _valueBytes.length) {\\n            return false;\\n        }\\n        for (uint256 i = 0; i < _baseBytes.length; i++) {\\n            if (\\n                _baseBytes[i] != _valueBytes[i] &&\\n                _upper(_baseBytes[i]) != _upper(_valueBytes[i])\\n            ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * Upper\\n     *\\n     * Converts all the values of a string to their corresponding upper case\\n     * value.\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string base to convert to upper case\\n     * @return string\\n     */\\n    function upper(string memory _base) internal pure returns (string memory) {\\n        bytes memory _baseBytes = bytes(_base);\\n        for (uint256 i = 0; i < _baseBytes.length; i++) {\\n            _baseBytes[i] = _upper(_baseBytes[i]);\\n        }\\n        return string(_baseBytes);\\n    }\\n\\n    /**\\n     * Lower\\n     *\\n     * Converts all the values of a string to their corresponding lower case\\n     * value.\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string base to convert to lower case\\n     * @return string\\n     */\\n    function lower(string memory _base) internal pure returns (string memory) {\\n        bytes memory _baseBytes = bytes(_base);\\n        for (uint256 i = 0; i < _baseBytes.length; i++) {\\n            _baseBytes[i] = _lower(_baseBytes[i]);\\n        }\\n        return string(_baseBytes);\\n    }\\n\\n    /**\\n     * Upper\\n     *\\n     * Convert an alphabetic character to upper case and return the original\\n     * value when not alphabetic\\n     *\\n     * @param _b1 The byte to be converted to upper case\\n     * @return bytes1 The converted value if the passed value was alphabetic\\n     *                and in a lower case otherwise returns the original value\\n     */\\n    function _upper(bytes1 _b1) private pure returns (bytes1) {\\n        if (_b1 >= 0x61 && _b1 <= 0x7A) {\\n            return bytes1(uint8(_b1) - 32);\\n        }\\n        return _b1;\\n    }\\n\\n    /**\\n     * Lower\\n     *\\n     * Convert an alphabetic character to lower case and return the original\\n     * value when not alphabetic\\n     *\\n     * @param _b1 The byte to be converted to lower case\\n     * @return bytes1 The converted value if the passed value was alphabetic\\n     *                and in a upper case otherwise returns the original value\\n     */\\n    function _lower(bytes1 _b1) private pure returns (bytes1) {\\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\\n            return bytes1(uint8(_b1) + 32);\\n        }\\n        return _b1;\\n    }\\n\\n    function uint2str(uint256 _i) internal pure returns (string memory str) {\\n        uint256 length_;\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        while (j != 0) {\\n            length_++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(length_);\\n        uint256 k = length_;\\n        j = _i;\\n        while (j != 0) {\\n            bstr[--k] = bytes1(uint8(48 + (j % 10)));\\n            j /= 10;\\n        }\\n        str = string(bstr);\\n    }\\n\\n    function st2num(string memory numString) internal pure returns(uint) {\\n        uint  val=0;\\n        bytes   memory stringBytes = bytes(numString);\\n        for (uint  i =  0; i<stringBytes.length; i++) {\\n            uint exp = stringBytes.length - i;\\n            bytes1 ival = stringBytes[i];\\n            uint8 uval = uint8(ival);\\n           uint jval = uval - uint(0x30);\\n   \\n           val +=  (uint(jval) * (10**(exp-1))); \\n        }\\n      return val;\\n    }\\n\\n    function concatStrUint(string memory _str, uint256 _num)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        string memory _convertStr = uint2str(_num);\\n        return concat(_str, _convertStr);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/v8/interfaces/INFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.11;\\n\\ninterface INFT {\\n    function creatorToken(uint256 tokenId) external returns (address);\\n\\n    function pause() external returns (bool);\\n\\n    function unpause() external returns (bool);\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function setMarket(address newMarket) external returns (bool);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"/contracts/v8/interfaces/IMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.11;\\n\\ninterface IMarket {\\n    struct MarketItem {\\n        uint256 itemId;\\n        uint256 tokenId;\\n        address payable seller;\\n        address payable owner;\\n        uint256 price;\\n        uint256 commission;\\n        bool sold;\\n        bool isPremium;\\n        bool isResolved;\\n        bool isRejected;\\n        bool isDistributeAssets;\\n    }\\n\\n    function lastItemId() external view returns (uint256);\\n\\n    function idTokenToMarket(uint256 tokenId) external view returns (uint256 itemId);\\n\\n    function itemIds() external view returns (uint256);\\n\\n    function toMarket() external view returns (address);\\n\\n    function fetchSpecificMarketItem(uint256 itemId) external view returns (MarketItem memory);\\n\\n    function fetchAllMarketItems(uint256 skip, uint256 limit) external view returns (MarketItem[] memory marketItems);\\n\\n    function fetchMarketItemsByTokenId(uint256 tokenId, uint256 skip, uint256 limit ) external view returns (MarketItem[] memory marketItems);\\n\\n    function marketItemsByTokenIdLength(uint256 tokenId) external view returns (uint256);\\n\\n    function resolveDeal( uint256 tokenId, address sender, address recipient) external returns (bool);\\n\\n    function saveMarketItem(MarketItem memory item) external returns (bool);\\n\\n    function setTokenIdToMarket(uint256 tokenId, uint256 itemId, bool remove) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/v8/access/TwoStageOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nabstract contract TwoStageOwnable {\\n    address private _nominatedOwner;\\n    address private _owner;\\n\\n    function nominatedOwner() public view returns (address) {\\n        return _nominatedOwner;\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    event OwnerChanged(address indexed newOwner);\\n    event OwnerNominated(address indexed nominatedOwner);\\n\\n    constructor(address owner_) {\\n        require(owner_ != address(0), \\\"Owner is zero\\\");\\n        _setOwner(owner_);\\n    }\\n\\n    function acceptOwnership() external returns (bool success) {\\n        require(msg.sender == _nominatedOwner, \\\"Not nominated to ownership\\\");\\n        _setOwner(_nominatedOwner);\\n        return true;\\n    }\\n\\n    function nominateNewOwner(address owner_) external onlyOwner returns (bool success) {\\n        _nominateNewOwner(owner_);\\n        return true;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == _owner, \\\"Not owner\\\");\\n        _;\\n    }\\n\\n    function _nominateNewOwner(address owner_) internal {\\n        if (_nominatedOwner == owner_) return;\\n        require(_owner != owner_, \\\"Already owner\\\");\\n        _nominatedOwner = owner_;\\n        emit OwnerNominated(owner_);\\n    }\\n\\n    function _setOwner(address newOwner) internal {\\n        if (_owner == newOwner) return;\\n        _owner = newOwner;\\n        _nominatedOwner = address(0);\\n        emit OwnerChanged(newOwner);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/vendor/ENSResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract ENSResolver {\\n  function addr(\\n    bytes32 node\\n  )\\n    public\\n    view\\n    virtual\\n    returns (\\n      address\\n    );\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.19;\\n\\nimport { BufferChainlink } from \\\"./BufferChainlink.sol\\\";\\n\\nlibrary CBORChainlink {\\n  using BufferChainlink for BufferChainlink.buffer;\\n\\n  uint8 private constant MAJOR_TYPE_INT = 0;\\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\\n  uint8 private constant MAJOR_TYPE_STRING = 3;\\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\\n  uint8 private constant MAJOR_TYPE_MAP = 5;\\n  uint8 private constant MAJOR_TYPE_TAG = 6;\\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\\n\\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\\n\\n  function encodeType(\\n    BufferChainlink.buffer memory buf,\\n    uint8 major,\\n    uint value\\n  )\\n    private\\n    pure\\n  {\\n    if(value <= 23) {\\n      buf.appendUint8(uint8((major << 5) | value));\\n    } else if(value <= 0xFF) {\\n      buf.appendUint8(uint8((major << 5) | 24));\\n      buf.appendInt(value, 1);\\n    } else if(value <= 0xFFFF) {\\n      buf.appendUint8(uint8((major << 5) | 25));\\n      buf.appendInt(value, 2);\\n    } else if(value <= 0xFFFFFFFF) {\\n      buf.appendUint8(uint8((major << 5) | 26));\\n      buf.appendInt(value, 4);\\n    } else if(value <= 0xFFFFFFFFFFFFFFFF) {\\n      buf.appendUint8(uint8((major << 5) | 27));\\n      buf.appendInt(value, 8);\\n    }\\n  }\\n\\n  function encodeIndefiniteLengthType(\\n    BufferChainlink.buffer memory buf,\\n    uint8 major\\n  )\\n    private\\n    pure\\n  {\\n    buf.appendUint8(uint8((major << 5) | 31));\\n  }\\n\\n  function encodeUInt(\\n    BufferChainlink.buffer memory buf,\\n    uint value\\n  )\\n    internal\\n    pure\\n  {\\n    encodeType(buf, MAJOR_TYPE_INT, value);\\n  }\\n\\n  function encodeInt(\\n    BufferChainlink.buffer memory buf,\\n    int value\\n  )\\n    internal\\n    pure\\n  {\\n    if(value < -0x10000000000000000) {\\n      encodeSignedBigNum(buf, value);\\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\\n      encodeBigNum(buf, value);\\n    } else if(value >= 0) {\\n      encodeType(buf, MAJOR_TYPE_INT, uint(value));\\n    } else {\\n      encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\\n    }\\n  }\\n\\n  function encodeBytes(\\n    BufferChainlink.buffer memory buf,\\n    bytes memory value\\n  )\\n    internal\\n    pure\\n  {\\n    encodeType(buf, MAJOR_TYPE_BYTES, value.length);\\n    buf.append(value);\\n  }\\n\\n  function encodeBigNum(\\n    BufferChainlink.buffer memory buf,\\n    int value\\n  )\\n    internal\\n    pure\\n  {\\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\\n    encodeBytes(buf, abi.encode(uint(value)));\\n  }\\n\\n  function encodeSignedBigNum(\\n    BufferChainlink.buffer memory buf,\\n    int input\\n  )\\n    internal\\n    pure\\n  {\\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\\n    encodeBytes(buf, abi.encode(uint(-1 - input)));\\n  }\\n\\n  function encodeString(\\n    BufferChainlink.buffer memory buf,\\n    string memory value\\n  )\\n    internal\\n    pure\\n  {\\n    encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\\n    buf.append(bytes(value));\\n  }\\n\\n  function startArray(\\n    BufferChainlink.buffer memory buf\\n  )\\n    internal\\n    pure\\n  {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\\n  }\\n\\n  function startMap(\\n    BufferChainlink.buffer memory buf\\n  )\\n    internal\\n    pure\\n  {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\\n  }\\n\\n  function endSequence(\\n    BufferChainlink.buffer memory buf\\n  )\\n    internal\\n    pure\\n  {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for writing to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary BufferChainlink {\\n  /**\\n  * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n  *      a capacity. The capacity may be longer than the current value, in\\n  *      which case it can be extended without the need to allocate more memory.\\n  */\\n  struct buffer {\\n    bytes buf;\\n    uint capacity;\\n  }\\n\\n  /**\\n  * @dev Initializes a buffer with an initial capacity.\\n  * @param buf The buffer to initialize.\\n  * @param capacity The number of bytes of space to allocate the buffer.\\n  * @return The buffer, for chaining.\\n  */\\n  function init(\\n    buffer memory buf,\\n    uint capacity\\n  )\\n    internal\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    if (capacity % 32 != 0) {\\n      capacity += 32 - (capacity % 32);\\n    }\\n    // Allocate space for the buffer data\\n    buf.capacity = capacity;\\n    assembly {\\n      let ptr := mload(0x40)\\n      mstore(buf, ptr)\\n      mstore(ptr, 0)\\n      mstore(0x40, add(32, add(ptr, capacity)))\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n  * @dev Initializes a new buffer from an existing bytes object.\\n  *      Changes to the buffer may mutate the original value.\\n  * @param b The bytes object to initialize the buffer with.\\n  * @return A new buffer.\\n  */\\n  function fromBytes(\\n    bytes memory b\\n  )\\n    internal\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    buffer memory buf;\\n    buf.buf = b;\\n    buf.capacity = b.length;\\n    return buf;\\n  }\\n\\n  function resize(\\n    buffer memory buf,\\n    uint capacity\\n  )\\n    private\\n    pure\\n  {\\n    bytes memory oldbuf = buf.buf;\\n    init(buf, capacity);\\n    append(buf, oldbuf);\\n  }\\n\\n  function max(\\n    uint a,\\n    uint b\\n  )\\n    private\\n    pure\\n    returns(\\n      uint\\n    )\\n  {\\n    if (a > b) {\\n      return a;\\n    }\\n    return b;\\n  }\\n\\n  /**\\n  * @dev Sets buffer length to 0.\\n  * @param buf The buffer to truncate.\\n  * @return The original buffer, for chaining..\\n  */\\n  function truncate(\\n    buffer memory buf\\n  )\\n    internal\\n    pure\\n    returns (\\n      buffer memory\\n    )\\n  {\\n    assembly {\\n      let bufptr := mload(buf)\\n      mstore(bufptr, 0)\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n  * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n  *      the capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param off The start offset to write to.\\n  * @param data The data to append.\\n  * @param len The number of bytes to copy.\\n  * @return The original buffer, for chaining.\\n  */\\n  function write(\\n    buffer memory buf,\\n    uint off,\\n    bytes memory data,\\n    uint len\\n  )\\n    internal\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    require(len <= data.length);\\n\\n    if (off + len > buf.capacity) {\\n      resize(buf, max(buf.capacity, len + off) * 2);\\n    }\\n\\n    uint dest;\\n    uint src;\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Length of existing buffer data\\n      let buflen := mload(bufptr)\\n      // Start address = buffer address + offset + sizeof(buffer length)\\n      dest := add(add(bufptr, 32), off)\\n      // Update buffer length if we're extending it\\n      if gt(add(len, off), buflen) {\\n        mstore(bufptr, add(len, off))\\n      }\\n      src := add(data, 32)\\n    }\\n\\n    // Copy word-length chunks while possible\\n    for (; len >= 32; len -= 32) {\\n      assembly {\\n        mstore(dest, mload(src))\\n      }\\n      dest += 32;\\n      src += 32;\\n    }\\n\\n    // Copy remaining bytes\\n    unchecked {\\n      uint mask = (256 ** (32 - len)) - 1;\\n      assembly {\\n        let srcpart := and(mload(src), not(mask))\\n        let destpart := and(mload(dest), mask)\\n        mstore(dest, or(destpart, srcpart))\\n      }\\n    }\\n\\n    return buf;\\n  }\\n\\n  /**\\n  * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n  *      the capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param data The data to append.\\n  * @param len The number of bytes to copy.\\n  * @return The original buffer, for chaining.\\n  */\\n  function append(\\n    buffer memory buf,\\n    bytes memory data,\\n    uint len\\n  )\\n    internal\\n    pure\\n    returns (\\n      buffer memory\\n    )\\n  {\\n    return write(buf, buf.buf.length, data, len);\\n  }\\n\\n  /**\\n  * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n  *      the capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param data The data to append.\\n  * @return The original buffer, for chaining.\\n  */\\n  function append(\\n    buffer memory buf,\\n    bytes memory data\\n  )\\n    internal\\n    pure\\n    returns (\\n      buffer memory\\n    )\\n  {\\n    return write(buf, buf.buf.length, data, data.length);\\n  }\\n\\n  /**\\n  * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\\n  *      capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param off The offset to write the byte at.\\n  * @param data The data to append.\\n  * @return The original buffer, for chaining.\\n  */\\n  function writeUint8(\\n    buffer memory buf,\\n    uint off,\\n    uint8 data\\n  )\\n    internal\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    if (off >= buf.capacity) {\\n      resize(buf, buf.capacity * 2);\\n    }\\n\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Length of existing buffer data\\n      let buflen := mload(bufptr)\\n      // Address = buffer address + sizeof(buffer length) + off\\n      let dest := add(add(bufptr, off), 32)\\n      mstore8(dest, data)\\n      // Update buffer length if we extended it\\n      if eq(off, buflen) {\\n        mstore(bufptr, add(buflen, 1))\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n  * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n  *      capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param data The data to append.\\n  * @return The original buffer, for chaining.\\n  */\\n  function appendUint8(\\n    buffer memory buf,\\n    uint8 data\\n  )\\n    internal\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    return writeUint8(buf, buf.buf.length, data);\\n  }\\n\\n  /**\\n  * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\\n  *      exceed the capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param off The offset to write at.\\n  * @param data The data to append.\\n  * @param len The number of bytes to write (left-aligned).\\n  * @return The original buffer, for chaining.\\n  */\\n  function write(\\n    buffer memory buf,\\n    uint off,\\n    bytes32 data,\\n    uint len\\n  )\\n    private\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    if (len + off > buf.capacity) {\\n      resize(buf, (len + off) * 2);\\n    }\\n\\n    unchecked {\\n      uint mask = (256 ** len) - 1;\\n      // Right-align data\\n      data = data >> (8 * (32 - len));\\n      assembly {\\n        // Memory address of the buffer data\\n        let bufptr := mload(buf)\\n        // Address = buffer address + sizeof(buffer length) + off + len\\n        let dest := add(add(bufptr, off), len)\\n        mstore(dest, or(and(mload(dest), not(mask)), data))\\n        // Update buffer length if we extended it\\n        if gt(add(off, len), mload(bufptr)) {\\n          mstore(bufptr, add(off, len))\\n        }\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n  * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\\n  *      capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param off The offset to write at.\\n  * @param data The data to append.\\n  * @return The original buffer, for chaining.\\n  */\\n  function writeBytes20(\\n    buffer memory buf,\\n    uint off,\\n    bytes20 data\\n  )\\n    internal\\n    pure\\n    returns (\\n      buffer memory\\n    )\\n  {\\n    return write(buf, off, bytes32(data), 20);\\n  }\\n\\n  /**\\n  * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n  *      the capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param data The data to append.\\n  * @return The original buffer, for chhaining.\\n  */\\n  function appendBytes20(\\n    buffer memory buf,\\n    bytes20 data\\n  )\\n    internal\\n    pure\\n    returns (\\n      buffer memory\\n    )\\n  {\\n    return write(buf, buf.buf.length, bytes32(data), 20);\\n  }\\n\\n  /**\\n  * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n  *      the capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param data The data to append.\\n  * @return The original buffer, for chaining.\\n  */\\n  function appendBytes32(\\n    buffer memory buf,\\n    bytes32 data\\n  )\\n    internal\\n    pure\\n    returns (\\n      buffer memory\\n    )\\n  {\\n    return write(buf, buf.buf.length, data, 32);\\n  }\\n\\n  /**\\n  * @dev Writes an integer to the buffer. Resizes if doing so would exceed\\n  *      the capacity of the buffer.\\n  * @param buf The buffer to append to.\\n  * @param off The offset to write at.\\n  * @param data The data to append.\\n  * @param len The number of bytes to write (right-aligned).\\n  * @return The original buffer, for chaining.\\n  */\\n  function writeInt(\\n    buffer memory buf,\\n    uint off,\\n    uint data,\\n    uint len\\n  )\\n    private\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    if (len + off > buf.capacity) {\\n      resize(buf, (len + off) * 2);\\n    }\\n\\n    uint mask = (256 ** len) - 1;\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Address = buffer address + off + sizeof(buffer length) + len\\n      let dest := add(add(bufptr, off), len)\\n      mstore(dest, or(and(mload(dest), not(mask)), data))\\n      // Update buffer length if we extended it\\n      if gt(add(off, len), mload(bufptr)) {\\n        mstore(bufptr, add(off, len))\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n    * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n    * exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer.\\n    */\\n  function appendInt(\\n    buffer memory buf,\\n    uint data,\\n    uint len\\n  )\\n    internal\\n    pure\\n    returns(\\n      buffer memory\\n    )\\n  {\\n    return writeInt(buf, buf.buf.length, data, len);\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface PointerInterface {\\n  \\n  function getAddress()\\n    external\\n    view\\n    returns (\\n      address\\n    );\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OracleInterface {\\n  function fulfillOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes32 data\\n  )\\n    external\\n    returns (\\n      bool\\n    );\\n\\n  function isAuthorizedSender(\\n    address node\\n  )\\n    external\\n    view\\n    returns (\\n      bool\\n    );\\n\\n  function withdraw(\\n    address recipient,\\n    uint256 amount\\n  ) external;\\n\\n  function withdrawable()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OracleInterface.sol\\\";\\nimport \\\"./ChainlinkRequestInterface.sol\\\";\\n\\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\\n\\n  function requestOracleData(\\n    address sender,\\n    uint256 payment,\\n    bytes32 specId,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  )\\n    external;\\n\\n  function fulfillOracleRequest2(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes calldata data\\n  )\\n    external\\n    returns (\\n      bool\\n    );\\n\\n  function ownerTransferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function distributeFunds(\\n    address payable[] calldata receivers,\\n    uint[] calldata amounts\\n  )\\n    external\\n    payable;\\n\\n  function getAuthorizedSenders()\\n    external\\n    returns (\\n      address[] memory\\n    );\\n\\n  function setAuthorizedSenders(\\n    address[] calldata senders\\n  ) external;\\n\\n  function getForwarder()\\n    external\\n    returns (\\n      address\\n    );\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n\\n  function allowance(\\n    address owner,\\n    address spender\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 remaining\\n    );\\n\\n  function approve(\\n    address spender,\\n    uint256 value\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function balanceOf(\\n    address owner\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 balance\\n    );\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8 decimalPlaces\\n    );\\n\\n  function decreaseApproval(\\n    address spender,\\n    uint256 addedValue\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function increaseApproval(\\n    address spender,\\n    uint256 subtractedValue\\n  ) external;\\n\\n  function name()\\n    external\\n    view\\n    returns (\\n      string memory tokenName\\n    );\\n\\n  function symbol()\\n    external\\n    view\\n    returns (\\n      string memory tokenSymbol\\n    );\\n\\n  function totalSupply()\\n    external\\n    view\\n    returns (\\n      uint256 totalTokensIssued\\n    );\\n\\n  function transfer(\\n    address to,\\n    uint256 value\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ENSInterface {\\n\\n  // Logged when the owner of a node assigns a new owner to a subnode.\\n  event NewOwner(\\n    bytes32 indexed node,\\n    bytes32 indexed label,\\n    address owner\\n  );\\n\\n  // Logged when the owner of a node transfers ownership to a new account.\\n  event Transfer(\\n    bytes32 indexed node,\\n    address owner\\n  );\\n\\n  // Logged when the resolver for a node changes.\\n  event NewResolver(\\n    bytes32 indexed node,\\n    address resolver\\n  );\\n\\n  // Logged when the TTL of a node changes\\n  event NewTTL(\\n    bytes32 indexed node,\\n    uint64 ttl\\n  );\\n\\n\\n  function setSubnodeOwner(\\n    bytes32 node,\\n    bytes32 label,\\n    address owner\\n  ) external;\\n\\n  function setResolver(\\n    bytes32 node,\\n    address resolver\\n  ) external;\\n\\n  function setOwner(\\n    bytes32 node,\\n    address owner\\n  ) external;\\n\\n  function setTTL(\\n    bytes32 node,\\n    uint64 ttl\\n  ) external;\\n\\n  function owner(\\n    bytes32 node\\n  )\\n    external\\n    view\\n    returns (\\n      address\\n    );\\n\\n  function resolver(\\n    bytes32 node\\n  )\\n    external\\n    view\\n    returns (\\n      address\\n    );\\n\\n  function ttl(\\n    bytes32 node\\n  )\\n    external\\n    view\\n    returns (\\n      uint64\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ChainlinkRequestInterface {\\n  function oracleRequest(\\n    address sender,\\n    uint256 requestPrice,\\n    bytes32 serviceAgreementID,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external;\\n\\n  function cancelOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Chainlink.sol\\\";\\nimport \\\"./interfaces/ENSInterface.sol\\\";\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"./interfaces/OperatorInterface.sol\\\";\\nimport \\\"./interfaces/PointerInterface.sol\\\";\\nimport { ENSResolver as ENSResolver_Chainlink } from \\\"./vendor/ENSResolver.sol\\\";\\n\\n/**\\n * @title The ChainlinkClient contract\\n * @notice Contract writers can inherit this contract in order to create requests for the\\n * Chainlink network\\n */\\ncontract ChainlinkClient {\\n  using Chainlink for Chainlink.Request;\\n\\n  uint256 constant internal LINK_DIVISIBILITY = 10**18;\\n  uint256 constant private AMOUNT_OVERRIDE = 0;\\n  address constant private SENDER_OVERRIDE = address(0);\\n  uint256 constant private ORACLE_ARGS_VERSION = 1;\\n  uint256 constant private OPERATOR_ARGS_VERSION = 2;\\n  bytes32 constant private ENS_TOKEN_SUBNAME = keccak256(\\\"link\\\");\\n  bytes32 constant private ENS_ORACLE_SUBNAME = keccak256(\\\"oracle\\\");\\n  address constant private LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\\n\\n  ENSInterface private ens;\\n  bytes32 private ensNode;\\n  LinkTokenInterface private link;\\n  OperatorInterface private oracle;\\n  uint256 private requestCount = 1;\\n  mapping(bytes32 => address) private pendingRequests;\\n\\n  event ChainlinkRequested(\\n    bytes32 indexed id\\n  );\\n  event ChainlinkFulfilled(\\n    bytes32 indexed id\\n  );\\n  event ChainlinkCancelled(\\n    bytes32 indexed id\\n  );\\n\\n  /**\\n   * @notice Creates a request that can hold additional parameters\\n   * @param specId The Job Specification ID that the request will be created for\\n   * @param callbackAddress The callback address that the response will be sent to\\n   * @param callbackFunctionSignature The callback function signature to use for the callback address\\n   * @return A Chainlink Request struct in memory\\n   */\\n  function buildChainlinkRequest(\\n    bytes32 specId,\\n    address callbackAddress,\\n    bytes4 callbackFunctionSignature\\n  )\\n    internal\\n    pure\\n    returns (\\n      Chainlink.Request memory\\n    )\\n  {\\n    Chainlink.Request memory req;\\n    return req.initialize(specId, callbackAddress, callbackFunctionSignature);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the stored oracle address\\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendChainlinkRequest(\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  )\\n    internal\\n    returns (\\n      bytes32\\n    )\\n  {\\n    return sendChainlinkRequestTo(address(oracle), req, payment);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the specified oracle address\\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\\n   * send LINK which creates a request on the target oracle contract.\\n   * Emits ChainlinkRequested event.\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendChainlinkRequestTo(\\n    address oracleAddress,\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  )\\n    internal\\n    returns (\\n      bytes32 requestId\\n    )\\n  {\\n    return rawRequest(oracleAddress, req, payment, ORACLE_ARGS_VERSION, oracle.oracleRequest.selector);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the stored oracle address\\n   * @dev This function supports multi-word response\\n   * @dev Calls `requestOracleDataFrom` with the stored oracle address\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function requestOracleData(\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  )\\n    internal\\n    returns (\\n      bytes32\\n    )\\n  {\\n    return requestOracleDataFrom(address(oracle), req, payment);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the specified oracle address\\n   * @dev This function supports multi-word response\\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\\n   * send LINK which creates a request on the target oracle contract.\\n   * Emits ChainlinkRequested event.\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function requestOracleDataFrom(\\n    address oracleAddress,\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  )\\n    internal\\n    returns (\\n      bytes32 requestId\\n    )\\n  {\\n    return rawRequest(oracleAddress, req, payment, OPERATOR_ARGS_VERSION, oracle.requestOracleData.selector);\\n  }\\n\\n  /**\\n   * @notice Make a request to an oracle\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @param argsVersion The version of data support (single word, multi word)\\n   * @return requestId The request ID\\n   */\\n  function rawRequest(\\n    address oracleAddress,\\n    Chainlink.Request memory req,\\n    uint256 payment,\\n    uint256 argsVersion,\\n    bytes4 funcSelector\\n  )\\n    private\\n    returns (\\n      bytes32 requestId\\n    )\\n  {\\n    requestId = keccak256(abi.encodePacked(this, requestCount));\\n    req.nonce = requestCount;\\n    pendingRequests[requestId] = oracleAddress;\\n    emit ChainlinkRequested(requestId);\\n    bytes memory encodedData = abi.encodeWithSelector(\\n      funcSelector,\\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\\n      req.id,\\n      req.callbackAddress,\\n      req.callbackFunctionId,\\n      req.nonce,\\n      argsVersion,\\n      req.buf.buf);\\n    require(link.transferAndCall(oracleAddress, payment, encodedData), \\\"unable to transferAndCall to oracle\\\");\\n    requestCount += 1;\\n  }\\n\\n  /**\\n   * @notice Allows a request to be cancelled if it has not been fulfilled\\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\\n   * Deletes the request from the `pendingRequests` mapping.\\n   * Emits ChainlinkCancelled event.\\n   * @param requestId The request ID\\n   * @param payment The amount of LINK sent for the request\\n   * @param callbackFunc The callback function specified for the request\\n   * @param expiration The time of the expiration for the request\\n   */\\n  function cancelChainlinkRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunc,\\n    uint256 expiration\\n  )\\n    internal\\n  {\\n    OperatorInterface requested = OperatorInterface(pendingRequests[requestId]);\\n    delete pendingRequests[requestId];\\n    emit ChainlinkCancelled(requestId);\\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle address\\n   * @param oracleAddress The address of the oracle contract\\n   */\\n  function setChainlinkOracle(\\n    address oracleAddress\\n  )\\n    internal\\n  {\\n    oracle = OperatorInterface(oracleAddress);\\n  }\\n\\n  /**\\n   * @notice Sets the LINK token address\\n   * @param linkAddress The address of the LINK token contract\\n   */\\n  function setChainlinkToken(\\n    address linkAddress\\n  )\\n    internal\\n  {\\n    link = LinkTokenInterface(linkAddress);\\n  }\\n\\n  /**\\n   * @notice Sets the Chainlink token address for the public\\n   * network as given by the Pointer contract\\n   */\\n  function setPublicChainlinkToken() \\n    internal\\n  {\\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\\n  }\\n\\n  /**\\n   * @notice Retrieves the stored address of the LINK token\\n   * @return The address of the LINK token\\n   */\\n  function chainlinkTokenAddress()\\n    internal\\n    view\\n    returns (\\n      address\\n    )\\n  {\\n    return address(link);\\n  }\\n\\n  /**\\n   * @notice Retrieves the stored address of the oracle contract\\n   * @return The address of the oracle contract\\n   */\\n  function chainlinkOracleAddress()\\n    internal\\n    view\\n    returns (\\n      address\\n    )\\n  {\\n    return address(oracle);\\n  }\\n\\n  /**\\n   * @notice Allows for a request which was created on another contract to be fulfilled\\n   * on this contract\\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\\n   * @param requestId The request ID used for the response\\n   */\\n  function addChainlinkExternalRequest(\\n    address oracleAddress,\\n    bytes32 requestId\\n  )\\n    internal\\n    notPendingRequest(requestId)\\n  {\\n    pendingRequests[requestId] = oracleAddress;\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\\n   * @dev Accounts for subnodes having different resolvers\\n   * @param ensAddress The address of the ENS contract\\n   * @param node The ENS node hash\\n   */\\n  function useChainlinkWithENS(\\n    address ensAddress,\\n    bytes32 node\\n  )\\n    internal\\n  {\\n    ens = ENSInterface(ensAddress);\\n    ensNode = node;\\n    bytes32 linkSubnode = keccak256(abi.encodePacked(ensNode, ENS_TOKEN_SUBNAME));\\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(ens.resolver(linkSubnode));\\n    setChainlinkToken(resolver.addr(linkSubnode));\\n    updateChainlinkOracleWithENS();\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle contract with the address resolved by ENS\\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\\n   */\\n  function updateChainlinkOracleWithENS()\\n    internal\\n  {\\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(ensNode, ENS_ORACLE_SUBNAME));\\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(ens.resolver(oracleSubnode));\\n    setChainlinkOracle(resolver.addr(oracleSubnode));\\n  }\\n\\n  /**\\n   * @notice Ensures that the fulfillment is valid for this contract\\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\\n   * @param requestId The request ID for fulfillment\\n   */\\n  function validateChainlinkCallback(\\n    bytes32 requestId\\n  )\\n    internal\\n    recordChainlinkFulfillment(requestId)\\n    // solhint-disable-next-line no-empty-blocks\\n  {}\\n\\n  /**\\n   * @dev Reverts if the sender is not the oracle of the request.\\n   * Emits ChainlinkFulfilled event.\\n   * @param requestId The request ID for fulfillment\\n   */\\n  modifier recordChainlinkFulfillment(\\n    bytes32 requestId\\n  )\\n  {\\n    require(msg.sender == pendingRequests[requestId],\\n            \\\"Source must be the oracle of the request\\\");\\n    delete pendingRequests[requestId];\\n    emit ChainlinkFulfilled(requestId);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the request is already pending\\n   * @param requestId The request ID for fulfillment\\n   */\\n  modifier notPendingRequest(\\n    bytes32 requestId\\n  )\\n  {\\n    require(pendingRequests[requestId] == address(0), \\\"Request is already pending\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/Chainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { CBORChainlink } from \\\"./vendor/CBORChainlink.sol\\\";\\nimport { BufferChainlink } from \\\"./vendor/BufferChainlink.sol\\\";\\n\\n/**\\n * @title Library for common Chainlink functions\\n * @dev Uses imported CBOR library for encoding to buffer\\n */\\nlibrary Chainlink {\\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\\n\\n  using CBORChainlink for BufferChainlink.buffer;\\n\\n  struct Request {\\n    bytes32 id;\\n    address callbackAddress;\\n    bytes4 callbackFunctionId;\\n    uint256 nonce;\\n    BufferChainlink.buffer buf;\\n  }\\n\\n  /**\\n   * @notice Initializes a Chainlink request\\n   * @dev Sets the ID, callback address, and callback function signature on the request\\n   * @param self The uninitialized request\\n   * @param jobId The Job Specification ID\\n   * @param callbackAddr The callback address\\n   * @param callbackFunc The callback function signature\\n   * @return The initialized request\\n   */\\n  function initialize(\\n    Request memory self,\\n    bytes32 jobId,\\n    address callbackAddr,\\n    bytes4 callbackFunc\\n  )\\n    internal\\n    pure\\n    returns (\\n      Chainlink.Request memory\\n    )\\n  {\\n    BufferChainlink.init(self.buf, defaultBufferSize);\\n    self.id = jobId;\\n    self.callbackAddress = callbackAddr;\\n    self.callbackFunctionId = callbackFunc;\\n    return self;\\n  }\\n\\n  /**\\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\\n   * @param self The initialized request\\n   * @param data The CBOR data\\n   */\\n  function setBuffer(\\n    Request memory self,\\n    bytes memory data\\n  )\\n    internal\\n    pure\\n  {\\n    BufferChainlink.init(self.buf, data.length);\\n    BufferChainlink.append(self.buf, data);\\n  }\\n\\n  /**\\n   * @notice Adds a string value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The string value to add\\n   */\\n  function add(\\n    Request memory self,\\n    string memory key,\\n    string memory value\\n  )\\n    internal\\n    pure\\n  {\\n    self.buf.encodeString(key);\\n    self.buf.encodeString(value);\\n  }\\n\\n  /**\\n   * @notice Adds a bytes value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The bytes value to add\\n   */\\n  function addBytes(\\n    Request memory self,\\n    string memory key,\\n    bytes memory value\\n  )\\n    internal\\n    pure\\n  {\\n    self.buf.encodeString(key);\\n    self.buf.encodeBytes(value);\\n  }\\n\\n  /**\\n   * @notice Adds a int256 value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The int256 value to add\\n   */\\n  function addInt(\\n    Request memory self,\\n    string memory key,\\n    int256 value\\n  )\\n    internal\\n    pure\\n  {\\n    self.buf.encodeString(key);\\n    self.buf.encodeInt(value);\\n  }\\n\\n  /**\\n   * @notice Adds a uint256 value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The uint256 value to add\\n   */\\n  function addUint(\\n    Request memory self,\\n    string memory key,\\n    uint256 value\\n  )\\n    internal\\n    pure\\n  {\\n    self.buf.encodeString(key);\\n    self.buf.encodeUInt(value);\\n  }\\n\\n  /**\\n   * @notice Adds an array of strings to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param values The array of string values to add\\n   */\\n  function addStringArray(\\n    Request memory self,\\n    string memory key,\\n    string[] memory values\\n  )\\n    internal\\n    pure\\n  {\\n    self.buf.encodeString(key);\\n    self.buf.startArray();\\n    for (uint256 i = 0; i < values.length; i++) {\\n      self.buf.encodeString(values[i]);\\n    }\\n    self.buf.endSequence();\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"urlRequest_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"linkToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nupayWalletAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracle_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"jobId_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"feeOracle_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"AssetsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"AssetsForciblyDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"DealRejected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"DealResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FeeSetted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"MarketItemCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sold\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPremium\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isResolved\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isRejected\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDistributeAssets\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct IMarket.MarketItem\",\"name\":\"item\",\"type\":\"tuple\"}],\"name\":\"MarketItemSaved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"MarketSaleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"Migrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"}],\"name\":\"NftContractSetted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nupayWallet\",\"type\":\"address\"}],\"name\":\"NupayWalletSetted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorSetted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oracleContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"jobId\",\"type\":\"bytes32\"}],\"name\":\"OracleSetted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nominatedOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"remove\",\"type\":\"bool\"}],\"name\":\"TokenIdToMarketSetted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"url\",\"type\":\"string\"}],\"name\":\"UrlRequestSetted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"createMarketItem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"createMarketSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeOracle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"skip\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"fetchAllMarketItems\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sold\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPremium\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isResolved\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isRejected\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDistributeAssets\",\"type\":\"bool\"}],\"internalType\":\"struct IMarket.MarketItem[]\",\"name\":\"marketItems\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"skip\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"fetchMarketItemsByTokenId\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sold\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPremium\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isResolved\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isRejected\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDistributeAssets\",\"type\":\"bool\"}],\"internalType\":\"struct IMarket.MarketItem[]\",\"name\":\"marketItems\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"fetchSpecificMarketItem\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sold\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPremium\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isResolved\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isRejected\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDistributeAssets\",\"type\":\"bool\"}],\"internalType\":\"struct IMarket.MarketItem\",\"name\":\"marketItem\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"comission\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shareMinter\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPremium\",\"type\":\"bool\"}],\"name\":\"forceDistributeAssets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fromMarket\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"commission\",\"type\":\"bytes32\"}],\"name\":\"fulfill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"idTokenToMarket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"itemIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastItemId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"linkToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"marketItemsByTokenIdLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"migrateTo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nupayWalletAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"rejectDeal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"reqId\",\"type\":\"bytes32\"}],\"name\":\"reqIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"resolveDeal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sold\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPremium\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isResolved\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isRejected\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDistributeAssets\",\"type\":\"bool\"}],\"internalType\":\"struct IMarket.MarketItem\",\"name\":\"item\",\"type\":\"tuple\"}],\"name\":\"saveMarketItem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setFeeOracle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"}],\"name\":\"setNftContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nupayWallet\",\"type\":\"address\"}],\"name\":\"setNupayWalletAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"jobId\",\"type\":\"bytes32\"}],\"name\":\"setOracle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"remove\",\"type\":\"bool\"}],\"name\":\"setTokenIdToMarket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"url\",\"type\":\"string\"}],\"name\":\"setUrlRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toMarket\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"urlRequest\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "NFTMarket", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "00000000000000000000000015270ce6a632d2449bf2d9eb1aa6842e04aabebb0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca000000000000000000000000998f5a6bef4081badfeecb4103d09c713bc5650800000000000000000000000015270ce6a632d2449bf2d9eb1aa6842e04aabebb000000000000000000000000daf50e6f70b6b11f01c063f1ec23145c8e7e608301f082bbb9ed4f0aa6272d837f9ea9ea00000000000000000000000000000000000000000000000000000000000000000000000000000000016345785d8a0000000000000000000000000000000000000000000000000000000000000000003868747470733a2f2f6d6b746170692e707269736d6e6674732e636f6d2f6170692f6e6674732f636f6d6d697373696f6e546f6b656e49642f0000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}