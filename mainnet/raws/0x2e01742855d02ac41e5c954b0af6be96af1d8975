{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @title IPRBProxy\n/// @author Paul Razvan Berg\n/// @notice Proxy contract to compose transactions on owner's behalf.\ninterface IPRBProxy {\n    /// EVENTS ///\n\n    event Execute(address indexed target, bytes data, bytes response);\n\n    event TransferOwnership(address indexed oldOwner, address indexed newOwner);\n\n    /// PUBLIC CONSTANT FUNCTIONS ///\n\n    /// @notice Returns a boolean flag that indicates whether the envoy has permission to call the given target\n    /// contract and function selector.\n    function getPermission(\n        address envoy,\n        address target,\n        bytes4 selector\n    ) external view returns (bool);\n\n    /// @notice The address of the owner account or contract.\n    function owner() external view returns (address);\n\n    /// @notice How much gas to reserve for running the remainder of the \"execute\" function after the DELEGATECALL.\n    /// @dev This prevents the proxy from becoming unusable if EVM opcode gas costs change in the future.\n    function minGasReserve() external view returns (uint256);\n\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n    /// @notice Delegate calls to the target contract by forwarding the call data. Returns the data it gets back,\n    /// including when the contract call reverts with a reason or custom error.\n    ///\n    /// @dev Requirements:\n    /// - The caller must be either an owner or an envoy.\n    /// - `target` must be a deployed contract.\n    /// - The owner cannot be changed during the DELEGATECALL.\n    ///\n    /// @param target The address of the target contract.\n    /// @param data Function selector plus ABI encoded data.\n    /// @return response The response received from the target contract.\n    function execute(address target, bytes calldata data) external payable returns (bytes memory response);\n\n    /// @notice Gives or takes a permission from an envoy to call the given target contract and function selector\n    /// on behalf of the owner.\n    /// @dev It is not an error to reset a permission on the same (envoy,target,selector) tuple multiple types.\n    ///\n    /// Requirements:\n    /// - The caller must be the owner.\n    ///\n    /// @param envoy The address of the envoy account.\n    /// @param target The address of the target contract.\n    /// @param selector The 4 byte function selector on the target contract.\n    /// @param permission The boolean permission to set.\n    function setPermission(\n        address envoy,\n        address target,\n        bytes4 selector,\n        bool permission\n    ) external;\n\n    /// @notice Transfers the owner of the contract to a new account.\n    /// @dev Requirements:\n    /// - The caller must be the owner.\n    /// @param newOwner The address of the new owner account.\n    function transferOwnership(address newOwner) external;\n}\n/// @title IPRBProxyFactory\n/// @author Paul Razvan Berg\n/// @notice Deploys new proxies with CREATE2.\ninterface IPRBProxyFactory {\n    /// EVENTS ///\n\n    event DeployProxy(\n        address indexed origin,\n        address indexed deployer,\n        address indexed owner,\n        bytes32 seed,\n        bytes32 salt,\n        address proxy\n    );\n\n    /// PUBLIC CONSTANT FUNCTIONS ///\n\n    /// @notice Gets the next seed that will be used to deploy the proxy.\n    /// @param eoa The externally owned account that will own the proxy.\n    function getNextSeed(address eoa) external view returns (bytes32 result);\n\n    /// @notice Mapping to track all deployed proxies.\n    /// @param proxy The address of the proxy to make the check for.\n    function isProxy(address proxy) external view returns (bool result);\n\n    /// @notice The release version of PRBProxy.\n    /// @dev This is stored in the factory rather than the proxy to save gas for end users.\n    function version() external view returns (uint256);\n\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n    /// @notice Deploys a new proxy via CREATE2.\n    /// @dev Sets \"msg.sender\" as the owner of the proxy.\n    /// @return proxy The address of the newly deployed proxy contract.\n    function deploy() external returns (address payable proxy);\n\n    /// @notice Deploys a new proxy via CREATE2, for the given owner.\n    /// @param owner The owner of the proxy.\n    /// @return proxy The address of the newly deployed proxy contract.\n    function deployFor(address owner) external returns (address payable proxy);\n}\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\n\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\n\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\n\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\n\n\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\n\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\n\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n/// @notice Emitted when the caller is not the owner.\nerror PRBProxy__ExecutionNotAuthorized(address owner, address caller, address target, bytes4 selector);\n\n/// @notice Emitted when execution reverted with no reason.\nerror PRBProxy__ExecutionReverted();\n\n/// @notice Emitted when the caller is not the owner.\nerror PRBProxy__NotOwner(address owner, address caller);\n\n/// @notice Emitted when the owner is changed during the DELEGATECALL.\nerror PRBProxy__OwnerChanged(address originalOwner, address newOwner);\n\n/// @notice Emitted when passing an EOA or an undeployed contract as the target.\nerror PRBProxy__TargetInvalid(address target);\n\n/// @title PRBProxy\n/// @author Paul Razvan Berg\ncontract PRBProxy is IPRBProxy, ERC1155Holder, ERC721Holder {\n    /// PUBLIC STORAGE ///\n\n    /// @inheritdoc IPRBProxy\n    address public override owner;\n\n    /// @inheritdoc IPRBProxy\n    uint256 public override minGasReserve;\n\n    /// INTERNAL STORAGE ///\n\n    /// @notice Maps envoys to target contracts to function selectors to boolean flags.\n    mapping(address => mapping(address => mapping(bytes4 => bool))) internal permissions;\n\n    /// CONSTRUCTOR ///\n\n    constructor() {\n        minGasReserve = 5_000;\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    /// FALLBACK FUNCTION ///\n\n    /// @dev Called when Ether is sent and the call data is empty.\n    receive() external payable {}\n\n    /// PUBLIC CONSTANT FUNCTIONS ///\n\n    /// @inheritdoc IPRBProxy\n    function getPermission(\n        address envoy,\n        address target,\n        bytes4 selector\n    ) external view override returns (bool) {\n        return permissions[envoy][target][selector];\n    }\n\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n    /// @inheritdoc IPRBProxy\n    function execute(address target, bytes calldata data) external payable override returns (bytes memory response) {\n        // Check that the caller is either the owner or an envoy.\n        if (owner != msg.sender) {\n            bytes4 selector;\n            assembly {\n                selector := calldataload(data.offset)\n            }\n            if (!permissions[msg.sender][target][selector]) {\n                revert PRBProxy__ExecutionNotAuthorized(owner, msg.sender, target, selector);\n            }\n        }\n\n        // Check that the target is a valid contract.\n        if (target.code.length == 0) {\n            revert PRBProxy__TargetInvalid(target);\n        }\n\n        // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\n        address owner_ = owner;\n\n        // Reserve some gas to ensure that the function has enough to finish the execution.\n        uint256 stipend = gasleft() - minGasReserve;\n\n        // Delegate call to the target contract.\n        bool success;\n        (success, response) = target.delegatecall{ gas: stipend }(data);\n\n        // Check that the owner has not been changed.\n        if (owner_ != owner) {\n            revert PRBProxy__OwnerChanged(owner_, owner);\n        }\n\n        // Log the execution.\n        emit Execute(target, data, response);\n\n        // Check if the call was successful or not.\n        if (!success) {\n            // If there is return data, the call reverted with a reason or a custom error.\n            if (response.length > 0) {\n                assembly {\n                    let returndata_size := mload(response)\n                    revert(add(32, response), returndata_size)\n                }\n            } else {\n                revert PRBProxy__ExecutionReverted();\n            }\n        }\n    }\n\n    /// @inheritdoc IPRBProxy\n    function setPermission(\n        address envoy,\n        address target,\n        bytes4 selector,\n        bool permission\n    ) external override {\n        if (owner != msg.sender) {\n            revert PRBProxy__NotOwner(owner, msg.sender);\n        }\n        permissions[envoy][target][selector] = permission;\n    }\n\n    /// @inheritdoc IPRBProxy\n    function transferOwnership(address newOwner) external override {\n        address oldOwner = owner;\n        if (oldOwner != msg.sender) {\n            revert PRBProxy__NotOwner(oldOwner, msg.sender);\n        }\n        owner = newOwner;\n        emit TransferOwnership(oldOwner, newOwner);\n    }\n}\n\n/// @title PRBProxyFactory\n/// @author Paul Razvan Berg\ncontract PRBProxyFactory is IPRBProxyFactory {\n    /// PUBLIC STORAGE ///\n\n    /// @inheritdoc IPRBProxyFactory\n    uint256 public constant override version = 2;\n\n    /// INTERNAL STORAGE ///\n\n    /// @dev Internal mapping to track all deployed proxies.\n    mapping(address => bool) internal proxies;\n\n    /// @dev Internal mapping to track the next seed to be used by an EOA.\n    mapping(address => bytes32) internal nextSeeds;\n\n    /// PUBLIC CONSTANT FUNCTIONS ///\n\n    /// @inheritdoc IPRBProxyFactory\n    function getNextSeed(address eoa) external view override returns (bytes32 nextSeed) {\n        nextSeed = nextSeeds[eoa];\n    }\n\n    /// @inheritdoc IPRBProxyFactory\n    function isProxy(address proxy) external view override returns (bool result) {\n        result = proxies[proxy];\n    }\n\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n    /// @inheritdoc IPRBProxyFactory\n    function deploy() external override returns (address payable proxy) {\n        proxy = deployFor(msg.sender);\n    }\n\n    /// @inheritdoc IPRBProxyFactory\n    function deployFor(address owner) public override returns (address payable proxy) {\n        bytes32 seed = nextSeeds[tx.origin];\n\n        // Prevent front-running the salt by hashing the concatenation of \"tx.origin\" and the user-provided seed.\n        bytes32 salt = keccak256(abi.encode(tx.origin, seed));\n\n        // Deploy the proxy with CREATE2.\n        proxy = payable(new PRBProxy{ salt: salt }());\n\n        // Transfer the ownership from this factory contract to the specified owner.\n        IPRBProxy(proxy).transferOwnership(owner);\n\n        // Mark the proxy as deployed.\n        proxies[proxy] = true;\n\n        // Increment the seed.\n        unchecked {\n            nextSeeds[tx.origin] = bytes32(uint256(seed) + 1);\n        }\n\n        // Log the proxy via en event.\n        emit DeployProxy(tx.origin, msg.sender, owner, seed, salt, address(proxy));\n    }\n}\n", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"DeployProxy\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"deployFor\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"eoa\",\"type\":\"address\"}],\"name\":\"getNextSeed\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"nextSeed\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"isProxy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PRBProxyFactory", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "8000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}