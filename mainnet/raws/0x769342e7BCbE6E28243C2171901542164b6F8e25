{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NFTVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"./tokens/ERC721.sol\\\";\\nimport \\\"./tokens/ERC20.sol\\\";\\nimport \\\"./utils/owner.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\ncontract RapPearsNft is ERC721, Owner {\\n    using Strings for *;\\n    ///=============================================================================================\\n    /// Data Struct\\n    ///=============================================================================================\\n\\n    struct Rewards {\\n        uint256 weight;\\n        uint256 tracker; //sum of delta(deposit) * yeildPerDeposit || SCALED\\n    }\\n\\n    struct MetaData {\\n        string name;\\n        address vaultAddress;\\n        uint256 withdrawable;\\n        uint256 id;\\n        uint256 vaultType;\\n    }\\n\\n    ///=============================================================================================\\n    /// Accounting State\\n    ///=============================================================================================\\n\\n    // tokenID => Deposits\\n    mapping(uint256 => Rewards) public deposits;\\n\\n    //sum of yeild/totalWeight scaled by SCALAR\\n    uint256 public yeildPerDeposit;\\n\\n    uint256 public totalWeight;\\n\\n    uint256 constant SCALAR = 1e10;\\n\\n    ///=============================================================================================\\n    /// Rappears\\n    ///=============================================================================================\\n\\n    // tokenId => lockUp timestamp\\n    mapping(uint256 => uint256) locked;\\n    uint256 internal lockTimeSeconds;\\n\\n    mapping(uint256 => mapping(address => bool)) privateMintClaimed;\\n\\n    mapping(uint256 => mapping(uint256 => uint256)) public qtyPricing;\\n    uint256 public defaultPricePerUnit = 1e17;\\n    uint256 public pricingVersionCount = 1;\\n\\n    uint256 public maxWhitelistMintPerTx;\\n\\n    bool internal publicMint;\\n    uint256 internal supplyCap;\\n\\n    mapping(address => uint256[]) public tokensByAddress;\\n\\n    // returns the current index in the tokensByAddress array\\n    mapping(uint256 => uint256) internal indexById;\\n\\n    ///=============================================================================================\\n    /// Misc\\n    ///=============================================================================================\\n\\n    ERC20 public weth;\\n\\n    uint256 internal devFeeBP;\\n\\n    uint256 public devBalance;\\n\\n    uint256 internal currentId;\\n\\n    ///=============================================================================================\\n    /// External Logic\\n    ///=============================================================================================\\n\\n    constructor(\\n        address _weth,\\n        uint256 _devFeeBP,\\n        uint256 _lockTime,\\n        uint256 _initalSupplyCap,\\n        uint256 _initialMintAmount,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC721(_name, _symbol) {\\n        weth = ERC20(_weth);\\n        devFeeBP = _devFeeBP;\\n        lockTimeSeconds = _lockTime;\\n        supplyCap = _initalSupplyCap;\\n\\n        for (uint256 i; i < _initialMintAmount; ) {\\n            _mintNewNFT();\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function adminMint(uint256 amount)\\n        external\\n        onlyOwner\\n        returns (uint256[] memory)\\n    {\\n        _takeFees();\\n        uint256[] memory ret = new uint256[](amount);\\n\\n        for (uint256 i; i < amount; ) {\\n            ret[i] = _mintNewNFT();\\n            // unlikely to overflow\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return ret;\\n    }\\n\\n    function mintNewNft(uint256 amount)\\n        external\\n        payable\\n        returns (uint256[] memory)\\n    {\\n        require(price(amount) <= msg.value, \\\"underpaid\\\");\\n        require(publicMint, \\\"not live\\\");\\n\\n        _takeFees();\\n\\n        uint256[] memory ret = new uint256[](amount);\\n\\n        for (uint256 i; i < amount; ) {\\n            ret[i] = _mintNewNFT();\\n\\n            // unlikely to overflow\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n\\n    function lockUp(uint256 id) external {\\n        require(msg.sender == ownerOf(id), \\\"Not Owner\\\");\\n\\n        locked[id] = block.timestamp;\\n        deposits[id].weight = 100; // 100 = 1 weight\\n        deposits[id].tracker += 100 * yeildPerDeposit;\\n        totalWeight += 100;\\n    }\\n\\n    event A(uint256);\\n\\n    function withdrawFromId(uint256 id, uint256 amount) public {\\n        require(\\n            block.timestamp - locked[id] >= lockTimeSeconds && locked[id] != 0,\\n            \\\"here\\\"\\n        );\\n\\n        locked[id] = 0;\\n\\n        _withdrawFromId(amount, id);\\n    }\\n\\n    function bundleWithdraw() external {\\n        uint256 length = tokensByAddress[msg.sender].length;\\n        for (uint256 i; i < length; ) {\\n            uint256 id = tokensByAddress[msg.sender][i];\\n            if (\\n                block.timestamp - locked[id] >= lockTimeSeconds &&\\n                locked[id] != 0\\n            ) {\\n                withdrawFromId(id, withdrawableById(id));\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function withdrawableById(uint256 id)\\n        public\\n        view\\n        returns (uint256 claimId)\\n    {\\n        return yieldPerId(id);\\n    }\\n\\n    function claimDevFeeBPs() external onlyOwner {\\n        weth.transfer(owner, devBalance);\\n    }\\n\\n    ///=============================================================================================\\n    /// Internal Logic\\n    ///=============================================================================================\\n\\n    function _mintNewNFT() internal returns (uint256) {\\n        uint256 id = ++currentId;\\n        require(currentId <= supplyCap);\\n\\n        _mint(msg.sender, id);\\n        _addId(msg.sender, id);\\n\\n        return id;\\n    }\\n\\n    function _withdrawFromId(uint256 amount, uint256 id) internal {\\n        require(msg.sender == ownerOf(id) && amount <= withdrawableById(id));\\n\\n        deposits[id].weight = 0; // user ceases to earn yield\\n        deposits[id].tracker = 0;\\n        totalWeight -= 100;\\n\\n        weth.transfer(msg.sender, amount);\\n    }\\n\\n    function _takeFees() internal {\\n        // grieifing is a non issue here\\n        (bool success, ) = payable(address(weth)).call{value: msg.value}(\\\"\\\");\\n        require(success);\\n\\n        uint256 toDev = (msg.value * devFeeBP) / 10000;\\n        devBalance += toDev;\\n\\n        if (totalWeight > 0) {\\n            distributeYeild(msg.value - toDev);\\n        } else {\\n            devBalance += (msg.value - toDev);\\n        }\\n    }\\n\\n    // add to list of ID by address\\n    function _addId(address who, uint256 id) internal {\\n        tokensByAddress[who].push(id);\\n\\n        indexById[id] = tokensByAddress[who].length - 1;\\n    }\\n\\n    // remove from list of id by address\\n    function _removeId(address who, uint256 id) internal {\\n        uint256 index = indexById[id]; // get index of value to remove\\n\\n        uint256 lastVal = tokensByAddress[who][tokensByAddress[who].length - 1]; // get last val from array\\n\\n        tokensByAddress[who][index] = lastVal; // set last value to remove index of value to remove\\n\\n        tokensByAddress[who].pop(); //pop off the now duplicate value\\n    }\\n\\n    ///=============================================================================================\\n    /// Yield\\n    ///=============================================================================================\\n\\n    function distributeYeild(uint256 amount) public virtual {\\n        yeildPerDeposit += ((amount * SCALAR) / totalWeight);\\n    }\\n\\n    function yieldPerId(uint256 id) public view returns (uint256) {\\n        uint256 pre = (deposits[id].weight * yeildPerDeposit) / SCALAR;\\n        return pre - (deposits[id].tracker / SCALAR);\\n    }\\n\\n    ///=============================================================================================\\n    /// Pricing\\n    ///=============================================================================================\\n\\n    function price(uint256 _count) public view returns (uint256) {\\n        uint256 pricePerUnit = qtyPricing[pricingVersionCount][_count];\\n        // Mint more than max discount reverts to max discount\\n        if (_count > maxWhitelistMintPerTx) {\\n            pricePerUnit = qtyPricing[pricingVersionCount][\\n                maxWhitelistMintPerTx\\n            ];\\n        }\\n        // Minting an undefined discount price uses defaults price\\n        if (pricePerUnit == 0) {\\n            pricePerUnit = defaultPricePerUnit;\\n        }\\n        return pricePerUnit * _count;\\n    }\\n\\n    ///=============================================================================================\\n    /// Whitelist\\n    ///=============================================================================================\\n\\n    function whitelistMint(\\n        uint256 amount,\\n        uint256 whitelistNonce,\\n        bytes32 msgHash,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) public payable returns (uint256[] memory) {\\n        require(msg.value >= price(amount), \\\"Value below price\\\");\\n        require(\\n            !privateMintClaimed[whitelistNonce][msg.sender],\\n            \\\"Already claimed!\\\"\\n        );\\n\\n        // Security check.\\n        bytes32 calculatedMsgHash = keccak256(\\n            abi.encodePacked(msg.sender, amount, whitelistNonce)\\n        );\\n\\n        address signer = ecrecover(\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", msgHash)\\n            ),\\n            _v,\\n            _r,\\n            _s\\n        );\\n        require(calculatedMsgHash == msgHash, \\\"Invalid hash\\\");\\n        require(owner == signer, \\\"Access denied\\\");\\n\\n        // Let's mint!\\n        privateMintClaimed[whitelistNonce][msg.sender] = true;\\n\\n        _takeFees();\\n\\n        uint256[] memory ret = new uint256[](amount);\\n\\n        for (uint256 i; i < amount; ) {\\n            ret[i] = _mintNewNFT();\\n            // unlikely to overflow\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n\\n    ///=============================================================================================\\n    /// Setters\\n    ///=============================================================================================\\n\\n    function setLockTime(uint256 _lockTime) external onlyOwner {\\n        lockTimeSeconds = _lockTime;\\n    }\\n\\n    function setMaxWhiteList(uint256 amount) public onlyOwner {\\n        maxWhitelistMintPerTx = amount;\\n    }\\n\\n    function setMintPrices(\\n        uint256 _defaultPricePerUnit,\\n        uint256[] memory qty,\\n        uint256[] memory prices\\n    ) public onlyOwner {\\n        require(\\n            qty.length == prices.length,\\n            \\\"Qty input vs price length mismatch\\\"\\n        );\\n        defaultPricePerUnit = _defaultPricePerUnit;\\n        ++pricingVersionCount;\\n\\n        bool containsMaxWhitelistMintPerTx = false;\\n        for (uint256 i = 0; i < qty.length; i++) {\\n            if (qty[i] == maxWhitelistMintPerTx) {\\n                containsMaxWhitelistMintPerTx = true;\\n            }\\n            qtyPricing[pricingVersionCount][qty[i]] = prices[i];\\n        }\\n        require(\\n            containsMaxWhitelistMintPerTx,\\n            \\\"prices do not include the max mint price\\\"\\n        );\\n    }\\n\\n    function setSupplyCap(uint256 total) external onlyOwner {\\n        supplyCap = total;\\n    }\\n\\n    function setPublicMint(bool open) external onlyOwner {\\n        publicMint = open;\\n    }\\n\\n    ///=============================================================================================\\n    /// Overrides\\n    ///=============================================================================================\\n\\n    string public ipfsLink;\\n\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(ipfsLink, tokenId.toString(), \\\".json\\\"));\\n    }\\n\\n    function setTokenUri(string memory baseURI) public onlyOwner {\\n        ipfsLink = baseURI;\\n    }\\n\\n    function totalSupply() public view returns (uint256) {\\n        return supplyCap;\\n    }\\n\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public override {\\n        require(\\n            locked[id] == 0 || locked[id] - block.timestamp >= lockTimeSeconds\\n        );\\n\\n        locked[id] = 0;\\n\\n        _removeId(from, id);\\n        _addId(to, id);\\n\\n        super.transferFrom(from, to, id);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\"\r\n    },\r\n    \"contracts/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/owner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @title Owner\\n/// @notice Transferrable owner authorization pattern.\\nabstract contract Owner {\\n\\n    ///===========================\\n    /// STATE\\n    ///===========================\\n\\n    /// @notice Emitted when the ownership is changed\\n    /// @param previousOwner Previous owner of the contract.\\n    /// @param newOwner New owner of the contract.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Current owner of the contract.\\n    address public owner;\\n\\n    ///@notice Modifier to verify that the sender is the owner of the contract.\\n    modifier onlyOwner() {\\n        require (msg.sender == owner, \\\"NOT_OWNER\\\");\\n        _;\\n    }\\n\\n    ///===========================\\n    /// INIT\\n    ///===========================\\n\\n    ///@notice Initially set the owner as the contract deployer.\\n    constructor() {\\n        _transferOwnership(msg.sender);\\n    }\\n\\n    ///===========================\\n    /// FUNCTIONS\\n    ///===========================\\n\\n    /// @notice Transfer the ownership of the contract.\\n    /// @param newOwner Address ownership is to be transferred to.\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    ///===========================\\n    /// INTERNAL\\n    ///===========================\\n\\n    /// @notice Transfer the ownership of the contract.\\n    /// @param newOwner Address ownership is to be transferred to.\\n    function _transferOwnership(address newOwner) internal {\\n        address oldOwner = owner;\\n        owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    \\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_devFeeBP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initalSupplyCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialMintAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"A\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"adminMint\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bundleWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDevFeeBPs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultPricePerUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tracker\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"distributeYeild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ipfsLink\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"lockUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWhitelistMintPerTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintNewNft\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pricingVersionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"qtyPricing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockTime\",\"type\":\"uint256\"}],\"name\":\"setLockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_defaultPricePerUnit\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"qty\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"name\":\"setMintPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"}],\"name\":\"setPublicMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"setSupplyCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"setTokenUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"whitelistNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"whitelistMint\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"withdrawableById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yeildPerDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"yieldPerId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RapPearsNft", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000001388000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000c52617070656172734e465473000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000085241505045415253000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}