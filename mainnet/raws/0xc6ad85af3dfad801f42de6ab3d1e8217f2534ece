{"status": "1", "message": "OK", "result": [{"SourceCode": "/*\n_____/\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\________/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\___        \n ___/\\\\\\/////////\\\\\\_\\/\\\\\\_____/\\\\\\//__\\/////\\\\\\///__\\/\\\\\\///////////____/\\\\\\/////////\\\\\\_       \n  __\\//\\\\\\______\\///__\\/\\\\\\__/\\\\\\//_________\\/\\\\\\_____\\/\\\\\\______________\\//\\\\\\______\\///__      \n   ___\\////\\\\\\_________\\/\\\\\\\\\\\\//\\\\\\_________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\_______\\////\\\\\\_________     \n    ______\\////\\\\\\______\\/\\\\\\//_\\//\\\\\\________\\/\\\\\\_____\\/\\\\\\///////___________\\////\\\\\\______    \n     _________\\////\\\\\\___\\/\\\\\\____\\//\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________________\\////\\\\\\___   \n      __/\\\\\\______\\//\\\\\\__\\/\\\\\\_____\\//\\\\\\______\\/\\\\\\_____\\/\\\\\\______________/\\\\\\______\\//\\\\\\__  \n       _\\///\\\\\\\\\\\\\\\\\\\\\\/___\\/\\\\\\______\\//\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\///\\\\\\\\\\\\\\\\\\\\\\/___ \n        ___\\///////////_____\\///________\\///__\\///////////__\\///////////////____\\///////////_____\n\nby tries.eth\n*/\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\n\n\n/**\n * @dev String operations.\n */\nlibrary CustomStrings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * Edited from OpenZeppelin's implementation\n     * Returns hex string without leading 0x\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory buffer = new bytes(2 * length);\n\n        for (uint256 i = 2 * length; i > 0; --i) {\n            buffer[i - 1] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n\n        return string(buffer);\n    }\n}\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsDateTimeLibrary {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 constant SECONDS_PER_MINUTE = 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 _days) {\n        require(year >= 1970);\n        int256 _year = int256(year);\n        int256 _month = int256(month);\n        int256 _day = int256(day);\n\n        int256 __days = _day -\n            32075 +\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\n            4 +\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\n            12 -\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\n            4 -\n            OFFSET19700101;\n\n        _days = uint256(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint256 _days)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        int256 __days = int256(_days);\n\n        int256 L = __days + 68569 + OFFSET19700101;\n        int256 N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int256 _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int256 _month = (80 * L) / 2447;\n        int256 _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint256(_year);\n        month = uint256(_month);\n        day = uint256(_day);\n    }\n\n    function timestampFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n}\n\n\nlibrary MathHelpers {\n    using CustomStrings for uint256;\n\n    struct ComputationData {\n        uint256 a;\n        uint256 b;\n        uint256 c;\n        uint256 d;\n        uint256 e;\n    }\n\n    struct StageAndProgressResult {\n        uint256 stage;\n        uint256 percentageOfStage;\n        uint256 currentYear;\n        uint256 currentMonth;\n        uint256 currentDay;\n        string description;\n    }\n\n    // sqrt approximation\n    function sqrt(int256 x) internal pure returns (int256 y) {\n        int256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    // Bhaskara\u2019s Approximation Formula for Sine\n    function sin(\n        int256 angle // deg * 100\n    ) internal pure returns (int256) {\n        int256 correctedAngle;\n        int8 sign;\n        int16 oneHundredEightyDeg = 180 * 100;\n\n        if (angle > oneHundredEightyDeg) {\n            // trig relation: cos(x) = -cos(x - 180)\n            correctedAngle = angle - (oneHundredEightyDeg);\n            sign = -1;\n        } else {\n            correctedAngle = angle;\n            sign = 1;\n        }\n\n        int256 rad = (10000 * 4 * correctedAngle * ((18000) - correctedAngle)) /\n            (405000000 - (correctedAngle * ((18000) - correctedAngle)));\n\n        return sign * rad; // rad * 10000\n    }\n\n    // Trig relation: cos(x) = sin(90 - x)\n    function cos(\n        int256 angle // deg * 100\n    ) internal pure returns (int256) {\n        int256 correctedAngle;\n        int8 sign;\n        int16 oneHundredEightyDeg = 180 * 100;\n\n        if (angle > oneHundredEightyDeg) {\n            // trig relation: cos(x) = -cos(x - 180)\n            correctedAngle = angle - (oneHundredEightyDeg);\n            sign = -1;\n        } else {\n            correctedAngle = angle;\n            sign = 1;\n        }\n\n        int256 sinAngle = (90 * 100) - correctedAngle;\n\n        return sign * sin(sinAngle);\n    }\n\n    // Trig relation: tan(x) = sin(x) / cos(x)\n    function tan(\n        int256 angle // deg * 100\n    ) internal pure returns (int256) {\n        require(angle != 9000, \"tan(90) is NaN\");\n        return (10000 * sin(angle)) / cos(angle); // rad\n    }\n\n    // Approximation of arccosine\n    function acos(\n        int256 angle // rad * 10000\n    ) internal pure returns (int256) {\n        int256 value1 = 2000000;\n        int256 value3 = 200;\n        int256 eight_thirds = 2666;\n\n        int256 a = sqrt(value1 + (value3 * angle));\n        int256 b = sqrt(value1 - (value3 * angle));\n        int256 c = sqrt(200000000 - (100000 * a));\n\n        return ((eight_thirds * c) - ((10000 * b) / 3));\n    }\n\n    //\n    // Astronomical Equations\n    //\n\n    function delta(int256 daysSinceVernalEquinox)\n        internal\n        pure\n        returns (int256)\n    {\n        int256 a = (100 * 360 * daysSinceVernalEquinox) / 365;\n        int256 b = sin(a);\n        int256 c = 41 * b;\n\n        return c;\n    }\n\n    function tau(int256 latitude, int256 daysSinceVernalEquinox)\n        internal\n        pure\n        returns (int256)\n    {\n        int256 tanBeta = tan(latitude); // rad * 10,000\n\n        int256 deltaFromVernalEquinox = delta(daysSinceVernalEquinox);\n        int256 tanDelta = tan((deltaFromVernalEquinox * 180) / 31415); // rad * 10,000\n\n        int256 cosTau = -1 * (tanBeta / 100) * (tanDelta / 100);\n        int256 tauRes = acos(cosTau);\n\n        return tauRes;\n    }\n\n    function secondsOffset(int256 longitude) internal pure returns (int256) {\n        return (longitude * 240) / 100; // deg * 240 (deg are multiplied by 100)\n    }\n\n    // Shortened algorithm for calculating the length\n    // of a day for a given day of the year and latitude\n    //\n    // http://www.jgiesen.de/astro/solarday.htm\n    //\n\n    function hoursToCulmination(int256 latitude, uint256 daysSinceVernalEquinox)\n        internal\n        pure\n        returns (uint256)\n    {\n        int256 tauFromVernalEquinoxAndLatitude = tau(\n            latitude,\n            int256(daysSinceVernalEquinox)\n        );\n\n        int256 pi = 314159;\n\n        int256 degrees = (tauFromVernalEquinoxAndLatitude * 180) / pi;\n\n        int256 percentOfDayToCulmination = (degrees * 100) / 360;\n\n        int256 daylightHoursToCulmination = (percentOfDayToCulmination * 24) /\n            10;\n\n        return uint256(daylightHoursToCulmination);\n    }\n\n    function currentDaysSinceEquinox(int256 longitude, uint256 currentSeconds)\n        internal\n        pure\n        returns (ComputationData memory)\n    {\n        uint256 longitudeOffsetSeconds = uint256(\n            int256(currentSeconds) + secondsOffset(longitude)\n        );\n\n        (\n            uint256 currentYear,\n            uint256 currentMonth,\n            uint256 currentDay\n        ) = BokkyPooBahsDateTimeLibrary.timestampToDate(longitudeOffsetSeconds);\n\n        uint256 march21SecondsSinceEpoch = BokkyPooBahsDateTimeLibrary\n            .timestampFromDate(\n                currentMonth > 3 ? currentYear : currentYear - 1,\n                3,\n                21\n            );\n\n        uint256 differenceSeconds = longitudeOffsetSeconds -\n            march21SecondsSinceEpoch;\n\n        uint256 differenceDays = differenceSeconds / 86400;\n\n        uint256 remainderSecondsToday = differenceSeconds % 86400;\n\n        uint256 daysSinceEquinox = differenceDays % 365;\n\n        return\n            ComputationData({\n                a: daysSinceEquinox,\n                b: remainderSecondsToday,\n                c: currentYear,\n                d: currentMonth,\n                e: currentDay\n            });\n    }\n\n    function stageCompletion(\n        uint256 currentSeconds,\n        uint256 stageStartSeconds,\n        uint256 stageEndSeconds\n    ) internal pure returns (uint256) {\n        uint256 stageLength = stageEndSeconds - stageStartSeconds;\n        uint256 currentStageLength = currentSeconds - stageStartSeconds;\n\n        return (currentStageLength * 100) / stageLength;\n    }\n\n    function liveHoursToCulmination(\n        int256 latitude,\n        int256 longitude,\n        uint256 currentSeconds\n    ) internal pure returns (ComputationData memory) {\n        ComputationData memory daysSinceEquinoxRes = currentDaysSinceEquinox(\n            longitude,\n            currentSeconds\n        );\n\n        return\n            ComputationData(\n                hoursToCulmination(latitude, daysSinceEquinoxRes.a), // hours * 100\n                daysSinceEquinoxRes.b, // currentSecondsToday\n                daysSinceEquinoxRes.c, // currentYear\n                daysSinceEquinoxRes.d, // currentMonth\n                daysSinceEquinoxRes.e // currentDay\n            );\n    }\n\n    function updatedPercentage(\n        uint256 percentageOfStage,\n        uint256 breakPointPercentage\n    ) internal pure returns (uint256) {\n        uint256 scalePercentage = breakPointPercentage / 10;\n\n        return\n            percentageOfStage <= breakPointPercentage\n                ? (percentageOfStage * 10) / scalePercentage\n                : ((percentageOfStage - breakPointPercentage) * 10) /\n                    (10 - scalePercentage);\n    }\n\n    function baseDescription(\n        uint256 stageLengthSeconds,\n        uint256 baseStageCompletionPercentage,\n        bool relativeToStart,\n        string memory context\n    ) internal pure returns (string memory) {\n        uint256 relevantHours;\n        if (relativeToStart) {\n            relevantHours =\n                (stageLengthSeconds * baseStageCompletionPercentage) /\n                360000;\n        } else {\n            relevantHours =\n                (stageLengthSeconds * (100 - baseStageCompletionPercentage)) /\n                360000;\n        }\n\n        string memory hoursDescription = relevantHours == 0\n            ? \"just \"\n            : string.concat(\n                relevantHours.toString(),\n                \" hour\",\n                relevantHours == 1 ? \" \" : \"s \"\n            );\n\n        return\n            string.concat(\n                hoursDescription,\n                relativeToStart ? \"after \" : \"before \",\n                context\n            );\n    }\n\n    function liveStageAndProgress(\n        int256 latitude,\n        int256 longitude,\n        uint256 currentSeconds\n    ) internal pure returns (StageAndProgressResult memory) {\n        ComputationData memory hoursToCulminationRes = liveHoursToCulmination(\n            latitude,\n            longitude,\n            currentSeconds\n        );\n\n        uint256 secondsToCulmination = (hoursToCulminationRes.a * 3600) / 1000;\n        uint256 noonSeconds = 43200; // seconds from midnight to midday\n\n        uint256 sunriseSeconds = noonSeconds - secondsToCulmination;\n        uint256 sunsetSeconds = noonSeconds + secondsToCulmination;\n\n        // get the correct \"stage\" and percentage of stage\n        uint256 stage;\n        uint256 percentageOfStage;\n        string memory description;\n\n        if (hoursToCulminationRes.b < sunriseSeconds) {\n            // midnight -> sunrise\n            percentageOfStage = stageCompletion(\n                hoursToCulminationRes.b,\n                0,\n                sunriseSeconds\n            );\n\n            description = baseDescription(\n                sunriseSeconds,\n                percentageOfStage,\n                percentageOfStage <= 50,\n                percentageOfStage <= 50 ? \"solar midnight\" : \"sunrise\"\n            );\n\n            stage = percentageOfStage <= 90 ? 0 : 1; // 90% from midnight to sunrise\n            percentageOfStage = updatedPercentage(percentageOfStage, 90);\n        } else if (hoursToCulminationRes.b < noonSeconds) {\n            // sunrise -> noon\n            percentageOfStage = stageCompletion(\n                hoursToCulminationRes.b,\n                sunriseSeconds,\n                noonSeconds\n            );\n\n            stage = percentageOfStage <= 50 ? 2 : 3; // 50% from sunrise to noon\n\n            description = baseDescription(\n                noonSeconds - sunriseSeconds,\n                percentageOfStage,\n                stage == 2,\n                stage == 2 ? \"sunrise\" : \"solar noon\"\n            );\n\n            percentageOfStage = updatedPercentage(percentageOfStage, 50);\n        } else if (hoursToCulminationRes.b < sunsetSeconds) {\n            // noon -> sunset\n            percentageOfStage = stageCompletion(\n                hoursToCulminationRes.b,\n                noonSeconds,\n                sunsetSeconds\n            );\n\n            stage = percentageOfStage <= 50 ? 4 : 5; // 50% from noon to sunset\n\n            description = baseDescription(\n                sunsetSeconds - noonSeconds,\n                percentageOfStage,\n                stage == 4,\n                stage == 4 ? \"solar noon\" : \"sunset\"\n            );\n\n            percentageOfStage = updatedPercentage(percentageOfStage, 50);\n        } else {\n            // sunset -> midnight\n            percentageOfStage = stageCompletion(\n                hoursToCulminationRes.b,\n                sunsetSeconds,\n                86400 // 24 hours (midnight)\n            );\n\n            description = baseDescription(\n                86400 - sunsetSeconds,\n                percentageOfStage,\n                percentageOfStage <= 50,\n                percentageOfStage <= 50 ? \"sunset\" : \"solar midnight\"\n            );\n\n            stage = percentageOfStage <= 10 ? 6 : 7; // 30% from sunset to midnight\n            percentageOfStage = updatedPercentage(percentageOfStage, 10);\n        }\n\n        return\n            StageAndProgressResult(\n                stage,\n                percentageOfStage,\n                hoursToCulminationRes.c,\n                hoursToCulminationRes.d,\n                hoursToCulminationRes.e,\n                description\n            );\n    }\n}\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n    bytes internal constant TABLE =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /// @notice Encodes some bytes to the base64 representation\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint256 len = data.length;\n        if (len == 0) return \"\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((len + 2) / 3);\n\n        // Add some extra buffer at the end\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes memory table = TABLE;\n\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n\n            for {\n                let i := 0\n            } lt(i, len) {\n\n            } {\n                i := add(i, 3)\n                let input := and(mload(add(data, i)), 0xffffff)\n\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF)\n                )\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF)\n                )\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(input, 0x3F))), 0xFF)\n                )\n                out := shl(224, out)\n\n                mstore(resultPtr, out)\n\n                resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n\n            mstore(result, encodedLen)\n        }\n\n        return string(result);\n    }\n}\n\nstruct StageColorData {\n    uint256 topColor;\n    uint256 bottomColor;\n    uint256 topOffsetPercentage;\n    uint256 bottomOffsetPercentage;\n}\n\nstruct SkyMetadata {\n    string locationName;\n    int256 latitude;\n    int256 longitude;\n}\n\ncontract SkyRenderer is Ownable {\n    using CustomStrings for uint256;\n    using Base64 for *;\n\n    // Colors to use for rendering sky\n    StageColorData[8] internal stageColorsData; // 0 - midnight, 2 - sunrise, 4 - noon, 6 - sunset\n\n    constructor() {}\n\n    // ========     ========\n    // ======= OWNER =======\n    // ========     ========\n\n    function setStageColors(StageColorData[8] calldata stageColors)\n        external\n        onlyOwner\n    {\n        for (uint256 n = 0; n < stageColors.length; n++) {\n            stageColorsData[n] = stageColors[n];\n        }\n    }\n\n    // ========     ========\n    // ======= RENDER ======\n    // ========     ========\n\n    function renderSky(\n        uint256 tokenId,\n        string calldata locationName,\n        int256 latitude,\n        int256 longitude\n    ) public view returns (string memory) {\n        MathHelpers.StageAndProgressResult memory computationRes = MathHelpers\n            .liveStageAndProgress(latitude, longitude, block.timestamp);\n\n        bytes memory dateString = bytes.concat(\n            bytes(computationRes.currentYear.toString()),\n            \".\",\n            bytes(computationRes.currentMonth.toString()),\n            \".\",\n            bytes(computationRes.currentDay.toString())\n        );\n\n        bytes memory tokenName = bytes.concat(\n            \"The sky over \",\n            bytes(locationName),\n            \" on \",\n            dateString\n        );\n\n        bytes memory tokenDescription = bytes.concat(\n            tokenName,\n            \" \",\n            bytes(computationRes.description),\n            \".\"\n        );\n\n        bytes memory attributes = bytes.concat(\n            '\"viewed_at\": \"',\n            dateString,\n            '\", \"location_name\": \"',\n            bytes(locationName),\n            '\", \"latitude\": \"',\n            bytes(intDegToString(latitude)),\n            '\", \"longitude\": \"',\n            bytes(intDegToString(longitude)),\n            '\", \"stage\": \"',\n            bytes(computationRes.stage.toString()),\n            '\", \"percentage\": \"',\n            bytes(computationRes.percentageOfStage.toString())\n        );\n\n        bytes memory tokenUriMetadata = bytes.concat(\n            '{ \"name\": \"',\n            tokenName,\n            '\", \"description\": \"',\n            tokenDescription,\n            '\", \"image\": \"',\n            bytes(\n                renderSkySvgBase64(\n                    tokenId,\n                    computationRes.stage,\n                    computationRes.percentageOfStage\n                )\n            ),\n            '\", \"attributes\": { ',\n            attributes,\n            '\" } }'\n        );\n\n        return\n            string.concat(\n                \"data:application/json;base64,\",\n                Base64.encode(tokenUriMetadata)\n            );\n    }\n\n    function intDegToString(int256 n) internal pure returns (string memory) {\n        uint256 absN = n < 0 ? uint256(-n) : uint256(n);\n\n        string memory numberWithDecimal = string.concat(\n            (absN / 100).toString(),\n            \".\",\n            (absN % 100).toString()\n        );\n\n        if (n < 0) {\n            return string.concat(\"-\", numberWithDecimal);\n        } else {\n            return numberWithDecimal;\n        }\n    }\n\n    function renderSkySvgBase64(\n        uint256 tokenId,\n        uint256 stage,\n        uint256 percentageOfStage\n    ) internal view returns (string memory) {\n        return\n            string.concat(\n                \"data:image/svg+xml;base64,\",\n                Base64.encode(renderSkySvg(tokenId, stage, percentageOfStage))\n            );\n    }\n\n    function renderSkySvg(\n        uint256 tokenId,\n        uint256 stage,\n        uint256 percentageOfStage\n    ) internal view returns (bytes memory) {\n        string memory innerSky = renderSkyGradient(stage, percentageOfStage);\n\n        if (stage % (stageColorsData.length - 1) == 0) {\n            innerSky = string.concat(\n                innerSky,\n                renderStarFilter(\n                    tokenId,\n                    stage == 0 ? 100 - percentageOfStage : percentageOfStage\n                )\n            );\n        }\n\n        return\n            bytes.concat(\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"1024\" height=\"1024\">',\n                bytes(innerSky),\n                \"</svg>\"\n            );\n    }\n\n    function renderSkyGradient(uint256 stage, uint256 percentageOfStage)\n        internal\n        view\n        returns (string memory)\n    {\n        StageColorData memory currentStageColorData = getCurrentColorData(\n            stage,\n            percentageOfStage\n        );\n\n        return\n            string.concat(\n                '<path fill=\"url(#a)\" d=\"M0 0h1024v1024H0z\"/><defs><linearGradient id=\"a\" gradientTransform=\"rotate(90)\"><stop offset=\"',\n                currentStageColorData.topOffsetPercentage.toString(),\n                '%\" stop-color=\"#',\n                currentStageColorData.topColor.toHexString(),\n                '\"/><stop offset=\"',\n                currentStageColorData.bottomOffsetPercentage.toString(),\n                '%\" stop-color=\"#',\n                currentStageColorData.bottomColor.toHexString(),\n                '\"/></linearGradient></defs>'\n            );\n    }\n\n    function getCurrentColorData(uint256 stage, uint256 percentageOfStage)\n        internal\n        view\n        returns (StageColorData memory)\n    {\n        uint256 nextStageIndex = stage >= 7 ? 0 : stage + 1;\n\n        uint256 stageTopColor = stageColorsData[stage].topColor;\n        uint256 stageBottomColor = stageColorsData[stage].bottomColor;\n\n        uint256 nextTopColor = stageColorsData[nextStageIndex].topColor;\n        uint256 nextBottomColor = stageColorsData[nextStageIndex].bottomColor;\n\n        // lerp colors if needed\n\n        if (stageTopColor != nextTopColor) {\n            stageTopColor = uint256(\n                lerpHexColors(\n                    int256(stageTopColor),\n                    int256(nextTopColor),\n                    int256(percentageOfStage)\n                )\n            );\n        }\n\n        if (stageBottomColor != nextBottomColor) {\n            stageBottomColor = uint256(\n                lerpHexColors(\n                    int256(stageBottomColor),\n                    int256(nextBottomColor),\n                    int256(percentageOfStage)\n                )\n            );\n        }\n\n        // Interpolate gradient offsets\n\n        uint256 stageTopOffset = stageColorsData[stage].topOffsetPercentage;\n        uint256 stageBottomOffset = stageColorsData[stage]\n            .bottomOffsetPercentage;\n\n        uint256 nextTopOffset = stageColorsData[nextStageIndex]\n            .topOffsetPercentage;\n        uint256 nextBottomOffset = stageColorsData[nextStageIndex]\n            .bottomOffsetPercentage;\n\n        if (stageTopOffset != nextTopOffset) {\n            stageTopOffset = uint256(\n                int256(stageTopOffset) +\n                    ((int256(nextTopOffset) - int256(stageTopOffset)) *\n                        int256(percentageOfStage)) /\n                    100\n            );\n        }\n\n        if (stageBottomOffset != nextBottomOffset) {\n            stageTopOffset = uint256(\n                int256(stageBottomOffset) +\n                    ((int256(nextBottomOffset) - int256(stageBottomOffset)) *\n                        int256(percentageOfStage)) /\n                    100\n            );\n        }\n\n        return\n            StageColorData(\n                stageTopColor,\n                stageBottomColor,\n                stageTopOffset,\n                stageBottomOffset\n            );\n    }\n\n    function renderStarFilter(uint256 tokenId, uint256 opacity)\n        internal\n        pure\n        returns (string memory)\n    {\n        return\n            string.concat(\n                '<filter id=\"b\"><feTurbulence baseFrequency=\"0.2\"',\n                ' seed=\"',\n                tokenId.toString(),\n                '\" />',\n                '<feColorMatrix values=\"0 0 0 20 -4 0 0 0 20 -4 0 0 0 20 -4 -2 -2 -2 1.7 0\"/></filter>',\n                '<rect width=\"100%\" height=\"100%\" filter=\"url(#b)\" opacity=\"',\n                opacity.toString(),\n                '%\"/>'\n            );\n    }\n\n    // Linear interpolation between two hex colors\n\n    function lerpHexColors(\n        int256 startColor,\n        int256 endColor,\n        int256 percentage // 0-100\n    ) internal pure returns (int256) {\n        int256 ar = (startColor & 0xFF0000) >> 16;\n        int256 ag = (startColor & 0x00FF00) >> 8;\n        int256 ab = (startColor & 0x0000FF);\n\n        int256 br = (endColor & 0xFF0000) >> 16;\n        int256 bg = (endColor & 0x00FF00) >> 8;\n        int256 bb = (endColor & 0x0000FF);\n\n        int256 rr = ((100 * ar) + percentage * (br - ar)) / 100;\n        int256 rg = ((100 * ag) + percentage * (bg - ag)) / 100;\n        int256 rb = ((100 * ab) + percentage * (bb - ab)) / 100;\n\n        return (rr << 16) + (rg << 8) + (rb | 0);\n    }\n}\n", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"locationName\",\"type\":\"string\"},{\"internalType\":\"int256\",\"name\":\"latitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"longitude\",\"type\":\"int256\"}],\"name\":\"renderSky\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"topColor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bottomColor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"topOffsetPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bottomOffsetPercentage\",\"type\":\"uint256\"}],\"internalType\":\"struct StageColorData[8]\",\"name\":\"stageColors\",\"type\":\"tuple[8]\"}],\"name\":\"setStageColors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SkyRenderer", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}