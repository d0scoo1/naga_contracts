{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"Address.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary Address {\\r\\n\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        \\r\\n        return account.code.length \\u003e 0;\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n        \\r\\n            if (returndata.length \\u003e 0) {\\r\\n            \\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"},\"Context.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"ERC165.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\nabstract contract ERC165 is IERC165 {\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return interfaceId == type(IERC165).interfaceId;\\r\\n    }\\r\\n}\"},\"ERC721.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./Strings.sol\\\";\\r\\nimport \\\"./Context.sol\\\";\\r\\nimport \\\"./ERC165.sol\\\";\\r\\nimport \\\"./IERC721.sol\\\";\\r\\nimport \\\"./IERC721Metadata.sol\\\";\\r\\nimport \\\"./IERC721Receiver.sol\\\";\\r\\n\\r\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\r\\n    using Address for address;\\r\\n    using Strings for uint256;\\r\\n\\r\\n    string private _name;\\r\\n\\r\\n    string private _symbol;\\r\\n\\r\\n    mapping(uint256 =\\u003e address) private _owners;\\r\\n\\r\\n    mapping(address =\\u003e uint256) private _balances;\\r\\n\\r\\n    mapping(uint256 =\\u003e address) private _tokenApprovals;\\r\\n\\r\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) private _operatorApprovals;\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\r\\n        return\\r\\n            interfaceId == type(IERC721).interfaceId ||\\r\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\r\\n            super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\r\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\r\\n        return _balances[owner];\\r\\n    }\\r\\n\\r\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\r\\n        address owner = _owners[tokenId];\\r\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\r\\n        return owner;\\r\\n    }\\r\\n\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\r\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\r\\n\\r\\n        string memory baseURI = _baseURI();\\r\\n        return bytes(baseURI).length \\u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\r\\n    }\\r\\n\\r\\n    function _baseURI() internal view virtual returns (string memory) {\\r\\n        return \\\"\\\";\\r\\n    }\\r\\n\\r\\n    function approve(address to, uint256 tokenId) public virtual override {\\r\\n        address owner = ERC721.ownerOf(tokenId);\\r\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\r\\n\\r\\n        require(\\r\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\r\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\r\\n        );\\r\\n\\r\\n        _approve(to, tokenId);\\r\\n    }\\r\\n\\r\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\r\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\r\\n\\r\\n        return _tokenApprovals[tokenId];\\r\\n    }\\r\\n\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\r\\n        _setApprovalForAll(_msgSender(), operator, approved);\\r\\n    }\\r\\n\\r\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\r\\n        return _operatorApprovals[owner][operator];\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) public virtual override {\\r\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\r\\n\\r\\n        _transfer(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) public virtual override {\\r\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) public virtual override {\\r\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\r\\n        _safeTransfer(from, to, tokenId, _data);\\r\\n    }\\r\\n\\r\\n    function _safeTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) internal virtual {\\r\\n        _transfer(from, to, tokenId);\\r\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\r\\n    }\\r\\n\\r\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\r\\n        return _owners[tokenId] != address(0);\\r\\n    }\\r\\n\\r\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\r\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\r\\n        address owner = ERC721.ownerOf(tokenId);\\r\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\r\\n    }\\r\\n\\r\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\r\\n        _safeMint(to, tokenId, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function _safeMint(\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) internal virtual {\\r\\n        _mint(to, tokenId);\\r\\n        require(\\r\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\r\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _mint(address to, uint256 tokenId) internal virtual {\\r\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\r\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), to, tokenId);\\r\\n\\r\\n        _balances[to] += 1;\\r\\n        _owners[tokenId] = to;\\r\\n\\r\\n        emit Transfer(address(0), to, tokenId);\\r\\n\\r\\n        _afterTokenTransfer(address(0), to, tokenId);\\r\\n    }\\r\\n\\r\\n    function _burn(uint256 tokenId) internal virtual {\\r\\n        address owner = ERC721.ownerOf(tokenId);\\r\\n\\r\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\r\\n\\r\\n        // Clear approvals\\r\\n        _approve(address(0), tokenId);\\r\\n\\r\\n        _balances[owner] -= 1;\\r\\n        delete _owners[tokenId];\\r\\n\\r\\n        emit Transfer(owner, address(0), tokenId);\\r\\n\\r\\n        _afterTokenTransfer(owner, address(0), tokenId);\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) internal virtual {\\r\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\r\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(from, to, tokenId);\\r\\n\\r\\n        _approve(address(0), tokenId);\\r\\n\\r\\n        _balances[from] -= 1;\\r\\n        _balances[to] += 1;\\r\\n        _owners[tokenId] = to;\\r\\n\\r\\n        emit Transfer(from, to, tokenId);\\r\\n\\r\\n        _afterTokenTransfer(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    function _approve(address to, uint256 tokenId) internal virtual {\\r\\n        _tokenApprovals[tokenId] = to;\\r\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\r\\n    }\\r\\n\\r\\n    function _setApprovalForAll(\\r\\n        address owner,\\r\\n        address operator,\\r\\n        bool approved\\r\\n    ) internal virtual {\\r\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\r\\n        _operatorApprovals[owner][operator] = approved;\\r\\n        emit ApprovalForAll(owner, operator, approved);\\r\\n    }\\r\\n\\r\\n    function _checkOnERC721Received(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) private returns (bool) {\\r\\n        if (to.isContract()) {\\r\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\r\\n                return retval == IERC721Receiver.onERC721Received.selector;\\r\\n            } catch (bytes memory reason) {\\r\\n                if (reason.length == 0) {\\r\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\r\\n                } else {\\r\\n                    assembly {\\r\\n                        revert(add(32, reason), mload(reason))\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        } else {\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) internal virtual {}\\r\\n\\r\\n    function _afterTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) internal virtual {}\\r\\n}\"},\"ERC721Enumerable.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ERC721.sol\\\";\\r\\nimport \\\"./IERC721Enumerable.sol\\\";\\r\\n\\r\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\r\\n    \\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) private _ownedTokens;\\r\\n\\r\\n    mapping(uint256 =\\u003e uint256) private _ownedTokensIndex;\\r\\n\\r\\n    uint256[] private _allTokens;\\r\\n\\r\\n    mapping(uint256 =\\u003e uint256) private _allTokensIndex;\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\r\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\r\\n        require(index \\u003c ERC721.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\r\\n        return _ownedTokens[owner][index];\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _allTokens.length;\\r\\n    }\\r\\n\\r\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\r\\n        require(index \\u003c ERC721Enumerable.totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\r\\n        return _allTokens[index];\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) internal virtual override {\\r\\n        super._beforeTokenTransfer(from, to, tokenId);\\r\\n\\r\\n        if (from == address(0)) {\\r\\n            _addTokenToAllTokensEnumeration(tokenId);\\r\\n        } else if (from != to) {\\r\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\r\\n        }\\r\\n        if (to == address(0)) {\\r\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\r\\n        } else if (to != from) {\\r\\n            _addTokenToOwnerEnumeration(to, tokenId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\r\\n        uint256 length = ERC721.balanceOf(to);\\r\\n        _ownedTokens[to][length] = tokenId;\\r\\n        _ownedTokensIndex[tokenId] = length;\\r\\n    }\\r\\n\\r\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\r\\n        _allTokensIndex[tokenId] = _allTokens.length;\\r\\n        _allTokens.push(tokenId);\\r\\n    }\\r\\n\\r\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\r\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\r\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\r\\n\\r\\n        if (tokenIndex != lastTokenIndex) {\\r\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\r\\n\\r\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\r\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\\u0027s index\\r\\n        }\\r\\n\\r\\n        delete _ownedTokensIndex[tokenId];\\r\\n        delete _ownedTokens[from][lastTokenIndex];\\r\\n    }\\r\\n\\r\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\r\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\r\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\r\\n\\r\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\r\\n\\r\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\r\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\\u0027s index\\r\\n\\r\\n        // This also deletes the contents at the last position of the array\\r\\n        delete _allTokensIndex[tokenId];\\r\\n        _allTokens.pop();\\r\\n    }\\r\\n}\"},\"IERC165.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC165 {\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\"},\"IERC721.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\ninterface IERC721 is IERC165 {\\r\\n   \\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function approve(address to, uint256 tokenId) external;\\r\\n\\r\\n    function setApprovalForAll(address operator, bool _approved) external;\\r\\n\\r\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n}\"},\"IERC721Enumerable.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC721.sol\\\";\\r\\n\\r\\ninterface IERC721Enumerable is IERC721 {\\r\\n   \\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\r\\n\\r\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\r\\n}\"},\"IERC721Metadata.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC721.sol\\\";\\r\\ninterface IERC721Metadata is IERC721 {\\r\\n  \\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\"},\"IERC721Receiver.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC721Receiver {\\r\\n    \\r\\n    function onERC721Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\"},\"MilitaryFinanceNFT.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ERC721Enumerable.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\ncontract MilitaryFinanceNFT is ERC721Enumerable, Ownable {\\r\\n\\r\\n    using Strings for uint256;\\r\\n\\r\\n    string public baseURI = \\\"ipfs://QmTCbup7X7G9jKUnay1odzVTyM3gndgApgapuySywHYpAg/mil.json\\\";\\r\\n    bool public isMintActive = false;\\r\\n\\r\\n    mapping(address=\\u003ebool) private hasMinted;\\r\\n    mapping(address=\\u003euint256) public nftPerAddress;\\r\\n\\r\\n    constructor() ERC721(\\\"Military Finance\\\", \\\"MF\\\") {\\r\\n        setBaseURI(baseURI);\\r\\n        assignNFT([0x0F02c84F0f4dde605B8F79A0f906189Fe3D6563b,0x4cf8b424df061DebF876a4B930D83A1c6999e41F,0xd5a5E3e8d783198E296418a0c372B6840a1d7908,0xCb7c988DCf1bd9798adad8C1f0fde85E301884BA,0x7b8575a65320fC220D75290123f13906B512B2B3,0x74D6400F9480df5e5ffc76283147836bcE8D3c95,0x42480b336ad6246Cfde0ADc3b5C0F987621301bF,0x04cD0F07C5dfB0Fd97E2D6D4dCF51Fc4bf6902b8,0x2515388f9135c6e554950a13f27A2D311a695005,0xdB379e9D031b31A339e1FA38ac14859987379f85,0x49410e0986Bf3DAe2099f6CF159c3a428775BaCD,0xE6ac31c0eBFBdC40C0d37F00b22D7798810CA534,0xfC283d4DB5FcbC9C1f121E6F7aE98279d2DCE7dd,0x4E5D191DFFb8d3DFe7790F91ACe6f9B80F04Ef0f,0x3cbF94db8624F711e43429bb35eac970fd787cF7,0x6aE85Eaade22A37bD8f82755946307C869300317,0xC83DCD8509559A81250A62Ab5bfA02fC377E0472,0xd73f155CbdE8904E378f23b7cF03e85422045fCe,0x89147c5005230ef53629C9C6B1EA98994E626Eb2,0xa665daa4CF74F388b5BA71921B399Ad8d6c246e8,0x18Ec26AB28fE3f01675da12D6bD9AE9BcE560cEb,0xa69EeE71308C9Ae74eBA62c369ee77E306906c0f,0x38EEad1e98dfB2FD75fA6D10FE9b6fAB59f5893E,0x4aa0e35DC8A91193BE87592e19a84Bd7051D4ce6,0x45Aa70E782Aa969AEacB0Bc0570D014ccC66b588,0xC27be6F5e9640cEF25F98217Ca10f3FD51CE8277,0xB7A7c45562Cef752cB695DbB37F721ac82589bfe,0x8419b7BFF5F0a028062812993b77CA1b4fa5D05F,0x1dde6B5963536D241Fd50afD28c062cE0C94Bb36,0xd4E17a7851EC93DE08eCb25638a9E09D457f93Cb,0xF21d95281337D1D7d6086bb03ddA4699d36B8568,0xe8e3451b15EB5e6d4c4092Ff7d4e6a328b8B1C49,0xcf9B51D3E910E3910e29eD54480dC4308F69096E,0xDa6db76eAed161d422D8BEB670d7056Ec75b7914,0xD3041A2d0A087818CbF164EfBC0C481bBA0Fba52,0xb8343637ddEEBA2b30a57e486390645960299A65,0x458BE92AdceaAA7ef850B9feB8DBAB7D59435831,0x5743Ce317A6f7155D5681701F935082c04255c97,0x8C3c67f6e2E4FBD181F9c0fE4030aFbeE732C864,0x25585f2c5E89BF0C0A6E56e13Cb4Db35Aa36450e,0x70887FC71a498A983A3d0dE9D0b1dD8fF3414515,0xe10fd8f09A586d3740ace93d2BB44018fbBe1E78,0x7c727fCaFC90D47AD11f4bf5f47a8f116eC1b697,0x2f365624c31cDb9aEc9ACC6B395deB155601BfeE,0x6EF959D111b62F0e830eFc471D01D47BA77984CC,0xeFC8C6986fA3a8A6E6bc4bFc1Cb42985B1d1E576,0xC501A034678F7a0ba939d02C4fA5F7F138565561,0x77Df96e69aD2Aaf27766B72FE9b15Fe17Be7F9Fa,0x3A93E420f88776eD82890735b1CF0362cFb4524b,0x297557bf0aEc3EEb9Da85c72d59bfe5D8f7C4C48,0x492D24C7C5370f55aB667605DEEeFAC0962DB69A,0x03f44A591DE8Db070Ab2Ba753fab753b5142d54c,0x713f78655336b56E88B71d18D6deC48Eb141fBD4,0x396162B335BFeAf590c548162aC844aD670BFe93,0xe8F7dA81CA885f1F97bcD129bd8d240cA7063e7A,0x4F051a38BF4795677bcfBb3b02f3C65580C4F920,0x5f0Ba33ad38EcB093A8F3aB08C8B5dA55Ca33947,0x9F56A5b7236c2F2440aD5a4C201938C1780176C0,0xcd15DBA1E6E6C7ad6477C253627Aad3F6397366a,0x849DFB80c24E83a623889426e17D3a452012b3e8,0x3967610e525aB2c2D19D7B6a896A9ab81E90d031,0x7ed63716911c13a56c55D43E1079679461BC929c,0x1DD9438351562A095e8c8A76EAb11F8321AbB3d9,0xa9EB742D925B248d3EaF6a8d57Fb1e9de9fe2952,0xcA0cdD507C949AE0c8575238DC16da1dd876b621,0x2083AfCce65cb7B90bB5F674ebbb6d3DD6faE530,0xd8d415806d20a7D1d28758C6BD73285ef2657888,0x6851ea3FB6abaEDBAA46eD92dd437173972b9E74,0x71D744165eC5f61598D192728E23A71D5D4983c8,0xe8A35d12B2Eb667A40063A048F143d61696c6BDd,0xe7EAc73B3076b3ce4889Ff294d736A0B03733cD0,0x8d1360FC5d845CfB438023bA89b4F30C66cfFDEf,0x68517c3aC4e9836605CEf894c2ee54D34084385c,0x2728BD850d20e0d588A7b0d51b9fD4d82f98D94A,0x97d8f0450352e366e96f7F76c290324C2b3627CE,0xb0c3930Ab043540A61E11B080EF9B076d86e760D,0xccf4Ed95207b4be79BE5494Df0d95eb7168E83Ad,0x62706e185595dBd747EAC3A0046b166d7EAa334c,0xbac0Ab0cFB622aBBEe48907bFa21Ba5aBe4deDaE,0x185F0b084cf273535F09a1d9b0b7534F16773d3C,0x1358a36E4f231FFee9be67A6d544e79129eA34F2,0x529BdDE496249E5b3462092Ef84b84315CD3e368],[2,2,1,1,1,2,20,20,2,4,10,21,4,10,1,1,2,2,2,4,4,5,10,10,10,10,10,10,10,10,10,10,10,15,20,20,20,50,50,100,1,8,1,8,1,2,2,10,10,24,1,1,4,4,20,2,2,4,4,8,10,16,4,1,2,10,4,10,13,1,5,120,1,50,1,18,1,2,5,2,1,100]);\\r\\n    }\\r\\n\\r\\n    function assignNFT(address[82] memory _addresses, uint8[82] memory _amountOfNFT) public onlyOwner {\\r\\n        require(_addresses.length == _amountOfNFT.length, \\\"No. of Addresses not equal to No. of NFTs!\\\");\\r\\n        for(uint i = 0; i \\u003c _addresses.length; i++) {\\r\\n            nftPerAddress[_addresses[i]] = _amountOfNFT[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setPerAddressNFT(address _address, uint256 _amountOfNFT) public onlyOwner{\\r\\n        nftPerAddress[_address] = _amountOfNFT;\\r\\n    }\\r\\n\\r\\n    function mint(uint256 _mintAmount) public {\\r\\n        require(isMintActive, \\\"Minting not started yet!\\\");\\r\\n        require(hasMinted[msg.sender] == false, \\\"You\\u0027ve already minted!\\\");\\r\\n        require(_mintAmount == nftPerAddress[msg.sender], \\\"You\\u0027re Not authorized to mint!\\\");\\r\\n        _mintLoop(msg.sender, _mintAmount);   \\r\\n        hasMinted[msg.sender] = true;\\r\\n        nftPerAddress[msg.sender] = 0;\\r\\n    }\\r\\n\\r\\n    function setMintStatus(bool _status) public onlyOwner{\\r\\n        isMintActive = _status;\\r\\n    }\\r\\n\\r\\n    function walletOfOwner(address _owner) public view returns (uint[] memory) { \\r\\n        uint[] memory _tokensOfOwner = new uint[](balanceOf(_owner)); \\r\\n\\r\\n        for (uint i=0; i \\u003c balanceOf(_owner);i++){\\r\\n            _tokensOfOwner[i] = tokenOfOwnerByIndex(_owner, i);\\r\\n        }\\r\\n        return (_tokensOfOwner);\\r\\n    }\\r\\n\\r\\n    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory){\\r\\n        require(\\r\\n        _exists(_tokenId),\\r\\n        \\\"ERC721Metadata: URI query for nonexistent token\\\"\\r\\n        );\\r\\n        return baseURI;\\r\\n    }\\r\\n    \\r\\n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\\r\\n        baseURI = _newBaseURI;\\r\\n    }\\r\\n    \\r\\n    function withdraw() public onlyOwner {\\r\\n        require(address(this).balance \\u003e= 0, \\\"contract has no ethers!\\\");\\r\\n        payable(owner()).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n  function _mintLoop(address _receiver, uint256 _mintAmount) internal {\\r\\n      uint supply = totalSupply();\\r\\n    for (uint8 i = 0; i \\u003c _mintAmount; i++) {\\r\\n      _safeMint(_receiver, supply+i+1);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _baseURI() internal view virtual override returns (string memory) {\\r\\n    return baseURI;\\r\\n  }\\r\\n}\"},\"Ownable.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\"},\"Strings.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary Strings {\\r\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        while (value != 0) {\\r\\n            digits -= 1;\\r\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\r\\n            value /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\r\\n        if (value == 0) {\\r\\n            return \\\"0x00\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 length = 0;\\r\\n        while (temp != 0) {\\r\\n            length++;\\r\\n            temp \\u003e\\u003e= 8;\\r\\n        }\\r\\n        return toHexString(value, length);\\r\\n    }\\r\\n\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\r\\n            buffer[i] = _HEX_SYMBOLS[value \\u0026 0xf];\\r\\n            value \\u003e\\u003e= 4;\\r\\n        }\\r\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\r\\n        return string(buffer);\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[82]\",\"name\":\"_addresses\",\"type\":\"address[82]\"},{\"internalType\":\"uint8[82]\",\"name\":\"_amountOfNFT\",\"type\":\"uint8[82]\"}],\"name\":\"assignNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMintActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nftPerAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setMintStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOfNFT\",\"type\":\"uint256\"}],\"name\":\"setPerAddressNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"walletOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MilitaryFinanceNFT", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ad8751a06a6a682f0b26d382f0a7f2dc49a54c0d0e0e7f355dd56ee059f5a2b0"}]}