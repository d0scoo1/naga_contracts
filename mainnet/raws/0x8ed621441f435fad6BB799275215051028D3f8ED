{"status": "1", "message": "OK", "result": [{"SourceCode": "/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: migrations/MigrationLib_Diphda.sol\n*\n* Latest source (may be newer): https://github.com/Synthetixio/synthetix/blob/master/contracts/migrations/MigrationLib_Diphda.sol\n* Docs: https://docs.synthetix.io/contracts/migrations/MigrationLib_Diphda\n*\n* Contract Dependencies: \n*\t- BaseDebtCache\n*\t- EternalStorage\n*\t- ExchangeRates\n*\t- ExternStateToken\n*\t- IAddressResolver\n*\t- IDebtCache\n*\t- IERC20\n*\t- IExchangeRates\n*\t- IExchangeState\n*\t- IFeePool\n*\t- IIssuer\n*\t- IRewardEscrow\n*\t- ISynth\n*\t- ISystemStatus\n*\t- LimitedSetup\n*\t- MixinResolver\n*\t- MixinSystemSettings\n*\t- Owned\n*\t- Proxy\n*\t- Proxyable\n*\t- State\n*\t- Synth\n* Libraries: \n*\t- MigrationLib_Diphda\n*\t- SafeCast\n*\t- SafeDecimalMath\n*\t- SafeMath\n*\t- VestingEntries\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2022 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\n\n\npragma solidity ^0.5.16;\n\n// https://docs.synthetix.io/contracts/source/contracts/owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getSynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iissuer\ninterface IIssuer {\n    // Views\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function canBurnSynths(address account) external view returns (bool);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsInvalid);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\n\n    function issuanceRatio() external view returns (uint);\n\n    function lastIssueEvent(address account) external view returns (uint);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function minimumStakeTime() external view returns (uint);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint);\n\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsInvalid);\n\n    // Restricted: used internally to Synthetix\n    function issueSynths(address from, uint amount) external;\n\n    function issueSynthsOnBehalf(\n        address issueFor,\n        address from,\n        uint amount\n    ) external;\n\n    function issueMaxSynths(address from) external;\n\n    function issueMaxSynthsOnBehalf(address issueFor, address from) external;\n\n    function burnSynths(address from, uint amount) external;\n\n    function burnSynthsOnBehalf(\n        address burnForAddress,\n        address from,\n        uint amount\n    ) external;\n\n    function burnSynthsToTarget(address from) external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external;\n\n    function burnForRedemption(\n        address deprecatedSynthProxy,\n        address account,\n        uint balance\n    ) external;\n\n    function liquidateDelinquentAccount(\n        address account,\n        uint susdAmount,\n        address liquidator\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\n\n    function setCurrentPeriodId(uint128 periodId) external;\n}\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/mixinresolver\ncontract MixinResolver {\n    AddressResolver public resolver;\n\n    mapping(bytes32 => address) private addressCache;\n\n    constructor(address _resolver) internal {\n        resolver = AddressResolver(_resolver);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\n        internal\n        pure\n        returns (bytes32[] memory combination)\n    {\n        combination = new bytes32[](first.length + second.length);\n\n        for (uint i = 0; i < first.length; i++) {\n            combination[i] = first[i];\n        }\n\n        for (uint j = 0; j < second.length; j++) {\n            combination[first.length + j] = second[j];\n        }\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\n\n    function rebuildCache() public {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        // The resolver must call this function whenver it updates its state\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            address destination =\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\"Resolver missing target: \", name)));\n            addressCache[name] = destination;\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\n        address _foundAddress = addressCache[name];\n        require(_foundAddress != address(0), string(abi.encodePacked(\"Missing address: \", name)));\n        return _foundAddress;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event CacheUpdated(bytes32 name, address destination);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/addressresolver\ncontract AddressResolver is Owned, IAddressResolver {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            repository[name] = destination;\n            emit AddressImported(name, destination);\n        }\n    }\n\n    /* ========= PUBLIC FUNCTIONS ========== */\n\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\n        for (uint i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\n        for (uint i = 0; i < names.length; i++) {\n            if (repository[names[i]] != destinations[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    function getSynth(bytes32 key) external view returns (address) {\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\n        return address(issuer.synths(key));\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AddressImported(bytes32 name, address destination);\n}\n\n\ncontract BaseMigration is Owned {\n    constructor(address _owner) internal Owned(_owner) {}\n\n    // safety value to return ownership (anyone can invoke)\n    function returnOwnership(address forContract) public {\n        bytes memory payload = abi.encodeWithSignature(\"nominateNewOwner(address)\", owner);\n\n        // solhint-disable avoid-low-level-calls\n        (bool success, ) = forContract.call(payload);\n\n        if (!success) {\n            // then try legacy way\n            bytes memory legacyPayload = abi.encodeWithSignature(\"nominateOwner(address)\", owner);\n\n            // solhint-disable avoid-low-level-calls\n            (bool legacySuccess, ) = forContract.call(legacyPayload);\n\n            require(legacySuccess, \"Legacy nomination failed\");\n        }\n    }\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n// Libraries\n\n\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    // Computes `a - b`, setting the value to 0 if b > a.\n    function floorsub(uint a, uint b) internal pure returns (uint) {\n        return b >= a ? 0 : a - b;\n    }\n\n    /* ---------- Utilities ---------- */\n    /*\n     * Absolute value of the input, returned as a signed number.\n     */\n    function signedAbs(int x) internal pure returns (int) {\n        return x < 0 ? -x : x;\n    }\n\n    /*\n     * Absolute value of the input, returned as an unsigned number.\n     */\n    function abs(int x) internal pure returns (uint) {\n        return uint(signedAbs(x));\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iflexiblestorage\ninterface IFlexibleStorage {\n    // Views\n    function getUIntValue(bytes32 contractName, bytes32 record) external view returns (uint);\n\n    function getUIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (uint[] memory);\n\n    function getIntValue(bytes32 contractName, bytes32 record) external view returns (int);\n\n    function getIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (int[] memory);\n\n    function getAddressValue(bytes32 contractName, bytes32 record) external view returns (address);\n\n    function getAddressValues(bytes32 contractName, bytes32[] calldata records) external view returns (address[] memory);\n\n    function getBoolValue(bytes32 contractName, bytes32 record) external view returns (bool);\n\n    function getBoolValues(bytes32 contractName, bytes32[] calldata records) external view returns (bool[] memory);\n\n    function getBytes32Value(bytes32 contractName, bytes32 record) external view returns (bytes32);\n\n    function getBytes32Values(bytes32 contractName, bytes32[] calldata records) external view returns (bytes32[] memory);\n\n    // Mutative functions\n    function deleteUIntValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteIntValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteAddressValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteBoolValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteBytes32Value(bytes32 contractName, bytes32 record) external;\n\n    function setUIntValue(\n        bytes32 contractName,\n        bytes32 record,\n        uint value\n    ) external;\n\n    function setUIntValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        uint[] calldata values\n    ) external;\n\n    function setIntValue(\n        bytes32 contractName,\n        bytes32 record,\n        int value\n    ) external;\n\n    function setIntValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        int[] calldata values\n    ) external;\n\n    function setAddressValue(\n        bytes32 contractName,\n        bytes32 record,\n        address value\n    ) external;\n\n    function setAddressValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        address[] calldata values\n    ) external;\n\n    function setBoolValue(\n        bytes32 contractName,\n        bytes32 record,\n        bool value\n    ) external;\n\n    function setBoolValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        bool[] calldata values\n    ) external;\n\n    function setBytes32Value(\n        bytes32 contractName,\n        bytes32 record,\n        bytes32 value\n    ) external;\n\n    function setBytes32Values(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        bytes32[] calldata values\n    ) external;\n}\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/mixinsystemsettings\ncontract MixinSystemSettings is MixinResolver {\n    // must match the one defined SystemSettingsLib, defined in both places due to sol v0.5 limitations\n    bytes32 internal constant SETTING_CONTRACT_NAME = \"SystemSettings\";\n\n    bytes32 internal constant SETTING_WAITING_PERIOD_SECS = \"waitingPeriodSecs\";\n    bytes32 internal constant SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR = \"priceDeviationThresholdFactor\";\n    bytes32 internal constant SETTING_ISSUANCE_RATIO = \"issuanceRatio\";\n    bytes32 internal constant SETTING_FEE_PERIOD_DURATION = \"feePeriodDuration\";\n    bytes32 internal constant SETTING_TARGET_THRESHOLD = \"targetThreshold\";\n    bytes32 internal constant SETTING_LIQUIDATION_DELAY = \"liquidationDelay\";\n    bytes32 internal constant SETTING_LIQUIDATION_RATIO = \"liquidationRatio\";\n    bytes32 internal constant SETTING_LIQUIDATION_PENALTY = \"liquidationPenalty\";\n    bytes32 internal constant SETTING_RATE_STALE_PERIOD = \"rateStalePeriod\";\n    /* ========== Exchange Fees Related ========== */\n    bytes32 internal constant SETTING_EXCHANGE_FEE_RATE = \"exchangeFeeRate\";\n    bytes32 internal constant SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD = \"exchangeDynamicFeeThreshold\";\n    bytes32 internal constant SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY = \"exchangeDynamicFeeWeightDecay\";\n    bytes32 internal constant SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS = \"exchangeDynamicFeeRounds\";\n    bytes32 internal constant SETTING_EXCHANGE_MAX_DYNAMIC_FEE = \"exchangeMaxDynamicFee\";\n    /* ========== End Exchange Fees Related ========== */\n    bytes32 internal constant SETTING_MINIMUM_STAKE_TIME = \"minimumStakeTime\";\n    bytes32 internal constant SETTING_AGGREGATOR_WARNING_FLAGS = \"aggregatorWarningFlags\";\n    bytes32 internal constant SETTING_TRADING_REWARDS_ENABLED = \"tradingRewardsEnabled\";\n    bytes32 internal constant SETTING_DEBT_SNAPSHOT_STALE_TIME = \"debtSnapshotStaleTime\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT = \"crossDomainDepositGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT = \"crossDomainEscrowGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT = \"crossDomainRewardGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT = \"crossDomainWithdrawalGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_FEE_PERIOD_CLOSE_GAS_LIMIT = \"crossDomainCloseGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT = \"crossDomainRelayGasLimit\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MAX_ETH = \"etherWrapperMaxETH\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MINT_FEE_RATE = \"etherWrapperMintFeeRate\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_BURN_FEE_RATE = \"etherWrapperBurnFeeRate\";\n    bytes32 internal constant SETTING_WRAPPER_MAX_TOKEN_AMOUNT = \"wrapperMaxTokens\";\n    bytes32 internal constant SETTING_WRAPPER_MINT_FEE_RATE = \"wrapperMintFeeRate\";\n    bytes32 internal constant SETTING_WRAPPER_BURN_FEE_RATE = \"wrapperBurnFeeRate\";\n    bytes32 internal constant SETTING_INTERACTION_DELAY = \"interactionDelay\";\n    bytes32 internal constant SETTING_COLLAPSE_FEE_RATE = \"collapseFeeRate\";\n    bytes32 internal constant SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK = \"atomicMaxVolumePerBlock\";\n    bytes32 internal constant SETTING_ATOMIC_TWAP_WINDOW = \"atomicTwapWindow\";\n    bytes32 internal constant SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING = \"atomicEquivalentForDexPricing\";\n    bytes32 internal constant SETTING_ATOMIC_EXCHANGE_FEE_RATE = \"atomicExchangeFeeRate\";\n    bytes32 internal constant SETTING_ATOMIC_PRICE_BUFFER = \"atomicPriceBuffer\";\n    bytes32 internal constant SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = \"atomicVolConsiderationWindow\";\n    bytes32 internal constant SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD = \"atomicVolUpdateThreshold\";\n\n    bytes32 internal constant CONTRACT_FLEXIBLESTORAGE = \"FlexibleStorage\";\n\n    enum CrossDomainMessageGasLimits {Deposit, Escrow, Reward, Withdrawal, CloseFeePeriod, Relay}\n\n    struct DynamicFeeConfig {\n        uint threshold;\n        uint weightDecay;\n        uint rounds;\n        uint maxFee;\n    }\n\n    constructor(address _resolver) internal MixinResolver(_resolver) {}\n\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        addresses = new bytes32[](1);\n        addresses[0] = CONTRACT_FLEXIBLESTORAGE;\n    }\n\n    function flexibleStorage() internal view returns (IFlexibleStorage) {\n        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));\n    }\n\n    function _getGasLimitSetting(CrossDomainMessageGasLimits gasLimitType) internal pure returns (bytes32) {\n        if (gasLimitType == CrossDomainMessageGasLimits.Deposit) {\n            return SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Escrow) {\n            return SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Reward) {\n            return SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Withdrawal) {\n            return SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Relay) {\n            return SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.CloseFeePeriod) {\n            return SETTING_CROSS_DOMAIN_FEE_PERIOD_CLOSE_GAS_LIMIT;\n        } else {\n            revert(\"Unknown gas limit type\");\n        }\n    }\n\n    function getCrossDomainMessageGasLimit(CrossDomainMessageGasLimits gasLimitType) internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, _getGasLimitSetting(gasLimitType));\n    }\n\n    function getTradingRewardsEnabled() internal view returns (bool) {\n        return flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME, SETTING_TRADING_REWARDS_ENABLED);\n    }\n\n    function getWaitingPeriodSecs() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_WAITING_PERIOD_SECS);\n    }\n\n    function getPriceDeviationThresholdFactor() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR);\n    }\n\n    function getIssuanceRatio() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ISSUANCE_RATIO);\n    }\n\n    function getFeePeriodDuration() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_FEE_PERIOD_DURATION);\n    }\n\n    function getTargetThreshold() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_TARGET_THRESHOLD);\n    }\n\n    function getLiquidationDelay() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_DELAY);\n    }\n\n    function getLiquidationRatio() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_RATIO);\n    }\n\n    function getLiquidationPenalty() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_PENALTY);\n    }\n\n    function getRateStalePeriod() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_RATE_STALE_PERIOD);\n    }\n\n    /* ========== Exchange Related Fees ========== */\n    function getExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE, currencyKey))\n            );\n    }\n\n    /// @notice Get exchange dynamic fee related keys\n    /// @return threshold, weight decay, rounds, and max fee\n    function getExchangeDynamicFeeConfig() internal view returns (DynamicFeeConfig memory) {\n        bytes32[] memory keys = new bytes32[](4);\n        keys[0] = SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD;\n        keys[1] = SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY;\n        keys[2] = SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS;\n        keys[3] = SETTING_EXCHANGE_MAX_DYNAMIC_FEE;\n        uint[] memory values = flexibleStorage().getUIntValues(SETTING_CONTRACT_NAME, keys);\n        return DynamicFeeConfig({threshold: values[0], weightDecay: values[1], rounds: values[2], maxFee: values[3]});\n    }\n\n    /* ========== End Exchange Related Fees ========== */\n\n    function getMinimumStakeTime() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MINIMUM_STAKE_TIME);\n    }\n\n    function getAggregatorWarningFlags() internal view returns (address) {\n        return flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME, SETTING_AGGREGATOR_WARNING_FLAGS);\n    }\n\n    function getDebtSnapshotStaleTime() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_DEBT_SNAPSHOT_STALE_TIME);\n    }\n\n    function getEtherWrapperMaxETH() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MAX_ETH);\n    }\n\n    function getEtherWrapperMintFeeRate() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MINT_FEE_RATE);\n    }\n\n    function getEtherWrapperBurnFeeRate() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_BURN_FEE_RATE);\n    }\n\n    function getWrapperMaxTokenAmount(address wrapper) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_WRAPPER_MAX_TOKEN_AMOUNT, wrapper))\n            );\n    }\n\n    function getWrapperMintFeeRate(address wrapper) internal view returns (int) {\n        return\n            flexibleStorage().getIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_WRAPPER_MINT_FEE_RATE, wrapper))\n            );\n    }\n\n    function getWrapperBurnFeeRate(address wrapper) internal view returns (int) {\n        return\n            flexibleStorage().getIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_WRAPPER_BURN_FEE_RATE, wrapper))\n            );\n    }\n\n    function getInteractionDelay(address collateral) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_INTERACTION_DELAY, collateral))\n            );\n    }\n\n    function getCollapseFeeRate(address collateral) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_COLLAPSE_FEE_RATE, collateral))\n            );\n    }\n\n    function getAtomicMaxVolumePerBlock() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK);\n    }\n\n    function getAtomicTwapWindow() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_TWAP_WINDOW);\n    }\n\n    function getAtomicEquivalentForDexPricing(bytes32 currencyKey) internal view returns (address) {\n        return\n            flexibleStorage().getAddressValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING, currencyKey))\n            );\n    }\n\n    function getAtomicExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_EXCHANGE_FEE_RATE, currencyKey))\n            );\n    }\n\n    function getAtomicPriceBuffer(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_PRICE_BUFFER, currencyKey))\n            );\n    }\n\n    function getAtomicVolatilityConsiderationWindow(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW, currencyKey))\n            );\n    }\n\n    function getAtomicVolatilityUpdateThreshold(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD, currencyKey))\n            );\n    }\n}\n\n\ninterface IDebtCache {\n    // Views\n\n    function cachedDebt() external view returns (uint);\n\n    function cachedSynthDebt(bytes32 currencyKey) external view returns (uint);\n\n    function cacheTimestamp() external view returns (uint);\n\n    function cacheInvalid() external view returns (bool);\n\n    function cacheStale() external view returns (bool);\n\n    function isInitialized() external view returns (bool);\n\n    function currentSynthDebts(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (\n            uint[] memory debtValues,\n            uint futuresDebt,\n            uint excludedDebt,\n            bool anyRateIsInvalid\n        );\n\n    function cachedSynthDebts(bytes32[] calldata currencyKeys) external view returns (uint[] memory debtValues);\n\n    function totalNonSnxBackedDebt() external view returns (uint excludedDebt, bool isInvalid);\n\n    function currentDebt() external view returns (uint debt, bool anyRateIsInvalid);\n\n    function cacheInfo()\n        external\n        view\n        returns (\n            uint debt,\n            uint timestamp,\n            bool isInvalid,\n            bool isStale\n        );\n\n    function excludedIssuedDebts(bytes32[] calldata currencyKeys) external view returns (uint[] memory excludedDebts);\n\n    // Mutative functions\n\n    function updateCachedSynthDebts(bytes32[] calldata currencyKeys) external;\n\n    function updateCachedSynthDebtWithRate(bytes32 currencyKey, uint currencyRate) external;\n\n    function updateCachedSynthDebtsWithRates(bytes32[] calldata currencyKeys, uint[] calldata currencyRates) external;\n\n    function updateDebtCacheValidity(bool currentlyInvalid) external;\n\n    function purgeCachedSynthDebt(bytes32 currencyKey) external;\n\n    function takeDebtSnapshot() external;\n\n    function recordExcludedDebtChange(bytes32 currencyKey, int256 delta) external;\n\n    function updateCachedsUSDDebt(int amount) external;\n\n    function importExcludedIssuedDebts(IDebtCache prevDebtCache, IIssuer prevIssuer) external;\n}\n\n\ninterface IVirtualSynth {\n    // Views\n    function balanceOfUnderlying(address account) external view returns (uint);\n\n    function rate() external view returns (uint);\n\n    function readyToSettle() external view returns (bool);\n\n    function secsLeftInWaitingPeriod() external view returns (uint);\n\n    function settled() external view returns (bool);\n\n    function synth() external view returns (ISynth);\n\n    // Mutative functions\n    function settle(address account) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchanger\ninterface IExchanger {\n    struct ExchangeEntrySettlement {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint reclaim;\n        uint rebate;\n        uint srcRoundIdAtPeriodEnd;\n        uint destRoundIdAtPeriodEnd;\n        uint timestamp;\n    }\n\n    struct ExchangeEntry {\n        uint sourceRate;\n        uint destinationRate;\n        uint destinationAmount;\n        uint exchangeFeeRate;\n        uint exchangeDynamicFeeRate;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    // Views\n    function calculateAmountAfterSettlement(\n        address from,\n        bytes32 currencyKey,\n        uint amount,\n        uint refunded\n    ) external view returns (uint amountAfterSettlement);\n\n    function isSynthRateInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function maxSecsLeftInWaitingPeriod(address account, bytes32 currencyKey) external view returns (uint);\n\n    function settlementOwing(address account, bytes32 currencyKey)\n        external\n        view\n        returns (\n            uint reclaimAmount,\n            uint rebateAmount,\n            uint numEntries\n        );\n\n    function hasWaitingPeriodOrSettlementOwing(address account, bytes32 currencyKey) external view returns (bool);\n\n    function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view returns (uint);\n\n    function dynamicFeeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\n        external\n        view\n        returns (uint feeRate, bool tooVolatile);\n\n    function getAmountsForExchange(\n        uint sourceAmount,\n        bytes32 sourceCurrencyKey,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint amountReceived,\n            uint fee,\n            uint exchangeFeeRate\n        );\n\n    function priceDeviationThresholdFactor() external view returns (uint);\n\n    function waitingPeriodSecs() external view returns (uint);\n\n    function lastExchangeRate(bytes32 currencyKey) external view returns (uint);\n\n    // Mutative functions\n    function exchange(\n        address exchangeForAddress,\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bool virtualSynth,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\n\n    function exchangeAtomically(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function settle(address from, bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntries\n        );\n\n    function suspendSynthWithInvalidRate(bytes32 currencyKey) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\ninterface IExchangeRates {\n    // Structs\n    struct RateAndUpdatedTime {\n        uint216 rate;\n        uint40 time;\n    }\n\n    // Views\n    function aggregators(bytes32 currencyKey) external view returns (address);\n\n    function aggregatorWarningFlags() external view returns (address);\n\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\n\n    function anyRateIsInvalidAtRound(bytes32[] calldata currencyKeys, uint[] calldata roundIds) external view returns (bool);\n\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\n\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value);\n\n    function effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveValueAndRatesAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveAtomicValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint systemValue,\n            uint systemSourceRate,\n            uint systemDestinationRate\n        );\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint);\n\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\n\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\n\n    function rateStalePeriod() external view returns (uint);\n\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(\n        bytes32 currencyKey,\n        uint numRounds,\n        uint roundId\n    ) external view returns (uint[] memory rates, uint[] memory times);\n\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (uint[] memory rates, bool anyRateInvalid);\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\n\n    function synthTooVolatileForAtomicExchange(bytes32 currencyKey) external view returns (bool);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isystemstatus\ninterface ISystemStatus {\n    struct Status {\n        bool canSuspend;\n        bool canResume;\n    }\n\n    struct Suspension {\n        bool suspended;\n        // reason is an integer code,\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\n        uint248 reason;\n    }\n\n    // Views\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\n\n    function requireSystemActive() external view;\n\n    function systemSuspended() external view returns (bool);\n\n    function requireIssuanceActive() external view;\n\n    function requireExchangeActive() external view;\n\n    function requireFuturesActive() external view;\n\n    function requireFuturesMarketActive(bytes32 marketKey) external view;\n\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function requireSynthActive(bytes32 currencyKey) external view;\n\n    function synthSuspended(bytes32 currencyKey) external view returns (bool);\n\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function systemSuspension() external view returns (bool suspended, uint248 reason);\n\n    function issuanceSuspension() external view returns (bool suspended, uint248 reason);\n\n    function exchangeSuspension() external view returns (bool suspended, uint248 reason);\n\n    function futuresSuspension() external view returns (bool suspended, uint248 reason);\n\n    function synthExchangeSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function synthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function futuresMarketSuspension(bytes32 marketKey) external view returns (bool suspended, uint248 reason);\n\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons);\n\n    function getSynthSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons);\n\n    function getFuturesMarketSuspensions(bytes32[] calldata marketKeys)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons);\n\n    // Restricted functions\n    function suspendIssuance(uint256 reason) external;\n\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external;\n\n    function suspendFuturesMarket(bytes32 marketKey, uint256 reason) external;\n\n    function updateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ierc20\ninterface IERC20 {\n    // ERC20 Optional Views\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    // Views\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    // Mutative functions\n    function transfer(address to, uint value) external returns (bool);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\ninterface ICollateralManager {\n    // Manager information\n    function hasCollateral(address collateral) external view returns (bool);\n\n    function isSynthManaged(bytes32 currencyKey) external view returns (bool);\n\n    // State information\n    function long(bytes32 synth) external view returns (uint amount);\n\n    function short(bytes32 synth) external view returns (uint amount);\n\n    function totalLong() external view returns (uint susdValue, bool anyRateIsInvalid);\n\n    function totalShort() external view returns (uint susdValue, bool anyRateIsInvalid);\n\n    function getBorrowRate() external view returns (uint borrowRate, bool anyRateIsInvalid);\n\n    function getShortRate(bytes32 synth) external view returns (uint shortRate, bool rateIsInvalid);\n\n    function getRatesAndTime(uint index)\n        external\n        view\n        returns (\n            uint entryRate,\n            uint lastRate,\n            uint lastUpdated,\n            uint newIndex\n        );\n\n    function getShortRatesAndTime(bytes32 currency, uint index)\n        external\n        view\n        returns (\n            uint entryRate,\n            uint lastRate,\n            uint lastUpdated,\n            uint newIndex\n        );\n\n    function exceedsDebtLimit(uint amount, bytes32 currency) external view returns (bool canIssue, bool anyRateIsInvalid);\n\n    function areSynthsAndCurrenciesSet(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys)\n        external\n        view\n        returns (bool);\n\n    function areShortableSynthsSet(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys)\n        external\n        view\n        returns (bool);\n\n    // Loans\n    function getNewLoanId() external returns (uint id);\n\n    // Manager mutative\n    function addCollaterals(address[] calldata collaterals) external;\n\n    function removeCollaterals(address[] calldata collaterals) external;\n\n    function addSynths(bytes32[] calldata synthNamesInResolver, bytes32[] calldata synthKeys) external;\n\n    function removeSynths(bytes32[] calldata synths, bytes32[] calldata synthKeys) external;\n\n    function addShortableSynths(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys) external;\n\n    function removeShortableSynths(bytes32[] calldata synths) external;\n\n    // State mutative\n\n    function incrementLongs(bytes32 synth, uint amount) external;\n\n    function decrementLongs(bytes32 synth, uint amount) external;\n\n    function incrementShorts(bytes32 synth, uint amount) external;\n\n    function decrementShorts(bytes32 synth, uint amount) external;\n\n    function accrueInterest(\n        uint interestIndex,\n        bytes32 currency,\n        bool isShort\n    ) external returns (uint difference, uint index);\n\n    function updateBorrowRatesCollateral(uint rate) external;\n\n    function updateShortRatesCollateral(bytes32 currency, uint rate) external;\n}\n\n\ninterface IWETH {\n    // ERC20 Optional Views\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    // Views\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    // Mutative functions\n    function transfer(address to, uint value) external returns (bool);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // WETH-specific functions.\n    function deposit() external payable;\n\n    function withdraw(uint amount) external;\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Deposit(address indexed to, uint amount);\n    event Withdrawal(address indexed to, uint amount);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ietherwrapper\ncontract IEtherWrapper {\n    function mint(uint amount) external;\n\n    function burn(uint amount) external;\n\n    function distributeFees() external;\n\n    function capacity() external view returns (uint);\n\n    function getReserves() external view returns (uint);\n\n    function totalIssuedSynths() external view returns (uint);\n\n    function calculateMintFee(uint amount) public view returns (uint);\n\n    function calculateBurnFee(uint amount) public view returns (uint);\n\n    function maxETH() public view returns (uint256);\n\n    function mintFeeRate() public view returns (uint256);\n\n    function burnFeeRate() public view returns (uint256);\n\n    function weth() public view returns (IWETH);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iwrapperfactory\ninterface IWrapperFactory {\n    function isWrapper(address possibleWrapper) external view returns (bool);\n\n    function createWrapper(\n        IERC20 token,\n        bytes32 currencyKey,\n        bytes32 synthContractName\n    ) external returns (address);\n\n    function distributeFees() external;\n}\n\n\ninterface IFuturesMarketManager {\n    function markets(uint index, uint pageSize) external view returns (address[] memory);\n\n    function numMarkets() external view returns (uint);\n\n    function allMarkets() external view returns (address[] memory);\n\n    function marketForKey(bytes32 marketKey) external view returns (address);\n\n    function marketsForKeys(bytes32[] calldata marketKeys) external view returns (address[] memory);\n\n    function totalDebt() external view returns (uint debt, bool isInvalid);\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/debtcache\ncontract BaseDebtCache is Owned, MixinSystemSettings, IDebtCache {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    uint internal _cachedDebt;\n    mapping(bytes32 => uint) internal _cachedSynthDebt;\n    mapping(bytes32 => uint) internal _excludedIssuedDebt;\n    uint internal _cacheTimestamp;\n    bool internal _cacheInvalid = true;\n\n    // flag to ensure importing excluded debt is invoked only once\n    bool public isInitialized = false; // public to avoid needing an event\n\n    /* ========== ENCODED NAMES ========== */\n\n    bytes32 internal constant sUSD = \"sUSD\";\n    bytes32 internal constant sETH = \"sETH\";\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_ISSUER = \"Issuer\";\n    bytes32 private constant CONTRACT_EXCHANGER = \"Exchanger\";\n    bytes32 private constant CONTRACT_EXRATES = \"ExchangeRates\";\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\n    bytes32 private constant CONTRACT_COLLATERALMANAGER = \"CollateralManager\";\n    bytes32 private constant CONTRACT_ETHER_WRAPPER = \"EtherWrapper\";\n    bytes32 private constant CONTRACT_FUTURESMARKETMANAGER = \"FuturesMarketManager\";\n    bytes32 private constant CONTRACT_WRAPPER_FACTORY = \"WrapperFactory\";\n\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {}\n\n    /* ========== VIEWS ========== */\n\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();\n        bytes32[] memory newAddresses = new bytes32[](8);\n        newAddresses[0] = CONTRACT_ISSUER;\n        newAddresses[1] = CONTRACT_EXCHANGER;\n        newAddresses[2] = CONTRACT_EXRATES;\n        newAddresses[3] = CONTRACT_SYSTEMSTATUS;\n        newAddresses[4] = CONTRACT_COLLATERALMANAGER;\n        newAddresses[5] = CONTRACT_WRAPPER_FACTORY;\n        newAddresses[6] = CONTRACT_ETHER_WRAPPER;\n        newAddresses[7] = CONTRACT_FUTURESMARKETMANAGER;\n        addresses = combineArrays(existingAddresses, newAddresses);\n    }\n\n    function issuer() internal view returns (IIssuer) {\n        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));\n    }\n\n    function exchanger() internal view returns (IExchanger) {\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\n    }\n\n    function exchangeRates() internal view returns (IExchangeRates) {\n        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));\n    }\n\n    function systemStatus() internal view returns (ISystemStatus) {\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\n    }\n\n    function collateralManager() internal view returns (ICollateralManager) {\n        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));\n    }\n\n    function etherWrapper() internal view returns (IEtherWrapper) {\n        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));\n    }\n\n    function futuresMarketManager() internal view returns (IFuturesMarketManager) {\n        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));\n    }\n\n    function wrapperFactory() internal view returns (IWrapperFactory) {\n        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));\n    }\n\n    function debtSnapshotStaleTime() external view returns (uint) {\n        return getDebtSnapshotStaleTime();\n    }\n\n    function cachedDebt() external view returns (uint) {\n        return _cachedDebt;\n    }\n\n    function cachedSynthDebt(bytes32 currencyKey) external view returns (uint) {\n        return _cachedSynthDebt[currencyKey];\n    }\n\n    function cacheTimestamp() external view returns (uint) {\n        return _cacheTimestamp;\n    }\n\n    function cacheInvalid() external view returns (bool) {\n        return _cacheInvalid;\n    }\n\n    function _cacheStale(uint timestamp) internal view returns (bool) {\n        // Note a 0 timestamp means that the cache is uninitialised.\n        // We'll keep the check explicitly in case the stale time is\n        // ever set to something higher than the current unix time (e.g. to turn off staleness).\n        return getDebtSnapshotStaleTime() < block.timestamp - timestamp || timestamp == 0;\n    }\n\n    function cacheStale() external view returns (bool) {\n        return _cacheStale(_cacheTimestamp);\n    }\n\n    function _issuedSynthValues(bytes32[] memory currencyKeys, uint[] memory rates)\n        internal\n        view\n        returns (uint[] memory values)\n    {\n        uint numValues = currencyKeys.length;\n        values = new uint[](numValues);\n        ISynth[] memory synths = issuer().getSynths(currencyKeys);\n\n        for (uint i = 0; i < numValues; i++) {\n            address synthAddress = address(synths[i]);\n            require(synthAddress != address(0), \"Synth does not exist\");\n            uint supply = IERC20(synthAddress).totalSupply();\n            values[i] = supply.multiplyDecimalRound(rates[i]);\n        }\n\n        return (values);\n    }\n\n    function _currentSynthDebts(bytes32[] memory currencyKeys)\n        internal\n        view\n        returns (\n            uint[] memory snxIssuedDebts,\n            uint _futuresDebt,\n            uint _excludedDebt,\n            bool anyRateIsInvalid\n        )\n    {\n        (uint[] memory rates, bool isInvalid) = exchangeRates().ratesAndInvalidForCurrencies(currencyKeys);\n        uint[] memory values = _issuedSynthValues(currencyKeys, rates);\n        (uint excludedDebt, bool isAnyNonSnxDebtRateInvalid) = _totalNonSnxBackedDebt(currencyKeys, rates, isInvalid);\n        (uint futuresDebt, bool futuresDebtIsInvalid) = futuresMarketManager().totalDebt();\n\n        return (values, futuresDebt, excludedDebt, isInvalid || futuresDebtIsInvalid || isAnyNonSnxDebtRateInvalid);\n    }\n\n    function currentSynthDebts(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (\n            uint[] memory debtValues,\n            uint futuresDebt,\n            uint excludedDebt,\n            bool anyRateIsInvalid\n        )\n    {\n        return _currentSynthDebts(currencyKeys);\n    }\n\n    function _cachedSynthDebts(bytes32[] memory currencyKeys) internal view returns (uint[] memory) {\n        uint numKeys = currencyKeys.length;\n        uint[] memory debts = new uint[](numKeys);\n        for (uint i = 0; i < numKeys; i++) {\n            debts[i] = _cachedSynthDebt[currencyKeys[i]];\n        }\n        return debts;\n    }\n\n    function cachedSynthDebts(bytes32[] calldata currencyKeys) external view returns (uint[] memory snxIssuedDebts) {\n        return _cachedSynthDebts(currencyKeys);\n    }\n\n    function _excludedIssuedDebts(bytes32[] memory currencyKeys) internal view returns (uint[] memory) {\n        uint numKeys = currencyKeys.length;\n        uint[] memory debts = new uint[](numKeys);\n        for (uint i = 0; i < numKeys; i++) {\n            debts[i] = _excludedIssuedDebt[currencyKeys[i]];\n        }\n        return debts;\n    }\n\n    function excludedIssuedDebts(bytes32[] calldata currencyKeys) external view returns (uint[] memory excludedDebts) {\n        return _excludedIssuedDebts(currencyKeys);\n    }\n\n    /// used when migrating to new DebtCache instance in order to import the excluded debt records\n    /// If this method is not run after upgrading the contract, the debt will be\n    /// incorrect w.r.t to wrapper factory assets until the values are imported from\n    /// previous instance of the contract\n    /// Also, in addition to this method it's possible to use recordExcludedDebtChange since\n    /// it's accessible to owner in case additional adjustments are required\n    function importExcludedIssuedDebts(IDebtCache prevDebtCache, IIssuer prevIssuer) external onlyOwner {\n        // this can only be run once so that recorded debt deltas aren't accidentally\n        // lost or double counted\n        require(!isInitialized, \"already initialized\");\n        isInitialized = true;\n\n        // get the currency keys from **previous** issuer, in case current issuer\n        // doesn't have all the synths at this point\n        // warning: if a synth won't be added to the current issuer before the next upgrade of this contract,\n        // its entry will be lost (because it won't be in the prevIssuer for next time).\n        // if for some reason this is a problem, it should be possible to use recordExcludedDebtChange() to amend\n        bytes32[] memory keys = prevIssuer.availableCurrencyKeys();\n\n        require(keys.length > 0, \"previous Issuer has no synths\");\n\n        // query for previous debt records\n        uint[] memory debts = prevDebtCache.excludedIssuedDebts(keys);\n\n        // store the values\n        for (uint i = 0; i < keys.length; i++) {\n            if (debts[i] > 0) {\n                // adding the values instead of overwriting in case some deltas were recorded in this\n                // contract already (e.g. if the upgrade was not atomic)\n                _excludedIssuedDebt[keys[i]] = _excludedIssuedDebt[keys[i]].add(debts[i]);\n            }\n        }\n    }\n\n    // Returns the total sUSD debt backed by non-SNX collateral.\n    function totalNonSnxBackedDebt() external view returns (uint excludedDebt, bool isInvalid) {\n        bytes32[] memory currencyKeys = issuer().availableCurrencyKeys();\n        (uint[] memory rates, bool ratesAreInvalid) = exchangeRates().ratesAndInvalidForCurrencies(currencyKeys);\n\n        return _totalNonSnxBackedDebt(currencyKeys, rates, ratesAreInvalid);\n    }\n\n    function _totalNonSnxBackedDebt(\n        bytes32[] memory currencyKeys,\n        uint[] memory rates,\n        bool ratesAreInvalid\n    ) internal view returns (uint excludedDebt, bool isInvalid) {\n        // Calculate excluded debt.\n        // 1. MultiCollateral long debt + short debt.\n        (uint longValue, bool anyTotalLongRateIsInvalid) = collateralManager().totalLong();\n        (uint shortValue, bool anyTotalShortRateIsInvalid) = collateralManager().totalShort();\n        isInvalid = ratesAreInvalid || anyTotalLongRateIsInvalid || anyTotalShortRateIsInvalid;\n        excludedDebt = longValue.add(shortValue);\n\n        // 2. EtherWrapper.\n        // Subtract sETH and sUSD issued by EtherWrapper.\n        excludedDebt = excludedDebt.add(etherWrapper().totalIssuedSynths());\n\n        // 3. WrapperFactory.\n        // Get the debt issued by the Wrappers.\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            excludedDebt = excludedDebt.add(_excludedIssuedDebt[currencyKeys[i]].multiplyDecimalRound(rates[i]));\n        }\n\n        return (excludedDebt, isInvalid);\n    }\n\n    function _currentDebt() internal view returns (uint debt, bool anyRateIsInvalid) {\n        bytes32[] memory currencyKeys = issuer().availableCurrencyKeys();\n        (uint[] memory rates, bool isInvalid) = exchangeRates().ratesAndInvalidForCurrencies(currencyKeys);\n\n        // Sum all issued synth values based on their supply.\n        uint[] memory values = _issuedSynthValues(currencyKeys, rates);\n        (uint excludedDebt, bool isAnyNonSnxDebtRateInvalid) = _totalNonSnxBackedDebt(currencyKeys, rates, isInvalid);\n\n        uint numValues = values.length;\n        uint total;\n        for (uint i; i < numValues; i++) {\n            total = total.add(values[i]);\n        }\n\n        // Add in the debt accounted for by futures\n        (uint futuresDebt, bool futuresDebtIsInvalid) = futuresMarketManager().totalDebt();\n        total = total.add(futuresDebt);\n\n        // Ensure that if the excluded non-SNX debt exceeds SNX-backed debt, no overflow occurs\n        total = total < excludedDebt ? 0 : total.sub(excludedDebt);\n\n        return (total, isInvalid || futuresDebtIsInvalid || isAnyNonSnxDebtRateInvalid);\n    }\n\n    function currentDebt() external view returns (uint debt, bool anyRateIsInvalid) {\n        return _currentDebt();\n    }\n\n    function cacheInfo()\n        external\n        view\n        returns (\n            uint debt,\n            uint timestamp,\n            bool isInvalid,\n            bool isStale\n        )\n    {\n        uint time = _cacheTimestamp;\n        return (_cachedDebt, time, _cacheInvalid, _cacheStale(time));\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    // Stub out all mutative functions as no-ops;\n    // since they do nothing, there are no restrictions\n\n    function updateCachedSynthDebts(bytes32[] calldata currencyKeys) external {}\n\n    function updateCachedSynthDebtWithRate(bytes32 currencyKey, uint currencyRate) external {}\n\n    function updateCachedSynthDebtsWithRates(bytes32[] calldata currencyKeys, uint[] calldata currencyRates) external {}\n\n    function updateDebtCacheValidity(bool currentlyInvalid) external {}\n\n    function purgeCachedSynthDebt(bytes32 currencyKey) external {}\n\n    function takeDebtSnapshot() external {}\n\n    function recordExcludedDebtChange(bytes32 currencyKey, int256 delta) external {}\n\n    function updateCachedsUSDDebt(int amount) external {}\n\n    /* ========== MODIFIERS ========== */\n\n    function _requireSystemActiveIfNotOwner() internal view {\n        if (msg.sender != owner) {\n            systemStatus().requireSystemActive();\n        }\n    }\n\n    modifier requireSystemActiveIfNotOwner() {\n        _requireSystemActiveIfNotOwner();\n        _;\n    }\n\n    function _onlyIssuer() internal view {\n        require(msg.sender == address(issuer()), \"Sender is not Issuer\");\n    }\n\n    modifier onlyIssuer() {\n        _onlyIssuer();\n        _;\n    }\n\n    function _onlyIssuerOrExchanger() internal view {\n        require(msg.sender == address(issuer()) || msg.sender == address(exchanger()), \"Sender is not Issuer or Exchanger\");\n    }\n\n    modifier onlyIssuerOrExchanger() {\n        _onlyIssuerOrExchanger();\n        _;\n    }\n\n    function _onlyDebtIssuer() internal view {\n        bool isWrapper = wrapperFactory().isWrapper(msg.sender);\n\n        // owner included for debugging and fixing in emergency situation\n        bool isOwner = msg.sender == owner;\n\n        require(isOwner || isWrapper, \"Only debt issuers may call this\");\n    }\n\n    modifier onlyDebtIssuer() {\n        _onlyDebtIssuer();\n        _;\n    }\n}\n\n\n// Libraries\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/debtcache\ncontract DebtCache is BaseDebtCache {\n    using SafeDecimalMath for uint;\n\n    bytes32 public constant CONTRACT_NAME = \"DebtCache\";\n\n    constructor(address _owner, address _resolver) public BaseDebtCache(_owner, _resolver) {}\n\n    bytes32 internal constant EXCLUDED_DEBT_KEY = \"EXCLUDED_DEBT\";\n    bytes32 internal constant FUTURES_DEBT_KEY = \"FUTURES_DEBT\";\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    // This function exists in case a synth is ever somehow removed without its snapshot being updated.\n    function purgeCachedSynthDebt(bytes32 currencyKey) external onlyOwner {\n        require(issuer().synths(currencyKey) == ISynth(0), \"Synth exists\");\n        delete _cachedSynthDebt[currencyKey];\n    }\n\n    function takeDebtSnapshot() external requireSystemActiveIfNotOwner {\n        bytes32[] memory currencyKeys = issuer().availableCurrencyKeys();\n        (uint[] memory values, uint futuresDebt, uint excludedDebt, bool isInvalid) = _currentSynthDebts(currencyKeys);\n\n        // The total SNX-backed debt is the debt of futures markets plus the debt of circulating synths.\n        uint snxCollateralDebt = futuresDebt;\n        _cachedSynthDebt[FUTURES_DEBT_KEY] = futuresDebt;\n        uint numValues = values.length;\n        for (uint i; i < numValues; i++) {\n            uint value = values[i];\n            snxCollateralDebt = snxCollateralDebt.add(value);\n            _cachedSynthDebt[currencyKeys[i]] = value;\n        }\n\n        // Subtract out the excluded non-SNX backed debt from our total\n        _cachedSynthDebt[EXCLUDED_DEBT_KEY] = excludedDebt;\n        uint newDebt = snxCollateralDebt.floorsub(excludedDebt);\n        _cachedDebt = newDebt;\n        _cacheTimestamp = block.timestamp;\n        emit DebtCacheUpdated(newDebt);\n        emit DebtCacheSnapshotTaken(block.timestamp);\n\n        // (in)validate the cache if necessary\n        _updateDebtCacheValidity(isInvalid);\n    }\n\n    function updateCachedSynthDebts(bytes32[] calldata currencyKeys) external requireSystemActiveIfNotOwner {\n        (uint[] memory rates, bool anyRateInvalid) = exchangeRates().ratesAndInvalidForCurrencies(currencyKeys);\n        _updateCachedSynthDebtsWithRates(currencyKeys, rates, anyRateInvalid);\n    }\n\n    function updateCachedSynthDebtWithRate(bytes32 currencyKey, uint currencyRate) external onlyIssuer {\n        bytes32[] memory synthKeyArray = new bytes32[](1);\n        synthKeyArray[0] = currencyKey;\n        uint[] memory synthRateArray = new uint[](1);\n        synthRateArray[0] = currencyRate;\n        _updateCachedSynthDebtsWithRates(synthKeyArray, synthRateArray, false);\n    }\n\n    function updateCachedSynthDebtsWithRates(bytes32[] calldata currencyKeys, uint[] calldata currencyRates)\n        external\n        onlyIssuerOrExchanger\n    {\n        _updateCachedSynthDebtsWithRates(currencyKeys, currencyRates, false);\n    }\n\n    function updateDebtCacheValidity(bool currentlyInvalid) external onlyIssuer {\n        _updateDebtCacheValidity(currentlyInvalid);\n    }\n\n    function recordExcludedDebtChange(bytes32 currencyKey, int256 delta) external onlyDebtIssuer {\n        int256 newExcludedDebt = int256(_excludedIssuedDebt[currencyKey]) + delta;\n\n        require(newExcludedDebt >= 0, \"Excluded debt cannot become negative\");\n\n        _excludedIssuedDebt[currencyKey] = uint(newExcludedDebt);\n    }\n\n    function updateCachedsUSDDebt(int amount) external onlyIssuer {\n        uint delta = SafeDecimalMath.abs(amount);\n        if (amount > 0) {\n            _cachedSynthDebt[sUSD] = _cachedSynthDebt[sUSD].add(delta);\n            _cachedDebt = _cachedDebt.add(delta);\n        } else {\n            _cachedSynthDebt[sUSD] = _cachedSynthDebt[sUSD].sub(delta);\n            _cachedDebt = _cachedDebt.sub(delta);\n        }\n\n        emit DebtCacheUpdated(_cachedDebt);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _updateDebtCacheValidity(bool currentlyInvalid) internal {\n        if (_cacheInvalid != currentlyInvalid) {\n            _cacheInvalid = currentlyInvalid;\n            emit DebtCacheValidityChanged(currentlyInvalid);\n        }\n    }\n\n    // Updated the global debt according to a rate/supply change in a subset of issued synths.\n    function _updateCachedSynthDebtsWithRates(\n        bytes32[] memory currencyKeys,\n        uint[] memory currentRates,\n        bool anyRateIsInvalid\n    ) internal {\n        uint numKeys = currencyKeys.length;\n        require(numKeys == currentRates.length, \"Input array lengths differ\");\n\n        // Compute the cached and current debt sum for the subset of synths provided.\n        uint cachedSum;\n        uint currentSum;\n        uint[] memory currentValues = _issuedSynthValues(currencyKeys, currentRates);\n\n        for (uint i = 0; i < numKeys; i++) {\n            bytes32 key = currencyKeys[i];\n            uint currentSynthDebt = currentValues[i];\n\n            cachedSum = cachedSum.add(_cachedSynthDebt[key]);\n            currentSum = currentSum.add(currentSynthDebt);\n\n            _cachedSynthDebt[key] = currentSynthDebt;\n        }\n\n        // Apply the debt update.\n        if (cachedSum != currentSum) {\n            uint debt = _cachedDebt;\n            // apply the delta between the cachedSum and currentSum\n            // add currentSum before sub cachedSum to prevent overflow as cachedSum > debt for large amount of excluded debt\n            debt = debt.add(currentSum).sub(cachedSum);\n            _cachedDebt = debt;\n            emit DebtCacheUpdated(debt);\n        }\n\n        // Invalidate the cache if necessary\n        if (anyRateIsInvalid) {\n            _updateDebtCacheValidity(anyRateIsInvalid);\n        }\n    }\n\n    /* ========== EVENTS ========== */\n\n    event DebtCacheUpdated(uint cachedDebt);\n    event DebtCacheSnapshotTaken(uint timestamp);\n    event DebtCacheValidityChanged(bool indexed isInvalid);\n}\n\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n\n\n/**\n * @title The V2 & V3 Aggregator Interface\n * @notice Solidity V0.5 does not allow interfaces to inherit from other\n * interfaces so this contract is a combination of v0.5 AggregatorInterface.sol\n * and v0.5 AggregatorV3Interface.sol.\n */\ninterface AggregatorV2V3Interface {\n  //\n  // V2 Interface:\n  //\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n\n  //\n  // V3 Interface:\n  //\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n\n\ninterface FlagsInterface {\n  function getFlag(address) external view returns (bool);\n  function getFlags(address[] calldata) external view returns (bool[] memory);\n  function raiseFlag(address) external;\n  function raiseFlags(address[] calldata) external;\n  function lowerFlags(address[] calldata) external;\n  function setRaisingAccessController(address) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/IExchangeCircuitBreaker\ninterface IExchangeCircuitBreaker {\n    // Views\n\n    function exchangeRates() external view returns (address);\n\n    function rateWithInvalid(bytes32 currencyKey) external view returns (uint, bool);\n\n    function priceDeviationThresholdFactor() external view returns (uint);\n\n    function isDeviationAboveThreshold(uint base, uint comparison) external view returns (bool);\n\n    function lastExchangeRate(bytes32 currencyKey) external view returns (uint);\n\n    // Mutative functions\n    function resetLastExchangeRate(bytes32[] calldata currencyKeys) external;\n\n    function rateWithBreakCircuit(bytes32 currencyKey) external returns (uint lastValidRate, bool circuitBroken);\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n// AggregatorInterface from Chainlink represents a decentralized pricing network for a single currency key\n\n// FlagsInterface from Chainlink addresses SIP-76\n\n\n// https://docs.synthetix.io/contracts/source/contracts/exchangerates\ncontract ExchangeRates is Owned, MixinSystemSettings, IExchangeRates {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    bytes32 public constant CONTRACT_NAME = \"ExchangeRates\";\n    //slither-disable-next-line naming-convention\n    bytes32 internal constant sUSD = \"sUSD\";\n\n    // Decentralized oracle networks that feed into pricing aggregators\n    mapping(bytes32 => AggregatorV2V3Interface) public aggregators;\n\n    mapping(bytes32 => uint8) public currencyKeyDecimals;\n\n    // List of aggregator keys for convenient iteration\n    bytes32[] public aggregatorKeys;\n\n    // ========== CONSTRUCTOR ==========\n\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {}\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function addAggregator(bytes32 currencyKey, address aggregatorAddress) external onlyOwner {\n        AggregatorV2V3Interface aggregator = AggregatorV2V3Interface(aggregatorAddress);\n        // This check tries to make sure that a valid aggregator is being added.\n        // It checks if the aggregator is an existing smart contract that has implemented `latestTimestamp` function.\n\n        require(aggregator.latestRound() >= 0, \"Given Aggregator is invalid\");\n        uint8 decimals = aggregator.decimals();\n        require(decimals <= 18, \"Aggregator decimals should be lower or equal to 18\");\n        if (address(aggregators[currencyKey]) == address(0)) {\n            aggregatorKeys.push(currencyKey);\n        }\n        aggregators[currencyKey] = aggregator;\n        currencyKeyDecimals[currencyKey] = decimals;\n        emit AggregatorAdded(currencyKey, address(aggregator));\n    }\n\n    function removeAggregator(bytes32 currencyKey) external onlyOwner {\n        address aggregator = address(aggregators[currencyKey]);\n        require(aggregator != address(0), \"No aggregator exists for key\");\n        delete aggregators[currencyKey];\n        delete currencyKeyDecimals[currencyKey];\n\n        bool wasRemoved = removeFromArray(currencyKey, aggregatorKeys);\n\n        if (wasRemoved) {\n            emit AggregatorRemoved(currencyKey, aggregator);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory currencies) {\n        uint count = 0;\n        currencies = new bytes32[](aggregatorKeys.length);\n        for (uint i = 0; i < aggregatorKeys.length; i++) {\n            bytes32 currencyKey = aggregatorKeys[i];\n            if (address(aggregators[currencyKey]) == aggregator) {\n                currencies[count++] = currencyKey;\n            }\n        }\n    }\n\n    function rateStalePeriod() external view returns (uint) {\n        return getRateStalePeriod();\n    }\n\n    function aggregatorWarningFlags() external view returns (address) {\n        return getAggregatorWarningFlags();\n    }\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time) {\n        RateAndUpdatedTime memory rateAndTime = _getRateAndUpdatedTime(currencyKey);\n        return (rateAndTime.rate, rateAndTime.time);\n    }\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint) {\n        uint roundId = startingRoundId;\n        uint nextTimestamp = 0;\n        while (true) {\n            (, nextTimestamp) = _getRateAndTimestampAtRound(currencyKey, roundId + 1);\n            // if there's no new round, then the previous roundId was the latest\n            if (nextTimestamp == 0 || nextTimestamp > startingTimestamp + timediff) {\n                return roundId;\n            }\n            roundId++;\n        }\n        return roundId;\n    }\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint) {\n        return _getCurrentRoundId(currencyKey);\n    }\n\n    function effectiveValueAndRatesAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        )\n    {\n        (sourceRate, ) = _getRateAndTimestampAtRound(sourceCurrencyKey, roundIdForSrc);\n        // If there's no change in the currency, then just return the amount they gave us\n        if (sourceCurrencyKey == destinationCurrencyKey) {\n            destinationRate = sourceRate;\n            value = sourceAmount;\n        } else {\n            (destinationRate, ) = _getRateAndTimestampAtRound(destinationCurrencyKey, roundIdForDest);\n            // prevent divide-by 0 error (this happens if the dest is not a valid rate)\n            if (destinationRate > 0) {\n                // Calculate the effective value by going from source -> USD -> destination\n                value = sourceAmount.multiplyDecimalRound(sourceRate).divideDecimalRound(destinationRate);\n            }\n        }\n    }\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time) {\n        return _getRateAndTimestampAtRound(currencyKey, roundId);\n    }\n\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256) {\n        return _getUpdatedTime(currencyKey);\n    }\n\n    function lastRateUpdateTimesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory) {\n        uint[] memory lastUpdateTimes = new uint[](currencyKeys.length);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            lastUpdateTimes[i] = _getUpdatedTime(currencyKeys[i]);\n        }\n\n        return lastUpdateTimes;\n    }\n\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value) {\n        (value, , ) = _effectiveValueAndRates(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);\n    }\n\n    function effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        )\n    {\n        return _effectiveValueAndRates(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    function effectiveAtomicValueAndRates(\n        bytes32,\n        uint,\n        bytes32\n    )\n        external\n        view\n        returns (\n            uint,\n            uint,\n            uint,\n            uint\n        )\n    {\n        _notImplemented();\n    }\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint) {\n        return _getRateAndUpdatedTime(currencyKey).rate;\n    }\n\n    /// @notice getting N rounds of rates for a currency at a specific round\n    /// @param currencyKey the currency key\n    /// @param numRounds the number of rounds to get\n    /// @param roundId the round id\n    /// @return a list of rates and a list of times\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(\n        bytes32 currencyKey,\n        uint numRounds,\n        uint roundId\n    ) external view returns (uint[] memory rates, uint[] memory times) {\n        rates = new uint[](numRounds);\n        times = new uint[](numRounds);\n\n        roundId = roundId > 0 ? roundId : _getCurrentRoundId(currencyKey);\n        for (uint i = 0; i < numRounds; i++) {\n            // fetch the rate and treat is as current, so inverse limits if frozen will always be applied\n            // regardless of current rate\n            (rates[i], times[i]) = _getRateAndTimestampAtRound(currencyKey, roundId);\n\n            if (roundId == 0) {\n                // if we hit the last round, then return what we have\n                return (rates, times);\n            } else {\n                roundId--;\n            }\n        }\n    }\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory) {\n        uint[] memory _localRates = new uint[](currencyKeys.length);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            _localRates[i] = _getRate(currencyKeys[i]);\n        }\n\n        return _localRates;\n    }\n\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid) {\n        RateAndUpdatedTime memory rateAndTime = _getRateAndUpdatedTime(currencyKey);\n\n        if (currencyKey == sUSD) {\n            return (rateAndTime.rate, false);\n        }\n        return (\n            rateAndTime.rate,\n            _rateIsStaleWithTime(getRateStalePeriod(), rateAndTime.time) ||\n                _rateIsFlagged(currencyKey, FlagsInterface(getAggregatorWarningFlags()))\n        );\n    }\n\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (uint[] memory rates, bool anyRateInvalid)\n    {\n        rates = new uint[](currencyKeys.length);\n\n        uint256 _rateStalePeriod = getRateStalePeriod();\n\n        // fetch all flags at once\n        bool[] memory flagList = getFlagsForRates(currencyKeys);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            // do one lookup of the rate & time to minimize gas\n            RateAndUpdatedTime memory rateEntry = _getRateAndUpdatedTime(currencyKeys[i]);\n            rates[i] = rateEntry.rate;\n            if (!anyRateInvalid && currencyKeys[i] != sUSD) {\n                anyRateInvalid = flagList[i] || _rateIsStaleWithTime(_rateStalePeriod, rateEntry.time);\n            }\n        }\n    }\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool) {\n        return _rateIsStale(currencyKey, getRateStalePeriod());\n    }\n\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool) {\n        return\n            _rateIsStale(currencyKey, getRateStalePeriod()) ||\n            _rateIsFlagged(currencyKey, FlagsInterface(getAggregatorWarningFlags()));\n    }\n\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool) {\n        return _rateIsFlagged(currencyKey, FlagsInterface(getAggregatorWarningFlags()));\n    }\n\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool) {\n        // Loop through each key and check whether the data point is stale.\n\n        uint256 _rateStalePeriod = getRateStalePeriod();\n        bool[] memory flagList = getFlagsForRates(currencyKeys);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            if (flagList[i] || _rateIsStale(currencyKeys[i], _rateStalePeriod)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /// this method checks whether any rate is:\n    /// 1. flagged\n    /// 2. stale with respect to current time (now)\n    function anyRateIsInvalidAtRound(bytes32[] calldata currencyKeys, uint[] calldata roundIds)\n        external\n        view\n        returns (bool)\n    {\n        // Loop through each key and check whether the data point is stale.\n\n        require(roundIds.length == currencyKeys.length, \"roundIds must be the same length as currencyKeys\");\n\n        uint256 _rateStalePeriod = getRateStalePeriod();\n        bool[] memory flagList = getFlagsForRates(currencyKeys);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            if (flagList[i] || _rateIsStaleAtRound(currencyKeys[i], roundIds[i], _rateStalePeriod)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function synthTooVolatileForAtomicExchange(bytes32) external view returns (bool) {\n        _notImplemented();\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function getFlagsForRates(bytes32[] memory currencyKeys) internal view returns (bool[] memory flagList) {\n        FlagsInterface _flags = FlagsInterface(getAggregatorWarningFlags());\n\n        // fetch all flags at once\n        if (_flags != FlagsInterface(0)) {\n            address[] memory _aggregators = new address[](currencyKeys.length);\n\n            for (uint i = 0; i < currencyKeys.length; i++) {\n                _aggregators[i] = address(aggregators[currencyKeys[i]]);\n            }\n\n            flagList = _flags.getFlags(_aggregators);\n        } else {\n            flagList = new bool[](currencyKeys.length);\n        }\n    }\n\n    function removeFromArray(bytes32 entry, bytes32[] storage array) internal returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == entry) {\n                delete array[i];\n\n                // Copy the last key into the place of the one we just deleted\n                // If there's only one key, this is array[0] = array[0].\n                // If we're deleting the last one, it's also a NOOP in the same way.\n                array[i] = array[array.length - 1];\n\n                // Decrease the size of the array by one.\n                array.length--;\n\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _formatAggregatorAnswer(bytes32 currencyKey, int256 rate) internal view returns (uint) {\n        require(rate >= 0, \"Negative rate not supported\");\n        if (currencyKeyDecimals[currencyKey] > 0) {\n            uint multiplier = 10**uint(SafeMath.sub(18, currencyKeyDecimals[currencyKey]));\n            return uint(uint(rate).mul(multiplier));\n        }\n        return uint(rate);\n    }\n\n    function _getRateAndUpdatedTime(bytes32 currencyKey) internal view returns (RateAndUpdatedTime memory) {\n        // sUSD rate is 1.0\n        if (currencyKey == sUSD) {\n            return RateAndUpdatedTime({rate: uint216(SafeDecimalMath.unit()), time: 0});\n        } else {\n            AggregatorV2V3Interface aggregator = aggregators[currencyKey];\n            if (aggregator != AggregatorV2V3Interface(0)) {\n                // this view from the aggregator is the most gas efficient but it can throw when there's no data,\n                // so let's call it low-level to suppress any reverts\n                bytes memory payload = abi.encodeWithSignature(\"latestRoundData()\");\n                // solhint-disable avoid-low-level-calls\n                // slither-disable-next-line low-level-calls\n                (bool success, bytes memory returnData) = address(aggregator).staticcall(payload);\n\n                if (success) {\n                    (, int256 answer, , uint256 updatedAt, ) =\n                        abi.decode(returnData, (uint80, int256, uint256, uint256, uint80));\n                    return\n                        RateAndUpdatedTime({\n                            rate: uint216(_formatAggregatorAnswer(currencyKey, answer)),\n                            time: uint40(updatedAt)\n                        });\n                } // else return defaults, to avoid reverting in views\n            } // else return defaults, to avoid reverting in views\n        }\n    }\n\n    function _getCurrentRoundId(bytes32 currencyKey) internal view returns (uint) {\n        if (currencyKey == sUSD) {\n            return 0;\n        }\n        AggregatorV2V3Interface aggregator = aggregators[currencyKey];\n        if (aggregator != AggregatorV2V3Interface(0)) {\n            return aggregator.latestRound();\n        } // else return defaults, to avoid reverting in views\n    }\n\n    function _getRateAndTimestampAtRound(bytes32 currencyKey, uint roundId) internal view returns (uint rate, uint time) {\n        // short circuit sUSD\n        if (currencyKey == sUSD) {\n            // sUSD has no rounds, and 0 time is preferrable for \"volatility\" heuristics\n            // which are used in atomic swaps and fee reclamation\n            return (SafeDecimalMath.unit(), 0);\n        } else {\n            AggregatorV2V3Interface aggregator = aggregators[currencyKey];\n            if (aggregator != AggregatorV2V3Interface(0)) {\n                // this view from the aggregator is the most gas efficient but it can throw when there's no data,\n                // so let's call it low-level to suppress any reverts\n                bytes memory payload = abi.encodeWithSignature(\"getRoundData(uint80)\", roundId);\n                // solhint-disable avoid-low-level-calls\n                (bool success, bytes memory returnData) = address(aggregator).staticcall(payload);\n\n                if (success) {\n                    (, int256 answer, , uint256 updatedAt, ) =\n                        abi.decode(returnData, (uint80, int256, uint256, uint256, uint80));\n                    return (_formatAggregatorAnswer(currencyKey, answer), updatedAt);\n                } // else return defaults, to avoid reverting in views\n            } // else return defaults, to avoid reverting in views\n        }\n    }\n\n    function _getRate(bytes32 currencyKey) internal view returns (uint256) {\n        return _getRateAndUpdatedTime(currencyKey).rate;\n    }\n\n    function _getUpdatedTime(bytes32 currencyKey) internal view returns (uint256) {\n        return _getRateAndUpdatedTime(currencyKey).time;\n    }\n\n    function _effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        internal\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        )\n    {\n        sourceRate = _getRate(sourceCurrencyKey);\n        // If there's no change in the currency, then just return the amount they gave us\n        if (sourceCurrencyKey == destinationCurrencyKey) {\n            destinationRate = sourceRate;\n            value = sourceAmount;\n        } else {\n            // Calculate the effective value by going from source -> USD -> destination\n            destinationRate = _getRate(destinationCurrencyKey);\n            // prevent divide-by 0 error (this happens if the dest is not a valid rate)\n            if (destinationRate > 0) {\n                value = sourceAmount.multiplyDecimalRound(sourceRate).divideDecimalRound(destinationRate);\n            }\n        }\n    }\n\n    function _rateIsStale(bytes32 currencyKey, uint _rateStalePeriod) internal view returns (bool) {\n        // sUSD is a special case and is never stale (check before an SLOAD of getRateAndUpdatedTime)\n        if (currencyKey == sUSD) {\n            return false;\n        }\n        return _rateIsStaleWithTime(_rateStalePeriod, _getUpdatedTime(currencyKey));\n    }\n\n    function _rateIsStaleAtRound(\n        bytes32 currencyKey,\n        uint roundId,\n        uint _rateStalePeriod\n    ) internal view returns (bool) {\n        // sUSD is a special case and is never stale (check before an SLOAD of getRateAndUpdatedTime)\n        if (currencyKey == sUSD) {\n            return false;\n        }\n        (, uint time) = _getRateAndTimestampAtRound(currencyKey, roundId);\n        return _rateIsStaleWithTime(_rateStalePeriod, time);\n    }\n\n    function _rateIsStaleWithTime(uint _rateStalePeriod, uint _time) internal view returns (bool) {\n        return _time.add(_rateStalePeriod) < now;\n    }\n\n    function _rateIsFlagged(bytes32 currencyKey, FlagsInterface flags) internal view returns (bool) {\n        // sUSD is a special case and is never invalid\n        if (currencyKey == sUSD) {\n            return false;\n        }\n        address aggregator = address(aggregators[currencyKey]);\n        // when no aggregator or when the flags haven't been setup\n        if (aggregator == address(0) || flags == FlagsInterface(0)) {\n            return false;\n        }\n        return flags.getFlag(aggregator);\n    }\n\n    function _notImplemented() internal pure {\n        // slither-disable-next-line dead-code\n        revert(\"Cannot be run on this layer\");\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AggregatorAdded(bytes32 currencyKey, address aggregator);\n    event AggregatorRemoved(bytes32 currencyKey, address aggregator);\n}\n\n\n// https://sips.synthetix.io/sips/sip-120/\n// Uniswap V3 based DecPriceAggregator (unaudited) e.g. https://etherscan.io/address/0xf120f029ac143633d1942e48ae2dfa2036c5786c#code\n// https://github.com/sohkai/uniswap-v3-spot-twap-oracle\n//  inteface: https://github.com/sohkai/uniswap-v3-spot-twap-oracle/blob/8f9777a6160a089c99f39f2ee297119ee293bc4b/contracts/interfaces/IDexPriceAggregator.sol\n//  implementation: https://github.com/sohkai/uniswap-v3-spot-twap-oracle/blob/8f9777a6160a089c99f39f2ee297119ee293bc4b/contracts/DexPriceAggregatorUniswapV3.sol\ninterface IDexPriceAggregator {\n    function assetToAsset(\n        address tokenIn,\n        uint amountIn,\n        address tokenOut,\n        uint twapPeriod\n    ) external view returns (uint amountOut);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/exchangerateswithdexpricing\ncontract ExchangeRatesWithDexPricing is ExchangeRates {\n    bytes32 public constant CONTRACT_NAME = \"ExchangeRatesWithDexPricing\";\n\n    bytes32 internal constant SETTING_DEX_PRICE_AGGREGATOR = \"dexPriceAggregator\";\n\n    constructor(address _owner, address _resolver) public ExchangeRates(_owner, _resolver) {}\n\n    /* ========== SETTERS ========== */\n\n    function setDexPriceAggregator(IDexPriceAggregator _dexPriceAggregator) external onlyOwner {\n        flexibleStorage().setAddressValue(\n            ExchangeRates.CONTRACT_NAME,\n            SETTING_DEX_PRICE_AGGREGATOR,\n            address(_dexPriceAggregator)\n        );\n        emit DexPriceAggregatorUpdated(address(_dexPriceAggregator));\n    }\n\n    /* ========== VIEWS ========== */\n\n    function dexPriceAggregator() public view returns (IDexPriceAggregator) {\n        return\n            IDexPriceAggregator(\n                flexibleStorage().getAddressValue(ExchangeRates.CONTRACT_NAME, SETTING_DEX_PRICE_AGGREGATOR)\n            );\n    }\n\n    function atomicTwapWindow() external view returns (uint) {\n        return getAtomicTwapWindow();\n    }\n\n    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {\n        return getAtomicEquivalentForDexPricing(currencyKey);\n    }\n\n    function atomicPriceBuffer(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicPriceBuffer(currencyKey);\n    }\n\n    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicVolatilityConsiderationWindow(currencyKey);\n    }\n\n    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicVolatilityUpdateThreshold(currencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    // Note that the returned systemValue, systemSourceRate, and systemDestinationRate are based on\n    // the current system rate, which may not be the atomic rate derived from value / sourceAmount\n    function effectiveAtomicValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint systemValue,\n            uint systemSourceRate,\n            uint systemDestinationRate\n        )\n    {\n        IERC20 sourceEquivalent = IERC20(getAtomicEquivalentForDexPricing(sourceCurrencyKey));\n        require(address(sourceEquivalent) != address(0), \"No atomic equivalent for src\");\n\n        IERC20 destEquivalent = IERC20(getAtomicEquivalentForDexPricing(destinationCurrencyKey));\n        require(address(destEquivalent) != address(0), \"No atomic equivalent for dest\");\n\n        (systemValue, systemSourceRate, systemDestinationRate) = _effectiveValueAndRates(\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey\n        );\n        // Derive P_CLBUF from highest configured buffer between source and destination synth\n        uint sourceBuffer = getAtomicPriceBuffer(sourceCurrencyKey);\n        uint destBuffer = getAtomicPriceBuffer(destinationCurrencyKey);\n        uint priceBuffer = sourceBuffer > destBuffer ? sourceBuffer : destBuffer; // max\n        uint pClbufValue = systemValue.multiplyDecimal(SafeDecimalMath.unit().sub(priceBuffer));\n\n        // refactired due to stack too deep\n        uint pDexValue = _dexPriceDestinationValue(sourceEquivalent, destEquivalent, sourceAmount);\n\n        // Final value is minimum output between P_CLBUF and P_TWAP\n        value = pClbufValue < pDexValue ? pClbufValue : pDexValue; // min\n    }\n\n    function _dexPriceDestinationValue(\n        IERC20 sourceEquivalent,\n        IERC20 destEquivalent,\n        uint sourceAmount\n    ) internal view returns (uint) {\n        // Normalize decimals in case equivalent asset uses different decimals from internal unit\n        uint sourceAmountInEquivalent =\n            (sourceAmount.mul(10**uint(sourceEquivalent.decimals()))).div(SafeDecimalMath.unit());\n\n        uint twapWindow = getAtomicTwapWindow();\n        require(twapWindow != 0, \"Uninitialized atomic twap window\");\n\n        uint twapValueInEquivalent =\n            dexPriceAggregator().assetToAsset(\n                address(sourceEquivalent),\n                sourceAmountInEquivalent,\n                address(destEquivalent),\n                twapWindow\n            );\n        require(twapValueInEquivalent > 0, \"dex price returned 0\");\n\n        // Similar to source amount, normalize decimals back to internal unit for output amount\n        return (twapValueInEquivalent.mul(SafeDecimalMath.unit())).div(10**uint(destEquivalent.decimals()));\n    }\n\n    function synthTooVolatileForAtomicExchange(bytes32 currencyKey) external view returns (bool) {\n        // sUSD is a special case and is never volatile\n        if (currencyKey == \"sUSD\") return false;\n\n        uint considerationWindow = getAtomicVolatilityConsiderationWindow(currencyKey);\n        uint updateThreshold = getAtomicVolatilityUpdateThreshold(currencyKey);\n\n        if (considerationWindow == 0 || updateThreshold == 0) {\n            // If either volatility setting is not set, never judge an asset to be volatile\n            return false;\n        }\n\n        // Go back through the historical oracle update rounds to see if there have been more\n        // updates in the consideration window than the allowed threshold.\n        // If there have, consider the asset volatile--by assumption that many close-by oracle\n        // updates is a good proxy for price volatility.\n        uint considerationWindowStart = block.timestamp.sub(considerationWindow);\n        uint roundId = _getCurrentRoundId(currencyKey);\n        for (updateThreshold; updateThreshold > 0; updateThreshold--) {\n            (uint rate, uint time) = _getRateAndTimestampAtRound(currencyKey, roundId);\n            if (time != 0 && time < considerationWindowStart) {\n                // Round was outside consideration window so we can stop querying further rounds\n                return false;\n            } else if (rate == 0 || time == 0) {\n                // Either entire round or a rate inside consideration window was not available\n                // Consider the asset volatile\n                break;\n            }\n\n            if (roundId == 0) {\n                // Not enough historical data to continue further\n                // Consider the asset volatile\n                break;\n            }\n            roundId--;\n        }\n\n        return true;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event DexPriceAggregatorUpdated(address newDexPriceAggregator);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/state\ncontract State is Owned {\n    // the address of the contract that can modify variables\n    // this can only be changed by the owner of this contract\n    address public associatedContract;\n\n    constructor(address _associatedContract) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== SETTERS ========== */\n\n    // Change the associated contract to a new address\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyAssociatedContract {\n        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AssociatedContractUpdated(address associatedContract);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangestate\ninterface IExchangeState {\n    // Views\n    struct ExchangeEntry {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint amountReceived;\n        uint exchangeFeeRate;\n        uint timestamp;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint);\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        );\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint);\n\n    // Mutative functions\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external;\n\n    function removeEntries(address account, bytes32 currencyKey) external;\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/exchangestate\ncontract ExchangeState is Owned, State, IExchangeState {\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/proxy\ncontract Proxy is Owned {\n    Proxyable public target;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    function setTarget(Proxyable _target) external onlyOwner {\n        target = _target;\n        emit TargetUpdated(_target);\n    }\n\n    function _emit(\n        bytes calldata callData,\n        uint numTopics,\n        bytes32 topic1,\n        bytes32 topic2,\n        bytes32 topic3,\n        bytes32 topic4\n    ) external onlyTarget {\n        uint size = callData.length;\n        bytes memory _callData = callData;\n\n        assembly {\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\n             * This means moving call_data across 32 bytes guarantees we correctly access\n             * the data itself. */\n            switch numTopics\n                case 0 {\n                    log0(add(_callData, 32), size)\n                }\n                case 1 {\n                    log1(add(_callData, 32), size, topic1)\n                }\n                case 2 {\n                    log2(add(_callData, 32), size, topic1, topic2)\n                }\n                case 3 {\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\n                }\n                case 4 {\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\n                }\n        }\n    }\n\n    // solhint-disable no-complex-fallback\n    function() external payable {\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\n        target.setMessageSender(msg.sender);\n\n        assembly {\n            let free_ptr := mload(0x40)\n            calldatacopy(free_ptr, 0, calldatasize)\n\n            /* We must explicitly forward ether to the underlying contract as well. */\n            let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n            returndatacopy(free_ptr, 0, returndatasize)\n\n            if iszero(result) {\n                revert(free_ptr, returndatasize)\n            }\n            return(free_ptr, returndatasize)\n        }\n    }\n\n    modifier onlyTarget {\n        require(Proxyable(msg.sender) == target, \"Must be proxy target\");\n        _;\n    }\n\n    event TargetUpdated(Proxyable newTarget);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/proxyable\ncontract Proxyable is Owned {\n    // This contract should be treated like an abstract contract\n\n    /* The proxy this contract exists behind. */\n    Proxy public proxy;\n\n    /* The caller of the proxy, passed through to this contract.\n     * Note that every function using this member must apply the onlyProxy or\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\n    address public messageSender;\n\n    constructor(address payable _proxy) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setProxy(address payable _proxy) external onlyOwner {\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setMessageSender(address sender) external onlyProxy {\n        messageSender = sender;\n    }\n\n    modifier onlyProxy {\n        _onlyProxy();\n        _;\n    }\n\n    function _onlyProxy() private view {\n        require(Proxy(msg.sender) == proxy, \"Only the proxy can call\");\n    }\n\n    modifier optionalProxy {\n        _optionalProxy();\n        _;\n    }\n\n    function _optionalProxy() private {\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n    }\n\n    modifier optionalProxy_onlyOwner {\n        _optionalProxy_onlyOwner();\n        _;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function _optionalProxy_onlyOwner() private {\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n        require(messageSender == owner, \"Owner only function\");\n    }\n\n    event ProxyUpdated(address proxyAddress);\n}\n\n\n// https://docs.synthetix.io/contracts/source/contracts/limitedsetup\ncontract LimitedSetup {\n    uint public setupExpiryTime;\n\n    /**\n     * @dev LimitedSetup Constructor.\n     * @param setupDuration The time the setup period will last for.\n     */\n    constructor(uint setupDuration) internal {\n        setupExpiryTime = now + setupDuration;\n    }\n\n    modifier onlyDuringSetup {\n        require(now < setupExpiryTime, \"Can only perform this action during setup\");\n        _;\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ifeepool\ninterface IFeePool {\n    // Views\n\n    // solhint-disable-next-line func-name-mixedcase\n    function FEE_ADDRESS() external view returns (address);\n\n    function feesAvailable(address account) external view returns (uint, uint);\n\n    function feePeriodDuration() external view returns (uint);\n\n    function isFeesClaimable(address account) external view returns (bool);\n\n    function targetThreshold() external view returns (uint);\n\n    function totalFeesAvailable() external view returns (uint);\n\n    function totalRewardsAvailable() external view returns (uint);\n\n    // Mutative Functions\n    function claimFees() external returns (bool);\n\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\n\n    function closeCurrentFeePeriod() external;\n\n    function closeSecondary(uint snxBackedDebt, uint debtShareSupply) external;\n\n    function recordFeePaid(uint sUSDAmount) external;\n\n    function setRewardsToDistribute(uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetix\ninterface ISynthetix {\n    // Views\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\n\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);\n\n    function totalIssuedSynthsExcludeOtherCollateral(bytes32 currencyKey) external view returns (uint);\n\n    function transferableSynthetix(address account) external view returns (uint transferable);\n\n    // Mutative Functions\n    function burnSynths(uint amount) external;\n\n    function burnSynthsOnBehalf(address burnForAddress, uint amount) external;\n\n    function burnSynthsToTarget() external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\n\n    function exchange(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalf(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeWithTracking(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeWithTrackingForInitiator(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalfWithTracking(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeWithVirtual(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\n\n    function exchangeAtomically(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function issueMaxSynths() external;\n\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\n\n    function issueSynths(uint amount) external;\n\n    function issueSynthsOnBehalf(address issueForAddress, uint amount) external;\n\n    function mint() external returns (bool);\n\n    function settle(bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntries\n        );\n\n    // Liquidations\n    function liquidateDelinquentAccount(address account, uint susdAmount) external returns (bool);\n\n    // Restricted Functions\n\n    function mintSecondary(address account, uint amount) external;\n\n    function mintSecondaryRewards(uint amount) external;\n\n    function burnSecondary(address account, uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetixdebtshare\ninterface ISynthetixDebtShare {\n    // Views\n\n    function currentPeriodId() external view returns (uint128);\n\n    function allowance(address account, address spender) external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function balanceOfOnPeriod(address account, uint periodId) external view returns (uint);\n\n    function totalSupply() external view returns (uint);\n\n    function sharePercent(address account) external view returns (uint);\n\n    function sharePercentOnPeriod(address account, uint periodId) external view returns (uint);\n\n    // Mutative functions\n\n    function takeSnapshot(uint128 id) external;\n\n    function mintShare(address account, uint256 amount) external;\n\n    function burnShare(address account, uint256 amount) external;\n\n    function approve(address, uint256) external pure returns (bool);\n\n    function transfer(address to, uint256 amount) external pure returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function addAuthorizedBroker(address target) external;\n\n    function removeAuthorizedBroker(address target) external;\n\n    function addAuthorizedToSnapshot(address target) external;\n\n    function removeAuthorizedToSnapshot(address target) external;\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/eternalstorage\n/**\n * @notice  This contract is based on the code available from this blog\n * https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88/\n * Implements support for storing a keccak256 key and value pairs. It is the more flexible\n * and extensible option. This ensures data schema changes can be implemented without\n * requiring upgrades to the storage contract.\n */\ncontract EternalStorage is Owned, State {\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== DATA TYPES ========== */\n    mapping(bytes32 => uint) internal UIntStorage;\n    mapping(bytes32 => string) internal StringStorage;\n    mapping(bytes32 => address) internal AddressStorage;\n    mapping(bytes32 => bytes) internal BytesStorage;\n    mapping(bytes32 => bytes32) internal Bytes32Storage;\n    mapping(bytes32 => bool) internal BooleanStorage;\n    mapping(bytes32 => int) internal IntStorage;\n\n    // UIntStorage;\n    function getUIntValue(bytes32 record) external view returns (uint) {\n        return UIntStorage[record];\n    }\n\n    function setUIntValue(bytes32 record, uint value) external onlyAssociatedContract {\n        UIntStorage[record] = value;\n    }\n\n    function deleteUIntValue(bytes32 record) external onlyAssociatedContract {\n        delete UIntStorage[record];\n    }\n\n    // StringStorage\n    function getStringValue(bytes32 record) external view returns (string memory) {\n        return StringStorage[record];\n    }\n\n    function setStringValue(bytes32 record, string calldata value) external onlyAssociatedContract {\n        StringStorage[record] = value;\n    }\n\n    function deleteStringValue(bytes32 record) external onlyAssociatedContract {\n        delete StringStorage[record];\n    }\n\n    // AddressStorage\n    function getAddressValue(bytes32 record) external view returns (address) {\n        return AddressStorage[record];\n    }\n\n    function setAddressValue(bytes32 record, address value) external onlyAssociatedContract {\n        AddressStorage[record] = value;\n    }\n\n    function deleteAddressValue(bytes32 record) external onlyAssociatedContract {\n        delete AddressStorage[record];\n    }\n\n    // BytesStorage\n    function getBytesValue(bytes32 record) external view returns (bytes memory) {\n        return BytesStorage[record];\n    }\n\n    function setBytesValue(bytes32 record, bytes calldata value) external onlyAssociatedContract {\n        BytesStorage[record] = value;\n    }\n\n    function deleteBytesValue(bytes32 record) external onlyAssociatedContract {\n        delete BytesStorage[record];\n    }\n\n    // Bytes32Storage\n    function getBytes32Value(bytes32 record) external view returns (bytes32) {\n        return Bytes32Storage[record];\n    }\n\n    function setBytes32Value(bytes32 record, bytes32 value) external onlyAssociatedContract {\n        Bytes32Storage[record] = value;\n    }\n\n    function deleteBytes32Value(bytes32 record) external onlyAssociatedContract {\n        delete Bytes32Storage[record];\n    }\n\n    // BooleanStorage\n    function getBooleanValue(bytes32 record) external view returns (bool) {\n        return BooleanStorage[record];\n    }\n\n    function setBooleanValue(bytes32 record, bool value) external onlyAssociatedContract {\n        BooleanStorage[record] = value;\n    }\n\n    function deleteBooleanValue(bytes32 record) external onlyAssociatedContract {\n        delete BooleanStorage[record];\n    }\n\n    // IntStorage\n    function getIntValue(bytes32 record) external view returns (int) {\n        return IntStorage[record];\n    }\n\n    function setIntValue(bytes32 record, int value) external onlyAssociatedContract {\n        IntStorage[record] = value;\n    }\n\n    function deleteIntValue(bytes32 record) external onlyAssociatedContract {\n        delete IntStorage[record];\n    }\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/feepooleternalstorage\ncontract FeePoolEternalStorage is EternalStorage, LimitedSetup {\n    bytes32 internal constant LAST_FEE_WITHDRAWAL = \"last_fee_withdrawal\";\n\n    constructor(address _owner, address _feePool) public EternalStorage(_owner, _feePool) LimitedSetup(6 weeks) {}\n\n    function importFeeWithdrawalData(address[] calldata accounts, uint[] calldata feePeriodIDs)\n        external\n        onlyOwner\n        onlyDuringSetup\n    {\n        require(accounts.length == feePeriodIDs.length, \"Length mismatch\");\n\n        for (uint8 i = 0; i < accounts.length; i++) {\n            this.setUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, accounts[i])), feePeriodIDs[i]);\n        }\n    }\n}\n\n\npragma experimental ABIEncoderV2;\n\nlibrary VestingEntries {\n    struct VestingEntry {\n        uint64 endTime;\n        uint256 escrowAmount;\n    }\n    struct VestingEntryWithID {\n        uint64 endTime;\n        uint256 escrowAmount;\n        uint256 entryID;\n    }\n}\n\ninterface IRewardEscrowV2 {\n    // Views\n    function balanceOf(address account) external view returns (uint);\n\n    function numVestingEntries(address account) external view returns (uint);\n\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\n\n    function totalVestedAccountBalance(address account) external view returns (uint);\n\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint);\n\n    function getVestingSchedules(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory);\n\n    function getAccountVestingEntryIDs(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (uint256[] memory);\n\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint);\n\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64, uint256);\n\n    // Mutative functions\n    function vest(uint256[] calldata entryIDs) external;\n\n    function createEscrowEntry(\n        address beneficiary,\n        uint256 deposit,\n        uint256 duration\n    ) external;\n\n    function appendVestingEntry(\n        address account,\n        uint256 quantity,\n        uint256 duration\n    ) external;\n\n    function migrateVestingSchedule(address _addressToMigrate) external;\n\n    function migrateAccountEscrowBalances(\n        address[] calldata accounts,\n        uint256[] calldata escrowBalances,\n        uint256[] calldata vestedBalances\n    ) external;\n\n    // Account Merging\n    function startMergingWindow() external;\n\n    function mergeAccount(address accountToMerge, uint256[] calldata entryIDs) external;\n\n    function nominateAccountToMerge(address account) external;\n\n    function accountMergingIsOpen() external view returns (bool);\n\n    // L2 Migration\n    function importVestingEntries(\n        address account,\n        uint256 escrowedAmount,\n        VestingEntries.VestingEntry[] calldata vestingEntries\n    ) external;\n\n    // Return amount of SNX transfered to SynthetixBridgeToOptimism deposit contract\n    function burnForMigration(address account, uint256[] calldata entryIDs)\n        external\n        returns (uint256 escrowedAccountBalance, VestingEntries.VestingEntry[] memory vestingEntries);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/idelegateapprovals\ninterface IDelegateApprovals {\n    // Views\n    function canBurnFor(address authoriser, address delegate) external view returns (bool);\n\n    function canIssueFor(address authoriser, address delegate) external view returns (bool);\n\n    function canClaimFor(address authoriser, address delegate) external view returns (bool);\n\n    function canExchangeFor(address authoriser, address delegate) external view returns (bool);\n\n    // Mutative\n    function approveAllDelegatePowers(address delegate) external;\n\n    function removeAllDelegatePowers(address delegate) external;\n\n    function approveBurnOnBehalf(address delegate) external;\n\n    function removeBurnOnBehalf(address delegate) external;\n\n    function approveIssueOnBehalf(address delegate) external;\n\n    function removeIssueOnBehalf(address delegate) external;\n\n    function approveClaimOnBehalf(address delegate) external;\n\n    function removeClaimOnBehalf(address delegate) external;\n\n    function approveExchangeOnBehalf(address delegate) external;\n\n    function removeExchangeOnBehalf(address delegate) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/irewardsdistribution\ninterface IRewardsDistribution {\n    // Structs\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    // Views\n    function authority() external view returns (address);\n\n    function distributions(uint index) external view returns (address destination, uint amount); // DistributionData\n\n    function distributionsLength() external view returns (uint);\n\n    // Mutative Functions\n    function distributeRewards(uint amount) external returns (bool);\n}\n\n\ninterface ISynthetixBridgeToOptimism {\n    function closeFeePeriod(uint snxBackedDebt, uint debtSharesSupply) external;\n\n    function migrateEscrow(uint256[][] calldata entryIDs) external;\n\n    function depositReward(uint amount) external;\n\n    function depositAndMigrateEscrow(uint256 depositAmount, uint256[][] calldata entryIDs) external;\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/feepool\ncontract FeePool is Owned, Proxyable, LimitedSetup, MixinSystemSettings, IFeePool {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    bytes32 public constant CONTRACT_NAME = \"FeePool\";\n\n    // Where fees are pooled in sUSD.\n    address public constant FEE_ADDRESS = 0xfeEFEEfeefEeFeefEEFEEfEeFeefEEFeeFEEFEeF;\n\n    // sUSD currencyKey. Fees stored and paid in sUSD\n    bytes32 private sUSD = \"sUSD\";\n\n    // This struct represents the issuance activity that's happened in a fee period.\n    struct FeePeriod {\n        uint64 feePeriodId;\n        uint64 startTime;\n        uint allNetworksSnxBackedDebt;\n        uint allNetworksDebtSharesSupply;\n        uint feesToDistribute;\n        uint feesClaimed;\n        uint rewardsToDistribute;\n        uint rewardsClaimed;\n    }\n\n    // A staker(mintr) can claim from the previous fee period (7 days) only.\n    // Fee Periods stored and managed from [0], such that [0] is always\n    // the current active fee period which is not claimable until the\n    // public function closeCurrentFeePeriod() is called closing the\n    // current weeks collected fees. [1] is last weeks feeperiod\n    uint8 public constant FEE_PERIOD_LENGTH = 2;\n\n    FeePeriod[FEE_PERIOD_LENGTH] private _recentFeePeriods;\n    uint256 private _currentFeePeriod;\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\n    bytes32 private constant CONTRACT_SYNTHETIXDEBTSHARE = \"SynthetixDebtShare\";\n    bytes32 private constant CONTRACT_FEEPOOLETERNALSTORAGE = \"FeePoolEternalStorage\";\n    bytes32 private constant CONTRACT_EXCHANGER = \"Exchanger\";\n    bytes32 private constant CONTRACT_ISSUER = \"Issuer\";\n    bytes32 private constant CONTRACT_REWARDESCROW_V2 = \"RewardEscrowV2\";\n    bytes32 private constant CONTRACT_DELEGATEAPPROVALS = \"DelegateApprovals\";\n    bytes32 private constant CONTRACT_COLLATERALMANAGER = \"CollateralManager\";\n    bytes32 private constant CONTRACT_REWARDSDISTRIBUTION = \"RewardsDistribution\";\n    bytes32 private constant CONTRACT_ETHER_WRAPPER = \"EtherWrapper\";\n    bytes32 private constant CONTRACT_FUTURES_MARKET_MANAGER = \"FuturesMarketManager\";\n    bytes32 private constant CONTRACT_WRAPPER_FACTORY = \"WrapperFactory\";\n\n    bytes32 private constant CONTRACT_SYNTHETIX_BRIDGE_TO_OPTIMISM = \"SynthetixBridgeToOptimism\";\n    bytes32 private constant CONTRACT_SYNTHETIX_BRIDGE_TO_BASE = \"SynthetixBridgeToBase\";\n\n    bytes32 private constant CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS = \"ext:AggregatorIssuedSynths\";\n    bytes32 private constant CONTRACT_EXT_AGGREGATOR_DEBT_RATIO = \"ext:AggregatorDebtRatio\";\n\n    /* ========== ETERNAL STORAGE CONSTANTS ========== */\n\n    bytes32 private constant LAST_FEE_WITHDRAWAL = \"last_fee_withdrawal\";\n\n    constructor(\n        address payable _proxy,\n        address _owner,\n        address _resolver\n    ) public Owned(_owner) Proxyable(_proxy) LimitedSetup(3 weeks) MixinSystemSettings(_resolver) {\n        // Set our initial fee period\n        _recentFeePeriodsStorage(0).feePeriodId = 1;\n        _recentFeePeriodsStorage(0).startTime = uint64(block.timestamp);\n    }\n\n    /* ========== VIEWS ========== */\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();\n        bytes32[] memory newAddresses = new bytes32[](14);\n        newAddresses[0] = CONTRACT_SYSTEMSTATUS;\n        newAddresses[1] = CONTRACT_SYNTHETIXDEBTSHARE;\n        newAddresses[2] = CONTRACT_FEEPOOLETERNALSTORAGE;\n        newAddresses[3] = CONTRACT_EXCHANGER;\n        newAddresses[4] = CONTRACT_ISSUER;\n        newAddresses[5] = CONTRACT_REWARDESCROW_V2;\n        newAddresses[6] = CONTRACT_DELEGATEAPPROVALS;\n        newAddresses[7] = CONTRACT_REWARDSDISTRIBUTION;\n        newAddresses[8] = CONTRACT_COLLATERALMANAGER;\n        newAddresses[9] = CONTRACT_WRAPPER_FACTORY;\n        newAddresses[10] = CONTRACT_ETHER_WRAPPER;\n        newAddresses[11] = CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS;\n        newAddresses[12] = CONTRACT_EXT_AGGREGATOR_DEBT_RATIO;\n        newAddresses[13] = CONTRACT_FUTURES_MARKET_MANAGER;\n        addresses = combineArrays(existingAddresses, newAddresses);\n    }\n\n    function systemStatus() internal view returns (ISystemStatus) {\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\n    }\n\n    function synthetixDebtShare() internal view returns (ISynthetixDebtShare) {\n        return ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE));\n    }\n\n    function feePoolEternalStorage() internal view returns (FeePoolEternalStorage) {\n        return FeePoolEternalStorage(requireAndGetAddress(CONTRACT_FEEPOOLETERNALSTORAGE));\n    }\n\n    function exchanger() internal view returns (IExchanger) {\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\n    }\n\n    function collateralManager() internal view returns (ICollateralManager) {\n        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));\n    }\n\n    function issuer() internal view returns (IIssuer) {\n        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));\n    }\n\n    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {\n        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));\n    }\n\n    function delegateApprovals() internal view returns (IDelegateApprovals) {\n        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));\n    }\n\n    function rewardsDistribution() internal view returns (IRewardsDistribution) {\n        return IRewardsDistribution(requireAndGetAddress(CONTRACT_REWARDSDISTRIBUTION));\n    }\n\n    function etherWrapper() internal view returns (IEtherWrapper) {\n        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));\n    }\n\n    function futuresMarketManager() internal view returns (IFuturesMarketManager) {\n        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURES_MARKET_MANAGER));\n    }\n\n    function wrapperFactory() internal view returns (IWrapperFactory) {\n        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));\n    }\n\n    function issuanceRatio() external view returns (uint) {\n        return getIssuanceRatio();\n    }\n\n    function feePeriodDuration() external view returns (uint) {\n        return getFeePeriodDuration();\n    }\n\n    function targetThreshold() external view returns (uint) {\n        return getTargetThreshold();\n    }\n\n    function allNetworksSnxBackedDebt() public view returns (uint256 debt, uint256 updatedAt) {\n        (, int256 rawData, , uint timestamp, ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS)).latestRoundData();\n\n        debt = uint(rawData);\n        updatedAt = timestamp;\n    }\n\n    function allNetworksDebtSharesSupply() public view returns (uint256 sharesSupply, uint256 updatedAt) {\n        (, int256 rawIssuedSynths, , uint issuedSynthsUpdatedAt, ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS)).latestRoundData();\n\n        (, int256 rawRatio, , uint ratioUpdatedAt, ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_DEBT_RATIO)).latestRoundData();\n\n        uint debt = uint(rawIssuedSynths);\n        sharesSupply = rawRatio == 0 ? 0 : debt.divideDecimalRoundPrecise(uint(rawRatio));\n        updatedAt = issuedSynthsUpdatedAt < ratioUpdatedAt ? issuedSynthsUpdatedAt : ratioUpdatedAt;\n    }\n\n    function recentFeePeriods(uint index)\n        external\n        view\n        returns (\n            uint64 feePeriodId,\n            uint64 unused, // required post 185 for api compatibility\n            uint64 startTime,\n            uint feesToDistribute,\n            uint feesClaimed,\n            uint rewardsToDistribute,\n            uint rewardsClaimed\n        )\n    {\n        FeePeriod memory feePeriod = _recentFeePeriodsStorage(index);\n        return (\n            feePeriod.feePeriodId,\n            0,\n            feePeriod.startTime,\n            feePeriod.feesToDistribute,\n            feePeriod.feesClaimed,\n            feePeriod.rewardsToDistribute,\n            feePeriod.rewardsClaimed\n        );\n    }\n\n    function _recentFeePeriodsStorage(uint index) internal view returns (FeePeriod storage) {\n        return _recentFeePeriods[(_currentFeePeriod + index) % FEE_PERIOD_LENGTH];\n    }\n\n    /**\n     * @notice The Exchanger contract informs us when fees are paid.\n     * @param amount susd amount in fees being paid.\n     */\n    function recordFeePaid(uint amount) external onlyInternalContracts {\n        // Keep track off fees in sUSD in the open fee pool period.\n        _recentFeePeriodsStorage(0).feesToDistribute = _recentFeePeriodsStorage(0).feesToDistribute.add(amount);\n    }\n\n    /**\n     * @notice The RewardsDistribution contract informs us how many SNX rewards are sent to RewardEscrow to be claimed.\n     */\n    function setRewardsToDistribute(uint amount) external optionalProxy {\n        require(messageSender == address(rewardsDistribution()), \"RewardsDistribution only\");\n        // Add the amount of SNX rewards to distribute on top of any rolling unclaimed amount\n        _recentFeePeriodsStorage(0).rewardsToDistribute = _recentFeePeriodsStorage(0).rewardsToDistribute.add(amount);\n    }\n\n    /**\n     * @notice Close the current fee period and start a new one.\n     */\n    function closeCurrentFeePeriod() external issuanceActive {\n        require(getFeePeriodDuration() > 0, \"Fee Period Duration not set\");\n        require(_recentFeePeriodsStorage(0).startTime <= (now - getFeePeriodDuration()), \"Too early to close fee period\");\n\n        // get current oracle values\n        (uint snxBackedDebt, ) = allNetworksSnxBackedDebt();\n        (uint debtSharesSupply, ) = allNetworksDebtSharesSupply();\n\n        // close on this chain\n        _closeSecondary(snxBackedDebt, debtSharesSupply);\n\n        // inform other chain of the chosen values\n        ISynthetixBridgeToOptimism(\n            resolver.requireAndGetAddress(\n                CONTRACT_SYNTHETIX_BRIDGE_TO_OPTIMISM,\n                \"Missing contract: SynthetixBridgeToOptimism\"\n            )\n        )\n            .closeFeePeriod(snxBackedDebt, debtSharesSupply);\n    }\n\n    function closeSecondary(uint allNetworksSnxBackedDebt, uint allNetworksDebtSharesSupply) external onlyRelayer {\n        _closeSecondary(allNetworksSnxBackedDebt, allNetworksDebtSharesSupply);\n    }\n\n    /**\n     * @notice Close the current fee period and start a new one.\n     */\n    function _closeSecondary(uint allNetworksSnxBackedDebt, uint allNetworksDebtSharesSupply) internal {\n        etherWrapper().distributeFees();\n        wrapperFactory().distributeFees();\n\n        // before closing the current fee period, set the recorded snxBackedDebt and debtSharesSupply\n        _recentFeePeriodsStorage(0).allNetworksDebtSharesSupply = allNetworksDebtSharesSupply;\n        _recentFeePeriodsStorage(0).allNetworksSnxBackedDebt = allNetworksSnxBackedDebt;\n\n        // Note:  when FEE_PERIOD_LENGTH = 2, periodClosing is the current period & periodToRollover is the last open claimable period\n        FeePeriod storage periodClosing = _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 2);\n        FeePeriod storage periodToRollover = _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 1);\n\n        // Any unclaimed fees from the last period in the array roll back one period.\n        // Because of the subtraction here, they're effectively proportionally redistributed to those who\n        // have already claimed from the old period, available in the new period.\n        // The subtraction is important so we don't create a ticking time bomb of an ever growing\n        // number of fees that can never decrease and will eventually overflow at the end of the fee pool.\n        _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 2).feesToDistribute = periodToRollover\n            .feesToDistribute\n            .sub(periodToRollover.feesClaimed)\n            .add(periodClosing.feesToDistribute);\n        _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 2).rewardsToDistribute = periodToRollover\n            .rewardsToDistribute\n            .sub(periodToRollover.rewardsClaimed)\n            .add(periodClosing.rewardsToDistribute);\n\n        // Shift the previous fee periods across to make room for the new one.\n        _currentFeePeriod = _currentFeePeriod.add(FEE_PERIOD_LENGTH).sub(1).mod(FEE_PERIOD_LENGTH);\n\n        // Clear the first element of the array to make sure we don't have any stale values.\n        delete _recentFeePeriods[_currentFeePeriod];\n\n        // Open up the new fee period.\n        // periodID is set to the current timestamp for compatibility with other systems taking snapshots on the debt shares\n        uint newFeePeriodId = block.timestamp;\n        _recentFeePeriodsStorage(0).feePeriodId = uint64(newFeePeriodId);\n        _recentFeePeriodsStorage(0).startTime = uint64(block.timestamp);\n\n        // Inform Issuer to start recording for the new fee period\n        issuer().setCurrentPeriodId(uint128(newFeePeriodId));\n\n        emitFeePeriodClosed(_recentFeePeriodsStorage(1).feePeriodId);\n    }\n\n    /**\n     * @notice Claim fees for last period when available or not already withdrawn.\n     */\n    function claimFees() external issuanceActive optionalProxy returns (bool) {\n        return _claimFees(messageSender);\n    }\n\n    /**\n     * @notice Delegated claimFees(). Call from the deletegated address\n     * and the fees will be sent to the claimingForAddress.\n     * approveClaimOnBehalf() must be called first to approve the deletage address\n     * @param claimingForAddress The account you are claiming fees for\n     */\n    function claimOnBehalf(address claimingForAddress) external issuanceActive optionalProxy returns (bool) {\n        require(delegateApprovals().canClaimFor(claimingForAddress, messageSender), \"Not approved to claim on behalf\");\n\n        return _claimFees(claimingForAddress);\n    }\n\n    function _claimFees(address claimingAddress) internal returns (bool) {\n        uint rewardsPaid = 0;\n        uint feesPaid = 0;\n        uint availableFees;\n        uint availableRewards;\n\n        // Address won't be able to claim fees if it is too far below the target c-ratio.\n        // It will need to burn synths then try claiming again.\n        (bool feesClaimable, bool anyRateIsInvalid) = _isFeesClaimableAndAnyRatesInvalid(claimingAddress);\n\n        require(feesClaimable, \"C-Ratio below penalty threshold\");\n\n        require(!anyRateIsInvalid, \"A synth or SNX rate is invalid\");\n\n        // Get the claimingAddress available fees and rewards\n        (availableFees, availableRewards) = feesAvailable(claimingAddress);\n\n        require(\n            availableFees > 0 || availableRewards > 0,\n            \"No fees or rewards available for period, or fees already claimed\"\n        );\n\n        // Record the address has claimed for this period\n        _setLastFeeWithdrawal(claimingAddress, _recentFeePeriodsStorage(1).feePeriodId);\n\n        if (availableFees > 0) {\n            // Record the fee payment in our recentFeePeriods\n            feesPaid = _recordFeePayment(availableFees);\n\n            // Send them their fees\n            _payFees(claimingAddress, feesPaid);\n        }\n\n        if (availableRewards > 0) {\n            // Record the reward payment in our recentFeePeriods\n            rewardsPaid = _recordRewardPayment(availableRewards);\n\n            // Send them their rewards\n            _payRewards(claimingAddress, rewardsPaid);\n        }\n\n        emitFeesClaimed(claimingAddress, feesPaid, rewardsPaid);\n\n        return true;\n    }\n\n    /**\n     * @notice Admin function to import the FeePeriod data from the previous contract\n     */\n    function importFeePeriod(\n        uint feePeriodIndex,\n        uint feePeriodId,\n        uint startTime,\n        uint feesToDistribute,\n        uint feesClaimed,\n        uint rewardsToDistribute,\n        uint rewardsClaimed\n    ) external optionalProxy_onlyOwner onlyDuringSetup {\n        require(feePeriodIndex < FEE_PERIOD_LENGTH, \"invalid fee period index\");\n\n        _recentFeePeriods[feePeriodIndex] = FeePeriod({\n            feePeriodId: uint64(feePeriodId),\n            startTime: uint64(startTime),\n            feesToDistribute: feesToDistribute,\n            feesClaimed: feesClaimed,\n            rewardsToDistribute: rewardsToDistribute,\n            rewardsClaimed: rewardsClaimed,\n            allNetworksSnxBackedDebt: 0,\n            allNetworksDebtSharesSupply: 0\n        });\n\n        // make sure recording is aware of the actual period id\n        if (feePeriodIndex == 0) {\n            issuer().setCurrentPeriodId(uint128(feePeriodId));\n        }\n    }\n\n    /**\n     * @notice Record the fee payment in our recentFeePeriods.\n     * @param sUSDAmount The amount of fees priced in sUSD.\n     */\n    function _recordFeePayment(uint sUSDAmount) internal returns (uint) {\n        // Don't assign to the parameter\n        uint remainingToAllocate = sUSDAmount;\n\n        uint feesPaid;\n        // Start at the oldest period and record the amount, moving to newer periods\n        // until we've exhausted the amount.\n        // The condition checks for overflow because we're going to 0 with an unsigned int.\n        for (uint i = FEE_PERIOD_LENGTH - 1; i < FEE_PERIOD_LENGTH; i--) {\n            uint feesAlreadyClaimed = _recentFeePeriodsStorage(i).feesClaimed;\n            uint delta = _recentFeePeriodsStorage(i).feesToDistribute.sub(feesAlreadyClaimed);\n\n            if (delta > 0) {\n                // Take the smaller of the amount left to claim in the period and the amount we need to allocate\n                uint amountInPeriod = delta < remainingToAllocate ? delta : remainingToAllocate;\n\n                _recentFeePeriodsStorage(i).feesClaimed = feesAlreadyClaimed.add(amountInPeriod);\n                remainingToAllocate = remainingToAllocate.sub(amountInPeriod);\n                feesPaid = feesPaid.add(amountInPeriod);\n\n                // No need to continue iterating if we've recorded the whole amount;\n                if (remainingToAllocate == 0) return feesPaid;\n            }\n        }\n\n        return feesPaid;\n    }\n\n    /**\n     * @notice Record the reward payment in our recentFeePeriods.\n     * @param snxAmount The amount of SNX tokens.\n     */\n    function _recordRewardPayment(uint snxAmount) internal returns (uint) {\n        // Don't assign to the parameter\n        uint remainingToAllocate = snxAmount;\n\n        uint rewardPaid;\n\n        // Start at the oldest period and record the amount, moving to newer periods\n        // until we've exhausted the amount.\n        // The condition checks for overflow because we're going to 0 with an unsigned int.\n        for (uint i = FEE_PERIOD_LENGTH - 1; i < FEE_PERIOD_LENGTH; i--) {\n            uint toDistribute =\n                _recentFeePeriodsStorage(i).rewardsToDistribute.sub(_recentFeePeriodsStorage(i).rewardsClaimed);\n\n            if (toDistribute > 0) {\n                // Take the smaller of the amount left to claim in the period and the amount we need to allocate\n                uint amountInPeriod = toDistribute < remainingToAllocate ? toDistribute : remainingToAllocate;\n\n                _recentFeePeriodsStorage(i).rewardsClaimed = _recentFeePeriodsStorage(i).rewardsClaimed.add(amountInPeriod);\n                remainingToAllocate = remainingToAllocate.sub(amountInPeriod);\n                rewardPaid = rewardPaid.add(amountInPeriod);\n\n                // No need to continue iterating if we've recorded the whole amount;\n                if (remainingToAllocate == 0) return rewardPaid;\n            }\n        }\n        return rewardPaid;\n    }\n\n    /**\n     * @notice Send the fees to claiming address.\n     * @param account The address to send the fees to.\n     * @param sUSDAmount The amount of fees priced in sUSD.\n     */\n    function _payFees(address account, uint sUSDAmount) internal notFeeAddress(account) {\n        // Grab the sUSD Synth\n        ISynth sUSDSynth = issuer().synths(sUSD);\n\n        // NOTE: we do not control the FEE_ADDRESS so it is not possible to do an\n        // ERC20.approve() transaction to allow this feePool to call ERC20.transferFrom\n        // to the accounts address\n\n        // Burn the source amount\n        sUSDSynth.burn(FEE_ADDRESS, sUSDAmount);\n\n        // Mint their new synths\n        sUSDSynth.issue(account, sUSDAmount);\n    }\n\n    /**\n     * @notice Send the rewards to claiming address - will be locked in rewardEscrow.\n     * @param account The address to send the fees to.\n     * @param snxAmount The amount of SNX.\n     */\n    function _payRewards(address account, uint snxAmount) internal notFeeAddress(account) {\n        /* Escrow the tokens for 1 year. */\n        uint escrowDuration = 52 weeks;\n\n        // Record vesting entry for claiming address and amount\n        // SNX already minted to rewardEscrow balance\n        rewardEscrowV2().appendVestingEntry(account, snxAmount, escrowDuration);\n    }\n\n    /**\n     * @notice The total fees available in the system to be withdrawnn in sUSD\n     */\n    function totalFeesAvailable() external view returns (uint) {\n        uint totalFees = 0;\n\n        // Fees in fee period [0] are not yet available for withdrawal\n        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {\n            totalFees = totalFees.add(_recentFeePeriodsStorage(i).feesToDistribute);\n            totalFees = totalFees.sub(_recentFeePeriodsStorage(i).feesClaimed);\n        }\n\n        return totalFees;\n    }\n\n    /**\n     * @notice The total SNX rewards available in the system to be withdrawn\n     */\n    function totalRewardsAvailable() external view returns (uint) {\n        uint totalRewards = 0;\n\n        // Rewards in fee period [0] are not yet available for withdrawal\n        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {\n            totalRewards = totalRewards.add(_recentFeePeriodsStorage(i).rewardsToDistribute);\n            totalRewards = totalRewards.sub(_recentFeePeriodsStorage(i).rewardsClaimed);\n        }\n\n        return totalRewards;\n    }\n\n    /**\n     * @notice The fees available to be withdrawn by a specific account, priced in sUSD\n     * @dev Returns two amounts, one for fees and one for SNX rewards\n     */\n    function feesAvailable(address account) public view returns (uint, uint) {\n        // Add up the fees\n        uint[2][FEE_PERIOD_LENGTH] memory userFees = feesByPeriod(account);\n\n        uint totalFees = 0;\n        uint totalRewards = 0;\n\n        // Fees & Rewards in fee period [0] are not yet available for withdrawal\n        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {\n            totalFees = totalFees.add(userFees[i][0]);\n            totalRewards = totalRewards.add(userFees[i][1]);\n        }\n\n        // And convert totalFees to sUSD\n        // Return totalRewards as is in SNX amount\n        return (totalFees, totalRewards);\n    }\n\n    function _isFeesClaimableAndAnyRatesInvalid(address account) internal view returns (bool, bool) {\n        // Threshold is calculated from ratio % above the target ratio (issuanceRatio).\n        //  0  <  10%:   Claimable\n        // 10% > above:  Unable to claim\n        (uint ratio, bool anyRateIsInvalid) = issuer().collateralisationRatioAndAnyRatesInvalid(account);\n        uint targetRatio = getIssuanceRatio();\n\n        // Claimable if collateral ratio below target ratio\n        if (ratio < targetRatio) {\n            return (true, anyRateIsInvalid);\n        }\n\n        // Calculate the threshold for collateral ratio before fees can't be claimed.\n        uint ratio_threshold = targetRatio.multiplyDecimal(SafeDecimalMath.unit().add(getTargetThreshold()));\n\n        // Not claimable if collateral ratio above threshold\n        if (ratio > ratio_threshold) {\n            return (false, anyRateIsInvalid);\n        }\n\n        return (true, anyRateIsInvalid);\n    }\n\n    function isFeesClaimable(address account) external view returns (bool feesClaimable) {\n        (feesClaimable, ) = _isFeesClaimableAndAnyRatesInvalid(account);\n    }\n\n    /**\n     * @notice Calculates fees by period for an account, priced in sUSD\n     * @param account The address you want to query the fees for\n     */\n    function feesByPeriod(address account) public view returns (uint[2][FEE_PERIOD_LENGTH] memory results) {\n        // What's the user's debt entry index and the debt they owe to the system at current feePeriod\n        uint userOwnershipPercentage;\n        ISynthetixDebtShare sds = synthetixDebtShare();\n\n        userOwnershipPercentage = sds.sharePercent(account);\n\n        // The [0] fee period is not yet ready to claim, but it is a fee period that they can have\n        // fees owing for, so we need to report on it anyway.\n        uint feesFromPeriod;\n        uint rewardsFromPeriod;\n        (feesFromPeriod, rewardsFromPeriod) = _feesAndRewardsFromPeriod(0, userOwnershipPercentage);\n\n        results[0][0] = feesFromPeriod;\n        results[0][1] = rewardsFromPeriod;\n\n        // Retrieve user's last fee claim by periodId\n        uint lastFeeWithdrawal = getLastFeeWithdrawal(account);\n\n        // Go through our fee periods from the oldest feePeriod[FEE_PERIOD_LENGTH - 1] and figure out what we owe them.\n        // Condition checks for periods > 0\n        for (uint i = FEE_PERIOD_LENGTH - 1; i > 0; i--) {\n            uint64 periodId = _recentFeePeriodsStorage(i).feePeriodId;\n            if (lastFeeWithdrawal < periodId) {\n                userOwnershipPercentage = sds.sharePercentOnPeriod(account, uint(periodId));\n\n                (feesFromPeriod, rewardsFromPeriod) = _feesAndRewardsFromPeriod(i, userOwnershipPercentage);\n\n                results[i][0] = feesFromPeriod;\n                results[i][1] = rewardsFromPeriod;\n            }\n        }\n    }\n\n    /**\n     * @notice ownershipPercentage is a high precision decimals uint based on\n     * wallet's debtPercentage. Gives a precise amount of the feesToDistribute\n     * for fees in the period. Precision factor is removed before results are\n     * returned.\n     * @dev The reported fees owing for the current period [0] are just a\n     * running balance until the fee period closes\n     */\n    function _feesAndRewardsFromPeriod(uint period, uint ownershipPercentage) internal view returns (uint, uint) {\n        // If it's zero, they haven't issued, and they have no fees OR rewards.\n        if (ownershipPercentage == 0) return (0, 0);\n\n        FeePeriod storage fp = _recentFeePeriodsStorage(period);\n\n        // Calculate their percentage of the fees / rewards in this period\n        // This is a high precision integer.\n        uint feesFromPeriod = fp.feesToDistribute.multiplyDecimal(ownershipPercentage);\n\n        uint rewardsFromPeriod = fp.rewardsToDistribute.multiplyDecimal(ownershipPercentage);\n\n        return (feesFromPeriod, rewardsFromPeriod);\n    }\n\n    function effectiveDebtRatioForPeriod(address account, uint period) external view returns (uint) {\n        // if period is not closed yet, or outside of the fee period range, return 0 instead of reverting\n        if (period == 0 || period >= FEE_PERIOD_LENGTH) {\n            return 0;\n        }\n\n        // If the period being checked is uninitialised then return 0. This is only at the start of the system.\n        if (_recentFeePeriodsStorage(period - 1).startTime == 0) return 0;\n\n        return synthetixDebtShare().sharePercentOnPeriod(account, uint(_recentFeePeriods[period].feePeriodId));\n    }\n\n    /**\n     * @notice Get the feePeriodID of the last claim this account made\n     * @param _claimingAddress account to check the last fee period ID claim for\n     * @return uint of the feePeriodID this account last claimed\n     */\n    function getLastFeeWithdrawal(address _claimingAddress) public view returns (uint) {\n        return feePoolEternalStorage().getUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, _claimingAddress)));\n    }\n\n    /**\n     * @notice Calculate the collateral ratio before user is blocked from claiming.\n     */\n    function getPenaltyThresholdRatio() public view returns (uint) {\n        return getIssuanceRatio().multiplyDecimal(SafeDecimalMath.unit().add(getTargetThreshold()));\n    }\n\n    /**\n     * @notice Set the feePeriodID of the last claim this account made\n     * @param _claimingAddress account to set the last feePeriodID claim for\n     * @param _feePeriodID the feePeriodID this account claimed fees for\n     */\n    function _setLastFeeWithdrawal(address _claimingAddress, uint _feePeriodID) internal {\n        feePoolEternalStorage().setUIntValue(\n            keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, _claimingAddress)),\n            _feePeriodID\n        );\n    }\n\n    /* ========== Modifiers ========== */\n\n    function _isInternalContract(address account) internal view returns (bool) {\n        return\n            account == address(exchanger()) ||\n            issuer().synthsByAddress(account) != bytes32(0) ||\n            collateralManager().hasCollateral(account) ||\n            account == address(futuresMarketManager()) ||\n            account == address(wrapperFactory()) ||\n            account == address(etherWrapper());\n    }\n\n    modifier onlyInternalContracts {\n        require(_isInternalContract(msg.sender), \"Only Internal Contracts\");\n        _;\n    }\n\n    modifier onlyRelayer {\n        require(\n            msg.sender == address(this) || msg.sender == resolver.getAddress(CONTRACT_SYNTHETIX_BRIDGE_TO_BASE),\n            \"Only valid relayer can call\"\n        );\n        _;\n    }\n\n    modifier notFeeAddress(address account) {\n        require(account != FEE_ADDRESS, \"Fee address not allowed\");\n        _;\n    }\n\n    modifier issuanceActive() {\n        systemStatus().requireIssuanceActive();\n        _;\n    }\n\n    /* ========== Proxy Events ========== */\n\n    event FeePeriodClosed(uint feePeriodId);\n    bytes32 private constant FEEPERIODCLOSED_SIG = keccak256(\"FeePeriodClosed(uint256)\");\n\n    function emitFeePeriodClosed(uint feePeriodId) internal {\n        proxy._emit(abi.encode(feePeriodId), 1, FEEPERIODCLOSED_SIG, 0, 0, 0);\n    }\n\n    event FeesClaimed(address account, uint sUSDAmount, uint snxRewards);\n    bytes32 private constant FEESCLAIMED_SIG = keccak256(\"FeesClaimed(address,uint256,uint256)\");\n\n    function emitFeesClaimed(\n        address account,\n        uint sUSDAmount,\n        uint snxRewards\n    ) internal {\n        proxy._emit(abi.encode(account, sUSDAmount, snxRewards), 1, FEESCLAIMED_SIG, 0, 0, 0);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\n\n/**\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ihasbalance\ninterface IHasBalance {\n    // Views\n    function balanceOf(address account) external view returns (uint);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iliquidations\ninterface ILiquidations {\n    // Views\n    function isOpenForLiquidation(address account) external view returns (bool);\n\n    function getLiquidationDeadlineForAccount(address account) external view returns (uint);\n\n    function isLiquidationDeadlinePassed(address account) external view returns (bool);\n\n    function liquidationDelay() external view returns (uint);\n\n    function liquidationRatio() external view returns (uint);\n\n    function liquidationPenalty() external view returns (uint);\n\n    function calculateAmountToFixCollateral(uint debtBalance, uint collateral) external view returns (uint);\n\n    // Mutative Functions\n    function flagAccountForLiquidation(address account) external;\n\n    // Restricted: used internally to Synthetix\n    function removeAccountInLiquidation(address account) external;\n\n    function checkAndRemoveAccountInLiquidation(address account) external;\n}\n\n\ninterface ISynthRedeemer {\n    // Rate of redemption - 0 for none\n    function redemptions(address synthProxy) external view returns (uint redeemRate);\n\n    // sUSD balance of deprecated token holder\n    function balanceOf(IERC20 synthProxy, address account) external view returns (uint balanceOfInsUSD);\n\n    // Full sUSD supply of token\n    function totalSupply(IERC20 synthProxy) external view returns (uint totalSupplyInsUSD);\n\n    function redeem(IERC20 synthProxy) external;\n\n    function redeemAll(IERC20[] calldata synthProxies) external;\n\n    function redeemPartial(IERC20 synthProxy, uint amountOfSynth) external;\n\n    // Restricted to Issuer\n    function deprecate(IERC20 synthProxy, uint rateToRedeem) external;\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\ninterface IProxy {\n    function target() external view returns (address);\n}\n\ninterface IIssuerInternalDebtCache {\n    function updateCachedSynthDebtWithRate(bytes32 currencyKey, uint currencyRate) external;\n\n    function updateCachedSynthDebtsWithRates(bytes32[] calldata currencyKeys, uint[] calldata currencyRates) external;\n\n    function updateDebtCacheValidity(bool currentlyInvalid) external;\n\n    function totalNonSnxBackedDebt() external view returns (uint excludedDebt, bool isInvalid);\n\n    function cacheInfo()\n        external\n        view\n        returns (\n            uint cachedDebt,\n            uint timestamp,\n            bool isInvalid,\n            bool isStale\n        );\n\n    function updateCachedsUSDDebt(int amount) external;\n}\n\n// https://docs.synthetix.io/contracts/source/contracts/issuer\ncontract Issuer is Owned, MixinSystemSettings, IIssuer {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    bytes32 public constant CONTRACT_NAME = \"Issuer\";\n\n    // SIP-165: Circuit breaker for Debt Synthesis\n    uint public constant CIRCUIT_BREAKER_SUSPENSION_REASON = 165;\n\n    // Available Synths which can be used with the system\n    ISynth[] public availableSynths;\n    mapping(bytes32 => ISynth) public synths;\n    mapping(address => bytes32) public synthsByAddress;\n\n    uint public lastDebtRatio;\n\n    /* ========== ENCODED NAMES ========== */\n\n    bytes32 internal constant sUSD = \"sUSD\";\n    bytes32 internal constant sETH = \"sETH\";\n    bytes32 internal constant SNX = \"SNX\";\n\n    // Flexible storage names\n\n    bytes32 internal constant LAST_ISSUE_EVENT = \"lastIssueEvent\";\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_SYNTHETIX = \"Synthetix\";\n    bytes32 private constant CONTRACT_EXCHANGER = \"Exchanger\";\n    bytes32 private constant CONTRACT_EXRATES = \"ExchangeRates\";\n    bytes32 private constant CONTRACT_SYNTHETIXDEBTSHARE = \"SynthetixDebtShare\";\n    bytes32 private constant CONTRACT_FEEPOOL = \"FeePool\";\n    bytes32 private constant CONTRACT_DELEGATEAPPROVALS = \"DelegateApprovals\";\n    bytes32 private constant CONTRACT_REWARDESCROW_V2 = \"RewardEscrowV2\";\n    bytes32 private constant CONTRACT_SYNTHETIXESCROW = \"SynthetixEscrow\";\n    bytes32 private constant CONTRACT_LIQUIDATIONS = \"Liquidations\";\n    bytes32 private constant CONTRACT_DEBTCACHE = \"DebtCache\";\n    bytes32 private constant CONTRACT_SYNTHREDEEMER = \"SynthRedeemer\";\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\n\n    bytes32 private constant CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS = \"ext:AggregatorIssuedSynths\";\n    bytes32 private constant CONTRACT_EXT_AGGREGATOR_DEBT_RATIO = \"ext:AggregatorDebtRatio\";\n\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {}\n\n    /* ========== VIEWS ========== */\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();\n        bytes32[] memory newAddresses = new bytes32[](14);\n        newAddresses[0] = CONTRACT_SYNTHETIX;\n        newAddresses[1] = CONTRACT_EXCHANGER;\n        newAddresses[2] = CONTRACT_EXRATES;\n        newAddresses[3] = CONTRACT_SYNTHETIXDEBTSHARE;\n        newAddresses[4] = CONTRACT_FEEPOOL;\n        newAddresses[5] = CONTRACT_DELEGATEAPPROVALS;\n        newAddresses[6] = CONTRACT_REWARDESCROW_V2;\n        newAddresses[7] = CONTRACT_SYNTHETIXESCROW;\n        newAddresses[8] = CONTRACT_LIQUIDATIONS;\n        newAddresses[9] = CONTRACT_DEBTCACHE;\n        newAddresses[10] = CONTRACT_SYNTHREDEEMER;\n        newAddresses[11] = CONTRACT_SYSTEMSTATUS;\n        newAddresses[12] = CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS;\n        newAddresses[13] = CONTRACT_EXT_AGGREGATOR_DEBT_RATIO;\n        return combineArrays(existingAddresses, newAddresses);\n    }\n\n    function synthetix() internal view returns (ISynthetix) {\n        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));\n    }\n\n    function exchanger() internal view returns (IExchanger) {\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\n    }\n\n    function exchangeRates() internal view returns (IExchangeRates) {\n        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));\n    }\n\n    function synthetixDebtShare() internal view returns (ISynthetixDebtShare) {\n        return ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE));\n    }\n\n    function feePool() internal view returns (IFeePool) {\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));\n    }\n\n    function liquidations() internal view returns (ILiquidations) {\n        return ILiquidations(requireAndGetAddress(CONTRACT_LIQUIDATIONS));\n    }\n\n    function delegateApprovals() internal view returns (IDelegateApprovals) {\n        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));\n    }\n\n    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {\n        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));\n    }\n\n    function synthetixEscrow() internal view returns (IHasBalance) {\n        return IHasBalance(requireAndGetAddress(CONTRACT_SYNTHETIXESCROW));\n    }\n\n    function debtCache() internal view returns (IIssuerInternalDebtCache) {\n        return IIssuerInternalDebtCache(requireAndGetAddress(CONTRACT_DEBTCACHE));\n    }\n\n    function synthRedeemer() internal view returns (ISynthRedeemer) {\n        return ISynthRedeemer(requireAndGetAddress(CONTRACT_SYNTHREDEEMER));\n    }\n\n    function systemStatus() internal view returns (ISystemStatus) {\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\n    }\n\n    function allNetworksDebtInfo()\n        public\n        view\n        returns (\n            uint256 debt,\n            uint256 sharesSupply,\n            bool isStale\n        )\n    {\n        (, int256 rawIssuedSynths, , uint issuedSynthsUpdatedAt, ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS)).latestRoundData();\n\n        (, int256 rawRatio, , uint ratioUpdatedAt, ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_DEBT_RATIO)).latestRoundData();\n\n        debt = uint(rawIssuedSynths);\n        sharesSupply = rawRatio == 0 ? 0 : debt.divideDecimalRoundPrecise(uint(rawRatio));\n        isStale =\n            block.timestamp - getRateStalePeriod() > issuedSynthsUpdatedAt ||\n            block.timestamp - getRateStalePeriod() > ratioUpdatedAt;\n    }\n\n    function issuanceRatio() external view returns (uint) {\n        return getIssuanceRatio();\n    }\n\n    function _debtSharesToIssuedSynth(\n        uint debtAmount,\n        uint totalSystemValue,\n        uint totalDebtShares\n    ) internal pure returns (uint) {\n        return debtAmount.multiplyDecimalRound(totalSystemValue).divideDecimalRound(totalDebtShares);\n    }\n\n    function _issuedSynthToDebtShares(\n        uint sharesAmount,\n        uint totalSystemValue,\n        uint totalDebtShares\n    ) internal pure returns (uint) {\n        return sharesAmount.multiplyDecimalRound(totalDebtShares).divideDecimalRound(totalSystemValue);\n    }\n\n    function _availableCurrencyKeysWithOptionalSNX(bool withSNX) internal view returns (bytes32[] memory) {\n        bytes32[] memory currencyKeys = new bytes32[](availableSynths.length + (withSNX ? 1 : 0));\n\n        for (uint i = 0; i < availableSynths.length; i++) {\n            currencyKeys[i] = synthsByAddress[address(availableSynths[i])];\n        }\n\n        if (withSNX) {\n            currencyKeys[availableSynths.length] = SNX;\n        }\n\n        return currencyKeys;\n    }\n\n    // Returns the total value of the debt pool in currency specified by `currencyKey`.\n    // To return only the SNX-backed debt, set `excludeCollateral` to true.\n    function _totalIssuedSynths(bytes32 currencyKey, bool excludeCollateral)\n        internal\n        view\n        returns (uint totalIssued, bool anyRateIsInvalid)\n    {\n        (uint debt, , bool cacheIsInvalid, bool cacheIsStale) = debtCache().cacheInfo();\n        anyRateIsInvalid = cacheIsInvalid || cacheIsStale;\n\n        IExchangeRates exRates = exchangeRates();\n\n        // Add total issued synths from non snx collateral back into the total if not excluded\n        if (!excludeCollateral) {\n            (uint nonSnxDebt, bool invalid) = debtCache().totalNonSnxBackedDebt();\n            debt = debt.add(nonSnxDebt);\n            anyRateIsInvalid = anyRateIsInvalid || invalid;\n        }\n\n        if (currencyKey == sUSD) {\n            return (debt, anyRateIsInvalid);\n        }\n\n        (uint currencyRate, bool currencyRateInvalid) = exRates.rateAndInvalid(currencyKey);\n        return (debt.divideDecimalRound(currencyRate), anyRateIsInvalid || currencyRateInvalid);\n    }\n\n    function _debtBalanceOfAndTotalDebt(uint debtShareBalance, bytes32 currencyKey)\n        internal\n        view\n        returns (\n            uint debtBalance,\n            uint totalSystemValue,\n            bool anyRateIsInvalid\n        )\n    {\n        // What's the total value of the system excluding ETH backed synths in their requested currency?\n        (uint snxBackedAmount, uint debtSharesAmount, bool debtInfoStale) = allNetworksDebtInfo();\n\n        if (debtShareBalance == 0) {\n            return (0, snxBackedAmount, debtInfoStale);\n        }\n\n        // existing functionality requires for us to convert into the exchange rate specified by `currencyKey`\n        (uint currencyRate, bool currencyRateInvalid) = exchangeRates().rateAndInvalid(currencyKey);\n\n        debtBalance = _debtSharesToIssuedSynth(debtShareBalance, snxBackedAmount, debtSharesAmount).divideDecimalRound(\n            currencyRate\n        );\n        totalSystemValue = snxBackedAmount;\n\n        anyRateIsInvalid = currencyRateInvalid || debtInfoStale;\n    }\n\n    function _canBurnSynths(address account) internal view returns (bool) {\n        return now >= _lastIssueEvent(account).add(getMinimumStakeTime());\n    }\n\n    function _lastIssueEvent(address account) internal view returns (uint) {\n        //  Get the timestamp of the last issue this account made\n        return flexibleStorage().getUIntValue(CONTRACT_NAME, keccak256(abi.encodePacked(LAST_ISSUE_EVENT, account)));\n    }\n\n    function _remainingIssuableSynths(address _issuer)\n        internal\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt,\n            bool anyRateIsInvalid\n        )\n    {\n        (alreadyIssued, totalSystemDebt, anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(\n            synthetixDebtShare().balanceOf(_issuer),\n            sUSD\n        );\n        (uint issuable, bool isInvalid) = _maxIssuableSynths(_issuer);\n        maxIssuable = issuable;\n        anyRateIsInvalid = anyRateIsInvalid || isInvalid;\n\n        if (alreadyIssued >= maxIssuable) {\n            maxIssuable = 0;\n        } else {\n            maxIssuable = maxIssuable.sub(alreadyIssued);\n        }\n    }\n\n    function _snxToUSD(uint amount, uint snxRate) internal pure returns (uint) {\n        return amount.multiplyDecimalRound(snxRate);\n    }\n\n    function _usdToSnx(uint amount, uint snxRate) internal pure returns (uint) {\n        return amount.divideDecimalRound(snxRate);\n    }\n\n    function _maxIssuableSynths(address _issuer) internal view returns (uint, bool) {\n        // What is the value of their SNX balance in sUSD\n        (uint snxRate, bool isInvalid) = exchangeRates().rateAndInvalid(SNX);\n        uint destinationValue = _snxToUSD(_collateral(_issuer), snxRate);\n\n        // They're allowed to issue up to issuanceRatio of that value\n        return (destinationValue.multiplyDecimal(getIssuanceRatio()), isInvalid);\n    }\n\n    function _collateralisationRatio(address _issuer) internal view returns (uint, bool) {\n        uint totalOwnedSynthetix = _collateral(_issuer);\n\n        (uint debtBalance, , bool anyRateIsInvalid) =\n            _debtBalanceOfAndTotalDebt(synthetixDebtShare().balanceOf(_issuer), SNX);\n\n        // it's more gas intensive to put this check here if they have 0 SNX, but it complies with the interface\n        if (totalOwnedSynthetix == 0) return (0, anyRateIsInvalid);\n\n        return (debtBalance.divideDecimalRound(totalOwnedSynthetix), anyRateIsInvalid);\n    }\n\n    function _collateral(address account) internal view returns (uint) {\n        uint balance = IERC20(address(synthetix())).balanceOf(account);\n\n        if (address(synthetixEscrow()) != address(0)) {\n            balance = balance.add(synthetixEscrow().balanceOf(account));\n        }\n\n        if (address(rewardEscrowV2()) != address(0)) {\n            balance = balance.add(rewardEscrowV2().balanceOf(account));\n        }\n\n        return balance;\n    }\n\n    function minimumStakeTime() external view returns (uint) {\n        return getMinimumStakeTime();\n    }\n\n    function canBurnSynths(address account) external view returns (bool) {\n        return _canBurnSynths(account);\n    }\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory) {\n        return _availableCurrencyKeysWithOptionalSNX(false);\n    }\n\n    function availableSynthCount() external view returns (uint) {\n        return availableSynths.length;\n    }\n\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid) {\n        (, anyRateInvalid) = exchangeRates().ratesAndInvalidForCurrencies(_availableCurrencyKeysWithOptionalSNX(true));\n    }\n\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint totalIssued) {\n        (totalIssued, ) = _totalIssuedSynths(currencyKey, excludeOtherCollateral);\n    }\n\n    function lastIssueEvent(address account) external view returns (uint) {\n        return _lastIssueEvent(account);\n    }\n\n    function collateralisationRatio(address _issuer) external view returns (uint cratio) {\n        (cratio, ) = _collateralisationRatio(_issuer);\n    }\n\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsInvalid)\n    {\n        return _collateralisationRatio(_issuer);\n    }\n\n    function collateral(address account) external view returns (uint) {\n        return _collateral(account);\n    }\n\n    function debtBalanceOf(address _issuer, bytes32 currencyKey) external view returns (uint debtBalance) {\n        ISynthetixDebtShare sds = synthetixDebtShare();\n\n        // What was their initial debt ownership?\n        uint debtShareBalance = sds.balanceOf(_issuer);\n\n        // If it's zero, they haven't issued, and they have no debt.\n        if (debtShareBalance == 0) return 0;\n\n        (debtBalance, , ) = _debtBalanceOfAndTotalDebt(debtShareBalance, currencyKey);\n    }\n\n    function remainingIssuableSynths(address _issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        )\n    {\n        (maxIssuable, alreadyIssued, totalSystemDebt, ) = _remainingIssuableSynths(_issuer);\n    }\n\n    function maxIssuableSynths(address _issuer) external view returns (uint) {\n        (uint maxIssuable, ) = _maxIssuableSynths(_issuer);\n        return maxIssuable;\n    }\n\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsInvalid)\n    {\n        // How many SNX do they have, excluding escrow?\n        // Note: We're excluding escrow here because we're interested in their transferable amount\n        // and escrowed SNX are not transferable.\n\n        // How many of those will be locked by the amount they've issued?\n        // Assuming issuance ratio is 20%, then issuing 20 SNX of value would require\n        // 100 SNX to be locked in their wallet to maintain their collateralisation ratio\n        // The locked synthetix value can exceed their balance.\n        uint debtBalance;\n        (debtBalance, , anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(synthetixDebtShare().balanceOf(account), SNX);\n        uint lockedSynthetixValue = debtBalance.divideDecimalRound(getIssuanceRatio());\n\n        // If we exceed the balance, no SNX are transferable, otherwise the difference is.\n        if (lockedSynthetixValue >= balance) {\n            transferable = 0;\n        } else {\n            transferable = balance.sub(lockedSynthetixValue);\n        }\n    }\n\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory) {\n        uint numKeys = currencyKeys.length;\n        ISynth[] memory addresses = new ISynth[](numKeys);\n\n        for (uint i = 0; i < numKeys; i++) {\n            addresses[i] = synths[currencyKeys[i]];\n        }\n\n        return addresses;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function _addSynth(ISynth synth) internal {\n        bytes32 currencyKey = synth.currencyKey();\n        require(synths[currencyKey] == ISynth(0), \"Synth exists\");\n        require(synthsByAddress[address(synth)] == bytes32(0), \"Synth address already exists\");\n\n        availableSynths.push(synth);\n        synths[currencyKey] = synth;\n        synthsByAddress[address(synth)] = currencyKey;\n\n        emit SynthAdded(currencyKey, address(synth));\n    }\n\n    function addSynth(ISynth synth) external onlyOwner {\n        _addSynth(synth);\n        // Invalidate the cache to force a snapshot to be recomputed. If a synth were to be added\n        // back to the system and it still somehow had cached debt, this would force the value to be\n        // updated.\n        debtCache().updateDebtCacheValidity(true);\n    }\n\n    function addSynths(ISynth[] calldata synthsToAdd) external onlyOwner {\n        uint numSynths = synthsToAdd.length;\n        for (uint i = 0; i < numSynths; i++) {\n            _addSynth(synthsToAdd[i]);\n        }\n\n        // Invalidate the cache to force a snapshot to be recomputed.\n        debtCache().updateDebtCacheValidity(true);\n    }\n\n    function _removeSynth(bytes32 currencyKey) internal {\n        address synthToRemove = address(synths[currencyKey]);\n        require(synthToRemove != address(0), \"Synth does not exist\");\n        require(currencyKey != sUSD, \"Cannot remove synth\");\n\n        uint synthSupply = IERC20(synthToRemove).totalSupply();\n\n        if (synthSupply > 0) {\n            (uint amountOfsUSD, uint rateToRedeem, ) =\n                exchangeRates().effectiveValueAndRates(currencyKey, synthSupply, \"sUSD\");\n            require(rateToRedeem > 0, \"Cannot remove synth to redeem without rate\");\n            ISynthRedeemer _synthRedeemer = synthRedeemer();\n            synths[sUSD].issue(address(_synthRedeemer), amountOfsUSD);\n            // ensure the debt cache is aware of the new sUSD issued\n            debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amountOfsUSD));\n            _synthRedeemer.deprecate(IERC20(address(Proxyable(address(synthToRemove)).proxy())), rateToRedeem);\n        }\n\n        // Remove the synth from the availableSynths array.\n        for (uint i = 0; i < availableSynths.length; i++) {\n            if (address(availableSynths[i]) == synthToRemove) {\n                delete availableSynths[i];\n\n                // Copy the last synth into the place of the one we just deleted\n                // If there's only one synth, this is synths[0] = synths[0].\n                // If we're deleting the last one, it's also a NOOP in the same way.\n                availableSynths[i] = availableSynths[availableSynths.length - 1];\n\n                // Decrease the size of the array by one.\n                availableSynths.length--;\n\n                break;\n            }\n        }\n\n        // And remove it from the synths mapping\n        delete synthsByAddress[synthToRemove];\n        delete synths[currencyKey];\n\n        emit SynthRemoved(currencyKey, synthToRemove);\n    }\n\n    function removeSynth(bytes32 currencyKey) external onlyOwner {\n        // Remove its contribution from the debt pool snapshot, and\n        // invalidate the cache to force a new snapshot.\n        IIssuerInternalDebtCache cache = debtCache();\n        cache.updateCachedSynthDebtWithRate(currencyKey, 0);\n        cache.updateDebtCacheValidity(true);\n\n        _removeSynth(currencyKey);\n    }\n\n    function removeSynths(bytes32[] calldata currencyKeys) external onlyOwner {\n        uint numKeys = currencyKeys.length;\n\n        // Remove their contributions from the debt pool snapshot, and\n        // invalidate the cache to force a new snapshot.\n        IIssuerInternalDebtCache cache = debtCache();\n        uint[] memory zeroRates = new uint[](numKeys);\n        cache.updateCachedSynthDebtsWithRates(currencyKeys, zeroRates);\n        cache.updateDebtCacheValidity(true);\n\n        for (uint i = 0; i < numKeys; i++) {\n            _removeSynth(currencyKeys[i]);\n        }\n    }\n\n    function issueSynths(address from, uint amount) external onlySynthetix {\n        require(amount > 0, \"Issuer: cannot issue 0 synths\");\n\n        _issueSynths(from, amount, false);\n    }\n\n    function issueMaxSynths(address from) external onlySynthetix {\n        _issueSynths(from, 0, true);\n    }\n\n    function issueSynthsOnBehalf(\n        address issueForAddress,\n        address from,\n        uint amount\n    ) external onlySynthetix {\n        _requireCanIssueOnBehalf(issueForAddress, from);\n        _issueSynths(issueForAddress, amount, false);\n    }\n\n    function issueMaxSynthsOnBehalf(address issueForAddress, address from) external onlySynthetix {\n        _requireCanIssueOnBehalf(issueForAddress, from);\n        _issueSynths(issueForAddress, 0, true);\n    }\n\n    function burnSynths(address from, uint amount) external onlySynthetix {\n        _voluntaryBurnSynths(from, amount, false);\n    }\n\n    function burnSynthsOnBehalf(\n        address burnForAddress,\n        address from,\n        uint amount\n    ) external onlySynthetix {\n        _requireCanBurnOnBehalf(burnForAddress, from);\n        _voluntaryBurnSynths(burnForAddress, amount, false);\n    }\n\n    function burnSynthsToTarget(address from) external onlySynthetix {\n        _voluntaryBurnSynths(from, 0, true);\n    }\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external onlySynthetix {\n        _requireCanBurnOnBehalf(burnForAddress, from);\n        _voluntaryBurnSynths(burnForAddress, 0, true);\n    }\n\n    function burnForRedemption(\n        address deprecatedSynthProxy,\n        address account,\n        uint balance\n    ) external onlySynthRedeemer {\n        ISynth(IProxy(deprecatedSynthProxy).target()).burn(account, balance);\n    }\n\n    function liquidateDelinquentAccount(\n        address account,\n        uint susdAmount,\n        address liquidator\n    ) external onlySynthetix returns (uint totalRedeemed, uint amountToLiquidate) {\n        // Ensure waitingPeriod and sUSD balance is settled as burning impacts the size of debt pool\n        require(!exchanger().hasWaitingPeriodOrSettlementOwing(liquidator, sUSD), \"sUSD needs to be settled\");\n\n        // Check account is liquidation open\n        require(liquidations().isOpenForLiquidation(account), \"Account not open for liquidation\");\n\n        // require liquidator has enough sUSD\n        require(IERC20(address(synths[sUSD])).balanceOf(liquidator) >= susdAmount, \"Not enough sUSD\");\n\n        uint liquidationPenalty = liquidations().liquidationPenalty();\n\n        // What is their debt in sUSD?\n        (uint debtBalance, uint totalDebtIssued, bool anyRateIsInvalid) =\n            _debtBalanceOfAndTotalDebt(synthetixDebtShare().balanceOf(account), sUSD);\n        (uint snxRate, bool snxRateInvalid) = exchangeRates().rateAndInvalid(SNX);\n        _requireRatesNotInvalid(anyRateIsInvalid || snxRateInvalid);\n\n        uint collateralForAccount = _collateral(account);\n        uint amountToFixRatio =\n            liquidations().calculateAmountToFixCollateral(debtBalance, _snxToUSD(collateralForAccount, snxRate));\n\n        // Cap amount to liquidate to repair collateral ratio based on issuance ratio\n        amountToLiquidate = amountToFixRatio < susdAmount ? amountToFixRatio : susdAmount;\n\n        // what's the equivalent amount of snx for the amountToLiquidate?\n        uint snxRedeemed = _usdToSnx(amountToLiquidate, snxRate);\n\n        // Add penalty\n        totalRedeemed = snxRedeemed.multiplyDecimal(SafeDecimalMath.unit().add(liquidationPenalty));\n\n        // if total SNX to redeem is greater than account's collateral\n        // account is under collateralised, liquidate all collateral and reduce sUSD to burn\n        if (totalRedeemed > collateralForAccount) {\n            // set totalRedeemed to all transferable collateral\n            totalRedeemed = collateralForAccount;\n\n            // whats the equivalent sUSD to burn for all collateral less penalty\n            amountToLiquidate = _snxToUSD(\n                collateralForAccount.divideDecimal(SafeDecimalMath.unit().add(liquidationPenalty)),\n                snxRate\n            );\n        }\n\n        // burn sUSD from messageSender (liquidator) and reduce account's debt\n        _burnSynths(account, liquidator, amountToLiquidate, debtBalance, totalDebtIssued);\n\n        // Remove liquidation flag if amount liquidated fixes ratio\n        if (amountToLiquidate == amountToFixRatio) {\n            // Remove liquidation\n            liquidations().removeAccountInLiquidation(account);\n        }\n    }\n\n    function setCurrentPeriodId(uint128 periodId) external {\n        require(msg.sender == address(feePool()), \"Must be fee pool\");\n\n        ISynthetixDebtShare sds = synthetixDebtShare();\n\n        if (sds.currentPeriodId() < periodId) {\n            sds.takeSnapshot(periodId);\n        }\n    }\n\n    function setLastDebtRatio(uint256 ratio) external onlyOwner {\n        lastDebtRatio = ratio;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _requireRatesNotInvalid(bool anyRateIsInvalid) internal pure {\n        require(!anyRateIsInvalid, \"A synth or SNX rate is invalid\");\n    }\n\n    function _requireCanIssueOnBehalf(address issueForAddress, address from) internal view {\n        require(delegateApprovals().canIssueFor(issueForAddress, from), \"Not approved to act on behalf\");\n    }\n\n    function _requireCanBurnOnBehalf(address burnForAddress, address from) internal view {\n        require(delegateApprovals().canBurnFor(burnForAddress, from), \"Not approved to act on behalf\");\n    }\n\n    function _issueSynths(\n        address from,\n        uint amount,\n        bool issueMax\n    ) internal {\n        // check breaker\n        if (!_verifyCircuitBreaker()) {\n            return;\n        }\n\n        (uint maxIssuable, , uint totalSystemDebt, bool anyRateIsInvalid) = _remainingIssuableSynths(from);\n        _requireRatesNotInvalid(anyRateIsInvalid);\n\n        if (!issueMax) {\n            require(amount <= maxIssuable, \"Amount too large\");\n        } else {\n            amount = maxIssuable;\n        }\n\n        // Keep track of the debt they're about to create\n        _addToDebtRegister(from, amount, totalSystemDebt);\n\n        // record issue timestamp\n        _setLastIssueEvent(from);\n\n        // Create their synths\n        synths[sUSD].issue(from, amount);\n\n        // Account for the issued debt in the cache\n        debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amount));\n    }\n\n    function _burnSynths(\n        address debtAccount,\n        address burnAccount,\n        uint amount,\n        uint existingDebt,\n        uint totalDebtIssued\n    ) internal returns (uint amountBurnt) {\n        // check breaker\n        if (!_verifyCircuitBreaker()) {\n            return 0;\n        }\n\n        // liquidation requires sUSD to be already settled / not in waiting period\n\n        // If they're trying to burn more debt than they actually owe, rather than fail the transaction, let's just\n        // clear their debt and leave them be.\n        amountBurnt = existingDebt < amount ? existingDebt : amount;\n\n        // Remove liquidated debt from the ledger\n        _removeFromDebtRegister(debtAccount, amountBurnt, existingDebt, totalDebtIssued);\n\n        // synth.burn does a safe subtraction on balance (so it will revert if there are not enough synths).\n        synths[sUSD].burn(burnAccount, amountBurnt);\n\n        // Account for the burnt debt in the cache.\n        debtCache().updateCachedsUSDDebt(-SafeCast.toInt256(amountBurnt));\n    }\n\n    // If burning to target, `amount` is ignored, and the correct quantity of sUSD is burnt to reach the target\n    // c-ratio, allowing fees to be claimed. In this case, pending settlements will be skipped as the user\n    // will still have debt remaining after reaching their target.\n    function _voluntaryBurnSynths(\n        address from,\n        uint amount,\n        bool burnToTarget\n    ) internal {\n        // check breaker\n        if (!_verifyCircuitBreaker()) {\n            return;\n        }\n\n        if (!burnToTarget) {\n            // If not burning to target, then burning requires that the minimum stake time has elapsed.\n            require(_canBurnSynths(from), \"Minimum stake time not reached\");\n            // First settle anything pending into sUSD as burning or issuing impacts the size of the debt pool\n            (, uint refunded, uint numEntriesSettled) = exchanger().settle(from, sUSD);\n            if (numEntriesSettled > 0) {\n                amount = exchanger().calculateAmountAfterSettlement(from, sUSD, amount, refunded);\n            }\n        }\n\n        (uint existingDebt, uint totalSystemValue, bool anyRateIsInvalid) =\n            _debtBalanceOfAndTotalDebt(synthetixDebtShare().balanceOf(from), sUSD);\n        (uint maxIssuableSynthsForAccount, bool snxRateInvalid) = _maxIssuableSynths(from);\n        _requireRatesNotInvalid(anyRateIsInvalid || snxRateInvalid);\n        require(existingDebt > 0, \"No debt to forgive\");\n\n        if (burnToTarget) {\n            amount = existingDebt.sub(maxIssuableSynthsForAccount);\n        }\n\n        uint amountBurnt = _burnSynths(from, from, amount, existingDebt, totalSystemValue);\n\n        // Check and remove liquidation if existingDebt after burning is <= maxIssuableSynths\n        // Issuance ratio is fixed so should remove any liquidations\n        if (existingDebt.sub(amountBurnt) <= maxIssuableSynthsForAccount) {\n            liquidations().removeAccountInLiquidation(from);\n        }\n    }\n\n    function _setLastIssueEvent(address account) internal {\n        // Set the timestamp of the last issueSynths\n        flexibleStorage().setUIntValue(\n            CONTRACT_NAME,\n            keccak256(abi.encodePacked(LAST_ISSUE_EVENT, account)),\n            block.timestamp\n        );\n    }\n\n    function _addToDebtRegister(\n        address from,\n        uint amount,\n        uint totalDebtIssued\n    ) internal {\n        ISynthetixDebtShare sds = synthetixDebtShare();\n\n        // it is possible (eg in tests, system initialized with extra debt) to have issued debt without any shares issued\n        // in which case, the first account to mint gets the debt. yw.\n        if (sds.totalSupply() == 0) {\n            sds.mintShare(from, amount);\n        } else {\n            sds.mintShare(from, _issuedSynthToDebtShares(amount, totalDebtIssued, sds.totalSupply()));\n        }\n    }\n\n    function _removeFromDebtRegister(\n        address from,\n        uint debtToRemove,\n        uint existingDebt,\n        uint totalDebtIssued\n    ) internal {\n        ISynthetixDebtShare sds = synthetixDebtShare();\n\n        uint currentDebtShare = sds.balanceOf(from);\n\n        if (debtToRemove == existingDebt) {\n            sds.burnShare(from, currentDebtShare);\n        } else {\n            uint balanceToRemove = _issuedSynthToDebtShares(debtToRemove, totalDebtIssued, sds.totalSupply());\n            sds.burnShare(from, balanceToRemove < currentDebtShare ? balanceToRemove : currentDebtShare);\n        }\n    }\n\n    function _verifyCircuitBreaker() internal returns (bool) {\n        (, int256 rawRatio, , uint ratioUpdatedAt, ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_DEBT_RATIO)).latestRoundData();\n\n        uint deviation = _calculateDeviation(lastDebtRatio, uint(rawRatio));\n\n        if (deviation >= getPriceDeviationThresholdFactor()) {\n            systemStatus().suspendIssuance(CIRCUIT_BREAKER_SUSPENSION_REASON);\n            return false;\n        }\n        lastDebtRatio = uint(rawRatio);\n\n        return true;\n    }\n\n    function _calculateDeviation(uint last, uint fresh) internal pure returns (uint deviation) {\n        if (last == 0) {\n            deviation = 1;\n        } else if (fresh == 0) {\n            deviation = uint(-1);\n        } else if (last > fresh) {\n            deviation = last.divideDecimal(fresh);\n        } else {\n            deviation = fresh.divideDecimal(last);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    function _onlySynthetix() internal view {\n        require(msg.sender == address(synthetix()), \"Issuer: Only the synthetix contract can perform this action\");\n    }\n\n    modifier onlySynthetix() {\n        _onlySynthetix(); // Use an internal function to save code size.\n        _;\n    }\n\n    function _onlySynthRedeemer() internal view {\n        require(msg.sender == address(synthRedeemer()), \"Issuer: Only the SynthRedeemer contract can perform this action\");\n    }\n\n    modifier onlySynthRedeemer() {\n        _onlySynthRedeemer();\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SynthAdded(bytes32 currencyKey, address synth);\n    event SynthRemoved(bytes32 currencyKey, address synth);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/tokenstate\ncontract TokenState is Owned, State {\n    /* ERC20 fields. */\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice Set ERC20 allowance.\n     * @dev Only the associated contract may call this.\n     * @param tokenOwner The authorising party.\n     * @param spender The authorised party.\n     * @param value The total value the authorised party may spend on the\n     * authorising party's behalf.\n     */\n    function setAllowance(\n        address tokenOwner,\n        address spender,\n        uint value\n    ) external onlyAssociatedContract {\n        allowance[tokenOwner][spender] = value;\n    }\n\n    /**\n     * @notice Set the balance in a given account\n     * @dev Only the associated contract may call this.\n     * @param account The account whose value to set.\n     * @param value The new balance of the given account.\n     */\n    function setBalanceOf(address account, uint value) external onlyAssociatedContract {\n        balanceOf[account] = value;\n    }\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/externstatetoken\ncontract ExternStateToken is Owned, Proxyable {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /* ========== STATE VARIABLES ========== */\n\n    /* Stores balances and allowances. */\n    TokenState public tokenState;\n\n    /* Other ERC20 fields. */\n    string public name;\n    string public symbol;\n    uint public totalSupply;\n    uint8 public decimals;\n\n    constructor(\n        address payable _proxy,\n        TokenState _tokenState,\n        string memory _name,\n        string memory _symbol,\n        uint _totalSupply,\n        uint8 _decimals,\n        address _owner\n    ) public Owned(_owner) Proxyable(_proxy) {\n        tokenState = _tokenState;\n\n        name = _name;\n        symbol = _symbol;\n        totalSupply = _totalSupply;\n        decimals = _decimals;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Returns the ERC20 allowance of one party to spend on behalf of another.\n     * @param owner The party authorising spending of their funds.\n     * @param spender The party spending tokenOwner's funds.\n     */\n    function allowance(address owner, address spender) public view returns (uint) {\n        return tokenState.allowance(owner, spender);\n    }\n\n    /**\n     * @notice Returns the ERC20 token balance of a given account.\n     */\n    function balanceOf(address account) external view returns (uint) {\n        return tokenState.balanceOf(account);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Set the address of the TokenState contract.\n     * @dev This can be used to \"pause\" transfer functionality, by pointing the tokenState at 0x000..\n     * as balances would be unreachable.\n     */\n    function setTokenState(TokenState _tokenState) external optionalProxy_onlyOwner {\n        tokenState = _tokenState;\n        emitTokenStateUpdated(address(_tokenState));\n    }\n\n    function _internalTransfer(\n        address from,\n        address to,\n        uint value\n    ) internal returns (bool) {\n        /* Disallow transfers to irretrievable-addresses. */\n        require(to != address(0) && to != address(this) && to != address(proxy), \"Cannot transfer to this address\");\n\n        // Insufficient balance will be handled by the safe subtraction.\n        tokenState.setBalanceOf(from, tokenState.balanceOf(from).sub(value));\n        tokenState.setBalanceOf(to, tokenState.balanceOf(to).add(value));\n\n        // Emit a standard ERC20 transfer event\n        emitTransfer(from, to, value);\n\n        return true;\n    }\n\n    /**\n     * @dev Perform an ERC20 token transfer. Designed to be called by transfer functions possessing\n     * the onlyProxy or optionalProxy modifiers.\n     */\n    function _transferByProxy(\n        address from,\n        address to,\n        uint value\n    ) internal returns (bool) {\n        return _internalTransfer(from, to, value);\n    }\n\n    /*\n     * @dev Perform an ERC20 token transferFrom. Designed to be called by transferFrom functions\n     * possessing the optionalProxy or optionalProxy modifiers.\n     */\n    function _transferFromByProxy(\n        address sender,\n        address from,\n        address to,\n        uint value\n    ) internal returns (bool) {\n        /* Insufficient allowance will be handled by the safe subtraction. */\n        tokenState.setAllowance(from, sender, tokenState.allowance(from, sender).sub(value));\n        return _internalTransfer(from, to, value);\n    }\n\n    /**\n     * @notice Approves spender to transfer on the message sender's behalf.\n     */\n    function approve(address spender, uint value) public optionalProxy returns (bool) {\n        address sender = messageSender;\n\n        tokenState.setAllowance(sender, spender, value);\n        emitApproval(sender, spender, value);\n        return true;\n    }\n\n    /* ========== EVENTS ========== */\n    function addressToBytes32(address input) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(input)));\n    }\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    bytes32 internal constant TRANSFER_SIG = keccak256(\"Transfer(address,address,uint256)\");\n\n    function emitTransfer(\n        address from,\n        address to,\n        uint value\n    ) internal {\n        proxy._emit(abi.encode(value), 3, TRANSFER_SIG, addressToBytes32(from), addressToBytes32(to), 0);\n    }\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    bytes32 internal constant APPROVAL_SIG = keccak256(\"Approval(address,address,uint256)\");\n\n    function emitApproval(\n        address owner,\n        address spender,\n        uint value\n    ) internal {\n        proxy._emit(abi.encode(value), 3, APPROVAL_SIG, addressToBytes32(owner), addressToBytes32(spender), 0);\n    }\n\n    event TokenStateUpdated(address newTokenState);\n    bytes32 internal constant TOKENSTATEUPDATED_SIG = keccak256(\"TokenStateUpdated(address)\");\n\n    function emitTokenStateUpdated(address newTokenState) internal {\n        proxy._emit(abi.encode(newTokenState), 1, TOKENSTATEUPDATED_SIG, 0, 0, 0);\n    }\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/synth\ncontract Synth is Owned, IERC20, ExternStateToken, MixinResolver, ISynth {\n    bytes32 public constant CONTRACT_NAME = \"Synth\";\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Currency key which identifies this Synth to the Synthetix system\n    bytes32 public currencyKey;\n\n    uint8 public constant DECIMALS = 18;\n\n    // Where fees are pooled in sUSD\n    address public constant FEE_ADDRESS = 0xfeEFEEfeefEeFeefEEFEEfEeFeefEEFeeFEEFEeF;\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\n    bytes32 private constant CONTRACT_EXCHANGER = \"Exchanger\";\n    bytes32 private constant CONTRACT_ISSUER = \"Issuer\";\n    bytes32 private constant CONTRACT_FEEPOOL = \"FeePool\";\n    bytes32 private constant CONTRACT_FUTURESMARKETMANAGER = \"FuturesMarketManager\";\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address payable _proxy,\n        TokenState _tokenState,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        address _owner,\n        bytes32 _currencyKey,\n        uint _totalSupply,\n        address _resolver\n    )\n        public\n        ExternStateToken(_proxy, _tokenState, _tokenName, _tokenSymbol, _totalSupply, DECIMALS, _owner)\n        MixinResolver(_resolver)\n    {\n        require(_proxy != address(0), \"_proxy cannot be 0\");\n        require(_owner != address(0), \"_owner cannot be 0\");\n\n        currencyKey = _currencyKey;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function transfer(address to, uint value) public optionalProxy returns (bool) {\n        _ensureCanTransfer(messageSender, value);\n\n        // transfers to FEE_ADDRESS will be exchanged into sUSD and recorded as fee\n        if (to == FEE_ADDRESS) {\n            return _transferToFeeAddress(to, value);\n        }\n\n        // transfers to 0x address will be burned\n        if (to == address(0)) {\n            return _internalBurn(messageSender, value);\n        }\n\n        return super._internalTransfer(messageSender, to, value);\n    }\n\n    function transferAndSettle(address to, uint value) public optionalProxy returns (bool) {\n        // Exchanger.settle ensures synth is active\n        (, , uint numEntriesSettled) = exchanger().settle(messageSender, currencyKey);\n\n        // Save gas instead of calling transferableSynths\n        uint balanceAfter = value;\n\n        if (numEntriesSettled > 0) {\n            balanceAfter = tokenState.balanceOf(messageSender);\n        }\n\n        // Reduce the value to transfer if balance is insufficient after reclaimed\n        value = value > balanceAfter ? balanceAfter : value;\n\n        return super._internalTransfer(messageSender, to, value);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public optionalProxy returns (bool) {\n        _ensureCanTransfer(from, value);\n\n        return _internalTransferFrom(from, to, value);\n    }\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) public optionalProxy returns (bool) {\n        // Exchanger.settle() ensures synth is active\n        (, , uint numEntriesSettled) = exchanger().settle(from, currencyKey);\n\n        // Save gas instead of calling transferableSynths\n        uint balanceAfter = value;\n\n        if (numEntriesSettled > 0) {\n            balanceAfter = tokenState.balanceOf(from);\n        }\n\n        // Reduce the value to transfer if balance is insufficient after reclaimed\n        value = value >= balanceAfter ? balanceAfter : value;\n\n        return _internalTransferFrom(from, to, value);\n    }\n\n    /**\n     * @notice _transferToFeeAddress function\n     * non-sUSD synths are exchanged into sUSD via synthInitiatedExchange\n     * notify feePool to record amount as fee paid to feePool */\n    function _transferToFeeAddress(address to, uint value) internal returns (bool) {\n        uint amountInUSD;\n\n        // sUSD can be transferred to FEE_ADDRESS directly\n        if (currencyKey == \"sUSD\") {\n            amountInUSD = value;\n            super._internalTransfer(messageSender, to, value);\n        } else {\n            // else exchange synth into sUSD and send to FEE_ADDRESS\n            (amountInUSD, ) = exchanger().exchange(\n                messageSender,\n                messageSender,\n                currencyKey,\n                value,\n                \"sUSD\",\n                FEE_ADDRESS,\n                false,\n                address(0),\n                bytes32(0)\n            );\n        }\n\n        // Notify feePool to record sUSD to distribute as fees\n        feePool().recordFeePaid(amountInUSD);\n\n        return true;\n    }\n\n    function issue(address account, uint amount) external onlyInternalContracts {\n        _internalIssue(account, amount);\n    }\n\n    function burn(address account, uint amount) external onlyInternalContracts {\n        _internalBurn(account, amount);\n    }\n\n    function _internalIssue(address account, uint amount) internal {\n        tokenState.setBalanceOf(account, tokenState.balanceOf(account).add(amount));\n        totalSupply = totalSupply.add(amount);\n        emitTransfer(address(0), account, amount);\n        emitIssued(account, amount);\n    }\n\n    function _internalBurn(address account, uint amount) internal returns (bool) {\n        tokenState.setBalanceOf(account, tokenState.balanceOf(account).sub(amount));\n        totalSupply = totalSupply.sub(amount);\n        emitTransfer(account, address(0), amount);\n        emitBurned(account, amount);\n\n        return true;\n    }\n\n    // Allow owner to set the total supply on import.\n    function setTotalSupply(uint amount) external optionalProxy_onlyOwner {\n        totalSupply = amount;\n    }\n\n    /* ========== VIEWS ========== */\n\n    // Note: use public visibility so that it can be invoked in a subclass\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        addresses = new bytes32[](5);\n        addresses[0] = CONTRACT_SYSTEMSTATUS;\n        addresses[1] = CONTRACT_EXCHANGER;\n        addresses[2] = CONTRACT_ISSUER;\n        addresses[3] = CONTRACT_FEEPOOL;\n        addresses[4] = CONTRACT_FUTURESMARKETMANAGER;\n    }\n\n    function systemStatus() internal view returns (ISystemStatus) {\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\n    }\n\n    function feePool() internal view returns (IFeePool) {\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));\n    }\n\n    function exchanger() internal view returns (IExchanger) {\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\n    }\n\n    function issuer() internal view returns (IIssuer) {\n        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));\n    }\n\n    function futuresMarketManager() internal view returns (IFuturesMarketManager) {\n        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));\n    }\n\n    function _ensureCanTransfer(address from, uint value) internal view {\n        require(exchanger().maxSecsLeftInWaitingPeriod(from, currencyKey) == 0, \"Cannot transfer during waiting period\");\n        require(transferableSynths(from) >= value, \"Insufficient balance after any settlement owing\");\n        systemStatus().requireSynthActive(currencyKey);\n    }\n\n    function transferableSynths(address account) public view returns (uint) {\n        (uint reclaimAmount, , ) = exchanger().settlementOwing(account, currencyKey);\n\n        // Note: ignoring rebate amount here because a settle() is required in order to\n        // allow the transfer to actually work\n\n        uint balance = tokenState.balanceOf(account);\n\n        if (reclaimAmount > balance) {\n            return 0;\n        } else {\n            return balance.sub(reclaimAmount);\n        }\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _internalTransferFrom(\n        address from,\n        address to,\n        uint value\n    ) internal returns (bool) {\n        // Skip allowance update in case of infinite allowance\n        if (tokenState.allowance(from, messageSender) != uint(-1)) {\n            // Reduce the allowance by the amount we're transferring.\n            // The safeSub call will handle an insufficient allowance.\n            tokenState.setAllowance(from, messageSender, tokenState.allowance(from, messageSender).sub(value));\n        }\n\n        return super._internalTransfer(from, to, value);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    function _isInternalContract(address account) internal view returns (bool) {\n        return\n            account == address(feePool()) ||\n            account == address(exchanger()) ||\n            account == address(issuer()) ||\n            account == address(futuresMarketManager());\n    }\n\n    modifier onlyInternalContracts() {\n        require(_isInternalContract(msg.sender), \"Only internal contracts allowed\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n    event Issued(address indexed account, uint value);\n    bytes32 private constant ISSUED_SIG = keccak256(\"Issued(address,uint256)\");\n\n    function emitIssued(address account, uint value) internal {\n        proxy._emit(abi.encode(value), 2, ISSUED_SIG, addressToBytes32(account), 0, 0);\n    }\n\n    event Burned(address indexed account, uint value);\n    bytes32 private constant BURNED_SIG = keccak256(\"Burned(address,uint256)\");\n\n    function emitBurned(address account, uint value) internal {\n        proxy._emit(abi.encode(value), 2, BURNED_SIG, addressToBytes32(account), 0, 0);\n    }\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/multicollateralsynth\ncontract MultiCollateralSynth is Synth {\n    bytes32 public constant CONTRACT_NAME = \"MultiCollateralSynth\";\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_COLLATERALMANAGER = \"CollateralManager\";\n    bytes32 private constant CONTRACT_ETHER_WRAPPER = \"EtherWrapper\";\n    bytes32 private constant CONTRACT_WRAPPER_FACTORY = \"WrapperFactory\";\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address payable _proxy,\n        TokenState _tokenState,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        address _owner,\n        bytes32 _currencyKey,\n        uint _totalSupply,\n        address _resolver\n    ) public Synth(_proxy, _tokenState, _tokenName, _tokenSymbol, _owner, _currencyKey, _totalSupply, _resolver) {}\n\n    /* ========== VIEWS ======================= */\n\n    function collateralManager() internal view returns (ICollateralManager) {\n        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));\n    }\n\n    function etherWrapper() internal view returns (IEtherWrapper) {\n        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));\n    }\n\n    function wrapperFactory() internal view returns (IWrapperFactory) {\n        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));\n    }\n\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        bytes32[] memory existingAddresses = Synth.resolverAddressesRequired();\n        bytes32[] memory newAddresses = new bytes32[](3);\n        newAddresses[0] = CONTRACT_COLLATERALMANAGER;\n        newAddresses[1] = CONTRACT_ETHER_WRAPPER;\n        newAddresses[2] = CONTRACT_WRAPPER_FACTORY;\n        addresses = combineArrays(existingAddresses, newAddresses);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Function that allows multi Collateral to issue a certain number of synths from an account.\n     * @param account Account to issue synths to\n     * @param amount Number of synths\n     */\n    function issue(address account, uint amount) external onlyInternalContracts {\n        super._internalIssue(account, amount);\n    }\n\n    /**\n     * @notice Function that allows multi Collateral to burn a certain number of synths from an account.\n     * @param account Account to burn synths from\n     * @param amount Number of synths\n     */\n    function burn(address account, uint amount) external onlyInternalContracts {\n        super._internalBurn(account, amount);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    // Contracts directly interacting with multiCollateralSynth or wrapper to issue and burn\n    modifier onlyInternalContracts() {\n        bool isInternal = super._isInternalContract(msg.sender);\n        bool isEtherWrapper = msg.sender == address(etherWrapper());\n        bool isWrapper = wrapperFactory().isWrapper(msg.sender);\n        bool isMultiCollateral = collateralManager().hasCollateral(msg.sender);\n\n        require(isInternal || isWrapper || isMultiCollateral || isEtherWrapper, \"Only internal contracts allowed\");\n        _;\n    }\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/proxyerc20\ncontract ProxyERC20 is Proxy, IERC20 {\n    constructor(address _owner) public Proxy(_owner) {}\n\n    // ------------- ERC20 Details ------------- //\n\n    function name() public view returns (string memory) {\n        // Immutable static call from target contract\n        return IERC20(address(target)).name();\n    }\n\n    function symbol() public view returns (string memory) {\n        // Immutable static call from target contract\n        return IERC20(address(target)).symbol();\n    }\n\n    function decimals() public view returns (uint8) {\n        // Immutable static call from target contract\n        return IERC20(address(target)).decimals();\n    }\n\n    // ------------- ERC20 Interface ------------- //\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view returns (uint256) {\n        // Immutable static call from target contract\n        return IERC20(address(target)).totalSupply();\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param account The address to query the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        // Immutable static call from target contract\n        return IERC20(address(target)).balanceOf(account);\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        // Immutable static call from target contract\n        return IERC20(address(target)).allowance(owner, spender);\n    }\n\n    /**\n     * @dev Transfer token for a specified address\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function transfer(address to, uint256 value) public returns (bool) {\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\n        target.setMessageSender(msg.sender);\n\n        // Forward the ERC20 call to the target contract\n        IERC20(address(target)).transfer(to, value);\n\n        // Event emitting will occur via Synthetix.Proxy._emit()\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\n        target.setMessageSender(msg.sender);\n\n        // Forward the ERC20 call to the target contract\n        IERC20(address(target)).approve(spender, value);\n\n        // Event emitting will occur via Synthetix.Proxy._emit()\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public returns (bool) {\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\n        target.setMessageSender(msg.sender);\n\n        // Forward the ERC20 call to the target contract\n        IERC20(address(target)).transferFrom(from, to, value);\n\n        // Event emitting will occur via Synthetix.Proxy._emit()\n        return true;\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/irewardescrow\ninterface IRewardEscrow {\n    // Views\n    function balanceOf(address account) external view returns (uint);\n\n    function numVestingEntries(address account) external view returns (uint);\n\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\n\n    function totalVestedAccountBalance(address account) external view returns (uint);\n\n    function getVestingScheduleEntry(address account, uint index) external view returns (uint[2] memory);\n\n    function getNextVestingIndex(address account) external view returns (uint);\n\n    // Mutative functions\n    function appendVestingEntry(address account, uint quantity) external;\n\n    function vest() external;\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/rewardescrow\ncontract RewardEscrow is Owned, IRewardEscrow {\n    using SafeMath for uint;\n\n    /* The corresponding Synthetix contract. */\n    ISynthetix public synthetix;\n\n    IFeePool public feePool;\n\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\n     * These are the times at which each given quantity of SNX vests. */\n    mapping(address => uint[2][]) public vestingSchedules;\n\n    /* An account's total escrowed synthetix balance to save recomputing this for fee extraction purposes. */\n    mapping(address => uint) public totalEscrowedAccountBalance;\n\n    /* An account's total vested reward synthetix. */\n    mapping(address => uint) public totalVestedAccountBalance;\n\n    /* The total remaining escrowed balance, for verifying the actual synthetix balance of this contract against. */\n    uint public totalEscrowedBalance;\n\n    uint internal constant TIME_INDEX = 0;\n    uint internal constant QUANTITY_INDEX = 1;\n\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules.\n     * There are 5 years of the supply schedule */\n    uint public constant MAX_VESTING_ENTRIES = 52 * 5;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        ISynthetix _synthetix,\n        IFeePool _feePool\n    ) public Owned(_owner) {\n        synthetix = _synthetix;\n        feePool = _feePool;\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice set the synthetix contract address as we need to transfer SNX when the user vests\n     */\n    function setSynthetix(ISynthetix _synthetix) external onlyOwner {\n        synthetix = _synthetix;\n        emit SynthetixUpdated(address(_synthetix));\n    }\n\n    /**\n     * @notice set the FeePool contract as it is the only authority to be able to call\n     * appendVestingEntry with the onlyFeePool modifer\n     */\n    function setFeePool(IFeePool _feePool) external onlyOwner {\n        feePool = _feePool;\n        emit FeePoolUpdated(address(_feePool));\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\n     */\n    function balanceOf(address account) public view returns (uint) {\n        return totalEscrowedAccountBalance[account];\n    }\n\n    function _numVestingEntries(address account) internal view returns (uint) {\n        return vestingSchedules[account].length;\n    }\n\n    /**\n     * @notice The number of vesting dates in an account's schedule.\n     */\n    function numVestingEntries(address account) external view returns (uint) {\n        return vestingSchedules[account].length;\n    }\n\n    /**\n     * @notice Get a particular schedule entry for an account.\n     * @return A pair of uints: (timestamp, synthetix quantity).\n     */\n    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {\n        return vestingSchedules[account][index];\n    }\n\n    /**\n     * @notice Get the time at which a given schedule entry will vest.\n     */\n    function getVestingTime(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Get the quantity of SNX associated with a given schedule entry.\n     */\n    function getVestingQuantity(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\n     */\n    function getNextVestingIndex(address account) public view returns (uint) {\n        uint len = _numVestingEntries(account);\n        for (uint i = 0; i < len; i++) {\n            if (getVestingTime(account, i) != 0) {\n                return i;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * @notice Obtain the next schedule entry that will vest for a given user.\n     * @return A pair of uints: (timestamp, synthetix quantity). */\n    function getNextVestingEntry(address account) public view returns (uint[2] memory) {\n        uint index = getNextVestingIndex(account);\n        if (index == _numVestingEntries(account)) {\n            return [uint(0), 0];\n        }\n        return getVestingScheduleEntry(account, index);\n    }\n\n    /**\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingTime(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingQuantity(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice return the full vesting schedule entries vest for a given user.\n     * @dev For DApps to display the vesting schedule for the\n     * inflationary supply over 5 years. Solidity cant return variable length arrays\n     * so this is returning pairs of data. Vesting Time at [0] and quantity at [1] and so on\n     */\n    function checkAccountSchedule(address account) public view returns (uint[520] memory) {\n        uint[520] memory _result;\n        uint schedules = _numVestingEntries(account);\n        for (uint i = 0; i < schedules; i++) {\n            uint[2] memory pair = getVestingScheduleEntry(account, i);\n            _result[i * 2] = pair[0];\n            _result[i * 2 + 1] = pair[1];\n        }\n        return _result;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function _appendVestingEntry(address account, uint quantity) internal {\n        /* No empty or already-passed vesting entries allowed. */\n        require(quantity != 0, \"Quantity cannot be zero\");\n\n        /* There must be enough balance in the contract to provide for the vesting entry. */\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\n        require(\n            totalEscrowedBalance <= IERC20(address(synthetix)).balanceOf(address(this)),\n            \"Must be enough balance in the contract to provide for the vesting entry\"\n        );\n\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\n        uint scheduleLength = vestingSchedules[account].length;\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \"Vesting schedule is too long\");\n\n        /* Escrow the tokens for 1 year. */\n        uint time = now + 52 weeks;\n\n        if (scheduleLength == 0) {\n            totalEscrowedAccountBalance[account] = quantity;\n        } else {\n            /* Disallow adding new vested SNX earlier than the last one.\n             * Since entries are only appended, this means that no vesting date can be repeated. */\n            require(\n                getVestingTime(account, scheduleLength - 1) < time,\n                \"Cannot add new vested entries earlier than the last one\"\n            );\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);\n        }\n\n        vestingSchedules[account].push([time, quantity]);\n\n        emit VestingEntryCreated(account, now, quantity);\n    }\n\n    /**\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\n     * @dev A call to this should accompany a previous successful call to synthetix.transfer(rewardEscrow, amount),\n     * to ensure that when the funds are withdrawn, there is enough balance.\n     * Note; although this function could technically be used to produce unbounded\n     * arrays, it's only withinn the 4 year period of the weekly inflation schedule.\n     * @param account The account to append a new vesting entry to.\n     * @param quantity The quantity of SNX that will be escrowed.\n     */\n    function appendVestingEntry(address account, uint quantity) external onlyFeePool {\n        _appendVestingEntry(account, quantity);\n    }\n\n    /**\n     * @notice Allow a user to withdraw any SNX in their schedule that have vested.\n     */\n    function vest() external {\n        uint numEntries = _numVestingEntries(msg.sender);\n        uint total;\n        for (uint i = 0; i < numEntries; i++) {\n            uint time = getVestingTime(msg.sender, i);\n            /* The list is sorted; when we reach the first future time, bail out. */\n            if (time > now) {\n                break;\n            }\n            uint qty = getVestingQuantity(msg.sender, i);\n            if (qty > 0) {\n                vestingSchedules[msg.sender][i] = [0, 0];\n                total = total.add(qty);\n            }\n        }\n\n        if (total != 0) {\n            totalEscrowedBalance = totalEscrowedBalance.sub(total);\n            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);\n            IERC20(address(synthetix)).transfer(msg.sender, total);\n            emit Vested(msg.sender, now, total);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyFeePool() {\n        bool isFeePool = msg.sender == address(feePool);\n\n        require(isFeePool, \"Only the FeePool contracts can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SynthetixUpdated(address newSynthetix);\n\n    event FeePoolUpdated(address newFeePool);\n\n    event Vested(address indexed beneficiary, uint time, uint value);\n\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/systemstatus\ncontract SystemStatus is Owned, ISystemStatus {\n    mapping(bytes32 => mapping(address => Status)) public accessControl;\n\n    uint248 public constant SUSPENSION_REASON_UPGRADE = 1;\n\n    bytes32 public constant SECTION_SYSTEM = \"System\";\n    bytes32 public constant SECTION_ISSUANCE = \"Issuance\";\n    bytes32 public constant SECTION_EXCHANGE = \"Exchange\";\n    bytes32 public constant SECTION_FUTURES = \"Futures\";\n    bytes32 public constant SECTION_SYNTH_EXCHANGE = \"SynthExchange\";\n    bytes32 public constant SECTION_SYNTH = \"Synth\";\n\n    bytes32 public constant CONTRACT_NAME = \"SystemStatus\";\n\n    Suspension public systemSuspension;\n\n    Suspension public issuanceSuspension;\n\n    Suspension public exchangeSuspension;\n\n    Suspension public futuresSuspension;\n\n    mapping(bytes32 => Suspension) public synthExchangeSuspension;\n\n    mapping(bytes32 => Suspension) public synthSuspension;\n\n    mapping(bytes32 => Suspension) public futuresMarketSuspension;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== VIEWS ========== */\n    function requireSystemActive() external view {\n        _internalRequireSystemActive();\n    }\n\n    function systemSuspended() external view returns (bool) {\n        return systemSuspension.suspended;\n    }\n\n    function requireIssuanceActive() external view {\n        // Issuance requires the system be active\n        _internalRequireSystemActive();\n\n        // and issuance itself of course\n        _internalRequireIssuanceActive();\n    }\n\n    function requireExchangeActive() external view {\n        // Exchanging requires the system be active\n        _internalRequireSystemActive();\n\n        // and exchanging itself of course\n        _internalRequireExchangeActive();\n    }\n\n    function requireSynthExchangeActive(bytes32 currencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n        _internalRequireSynthExchangeActive(currencyKey);\n    }\n\n    function requireFuturesActive() external view {\n        _internalRequireSystemActive();\n        _internalRequireExchangeActive();\n        _internalRequireFuturesActive();\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function requireFuturesMarketActive(bytes32 marketKey) external view {\n        _internalRequireSystemActive();\n        _internalRequireExchangeActive(); // exchanging implicitely used\n        _internalRequireFuturesActive(); // futures global flag\n        _internalRequireFuturesMarketActive(marketKey); // specific futures market flag\n    }\n\n    function synthSuspended(bytes32 currencyKey) external view returns (bool) {\n        return systemSuspension.suspended || synthSuspension[currencyKey].suspended;\n    }\n\n    function requireSynthActive(bytes32 currencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n        _internalRequireSynthActive(currencyKey);\n    }\n\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n        _internalRequireSynthActive(sourceCurrencyKey);\n        _internalRequireSynthActive(destinationCurrencyKey);\n    }\n\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n\n        // and exchanging must be active\n        _internalRequireExchangeActive();\n\n        // and the synth exchanging between the synths must be active\n        _internalRequireSynthExchangeActive(sourceCurrencyKey);\n        _internalRequireSynthExchangeActive(destinationCurrencyKey);\n\n        // and finally, the synths cannot be suspended\n        _internalRequireSynthActive(sourceCurrencyKey);\n        _internalRequireSynthActive(destinationCurrencyKey);\n    }\n\n    function isSystemUpgrading() external view returns (bool) {\n        return systemSuspension.suspended && systemSuspension.reason == SUSPENSION_REASON_UPGRADE;\n    }\n\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons)\n    {\n        exchangeSuspensions = new bool[](synths.length);\n        reasons = new uint256[](synths.length);\n\n        for (uint i = 0; i < synths.length; i++) {\n            exchangeSuspensions[i] = synthExchangeSuspension[synths[i]].suspended;\n            reasons[i] = synthExchangeSuspension[synths[i]].reason;\n        }\n    }\n\n    function getSynthSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons)\n    {\n        suspensions = new bool[](synths.length);\n        reasons = new uint256[](synths.length);\n\n        for (uint i = 0; i < synths.length; i++) {\n            suspensions[i] = synthSuspension[synths[i]].suspended;\n            reasons[i] = synthSuspension[synths[i]].reason;\n        }\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function getFuturesMarketSuspensions(bytes32[] calldata marketKeys)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons)\n    {\n        suspensions = new bool[](marketKeys.length);\n        reasons = new uint256[](marketKeys.length);\n\n        for (uint i = 0; i < marketKeys.length; i++) {\n            suspensions[i] = futuresMarketSuspension[marketKeys[i]].suspended;\n            reasons[i] = futuresMarketSuspension[marketKeys[i]].reason;\n        }\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n    function updateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) external onlyOwner {\n        _internalUpdateAccessControl(section, account, canSuspend, canResume);\n    }\n\n    function updateAccessControls(\n        bytes32[] calldata sections,\n        address[] calldata accounts,\n        bool[] calldata canSuspends,\n        bool[] calldata canResumes\n    ) external onlyOwner {\n        require(\n            sections.length == accounts.length &&\n                accounts.length == canSuspends.length &&\n                canSuspends.length == canResumes.length,\n            \"Input array lengths must match\"\n        );\n        for (uint i = 0; i < sections.length; i++) {\n            _internalUpdateAccessControl(sections[i], accounts[i], canSuspends[i], canResumes[i]);\n        }\n    }\n\n    function suspendSystem(uint256 reason) external {\n        _requireAccessToSuspend(SECTION_SYSTEM);\n        systemSuspension.suspended = true;\n        systemSuspension.reason = uint248(reason);\n        emit SystemSuspended(systemSuspension.reason);\n    }\n\n    function resumeSystem() external {\n        _requireAccessToResume(SECTION_SYSTEM);\n        systemSuspension.suspended = false;\n        emit SystemResumed(uint256(systemSuspension.reason));\n        systemSuspension.reason = 0;\n    }\n\n    function suspendIssuance(uint256 reason) external {\n        _requireAccessToSuspend(SECTION_ISSUANCE);\n        issuanceSuspension.suspended = true;\n        issuanceSuspension.reason = uint248(reason);\n        emit IssuanceSuspended(reason);\n    }\n\n    function resumeIssuance() external {\n        _requireAccessToResume(SECTION_ISSUANCE);\n        issuanceSuspension.suspended = false;\n        emit IssuanceResumed(uint256(issuanceSuspension.reason));\n        issuanceSuspension.reason = 0;\n    }\n\n    function suspendExchange(uint256 reason) external {\n        _requireAccessToSuspend(SECTION_EXCHANGE);\n        exchangeSuspension.suspended = true;\n        exchangeSuspension.reason = uint248(reason);\n        emit ExchangeSuspended(reason);\n    }\n\n    function resumeExchange() external {\n        _requireAccessToResume(SECTION_EXCHANGE);\n        exchangeSuspension.suspended = false;\n        emit ExchangeResumed(uint256(exchangeSuspension.reason));\n        exchangeSuspension.reason = 0;\n    }\n\n    function suspendFutures(uint256 reason) external {\n        _requireAccessToSuspend(SECTION_FUTURES);\n        futuresSuspension.suspended = true;\n        futuresSuspension.reason = uint248(reason);\n        emit FuturesSuspended(reason);\n    }\n\n    function resumeFutures() external {\n        _requireAccessToResume(SECTION_FUTURES);\n        futuresSuspension.suspended = false;\n        emit FuturesResumed(uint256(futuresSuspension.reason));\n        futuresSuspension.reason = 0;\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function suspendFuturesMarket(bytes32 marketKey, uint256 reason) external {\n        bytes32[] memory marketKeys = new bytes32[](1);\n        marketKeys[0] = marketKey;\n        _internalSuspendFuturesMarkets(marketKeys, reason);\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function suspendFuturesMarkets(bytes32[] calldata marketKeys, uint256 reason) external {\n        _internalSuspendFuturesMarkets(marketKeys, reason);\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function resumeFuturesMarket(bytes32 marketKey) external {\n        bytes32[] memory marketKeys = new bytes32[](1);\n        marketKeys[0] = marketKey;\n        _internalResumeFuturesMarkets(marketKeys);\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function resumeFuturesMarkets(bytes32[] calldata marketKeys) external {\n        _internalResumeFuturesMarkets(marketKeys);\n    }\n\n    function suspendSynthExchange(bytes32 currencyKey, uint256 reason) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalSuspendSynthExchange(currencyKeys, reason);\n    }\n\n    function suspendSynthsExchange(bytes32[] calldata currencyKeys, uint256 reason) external {\n        _internalSuspendSynthExchange(currencyKeys, reason);\n    }\n\n    function resumeSynthExchange(bytes32 currencyKey) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalResumeSynthsExchange(currencyKeys);\n    }\n\n    function resumeSynthsExchange(bytes32[] calldata currencyKeys) external {\n        _internalResumeSynthsExchange(currencyKeys);\n    }\n\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalSuspendSynths(currencyKeys, reason);\n    }\n\n    function suspendSynths(bytes32[] calldata currencyKeys, uint256 reason) external {\n        _internalSuspendSynths(currencyKeys, reason);\n    }\n\n    function resumeSynth(bytes32 currencyKey) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalResumeSynths(currencyKeys);\n    }\n\n    function resumeSynths(bytes32[] calldata currencyKeys) external {\n        _internalResumeSynths(currencyKeys);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _requireAccessToSuspend(bytes32 section) internal view {\n        require(accessControl[section][msg.sender].canSuspend, \"Restricted to access control list\");\n    }\n\n    function _requireAccessToResume(bytes32 section) internal view {\n        require(accessControl[section][msg.sender].canResume, \"Restricted to access control list\");\n    }\n\n    function _internalRequireSystemActive() internal view {\n        require(\n            !systemSuspension.suspended,\n            systemSuspension.reason == SUSPENSION_REASON_UPGRADE\n                ? \"Synthetix is suspended, upgrade in progress... please stand by\"\n                : \"Synthetix is suspended. Operation prohibited\"\n        );\n    }\n\n    function _internalRequireIssuanceActive() internal view {\n        require(!issuanceSuspension.suspended, \"Issuance is suspended. Operation prohibited\");\n    }\n\n    function _internalRequireExchangeActive() internal view {\n        require(!exchangeSuspension.suspended, \"Exchange is suspended. Operation prohibited\");\n    }\n\n    function _internalRequireFuturesActive() internal view {\n        require(!futuresSuspension.suspended, \"Futures markets are suspended. Operation prohibited\");\n    }\n\n    function _internalRequireSynthExchangeActive(bytes32 currencyKey) internal view {\n        require(!synthExchangeSuspension[currencyKey].suspended, \"Synth exchange suspended. Operation prohibited\");\n    }\n\n    function _internalRequireSynthActive(bytes32 currencyKey) internal view {\n        require(!synthSuspension[currencyKey].suspended, \"Synth is suspended. Operation prohibited\");\n    }\n\n    function _internalRequireFuturesMarketActive(bytes32 marketKey) internal view {\n        require(!futuresMarketSuspension[marketKey].suspended, \"Market suspended\");\n    }\n\n    function _internalSuspendSynths(bytes32[] memory currencyKeys, uint256 reason) internal {\n        _requireAccessToSuspend(SECTION_SYNTH);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            synthSuspension[currencyKey].suspended = true;\n            synthSuspension[currencyKey].reason = uint248(reason);\n            emit SynthSuspended(currencyKey, reason);\n        }\n    }\n\n    function _internalResumeSynths(bytes32[] memory currencyKeys) internal {\n        _requireAccessToResume(SECTION_SYNTH);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            emit SynthResumed(currencyKey, uint256(synthSuspension[currencyKey].reason));\n            delete synthSuspension[currencyKey];\n        }\n    }\n\n    function _internalSuspendSynthExchange(bytes32[] memory currencyKeys, uint256 reason) internal {\n        _requireAccessToSuspend(SECTION_SYNTH_EXCHANGE);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            synthExchangeSuspension[currencyKey].suspended = true;\n            synthExchangeSuspension[currencyKey].reason = uint248(reason);\n            emit SynthExchangeSuspended(currencyKey, reason);\n        }\n    }\n\n    function _internalResumeSynthsExchange(bytes32[] memory currencyKeys) internal {\n        _requireAccessToResume(SECTION_SYNTH_EXCHANGE);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            emit SynthExchangeResumed(currencyKey, uint256(synthExchangeSuspension[currencyKey].reason));\n            delete synthExchangeSuspension[currencyKey];\n        }\n    }\n\n    function _internalSuspendFuturesMarkets(bytes32[] memory marketKeys, uint256 reason) internal {\n        _requireAccessToSuspend(SECTION_FUTURES);\n        for (uint i = 0; i < marketKeys.length; i++) {\n            bytes32 marketKey = marketKeys[i];\n            futuresMarketSuspension[marketKey].suspended = true;\n            futuresMarketSuspension[marketKey].reason = uint248(reason);\n            emit FuturesMarketSuspended(marketKey, reason);\n        }\n    }\n\n    function _internalResumeFuturesMarkets(bytes32[] memory marketKeys) internal {\n        _requireAccessToResume(SECTION_FUTURES);\n        for (uint i = 0; i < marketKeys.length; i++) {\n            bytes32 marketKey = marketKeys[i];\n            emit FuturesMarketResumed(marketKey, uint256(futuresMarketSuspension[marketKey].reason));\n            delete futuresMarketSuspension[marketKey];\n        }\n    }\n\n    function _internalUpdateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) internal {\n        require(\n            section == SECTION_SYSTEM ||\n                section == SECTION_ISSUANCE ||\n                section == SECTION_EXCHANGE ||\n                section == SECTION_FUTURES ||\n                section == SECTION_SYNTH_EXCHANGE ||\n                section == SECTION_SYNTH,\n            \"Invalid section supplied\"\n        );\n        accessControl[section][account].canSuspend = canSuspend;\n        accessControl[section][account].canResume = canResume;\n        emit AccessControlUpdated(section, account, canSuspend, canResume);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SystemSuspended(uint256 reason);\n    event SystemResumed(uint256 reason);\n\n    event IssuanceSuspended(uint256 reason);\n    event IssuanceResumed(uint256 reason);\n\n    event ExchangeSuspended(uint256 reason);\n    event ExchangeResumed(uint256 reason);\n\n    event FuturesSuspended(uint256 reason);\n    event FuturesResumed(uint256 reason);\n\n    event SynthExchangeSuspended(bytes32 currencyKey, uint256 reason);\n    event SynthExchangeResumed(bytes32 currencyKey, uint256 reason);\n\n    event SynthSuspended(bytes32 currencyKey, uint256 reason);\n    event SynthResumed(bytes32 currencyKey, uint256 reason);\n\n    event FuturesMarketSuspended(bytes32 marketKey, uint256 reason);\n    event FuturesMarketResumed(bytes32 marketKey, uint256 reason);\n\n    event AccessControlUpdated(bytes32 indexed section, address indexed account, bool canSuspend, bool canResume);\n}\n\n\ninterface ISynthetixNamedContract {\n    // solhint-disable func-name-mixedcase\n    function CONTRACT_NAME() external view returns (bytes32);\n}\n\n// solhint-disable contract-name-camelcase\nlibrary MigrationLib_Diphda {\n        // ----------------------------\n    // EXISTING SYNTHETIX CONTRACTS\n    // ----------------------------\n\n    // https://etherscan.io/address/0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83\n    AddressResolver public constant addressresolver_i = AddressResolver(0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83);\n    // https://etherscan.io/address/0xb440DD674e1243644791a4AdfE3A2AbB0A92d309\n    Proxy public constant proxyfeepool_i = Proxy(0xb440DD674e1243644791a4AdfE3A2AbB0A92d309);\n    // https://etherscan.io/address/0xC9DFff5fA5605fd94F8B7927b892F2B57391e8bB\n    FeePoolEternalStorage public constant feepooleternalstorage_i = FeePoolEternalStorage(0xC9DFff5fA5605fd94F8B7927b892F2B57391e8bB);\n    // https://etherscan.io/address/0x545973f28950f50fc6c7F52AAb4Ad214A27C0564\n    ExchangeState public constant exchangestate_i = ExchangeState(0x545973f28950f50fc6c7F52AAb4Ad214A27C0564);\n    // https://etherscan.io/address/0x696c905F8F8c006cA46e9808fE7e00049507798F\n    SystemStatus public constant systemstatus_i = SystemStatus(0x696c905F8F8c006cA46e9808fE7e00049507798F);\n    // https://etherscan.io/address/0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F\n    RewardEscrow public constant rewardescrow_i = RewardEscrow(0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F);\n    // https://etherscan.io/address/0x3B2f389AeE480238A49E3A9985cd6815370712eB\n    FeePool public constant feepool_i = FeePool(0x3B2f389AeE480238A49E3A9985cd6815370712eB);\n    // https://etherscan.io/address/0x1620Aa736939597891C1940CF0d28b82566F9390\n    DebtCache public constant debtcache_i = DebtCache(0x1620Aa736939597891C1940CF0d28b82566F9390);\n    // https://etherscan.io/address/0x6fA9E5923CBFDD39F0B625Bf1350Ffb50D5006b9\n    ExchangeRatesWithDexPricing public constant exchangerates_i = ExchangeRatesWithDexPricing(0x6fA9E5923CBFDD39F0B625Bf1350Ffb50D5006b9);\n    // https://etherscan.io/address/0x7df9b3f8f1C011D8BD707430e97E747479DD532a\n    MultiCollateralSynth public constant synthsusd_i = MultiCollateralSynth(0x7df9b3f8f1C011D8BD707430e97E747479DD532a);\n    // https://etherscan.io/address/0x05a9CBe762B36632b3594DA4F082340E0e5343e8\n    TokenState public constant tokenstatesusd_i = TokenState(0x05a9CBe762B36632b3594DA4F082340E0e5343e8);\n    // https://etherscan.io/address/0x57Ab1ec28D129707052df4dF418D58a2D46d5f51\n    Proxy public constant proxysusd_i = Proxy(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51);\n    // https://etherscan.io/address/0x1b06a00Df0B27E7871E753720D4917a7D1aac68b\n    MultiCollateralSynth public constant synthseur_i = MultiCollateralSynth(0x1b06a00Df0B27E7871E753720D4917a7D1aac68b);\n    // https://etherscan.io/address/0x6568D9e750fC44AF00f857885Dfb8281c00529c4\n    TokenState public constant tokenstateseur_i = TokenState(0x6568D9e750fC44AF00f857885Dfb8281c00529c4);\n    // https://etherscan.io/address/0xD71eCFF9342A5Ced620049e616c5035F1dB98620\n    ProxyERC20 public constant proxyseur_i = ProxyERC20(0xD71eCFF9342A5Ced620049e616c5035F1dB98620);\n    // https://etherscan.io/address/0xB82f11f3168Ece7D56fe6a5679567948090de7C5\n    MultiCollateralSynth public constant synthsjpy_i = MultiCollateralSynth(0xB82f11f3168Ece7D56fe6a5679567948090de7C5);\n    // https://etherscan.io/address/0x4dFACfB15514C21c991ff75Bc7Bf6Fb1F98361ed\n    TokenState public constant tokenstatesjpy_i = TokenState(0x4dFACfB15514C21c991ff75Bc7Bf6Fb1F98361ed);\n    // https://etherscan.io/address/0xF6b1C627e95BFc3c1b4c9B825a032Ff0fBf3e07d\n    ProxyERC20 public constant proxysjpy_i = ProxyERC20(0xF6b1C627e95BFc3c1b4c9B825a032Ff0fBf3e07d);\n    // https://etherscan.io/address/0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C\n    MultiCollateralSynth public constant synthsaud_i = MultiCollateralSynth(0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C);\n    // https://etherscan.io/address/0xCb29D2cf2C65d3Be1d00F07f3441390432D55203\n    TokenState public constant tokenstatesaud_i = TokenState(0xCb29D2cf2C65d3Be1d00F07f3441390432D55203);\n    // https://etherscan.io/address/0xF48e200EAF9906362BB1442fca31e0835773b8B4\n    ProxyERC20 public constant proxysaud_i = ProxyERC20(0xF48e200EAF9906362BB1442fca31e0835773b8B4);\n    // https://etherscan.io/address/0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf\n    MultiCollateralSynth public constant synthsgbp_i = MultiCollateralSynth(0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf);\n    // https://etherscan.io/address/0x7e88D19A79b291cfE5696d496055f7e57F537A75\n    TokenState public constant tokenstatesgbp_i = TokenState(0x7e88D19A79b291cfE5696d496055f7e57F537A75);\n    // https://etherscan.io/address/0x97fe22E7341a0Cd8Db6F6C021A24Dc8f4DAD855F\n    ProxyERC20 public constant proxysgbp_i = ProxyERC20(0x97fe22E7341a0Cd8Db6F6C021A24Dc8f4DAD855F);\n    // https://etherscan.io/address/0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d\n    MultiCollateralSynth public constant synthschf_i = MultiCollateralSynth(0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d);\n    // https://etherscan.io/address/0x52496fE8a4feaEFe14d9433E00D48E6929c13deC\n    TokenState public constant tokenstateschf_i = TokenState(0x52496fE8a4feaEFe14d9433E00D48E6929c13deC);\n    // https://etherscan.io/address/0x0F83287FF768D1c1e17a42F44d644D7F22e8ee1d\n    ProxyERC20 public constant proxyschf_i = ProxyERC20(0x0F83287FF768D1c1e17a42F44d644D7F22e8ee1d);\n    // https://etherscan.io/address/0x527637bE27640d6C3e751d24DC67129A6d13E11C\n    MultiCollateralSynth public constant synthskrw_i = MultiCollateralSynth(0x527637bE27640d6C3e751d24DC67129A6d13E11C);\n    // https://etherscan.io/address/0x93B6e9FbBd2c32a0DC3C2B943B7C3CBC2fE23730\n    TokenState public constant tokenstateskrw_i = TokenState(0x93B6e9FbBd2c32a0DC3C2B943B7C3CBC2fE23730);\n    // https://etherscan.io/address/0x269895a3dF4D73b077Fc823dD6dA1B95f72Aaf9B\n    ProxyERC20 public constant proxyskrw_i = ProxyERC20(0x269895a3dF4D73b077Fc823dD6dA1B95f72Aaf9B);\n    // https://etherscan.io/address/0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6\n    MultiCollateralSynth public constant synthsbtc_i = MultiCollateralSynth(0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6);\n    // https://etherscan.io/address/0x4F6296455F8d754c19821cF1EC8FeBF2cD456E67\n    TokenState public constant tokenstatesbtc_i = TokenState(0x4F6296455F8d754c19821cF1EC8FeBF2cD456E67);\n    // https://etherscan.io/address/0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6\n    ProxyERC20 public constant proxysbtc_i = ProxyERC20(0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6);\n    // https://etherscan.io/address/0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6\n    MultiCollateralSynth public constant synthseth_i = MultiCollateralSynth(0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6);\n    // https://etherscan.io/address/0x34A5ef81d18F3a305aE9C2d7DF42beef4c79031c\n    TokenState public constant tokenstateseth_i = TokenState(0x34A5ef81d18F3a305aE9C2d7DF42beef4c79031c);\n    // https://etherscan.io/address/0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb\n    ProxyERC20 public constant proxyseth_i = ProxyERC20(0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb);\n    // https://etherscan.io/address/0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6\n    MultiCollateralSynth public constant synthslink_i = MultiCollateralSynth(0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6);\n    // https://etherscan.io/address/0x577D4a7395c6A5f46d9981a5F83fa7294926aBB0\n    TokenState public constant tokenstateslink_i = TokenState(0x577D4a7395c6A5f46d9981a5F83fa7294926aBB0);\n    // https://etherscan.io/address/0xbBC455cb4F1B9e4bFC4B73970d360c8f032EfEE6\n    ProxyERC20 public constant proxyslink_i = ProxyERC20(0xbBC455cb4F1B9e4bFC4B73970d360c8f032EfEE6);\n    // https://etherscan.io/address/0xB34F4d7c207D8979D05EDb0F63f174764Bd67825\n    MultiCollateralSynth public constant synthsada_i = MultiCollateralSynth(0xB34F4d7c207D8979D05EDb0F63f174764Bd67825);\n    // https://etherscan.io/address/0x9956c5019a24fbd5B506AD070b771577bAc5c343\n    TokenState public constant tokenstatesada_i = TokenState(0x9956c5019a24fbd5B506AD070b771577bAc5c343);\n    // https://etherscan.io/address/0xe36E2D3c7c34281FA3bC737950a68571736880A1\n    ProxyERC20 public constant proxysada_i = ProxyERC20(0xe36E2D3c7c34281FA3bC737950a68571736880A1);\n    // https://etherscan.io/address/0x95aE43E5E96314E4afffcf19D9419111cd11169e\n    MultiCollateralSynth public constant synthsaave_i = MultiCollateralSynth(0x95aE43E5E96314E4afffcf19D9419111cd11169e);\n    // https://etherscan.io/address/0x9BcED8A8E3Ad81c9b146FFC880358f734A06f7c0\n    TokenState public constant tokenstatesaave_i = TokenState(0x9BcED8A8E3Ad81c9b146FFC880358f734A06f7c0);\n    // https://etherscan.io/address/0xd2dF355C19471c8bd7D8A3aa27Ff4e26A21b4076\n    ProxyERC20 public constant proxysaave_i = ProxyERC20(0xd2dF355C19471c8bd7D8A3aa27Ff4e26A21b4076);\n    // https://etherscan.io/address/0x27b45A4208b87A899009f45888139882477Acea5\n    MultiCollateralSynth public constant synthsdot_i = MultiCollateralSynth(0x27b45A4208b87A899009f45888139882477Acea5);\n    // https://etherscan.io/address/0x73B1a2643507Cd30F11Dfcf2D974f4373E5BC077\n    TokenState public constant tokenstatesdot_i = TokenState(0x73B1a2643507Cd30F11Dfcf2D974f4373E5BC077);\n    // https://etherscan.io/address/0x1715AC0743102BF5Cd58EfBB6Cf2dC2685d967b6\n    ProxyERC20 public constant proxysdot_i = ProxyERC20(0x1715AC0743102BF5Cd58EfBB6Cf2dC2685d967b6);\n    // https://etherscan.io/address/0x6DF798ec713b33BE823b917F27820f2aA0cf7662\n    MultiCollateralSynth public constant synthsethbtc_i = MultiCollateralSynth(0x6DF798ec713b33BE823b917F27820f2aA0cf7662);\n    // https://etherscan.io/address/0x042A7A0022A7695454ac5Be77a4860e50c9683fC\n    TokenState public constant tokenstatesethbtc_i = TokenState(0x042A7A0022A7695454ac5Be77a4860e50c9683fC);\n    // https://etherscan.io/address/0x104eDF1da359506548BFc7c25bA1E28C16a70235\n    ProxyERC20 public constant proxysethbtc_i = ProxyERC20(0x104eDF1da359506548BFc7c25bA1E28C16a70235);\n    // https://etherscan.io/address/0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124\n    MultiCollateralSynth public constant synthsdefi_i = MultiCollateralSynth(0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124);\n    // https://etherscan.io/address/0x7Ac2D37098a65B0f711CFfA3be635F1E6aCacFaB\n    TokenState public constant tokenstatesdefi_i = TokenState(0x7Ac2D37098a65B0f711CFfA3be635F1E6aCacFaB);\n    // https://etherscan.io/address/0xe1aFe1Fd76Fd88f78cBf599ea1846231B8bA3B6B\n    ProxyERC20 public constant proxysdefi_i = ProxyERC20(0xe1aFe1Fd76Fd88f78cBf599ea1846231B8bA3B6B);\n    // https://etherscan.io/address/0xE60E71E47Ca405946CF147CA9d7589a851DBcddC\n    Issuer public constant issuer_i = Issuer(0xE60E71E47Ca405946CF147CA9d7589a851DBcddC);\n\n    // ----------------------------------\n    // NEW CONTRACTS DEPLOYED TO BE ADDED\n    // ----------------------------------\n\n    // https://etherscan.io/address/0x977d0DD7eA212E9ca1dcD4Ec15cd7Ceb135fa68D\n    address public constant new_OneNetAggregatorDebtRatio_contract = 0x977d0DD7eA212E9ca1dcD4Ec15cd7Ceb135fa68D;\n    // https://etherscan.io/address/0x696c905F8F8c006cA46e9808fE7e00049507798F\n    address public constant new_SystemStatus_contract = 0x696c905F8F8c006cA46e9808fE7e00049507798F;\n    // https://etherscan.io/address/0x6fA9E5923CBFDD39F0B625Bf1350Ffb50D5006b9\n    address public constant new_ExchangeRates_contract = 0x6fA9E5923CBFDD39F0B625Bf1350Ffb50D5006b9;\n    // https://etherscan.io/address/0xcf1405b18dBCEA2893Abe635c88359C75878B9e1\n    address public constant new_OneNetAggregatorIssuedSynths_contract = 0xcf1405b18dBCEA2893Abe635c88359C75878B9e1;\n    // https://etherscan.io/address/0x3B2f389AeE480238A49E3A9985cd6815370712eB\n    address public constant new_FeePool_contract = 0x3B2f389AeE480238A49E3A9985cd6815370712eB;\n    // https://etherscan.io/address/0x74E9a032B04D9732E826eECFC5c7A1C183602FB1\n    address public constant new_Exchanger_contract = 0x74E9a032B04D9732E826eECFC5c7A1C183602FB1;\n    // https://etherscan.io/address/0xeAcaEd9581294b1b5cfb6B941d4B8B81B2005437\n    address public constant new_ExchangeCircuitBreaker_contract = 0xeAcaEd9581294b1b5cfb6B941d4B8B81B2005437;\n    // https://etherscan.io/address/0x1620Aa736939597891C1940CF0d28b82566F9390\n    address public constant new_DebtCache_contract = 0x1620Aa736939597891C1940CF0d28b82566F9390;\n    // https://etherscan.io/address/0xc51f137e19F1ae6944887388FD12b2b6dFD12594\n    address public constant new_SynthetixBridgeToOptimism_contract = 0xc51f137e19F1ae6944887388FD12b2b6dFD12594;\n    // https://etherscan.io/address/0xE60E71E47Ca405946CF147CA9d7589a851DBcddC\n    address public constant new_Issuer_contract = 0xE60E71E47Ca405946CF147CA9d7589a851DBcddC;\n    // https://etherscan.io/address/0x7df9b3f8f1C011D8BD707430e97E747479DD532a\n    address public constant new_SynthsUSD_contract = 0x7df9b3f8f1C011D8BD707430e97E747479DD532a;\n    // https://etherscan.io/address/0x1b06a00Df0B27E7871E753720D4917a7D1aac68b\n    address public constant new_SynthsEUR_contract = 0x1b06a00Df0B27E7871E753720D4917a7D1aac68b;\n    // https://etherscan.io/address/0xB82f11f3168Ece7D56fe6a5679567948090de7C5\n    address public constant new_SynthsJPY_contract = 0xB82f11f3168Ece7D56fe6a5679567948090de7C5;\n    // https://etherscan.io/address/0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C\n    address public constant new_SynthsAUD_contract = 0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C;\n    // https://etherscan.io/address/0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf\n    address public constant new_SynthsGBP_contract = 0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf;\n    // https://etherscan.io/address/0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d\n    address public constant new_SynthsCHF_contract = 0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d;\n    // https://etherscan.io/address/0x527637bE27640d6C3e751d24DC67129A6d13E11C\n    address public constant new_SynthsKRW_contract = 0x527637bE27640d6C3e751d24DC67129A6d13E11C;\n    // https://etherscan.io/address/0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6\n    address public constant new_SynthsETH_contract = 0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6;\n    // https://etherscan.io/address/0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6\n    address public constant new_SynthsBTC_contract = 0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6;\n    // https://etherscan.io/address/0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6\n    address public constant new_SynthsLINK_contract = 0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6;\n    // https://etherscan.io/address/0xB34F4d7c207D8979D05EDb0F63f174764Bd67825\n    address public constant new_SynthsADA_contract = 0xB34F4d7c207D8979D05EDb0F63f174764Bd67825;\n    // https://etherscan.io/address/0x95aE43E5E96314E4afffcf19D9419111cd11169e\n    address public constant new_SynthsAAVE_contract = 0x95aE43E5E96314E4afffcf19D9419111cd11169e;\n    // https://etherscan.io/address/0x27b45A4208b87A899009f45888139882477Acea5\n    address public constant new_SynthsDOT_contract = 0x27b45A4208b87A899009f45888139882477Acea5;\n    // https://etherscan.io/address/0x6DF798ec713b33BE823b917F27820f2aA0cf7662\n    address public constant new_SynthsETHBTC_contract = 0x6DF798ec713b33BE823b917F27820f2aA0cf7662;\n    // https://etherscan.io/address/0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124\n    address public constant new_SynthsDEFI_contract = 0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124;\n    // https://etherscan.io/address/0x834Ef6c82D431Ac9A7A6B66325F185b2430780D7\n    address public constant new_FuturesMarketManager_contract = 0x834Ef6c82D431Ac9A7A6B66325F185b2430780D7;\n\n    function migrate2() external {\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sUSD();\n        // Ensure the sUSD synth can write to its TokenState;\n        tokenstatesusd_i.setAssociatedContract(new_SynthsUSD_contract);\n        // Ensure the sUSD synth Proxy is correctly connected to the Synth;\n        proxysusd_i.setTarget(Proxyable(new_SynthsUSD_contract));\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sEUR();\n        // Ensure the sEUR synth can write to its TokenState;\n        tokenstateseur_i.setAssociatedContract(new_SynthsEUR_contract);\n        // Ensure the sEUR synth Proxy is correctly connected to the Synth;\n        proxyseur_i.setTarget(Proxyable(new_SynthsEUR_contract));\n        // Ensure the ExchangeRates contract has the feed for sEUR;\n        exchangerates_i.addAggregator(\"sEUR\", 0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sJPY();\n        // Ensure the sJPY synth can write to its TokenState;\n        tokenstatesjpy_i.setAssociatedContract(new_SynthsJPY_contract);\n        // Ensure the sJPY synth Proxy is correctly connected to the Synth;\n        proxysjpy_i.setTarget(Proxyable(new_SynthsJPY_contract));\n        // Ensure the ExchangeRates contract has the feed for sJPY;\n        exchangerates_i.addAggregator(\"sJPY\", 0xBcE206caE7f0ec07b545EddE332A47C2F75bbeb3);\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sAUD();\n        // Ensure the sAUD synth can write to its TokenState;\n        tokenstatesaud_i.setAssociatedContract(new_SynthsAUD_contract);\n        // Ensure the sAUD synth Proxy is correctly connected to the Synth;\n        proxysaud_i.setTarget(Proxyable(new_SynthsAUD_contract));\n        // Ensure the ExchangeRates contract has the feed for sAUD;\n        exchangerates_i.addAggregator(\"sAUD\", 0x77F9710E7d0A19669A13c055F62cd80d313dF022);\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sGBP();\n        // Ensure the sGBP synth can write to its TokenState;\n        tokenstatesgbp_i.setAssociatedContract(new_SynthsGBP_contract);\n        // Ensure the sGBP synth Proxy is correctly connected to the Synth;\n        proxysgbp_i.setTarget(Proxyable(new_SynthsGBP_contract));\n        // Ensure the ExchangeRates contract has the feed for sGBP;\n        exchangerates_i.addAggregator(\"sGBP\", 0x5c0Ab2d9b5a7ed9f470386e82BB36A3613cDd4b5);\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sCHF();\n        // Ensure the sCHF synth can write to its TokenState;\n        tokenstateschf_i.setAssociatedContract(new_SynthsCHF_contract);\n        // Ensure the sCHF synth Proxy is correctly connected to the Synth;\n        proxyschf_i.setTarget(Proxyable(new_SynthsCHF_contract));\n        // Ensure the ExchangeRates contract has the feed for sCHF;\n        exchangerates_i.addAggregator(\"sCHF\", 0x449d117117838fFA61263B61dA6301AA2a88B13A);\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sKRW();\n        // Ensure the sKRW synth can write to its TokenState;\n        tokenstateskrw_i.setAssociatedContract(new_SynthsKRW_contract);\n        // Ensure the sKRW synth Proxy is correctly connected to the Synth;\n        proxyskrw_i.setTarget(Proxyable(new_SynthsKRW_contract));\n        // Ensure the ExchangeRates contract has the feed for sKRW;\n        exchangerates_i.addAggregator(\"sKRW\", 0x01435677FB11763550905594A16B645847C1d0F3);\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sBTC();\n        // Ensure the sBTC synth can write to its TokenState;\n        tokenstatesbtc_i.setAssociatedContract(new_SynthsBTC_contract);\n        // Ensure the sBTC synth Proxy is correctly connected to the Synth;\n        proxysbtc_i.setTarget(Proxyable(new_SynthsBTC_contract));\n        // Ensure the ExchangeRates contract has the feed for sBTC;\n        exchangerates_i.addAggregator(\"sBTC\", 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sETH();\n        // Ensure the sETH synth can write to its TokenState;\n        tokenstateseth_i.setAssociatedContract(new_SynthsETH_contract);\n        // Ensure the sETH synth Proxy is correctly connected to the Synth;\n        proxyseth_i.setTarget(Proxyable(new_SynthsETH_contract));\n        // Ensure the ExchangeRates contract has the feed for sETH;\n        exchangerates_i.addAggregator(\"sETH\", 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sLINK();\n        // Ensure the sLINK synth can write to its TokenState;\n        tokenstateslink_i.setAssociatedContract(new_SynthsLINK_contract);\n        // Ensure the sLINK synth Proxy is correctly connected to the Synth;\n        proxyslink_i.setTarget(Proxyable(new_SynthsLINK_contract));\n        // Ensure the ExchangeRates contract has the feed for sLINK;\n        exchangerates_i.addAggregator(\"sLINK\", 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c);\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sADA();\n        // Ensure the sADA synth can write to its TokenState;\n        tokenstatesada_i.setAssociatedContract(new_SynthsADA_contract);\n        // Ensure the sADA synth Proxy is correctly connected to the Synth;\n        proxysada_i.setTarget(Proxyable(new_SynthsADA_contract));\n        // Ensure the ExchangeRates contract has the feed for sADA;\n        exchangerates_i.addAggregator(\"sADA\", 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55);\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sAAVE();\n        // Ensure the sAAVE synth can write to its TokenState;\n        tokenstatesaave_i.setAssociatedContract(new_SynthsAAVE_contract);\n        // Ensure the sAAVE synth Proxy is correctly connected to the Synth;\n        proxysaave_i.setTarget(Proxyable(new_SynthsAAVE_contract));\n        // Ensure the ExchangeRates contract has the feed for sAAVE;\n        exchangerates_i.addAggregator(\"sAAVE\", 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9);\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sDOT();\n        // Ensure the sDOT synth can write to its TokenState;\n        tokenstatesdot_i.setAssociatedContract(new_SynthsDOT_contract);\n        // Ensure the sDOT synth Proxy is correctly connected to the Synth;\n        proxysdot_i.setTarget(Proxyable(new_SynthsDOT_contract));\n        // Ensure the ExchangeRates contract has the feed for sDOT;\n        exchangerates_i.addAggregator(\"sDOT\", 0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734);\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sETHBTC();\n        // Ensure the sETHBTC synth can write to its TokenState;\n        tokenstatesethbtc_i.setAssociatedContract(new_SynthsETHBTC_contract);\n        // Ensure the sETHBTC synth Proxy is correctly connected to the Synth;\n        proxysethbtc_i.setTarget(Proxyable(new_SynthsETHBTC_contract));\n        // Ensure the ExchangeRates contract has the feed for sETHBTC;\n        exchangerates_i.addAggregator(\"sETHBTC\", 0xAc559F25B1619171CbC396a50854A3240b6A4e99);\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sDEFI();\n        // Ensure the sDEFI synth can write to its TokenState;\n        tokenstatesdefi_i.setAssociatedContract(new_SynthsDEFI_contract);\n        // Ensure the sDEFI synth Proxy is correctly connected to the Synth;\n        proxysdefi_i.setTarget(Proxyable(new_SynthsDEFI_contract));\n        // Ensure the ExchangeRates contract has the feed for sDEFI;\n        exchangerates_i.addAggregator(\"sDEFI\", 0xa8E875F94138B0C5b51d1e1d5dE35bbDdd28EA87);\n        // Add synths to the Issuer contract - batch 1;\n        issuer_addSynths_96();\n        // SIP-120 Set the DEX price aggregator (uniswap TWAP oracle reader);\n        exchangerates_i.setDexPriceAggregator(IDexPriceAggregator(0xf120F029Ac143633d1942e48aE2Dfa2036C5786c));\n    }\n\n    function copyTotalSupplyFrom_sUSD() internal {\n        // https://etherscan.io/address/0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA;\n        Synth existingSynth = Synth(0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA);\n        // https://etherscan.io/address/0x7df9b3f8f1C011D8BD707430e97E747479DD532a;\n        Synth newSynth = Synth(0x7df9b3f8f1C011D8BD707430e97E747479DD532a);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    \n    function copyTotalSupplyFrom_sEUR() internal {\n        // https://etherscan.io/address/0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0;\n        Synth existingSynth = Synth(0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0);\n        // https://etherscan.io/address/0x1b06a00Df0B27E7871E753720D4917a7D1aac68b;\n        Synth newSynth = Synth(0x1b06a00Df0B27E7871E753720D4917a7D1aac68b);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    \n    function copyTotalSupplyFrom_sJPY() internal {\n        // https://etherscan.io/address/0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A;\n        Synth existingSynth = Synth(0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A);\n        // https://etherscan.io/address/0xB82f11f3168Ece7D56fe6a5679567948090de7C5;\n        Synth newSynth = Synth(0xB82f11f3168Ece7D56fe6a5679567948090de7C5);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    \n    function copyTotalSupplyFrom_sAUD() internal {\n        // https://etherscan.io/address/0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827;\n        Synth existingSynth = Synth(0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827);\n        // https://etherscan.io/address/0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C;\n        Synth newSynth = Synth(0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    \n    function copyTotalSupplyFrom_sGBP() internal {\n        // https://etherscan.io/address/0xde3892383965FBa6eC434bE6350F85f140098708;\n        Synth existingSynth = Synth(0xde3892383965FBa6eC434bE6350F85f140098708);\n        // https://etherscan.io/address/0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf;\n        Synth newSynth = Synth(0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    \n    function copyTotalSupplyFrom_sCHF() internal {\n        // https://etherscan.io/address/0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D;\n        Synth existingSynth = Synth(0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D);\n        // https://etherscan.io/address/0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d;\n        Synth newSynth = Synth(0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    \n    function copyTotalSupplyFrom_sKRW() internal {\n        // https://etherscan.io/address/0xe2f532c389deb5E42DCe53e78A9762949A885455;\n        Synth existingSynth = Synth(0xe2f532c389deb5E42DCe53e78A9762949A885455);\n        // https://etherscan.io/address/0x527637bE27640d6C3e751d24DC67129A6d13E11C;\n        Synth newSynth = Synth(0x527637bE27640d6C3e751d24DC67129A6d13E11C);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    \n    function copyTotalSupplyFrom_sBTC() internal {\n        // https://etherscan.io/address/0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353;\n        Synth existingSynth = Synth(0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353);\n        // https://etherscan.io/address/0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6;\n        Synth newSynth = Synth(0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    \n    function copyTotalSupplyFrom_sETH() internal {\n        // https://etherscan.io/address/0xc70B42930BD8D30A79B55415deC3be60827559f7;\n        Synth existingSynth = Synth(0xc70B42930BD8D30A79B55415deC3be60827559f7);\n        // https://etherscan.io/address/0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6;\n        Synth newSynth = Synth(0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    \n    function copyTotalSupplyFrom_sLINK() internal {\n        // https://etherscan.io/address/0x3FFE35c3d412150C3B91d3E22eBA60E16030C608;\n        Synth existingSynth = Synth(0x3FFE35c3d412150C3B91d3E22eBA60E16030C608);\n        // https://etherscan.io/address/0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6;\n        Synth newSynth = Synth(0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    \n    function copyTotalSupplyFrom_sADA() internal {\n        // https://etherscan.io/address/0x8f9fa817200F5B95f9572c8Acf2b31410C00335a;\n        Synth existingSynth = Synth(0x8f9fa817200F5B95f9572c8Acf2b31410C00335a);\n        // https://etherscan.io/address/0xB34F4d7c207D8979D05EDb0F63f174764Bd67825;\n        Synth newSynth = Synth(0xB34F4d7c207D8979D05EDb0F63f174764Bd67825);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    \n    function copyTotalSupplyFrom_sAAVE() internal {\n        // https://etherscan.io/address/0x0705F0716b12a703d4F8832Ec7b97C61771f0361;\n        Synth existingSynth = Synth(0x0705F0716b12a703d4F8832Ec7b97C61771f0361);\n        // https://etherscan.io/address/0x95aE43E5E96314E4afffcf19D9419111cd11169e;\n        Synth newSynth = Synth(0x95aE43E5E96314E4afffcf19D9419111cd11169e);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    \n    function copyTotalSupplyFrom_sDOT() internal {\n        // https://etherscan.io/address/0xfA60918C4417b64E722ca15d79C751c1f24Ab995;\n        Synth existingSynth = Synth(0xfA60918C4417b64E722ca15d79C751c1f24Ab995);\n        // https://etherscan.io/address/0x27b45A4208b87A899009f45888139882477Acea5;\n        Synth newSynth = Synth(0x27b45A4208b87A899009f45888139882477Acea5);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    \n    function copyTotalSupplyFrom_sETHBTC() internal {\n        // https://etherscan.io/address/0xcc3aab773e2171b2E257Ee17001400eE378aa52B;\n        Synth existingSynth = Synth(0xcc3aab773e2171b2E257Ee17001400eE378aa52B);\n        // https://etherscan.io/address/0x6DF798ec713b33BE823b917F27820f2aA0cf7662;\n        Synth newSynth = Synth(0x6DF798ec713b33BE823b917F27820f2aA0cf7662);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    \n    function copyTotalSupplyFrom_sDEFI() internal {\n        // https://etherscan.io/address/0xe59dFC746D566EB40F92ed0B162004e24E3AC932;\n        Synth existingSynth = Synth(0xe59dFC746D566EB40F92ed0B162004e24E3AC932);\n        // https://etherscan.io/address/0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124;\n        Synth newSynth = Synth(0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n    \n    function issuer_addSynths_96() internal {\n        ISynth[] memory issuer_addSynths_synthsToAdd_96_0 = new ISynth[](15);\n        issuer_addSynths_synthsToAdd_96_0[0] = ISynth(new_SynthsUSD_contract);\n        issuer_addSynths_synthsToAdd_96_0[1] = ISynth(new_SynthsEUR_contract);\n        issuer_addSynths_synthsToAdd_96_0[2] = ISynth(new_SynthsJPY_contract);\n        issuer_addSynths_synthsToAdd_96_0[3] = ISynth(new_SynthsAUD_contract);\n        issuer_addSynths_synthsToAdd_96_0[4] = ISynth(new_SynthsGBP_contract);\n        issuer_addSynths_synthsToAdd_96_0[5] = ISynth(new_SynthsCHF_contract);\n        issuer_addSynths_synthsToAdd_96_0[6] = ISynth(new_SynthsKRW_contract);\n        issuer_addSynths_synthsToAdd_96_0[7] = ISynth(new_SynthsBTC_contract);\n        issuer_addSynths_synthsToAdd_96_0[8] = ISynth(new_SynthsETH_contract);\n        issuer_addSynths_synthsToAdd_96_0[9] = ISynth(new_SynthsLINK_contract);\n        issuer_addSynths_synthsToAdd_96_0[10] = ISynth(new_SynthsADA_contract);\n        issuer_addSynths_synthsToAdd_96_0[11] = ISynth(new_SynthsAAVE_contract);\n        issuer_addSynths_synthsToAdd_96_0[12] = ISynth(new_SynthsDOT_contract);\n        issuer_addSynths_synthsToAdd_96_0[13] = ISynth(new_SynthsETHBTC_contract);\n        issuer_addSynths_synthsToAdd_96_0[14] = ISynth(new_SynthsDEFI_contract);\n        issuer_i.addSynths(issuer_addSynths_synthsToAdd_96_0);\n    }\n\n\n    function addressresolver_importAddresses_0() external {\n        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](28);\n        addressresolver_importAddresses_names_0_0[0] = bytes32(\"OneNetAggregatorDebtRatio\");\n        addressresolver_importAddresses_names_0_0[1] = bytes32(\"SystemStatus\");\n        addressresolver_importAddresses_names_0_0[2] = bytes32(\"ExchangeRates\");\n        addressresolver_importAddresses_names_0_0[3] = bytes32(\"OneNetAggregatorIssuedSynths\");\n        addressresolver_importAddresses_names_0_0[4] = bytes32(\"FeePool\");\n        addressresolver_importAddresses_names_0_0[5] = bytes32(\"Exchanger\");\n        addressresolver_importAddresses_names_0_0[6] = bytes32(\"ExchangeCircuitBreaker\");\n        addressresolver_importAddresses_names_0_0[7] = bytes32(\"DebtCache\");\n        addressresolver_importAddresses_names_0_0[8] = bytes32(\"SynthetixBridgeToOptimism\");\n        addressresolver_importAddresses_names_0_0[9] = bytes32(\"Issuer\");\n        addressresolver_importAddresses_names_0_0[10] = bytes32(\"SynthsUSD\");\n        addressresolver_importAddresses_names_0_0[11] = bytes32(\"SynthsEUR\");\n        addressresolver_importAddresses_names_0_0[12] = bytes32(\"SynthsJPY\");\n        addressresolver_importAddresses_names_0_0[13] = bytes32(\"SynthsAUD\");\n        addressresolver_importAddresses_names_0_0[14] = bytes32(\"SynthsGBP\");\n        addressresolver_importAddresses_names_0_0[15] = bytes32(\"SynthsCHF\");\n        addressresolver_importAddresses_names_0_0[16] = bytes32(\"SynthsKRW\");\n        addressresolver_importAddresses_names_0_0[17] = bytes32(\"SynthsETH\");\n        addressresolver_importAddresses_names_0_0[18] = bytes32(\"SynthsBTC\");\n        addressresolver_importAddresses_names_0_0[19] = bytes32(\"SynthsLINK\");\n        addressresolver_importAddresses_names_0_0[20] = bytes32(\"SynthsADA\");\n        addressresolver_importAddresses_names_0_0[21] = bytes32(\"SynthsAAVE\");\n        addressresolver_importAddresses_names_0_0[22] = bytes32(\"SynthsDOT\");\n        addressresolver_importAddresses_names_0_0[23] = bytes32(\"SynthsETHBTC\");\n        addressresolver_importAddresses_names_0_0[24] = bytes32(\"SynthsDEFI\");\n        addressresolver_importAddresses_names_0_0[25] = bytes32(\"FuturesMarketManager\");\n        addressresolver_importAddresses_names_0_0[26] = bytes32(\"ext:AggregatorIssuedSynths\");\n        addressresolver_importAddresses_names_0_0[27] = bytes32(\"ext:AggregatorDebtRatio\");\n        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](28);\n        addressresolver_importAddresses_destinations_0_1[0] = address(new_OneNetAggregatorDebtRatio_contract);\n        addressresolver_importAddresses_destinations_0_1[1] = address(new_SystemStatus_contract);\n        addressresolver_importAddresses_destinations_0_1[2] = address(new_ExchangeRates_contract);\n        addressresolver_importAddresses_destinations_0_1[3] = address(new_OneNetAggregatorIssuedSynths_contract);\n        addressresolver_importAddresses_destinations_0_1[4] = address(new_FeePool_contract);\n        addressresolver_importAddresses_destinations_0_1[5] = address(new_Exchanger_contract);\n        addressresolver_importAddresses_destinations_0_1[6] = address(new_ExchangeCircuitBreaker_contract);\n        addressresolver_importAddresses_destinations_0_1[7] = address(new_DebtCache_contract);\n        addressresolver_importAddresses_destinations_0_1[8] = address(new_SynthetixBridgeToOptimism_contract);\n        addressresolver_importAddresses_destinations_0_1[9] = address(new_Issuer_contract);\n        addressresolver_importAddresses_destinations_0_1[10] = address(new_SynthsUSD_contract);\n        addressresolver_importAddresses_destinations_0_1[11] = address(new_SynthsEUR_contract);\n        addressresolver_importAddresses_destinations_0_1[12] = address(new_SynthsJPY_contract);\n        addressresolver_importAddresses_destinations_0_1[13] = address(new_SynthsAUD_contract);\n        addressresolver_importAddresses_destinations_0_1[14] = address(new_SynthsGBP_contract);\n        addressresolver_importAddresses_destinations_0_1[15] = address(new_SynthsCHF_contract);\n        addressresolver_importAddresses_destinations_0_1[16] = address(new_SynthsKRW_contract);\n        addressresolver_importAddresses_destinations_0_1[17] = address(new_SynthsETH_contract);\n        addressresolver_importAddresses_destinations_0_1[18] = address(new_SynthsBTC_contract);\n        addressresolver_importAddresses_destinations_0_1[19] = address(new_SynthsLINK_contract);\n        addressresolver_importAddresses_destinations_0_1[20] = address(new_SynthsADA_contract);\n        addressresolver_importAddresses_destinations_0_1[21] = address(new_SynthsAAVE_contract);\n        addressresolver_importAddresses_destinations_0_1[22] = address(new_SynthsDOT_contract);\n        addressresolver_importAddresses_destinations_0_1[23] = address(new_SynthsETHBTC_contract);\n        addressresolver_importAddresses_destinations_0_1[24] = address(new_SynthsDEFI_contract);\n        addressresolver_importAddresses_destinations_0_1[25] = address(new_FuturesMarketManager_contract);\n        addressresolver_importAddresses_destinations_0_1[26] = address(new_OneNetAggregatorIssuedSynths_contract);\n        addressresolver_importAddresses_destinations_0_1[27] = address(new_OneNetAggregatorDebtRatio_contract);\n        addressresolver_i.importAddresses(addressresolver_importAddresses_names_0_0, addressresolver_importAddresses_destinations_0_1);\n    }\n\n    \n    function addressresolver_rebuildCaches_1() external {\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_1_0 = new MixinResolver[](20);\n        addressresolver_rebuildCaches_destinations_1_0[0] = MixinResolver(0xDA4eF8520b1A57D7d63f1E249606D1A459698876);\n        addressresolver_rebuildCaches_destinations_1_0[1] = MixinResolver(0xAD95C918af576c82Df740878C3E983CBD175daB6);\n        addressresolver_rebuildCaches_destinations_1_0[2] = MixinResolver(new_FeePool_contract);\n        addressresolver_rebuildCaches_destinations_1_0[3] = MixinResolver(0xE95A536cF5C7384FF1ef54819Dc54E03d0FF1979);\n        addressresolver_rebuildCaches_destinations_1_0[4] = MixinResolver(new_DebtCache_contract);\n        addressresolver_rebuildCaches_destinations_1_0[5] = MixinResolver(new_Exchanger_contract);\n        addressresolver_rebuildCaches_destinations_1_0[6] = MixinResolver(new_ExchangeCircuitBreaker_contract);\n        addressresolver_rebuildCaches_destinations_1_0[7] = MixinResolver(new_Issuer_contract);\n        addressresolver_rebuildCaches_destinations_1_0[8] = MixinResolver(new_SynthsUSD_contract);\n        addressresolver_rebuildCaches_destinations_1_0[9] = MixinResolver(new_SynthsEUR_contract);\n        addressresolver_rebuildCaches_destinations_1_0[10] = MixinResolver(new_SynthsJPY_contract);\n        addressresolver_rebuildCaches_destinations_1_0[11] = MixinResolver(new_SynthsAUD_contract);\n        addressresolver_rebuildCaches_destinations_1_0[12] = MixinResolver(new_SynthsGBP_contract);\n        addressresolver_rebuildCaches_destinations_1_0[13] = MixinResolver(new_SynthsCHF_contract);\n        addressresolver_rebuildCaches_destinations_1_0[14] = MixinResolver(new_SynthsKRW_contract);\n        addressresolver_rebuildCaches_destinations_1_0[15] = MixinResolver(new_SynthsBTC_contract);\n        addressresolver_rebuildCaches_destinations_1_0[16] = MixinResolver(new_SynthsETH_contract);\n        addressresolver_rebuildCaches_destinations_1_0[17] = MixinResolver(new_SynthsLINK_contract);\n        addressresolver_rebuildCaches_destinations_1_0[18] = MixinResolver(new_SynthsADA_contract);\n        addressresolver_rebuildCaches_destinations_1_0[19] = MixinResolver(new_SynthsAAVE_contract);\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_1_0);\n    }\n\n    \n    function addressresolver_rebuildCaches_2() external {\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_2_0 = new MixinResolver[](16);\n        addressresolver_rebuildCaches_destinations_2_0[0] = MixinResolver(new_SynthsDOT_contract);\n        addressresolver_rebuildCaches_destinations_2_0[1] = MixinResolver(new_SynthsETHBTC_contract);\n        addressresolver_rebuildCaches_destinations_2_0[2] = MixinResolver(new_SynthsDEFI_contract);\n        addressresolver_rebuildCaches_destinations_2_0[3] = MixinResolver(0x5c8344bcdC38F1aB5EB5C1d4a35DdEeA522B5DfA);\n        addressresolver_rebuildCaches_destinations_2_0[4] = MixinResolver(0xaa03aB31b55DceEeF845C8d17890CC61cD98eD04);\n        addressresolver_rebuildCaches_destinations_2_0[5] = MixinResolver(0x1F2c3a1046c32729862fcB038369696e3273a516);\n        addressresolver_rebuildCaches_destinations_2_0[6] = MixinResolver(0x7C22547779c8aa41bAE79E03E8383a0BefBCecf0);\n        addressresolver_rebuildCaches_destinations_2_0[7] = MixinResolver(0xC1AAE9d18bBe386B102435a8632C8063d31e747C);\n        addressresolver_rebuildCaches_destinations_2_0[8] = MixinResolver(0x067e398605E84F2D0aEEC1806e62768C5110DCc6);\n        addressresolver_rebuildCaches_destinations_2_0[9] = MixinResolver(new_ExchangeRates_contract);\n        addressresolver_rebuildCaches_destinations_2_0[10] = MixinResolver(new_SynthetixBridgeToOptimism_contract);\n        addressresolver_rebuildCaches_destinations_2_0[11] = MixinResolver(0x02f9bC46beD33acdB9cb002fe346734CeF8a9480);\n        addressresolver_rebuildCaches_destinations_2_0[12] = MixinResolver(0x62922670313bf6b41C580143d1f6C173C5C20019);\n        addressresolver_rebuildCaches_destinations_2_0[13] = MixinResolver(0x89FCb32F29e509cc42d0C8b6f058C993013A843F);\n        addressresolver_rebuildCaches_destinations_2_0[14] = MixinResolver(0xe533139Af961c9747356D947838c98451015e234);\n        addressresolver_rebuildCaches_destinations_2_0[15] = MixinResolver(0x7A3d898b717e50a96fd8b232E9d15F0A547A7eeb);\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_2_0);\n    }\n}\n\n    ", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"addressresolver_i\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"AddressResolver\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debtcache_i\",\"outputs\":[{\"internalType\":\"contract DebtCache\",\"name\":\"\",\"type\":\"DebtCache\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangerates_i\",\"outputs\":[{\"internalType\":\"contract ExchangeRatesWithDexPricing\",\"name\":\"\",\"type\":\"ExchangeRatesWithDexPricing\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangestate_i\",\"outputs\":[{\"internalType\":\"contract ExchangeState\",\"name\":\"\",\"type\":\"ExchangeState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feepool_i\",\"outputs\":[{\"internalType\":\"contract FeePool\",\"name\":\"\",\"type\":\"FeePool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feepooleternalstorage_i\",\"outputs\":[{\"internalType\":\"contract FeePoolEternalStorage\",\"name\":\"\",\"type\":\"FeePoolEternalStorage\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuer_i\",\"outputs\":[{\"internalType\":\"contract Issuer\",\"name\":\"\",\"type\":\"Issuer\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_DebtCache_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_ExchangeCircuitBreaker_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_ExchangeRates_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Exchanger_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_FeePool_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_FuturesMarketManager_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Issuer_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_OneNetAggregatorDebtRatio_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_OneNetAggregatorIssuedSynths_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthetixBridgeToOptimism_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsAAVE_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsADA_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsAUD_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsBTC_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsCHF_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsDEFI_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsDOT_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsETHBTC_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsETH_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsEUR_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsGBP_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsJPY_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsKRW_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsLINK_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsUSD_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SystemStatus_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyfeepool_i\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"Proxy\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysaave_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"ProxyERC20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysada_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"ProxyERC20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysaud_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"ProxyERC20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysbtc_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"ProxyERC20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyschf_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"ProxyERC20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysdefi_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"ProxyERC20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysdot_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"ProxyERC20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyseth_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"ProxyERC20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysethbtc_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"ProxyERC20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyseur_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"ProxyERC20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysgbp_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"ProxyERC20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysjpy_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"ProxyERC20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyskrw_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"ProxyERC20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyslink_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"ProxyERC20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysusd_i\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"Proxy\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardescrow_i\",\"outputs\":[{\"internalType\":\"contract RewardEscrow\",\"name\":\"\",\"type\":\"RewardEscrow\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsaave_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"MultiCollateralSynth\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsada_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"MultiCollateralSynth\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsaud_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"MultiCollateralSynth\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsbtc_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"MultiCollateralSynth\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthschf_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"MultiCollateralSynth\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsdefi_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"MultiCollateralSynth\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsdot_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"MultiCollateralSynth\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthseth_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"MultiCollateralSynth\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsethbtc_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"MultiCollateralSynth\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthseur_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"MultiCollateralSynth\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsgbp_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"MultiCollateralSynth\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsjpy_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"MultiCollateralSynth\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthskrw_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"MultiCollateralSynth\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthslink_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"MultiCollateralSynth\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsusd_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"MultiCollateralSynth\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemstatus_i\",\"outputs\":[{\"internalType\":\"contract SystemStatus\",\"name\":\"\",\"type\":\"SystemStatus\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesaave_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"TokenState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesada_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"TokenState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesaud_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"TokenState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesbtc_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"TokenState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateschf_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"TokenState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesdefi_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"TokenState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesdot_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"TokenState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateseth_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"TokenState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesethbtc_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"TokenState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateseur_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"TokenState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesgbp_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"TokenState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesjpy_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"TokenState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateskrw_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"TokenState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateslink_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"TokenState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesusd_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"TokenState\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MigrationLib_Diphda", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}