{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface AggregatorValidatorInterface {\r\n  function validate(\r\n    uint256 previousRoundId,\r\n    int256 previousAnswer,\r\n    uint256 currentRoundId,\r\n    int256 currentAnswer\r\n  )\r\n    external\r\n    returns (\r\n      bool\r\n    );\r\n}\r\n\r\nabstract contract TypeAndVersionInterface{\r\n  function typeAndVersion()\r\n    external\r\n    pure\r\n    virtual\r\n    returns (\r\n      string memory\r\n    );\r\n}\r\n\r\n/**\r\n * @title The ConfirmedOwner contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract ConfirmedOwner {\r\n\r\n  address private s_owner;\r\n  address private s_pendingOwner;\r\n\r\n  event OwnershipTransferRequested(\r\n    address indexed from,\r\n    address indexed to\r\n  );\r\n  event OwnershipTransferred(\r\n    address indexed from,\r\n    address indexed to\r\n  );\r\n\r\n  constructor(address newOwner) {\r\n    s_owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @notice Allows an owner to begin transferring ownership to a new address,\r\n   * pending.\r\n   */\r\n  function transferOwnership(\r\n    address to\r\n  )\r\n    external\r\n    onlyOwner()\r\n  {\r\n    require(to != msg.sender, \"Cannot transfer to self\");\r\n\r\n    s_pendingOwner = to;\r\n\r\n    emit OwnershipTransferRequested(s_owner, to);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows an ownership transfer to be completed by the recipient.\r\n   */\r\n  function acceptOwnership()\r\n    external\r\n  {\r\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\r\n\r\n    address oldOwner = s_owner;\r\n    s_owner = msg.sender;\r\n    s_pendingOwner = address(0);\r\n\r\n    emit OwnershipTransferred(oldOwner, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the current owner\r\n   */\r\n  function owner()\r\n    public\r\n    view\r\n    returns (\r\n      address\r\n    )\r\n  {\r\n    return s_owner;\r\n  }\r\n\r\n  /**\r\n   * @notice Reverts if called by anyone other than the contract owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == s_owner, \"Only callable by owner\");\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract ValidatorProxy is AggregatorValidatorInterface, TypeAndVersionInterface, ConfirmedOwner {\r\n\r\n  /// @notice Uses a single storage slot to store the current address\r\n  struct AggregatorConfiguration {\r\n    address target;\r\n    bool hasNewProposal;\r\n  }\r\n\r\n  struct ValidatorConfiguration {\r\n    AggregatorValidatorInterface target;\r\n    bool hasNewProposal;\r\n  }\r\n\r\n  // Configuration for the current aggregator\r\n  AggregatorConfiguration private s_currentAggregator;\r\n  // Proposed aggregator address\r\n  address private s_proposedAggregator;\r\n\r\n  // Configuration for the current validator\r\n  ValidatorConfiguration private s_currentValidator;\r\n  // Proposed validator address\r\n  AggregatorValidatorInterface private s_proposedValidator;\r\n\r\n  event AggregatorProposed(\r\n    address indexed aggregator\r\n  );\r\n  event AggregatorUpgraded(\r\n    address indexed previous,\r\n    address indexed current\r\n  );\r\n  event ValidatorProposed(\r\n    AggregatorValidatorInterface indexed validator\r\n  );\r\n  event ValidatorUpgraded(\r\n    AggregatorValidatorInterface indexed previous,\r\n    AggregatorValidatorInterface indexed current\r\n  );\r\n  /// @notice The proposed aggregator called validate, but the call was not passed on to any validators\r\n  event ProposedAggregatorValidateCall(\r\n    address indexed proposed,\r\n    uint256 previousRoundId,\r\n    int256 previousAnswer,\r\n    uint256 currentRoundId,\r\n    int256 currentAnswer\r\n  );\r\n\r\n  /**\r\n   * @notice Construct the ValidatorProxy with an aggregator and a validator\r\n   * @param aggregator address\r\n   * @param validator address\r\n   */\r\n  constructor(\r\n    address aggregator,\r\n    AggregatorValidatorInterface validator\r\n  )\r\n    ConfirmedOwner(msg.sender)\r\n  {\r\n    s_currentAggregator = AggregatorConfiguration({\r\n      target: aggregator,\r\n      hasNewProposal: false\r\n    });\r\n    s_currentValidator = ValidatorConfiguration({\r\n      target: validator,\r\n      hasNewProposal: false\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @notice Validate a transmission\r\n   * @dev Must be called by either the `s_currentAggregator.target`, or the `s_proposedAggregator`.\r\n   * If called by the `s_currentAggregator.target` this function passes the call on to the `s_currentValidator.target`\r\n   * and the `s_proposedValidator`, if it is set.\r\n   * If called by the `s_proposedAggregator` this function emits a `ProposedAggregatorValidateCall` to signal that\r\n   * the call was received.\r\n   * @dev To guard against external `validate` calls reverting, we use raw calls here.\r\n   * We favour `call` over try-catch to ensure that failures are avoided even if the validator address is incorrectly\r\n   * set as a non-contract address.\r\n   * @dev If the `aggregator` and `validator` are the same contract or collude, this could exhibit reentrancy behavior.\r\n   * However, since that contract would have to be explicitly written for reentrancy and that the `owner` would have\r\n   * to configure this contract to use that malicious contract, we refrain from using mutex or check here.\r\n   * @dev This does not perform any checks on any roundId, so it is possible that a validator receive different reports\r\n   * for the same roundId at different points in time. Validator implementations should be aware of this.\r\n   * @param previousRoundId uint256\r\n   * @param previousAnswer int256\r\n   * @param currentRoundId uint256\r\n   * @param currentAnswer int256\r\n   * @return bool\r\n   */\r\n  function validate(\r\n    uint256 previousRoundId,\r\n    int256 previousAnswer,\r\n    uint256 currentRoundId,\r\n    int256 currentAnswer\r\n  )\r\n    external\r\n    override\r\n    returns (\r\n      bool\r\n    )\r\n  {\r\n    address currentAggregator = s_currentAggregator.target;\r\n    if (msg.sender != currentAggregator) {\r\n      address proposedAggregator = s_proposedAggregator;\r\n      require(msg.sender == proposedAggregator, \"Not a configured aggregator\");\r\n      // If the aggregator is still in proposed state, emit an event and don't push to any validator.\r\n      // This is to confirm that `validate` is being called prior to upgrade.\r\n      emit ProposedAggregatorValidateCall(\r\n        proposedAggregator,\r\n        previousRoundId,\r\n        previousAnswer,\r\n        currentRoundId,\r\n        currentAnswer\r\n      );\r\n      return true;\r\n    }\r\n\r\n    // Send the validate call to the current validator\r\n    ValidatorConfiguration memory currentValidator = s_currentValidator;\r\n    address currentValidatorAddress = address(currentValidator.target);\r\n    require(currentValidatorAddress != address(0), \"No validator set\");\r\n    currentValidatorAddress.call(\r\n      abi.encodeWithSelector(\r\n        AggregatorValidatorInterface.validate.selector,\r\n        previousRoundId,\r\n        previousAnswer,\r\n        currentRoundId,\r\n        currentAnswer\r\n      )\r\n    );\r\n    // If there is a new proposed validator, send the validate call to that validator also\r\n    if (currentValidator.hasNewProposal) {\r\n      address(s_proposedValidator).call(\r\n        abi.encodeWithSelector(\r\n          AggregatorValidatorInterface.validate.selector,\r\n          previousRoundId,\r\n          previousAnswer,\r\n          currentRoundId,\r\n          currentAnswer\r\n        )\r\n      );\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** AGGREGATOR CONFIGURATION FUNCTIONS **/\r\n\r\n  /**\r\n   * @notice Propose an aggregator\r\n   * @dev A zero address can be used to unset the proposed aggregator. Only owner can call.\r\n   * @param proposed address\r\n   */\r\n  function proposeNewAggregator(\r\n    address proposed\r\n  )\r\n    external\r\n    onlyOwner()\r\n  {\r\n    require(s_proposedAggregator != proposed && s_currentAggregator.target != proposed, \"Invalid proposal\");\r\n    s_proposedAggregator = proposed;\r\n    // If proposed is zero address, hasNewProposal = false\r\n    s_currentAggregator.hasNewProposal = (proposed != address(0));\r\n    emit AggregatorProposed(proposed);\r\n  }\r\n\r\n  /**\r\n   * @notice Upgrade the aggregator by setting the current aggregator as the proposed aggregator.\r\n   * @dev Must have a proposed aggregator. Only owner can call.\r\n   */\r\n  function upgradeAggregator()\r\n    external\r\n    onlyOwner()\r\n  {\r\n    // Get configuration in memory\r\n    AggregatorConfiguration memory current = s_currentAggregator;\r\n    address previous = current.target;\r\n    address proposed = s_proposedAggregator;\r\n\r\n    // Perform the upgrade\r\n    require(current.hasNewProposal, \"No proposal\");\r\n    s_currentAggregator = AggregatorConfiguration({\r\n      target: proposed,\r\n      hasNewProposal: false\r\n    });\r\n    delete s_proposedAggregator;\r\n\r\n    emit AggregatorUpgraded(previous, proposed);\r\n  }\r\n\r\n  /**\r\n   * @notice Get aggregator details\r\n   * @return current address\r\n   * @return hasProposal bool\r\n   * @return proposed address\r\n   */\r\n  function getAggregators()\r\n    external\r\n    view\r\n    returns(\r\n      address current,\r\n      bool hasProposal,\r\n      address proposed\r\n    )\r\n  {\r\n    current = s_currentAggregator.target;\r\n    hasProposal = s_currentAggregator.hasNewProposal;\r\n    proposed = s_proposedAggregator;\r\n  }\r\n\r\n  /** VALIDATOR CONFIGURATION FUNCTIONS **/\r\n\r\n  /**\r\n   * @notice Propose an validator\r\n   * @dev A zero address can be used to unset the proposed validator. Only owner can call.\r\n   * @param proposed address\r\n   */\r\n  function proposeNewValidator(\r\n    AggregatorValidatorInterface proposed\r\n  )\r\n    external\r\n    onlyOwner()\r\n  {\r\n    require(s_proposedValidator != proposed && s_currentValidator.target != proposed, \"Invalid proposal\");\r\n    s_proposedValidator = proposed;\r\n    // If proposed is zero address, hasNewProposal = false\r\n    s_currentValidator.hasNewProposal = (address(proposed) != address(0));\r\n    emit ValidatorProposed(proposed);\r\n  }\r\n\r\n  /**\r\n   * @notice Upgrade the validator by setting the current validator as the proposed validator.\r\n   * @dev Must have a proposed validator. Only owner can call.\r\n   */\r\n  function upgradeValidator()\r\n    external\r\n    onlyOwner()\r\n  {\r\n    // Get configuration in memory\r\n    ValidatorConfiguration memory current = s_currentValidator;\r\n    AggregatorValidatorInterface previous = current.target;\r\n    AggregatorValidatorInterface proposed = s_proposedValidator;\r\n\r\n    // Perform the upgrade\r\n    require(current.hasNewProposal, \"No proposal\");\r\n    s_currentValidator = ValidatorConfiguration({\r\n      target: proposed,\r\n      hasNewProposal: false\r\n    });\r\n    delete s_proposedValidator;\r\n\r\n    emit ValidatorUpgraded(previous, proposed);\r\n  }\r\n\r\n  /**\r\n   * @notice Get validator details\r\n   * @return current address\r\n   * @return hasProposal bool\r\n   * @return proposed address\r\n   */\r\n  function getValidators()\r\n    external\r\n    view\r\n    returns(\r\n      AggregatorValidatorInterface current,\r\n      bool hasProposal,\r\n      AggregatorValidatorInterface proposed\r\n    )\r\n  {\r\n    current = s_currentValidator.target;\r\n    hasProposal = s_currentValidator.hasNewProposal;\r\n    proposed = s_proposedValidator;\r\n  }\r\n\r\n  /**\r\n   * @notice The type and version of this contract\r\n   * @return Type and version string\r\n   */\r\n  function typeAndVersion()\r\n    external\r\n    pure\r\n    virtual\r\n    override\r\n    returns (\r\n      string memory\r\n    )\r\n  {\r\n    return \"ValidatorProxy 1.0.0\";\r\n  }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"validator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"AggregatorProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"AggregatorUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousRoundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"previousAnswer\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentRoundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"currentAnswer\",\"type\":\"int256\"}],\"name\":\"ProposedAggregatorValidateCall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"ValidatorProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"ValidatorUpgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAggregators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasProposal\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getValidators\",\"outputs\":[{\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"current\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasProposal\",\"type\":\"bool\"},{\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"proposed\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"}],\"name\":\"proposeNewAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"proposed\",\"type\":\"address\"}],\"name\":\"proposeNewValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"previousRoundId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"previousAnswer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"currentRoundId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"currentAnswer\",\"type\":\"int256\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ValidatorProxy", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000061eb091ea16a32ea5b880d0b3d09d518c340d75000000000000000000000000061eb091ea16a32ea5b880d0b3d09d518c340d750", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://04006ab1054f7b01fcb0c8dd01856fa6c6c9da9b7f28d52a7150bedb94686c74"}]}