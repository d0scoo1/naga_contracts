{"status": "1", "message": "OK", "result": [{"SourceCode": "/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: migrations/Migration_Saiph.sol\n*\n* Latest source (may be newer): https://github.com/Synthetixio/synthetix/blob/master/contracts/migrations/Migration_Saiph.sol\n* Docs: https://docs.synthetix.io/contracts/migrations/Migration_Saiph\n*\n* Contract Dependencies: \n*\t- BaseMigration\n*\t- ExternStateToken\n*\t- IAddressResolver\n*\t- IERC20\n*\t- IIssuer\n*\t- IRewardEscrow\n*\t- IRewardsDistribution\n*\t- ISynth\n*\t- ISystemStatus\n*\t- LegacyOwned\n*\t- MixinResolver\n*\t- MixinSystemSettings\n*\t- Owned\n*\t- Proxy\n*\t- Proxyable\n*\t- State\n*\t- Synth\n* Libraries: \n*\t- SafeCast\n*\t- SafeDecimalMath\n*\t- SafeMath\n*\t- VestingEntries\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2022 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\n\n\npragma solidity ^0.5.16;\n\n// https://docs.synthetix.io/contracts/source/contracts/owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getSynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iissuer\ninterface IIssuer {\n    // Views\n\n    function allNetworksDebtInfo()\n        external\n        view\n        returns (\n            uint256 debt,\n            uint256 sharesSupply,\n            bool isStale\n        );\n\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function canBurnSynths(address account) external view returns (bool);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsInvalid);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\n\n    function issuanceRatio() external view returns (uint);\n\n    function lastIssueEvent(address account) external view returns (uint);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function minimumStakeTime() external view returns (uint);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint);\n\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsInvalid);\n\n    // Restricted: used internally to Synthetix\n    function addSynths(ISynth[] calldata synthsToAdd) external;\n\n    function issueSynths(address from, uint amount) external;\n\n    function issueSynthsOnBehalf(\n        address issueFor,\n        address from,\n        uint amount\n    ) external;\n\n    function issueMaxSynths(address from) external;\n\n    function issueMaxSynthsOnBehalf(address issueFor, address from) external;\n\n    function burnSynths(address from, uint amount) external;\n\n    function burnSynthsOnBehalf(\n        address burnForAddress,\n        address from,\n        uint amount\n    ) external;\n\n    function burnSynthsToTarget(address from) external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external;\n\n    function burnForRedemption(\n        address deprecatedSynthProxy,\n        address account,\n        uint balance\n    ) external;\n\n    function setCurrentPeriodId(uint128 periodId) external;\n\n    function liquidateAccount(address account, bool isSelfLiquidation)\n        external\n        returns (uint totalRedeemed, uint amountToLiquidate);\n\n    function issueSynthsWithoutDebt(\n        bytes32 currencyKey,\n        address to,\n        uint amount\n    ) external returns (bool rateInvalid);\n\n    function burnSynthsWithoutDebt(\n        bytes32 currencyKey,\n        address to,\n        uint amount\n    ) external returns (bool rateInvalid);\n}\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/mixinresolver\ncontract MixinResolver {\n    AddressResolver public resolver;\n\n    mapping(bytes32 => address) private addressCache;\n\n    constructor(address _resolver) internal {\n        resolver = AddressResolver(_resolver);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\n        internal\n        pure\n        returns (bytes32[] memory combination)\n    {\n        combination = new bytes32[](first.length + second.length);\n\n        for (uint i = 0; i < first.length; i++) {\n            combination[i] = first[i];\n        }\n\n        for (uint j = 0; j < second.length; j++) {\n            combination[first.length + j] = second[j];\n        }\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\n\n    function rebuildCache() public {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        // The resolver must call this function whenver it updates its state\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            address destination =\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\"Resolver missing target: \", name)));\n            addressCache[name] = destination;\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\n        address _foundAddress = addressCache[name];\n        require(_foundAddress != address(0), string(abi.encodePacked(\"Missing address: \", name)));\n        return _foundAddress;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event CacheUpdated(bytes32 name, address destination);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/addressresolver\ncontract AddressResolver is Owned, IAddressResolver {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            repository[name] = destination;\n            emit AddressImported(name, destination);\n        }\n    }\n\n    /* ========= PUBLIC FUNCTIONS ========== */\n\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\n        for (uint i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\n        for (uint i = 0; i < names.length; i++) {\n            if (repository[names[i]] != destinations[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    function getSynth(bytes32 key) external view returns (address) {\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\n        return address(issuer.synths(key));\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AddressImported(bytes32 name, address destination);\n}\n\n\ncontract BaseMigration is Owned {\n    constructor(address _owner) internal Owned(_owner) {}\n\n    // safety value to return ownership (anyone can invoke)\n    function returnOwnership(address forContract) public {\n        bytes memory payload = abi.encodeWithSignature(\"nominateNewOwner(address)\", owner);\n\n        // solhint-disable avoid-low-level-calls\n        (bool success, ) = forContract.call(payload);\n\n        if (!success) {\n            // then try legacy way\n            bytes memory legacyPayload = abi.encodeWithSignature(\"nominateOwner(address)\", owner);\n\n            // solhint-disable avoid-low-level-calls\n            (bool legacySuccess, ) = forContract.call(legacyPayload);\n\n            require(legacySuccess, \"Legacy nomination failed\");\n        }\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iflexiblestorage\ninterface IFlexibleStorage {\n    // Views\n    function getUIntValue(bytes32 contractName, bytes32 record) external view returns (uint);\n\n    function getUIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (uint[] memory);\n\n    function getIntValue(bytes32 contractName, bytes32 record) external view returns (int);\n\n    function getIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (int[] memory);\n\n    function getAddressValue(bytes32 contractName, bytes32 record) external view returns (address);\n\n    function getAddressValues(bytes32 contractName, bytes32[] calldata records) external view returns (address[] memory);\n\n    function getBoolValue(bytes32 contractName, bytes32 record) external view returns (bool);\n\n    function getBoolValues(bytes32 contractName, bytes32[] calldata records) external view returns (bool[] memory);\n\n    function getBytes32Value(bytes32 contractName, bytes32 record) external view returns (bytes32);\n\n    function getBytes32Values(bytes32 contractName, bytes32[] calldata records) external view returns (bytes32[] memory);\n\n    // Mutative functions\n    function deleteUIntValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteIntValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteAddressValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteBoolValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteBytes32Value(bytes32 contractName, bytes32 record) external;\n\n    function setUIntValue(\n        bytes32 contractName,\n        bytes32 record,\n        uint value\n    ) external;\n\n    function setUIntValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        uint[] calldata values\n    ) external;\n\n    function setIntValue(\n        bytes32 contractName,\n        bytes32 record,\n        int value\n    ) external;\n\n    function setIntValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        int[] calldata values\n    ) external;\n\n    function setAddressValue(\n        bytes32 contractName,\n        bytes32 record,\n        address value\n    ) external;\n\n    function setAddressValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        address[] calldata values\n    ) external;\n\n    function setBoolValue(\n        bytes32 contractName,\n        bytes32 record,\n        bool value\n    ) external;\n\n    function setBoolValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        bool[] calldata values\n    ) external;\n\n    function setBytes32Value(\n        bytes32 contractName,\n        bytes32 record,\n        bytes32 value\n    ) external;\n\n    function setBytes32Values(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        bytes32[] calldata values\n    ) external;\n}\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/mixinsystemsettings\ncontract MixinSystemSettings is MixinResolver {\n    // must match the one defined SystemSettingsLib, defined in both places due to sol v0.5 limitations\n    bytes32 internal constant SETTING_CONTRACT_NAME = \"SystemSettings\";\n\n    bytes32 internal constant SETTING_WAITING_PERIOD_SECS = \"waitingPeriodSecs\";\n    bytes32 internal constant SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR = \"priceDeviationThresholdFactor\";\n    bytes32 internal constant SETTING_ISSUANCE_RATIO = \"issuanceRatio\";\n    bytes32 internal constant SETTING_FEE_PERIOD_DURATION = \"feePeriodDuration\";\n    bytes32 internal constant SETTING_TARGET_THRESHOLD = \"targetThreshold\";\n    bytes32 internal constant SETTING_LIQUIDATION_DELAY = \"liquidationDelay\";\n    bytes32 internal constant SETTING_LIQUIDATION_RATIO = \"liquidationRatio\";\n    bytes32 internal constant SETTING_LIQUIDATION_ESCROW_DURATION = \"liquidationEscrowDuration\";\n    bytes32 internal constant SETTING_LIQUIDATION_PENALTY = \"liquidationPenalty\";\n    bytes32 internal constant SETTING_SELF_LIQUIDATION_PENALTY = \"selfLiquidationPenalty\";\n    bytes32 internal constant SETTING_FLAG_REWARD = \"flagReward\";\n    bytes32 internal constant SETTING_LIQUIDATE_REWARD = \"liquidateReward\";\n    bytes32 internal constant SETTING_RATE_STALE_PERIOD = \"rateStalePeriod\";\n    /* ========== Exchange Fees Related ========== */\n    bytes32 internal constant SETTING_EXCHANGE_FEE_RATE = \"exchangeFeeRate\";\n    bytes32 internal constant SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD = \"exchangeDynamicFeeThreshold\";\n    bytes32 internal constant SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY = \"exchangeDynamicFeeWeightDecay\";\n    bytes32 internal constant SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS = \"exchangeDynamicFeeRounds\";\n    bytes32 internal constant SETTING_EXCHANGE_MAX_DYNAMIC_FEE = \"exchangeMaxDynamicFee\";\n    /* ========== End Exchange Fees Related ========== */\n    bytes32 internal constant SETTING_MINIMUM_STAKE_TIME = \"minimumStakeTime\";\n    bytes32 internal constant SETTING_AGGREGATOR_WARNING_FLAGS = \"aggregatorWarningFlags\";\n    bytes32 internal constant SETTING_TRADING_REWARDS_ENABLED = \"tradingRewardsEnabled\";\n    bytes32 internal constant SETTING_DEBT_SNAPSHOT_STALE_TIME = \"debtSnapshotStaleTime\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT = \"crossDomainDepositGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT = \"crossDomainEscrowGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT = \"crossDomainRewardGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT = \"crossDomainWithdrawalGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_FEE_PERIOD_CLOSE_GAS_LIMIT = \"crossDomainCloseGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT = \"crossDomainRelayGasLimit\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MAX_ETH = \"etherWrapperMaxETH\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MINT_FEE_RATE = \"etherWrapperMintFeeRate\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_BURN_FEE_RATE = \"etherWrapperBurnFeeRate\";\n    bytes32 internal constant SETTING_WRAPPER_MAX_TOKEN_AMOUNT = \"wrapperMaxTokens\";\n    bytes32 internal constant SETTING_WRAPPER_MINT_FEE_RATE = \"wrapperMintFeeRate\";\n    bytes32 internal constant SETTING_WRAPPER_BURN_FEE_RATE = \"wrapperBurnFeeRate\";\n    bytes32 internal constant SETTING_INTERACTION_DELAY = \"interactionDelay\";\n    bytes32 internal constant SETTING_COLLAPSE_FEE_RATE = \"collapseFeeRate\";\n    bytes32 internal constant SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK = \"atomicMaxVolumePerBlock\";\n    bytes32 internal constant SETTING_ATOMIC_TWAP_WINDOW = \"atomicTwapWindow\";\n    bytes32 internal constant SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING = \"atomicEquivalentForDexPricing\";\n    bytes32 internal constant SETTING_ATOMIC_EXCHANGE_FEE_RATE = \"atomicExchangeFeeRate\";\n    bytes32 internal constant SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = \"atomicVolConsiderationWindow\";\n    bytes32 internal constant SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD = \"atomicVolUpdateThreshold\";\n    bytes32 internal constant SETTING_PURE_CHAINLINK_PRICE_FOR_ATOMIC_SWAPS_ENABLED = \"pureChainlinkForAtomicsEnabled\";\n    bytes32 internal constant SETTING_CROSS_SYNTH_TRANSFER_ENABLED = \"crossChainSynthTransferEnabled\";\n\n    bytes32 internal constant CONTRACT_FLEXIBLESTORAGE = \"FlexibleStorage\";\n\n    enum CrossDomainMessageGasLimits {Deposit, Escrow, Reward, Withdrawal, CloseFeePeriod, Relay}\n\n    struct DynamicFeeConfig {\n        uint threshold;\n        uint weightDecay;\n        uint rounds;\n        uint maxFee;\n    }\n\n    constructor(address _resolver) internal MixinResolver(_resolver) {}\n\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        addresses = new bytes32[](1);\n        addresses[0] = CONTRACT_FLEXIBLESTORAGE;\n    }\n\n    function flexibleStorage() internal view returns (IFlexibleStorage) {\n        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));\n    }\n\n    function _getGasLimitSetting(CrossDomainMessageGasLimits gasLimitType) internal pure returns (bytes32) {\n        if (gasLimitType == CrossDomainMessageGasLimits.Deposit) {\n            return SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Escrow) {\n            return SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Reward) {\n            return SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Withdrawal) {\n            return SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Relay) {\n            return SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.CloseFeePeriod) {\n            return SETTING_CROSS_DOMAIN_FEE_PERIOD_CLOSE_GAS_LIMIT;\n        } else {\n            revert(\"Unknown gas limit type\");\n        }\n    }\n\n    function getCrossDomainMessageGasLimit(CrossDomainMessageGasLimits gasLimitType) internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, _getGasLimitSetting(gasLimitType));\n    }\n\n    function getTradingRewardsEnabled() internal view returns (bool) {\n        return flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME, SETTING_TRADING_REWARDS_ENABLED);\n    }\n\n    function getWaitingPeriodSecs() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_WAITING_PERIOD_SECS);\n    }\n\n    function getPriceDeviationThresholdFactor() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR);\n    }\n\n    function getIssuanceRatio() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ISSUANCE_RATIO);\n    }\n\n    function getFeePeriodDuration() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_FEE_PERIOD_DURATION);\n    }\n\n    function getTargetThreshold() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_TARGET_THRESHOLD);\n    }\n\n    function getLiquidationDelay() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_DELAY);\n    }\n\n    function getLiquidationRatio() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_RATIO);\n    }\n\n    function getLiquidationEscrowDuration() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_ESCROW_DURATION);\n    }\n\n    function getLiquidationPenalty() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_PENALTY);\n    }\n\n    function getSelfLiquidationPenalty() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_SELF_LIQUIDATION_PENALTY);\n    }\n\n    function getFlagReward() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_FLAG_REWARD);\n    }\n\n    function getLiquidateReward() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATE_REWARD);\n    }\n\n    function getRateStalePeriod() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_RATE_STALE_PERIOD);\n    }\n\n    /* ========== Exchange Related Fees ========== */\n    function getExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE, currencyKey))\n            );\n    }\n\n    /// @notice Get exchange dynamic fee related keys\n    /// @return threshold, weight decay, rounds, and max fee\n    function getExchangeDynamicFeeConfig() internal view returns (DynamicFeeConfig memory) {\n        bytes32[] memory keys = new bytes32[](4);\n        keys[0] = SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD;\n        keys[1] = SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY;\n        keys[2] = SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS;\n        keys[3] = SETTING_EXCHANGE_MAX_DYNAMIC_FEE;\n        uint[] memory values = flexibleStorage().getUIntValues(SETTING_CONTRACT_NAME, keys);\n        return DynamicFeeConfig({threshold: values[0], weightDecay: values[1], rounds: values[2], maxFee: values[3]});\n    }\n\n    /* ========== End Exchange Related Fees ========== */\n\n    function getMinimumStakeTime() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MINIMUM_STAKE_TIME);\n    }\n\n    function getAggregatorWarningFlags() internal view returns (address) {\n        return flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME, SETTING_AGGREGATOR_WARNING_FLAGS);\n    }\n\n    function getDebtSnapshotStaleTime() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_DEBT_SNAPSHOT_STALE_TIME);\n    }\n\n    function getEtherWrapperMaxETH() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MAX_ETH);\n    }\n\n    function getEtherWrapperMintFeeRate() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MINT_FEE_RATE);\n    }\n\n    function getEtherWrapperBurnFeeRate() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_BURN_FEE_RATE);\n    }\n\n    function getWrapperMaxTokenAmount(address wrapper) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_WRAPPER_MAX_TOKEN_AMOUNT, wrapper))\n            );\n    }\n\n    function getWrapperMintFeeRate(address wrapper) internal view returns (int) {\n        return\n            flexibleStorage().getIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_WRAPPER_MINT_FEE_RATE, wrapper))\n            );\n    }\n\n    function getWrapperBurnFeeRate(address wrapper) internal view returns (int) {\n        return\n            flexibleStorage().getIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_WRAPPER_BURN_FEE_RATE, wrapper))\n            );\n    }\n\n    function getInteractionDelay(address collateral) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_INTERACTION_DELAY, collateral))\n            );\n    }\n\n    function getCollapseFeeRate(address collateral) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_COLLAPSE_FEE_RATE, collateral))\n            );\n    }\n\n    function getAtomicMaxVolumePerBlock() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK);\n    }\n\n    function getAtomicTwapWindow() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_TWAP_WINDOW);\n    }\n\n    function getAtomicEquivalentForDexPricing(bytes32 currencyKey) internal view returns (address) {\n        return\n            flexibleStorage().getAddressValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING, currencyKey))\n            );\n    }\n\n    function getAtomicExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_EXCHANGE_FEE_RATE, currencyKey))\n            );\n    }\n\n    function getAtomicVolatilityConsiderationWindow(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW, currencyKey))\n            );\n    }\n\n    function getAtomicVolatilityUpdateThreshold(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD, currencyKey))\n            );\n    }\n\n    function getPureChainlinkPriceForAtomicSwapsEnabled(bytes32 currencyKey) internal view returns (bool) {\n        return\n            flexibleStorage().getBoolValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_PURE_CHAINLINK_PRICE_FOR_ATOMIC_SWAPS_ENABLED, currencyKey))\n            );\n    }\n\n    function getCrossChainSynthTransferEnabled(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_CROSS_SYNTH_TRANSFER_ENABLED, currencyKey))\n            );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\n\n/**\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n// Libraries\n\n\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    // Computes `a - b`, setting the value to 0 if b > a.\n    function floorsub(uint a, uint b) internal pure returns (uint) {\n        return b >= a ? 0 : a - b;\n    }\n\n    /* ---------- Utilities ---------- */\n    /*\n     * Absolute value of the input, returned as a signed number.\n     */\n    function signedAbs(int x) internal pure returns (int) {\n        return x < 0 ? -x : x;\n    }\n\n    /*\n     * Absolute value of the input, returned as an unsigned number.\n     */\n    function abs(int x) internal pure returns (uint) {\n        return uint(signedAbs(x));\n    }\n}\n\n\ninterface IVirtualSynth {\n    // Views\n    function balanceOfUnderlying(address account) external view returns (uint);\n\n    function rate() external view returns (uint);\n\n    function readyToSettle() external view returns (bool);\n\n    function secsLeftInWaitingPeriod() external view returns (uint);\n\n    function settled() external view returns (bool);\n\n    function synth() external view returns (ISynth);\n\n    // Mutative functions\n    function settle(address account) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetix\ninterface ISynthetix {\n    // Views\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\n\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);\n\n    function totalIssuedSynthsExcludeOtherCollateral(bytes32 currencyKey) external view returns (uint);\n\n    function transferableSynthetix(address account) external view returns (uint transferable);\n\n    // Mutative Functions\n    function burnSynths(uint amount) external;\n\n    function burnSynthsOnBehalf(address burnForAddress, uint amount) external;\n\n    function burnSynthsToTarget() external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\n\n    function exchange(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalf(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeWithTracking(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeWithTrackingForInitiator(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalfWithTracking(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeWithVirtual(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\n\n    function exchangeAtomically(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        bytes32 trackingCode,\n        uint minAmount\n    ) external returns (uint amountReceived);\n\n    function issueMaxSynths() external;\n\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\n\n    function issueSynths(uint amount) external;\n\n    function issueSynthsOnBehalf(address issueForAddress, uint amount) external;\n\n    function mint() external returns (bool);\n\n    function settle(bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntries\n        );\n\n    // Liquidations\n    function liquidateDelinquentAccount(address account) external returns (bool);\n\n    function liquidateSelf() external returns (bool);\n\n    // Restricted Functions\n\n    function mintSecondary(address account, uint amount) external;\n\n    function mintSecondaryRewards(uint amount) external;\n\n    function burnSecondary(address account, uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ifeepool\ninterface IFeePool {\n    // Views\n\n    // solhint-disable-next-line func-name-mixedcase\n    function FEE_ADDRESS() external view returns (address);\n\n    function feesAvailable(address account) external view returns (uint, uint);\n\n    function feePeriodDuration() external view returns (uint);\n\n    function isFeesClaimable(address account) external view returns (bool);\n\n    function targetThreshold() external view returns (uint);\n\n    function totalFeesAvailable() external view returns (uint);\n\n    function totalRewardsAvailable() external view returns (uint);\n\n    // Mutative Functions\n    function claimFees() external returns (bool);\n\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\n\n    function closeCurrentFeePeriod() external;\n\n    function closeSecondary(uint snxBackedDebt, uint debtShareSupply) external;\n\n    function recordFeePaid(uint sUSDAmount) external;\n\n    function setRewardsToDistribute(uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetixdebtshare\ninterface ISynthetixDebtShare {\n    // Views\n\n    function currentPeriodId() external view returns (uint128);\n\n    function allowance(address account, address spender) external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function balanceOfOnPeriod(address account, uint periodId) external view returns (uint);\n\n    function totalSupply() external view returns (uint);\n\n    function sharePercent(address account) external view returns (uint);\n\n    function sharePercentOnPeriod(address account, uint periodId) external view returns (uint);\n\n    // Mutative functions\n\n    function takeSnapshot(uint128 id) external;\n\n    function mintShare(address account, uint256 amount) external;\n\n    function burnShare(address account, uint256 amount) external;\n\n    function approve(address, uint256) external pure returns (bool);\n\n    function transfer(address to, uint256 amount) external pure returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function addAuthorizedBroker(address target) external;\n\n    function removeAuthorizedBroker(address target) external;\n\n    function addAuthorizedToSnapshot(address target) external;\n\n    function removeAuthorizedToSnapshot(address target) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchanger\ninterface IExchanger {\n    struct ExchangeEntrySettlement {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint reclaim;\n        uint rebate;\n        uint srcRoundIdAtPeriodEnd;\n        uint destRoundIdAtPeriodEnd;\n        uint timestamp;\n    }\n\n    struct ExchangeEntry {\n        uint sourceRate;\n        uint destinationRate;\n        uint destinationAmount;\n        uint exchangeFeeRate;\n        uint exchangeDynamicFeeRate;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    // Views\n    function calculateAmountAfterSettlement(\n        address from,\n        bytes32 currencyKey,\n        uint amount,\n        uint refunded\n    ) external view returns (uint amountAfterSettlement);\n\n    function isSynthRateInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function maxSecsLeftInWaitingPeriod(address account, bytes32 currencyKey) external view returns (uint);\n\n    function settlementOwing(address account, bytes32 currencyKey)\n        external\n        view\n        returns (\n            uint reclaimAmount,\n            uint rebateAmount,\n            uint numEntries\n        );\n\n    function hasWaitingPeriodOrSettlementOwing(address account, bytes32 currencyKey) external view returns (bool);\n\n    function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view returns (uint);\n\n    function dynamicFeeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\n        external\n        view\n        returns (uint feeRate, bool tooVolatile);\n\n    function getAmountsForExchange(\n        uint sourceAmount,\n        bytes32 sourceCurrencyKey,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint amountReceived,\n            uint fee,\n            uint exchangeFeeRate\n        );\n\n    function priceDeviationThresholdFactor() external view returns (uint);\n\n    function waitingPeriodSecs() external view returns (uint);\n\n    function lastExchangeRate(bytes32 currencyKey) external view returns (uint);\n\n    // Mutative functions\n    function exchange(\n        address exchangeForAddress,\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bool virtualSynth,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\n\n    function exchangeAtomically(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bytes32 trackingCode,\n        uint minAmount\n    ) external returns (uint amountReceived);\n\n    function settle(address from, bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntries\n        );\n\n    function suspendSynthWithInvalidRate(bytes32 currencyKey) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/idelegateapprovals\ninterface IDelegateApprovals {\n    // Views\n    function canBurnFor(address authoriser, address delegate) external view returns (bool);\n\n    function canIssueFor(address authoriser, address delegate) external view returns (bool);\n\n    function canClaimFor(address authoriser, address delegate) external view returns (bool);\n\n    function canExchangeFor(address authoriser, address delegate) external view returns (bool);\n\n    // Mutative\n    function approveAllDelegatePowers(address delegate) external;\n\n    function removeAllDelegatePowers(address delegate) external;\n\n    function approveBurnOnBehalf(address delegate) external;\n\n    function removeBurnOnBehalf(address delegate) external;\n\n    function approveIssueOnBehalf(address delegate) external;\n\n    function removeIssueOnBehalf(address delegate) external;\n\n    function approveClaimOnBehalf(address delegate) external;\n\n    function removeClaimOnBehalf(address delegate) external;\n\n    function approveExchangeOnBehalf(address delegate) external;\n\n    function removeExchangeOnBehalf(address delegate) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\ninterface IExchangeRates {\n    // Structs\n    struct RateAndUpdatedTime {\n        uint216 rate;\n        uint40 time;\n    }\n\n    // Views\n    function aggregators(bytes32 currencyKey) external view returns (address);\n\n    function aggregatorWarningFlags() external view returns (address);\n\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\n\n    function anyRateIsInvalidAtRound(bytes32[] calldata currencyKeys, uint[] calldata roundIds) external view returns (bool);\n\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\n\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value);\n\n    function effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveValueAndRatesAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveAtomicValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint systemValue,\n            uint systemSourceRate,\n            uint systemDestinationRate\n        );\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint);\n\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\n\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\n\n    function rateStalePeriod() external view returns (uint);\n\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(\n        bytes32 currencyKey,\n        uint numRounds,\n        uint roundId\n    ) external view returns (uint[] memory rates, uint[] memory times);\n\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (uint[] memory rates, bool anyRateInvalid);\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\n\n    function synthTooVolatileForAtomicExchange(bytes32 currencyKey) external view returns (bool);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ihasbalance\ninterface IHasBalance {\n    // Views\n    function balanceOf(address account) external view returns (uint);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ierc20\ninterface IERC20 {\n    // ERC20 Optional Views\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    // Views\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    // Mutative functions\n    function transfer(address to, uint value) external returns (bool);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\ninterface ILiquidator {\n    // Views\n    function issuanceRatio() external view returns (uint);\n\n    function liquidationDelay() external view returns (uint);\n\n    function liquidationRatio() external view returns (uint);\n\n    function liquidationEscrowDuration() external view returns (uint);\n\n    function liquidationPenalty() external view returns (uint);\n\n    function selfLiquidationPenalty() external view returns (uint);\n\n    function liquidateReward() external view returns (uint);\n\n    function flagReward() external view returns (uint);\n\n    function liquidationCollateralRatio() external view returns (uint);\n\n    function getLiquidationDeadlineForAccount(address account) external view returns (uint);\n\n    function getLiquidationCallerForAccount(address account) external view returns (address);\n\n    function isLiquidationOpen(address account, bool isSelfLiquidation) external view returns (bool);\n\n    function isLiquidationDeadlinePassed(address account) external view returns (bool);\n\n    function calculateAmountToFixCollateral(\n        uint debtBalance,\n        uint collateral,\n        uint penalty\n    ) external view returns (uint);\n\n    // Mutative Functions\n    function flagAccountForLiquidation(address account) external;\n\n    // Restricted: used internally to Synthetix contracts\n    function removeAccountInLiquidation(address account) external;\n\n    function checkAndRemoveAccountInLiquidation(address account) external;\n}\n\n\ninterface ILiquidatorRewards {\n    // Views\n\n    function earned(address account) external view returns (uint256);\n\n    // Mutative\n\n    function getReward(address account) external;\n\n    function notifyRewardAmount(uint256 reward) external;\n\n    function updateEntry(address account) external;\n}\n\n\ninterface ICollateralManager {\n    // Manager information\n    function hasCollateral(address collateral) external view returns (bool);\n\n    function isSynthManaged(bytes32 currencyKey) external view returns (bool);\n\n    // State information\n    function long(bytes32 synth) external view returns (uint amount);\n\n    function short(bytes32 synth) external view returns (uint amount);\n\n    function totalLong() external view returns (uint susdValue, bool anyRateIsInvalid);\n\n    function totalShort() external view returns (uint susdValue, bool anyRateIsInvalid);\n\n    function getBorrowRate() external view returns (uint borrowRate, bool anyRateIsInvalid);\n\n    function getShortRate(bytes32 synth) external view returns (uint shortRate, bool rateIsInvalid);\n\n    function getRatesAndTime(uint index)\n        external\n        view\n        returns (\n            uint entryRate,\n            uint lastRate,\n            uint lastUpdated,\n            uint newIndex\n        );\n\n    function getShortRatesAndTime(bytes32 currency, uint index)\n        external\n        view\n        returns (\n            uint entryRate,\n            uint lastRate,\n            uint lastUpdated,\n            uint newIndex\n        );\n\n    function exceedsDebtLimit(uint amount, bytes32 currency) external view returns (bool canIssue, bool anyRateIsInvalid);\n\n    function areSynthsAndCurrenciesSet(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys)\n        external\n        view\n        returns (bool);\n\n    function areShortableSynthsSet(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys)\n        external\n        view\n        returns (bool);\n\n    // Loans\n    function getNewLoanId() external returns (uint id);\n\n    // Manager mutative\n    function addCollaterals(address[] calldata collaterals) external;\n\n    function removeCollaterals(address[] calldata collaterals) external;\n\n    function addSynths(bytes32[] calldata synthNamesInResolver, bytes32[] calldata synthKeys) external;\n\n    function removeSynths(bytes32[] calldata synths, bytes32[] calldata synthKeys) external;\n\n    function addShortableSynths(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys) external;\n\n    function removeShortableSynths(bytes32[] calldata synths) external;\n\n    // State mutative\n\n    function incrementLongs(bytes32 synth, uint amount) external;\n\n    function decrementLongs(bytes32 synth, uint amount) external;\n\n    function incrementShorts(bytes32 synth, uint amount) external;\n\n    function decrementShorts(bytes32 synth, uint amount) external;\n\n    function accrueInterest(\n        uint interestIndex,\n        bytes32 currency,\n        bool isShort\n    ) external returns (uint difference, uint index);\n\n    function updateBorrowRatesCollateral(uint rate) external;\n\n    function updateShortRatesCollateral(bytes32 currency, uint rate) external;\n}\n\n\npragma experimental ABIEncoderV2;\n\nlibrary VestingEntries {\n    struct VestingEntry {\n        uint64 endTime;\n        uint256 escrowAmount;\n    }\n    struct VestingEntryWithID {\n        uint64 endTime;\n        uint256 escrowAmount;\n        uint256 entryID;\n    }\n}\n\ninterface IRewardEscrowV2 {\n    // Views\n    function balanceOf(address account) external view returns (uint);\n\n    function numVestingEntries(address account) external view returns (uint);\n\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\n\n    function totalVestedAccountBalance(address account) external view returns (uint);\n\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint);\n\n    function getVestingSchedules(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory);\n\n    function getAccountVestingEntryIDs(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (uint256[] memory);\n\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint);\n\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64, uint256);\n\n    // Mutative functions\n    function vest(uint256[] calldata entryIDs) external;\n\n    function createEscrowEntry(\n        address beneficiary,\n        uint256 deposit,\n        uint256 duration\n    ) external;\n\n    function appendVestingEntry(\n        address account,\n        uint256 quantity,\n        uint256 duration\n    ) external;\n\n    function migrateVestingSchedule(address _addressToMigrate) external;\n\n    function migrateAccountEscrowBalances(\n        address[] calldata accounts,\n        uint256[] calldata escrowBalances,\n        uint256[] calldata vestedBalances\n    ) external;\n\n    // Account Merging\n    function startMergingWindow() external;\n\n    function mergeAccount(address accountToMerge, uint256[] calldata entryIDs) external;\n\n    function nominateAccountToMerge(address account) external;\n\n    function accountMergingIsOpen() external view returns (bool);\n\n    // L2 Migration\n    function importVestingEntries(\n        address account,\n        uint256 escrowedAmount,\n        VestingEntries.VestingEntry[] calldata vestingEntries\n    ) external;\n\n    // Return amount of SNX transfered to SynthetixBridgeToOptimism deposit contract\n    function burnForMigration(address account, uint256[] calldata entryIDs)\n        external\n        returns (uint256 escrowedAccountBalance, VestingEntries.VestingEntry[] memory vestingEntries);\n}\n\n\ninterface ISynthRedeemer {\n    // Rate of redemption - 0 for none\n    function redemptions(address synthProxy) external view returns (uint redeemRate);\n\n    // sUSD balance of deprecated token holder\n    function balanceOf(IERC20 synthProxy, address account) external view returns (uint balanceOfInsUSD);\n\n    // Full sUSD supply of token\n    function totalSupply(IERC20 synthProxy) external view returns (uint totalSupplyInsUSD);\n\n    function redeem(IERC20 synthProxy) external;\n\n    function redeemAll(IERC20[] calldata synthProxies) external;\n\n    function redeemPartial(IERC20 synthProxy, uint amountOfSynth) external;\n\n    // Restricted to Issuer\n    function deprecate(IERC20 synthProxy, uint rateToRedeem) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isystemstatus\ninterface ISystemStatus {\n    struct Status {\n        bool canSuspend;\n        bool canResume;\n    }\n\n    struct Suspension {\n        bool suspended;\n        // reason is an integer code,\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\n        uint248 reason;\n    }\n\n    // Views\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\n\n    function requireSystemActive() external view;\n\n    function systemSuspended() external view returns (bool);\n\n    function requireIssuanceActive() external view;\n\n    function requireExchangeActive() external view;\n\n    function requireFuturesActive() external view;\n\n    function requireFuturesMarketActive(bytes32 marketKey) external view;\n\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function requireSynthActive(bytes32 currencyKey) external view;\n\n    function synthSuspended(bytes32 currencyKey) external view returns (bool);\n\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function systemSuspension() external view returns (bool suspended, uint248 reason);\n\n    function issuanceSuspension() external view returns (bool suspended, uint248 reason);\n\n    function exchangeSuspension() external view returns (bool suspended, uint248 reason);\n\n    function futuresSuspension() external view returns (bool suspended, uint248 reason);\n\n    function synthExchangeSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function synthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function futuresMarketSuspension(bytes32 marketKey) external view returns (bool suspended, uint248 reason);\n\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons);\n\n    function getSynthSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons);\n\n    function getFuturesMarketSuspensions(bytes32[] calldata marketKeys)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons);\n\n    // Restricted functions\n    function suspendIssuance(uint256 reason) external;\n\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external;\n\n    function suspendFuturesMarket(bytes32 marketKey, uint256 reason) external;\n\n    function updateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) external;\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/proxy\ncontract Proxy is Owned {\n    Proxyable public target;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    function setTarget(Proxyable _target) external onlyOwner {\n        target = _target;\n        emit TargetUpdated(_target);\n    }\n\n    function _emit(\n        bytes calldata callData,\n        uint numTopics,\n        bytes32 topic1,\n        bytes32 topic2,\n        bytes32 topic3,\n        bytes32 topic4\n    ) external onlyTarget {\n        uint size = callData.length;\n        bytes memory _callData = callData;\n\n        assembly {\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\n             * This means moving call_data across 32 bytes guarantees we correctly access\n             * the data itself. */\n            switch numTopics\n                case 0 {\n                    log0(add(_callData, 32), size)\n                }\n                case 1 {\n                    log1(add(_callData, 32), size, topic1)\n                }\n                case 2 {\n                    log2(add(_callData, 32), size, topic1, topic2)\n                }\n                case 3 {\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\n                }\n                case 4 {\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\n                }\n        }\n    }\n\n    // solhint-disable no-complex-fallback\n    function() external payable {\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\n        target.setMessageSender(msg.sender);\n\n        assembly {\n            let free_ptr := mload(0x40)\n            calldatacopy(free_ptr, 0, calldatasize)\n\n            /* We must explicitly forward ether to the underlying contract as well. */\n            let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n            returndatacopy(free_ptr, 0, returndatasize)\n\n            if iszero(result) {\n                revert(free_ptr, returndatasize)\n            }\n            return(free_ptr, returndatasize)\n        }\n    }\n\n    modifier onlyTarget {\n        require(Proxyable(msg.sender) == target, \"Must be proxy target\");\n        _;\n    }\n\n    event TargetUpdated(Proxyable newTarget);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/proxyable\ncontract Proxyable is Owned {\n    // This contract should be treated like an abstract contract\n\n    /* The proxy this contract exists behind. */\n    Proxy public proxy;\n\n    /* The caller of the proxy, passed through to this contract.\n     * Note that every function using this member must apply the onlyProxy or\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\n    address public messageSender;\n\n    constructor(address payable _proxy) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setProxy(address payable _proxy) external onlyOwner {\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setMessageSender(address sender) external onlyProxy {\n        messageSender = sender;\n    }\n\n    modifier onlyProxy {\n        _onlyProxy();\n        _;\n    }\n\n    function _onlyProxy() private view {\n        require(Proxy(msg.sender) == proxy, \"Only the proxy can call\");\n    }\n\n    modifier optionalProxy {\n        _optionalProxy();\n        _;\n    }\n\n    function _optionalProxy() private {\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n    }\n\n    modifier optionalProxy_onlyOwner {\n        _optionalProxy_onlyOwner();\n        _;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function _optionalProxy_onlyOwner() private {\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n        require(messageSender == owner, \"Owner only function\");\n    }\n\n    event ProxyUpdated(address proxyAddress);\n}\n\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n\n\n/**\n * @title The V2 & V3 Aggregator Interface\n * @notice Solidity V0.5 does not allow interfaces to inherit from other\n * interfaces so this contract is a combination of v0.5 AggregatorInterface.sol\n * and v0.5 AggregatorV3Interface.sol.\n */\ninterface AggregatorV2V3Interface {\n  //\n  // V2 Interface:\n  //\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n\n  //\n  // V3 Interface:\n  //\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\ninterface IProxy {\n    function target() external view returns (address);\n}\n\ninterface IIssuerInternalDebtCache {\n    function updateCachedSynthDebtWithRate(bytes32 currencyKey, uint currencyRate) external;\n\n    function updateCachedSynthDebtsWithRates(bytes32[] calldata currencyKeys, uint[] calldata currencyRates) external;\n\n    function updateDebtCacheValidity(bool currentlyInvalid) external;\n\n    function totalNonSnxBackedDebt() external view returns (uint excludedDebt, bool isInvalid);\n\n    function cacheInfo()\n        external\n        view\n        returns (\n            uint cachedDebt,\n            uint timestamp,\n            bool isInvalid,\n            bool isStale\n        );\n\n    function updateCachedsUSDDebt(int amount) external;\n}\n\n// https://docs.synthetix.io/contracts/source/contracts/issuer\ncontract Issuer is Owned, MixinSystemSettings, IIssuer {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    bytes32 public constant CONTRACT_NAME = \"Issuer\";\n\n    // SIP-165: Circuit breaker for Debt Synthesis\n    uint public constant CIRCUIT_BREAKER_SUSPENSION_REASON = 165;\n\n    // Available Synths which can be used with the system\n    ISynth[] public availableSynths;\n    mapping(bytes32 => ISynth) public synths;\n    mapping(address => bytes32) public synthsByAddress;\n\n    uint public lastDebtRatio;\n\n    /* ========== ENCODED NAMES ========== */\n\n    bytes32 internal constant sUSD = \"sUSD\";\n    bytes32 internal constant sETH = \"sETH\";\n    bytes32 internal constant SNX = \"SNX\";\n\n    // Flexible storage names\n\n    bytes32 internal constant LAST_ISSUE_EVENT = \"lastIssueEvent\";\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_SYNTHETIX = \"Synthetix\";\n    bytes32 private constant CONTRACT_EXCHANGER = \"Exchanger\";\n    bytes32 private constant CONTRACT_EXRATES = \"ExchangeRates\";\n    bytes32 private constant CONTRACT_SYNTHETIXDEBTSHARE = \"SynthetixDebtShare\";\n    bytes32 private constant CONTRACT_FEEPOOL = \"FeePool\";\n    bytes32 private constant CONTRACT_DELEGATEAPPROVALS = \"DelegateApprovals\";\n    bytes32 private constant CONTRACT_REWARDESCROW_V2 = \"RewardEscrowV2\";\n    bytes32 private constant CONTRACT_SYNTHETIXESCROW = \"SynthetixEscrow\";\n    bytes32 private constant CONTRACT_LIQUIDATOR = \"Liquidator\";\n    bytes32 private constant CONTRACT_LIQUIDATOR_REWARDS = \"LiquidatorRewards\";\n    bytes32 private constant CONTRACT_DEBTCACHE = \"DebtCache\";\n    bytes32 private constant CONTRACT_SYNTHREDEEMER = \"SynthRedeemer\";\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\n    bytes32 private constant CONTRACT_SYNTHETIXBRIDGETOOPTIMISM = \"SynthetixBridgeToOptimism\";\n    bytes32 private constant CONTRACT_SYNTHETIXBRIDGETOBASE = \"SynthetixBridgeToBase\";\n\n    bytes32 private constant CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS = \"ext:AggregatorIssuedSynths\";\n    bytes32 private constant CONTRACT_EXT_AGGREGATOR_DEBT_RATIO = \"ext:AggregatorDebtRatio\";\n\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {}\n\n    /* ========== VIEWS ========== */\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();\n        bytes32[] memory newAddresses = new bytes32[](15);\n        newAddresses[0] = CONTRACT_SYNTHETIX;\n        newAddresses[1] = CONTRACT_EXCHANGER;\n        newAddresses[2] = CONTRACT_EXRATES;\n        newAddresses[3] = CONTRACT_SYNTHETIXDEBTSHARE;\n        newAddresses[4] = CONTRACT_FEEPOOL;\n        newAddresses[5] = CONTRACT_DELEGATEAPPROVALS;\n        newAddresses[6] = CONTRACT_REWARDESCROW_V2;\n        newAddresses[7] = CONTRACT_SYNTHETIXESCROW;\n        newAddresses[8] = CONTRACT_LIQUIDATOR;\n        newAddresses[9] = CONTRACT_LIQUIDATOR_REWARDS;\n        newAddresses[10] = CONTRACT_DEBTCACHE;\n        newAddresses[11] = CONTRACT_SYNTHREDEEMER;\n        newAddresses[12] = CONTRACT_SYSTEMSTATUS;\n        newAddresses[13] = CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS;\n        newAddresses[14] = CONTRACT_EXT_AGGREGATOR_DEBT_RATIO;\n        return combineArrays(existingAddresses, newAddresses);\n    }\n\n    function synthetix() internal view returns (ISynthetix) {\n        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));\n    }\n\n    function exchanger() internal view returns (IExchanger) {\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\n    }\n\n    function exchangeRates() internal view returns (IExchangeRates) {\n        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));\n    }\n\n    function synthetixDebtShare() internal view returns (ISynthetixDebtShare) {\n        return ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE));\n    }\n\n    function feePool() internal view returns (IFeePool) {\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));\n    }\n\n    function liquidator() internal view returns (ILiquidator) {\n        return ILiquidator(requireAndGetAddress(CONTRACT_LIQUIDATOR));\n    }\n\n    function liquidatorRewards() internal view returns (ILiquidatorRewards) {\n        return ILiquidatorRewards(requireAndGetAddress(CONTRACT_LIQUIDATOR_REWARDS));\n    }\n\n    function delegateApprovals() internal view returns (IDelegateApprovals) {\n        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));\n    }\n\n    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {\n        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));\n    }\n\n    function synthetixEscrow() internal view returns (IHasBalance) {\n        return IHasBalance(requireAndGetAddress(CONTRACT_SYNTHETIXESCROW));\n    }\n\n    function debtCache() internal view returns (IIssuerInternalDebtCache) {\n        return IIssuerInternalDebtCache(requireAndGetAddress(CONTRACT_DEBTCACHE));\n    }\n\n    function synthRedeemer() internal view returns (ISynthRedeemer) {\n        return ISynthRedeemer(requireAndGetAddress(CONTRACT_SYNTHREDEEMER));\n    }\n\n    function systemStatus() internal view returns (ISystemStatus) {\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\n    }\n\n    function allNetworksDebtInfo()\n        public\n        view\n        returns (\n            uint256 debt,\n            uint256 sharesSupply,\n            bool isStale\n        )\n    {\n        (, int256 rawIssuedSynths, , uint issuedSynthsUpdatedAt, ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS)).latestRoundData();\n\n        (, int256 rawRatio, , uint ratioUpdatedAt, ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_DEBT_RATIO)).latestRoundData();\n\n        debt = uint(rawIssuedSynths);\n        sharesSupply = rawRatio == 0 ? 0 : debt.divideDecimalRoundPrecise(uint(rawRatio));\n        isStale =\n            block.timestamp - getRateStalePeriod() > issuedSynthsUpdatedAt ||\n            block.timestamp - getRateStalePeriod() > ratioUpdatedAt;\n    }\n\n    function issuanceRatio() external view returns (uint) {\n        return getIssuanceRatio();\n    }\n\n    function _sharesForDebt(uint debtAmount) internal view returns (uint) {\n        (, int256 rawRatio, , , ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_DEBT_RATIO)).latestRoundData();\n\n        return rawRatio == 0 ? 0 : debtAmount.divideDecimalRoundPrecise(uint(rawRatio));\n    }\n\n    function _debtForShares(uint sharesAmount) internal view returns (uint) {\n        (, int256 rawRatio, , , ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_DEBT_RATIO)).latestRoundData();\n\n        return sharesAmount.multiplyDecimalRoundPrecise(uint(rawRatio));\n    }\n\n    function _availableCurrencyKeysWithOptionalSNX(bool withSNX) internal view returns (bytes32[] memory) {\n        bytes32[] memory currencyKeys = new bytes32[](availableSynths.length + (withSNX ? 1 : 0));\n\n        for (uint i = 0; i < availableSynths.length; i++) {\n            currencyKeys[i] = synthsByAddress[address(availableSynths[i])];\n        }\n\n        if (withSNX) {\n            currencyKeys[availableSynths.length] = SNX;\n        }\n\n        return currencyKeys;\n    }\n\n    // Returns the total value of the debt pool in currency specified by `currencyKey`.\n    // To return only the SNX-backed debt, set `excludeCollateral` to true.\n    function _totalIssuedSynths(bytes32 currencyKey, bool excludeCollateral)\n        internal\n        view\n        returns (uint totalIssued, bool anyRateIsInvalid)\n    {\n        (uint debt, , bool cacheIsInvalid, bool cacheIsStale) = debtCache().cacheInfo();\n        anyRateIsInvalid = cacheIsInvalid || cacheIsStale;\n\n        IExchangeRates exRates = exchangeRates();\n\n        // Add total issued synths from non snx collateral back into the total if not excluded\n        if (!excludeCollateral) {\n            (uint nonSnxDebt, bool invalid) = debtCache().totalNonSnxBackedDebt();\n            debt = debt.add(nonSnxDebt);\n            anyRateIsInvalid = anyRateIsInvalid || invalid;\n        }\n\n        if (currencyKey == sUSD) {\n            return (debt, anyRateIsInvalid);\n        }\n\n        (uint currencyRate, bool currencyRateInvalid) = exRates.rateAndInvalid(currencyKey);\n        return (debt.divideDecimalRound(currencyRate), anyRateIsInvalid || currencyRateInvalid);\n    }\n\n    function _debtBalanceOfAndTotalDebt(uint debtShareBalance, bytes32 currencyKey)\n        internal\n        view\n        returns (\n            uint debtBalance,\n            uint totalSystemValue,\n            bool anyRateIsInvalid\n        )\n    {\n        // What's the total value of the system excluding ETH backed synths in their requested currency?\n        (uint snxBackedAmount, , bool debtInfoStale) = allNetworksDebtInfo();\n\n        if (debtShareBalance == 0) {\n            return (0, snxBackedAmount, debtInfoStale);\n        }\n\n        // existing functionality requires for us to convert into the exchange rate specified by `currencyKey`\n        (uint currencyRate, bool currencyRateInvalid) = exchangeRates().rateAndInvalid(currencyKey);\n\n        debtBalance = _debtForShares(debtShareBalance).divideDecimalRound(currencyRate);\n        totalSystemValue = snxBackedAmount;\n\n        anyRateIsInvalid = currencyRateInvalid || debtInfoStale;\n    }\n\n    function _canBurnSynths(address account) internal view returns (bool) {\n        return now >= _lastIssueEvent(account).add(getMinimumStakeTime());\n    }\n\n    function _lastIssueEvent(address account) internal view returns (uint) {\n        //  Get the timestamp of the last issue this account made\n        return flexibleStorage().getUIntValue(CONTRACT_NAME, keccak256(abi.encodePacked(LAST_ISSUE_EVENT, account)));\n    }\n\n    function _remainingIssuableSynths(address _issuer)\n        internal\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt,\n            bool anyRateIsInvalid\n        )\n    {\n        (alreadyIssued, totalSystemDebt, anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(\n            synthetixDebtShare().balanceOf(_issuer),\n            sUSD\n        );\n        (uint issuable, bool isInvalid) = _maxIssuableSynths(_issuer);\n        maxIssuable = issuable;\n        anyRateIsInvalid = anyRateIsInvalid || isInvalid;\n\n        if (alreadyIssued >= maxIssuable) {\n            maxIssuable = 0;\n        } else {\n            maxIssuable = maxIssuable.sub(alreadyIssued);\n        }\n    }\n\n    function _snxToUSD(uint amount, uint snxRate) internal pure returns (uint) {\n        return amount.multiplyDecimalRound(snxRate);\n    }\n\n    function _usdToSnx(uint amount, uint snxRate) internal pure returns (uint) {\n        return amount.divideDecimalRound(snxRate);\n    }\n\n    function _maxIssuableSynths(address _issuer) internal view returns (uint, bool) {\n        // What is the value of their SNX balance in sUSD\n        (uint snxRate, bool isInvalid) = exchangeRates().rateAndInvalid(SNX);\n        uint destinationValue = _snxToUSD(_collateral(_issuer), snxRate);\n\n        // They're allowed to issue up to issuanceRatio of that value\n        return (destinationValue.multiplyDecimal(getIssuanceRatio()), isInvalid);\n    }\n\n    function _collateralisationRatio(address _issuer) internal view returns (uint, bool) {\n        uint totalOwnedSynthetix = _collateral(_issuer);\n\n        (uint debtBalance, , bool anyRateIsInvalid) =\n            _debtBalanceOfAndTotalDebt(synthetixDebtShare().balanceOf(_issuer), SNX);\n\n        // it's more gas intensive to put this check here if they have 0 SNX, but it complies with the interface\n        if (totalOwnedSynthetix == 0) return (0, anyRateIsInvalid);\n\n        return (debtBalance.divideDecimalRound(totalOwnedSynthetix), anyRateIsInvalid);\n    }\n\n    function _collateral(address account) internal view returns (uint) {\n        uint balance = IERC20(address(synthetix())).balanceOf(account);\n\n        if (address(synthetixEscrow()) != address(0)) {\n            balance = balance.add(synthetixEscrow().balanceOf(account));\n        }\n\n        if (address(rewardEscrowV2()) != address(0)) {\n            balance = balance.add(rewardEscrowV2().balanceOf(account));\n        }\n\n        if (address(liquidatorRewards()) != address(0)) {\n            balance = balance.add(liquidatorRewards().earned(account));\n        }\n\n        return balance;\n    }\n\n    function minimumStakeTime() external view returns (uint) {\n        return getMinimumStakeTime();\n    }\n\n    function canBurnSynths(address account) external view returns (bool) {\n        return _canBurnSynths(account);\n    }\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory) {\n        return _availableCurrencyKeysWithOptionalSNX(false);\n    }\n\n    function availableSynthCount() external view returns (uint) {\n        return availableSynths.length;\n    }\n\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid) {\n        (, anyRateInvalid) = exchangeRates().ratesAndInvalidForCurrencies(_availableCurrencyKeysWithOptionalSNX(true));\n    }\n\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint totalIssued) {\n        (totalIssued, ) = _totalIssuedSynths(currencyKey, excludeOtherCollateral);\n    }\n\n    function lastIssueEvent(address account) external view returns (uint) {\n        return _lastIssueEvent(account);\n    }\n\n    function collateralisationRatio(address _issuer) external view returns (uint cratio) {\n        (cratio, ) = _collateralisationRatio(_issuer);\n    }\n\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsInvalid)\n    {\n        return _collateralisationRatio(_issuer);\n    }\n\n    function collateral(address account) external view returns (uint) {\n        return _collateral(account);\n    }\n\n    function debtBalanceOf(address _issuer, bytes32 currencyKey) external view returns (uint debtBalance) {\n        ISynthetixDebtShare sds = synthetixDebtShare();\n\n        // What was their initial debt ownership?\n        uint debtShareBalance = sds.balanceOf(_issuer);\n\n        // If it's zero, they haven't issued, and they have no debt.\n        if (debtShareBalance == 0) return 0;\n\n        (debtBalance, , ) = _debtBalanceOfAndTotalDebt(debtShareBalance, currencyKey);\n    }\n\n    function remainingIssuableSynths(address _issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        )\n    {\n        (maxIssuable, alreadyIssued, totalSystemDebt, ) = _remainingIssuableSynths(_issuer);\n    }\n\n    function maxIssuableSynths(address _issuer) external view returns (uint) {\n        (uint maxIssuable, ) = _maxIssuableSynths(_issuer);\n        return maxIssuable;\n    }\n\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsInvalid)\n    {\n        // How many SNX do they have, excluding escrow?\n        // Note: We're excluding escrow here because we're interested in their transferable amount\n        // and escrowed SNX are not transferable.\n\n        // How many of those will be locked by the amount they've issued?\n        // Assuming issuance ratio is 20%, then issuing 20 SNX of value would require\n        // 100 SNX to be locked in their wallet to maintain their collateralisation ratio\n        // The locked synthetix value can exceed their balance.\n        uint debtBalance;\n        (debtBalance, , anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(synthetixDebtShare().balanceOf(account), SNX);\n        uint lockedSynthetixValue = debtBalance.divideDecimalRound(getIssuanceRatio());\n\n        // If we exceed the balance, no SNX are transferable, otherwise the difference is.\n        if (lockedSynthetixValue >= balance) {\n            transferable = 0;\n        } else {\n            transferable = balance.sub(lockedSynthetixValue);\n        }\n    }\n\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory) {\n        uint numKeys = currencyKeys.length;\n        ISynth[] memory addresses = new ISynth[](numKeys);\n\n        for (uint i = 0; i < numKeys; i++) {\n            addresses[i] = synths[currencyKeys[i]];\n        }\n\n        return addresses;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function _addSynth(ISynth synth) internal {\n        bytes32 currencyKey = synth.currencyKey();\n        require(synths[currencyKey] == ISynth(0), \"Synth exists\");\n        require(synthsByAddress[address(synth)] == bytes32(0), \"Synth address already exists\");\n\n        availableSynths.push(synth);\n        synths[currencyKey] = synth;\n        synthsByAddress[address(synth)] = currencyKey;\n\n        emit SynthAdded(currencyKey, address(synth));\n    }\n\n    function addSynth(ISynth synth) external onlyOwner {\n        _addSynth(synth);\n        // Invalidate the cache to force a snapshot to be recomputed. If a synth were to be added\n        // back to the system and it still somehow had cached debt, this would force the value to be\n        // updated.\n        debtCache().updateDebtCacheValidity(true);\n    }\n\n    function addSynths(ISynth[] calldata synthsToAdd) external onlyOwner {\n        uint numSynths = synthsToAdd.length;\n        for (uint i = 0; i < numSynths; i++) {\n            _addSynth(synthsToAdd[i]);\n        }\n\n        // Invalidate the cache to force a snapshot to be recomputed.\n        debtCache().updateDebtCacheValidity(true);\n    }\n\n    function _removeSynth(bytes32 currencyKey) internal {\n        address synthToRemove = address(synths[currencyKey]);\n        require(synthToRemove != address(0), \"Synth does not exist\");\n        require(currencyKey != sUSD, \"Cannot remove synth\");\n\n        uint synthSupply = IERC20(synthToRemove).totalSupply();\n\n        if (synthSupply > 0) {\n            (uint amountOfsUSD, uint rateToRedeem, ) =\n                exchangeRates().effectiveValueAndRates(currencyKey, synthSupply, \"sUSD\");\n            require(rateToRedeem > 0, \"Cannot remove synth to redeem without rate\");\n            ISynthRedeemer _synthRedeemer = synthRedeemer();\n            synths[sUSD].issue(address(_synthRedeemer), amountOfsUSD);\n            // ensure the debt cache is aware of the new sUSD issued\n            debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amountOfsUSD));\n            _synthRedeemer.deprecate(IERC20(address(Proxyable(address(synthToRemove)).proxy())), rateToRedeem);\n        }\n\n        // Remove the synth from the availableSynths array.\n        for (uint i = 0; i < availableSynths.length; i++) {\n            if (address(availableSynths[i]) == synthToRemove) {\n                delete availableSynths[i];\n\n                // Copy the last synth into the place of the one we just deleted\n                // If there's only one synth, this is synths[0] = synths[0].\n                // If we're deleting the last one, it's also a NOOP in the same way.\n                availableSynths[i] = availableSynths[availableSynths.length - 1];\n\n                // Decrease the size of the array by one.\n                availableSynths.length--;\n\n                break;\n            }\n        }\n\n        // And remove it from the synths mapping\n        delete synthsByAddress[synthToRemove];\n        delete synths[currencyKey];\n\n        emit SynthRemoved(currencyKey, synthToRemove);\n    }\n\n    function removeSynth(bytes32 currencyKey) external onlyOwner {\n        // Remove its contribution from the debt pool snapshot, and\n        // invalidate the cache to force a new snapshot.\n        IIssuerInternalDebtCache cache = debtCache();\n        cache.updateCachedSynthDebtWithRate(currencyKey, 0);\n        cache.updateDebtCacheValidity(true);\n\n        _removeSynth(currencyKey);\n    }\n\n    function removeSynths(bytes32[] calldata currencyKeys) external onlyOwner {\n        uint numKeys = currencyKeys.length;\n\n        // Remove their contributions from the debt pool snapshot, and\n        // invalidate the cache to force a new snapshot.\n        IIssuerInternalDebtCache cache = debtCache();\n        uint[] memory zeroRates = new uint[](numKeys);\n        cache.updateCachedSynthDebtsWithRates(currencyKeys, zeroRates);\n        cache.updateDebtCacheValidity(true);\n\n        for (uint i = 0; i < numKeys; i++) {\n            _removeSynth(currencyKeys[i]);\n        }\n    }\n\n    function issueSynthsWithoutDebt(\n        bytes32 currencyKey,\n        address to,\n        uint amount\n    ) external onlyTrustedMinters returns (bool rateInvalid) {\n        require(address(synths[currencyKey]) != address(0), \"Issuer: synth doesn't exist\");\n        require(amount > 0, \"Issuer: cannot issue 0 synths\");\n\n        // record issue timestamp\n        _setLastIssueEvent(to);\n\n        // Create their synths\n        synths[currencyKey].issue(to, amount);\n\n        // Account for the issued debt in the cache\n        (uint rate, bool rateInvalid) = exchangeRates().rateAndInvalid(currencyKey);\n        debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amount.multiplyDecimal(rate)));\n\n        // returned so that the caller can decide what to do if the rate is invalid\n        return rateInvalid;\n    }\n\n    function burnSynthsWithoutDebt(\n        bytes32 currencyKey,\n        address from,\n        uint amount\n    ) external onlyTrustedMinters returns (bool rateInvalid) {\n        require(address(synths[currencyKey]) != address(0), \"Issuer: synth doesn't exist\");\n        require(amount > 0, \"Issuer: cannot issue 0 synths\");\n\n        exchanger().settle(from, currencyKey);\n\n        // Burn some synths\n        synths[currencyKey].burn(from, amount);\n\n        // Account for the burnt debt in the cache. If rate is invalid, the user won't be able to exchange\n        (uint rate, bool rateInvalid) = exchangeRates().rateAndInvalid(currencyKey);\n        debtCache().updateCachedsUSDDebt(-SafeCast.toInt256(amount.multiplyDecimal(rate)));\n\n        // returned so that the caller can decide what to do if the rate is invalid\n        return rateInvalid;\n    }\n\n    /**\n     * Function used to migrate balances from the CollateralShort contract\n     * @param short The address of the CollateralShort contract to be upgraded\n     * @param amount The amount of sUSD collateral to be burnt\n     */\n    function upgradeCollateralShort(address short, uint amount) external onlyOwner {\n        require(short != address(0), \"Issuer: invalid address\");\n        require(short == resolver.getAddress(\"CollateralShortLegacy\"), \"Issuer: wrong short address\");\n        require(address(synths[sUSD]) != address(0), \"Issuer: synth doesn't exist\");\n        require(amount > 0, \"Issuer: cannot burn 0 synths\");\n\n        exchanger().settle(short, sUSD);\n\n        synths[sUSD].burn(short, amount);\n    }\n\n    function issueSynths(address from, uint amount) external onlySynthetix {\n        require(amount > 0, \"Issuer: cannot issue 0 synths\");\n\n        _issueSynths(from, amount, false);\n    }\n\n    function issueMaxSynths(address from) external onlySynthetix {\n        _issueSynths(from, 0, true);\n    }\n\n    function issueSynthsOnBehalf(\n        address issueForAddress,\n        address from,\n        uint amount\n    ) external onlySynthetix {\n        _requireCanIssueOnBehalf(issueForAddress, from);\n        _issueSynths(issueForAddress, amount, false);\n    }\n\n    function issueMaxSynthsOnBehalf(address issueForAddress, address from) external onlySynthetix {\n        _requireCanIssueOnBehalf(issueForAddress, from);\n        _issueSynths(issueForAddress, 0, true);\n    }\n\n    function burnSynths(address from, uint amount) external onlySynthetix {\n        _voluntaryBurnSynths(from, amount, false);\n    }\n\n    function burnSynthsOnBehalf(\n        address burnForAddress,\n        address from,\n        uint amount\n    ) external onlySynthetix {\n        _requireCanBurnOnBehalf(burnForAddress, from);\n        _voluntaryBurnSynths(burnForAddress, amount, false);\n    }\n\n    function burnSynthsToTarget(address from) external onlySynthetix {\n        _voluntaryBurnSynths(from, 0, true);\n    }\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external onlySynthetix {\n        _requireCanBurnOnBehalf(burnForAddress, from);\n        _voluntaryBurnSynths(burnForAddress, 0, true);\n    }\n\n    function burnForRedemption(\n        address deprecatedSynthProxy,\n        address account,\n        uint balance\n    ) external onlySynthRedeemer {\n        ISynth(IProxy(deprecatedSynthProxy).target()).burn(account, balance);\n    }\n\n    // SIP-148: Upgraded Liquidation Mechanism\n    /// @notice This is where the core internal liquidation logic resides. This function can only be invoked by Synthetix.\n    /// @param account The account to be liquidated\n    /// @param isSelfLiquidation boolean to determine if this is a forced or self-invoked liquidation\n    /// @return uint the total amount of collateral (SNX) to redeem\n    /// @return uint the amount of debt (sUSD) to burn in order to fix the account's c-ratio\n    function liquidateAccount(address account, bool isSelfLiquidation)\n        external\n        onlySynthetix\n        returns (uint totalRedeemed, uint amountToLiquidate)\n    {\n        require(liquidator().isLiquidationOpen(account, isSelfLiquidation), \"Not open for liquidation\");\n\n        // Get the penalty for the liquidation type\n        uint penalty = isSelfLiquidation ? getSelfLiquidationPenalty() : getLiquidationPenalty();\n\n        // Get the account's debt balance\n        (uint debtBalance, , bool anyRateIsInvalid) =\n            _debtBalanceOfAndTotalDebt(synthetixDebtShare().balanceOf(account), sUSD);\n\n        // Get the SNX rate\n        (uint snxRate, bool snxRateInvalid) = exchangeRates().rateAndInvalid(SNX);\n        _requireRatesNotInvalid(anyRateIsInvalid || snxRateInvalid);\n\n        // Get the total amount of SNX collateral (including escrows and rewards)\n        uint collateralForAccount = _collateral(account);\n\n        // Calculate the amount of debt to liquidate to fix c-ratio\n        amountToLiquidate = liquidator().calculateAmountToFixCollateral(\n            debtBalance,\n            _snxToUSD(collateralForAccount, snxRate),\n            penalty\n        );\n\n        // Get the equivalent amount of SNX for the amount to liquidate\n        // Note: While amountToLiquidate takes the penalty into account, it does not accommodate for the addition of the penalty in terms of SNX.\n        // Therefore, it is correct to add the penalty modification below to the totalRedeemed.\n        totalRedeemed = _usdToSnx(amountToLiquidate, snxRate).multiplyDecimal(SafeDecimalMath.unit().add(penalty));\n\n        // The balanceOf here can be considered \"transferable\" since it's not escrowed,\n        // and it is the only SNX that can potentially be transfered if unstaked.\n        uint transferableBalance = IERC20(address(synthetix())).balanceOf(account);\n        if (totalRedeemed > transferableBalance) {\n            // Liquidate the account's debt based on the liquidation penalty.\n            amountToLiquidate = amountToLiquidate.multiplyDecimal(transferableBalance).divideDecimal(totalRedeemed);\n\n            // Set totalRedeemed to all transferable collateral.\n            // i.e. the value of the account's staking position relative to balanceOf will be unwound.\n            totalRedeemed = transferableBalance;\n        }\n\n        // Reduce debt shares by amount to liquidate.\n        _removeFromDebtRegister(account, amountToLiquidate, debtBalance);\n\n        // Remove liquidation flag\n        liquidator().removeAccountInLiquidation(account);\n    }\n\n    function setCurrentPeriodId(uint128 periodId) external {\n        require(msg.sender == address(feePool()), \"Must be fee pool\");\n\n        ISynthetixDebtShare sds = synthetixDebtShare();\n\n        if (sds.currentPeriodId() < periodId) {\n            sds.takeSnapshot(periodId);\n        }\n    }\n\n    function setLastDebtRatio(uint256 ratio) external onlyOwner {\n        lastDebtRatio = ratio;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _requireRatesNotInvalid(bool anyRateIsInvalid) internal pure {\n        require(!anyRateIsInvalid, \"A synth or SNX rate is invalid\");\n    }\n\n    function _requireCanIssueOnBehalf(address issueForAddress, address from) internal view {\n        require(delegateApprovals().canIssueFor(issueForAddress, from), \"Not approved to act on behalf\");\n    }\n\n    function _requireCanBurnOnBehalf(address burnForAddress, address from) internal view {\n        require(delegateApprovals().canBurnFor(burnForAddress, from), \"Not approved to act on behalf\");\n    }\n\n    function _issueSynths(\n        address from,\n        uint amount,\n        bool issueMax\n    ) internal {\n        // check breaker\n        if (!_verifyCircuitBreaker()) {\n            return;\n        }\n\n        (uint maxIssuable, , , bool anyRateIsInvalid) = _remainingIssuableSynths(from);\n        _requireRatesNotInvalid(anyRateIsInvalid);\n\n        if (!issueMax) {\n            require(amount <= maxIssuable, \"Amount too large\");\n        } else {\n            amount = maxIssuable;\n        }\n\n        // Keep track of the debt they're about to create\n        _addToDebtRegister(from, amount);\n\n        // record issue timestamp\n        _setLastIssueEvent(from);\n\n        // Create their synths\n        synths[sUSD].issue(from, amount);\n\n        // Account for the issued debt in the cache\n        debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amount));\n    }\n\n    function _burnSynths(\n        address debtAccount,\n        address burnAccount,\n        uint amount,\n        uint existingDebt\n    ) internal returns (uint amountBurnt) {\n        // check breaker\n        if (!_verifyCircuitBreaker()) {\n            return 0;\n        }\n\n        // liquidation requires sUSD to be already settled / not in waiting period\n\n        // If they're trying to burn more debt than they actually owe, rather than fail the transaction, let's just\n        // clear their debt and leave them be.\n        amountBurnt = existingDebt < amount ? existingDebt : amount;\n\n        // Remove liquidated debt from the ledger\n        _removeFromDebtRegister(debtAccount, amountBurnt, existingDebt);\n\n        // synth.burn does a safe subtraction on balance (so it will revert if there are not enough synths).\n        synths[sUSD].burn(burnAccount, amountBurnt);\n\n        // Account for the burnt debt in the cache.\n        debtCache().updateCachedsUSDDebt(-SafeCast.toInt256(amountBurnt));\n    }\n\n    // If burning to target, `amount` is ignored, and the correct quantity of sUSD is burnt to reach the target\n    // c-ratio, allowing fees to be claimed. In this case, pending settlements will be skipped as the user\n    // will still have debt remaining after reaching their target.\n    function _voluntaryBurnSynths(\n        address from,\n        uint amount,\n        bool burnToTarget\n    ) internal {\n        // check breaker\n        if (!_verifyCircuitBreaker()) {\n            return;\n        }\n\n        if (!burnToTarget) {\n            // If not burning to target, then burning requires that the minimum stake time has elapsed.\n            require(_canBurnSynths(from), \"Minimum stake time not reached\");\n            // First settle anything pending into sUSD as burning or issuing impacts the size of the debt pool\n            (, uint refunded, uint numEntriesSettled) = exchanger().settle(from, sUSD);\n            if (numEntriesSettled > 0) {\n                amount = exchanger().calculateAmountAfterSettlement(from, sUSD, amount, refunded);\n            }\n        }\n\n        (uint existingDebt, , bool anyRateIsInvalid) =\n            _debtBalanceOfAndTotalDebt(synthetixDebtShare().balanceOf(from), sUSD);\n        (uint maxIssuableSynthsForAccount, bool snxRateInvalid) = _maxIssuableSynths(from);\n        _requireRatesNotInvalid(anyRateIsInvalid || snxRateInvalid);\n        require(existingDebt > 0, \"No debt to forgive\");\n\n        if (burnToTarget) {\n            amount = existingDebt.sub(maxIssuableSynthsForAccount);\n        }\n\n        uint amountBurnt = _burnSynths(from, from, amount, existingDebt);\n\n        // Check and remove liquidation if existingDebt after burning is <= maxIssuableSynths\n        // Issuance ratio is fixed so should remove any liquidations\n        if (existingDebt.sub(amountBurnt) <= maxIssuableSynthsForAccount) {\n            liquidator().removeAccountInLiquidation(from);\n        }\n    }\n\n    function _setLastIssueEvent(address account) internal {\n        // Set the timestamp of the last issueSynths\n        flexibleStorage().setUIntValue(\n            CONTRACT_NAME,\n            keccak256(abi.encodePacked(LAST_ISSUE_EVENT, account)),\n            block.timestamp\n        );\n    }\n\n    function _addToDebtRegister(address from, uint amount) internal {\n        // important: this has to happen before any updates to user's debt shares\n        liquidatorRewards().updateEntry(from);\n\n        ISynthetixDebtShare sds = synthetixDebtShare();\n\n        // it is possible (eg in tests, system initialized with extra debt) to have issued debt without any shares issued\n        // in which case, the first account to mint gets the debt. yw.\n        uint debtShares = _sharesForDebt(amount);\n        if (debtShares == 0) {\n            sds.mintShare(from, amount);\n        } else {\n            sds.mintShare(from, debtShares);\n        }\n    }\n\n    function _removeFromDebtRegister(\n        address from,\n        uint debtToRemove,\n        uint existingDebt\n    ) internal {\n        // important: this has to happen before any updates to user's debt shares\n        liquidatorRewards().updateEntry(from);\n\n        ISynthetixDebtShare sds = synthetixDebtShare();\n\n        uint currentDebtShare = sds.balanceOf(from);\n\n        if (debtToRemove == existingDebt) {\n            sds.burnShare(from, currentDebtShare);\n        } else {\n            uint sharesToRemove = _sharesForDebt(debtToRemove);\n            sds.burnShare(from, sharesToRemove < currentDebtShare ? sharesToRemove : currentDebtShare);\n        }\n    }\n\n    function _verifyCircuitBreaker() internal returns (bool) {\n        (, int256 rawRatio, , , ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_DEBT_RATIO)).latestRoundData();\n\n        uint deviation = _calculateDeviation(lastDebtRatio, uint(rawRatio));\n\n        if (deviation >= getPriceDeviationThresholdFactor()) {\n            systemStatus().suspendIssuance(CIRCUIT_BREAKER_SUSPENSION_REASON);\n            return false;\n        }\n        lastDebtRatio = uint(rawRatio);\n\n        return true;\n    }\n\n    function _calculateDeviation(uint last, uint fresh) internal pure returns (uint deviation) {\n        if (last == 0) {\n            deviation = 1;\n        } else if (fresh == 0) {\n            deviation = uint(-1);\n        } else if (last > fresh) {\n            deviation = last.divideDecimal(fresh);\n        } else {\n            deviation = fresh.divideDecimal(last);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n    modifier onlySynthetix() {\n        require(msg.sender == address(synthetix()), \"Issuer: Only the synthetix contract can perform this action\");\n        _;\n    }\n\n    modifier onlyTrustedMinters() {\n        address bridgeL1 = resolver.getAddress(CONTRACT_SYNTHETIXBRIDGETOOPTIMISM);\n        address bridgeL2 = resolver.getAddress(CONTRACT_SYNTHETIXBRIDGETOBASE);\n        require(msg.sender == bridgeL1 || msg.sender == bridgeL2, \"Issuer: only trusted minters\");\n        require(bridgeL1 == address(0) || bridgeL2 == address(0), \"Issuer: one minter must be 0x0\");\n        _;\n    }\n\n    function _onlySynthRedeemer() internal view {\n        require(msg.sender == address(synthRedeemer()), \"Issuer: Only the SynthRedeemer contract can perform this action\");\n    }\n\n    modifier onlySynthRedeemer() {\n        _onlySynthRedeemer();\n        _;\n    }\n\n    modifier issuanceActive() {\n        _issuanceActive();\n        _;\n    }\n\n    function _issuanceActive() private {\n        systemStatus().requireIssuanceActive();\n    }\n\n    modifier synthActive(bytes32 currencyKey) {\n        _synthActive(currencyKey);\n        _;\n    }\n\n    function _synthActive(bytes32 currencyKey) private {\n        systemStatus().requireSynthActive(currencyKey);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SynthAdded(bytes32 currencyKey, address synth);\n    event SynthRemoved(bytes32 currencyKey, address synth);\n}\n\n\ncontract LegacyOwned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        owner = _owner;\n    }\n\n    function nominateOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner);\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\ncontract LegacyTokenState is LegacyOwned {\n    // the address of the contract that can modify balances and allowances\n    // this can only be changed by the owner of this contract\n    address public associatedContract;\n\n    // ERC20 fields.\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    constructor(address _owner, address _associatedContract) public LegacyOwned(_owner) {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== SETTERS ========== */\n\n    // Change the associated contract to a new address\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    function setAllowance(\n        address tokenOwner,\n        address spender,\n        uint value\n    ) external onlyAssociatedContract {\n        allowance[tokenOwner][spender] = value;\n    }\n\n    function setBalanceOf(address account, uint value) external onlyAssociatedContract {\n        balanceOf[account] = value;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyAssociatedContract {\n        require(msg.sender == associatedContract);\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AssociatedContractUpdated(address _associatedContract);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/state\ncontract State is Owned {\n    // the address of the contract that can modify variables\n    // this can only be changed by the owner of this contract\n    address public associatedContract;\n\n    constructor(address _associatedContract) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== SETTERS ========== */\n\n    // Change the associated contract to a new address\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyAssociatedContract {\n        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AssociatedContractUpdated(address associatedContract);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/tokenstate\ncontract TokenState is Owned, State {\n    /* ERC20 fields. */\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice Set ERC20 allowance.\n     * @dev Only the associated contract may call this.\n     * @param tokenOwner The authorising party.\n     * @param spender The authorised party.\n     * @param value The total value the authorised party may spend on the\n     * authorising party's behalf.\n     */\n    function setAllowance(\n        address tokenOwner,\n        address spender,\n        uint value\n    ) external onlyAssociatedContract {\n        allowance[tokenOwner][spender] = value;\n    }\n\n    /**\n     * @notice Set the balance in a given account\n     * @dev Only the associated contract may call this.\n     * @param account The account whose value to set.\n     * @param value The new balance of the given account.\n     */\n    function setBalanceOf(address account, uint value) external onlyAssociatedContract {\n        balanceOf[account] = value;\n    }\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/externstatetoken\ncontract ExternStateToken is Owned, Proxyable {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /* ========== STATE VARIABLES ========== */\n\n    /* Stores balances and allowances. */\n    TokenState public tokenState;\n\n    /* Other ERC20 fields. */\n    string public name;\n    string public symbol;\n    uint public totalSupply;\n    uint8 public decimals;\n\n    constructor(\n        address payable _proxy,\n        TokenState _tokenState,\n        string memory _name,\n        string memory _symbol,\n        uint _totalSupply,\n        uint8 _decimals,\n        address _owner\n    ) public Owned(_owner) Proxyable(_proxy) {\n        tokenState = _tokenState;\n\n        name = _name;\n        symbol = _symbol;\n        totalSupply = _totalSupply;\n        decimals = _decimals;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Returns the ERC20 allowance of one party to spend on behalf of another.\n     * @param owner The party authorising spending of their funds.\n     * @param spender The party spending tokenOwner's funds.\n     */\n    function allowance(address owner, address spender) public view returns (uint) {\n        return tokenState.allowance(owner, spender);\n    }\n\n    /**\n     * @notice Returns the ERC20 token balance of a given account.\n     */\n    function balanceOf(address account) external view returns (uint) {\n        return tokenState.balanceOf(account);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Set the address of the TokenState contract.\n     * @dev This can be used to \"pause\" transfer functionality, by pointing the tokenState at 0x000..\n     * as balances would be unreachable.\n     */\n    function setTokenState(TokenState _tokenState) external optionalProxy_onlyOwner {\n        tokenState = _tokenState;\n        emitTokenStateUpdated(address(_tokenState));\n    }\n\n    function _internalTransfer(\n        address from,\n        address to,\n        uint value\n    ) internal returns (bool) {\n        /* Disallow transfers to irretrievable-addresses. */\n        require(to != address(0) && to != address(this) && to != address(proxy), \"Cannot transfer to this address\");\n\n        // Insufficient balance will be handled by the safe subtraction.\n        tokenState.setBalanceOf(from, tokenState.balanceOf(from).sub(value));\n        tokenState.setBalanceOf(to, tokenState.balanceOf(to).add(value));\n\n        // Emit a standard ERC20 transfer event\n        emitTransfer(from, to, value);\n\n        return true;\n    }\n\n    /**\n     * @dev Perform an ERC20 token transfer. Designed to be called by transfer functions possessing\n     * the onlyProxy or optionalProxy modifiers.\n     */\n    function _transferByProxy(\n        address from,\n        address to,\n        uint value\n    ) internal returns (bool) {\n        return _internalTransfer(from, to, value);\n    }\n\n    /*\n     * @dev Perform an ERC20 token transferFrom. Designed to be called by transferFrom functions\n     * possessing the optionalProxy or optionalProxy modifiers.\n     */\n    function _transferFromByProxy(\n        address sender,\n        address from,\n        address to,\n        uint value\n    ) internal returns (bool) {\n        /* Insufficient allowance will be handled by the safe subtraction. */\n        tokenState.setAllowance(from, sender, tokenState.allowance(from, sender).sub(value));\n        return _internalTransfer(from, to, value);\n    }\n\n    /**\n     * @notice Approves spender to transfer on the message sender's behalf.\n     */\n    function approve(address spender, uint value) public optionalProxy returns (bool) {\n        address sender = messageSender;\n\n        tokenState.setAllowance(sender, spender, value);\n        emitApproval(sender, spender, value);\n        return true;\n    }\n\n    /* ========== EVENTS ========== */\n    function addressToBytes32(address input) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(input)));\n    }\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    bytes32 internal constant TRANSFER_SIG = keccak256(\"Transfer(address,address,uint256)\");\n\n    function emitTransfer(\n        address from,\n        address to,\n        uint value\n    ) internal {\n        proxy._emit(abi.encode(value), 3, TRANSFER_SIG, addressToBytes32(from), addressToBytes32(to), 0);\n    }\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    bytes32 internal constant APPROVAL_SIG = keccak256(\"Approval(address,address,uint256)\");\n\n    function emitApproval(\n        address owner,\n        address spender,\n        uint value\n    ) internal {\n        proxy._emit(abi.encode(value), 3, APPROVAL_SIG, addressToBytes32(owner), addressToBytes32(spender), 0);\n    }\n\n    event TokenStateUpdated(address newTokenState);\n    bytes32 internal constant TOKENSTATEUPDATED_SIG = keccak256(\"TokenStateUpdated(address)\");\n\n    function emitTokenStateUpdated(address newTokenState) internal {\n        proxy._emit(abi.encode(newTokenState), 1, TOKENSTATEUPDATED_SIG, 0, 0, 0);\n    }\n}\n\n\ninterface IFuturesMarketManager {\n    function markets(uint index, uint pageSize) external view returns (address[] memory);\n\n    function numMarkets() external view returns (uint);\n\n    function allMarkets() external view returns (address[] memory);\n\n    function marketForKey(bytes32 marketKey) external view returns (address);\n\n    function marketsForKeys(bytes32[] calldata marketKeys) external view returns (address[] memory);\n\n    function totalDebt() external view returns (uint debt, bool isInvalid);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/synth\ncontract Synth is Owned, IERC20, ExternStateToken, MixinResolver, ISynth {\n    bytes32 public constant CONTRACT_NAME = \"Synth\";\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Currency key which identifies this Synth to the Synthetix system\n    bytes32 public currencyKey;\n\n    uint8 public constant DECIMALS = 18;\n\n    // Where fees are pooled in sUSD\n    address public constant FEE_ADDRESS = 0xfeEFEEfeefEeFeefEEFEEfEeFeefEEFeeFEEFEeF;\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\n    bytes32 private constant CONTRACT_EXCHANGER = \"Exchanger\";\n    bytes32 private constant CONTRACT_ISSUER = \"Issuer\";\n    bytes32 private constant CONTRACT_FEEPOOL = \"FeePool\";\n    bytes32 private constant CONTRACT_FUTURESMARKETMANAGER = \"FuturesMarketManager\";\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address payable _proxy,\n        TokenState _tokenState,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        address _owner,\n        bytes32 _currencyKey,\n        uint _totalSupply,\n        address _resolver\n    )\n        public\n        ExternStateToken(_proxy, _tokenState, _tokenName, _tokenSymbol, _totalSupply, DECIMALS, _owner)\n        MixinResolver(_resolver)\n    {\n        require(_proxy != address(0), \"_proxy cannot be 0\");\n        require(_owner != address(0), \"_owner cannot be 0\");\n\n        currencyKey = _currencyKey;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function transfer(address to, uint value) public onlyProxyOrInternal returns (bool) {\n        _ensureCanTransfer(messageSender, value);\n\n        // transfers to FEE_ADDRESS will be exchanged into sUSD and recorded as fee\n        if (to == FEE_ADDRESS) {\n            return _transferToFeeAddress(to, value);\n        }\n\n        // transfers to 0x address will be burned\n        if (to == address(0)) {\n            return _internalBurn(messageSender, value);\n        }\n\n        return super._internalTransfer(messageSender, to, value);\n    }\n\n    function transferAndSettle(address to, uint value) public onlyProxyOrInternal returns (bool) {\n        // Exchanger.settle ensures synth is active\n        (, , uint numEntriesSettled) = exchanger().settle(messageSender, currencyKey);\n\n        // Save gas instead of calling transferableSynths\n        uint balanceAfter = value;\n\n        if (numEntriesSettled > 0) {\n            balanceAfter = tokenState.balanceOf(messageSender);\n        }\n\n        // Reduce the value to transfer if balance is insufficient after reclaimed\n        value = value > balanceAfter ? balanceAfter : value;\n\n        return super._internalTransfer(messageSender, to, value);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public onlyProxyOrInternal returns (bool) {\n        _ensureCanTransfer(from, value);\n\n        return _internalTransferFrom(from, to, value);\n    }\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) public onlyProxyOrInternal returns (bool) {\n        // Exchanger.settle() ensures synth is active\n        (, , uint numEntriesSettled) = exchanger().settle(from, currencyKey);\n\n        // Save gas instead of calling transferableSynths\n        uint balanceAfter = value;\n\n        if (numEntriesSettled > 0) {\n            balanceAfter = tokenState.balanceOf(from);\n        }\n\n        // Reduce the value to transfer if balance is insufficient after reclaimed\n        value = value >= balanceAfter ? balanceAfter : value;\n\n        return _internalTransferFrom(from, to, value);\n    }\n\n    /**\n     * @notice _transferToFeeAddress function\n     * non-sUSD synths are exchanged into sUSD via synthInitiatedExchange\n     * notify feePool to record amount as fee paid to feePool */\n    function _transferToFeeAddress(address to, uint value) internal returns (bool) {\n        uint amountInUSD;\n\n        // sUSD can be transferred to FEE_ADDRESS directly\n        if (currencyKey == \"sUSD\") {\n            amountInUSD = value;\n            super._internalTransfer(messageSender, to, value);\n        } else {\n            // else exchange synth into sUSD and send to FEE_ADDRESS\n            (amountInUSD, ) = exchanger().exchange(\n                messageSender,\n                messageSender,\n                currencyKey,\n                value,\n                \"sUSD\",\n                FEE_ADDRESS,\n                false,\n                address(0),\n                bytes32(0)\n            );\n        }\n\n        // Notify feePool to record sUSD to distribute as fees\n        feePool().recordFeePaid(amountInUSD);\n\n        return true;\n    }\n\n    function issue(address account, uint amount) external onlyInternalContracts {\n        _internalIssue(account, amount);\n    }\n\n    function burn(address account, uint amount) external onlyInternalContracts {\n        _internalBurn(account, amount);\n    }\n\n    function _internalIssue(address account, uint amount) internal {\n        tokenState.setBalanceOf(account, tokenState.balanceOf(account).add(amount));\n        totalSupply = totalSupply.add(amount);\n        emitTransfer(address(0), account, amount);\n        emitIssued(account, amount);\n    }\n\n    function _internalBurn(address account, uint amount) internal returns (bool) {\n        tokenState.setBalanceOf(account, tokenState.balanceOf(account).sub(amount));\n        totalSupply = totalSupply.sub(amount);\n        emitTransfer(account, address(0), amount);\n        emitBurned(account, amount);\n\n        return true;\n    }\n\n    // Allow owner to set the total supply on import.\n    function setTotalSupply(uint amount) external optionalProxy_onlyOwner {\n        totalSupply = amount;\n    }\n\n    /* ========== VIEWS ========== */\n\n    // Note: use public visibility so that it can be invoked in a subclass\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        addresses = new bytes32[](5);\n        addresses[0] = CONTRACT_SYSTEMSTATUS;\n        addresses[1] = CONTRACT_EXCHANGER;\n        addresses[2] = CONTRACT_ISSUER;\n        addresses[3] = CONTRACT_FEEPOOL;\n        addresses[4] = CONTRACT_FUTURESMARKETMANAGER;\n    }\n\n    function systemStatus() internal view returns (ISystemStatus) {\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\n    }\n\n    function feePool() internal view returns (IFeePool) {\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));\n    }\n\n    function exchanger() internal view returns (IExchanger) {\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\n    }\n\n    function issuer() internal view returns (IIssuer) {\n        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));\n    }\n\n    function futuresMarketManager() internal view returns (IFuturesMarketManager) {\n        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));\n    }\n\n    function _ensureCanTransfer(address from, uint value) internal view {\n        require(exchanger().maxSecsLeftInWaitingPeriod(from, currencyKey) == 0, \"Cannot transfer during waiting period\");\n        require(transferableSynths(from) >= value, \"Insufficient balance after any settlement owing\");\n        systemStatus().requireSynthActive(currencyKey);\n    }\n\n    function transferableSynths(address account) public view returns (uint) {\n        (uint reclaimAmount, , ) = exchanger().settlementOwing(account, currencyKey);\n\n        // Note: ignoring rebate amount here because a settle() is required in order to\n        // allow the transfer to actually work\n\n        uint balance = tokenState.balanceOf(account);\n\n        if (reclaimAmount > balance) {\n            return 0;\n        } else {\n            return balance.sub(reclaimAmount);\n        }\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _internalTransferFrom(\n        address from,\n        address to,\n        uint value\n    ) internal returns (bool) {\n        // Skip allowance update in case of infinite allowance\n        if (tokenState.allowance(from, messageSender) != uint(-1)) {\n            // Reduce the allowance by the amount we're transferring.\n            // The safeSub call will handle an insufficient allowance.\n            tokenState.setAllowance(from, messageSender, tokenState.allowance(from, messageSender).sub(value));\n        }\n\n        return super._internalTransfer(from, to, value);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    function _isInternalContract(address account) internal view returns (bool) {\n        return\n            account == address(feePool()) ||\n            account == address(exchanger()) ||\n            account == address(issuer()) ||\n            account == address(futuresMarketManager());\n    }\n\n    modifier onlyInternalContracts() {\n        require(_isInternalContract(msg.sender), \"Only internal contracts allowed\");\n        _;\n    }\n\n    modifier onlyProxyOrInternal {\n        _onlyProxyOrInternal();\n        _;\n    }\n\n    function _onlyProxyOrInternal() internal {\n        if (msg.sender == address(proxy)) {\n            // allow proxy through, messageSender should be already set correctly\n            return;\n        } else if (_isInternalTransferCaller(msg.sender)) {\n            // optionalProxy behaviour only for the internal legacy contracts\n            messageSender = msg.sender;\n        } else {\n            revert(\"Only the proxy can call\");\n        }\n    }\n\n    /// some legacy internal contracts use transfer methods directly on implementation\n    /// which isn't supported due to SIP-238 for other callers\n    function _isInternalTransferCaller(address caller) internal view returns (bool) {\n        // These entries are not required or cached in order to allow them to not exist (==address(0))\n        // e.g. due to not being available on L2 or at some future point in time.\n        return\n            // ordered to reduce gas for more frequent calls\n            caller == resolver.getAddress(\"CollateralShort\") ||\n            // not used frequently\n            caller == resolver.getAddress(\"SynthRedeemer\") ||\n            caller == resolver.getAddress(\"WrapperFactory\") || // transfer not used by users\n            // legacy\n            caller == resolver.getAddress(\"NativeEtherWrapper\") ||\n            caller == resolver.getAddress(\"Depot\");\n    }\n\n    /* ========== EVENTS ========== */\n    event Issued(address indexed account, uint value);\n\n    bytes32 private constant ISSUED_SIG = keccak256(\"Issued(address,uint256)\");\n\n    function emitIssued(address account, uint value) internal {\n        proxy._emit(abi.encode(value), 2, ISSUED_SIG, addressToBytes32(account), 0, 0);\n    }\n\n    event Burned(address indexed account, uint value);\n\n    bytes32 private constant BURNED_SIG = keccak256(\"Burned(address,uint256)\");\n\n    function emitBurned(address account, uint value) internal {\n        proxy._emit(abi.encode(value), 2, BURNED_SIG, addressToBytes32(account), 0, 0);\n    }\n}\n\n\ninterface IWETH {\n    // ERC20 Optional Views\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    // Views\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    // Mutative functions\n    function transfer(address to, uint value) external returns (bool);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // WETH-specific functions.\n    function deposit() external payable;\n\n    function withdraw(uint amount) external;\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Deposit(address indexed to, uint amount);\n    event Withdrawal(address indexed to, uint amount);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ietherwrapper\ncontract IEtherWrapper {\n    function mint(uint amount) external;\n\n    function burn(uint amount) external;\n\n    function distributeFees() external;\n\n    function capacity() external view returns (uint);\n\n    function getReserves() external view returns (uint);\n\n    function totalIssuedSynths() external view returns (uint);\n\n    function calculateMintFee(uint amount) public view returns (uint);\n\n    function calculateBurnFee(uint amount) public view returns (uint);\n\n    function maxETH() public view returns (uint256);\n\n    function mintFeeRate() public view returns (uint256);\n\n    function burnFeeRate() public view returns (uint256);\n\n    function weth() public view returns (IWETH);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iwrapperfactory\ninterface IWrapperFactory {\n    function isWrapper(address possibleWrapper) external view returns (bool);\n\n    function createWrapper(\n        IERC20 token,\n        bytes32 currencyKey,\n        bytes32 synthContractName\n    ) external returns (address);\n\n    function distributeFees() external;\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/multicollateralsynth\ncontract MultiCollateralSynth is Synth {\n    bytes32 public constant CONTRACT_NAME = \"MultiCollateralSynth\";\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_COLLATERALMANAGER = \"CollateralManager\";\n    bytes32 private constant CONTRACT_ETHER_WRAPPER = \"EtherWrapper\";\n    bytes32 private constant CONTRACT_WRAPPER_FACTORY = \"WrapperFactory\";\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address payable _proxy,\n        TokenState _tokenState,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        address _owner,\n        bytes32 _currencyKey,\n        uint _totalSupply,\n        address _resolver\n    ) public Synth(_proxy, _tokenState, _tokenName, _tokenSymbol, _owner, _currencyKey, _totalSupply, _resolver) {}\n\n    /* ========== VIEWS ======================= */\n\n    function collateralManager() internal view returns (ICollateralManager) {\n        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));\n    }\n\n    function etherWrapper() internal view returns (IEtherWrapper) {\n        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));\n    }\n\n    function wrapperFactory() internal view returns (IWrapperFactory) {\n        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));\n    }\n\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        bytes32[] memory existingAddresses = Synth.resolverAddressesRequired();\n        bytes32[] memory newAddresses = new bytes32[](3);\n        newAddresses[0] = CONTRACT_COLLATERALMANAGER;\n        newAddresses[1] = CONTRACT_ETHER_WRAPPER;\n        newAddresses[2] = CONTRACT_WRAPPER_FACTORY;\n        addresses = combineArrays(existingAddresses, newAddresses);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Function that allows multi Collateral to issue a certain number of synths from an account.\n     * @param account Account to issue synths to\n     * @param amount Number of synths\n     */\n    function issue(address account, uint amount) external onlyInternalContracts {\n        super._internalIssue(account, amount);\n    }\n\n    /**\n     * @notice Function that allows multi Collateral to burn a certain number of synths from an account.\n     * @param account Account to burn synths from\n     * @param amount Number of synths\n     */\n    function burn(address account, uint amount) external onlyInternalContracts {\n        super._internalBurn(account, amount);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    // overriding modifier from super to add more internal contracts and checks\n    function _isInternalContract(address account) internal view returns (bool) {\n        return\n            super._isInternalContract(account) ||\n            collateralManager().hasCollateral(account) ||\n            wrapperFactory().isWrapper(account) ||\n            (account == address(etherWrapper()));\n    }\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/proxyerc20\ncontract ProxyERC20 is Proxy, IERC20 {\n    constructor(address _owner) public Proxy(_owner) {}\n\n    // ------------- ERC20 Details ------------- //\n\n    function name() public view returns (string memory) {\n        // Immutable static call from target contract\n        return IERC20(address(target)).name();\n    }\n\n    function symbol() public view returns (string memory) {\n        // Immutable static call from target contract\n        return IERC20(address(target)).symbol();\n    }\n\n    function decimals() public view returns (uint8) {\n        // Immutable static call from target contract\n        return IERC20(address(target)).decimals();\n    }\n\n    // ------------- ERC20 Interface ------------- //\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view returns (uint256) {\n        // Immutable static call from target contract\n        return IERC20(address(target)).totalSupply();\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param account The address to query the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        // Immutable static call from target contract\n        return IERC20(address(target)).balanceOf(account);\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        // Immutable static call from target contract\n        return IERC20(address(target)).allowance(owner, spender);\n    }\n\n    /**\n     * @dev Transfer token for a specified address\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function transfer(address to, uint256 value) public returns (bool) {\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\n        target.setMessageSender(msg.sender);\n\n        // Forward the ERC20 call to the target contract\n        IERC20(address(target)).transfer(to, value);\n\n        // Event emitting will occur via Synthetix.Proxy._emit()\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\n        target.setMessageSender(msg.sender);\n\n        // Forward the ERC20 call to the target contract\n        IERC20(address(target)).approve(spender, value);\n\n        // Event emitting will occur via Synthetix.Proxy._emit()\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public returns (bool) {\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\n        target.setMessageSender(msg.sender);\n\n        // Forward the ERC20 call to the target contract\n        IERC20(address(target)).transferFrom(from, to, value);\n\n        // Event emitting will occur via Synthetix.Proxy._emit()\n        return true;\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/irewardescrow\ninterface IRewardEscrow {\n    // Views\n    function balanceOf(address account) external view returns (uint);\n\n    function numVestingEntries(address account) external view returns (uint);\n\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\n\n    function totalVestedAccountBalance(address account) external view returns (uint);\n\n    function getVestingScheduleEntry(address account, uint index) external view returns (uint[2] memory);\n\n    function getNextVestingIndex(address account) external view returns (uint);\n\n    // Mutative functions\n    function appendVestingEntry(address account, uint quantity) external;\n\n    function vest() external;\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/rewardescrow\ncontract RewardEscrow is Owned, IRewardEscrow {\n    using SafeMath for uint;\n\n    /* The corresponding Synthetix contract. */\n    ISynthetix public synthetix;\n\n    IFeePool public feePool;\n\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\n     * These are the times at which each given quantity of SNX vests. */\n    mapping(address => uint[2][]) public vestingSchedules;\n\n    /* An account's total escrowed synthetix balance to save recomputing this for fee extraction purposes. */\n    mapping(address => uint) public totalEscrowedAccountBalance;\n\n    /* An account's total vested reward synthetix. */\n    mapping(address => uint) public totalVestedAccountBalance;\n\n    /* The total remaining escrowed balance, for verifying the actual synthetix balance of this contract against. */\n    uint public totalEscrowedBalance;\n\n    uint internal constant TIME_INDEX = 0;\n    uint internal constant QUANTITY_INDEX = 1;\n\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules.\n     * There are 5 years of the supply schedule */\n    uint public constant MAX_VESTING_ENTRIES = 52 * 5;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        ISynthetix _synthetix,\n        IFeePool _feePool\n    ) public Owned(_owner) {\n        synthetix = _synthetix;\n        feePool = _feePool;\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice set the synthetix contract address as we need to transfer SNX when the user vests\n     */\n    function setSynthetix(ISynthetix _synthetix) external onlyOwner {\n        synthetix = _synthetix;\n        emit SynthetixUpdated(address(_synthetix));\n    }\n\n    /**\n     * @notice set the FeePool contract as it is the only authority to be able to call\n     * appendVestingEntry with the onlyFeePool modifer\n     */\n    function setFeePool(IFeePool _feePool) external onlyOwner {\n        feePool = _feePool;\n        emit FeePoolUpdated(address(_feePool));\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\n     */\n    function balanceOf(address account) public view returns (uint) {\n        return totalEscrowedAccountBalance[account];\n    }\n\n    function _numVestingEntries(address account) internal view returns (uint) {\n        return vestingSchedules[account].length;\n    }\n\n    /**\n     * @notice The number of vesting dates in an account's schedule.\n     */\n    function numVestingEntries(address account) external view returns (uint) {\n        return vestingSchedules[account].length;\n    }\n\n    /**\n     * @notice Get a particular schedule entry for an account.\n     * @return A pair of uints: (timestamp, synthetix quantity).\n     */\n    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {\n        return vestingSchedules[account][index];\n    }\n\n    /**\n     * @notice Get the time at which a given schedule entry will vest.\n     */\n    function getVestingTime(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Get the quantity of SNX associated with a given schedule entry.\n     */\n    function getVestingQuantity(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\n     */\n    function getNextVestingIndex(address account) public view returns (uint) {\n        uint len = _numVestingEntries(account);\n        for (uint i = 0; i < len; i++) {\n            if (getVestingTime(account, i) != 0) {\n                return i;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * @notice Obtain the next schedule entry that will vest for a given user.\n     * @return A pair of uints: (timestamp, synthetix quantity). */\n    function getNextVestingEntry(address account) public view returns (uint[2] memory) {\n        uint index = getNextVestingIndex(account);\n        if (index == _numVestingEntries(account)) {\n            return [uint(0), 0];\n        }\n        return getVestingScheduleEntry(account, index);\n    }\n\n    /**\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingTime(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingQuantity(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice return the full vesting schedule entries vest for a given user.\n     * @dev For DApps to display the vesting schedule for the\n     * inflationary supply over 5 years. Solidity cant return variable length arrays\n     * so this is returning pairs of data. Vesting Time at [0] and quantity at [1] and so on\n     */\n    function checkAccountSchedule(address account) public view returns (uint[520] memory) {\n        uint[520] memory _result;\n        uint schedules = _numVestingEntries(account);\n        for (uint i = 0; i < schedules; i++) {\n            uint[2] memory pair = getVestingScheduleEntry(account, i);\n            _result[i * 2] = pair[0];\n            _result[i * 2 + 1] = pair[1];\n        }\n        return _result;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function _appendVestingEntry(address account, uint quantity) internal {\n        /* No empty or already-passed vesting entries allowed. */\n        require(quantity != 0, \"Quantity cannot be zero\");\n\n        /* There must be enough balance in the contract to provide for the vesting entry. */\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\n        require(\n            totalEscrowedBalance <= IERC20(address(synthetix)).balanceOf(address(this)),\n            \"Must be enough balance in the contract to provide for the vesting entry\"\n        );\n\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\n        uint scheduleLength = vestingSchedules[account].length;\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \"Vesting schedule is too long\");\n\n        /* Escrow the tokens for 1 year. */\n        uint time = now + 52 weeks;\n\n        if (scheduleLength == 0) {\n            totalEscrowedAccountBalance[account] = quantity;\n        } else {\n            /* Disallow adding new vested SNX earlier than the last one.\n             * Since entries are only appended, this means that no vesting date can be repeated. */\n            require(\n                getVestingTime(account, scheduleLength - 1) < time,\n                \"Cannot add new vested entries earlier than the last one\"\n            );\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);\n        }\n\n        vestingSchedules[account].push([time, quantity]);\n\n        emit VestingEntryCreated(account, now, quantity);\n    }\n\n    /**\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\n     * @dev A call to this should accompany a previous successful call to synthetix.transfer(rewardEscrow, amount),\n     * to ensure that when the funds are withdrawn, there is enough balance.\n     * Note; although this function could technically be used to produce unbounded\n     * arrays, it's only withinn the 4 year period of the weekly inflation schedule.\n     * @param account The account to append a new vesting entry to.\n     * @param quantity The quantity of SNX that will be escrowed.\n     */\n    function appendVestingEntry(address account, uint quantity) external onlyFeePool {\n        _appendVestingEntry(account, quantity);\n    }\n\n    /**\n     * @notice Allow a user to withdraw any SNX in their schedule that have vested.\n     */\n    function vest() external {\n        uint numEntries = _numVestingEntries(msg.sender);\n        uint total;\n        for (uint i = 0; i < numEntries; i++) {\n            uint time = getVestingTime(msg.sender, i);\n            /* The list is sorted; when we reach the first future time, bail out. */\n            if (time > now) {\n                break;\n            }\n            uint qty = getVestingQuantity(msg.sender, i);\n            if (qty > 0) {\n                vestingSchedules[msg.sender][i] = [0, 0];\n                total = total.add(qty);\n            }\n        }\n\n        if (total != 0) {\n            totalEscrowedBalance = totalEscrowedBalance.sub(total);\n            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);\n            IERC20(address(synthetix)).transfer(msg.sender, total);\n            emit Vested(msg.sender, now, total);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyFeePool() {\n        bool isFeePool = msg.sender == address(feePool);\n\n        require(isFeePool, \"Only the FeePool contracts can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SynthetixUpdated(address newSynthetix);\n\n    event FeePoolUpdated(address newFeePool);\n\n    event Vested(address indexed beneficiary, uint time, uint value);\n\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/irewardsdistribution\ninterface IRewardsDistribution {\n    // Structs\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    // Views\n    function authority() external view returns (address);\n\n    function distributions(uint index) external view returns (address destination, uint amount); // DistributionData\n\n    function distributionsLength() external view returns (uint);\n\n    // Mutative Functions\n    function distributeRewards(uint amount) external returns (bool);\n}\n\n\n// Inheritance\n\n\n// Libraires\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/rewardsdistribution\ncontract RewardsDistribution is Owned, IRewardsDistribution {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the authority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    function distributeRewards(uint amount) external returns (bool) {\n        require(amount > 0, \"Nothing to distribute\");\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(\n            IERC20(synthetixProxy).balanceOf(address(this)) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n\n                // solhint-disable avoid-low-level-calls\n                (bool success, ) = distributions[i].destination.call(payload);\n\n                if (!success) {\n                    // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n                }\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/systemstatus\ncontract SystemStatus is Owned, ISystemStatus {\n    mapping(bytes32 => mapping(address => Status)) public accessControl;\n\n    uint248 public constant SUSPENSION_REASON_UPGRADE = 1;\n\n    bytes32 public constant SECTION_SYSTEM = \"System\";\n    bytes32 public constant SECTION_ISSUANCE = \"Issuance\";\n    bytes32 public constant SECTION_EXCHANGE = \"Exchange\";\n    bytes32 public constant SECTION_FUTURES = \"Futures\";\n    bytes32 public constant SECTION_SYNTH_EXCHANGE = \"SynthExchange\";\n    bytes32 public constant SECTION_SYNTH = \"Synth\";\n\n    bytes32 public constant CONTRACT_NAME = \"SystemStatus\";\n\n    Suspension public systemSuspension;\n\n    Suspension public issuanceSuspension;\n\n    Suspension public exchangeSuspension;\n\n    Suspension public futuresSuspension;\n\n    mapping(bytes32 => Suspension) public synthExchangeSuspension;\n\n    mapping(bytes32 => Suspension) public synthSuspension;\n\n    mapping(bytes32 => Suspension) public futuresMarketSuspension;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== VIEWS ========== */\n    function requireSystemActive() external view {\n        _internalRequireSystemActive();\n    }\n\n    function systemSuspended() external view returns (bool) {\n        return systemSuspension.suspended;\n    }\n\n    function requireIssuanceActive() external view {\n        // Issuance requires the system be active\n        _internalRequireSystemActive();\n\n        // and issuance itself of course\n        _internalRequireIssuanceActive();\n    }\n\n    function requireExchangeActive() external view {\n        // Exchanging requires the system be active\n        _internalRequireSystemActive();\n\n        // and exchanging itself of course\n        _internalRequireExchangeActive();\n    }\n\n    function requireSynthExchangeActive(bytes32 currencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n        _internalRequireSynthExchangeActive(currencyKey);\n    }\n\n    function requireFuturesActive() external view {\n        _internalRequireSystemActive();\n        _internalRequireExchangeActive();\n        _internalRequireFuturesActive();\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function requireFuturesMarketActive(bytes32 marketKey) external view {\n        _internalRequireSystemActive();\n        _internalRequireExchangeActive(); // exchanging implicitely used\n        _internalRequireFuturesActive(); // futures global flag\n        _internalRequireFuturesMarketActive(marketKey); // specific futures market flag\n    }\n\n    function synthSuspended(bytes32 currencyKey) external view returns (bool) {\n        return systemSuspension.suspended || synthSuspension[currencyKey].suspended;\n    }\n\n    function requireSynthActive(bytes32 currencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n        _internalRequireSynthActive(currencyKey);\n    }\n\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n        _internalRequireSynthActive(sourceCurrencyKey);\n        _internalRequireSynthActive(destinationCurrencyKey);\n    }\n\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n\n        // and exchanging must be active\n        _internalRequireExchangeActive();\n\n        // and the synth exchanging between the synths must be active\n        _internalRequireSynthExchangeActive(sourceCurrencyKey);\n        _internalRequireSynthExchangeActive(destinationCurrencyKey);\n\n        // and finally, the synths cannot be suspended\n        _internalRequireSynthActive(sourceCurrencyKey);\n        _internalRequireSynthActive(destinationCurrencyKey);\n    }\n\n    function isSystemUpgrading() external view returns (bool) {\n        return systemSuspension.suspended && systemSuspension.reason == SUSPENSION_REASON_UPGRADE;\n    }\n\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons)\n    {\n        exchangeSuspensions = new bool[](synths.length);\n        reasons = new uint256[](synths.length);\n\n        for (uint i = 0; i < synths.length; i++) {\n            exchangeSuspensions[i] = synthExchangeSuspension[synths[i]].suspended;\n            reasons[i] = synthExchangeSuspension[synths[i]].reason;\n        }\n    }\n\n    function getSynthSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons)\n    {\n        suspensions = new bool[](synths.length);\n        reasons = new uint256[](synths.length);\n\n        for (uint i = 0; i < synths.length; i++) {\n            suspensions[i] = synthSuspension[synths[i]].suspended;\n            reasons[i] = synthSuspension[synths[i]].reason;\n        }\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function getFuturesMarketSuspensions(bytes32[] calldata marketKeys)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons)\n    {\n        suspensions = new bool[](marketKeys.length);\n        reasons = new uint256[](marketKeys.length);\n\n        for (uint i = 0; i < marketKeys.length; i++) {\n            suspensions[i] = futuresMarketSuspension[marketKeys[i]].suspended;\n            reasons[i] = futuresMarketSuspension[marketKeys[i]].reason;\n        }\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n    function updateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) external onlyOwner {\n        _internalUpdateAccessControl(section, account, canSuspend, canResume);\n    }\n\n    function updateAccessControls(\n        bytes32[] calldata sections,\n        address[] calldata accounts,\n        bool[] calldata canSuspends,\n        bool[] calldata canResumes\n    ) external onlyOwner {\n        require(\n            sections.length == accounts.length &&\n                accounts.length == canSuspends.length &&\n                canSuspends.length == canResumes.length,\n            \"Input array lengths must match\"\n        );\n        for (uint i = 0; i < sections.length; i++) {\n            _internalUpdateAccessControl(sections[i], accounts[i], canSuspends[i], canResumes[i]);\n        }\n    }\n\n    function suspendSystem(uint256 reason) external {\n        _requireAccessToSuspend(SECTION_SYSTEM);\n        systemSuspension.suspended = true;\n        systemSuspension.reason = uint248(reason);\n        emit SystemSuspended(systemSuspension.reason);\n    }\n\n    function resumeSystem() external {\n        _requireAccessToResume(SECTION_SYSTEM);\n        systemSuspension.suspended = false;\n        emit SystemResumed(uint256(systemSuspension.reason));\n        systemSuspension.reason = 0;\n    }\n\n    function suspendIssuance(uint256 reason) external {\n        _requireAccessToSuspend(SECTION_ISSUANCE);\n        issuanceSuspension.suspended = true;\n        issuanceSuspension.reason = uint248(reason);\n        emit IssuanceSuspended(reason);\n    }\n\n    function resumeIssuance() external {\n        _requireAccessToResume(SECTION_ISSUANCE);\n        issuanceSuspension.suspended = false;\n        emit IssuanceResumed(uint256(issuanceSuspension.reason));\n        issuanceSuspension.reason = 0;\n    }\n\n    function suspendExchange(uint256 reason) external {\n        _requireAccessToSuspend(SECTION_EXCHANGE);\n        exchangeSuspension.suspended = true;\n        exchangeSuspension.reason = uint248(reason);\n        emit ExchangeSuspended(reason);\n    }\n\n    function resumeExchange() external {\n        _requireAccessToResume(SECTION_EXCHANGE);\n        exchangeSuspension.suspended = false;\n        emit ExchangeResumed(uint256(exchangeSuspension.reason));\n        exchangeSuspension.reason = 0;\n    }\n\n    function suspendFutures(uint256 reason) external {\n        _requireAccessToSuspend(SECTION_FUTURES);\n        futuresSuspension.suspended = true;\n        futuresSuspension.reason = uint248(reason);\n        emit FuturesSuspended(reason);\n    }\n\n    function resumeFutures() external {\n        _requireAccessToResume(SECTION_FUTURES);\n        futuresSuspension.suspended = false;\n        emit FuturesResumed(uint256(futuresSuspension.reason));\n        futuresSuspension.reason = 0;\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function suspendFuturesMarket(bytes32 marketKey, uint256 reason) external {\n        bytes32[] memory marketKeys = new bytes32[](1);\n        marketKeys[0] = marketKey;\n        _internalSuspendFuturesMarkets(marketKeys, reason);\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function suspendFuturesMarkets(bytes32[] calldata marketKeys, uint256 reason) external {\n        _internalSuspendFuturesMarkets(marketKeys, reason);\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function resumeFuturesMarket(bytes32 marketKey) external {\n        bytes32[] memory marketKeys = new bytes32[](1);\n        marketKeys[0] = marketKey;\n        _internalResumeFuturesMarkets(marketKeys);\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function resumeFuturesMarkets(bytes32[] calldata marketKeys) external {\n        _internalResumeFuturesMarkets(marketKeys);\n    }\n\n    function suspendSynthExchange(bytes32 currencyKey, uint256 reason) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalSuspendSynthExchange(currencyKeys, reason);\n    }\n\n    function suspendSynthsExchange(bytes32[] calldata currencyKeys, uint256 reason) external {\n        _internalSuspendSynthExchange(currencyKeys, reason);\n    }\n\n    function resumeSynthExchange(bytes32 currencyKey) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalResumeSynthsExchange(currencyKeys);\n    }\n\n    function resumeSynthsExchange(bytes32[] calldata currencyKeys) external {\n        _internalResumeSynthsExchange(currencyKeys);\n    }\n\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalSuspendSynths(currencyKeys, reason);\n    }\n\n    function suspendSynths(bytes32[] calldata currencyKeys, uint256 reason) external {\n        _internalSuspendSynths(currencyKeys, reason);\n    }\n\n    function resumeSynth(bytes32 currencyKey) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalResumeSynths(currencyKeys);\n    }\n\n    function resumeSynths(bytes32[] calldata currencyKeys) external {\n        _internalResumeSynths(currencyKeys);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _requireAccessToSuspend(bytes32 section) internal view {\n        require(accessControl[section][msg.sender].canSuspend, \"Restricted to access control list\");\n    }\n\n    function _requireAccessToResume(bytes32 section) internal view {\n        require(accessControl[section][msg.sender].canResume, \"Restricted to access control list\");\n    }\n\n    function _internalRequireSystemActive() internal view {\n        require(\n            !systemSuspension.suspended,\n            systemSuspension.reason == SUSPENSION_REASON_UPGRADE\n                ? \"Synthetix is suspended, upgrade in progress... please stand by\"\n                : \"Synthetix is suspended. Operation prohibited\"\n        );\n    }\n\n    function _internalRequireIssuanceActive() internal view {\n        require(!issuanceSuspension.suspended, \"Issuance is suspended. Operation prohibited\");\n    }\n\n    function _internalRequireExchangeActive() internal view {\n        require(!exchangeSuspension.suspended, \"Exchange is suspended. Operation prohibited\");\n    }\n\n    function _internalRequireFuturesActive() internal view {\n        require(!futuresSuspension.suspended, \"Futures markets are suspended. Operation prohibited\");\n    }\n\n    function _internalRequireSynthExchangeActive(bytes32 currencyKey) internal view {\n        require(!synthExchangeSuspension[currencyKey].suspended, \"Synth exchange suspended. Operation prohibited\");\n    }\n\n    function _internalRequireSynthActive(bytes32 currencyKey) internal view {\n        require(!synthSuspension[currencyKey].suspended, \"Synth is suspended. Operation prohibited\");\n    }\n\n    function _internalRequireFuturesMarketActive(bytes32 marketKey) internal view {\n        require(!futuresMarketSuspension[marketKey].suspended, \"Market suspended\");\n    }\n\n    function _internalSuspendSynths(bytes32[] memory currencyKeys, uint256 reason) internal {\n        _requireAccessToSuspend(SECTION_SYNTH);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            synthSuspension[currencyKey].suspended = true;\n            synthSuspension[currencyKey].reason = uint248(reason);\n            emit SynthSuspended(currencyKey, reason);\n        }\n    }\n\n    function _internalResumeSynths(bytes32[] memory currencyKeys) internal {\n        _requireAccessToResume(SECTION_SYNTH);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            emit SynthResumed(currencyKey, uint256(synthSuspension[currencyKey].reason));\n            delete synthSuspension[currencyKey];\n        }\n    }\n\n    function _internalSuspendSynthExchange(bytes32[] memory currencyKeys, uint256 reason) internal {\n        _requireAccessToSuspend(SECTION_SYNTH_EXCHANGE);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            synthExchangeSuspension[currencyKey].suspended = true;\n            synthExchangeSuspension[currencyKey].reason = uint248(reason);\n            emit SynthExchangeSuspended(currencyKey, reason);\n        }\n    }\n\n    function _internalResumeSynthsExchange(bytes32[] memory currencyKeys) internal {\n        _requireAccessToResume(SECTION_SYNTH_EXCHANGE);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            emit SynthExchangeResumed(currencyKey, uint256(synthExchangeSuspension[currencyKey].reason));\n            delete synthExchangeSuspension[currencyKey];\n        }\n    }\n\n    function _internalSuspendFuturesMarkets(bytes32[] memory marketKeys, uint256 reason) internal {\n        _requireAccessToSuspend(SECTION_FUTURES);\n        for (uint i = 0; i < marketKeys.length; i++) {\n            bytes32 marketKey = marketKeys[i];\n            futuresMarketSuspension[marketKey].suspended = true;\n            futuresMarketSuspension[marketKey].reason = uint248(reason);\n            emit FuturesMarketSuspended(marketKey, reason);\n        }\n    }\n\n    function _internalResumeFuturesMarkets(bytes32[] memory marketKeys) internal {\n        _requireAccessToResume(SECTION_FUTURES);\n        for (uint i = 0; i < marketKeys.length; i++) {\n            bytes32 marketKey = marketKeys[i];\n            emit FuturesMarketResumed(marketKey, uint256(futuresMarketSuspension[marketKey].reason));\n            delete futuresMarketSuspension[marketKey];\n        }\n    }\n\n    function _internalUpdateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) internal {\n        require(\n            section == SECTION_SYSTEM ||\n                section == SECTION_ISSUANCE ||\n                section == SECTION_EXCHANGE ||\n                section == SECTION_FUTURES ||\n                section == SECTION_SYNTH_EXCHANGE ||\n                section == SECTION_SYNTH,\n            \"Invalid section supplied\"\n        );\n        accessControl[section][account].canSuspend = canSuspend;\n        accessControl[section][account].canResume = canResume;\n        emit AccessControlUpdated(section, account, canSuspend, canResume);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SystemSuspended(uint256 reason);\n    event SystemResumed(uint256 reason);\n\n    event IssuanceSuspended(uint256 reason);\n    event IssuanceResumed(uint256 reason);\n\n    event ExchangeSuspended(uint256 reason);\n    event ExchangeResumed(uint256 reason);\n\n    event FuturesSuspended(uint256 reason);\n    event FuturesResumed(uint256 reason);\n\n    event SynthExchangeSuspended(bytes32 currencyKey, uint256 reason);\n    event SynthExchangeResumed(bytes32 currencyKey, uint256 reason);\n\n    event SynthSuspended(bytes32 currencyKey, uint256 reason);\n    event SynthResumed(bytes32 currencyKey, uint256 reason);\n\n    event FuturesMarketSuspended(bytes32 marketKey, uint256 reason);\n    event FuturesMarketResumed(bytes32 marketKey, uint256 reason);\n\n    event AccessControlUpdated(bytes32 indexed section, address indexed account, bool canSuspend, bool canResume);\n}\n\n\ninterface ISynthetixNamedContract {\n    // solhint-disable func-name-mixedcase\n    function CONTRACT_NAME() external view returns (bytes32);\n}\n\n// solhint-disable contract-name-camelcase\ncontract Migration_Saiph is BaseMigration {\n    // https://etherscan.io/address/0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\n    address public constant OWNER = 0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\n\n    // ----------------------------\n    // EXISTING SYNTHETIX CONTRACTS\n    // ----------------------------\n\n    // https://etherscan.io/address/0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83\n    AddressResolver public constant addressresolver_i = AddressResolver(0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83);\n    // https://etherscan.io/address/0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F\n    Proxy public constant proxysynthetix_i = Proxy(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F);\n    // https://etherscan.io/address/0x696c905F8F8c006cA46e9808fE7e00049507798F\n    SystemStatus public constant systemstatus_i = SystemStatus(0x696c905F8F8c006cA46e9808fE7e00049507798F);\n    // https://etherscan.io/address/0x5b1b5fEa1b99D83aD479dF0C222F0492385381dD\n    LegacyTokenState public constant tokenstatesynthetix_i = LegacyTokenState(0x5b1b5fEa1b99D83aD479dF0C222F0492385381dD);\n    // https://etherscan.io/address/0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F\n    RewardEscrow public constant rewardescrow_i = RewardEscrow(0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F);\n    // https://etherscan.io/address/0x29C295B046a73Cde593f21f63091B072d407e3F2\n    RewardsDistribution public constant rewardsdistribution_i =\n        RewardsDistribution(0x29C295B046a73Cde593f21f63091B072d407e3F2);\n    // https://etherscan.io/address/0x10A5F7D9D65bCc2734763444D4940a31b109275f\n    MultiCollateralSynth public constant synthsusd_i = MultiCollateralSynth(0x10A5F7D9D65bCc2734763444D4940a31b109275f);\n    // https://etherscan.io/address/0x05a9CBe762B36632b3594DA4F082340E0e5343e8\n    TokenState public constant tokenstatesusd_i = TokenState(0x05a9CBe762B36632b3594DA4F082340E0e5343e8);\n    // https://etherscan.io/address/0x57Ab1ec28D129707052df4dF418D58a2D46d5f51\n    Proxy public constant proxysusd_i = Proxy(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51);\n    // https://etherscan.io/address/0xa8E31E3C38aDD6052A9407298FAEB8fD393A6cF9\n    MultiCollateralSynth public constant synthseur_i = MultiCollateralSynth(0xa8E31E3C38aDD6052A9407298FAEB8fD393A6cF9);\n    // https://etherscan.io/address/0x6568D9e750fC44AF00f857885Dfb8281c00529c4\n    TokenState public constant tokenstateseur_i = TokenState(0x6568D9e750fC44AF00f857885Dfb8281c00529c4);\n    // https://etherscan.io/address/0xD71eCFF9342A5Ced620049e616c5035F1dB98620\n    ProxyERC20 public constant proxyseur_i = ProxyERC20(0xD71eCFF9342A5Ced620049e616c5035F1dB98620);\n    // https://etherscan.io/address/0xE1cc2332852B2Ac0dA59A1f9D3051829f4eF3c1C\n    MultiCollateralSynth public constant synthsjpy_i = MultiCollateralSynth(0xE1cc2332852B2Ac0dA59A1f9D3051829f4eF3c1C);\n    // https://etherscan.io/address/0x4dFACfB15514C21c991ff75Bc7Bf6Fb1F98361ed\n    TokenState public constant tokenstatesjpy_i = TokenState(0x4dFACfB15514C21c991ff75Bc7Bf6Fb1F98361ed);\n    // https://etherscan.io/address/0xF6b1C627e95BFc3c1b4c9B825a032Ff0fBf3e07d\n    ProxyERC20 public constant proxysjpy_i = ProxyERC20(0xF6b1C627e95BFc3c1b4c9B825a032Ff0fBf3e07d);\n    // https://etherscan.io/address/0xfb020CA7f4e8C4a5bBBe060f59a249c6275d2b69\n    MultiCollateralSynth public constant synthsaud_i = MultiCollateralSynth(0xfb020CA7f4e8C4a5bBBe060f59a249c6275d2b69);\n    // https://etherscan.io/address/0xCb29D2cf2C65d3Be1d00F07f3441390432D55203\n    TokenState public constant tokenstatesaud_i = TokenState(0xCb29D2cf2C65d3Be1d00F07f3441390432D55203);\n    // https://etherscan.io/address/0xF48e200EAF9906362BB1442fca31e0835773b8B4\n    ProxyERC20 public constant proxysaud_i = ProxyERC20(0xF48e200EAF9906362BB1442fca31e0835773b8B4);\n    // https://etherscan.io/address/0xdc883b9d9Ee16f74bE08826E68dF4C9D9d26e8bD\n    MultiCollateralSynth public constant synthsgbp_i = MultiCollateralSynth(0xdc883b9d9Ee16f74bE08826E68dF4C9D9d26e8bD);\n    // https://etherscan.io/address/0x7e88D19A79b291cfE5696d496055f7e57F537A75\n    TokenState public constant tokenstatesgbp_i = TokenState(0x7e88D19A79b291cfE5696d496055f7e57F537A75);\n    // https://etherscan.io/address/0x97fe22E7341a0Cd8Db6F6C021A24Dc8f4DAD855F\n    ProxyERC20 public constant proxysgbp_i = ProxyERC20(0x97fe22E7341a0Cd8Db6F6C021A24Dc8f4DAD855F);\n    // https://etherscan.io/address/0xBb5b03E920cF702De5A3bA9Fc1445aF4B3919c88\n    MultiCollateralSynth public constant synthschf_i = MultiCollateralSynth(0xBb5b03E920cF702De5A3bA9Fc1445aF4B3919c88);\n    // https://etherscan.io/address/0x52496fE8a4feaEFe14d9433E00D48E6929c13deC\n    TokenState public constant tokenstateschf_i = TokenState(0x52496fE8a4feaEFe14d9433E00D48E6929c13deC);\n    // https://etherscan.io/address/0x0F83287FF768D1c1e17a42F44d644D7F22e8ee1d\n    ProxyERC20 public constant proxyschf_i = ProxyERC20(0x0F83287FF768D1c1e17a42F44d644D7F22e8ee1d);\n    // https://etherscan.io/address/0xdAe6C79c46aB3B280Ca28259000695529cbD1339\n    MultiCollateralSynth public constant synthskrw_i = MultiCollateralSynth(0xdAe6C79c46aB3B280Ca28259000695529cbD1339);\n    // https://etherscan.io/address/0x93B6e9FbBd2c32a0DC3C2B943B7C3CBC2fE23730\n    TokenState public constant tokenstateskrw_i = TokenState(0x93B6e9FbBd2c32a0DC3C2B943B7C3CBC2fE23730);\n    // https://etherscan.io/address/0x269895a3dF4D73b077Fc823dD6dA1B95f72Aaf9B\n    ProxyERC20 public constant proxyskrw_i = ProxyERC20(0x269895a3dF4D73b077Fc823dD6dA1B95f72Aaf9B);\n    // https://etherscan.io/address/0x1cB004a8e84a5CE95C1fF895EE603BaC8EC506c7\n    MultiCollateralSynth public constant synthsbtc_i = MultiCollateralSynth(0x1cB004a8e84a5CE95C1fF895EE603BaC8EC506c7);\n    // https://etherscan.io/address/0x4F6296455F8d754c19821cF1EC8FeBF2cD456E67\n    TokenState public constant tokenstatesbtc_i = TokenState(0x4F6296455F8d754c19821cF1EC8FeBF2cD456E67);\n    // https://etherscan.io/address/0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6\n    ProxyERC20 public constant proxysbtc_i = ProxyERC20(0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6);\n    // https://etherscan.io/address/0x5D4C724BFe3a228Ff0E29125Ac1571FE093700a4\n    MultiCollateralSynth public constant synthseth_i = MultiCollateralSynth(0x5D4C724BFe3a228Ff0E29125Ac1571FE093700a4);\n    // https://etherscan.io/address/0x34A5ef81d18F3a305aE9C2d7DF42beef4c79031c\n    TokenState public constant tokenstateseth_i = TokenState(0x34A5ef81d18F3a305aE9C2d7DF42beef4c79031c);\n    // https://etherscan.io/address/0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb\n    ProxyERC20 public constant proxyseth_i = ProxyERC20(0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb);\n    // https://etherscan.io/address/0xDF69bC4541b86Aa4c5A470B4347E730c38b2c3B2\n    MultiCollateralSynth public constant synthslink_i = MultiCollateralSynth(0xDF69bC4541b86Aa4c5A470B4347E730c38b2c3B2);\n    // https://etherscan.io/address/0x577D4a7395c6A5f46d9981a5F83fa7294926aBB0\n    TokenState public constant tokenstateslink_i = TokenState(0x577D4a7395c6A5f46d9981a5F83fa7294926aBB0);\n    // https://etherscan.io/address/0xbBC455cb4F1B9e4bFC4B73970d360c8f032EfEE6\n    ProxyERC20 public constant proxyslink_i = ProxyERC20(0xbBC455cb4F1B9e4bFC4B73970d360c8f032EfEE6);\n    // https://etherscan.io/address/0x91b82d62Ff322b8e02b86f33E9A99a813437830d\n    MultiCollateralSynth public constant synthsada_i = MultiCollateralSynth(0x91b82d62Ff322b8e02b86f33E9A99a813437830d);\n    // https://etherscan.io/address/0x9956c5019a24fbd5B506AD070b771577bAc5c343\n    TokenState public constant tokenstatesada_i = TokenState(0x9956c5019a24fbd5B506AD070b771577bAc5c343);\n    // https://etherscan.io/address/0xe36E2D3c7c34281FA3bC737950a68571736880A1\n    ProxyERC20 public constant proxysada_i = ProxyERC20(0xe36E2D3c7c34281FA3bC737950a68571736880A1);\n    // https://etherscan.io/address/0x942Eb6e8c029EB22103743C99985aF4F4515a559\n    MultiCollateralSynth public constant synthsaave_i = MultiCollateralSynth(0x942Eb6e8c029EB22103743C99985aF4F4515a559);\n    // https://etherscan.io/address/0x9BcED8A8E3Ad81c9b146FFC880358f734A06f7c0\n    TokenState public constant tokenstatesaave_i = TokenState(0x9BcED8A8E3Ad81c9b146FFC880358f734A06f7c0);\n    // https://etherscan.io/address/0xd2dF355C19471c8bd7D8A3aa27Ff4e26A21b4076\n    ProxyERC20 public constant proxysaave_i = ProxyERC20(0xd2dF355C19471c8bd7D8A3aa27Ff4e26A21b4076);\n    // https://etherscan.io/address/0x75A0c1597137AA36B40b6a515D997F9a6c6eefEB\n    MultiCollateralSynth public constant synthsdot_i = MultiCollateralSynth(0x75A0c1597137AA36B40b6a515D997F9a6c6eefEB);\n    // https://etherscan.io/address/0x73B1a2643507Cd30F11Dfcf2D974f4373E5BC077\n    TokenState public constant tokenstatesdot_i = TokenState(0x73B1a2643507Cd30F11Dfcf2D974f4373E5BC077);\n    // https://etherscan.io/address/0x1715AC0743102BF5Cd58EfBB6Cf2dC2685d967b6\n    ProxyERC20 public constant proxysdot_i = ProxyERC20(0x1715AC0743102BF5Cd58EfBB6Cf2dC2685d967b6);\n    // https://etherscan.io/address/0x07C1E81C345A7c58d7c24072EFc5D929BD0647AD\n    MultiCollateralSynth public constant synthsethbtc_i = MultiCollateralSynth(0x07C1E81C345A7c58d7c24072EFc5D929BD0647AD);\n    // https://etherscan.io/address/0x042A7A0022A7695454ac5Be77a4860e50c9683fC\n    TokenState public constant tokenstatesethbtc_i = TokenState(0x042A7A0022A7695454ac5Be77a4860e50c9683fC);\n    // https://etherscan.io/address/0x104eDF1da359506548BFc7c25bA1E28C16a70235\n    ProxyERC20 public constant proxysethbtc_i = ProxyERC20(0x104eDF1da359506548BFc7c25bA1E28C16a70235);\n    // https://etherscan.io/address/0x918b1dbf0917FdD74D03fB9434915E2ECEc89286\n    MultiCollateralSynth public constant synthsdefi_i = MultiCollateralSynth(0x918b1dbf0917FdD74D03fB9434915E2ECEc89286);\n    // https://etherscan.io/address/0x7Ac2D37098a65B0f711CFfA3be635F1E6aCacFaB\n    TokenState public constant tokenstatesdefi_i = TokenState(0x7Ac2D37098a65B0f711CFfA3be635F1E6aCacFaB);\n    // https://etherscan.io/address/0xe1aFe1Fd76Fd88f78cBf599ea1846231B8bA3B6B\n    ProxyERC20 public constant proxysdefi_i = ProxyERC20(0xe1aFe1Fd76Fd88f78cBf599ea1846231B8bA3B6B);\n    // https://etherscan.io/address/0xE5CC99EFA57943F4EA0cE6bed265318697748649\n    Issuer public constant issuer_i = Issuer(0xE5CC99EFA57943F4EA0cE6bed265318697748649);\n\n    // ----------------------------------\n    // NEW CONTRACTS DEPLOYED TO BE ADDED\n    // ----------------------------------\n\n    // https://etherscan.io/address/0x08F30Ecf2C15A783083ab9D5b9211c22388d0564\n    address public constant new_Synthetix_contract = 0x08F30Ecf2C15A783083ab9D5b9211c22388d0564;\n    // https://etherscan.io/address/0xE5CC99EFA57943F4EA0cE6bed265318697748649\n    address public constant new_Issuer_contract = 0xE5CC99EFA57943F4EA0cE6bed265318697748649;\n    // https://etherscan.io/address/0x10A5F7D9D65bCc2734763444D4940a31b109275f\n    address public constant new_SynthsUSD_contract = 0x10A5F7D9D65bCc2734763444D4940a31b109275f;\n    // https://etherscan.io/address/0xE1cc2332852B2Ac0dA59A1f9D3051829f4eF3c1C\n    address public constant new_SynthsJPY_contract = 0xE1cc2332852B2Ac0dA59A1f9D3051829f4eF3c1C;\n    // https://etherscan.io/address/0xa8E31E3C38aDD6052A9407298FAEB8fD393A6cF9\n    address public constant new_SynthsEUR_contract = 0xa8E31E3C38aDD6052A9407298FAEB8fD393A6cF9;\n    // https://etherscan.io/address/0xfb020CA7f4e8C4a5bBBe060f59a249c6275d2b69\n    address public constant new_SynthsAUD_contract = 0xfb020CA7f4e8C4a5bBBe060f59a249c6275d2b69;\n    // https://etherscan.io/address/0xdc883b9d9Ee16f74bE08826E68dF4C9D9d26e8bD\n    address public constant new_SynthsGBP_contract = 0xdc883b9d9Ee16f74bE08826E68dF4C9D9d26e8bD;\n    // https://etherscan.io/address/0xBb5b03E920cF702De5A3bA9Fc1445aF4B3919c88\n    address public constant new_SynthsCHF_contract = 0xBb5b03E920cF702De5A3bA9Fc1445aF4B3919c88;\n    // https://etherscan.io/address/0xdAe6C79c46aB3B280Ca28259000695529cbD1339\n    address public constant new_SynthsKRW_contract = 0xdAe6C79c46aB3B280Ca28259000695529cbD1339;\n    // https://etherscan.io/address/0x5D4C724BFe3a228Ff0E29125Ac1571FE093700a4\n    address public constant new_SynthsETH_contract = 0x5D4C724BFe3a228Ff0E29125Ac1571FE093700a4;\n    // https://etherscan.io/address/0x1cB004a8e84a5CE95C1fF895EE603BaC8EC506c7\n    address public constant new_SynthsBTC_contract = 0x1cB004a8e84a5CE95C1fF895EE603BaC8EC506c7;\n    // https://etherscan.io/address/0xDF69bC4541b86Aa4c5A470B4347E730c38b2c3B2\n    address public constant new_SynthsLINK_contract = 0xDF69bC4541b86Aa4c5A470B4347E730c38b2c3B2;\n    // https://etherscan.io/address/0x942Eb6e8c029EB22103743C99985aF4F4515a559\n    address public constant new_SynthsAAVE_contract = 0x942Eb6e8c029EB22103743C99985aF4F4515a559;\n    // https://etherscan.io/address/0x91b82d62Ff322b8e02b86f33E9A99a813437830d\n    address public constant new_SynthsADA_contract = 0x91b82d62Ff322b8e02b86f33E9A99a813437830d;\n    // https://etherscan.io/address/0x75A0c1597137AA36B40b6a515D997F9a6c6eefEB\n    address public constant new_SynthsDOT_contract = 0x75A0c1597137AA36B40b6a515D997F9a6c6eefEB;\n    // https://etherscan.io/address/0x918b1dbf0917FdD74D03fB9434915E2ECEc89286\n    address public constant new_SynthsDEFI_contract = 0x918b1dbf0917FdD74D03fB9434915E2ECEc89286;\n    // https://etherscan.io/address/0x07C1E81C345A7c58d7c24072EFc5D929BD0647AD\n    address public constant new_SynthsETHBTC_contract = 0x07C1E81C345A7c58d7c24072EFc5D929BD0647AD;\n\n    constructor() public BaseMigration(OWNER) {}\n\n    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {\n        contracts = new address[](52);\n        contracts[0] = address(addressresolver_i);\n        contracts[1] = address(proxysynthetix_i);\n        contracts[2] = address(systemstatus_i);\n        contracts[3] = address(tokenstatesynthetix_i);\n        contracts[4] = address(rewardescrow_i);\n        contracts[5] = address(rewardsdistribution_i);\n        contracts[6] = address(synthsusd_i);\n        contracts[7] = address(tokenstatesusd_i);\n        contracts[8] = address(proxysusd_i);\n        contracts[9] = address(synthseur_i);\n        contracts[10] = address(tokenstateseur_i);\n        contracts[11] = address(proxyseur_i);\n        contracts[12] = address(synthsjpy_i);\n        contracts[13] = address(tokenstatesjpy_i);\n        contracts[14] = address(proxysjpy_i);\n        contracts[15] = address(synthsaud_i);\n        contracts[16] = address(tokenstatesaud_i);\n        contracts[17] = address(proxysaud_i);\n        contracts[18] = address(synthsgbp_i);\n        contracts[19] = address(tokenstatesgbp_i);\n        contracts[20] = address(proxysgbp_i);\n        contracts[21] = address(synthschf_i);\n        contracts[22] = address(tokenstateschf_i);\n        contracts[23] = address(proxyschf_i);\n        contracts[24] = address(synthskrw_i);\n        contracts[25] = address(tokenstateskrw_i);\n        contracts[26] = address(proxyskrw_i);\n        contracts[27] = address(synthsbtc_i);\n        contracts[28] = address(tokenstatesbtc_i);\n        contracts[29] = address(proxysbtc_i);\n        contracts[30] = address(synthseth_i);\n        contracts[31] = address(tokenstateseth_i);\n        contracts[32] = address(proxyseth_i);\n        contracts[33] = address(synthslink_i);\n        contracts[34] = address(tokenstateslink_i);\n        contracts[35] = address(proxyslink_i);\n        contracts[36] = address(synthsada_i);\n        contracts[37] = address(tokenstatesada_i);\n        contracts[38] = address(proxysada_i);\n        contracts[39] = address(synthsaave_i);\n        contracts[40] = address(tokenstatesaave_i);\n        contracts[41] = address(proxysaave_i);\n        contracts[42] = address(synthsdot_i);\n        contracts[43] = address(tokenstatesdot_i);\n        contracts[44] = address(proxysdot_i);\n        contracts[45] = address(synthsethbtc_i);\n        contracts[46] = address(tokenstatesethbtc_i);\n        contracts[47] = address(proxysethbtc_i);\n        contracts[48] = address(synthsdefi_i);\n        contracts[49] = address(tokenstatesdefi_i);\n        contracts[50] = address(proxysdefi_i);\n        contracts[51] = address(issuer_i);\n    }\n\n    function migrate() external onlyOwner {\n        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes\n        acceptAll();\n\n        // MIGRATION\n        // Import all new contracts into the address resolver;\n        addressresolver_importAddresses_0();\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;\n        addressresolver_rebuildCaches_1();\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;\n        addressresolver_rebuildCaches_2();\n        // Ensure the SNX proxy has the correct Synthetix target set;\n        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));\n        // Ensure Issuer contract can suspend issuance - see SIP-165;\n        systemstatus_i.updateAccessControl(\"Issuance\", new_Issuer_contract, true, false);\n        // Ensure the Synthetix contract can write to its TokenState contract;\n        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);\n        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;\n        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));\n        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;\n        rewardsdistribution_i.setAuthority(new_Synthetix_contract);\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sUSD();\n        // Ensure the sUSD synth can write to its TokenState;\n        tokenstatesusd_i.setAssociatedContract(new_SynthsUSD_contract);\n        // Ensure the sUSD synth Proxy is correctly connected to the Synth;\n        proxysusd_i.setTarget(Proxyable(new_SynthsUSD_contract));\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sEUR();\n        // Ensure the sEUR synth can write to its TokenState;\n        tokenstateseur_i.setAssociatedContract(new_SynthsEUR_contract);\n        // Ensure the sEUR synth Proxy is correctly connected to the Synth;\n        proxyseur_i.setTarget(Proxyable(new_SynthsEUR_contract));\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sJPY();\n        // Ensure the sJPY synth can write to its TokenState;\n        tokenstatesjpy_i.setAssociatedContract(new_SynthsJPY_contract);\n        // Ensure the sJPY synth Proxy is correctly connected to the Synth;\n        proxysjpy_i.setTarget(Proxyable(new_SynthsJPY_contract));\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sAUD();\n        // Ensure the sAUD synth can write to its TokenState;\n        tokenstatesaud_i.setAssociatedContract(new_SynthsAUD_contract);\n        // Ensure the sAUD synth Proxy is correctly connected to the Synth;\n        proxysaud_i.setTarget(Proxyable(new_SynthsAUD_contract));\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sGBP();\n        // Ensure the sGBP synth can write to its TokenState;\n        tokenstatesgbp_i.setAssociatedContract(new_SynthsGBP_contract);\n        // Ensure the sGBP synth Proxy is correctly connected to the Synth;\n        proxysgbp_i.setTarget(Proxyable(new_SynthsGBP_contract));\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sCHF();\n        // Ensure the sCHF synth can write to its TokenState;\n        tokenstateschf_i.setAssociatedContract(new_SynthsCHF_contract);\n        // Ensure the sCHF synth Proxy is correctly connected to the Synth;\n        proxyschf_i.setTarget(Proxyable(new_SynthsCHF_contract));\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sKRW();\n        // Ensure the sKRW synth can write to its TokenState;\n        tokenstateskrw_i.setAssociatedContract(new_SynthsKRW_contract);\n        // Ensure the sKRW synth Proxy is correctly connected to the Synth;\n        proxyskrw_i.setTarget(Proxyable(new_SynthsKRW_contract));\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sBTC();\n        // Ensure the sBTC synth can write to its TokenState;\n        tokenstatesbtc_i.setAssociatedContract(new_SynthsBTC_contract);\n        // Ensure the sBTC synth Proxy is correctly connected to the Synth;\n        proxysbtc_i.setTarget(Proxyable(new_SynthsBTC_contract));\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sETH();\n        // Ensure the sETH synth can write to its TokenState;\n        tokenstateseth_i.setAssociatedContract(new_SynthsETH_contract);\n        // Ensure the sETH synth Proxy is correctly connected to the Synth;\n        proxyseth_i.setTarget(Proxyable(new_SynthsETH_contract));\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sLINK();\n        // Ensure the sLINK synth can write to its TokenState;\n        tokenstateslink_i.setAssociatedContract(new_SynthsLINK_contract);\n        // Ensure the sLINK synth Proxy is correctly connected to the Synth;\n        proxyslink_i.setTarget(Proxyable(new_SynthsLINK_contract));\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sADA();\n        // Ensure the sADA synth can write to its TokenState;\n        tokenstatesada_i.setAssociatedContract(new_SynthsADA_contract);\n        // Ensure the sADA synth Proxy is correctly connected to the Synth;\n        proxysada_i.setTarget(Proxyable(new_SynthsADA_contract));\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sAAVE();\n        // Ensure the sAAVE synth can write to its TokenState;\n        tokenstatesaave_i.setAssociatedContract(new_SynthsAAVE_contract);\n        // Ensure the sAAVE synth Proxy is correctly connected to the Synth;\n        proxysaave_i.setTarget(Proxyable(new_SynthsAAVE_contract));\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sDOT();\n        // Ensure the sDOT synth can write to its TokenState;\n        tokenstatesdot_i.setAssociatedContract(new_SynthsDOT_contract);\n        // Ensure the sDOT synth Proxy is correctly connected to the Synth;\n        proxysdot_i.setTarget(Proxyable(new_SynthsDOT_contract));\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sETHBTC();\n        // Ensure the sETHBTC synth can write to its TokenState;\n        tokenstatesethbtc_i.setAssociatedContract(new_SynthsETHBTC_contract);\n        // Ensure the sETHBTC synth Proxy is correctly connected to the Synth;\n        proxysethbtc_i.setTarget(Proxyable(new_SynthsETHBTC_contract));\n        // Ensure the new synth has the totalSupply from the previous one;\n        copyTotalSupplyFrom_sDEFI();\n        // Ensure the sDEFI synth can write to its TokenState;\n        tokenstatesdefi_i.setAssociatedContract(new_SynthsDEFI_contract);\n        // Ensure the sDEFI synth Proxy is correctly connected to the Synth;\n        proxysdefi_i.setTarget(Proxyable(new_SynthsDEFI_contract));\n        // Add synths to the Issuer contract - batch 1;\n        issuer_addSynths_70();\n\n        // NOMINATE OWNERSHIP back to owner for aforementioned contracts\n        nominateAll();\n    }\n\n    function acceptAll() internal {\n        address[] memory contracts = contractsRequiringOwnership();\n        for (uint i = 0; i < contracts.length; i++) {\n            Owned(contracts[i]).acceptOwnership();\n        }\n    }\n\n    function nominateAll() internal {\n        address[] memory contracts = contractsRequiringOwnership();\n        for (uint i = 0; i < contracts.length; i++) {\n            returnOwnership(contracts[i]);\n        }\n    }\n\n    function addressresolver_importAddresses_0() internal {\n        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](17);\n        addressresolver_importAddresses_names_0_0[0] = bytes32(\"Synthetix\");\n        addressresolver_importAddresses_names_0_0[1] = bytes32(\"Issuer\");\n        addressresolver_importAddresses_names_0_0[2] = bytes32(\"SynthsUSD\");\n        addressresolver_importAddresses_names_0_0[3] = bytes32(\"SynthsJPY\");\n        addressresolver_importAddresses_names_0_0[4] = bytes32(\"SynthsEUR\");\n        addressresolver_importAddresses_names_0_0[5] = bytes32(\"SynthsAUD\");\n        addressresolver_importAddresses_names_0_0[6] = bytes32(\"SynthsGBP\");\n        addressresolver_importAddresses_names_0_0[7] = bytes32(\"SynthsCHF\");\n        addressresolver_importAddresses_names_0_0[8] = bytes32(\"SynthsKRW\");\n        addressresolver_importAddresses_names_0_0[9] = bytes32(\"SynthsETH\");\n        addressresolver_importAddresses_names_0_0[10] = bytes32(\"SynthsBTC\");\n        addressresolver_importAddresses_names_0_0[11] = bytes32(\"SynthsLINK\");\n        addressresolver_importAddresses_names_0_0[12] = bytes32(\"SynthsAAVE\");\n        addressresolver_importAddresses_names_0_0[13] = bytes32(\"SynthsADA\");\n        addressresolver_importAddresses_names_0_0[14] = bytes32(\"SynthsDOT\");\n        addressresolver_importAddresses_names_0_0[15] = bytes32(\"SynthsDEFI\");\n        addressresolver_importAddresses_names_0_0[16] = bytes32(\"SynthsETHBTC\");\n        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](17);\n        addressresolver_importAddresses_destinations_0_1[0] = address(new_Synthetix_contract);\n        addressresolver_importAddresses_destinations_0_1[1] = address(new_Issuer_contract);\n        addressresolver_importAddresses_destinations_0_1[2] = address(new_SynthsUSD_contract);\n        addressresolver_importAddresses_destinations_0_1[3] = address(new_SynthsJPY_contract);\n        addressresolver_importAddresses_destinations_0_1[4] = address(new_SynthsEUR_contract);\n        addressresolver_importAddresses_destinations_0_1[5] = address(new_SynthsAUD_contract);\n        addressresolver_importAddresses_destinations_0_1[6] = address(new_SynthsGBP_contract);\n        addressresolver_importAddresses_destinations_0_1[7] = address(new_SynthsCHF_contract);\n        addressresolver_importAddresses_destinations_0_1[8] = address(new_SynthsKRW_contract);\n        addressresolver_importAddresses_destinations_0_1[9] = address(new_SynthsETH_contract);\n        addressresolver_importAddresses_destinations_0_1[10] = address(new_SynthsBTC_contract);\n        addressresolver_importAddresses_destinations_0_1[11] = address(new_SynthsLINK_contract);\n        addressresolver_importAddresses_destinations_0_1[12] = address(new_SynthsAAVE_contract);\n        addressresolver_importAddresses_destinations_0_1[13] = address(new_SynthsADA_contract);\n        addressresolver_importAddresses_destinations_0_1[14] = address(new_SynthsDOT_contract);\n        addressresolver_importAddresses_destinations_0_1[15] = address(new_SynthsDEFI_contract);\n        addressresolver_importAddresses_destinations_0_1[16] = address(new_SynthsETHBTC_contract);\n        addressresolver_i.importAddresses(\n            addressresolver_importAddresses_names_0_0,\n            addressresolver_importAddresses_destinations_0_1\n        );\n    }\n\n    function addressresolver_rebuildCaches_1() internal {\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_1_0 = new MixinResolver[](20);\n        addressresolver_rebuildCaches_destinations_1_0[0] = MixinResolver(0xDA4eF8520b1A57D7d63f1E249606D1A459698876);\n        addressresolver_rebuildCaches_destinations_1_0[1] = MixinResolver(0x0e5fe1b05612581576e9A3dB048416d0B1E3C425);\n        addressresolver_rebuildCaches_destinations_1_0[2] = MixinResolver(0xf79603a71144e415730C1A6f57F366E4Ea962C00);\n        addressresolver_rebuildCaches_destinations_1_0[3] = MixinResolver(0xD64D83829D92B5bdA881f6f61A4e4E27Fc185387);\n        addressresolver_rebuildCaches_destinations_1_0[4] = MixinResolver(new_Issuer_contract);\n        addressresolver_rebuildCaches_destinations_1_0[5] = MixinResolver(0x62922670313bf6b41C580143d1f6C173C5C20019);\n        addressresolver_rebuildCaches_destinations_1_0[6] = MixinResolver(0x39Ea01a0298C315d149a490E34B59Dbf2EC7e48F);\n        addressresolver_rebuildCaches_destinations_1_0[7] = MixinResolver(new_Synthetix_contract);\n        addressresolver_rebuildCaches_destinations_1_0[8] = MixinResolver(0x89FCb32F29e509cc42d0C8b6f058C993013A843F);\n        addressresolver_rebuildCaches_destinations_1_0[9] = MixinResolver(0x3B2f389AeE480238A49E3A9985cd6815370712eB);\n        addressresolver_rebuildCaches_destinations_1_0[10] = MixinResolver(0x1620Aa736939597891C1940CF0d28b82566F9390);\n        addressresolver_rebuildCaches_destinations_1_0[11] = MixinResolver(0xeAcaEd9581294b1b5cfb6B941d4B8B81B2005437);\n        addressresolver_rebuildCaches_destinations_1_0[12] = MixinResolver(0xe533139Af961c9747356D947838c98451015e234);\n        addressresolver_rebuildCaches_destinations_1_0[13] = MixinResolver(new_SynthsUSD_contract);\n        addressresolver_rebuildCaches_destinations_1_0[14] = MixinResolver(new_SynthsEUR_contract);\n        addressresolver_rebuildCaches_destinations_1_0[15] = MixinResolver(new_SynthsJPY_contract);\n        addressresolver_rebuildCaches_destinations_1_0[16] = MixinResolver(new_SynthsAUD_contract);\n        addressresolver_rebuildCaches_destinations_1_0[17] = MixinResolver(new_SynthsGBP_contract);\n        addressresolver_rebuildCaches_destinations_1_0[18] = MixinResolver(new_SynthsCHF_contract);\n        addressresolver_rebuildCaches_destinations_1_0[19] = MixinResolver(new_SynthsKRW_contract);\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_1_0);\n    }\n\n    function addressresolver_rebuildCaches_2() internal {\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_2_0 = new MixinResolver[](16);\n        addressresolver_rebuildCaches_destinations_2_0[0] = MixinResolver(new_SynthsBTC_contract);\n        addressresolver_rebuildCaches_destinations_2_0[1] = MixinResolver(new_SynthsETH_contract);\n        addressresolver_rebuildCaches_destinations_2_0[2] = MixinResolver(new_SynthsLINK_contract);\n        addressresolver_rebuildCaches_destinations_2_0[3] = MixinResolver(new_SynthsADA_contract);\n        addressresolver_rebuildCaches_destinations_2_0[4] = MixinResolver(new_SynthsAAVE_contract);\n        addressresolver_rebuildCaches_destinations_2_0[5] = MixinResolver(new_SynthsDOT_contract);\n        addressresolver_rebuildCaches_destinations_2_0[6] = MixinResolver(new_SynthsETHBTC_contract);\n        addressresolver_rebuildCaches_destinations_2_0[7] = MixinResolver(new_SynthsDEFI_contract);\n        addressresolver_rebuildCaches_destinations_2_0[8] = MixinResolver(0xC1AAE9d18bBe386B102435a8632C8063d31e747C);\n        addressresolver_rebuildCaches_destinations_2_0[9] = MixinResolver(0x067e398605E84F2D0aEEC1806e62768C5110DCc6);\n        addressresolver_rebuildCaches_destinations_2_0[10] = MixinResolver(0x02f9bC46beD33acdB9cb002fe346734CeF8a9480);\n        addressresolver_rebuildCaches_destinations_2_0[11] = MixinResolver(0x5c8344bcdC38F1aB5EB5C1d4a35DdEeA522B5DfA);\n        addressresolver_rebuildCaches_destinations_2_0[12] = MixinResolver(0xaa03aB31b55DceEeF845C8d17890CC61cD98eD04);\n        addressresolver_rebuildCaches_destinations_2_0[13] = MixinResolver(0x1F2c3a1046c32729862fcB038369696e3273a516);\n        addressresolver_rebuildCaches_destinations_2_0[14] = MixinResolver(0x7C22547779c8aa41bAE79E03E8383a0BefBCecf0);\n        addressresolver_rebuildCaches_destinations_2_0[15] = MixinResolver(0x7A3d898b717e50a96fd8b232E9d15F0A547A7eeb);\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_2_0);\n    }\n\n    function copyTotalSupplyFrom_sUSD() internal {\n        // https://etherscan.io/address/0x7df9b3f8f1C011D8BD707430e97E747479DD532a;\n        Synth existingSynth = Synth(0x7df9b3f8f1C011D8BD707430e97E747479DD532a);\n        // https://etherscan.io/address/0x10A5F7D9D65bCc2734763444D4940a31b109275f;\n        Synth newSynth = Synth(0x10A5F7D9D65bCc2734763444D4940a31b109275f);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    function copyTotalSupplyFrom_sEUR() internal {\n        // https://etherscan.io/address/0x1b06a00Df0B27E7871E753720D4917a7D1aac68b;\n        Synth existingSynth = Synth(0x1b06a00Df0B27E7871E753720D4917a7D1aac68b);\n        // https://etherscan.io/address/0xa8E31E3C38aDD6052A9407298FAEB8fD393A6cF9;\n        Synth newSynth = Synth(0xa8E31E3C38aDD6052A9407298FAEB8fD393A6cF9);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    function copyTotalSupplyFrom_sJPY() internal {\n        // https://etherscan.io/address/0xB82f11f3168Ece7D56fe6a5679567948090de7C5;\n        Synth existingSynth = Synth(0xB82f11f3168Ece7D56fe6a5679567948090de7C5);\n        // https://etherscan.io/address/0xE1cc2332852B2Ac0dA59A1f9D3051829f4eF3c1C;\n        Synth newSynth = Synth(0xE1cc2332852B2Ac0dA59A1f9D3051829f4eF3c1C);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    function copyTotalSupplyFrom_sAUD() internal {\n        // https://etherscan.io/address/0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C;\n        Synth existingSynth = Synth(0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C);\n        // https://etherscan.io/address/0xfb020CA7f4e8C4a5bBBe060f59a249c6275d2b69;\n        Synth newSynth = Synth(0xfb020CA7f4e8C4a5bBBe060f59a249c6275d2b69);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    function copyTotalSupplyFrom_sGBP() internal {\n        // https://etherscan.io/address/0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf;\n        Synth existingSynth = Synth(0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf);\n        // https://etherscan.io/address/0xdc883b9d9Ee16f74bE08826E68dF4C9D9d26e8bD;\n        Synth newSynth = Synth(0xdc883b9d9Ee16f74bE08826E68dF4C9D9d26e8bD);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    function copyTotalSupplyFrom_sCHF() internal {\n        // https://etherscan.io/address/0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d;\n        Synth existingSynth = Synth(0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d);\n        // https://etherscan.io/address/0xBb5b03E920cF702De5A3bA9Fc1445aF4B3919c88;\n        Synth newSynth = Synth(0xBb5b03E920cF702De5A3bA9Fc1445aF4B3919c88);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    function copyTotalSupplyFrom_sKRW() internal {\n        // https://etherscan.io/address/0x527637bE27640d6C3e751d24DC67129A6d13E11C;\n        Synth existingSynth = Synth(0x527637bE27640d6C3e751d24DC67129A6d13E11C);\n        // https://etherscan.io/address/0xdAe6C79c46aB3B280Ca28259000695529cbD1339;\n        Synth newSynth = Synth(0xdAe6C79c46aB3B280Ca28259000695529cbD1339);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    function copyTotalSupplyFrom_sBTC() internal {\n        // https://etherscan.io/address/0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6;\n        Synth existingSynth = Synth(0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6);\n        // https://etherscan.io/address/0x1cB004a8e84a5CE95C1fF895EE603BaC8EC506c7;\n        Synth newSynth = Synth(0x1cB004a8e84a5CE95C1fF895EE603BaC8EC506c7);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    function copyTotalSupplyFrom_sETH() internal {\n        // https://etherscan.io/address/0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6;\n        Synth existingSynth = Synth(0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6);\n        // https://etherscan.io/address/0x5D4C724BFe3a228Ff0E29125Ac1571FE093700a4;\n        Synth newSynth = Synth(0x5D4C724BFe3a228Ff0E29125Ac1571FE093700a4);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    function copyTotalSupplyFrom_sLINK() internal {\n        // https://etherscan.io/address/0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6;\n        Synth existingSynth = Synth(0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6);\n        // https://etherscan.io/address/0xDF69bC4541b86Aa4c5A470B4347E730c38b2c3B2;\n        Synth newSynth = Synth(0xDF69bC4541b86Aa4c5A470B4347E730c38b2c3B2);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    function copyTotalSupplyFrom_sADA() internal {\n        // https://etherscan.io/address/0xB34F4d7c207D8979D05EDb0F63f174764Bd67825;\n        Synth existingSynth = Synth(0xB34F4d7c207D8979D05EDb0F63f174764Bd67825);\n        // https://etherscan.io/address/0x91b82d62Ff322b8e02b86f33E9A99a813437830d;\n        Synth newSynth = Synth(0x91b82d62Ff322b8e02b86f33E9A99a813437830d);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    function copyTotalSupplyFrom_sAAVE() internal {\n        // https://etherscan.io/address/0x95aE43E5E96314E4afffcf19D9419111cd11169e;\n        Synth existingSynth = Synth(0x95aE43E5E96314E4afffcf19D9419111cd11169e);\n        // https://etherscan.io/address/0x942Eb6e8c029EB22103743C99985aF4F4515a559;\n        Synth newSynth = Synth(0x942Eb6e8c029EB22103743C99985aF4F4515a559);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    function copyTotalSupplyFrom_sDOT() internal {\n        // https://etherscan.io/address/0x27b45A4208b87A899009f45888139882477Acea5;\n        Synth existingSynth = Synth(0x27b45A4208b87A899009f45888139882477Acea5);\n        // https://etherscan.io/address/0x75A0c1597137AA36B40b6a515D997F9a6c6eefEB;\n        Synth newSynth = Synth(0x75A0c1597137AA36B40b6a515D997F9a6c6eefEB);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    function copyTotalSupplyFrom_sETHBTC() internal {\n        // https://etherscan.io/address/0x6DF798ec713b33BE823b917F27820f2aA0cf7662;\n        Synth existingSynth = Synth(0x6DF798ec713b33BE823b917F27820f2aA0cf7662);\n        // https://etherscan.io/address/0x07C1E81C345A7c58d7c24072EFc5D929BD0647AD;\n        Synth newSynth = Synth(0x07C1E81C345A7c58d7c24072EFc5D929BD0647AD);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    function copyTotalSupplyFrom_sDEFI() internal {\n        // https://etherscan.io/address/0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124;\n        Synth existingSynth = Synth(0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124);\n        // https://etherscan.io/address/0x918b1dbf0917FdD74D03fB9434915E2ECEc89286;\n        Synth newSynth = Synth(0x918b1dbf0917FdD74D03fB9434915E2ECEc89286);\n        newSynth.setTotalSupply(existingSynth.totalSupply());\n    }\n\n    function issuer_addSynths_70() internal {\n        ISynth[] memory issuer_addSynths_synthsToAdd_70_0 = new ISynth[](15);\n        issuer_addSynths_synthsToAdd_70_0[0] = ISynth(new_SynthsUSD_contract);\n        issuer_addSynths_synthsToAdd_70_0[1] = ISynth(new_SynthsEUR_contract);\n        issuer_addSynths_synthsToAdd_70_0[2] = ISynth(new_SynthsJPY_contract);\n        issuer_addSynths_synthsToAdd_70_0[3] = ISynth(new_SynthsAUD_contract);\n        issuer_addSynths_synthsToAdd_70_0[4] = ISynth(new_SynthsGBP_contract);\n        issuer_addSynths_synthsToAdd_70_0[5] = ISynth(new_SynthsCHF_contract);\n        issuer_addSynths_synthsToAdd_70_0[6] = ISynth(new_SynthsKRW_contract);\n        issuer_addSynths_synthsToAdd_70_0[7] = ISynth(new_SynthsBTC_contract);\n        issuer_addSynths_synthsToAdd_70_0[8] = ISynth(new_SynthsETH_contract);\n        issuer_addSynths_synthsToAdd_70_0[9] = ISynth(new_SynthsLINK_contract);\n        issuer_addSynths_synthsToAdd_70_0[10] = ISynth(new_SynthsADA_contract);\n        issuer_addSynths_synthsToAdd_70_0[11] = ISynth(new_SynthsAAVE_contract);\n        issuer_addSynths_synthsToAdd_70_0[12] = ISynth(new_SynthsDOT_contract);\n        issuer_addSynths_synthsToAdd_70_0[13] = ISynth(new_SynthsETHBTC_contract);\n        issuer_addSynths_synthsToAdd_70_0[14] = ISynth(new_SynthsDEFI_contract);\n        issuer_i.addSynths(issuer_addSynths_synthsToAdd_70_0);\n    }\n}\n\n    ", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"OWNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressresolver_i\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractsRequiringOwnership\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuer_i\",\"outputs\":[{\"internalType\":\"contract Issuer\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Issuer_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Synthetix_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsAAVE_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsADA_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsAUD_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsBTC_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsCHF_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsDEFI_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsDOT_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsETHBTC_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsETH_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsEUR_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsGBP_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsJPY_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsKRW_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsLINK_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsUSD_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysaave_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysada_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysaud_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysbtc_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyschf_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysdefi_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysdot_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyseth_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysethbtc_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyseur_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysgbp_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysjpy_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyskrw_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyslink_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysusd_i\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysynthetix_i\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"forContract\",\"type\":\"address\"}],\"name\":\"returnOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardescrow_i\",\"outputs\":[{\"internalType\":\"contract RewardEscrow\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsdistribution_i\",\"outputs\":[{\"internalType\":\"contract RewardsDistribution\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsaave_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsada_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsaud_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsbtc_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthschf_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsdefi_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsdot_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthseth_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsethbtc_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthseur_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsgbp_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsjpy_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthskrw_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthslink_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsusd_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemstatus_i\",\"outputs\":[{\"internalType\":\"contract SystemStatus\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesaave_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesada_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesaud_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesbtc_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateschf_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesdefi_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesdot_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateseth_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesethbtc_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateseur_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesgbp_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesjpy_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateskrw_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateslink_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesusd_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesynthetix_i\",\"outputs\":[{\"internalType\":\"contract LegacyTokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Migration_Saiph", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}