{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/risk/RiskManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport \\\"../utils/Governable.sol\\\";\\nimport \\\"../interfaces/risk/ICoverageDataProvider.sol\\\";\\nimport \\\"../interfaces/utils/IRegistry.sol\\\";\\nimport \\\"../interfaces/risk/IRiskManager.sol\\\";\\n\\n/**\\n * @title RiskManager\\n * @author solace.fi\\n * @notice Calculates the acceptable risk, sellable cover, and capital requirements of Solace products and capital pool.\\n *\\n * The total amount of sellable coverage is proportional to the assets in the [**risk backing capital pool**](./Vault). The max cover is split amongst products in a weighting system. [**Governance**](/docs/protocol/governance) can change these weights and with it each product's sellable cover.\\n *\\n * The minimum capital requirement is proportional to the amount of cover sold to active policies.\\n *\\n * Solace can use leverage to sell more cover than the available capital. The amount of leverage is stored as [`partialReservesFactor`](#partialreservesfactor) and is settable by [**governance**](/docs/protocol/governance).\\n */\\ncontract RiskManager is IRiskManager, Governable {\\n\\n    /***************************************\\n    GLOBAL VARIABLES\\n    ***************************************/\\n\\n    /// @notice Holds mapping strategy => inddex.\\n    mapping(address => uint256) private _strategyToIndex;\\n    /// @notice Holds mapping index => strategy.\\n    mapping(uint256 => address) private _indexToStrategy;\\n    /// @notice Holds strategies.\\n    mapping(address => Strategy) private _strategies;\\n    /// @notice Returns true if the caller valid cover limit updater.\\n    mapping(address => bool) public canUpdateCoverLimit;\\n    // The current amount covered (in wei).\\n    uint256 internal _activeCoverLimit;\\n    /// @notice The current amount covered (in wei) per strategy;\\n    mapping(address => uint256) internal _activeCoverLimitPerStrategy;\\n    /// @notice The total strategy count.\\n    uint256 private _strategyCount;\\n    /// @notice The total weight sum of all strategies.\\n    uint32 private _weightSum;\\n    /// @notice Multiplier for minimum capital requirement in BPS.\\n    uint16 private _partialReservesFactor;\\n    /// @notice 10k basis points (100%).\\n    uint16 private constant MAX_BPS = 10000;\\n\\n    /// @notice Registry contract.\\n    IRegistry private _registry;\\n\\n    /**\\n     * @notice Constructs the RiskManager contract.\\n     * @param governance_ The address of the [governor](/docs/protocol/governance).\\n     * @param registry_ Address of registry.\\n     */\\n    constructor(address governance_, address registry_) Governable(governance_) {\\n        require(registry_ != address(0x0), \\\"zero address registry\\\");\\n        _registry = IRegistry(registry_);\\n        _partialReservesFactor = MAX_BPS;\\n    }\\n\\n    /***************************************\\n    RISK MANAGER MUTUATOR FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Adds a new `Risk Strategy` to the `Risk Manager`. The community votes the strategy for coverage weight allocation.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param strategy_ The address of the risk strategy.\\n     * @return index The index of the risk strategy.\\n    */\\n    function addRiskStrategy(address strategy_) external override onlyGovernance returns (uint256 index) {\\n        require(strategy_ != address(0x0), \\\"zero address strategy\\\");\\n        require(_strategyToIndex[strategy_] == 0, \\\"duplicate strategy\\\");\\n\\n        uint256 strategyCount = _strategyCount;\\n        _strategies[strategy_] = Strategy({\\n            id: ++strategyCount,\\n            weight: 0,\\n            status: StrategyStatus.INACTIVE,\\n            timestamp: block.timestamp\\n        });\\n        _strategyToIndex[strategy_] = strategyCount;\\n        _indexToStrategy[strategyCount] = strategy_;\\n        _strategyCount = strategyCount;\\n        emit StrategyAdded(strategy_);\\n        return strategyCount;\\n    }\\n\\n    /**\\n     * @notice Sets the weight of the `Risk Strategy`.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param strategy_ The address of the risk strategy.\\n     * @param weight_ The value to set.\\n    */\\n    function setWeightAllocation(address strategy_, uint32 weight_) external override onlyGovernance {\\n        require(weight_ > 0, \\\"invalid weight!\\\");\\n        require(strategyIsActive(strategy_), \\\"inactive strategy\\\");\\n        require(validateAllocation(strategy_, weight_), \\\"invalid weight allocation\\\");\\n        Strategy storage riskStrategy = _strategies[strategy_];\\n        _weightSum = (_weightSum + weight_) - riskStrategy.weight;\\n        riskStrategy.weight = weight_;\\n        emit RiskStrategyWeightAllocationSet(strategy_, weight_);\\n    }\\n\\n    /**\\n     * @notice Sets the status of the `Risk Strategy`.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param strategy_ The address of the risk strategy.\\n     * @param status_ The status to set.\\n    */\\n    function setStrategyStatus(address strategy_, uint8 status_) public override onlyGovernance {\\n        require(strategy_ != address(0x0), \\\"zero address strategy\\\");\\n        require(_strategyToIndex[strategy_] > 0, \\\"non-exist strategy\\\");\\n        Strategy storage riskStrategy = _strategies[strategy_];\\n        riskStrategy.status = StrategyStatus(status_);\\n        emit StrategyStatusUpdated(strategy_, status_);\\n    }\\n\\n   /**\\n     * @notice Updates the active cover limit amount for the given strategy. \\n     * This function is only called by valid requesters when a new policy is bought or updated.\\n     * @dev The policy manager and soteria will call this function for now.\\n     * @param strategy The strategy address to add cover limit.\\n     * @param currentCoverLimit The current cover limit amount of the strategy's product.\\n     * @param newCoverLimit The new cover limit amount of the strategy's product.\\n    */\\n    function updateActiveCoverLimitForStrategy(address strategy, uint256 currentCoverLimit, uint256 newCoverLimit) external override {\\n        require(canUpdateCoverLimit[msg.sender], \\\"unauthorized caller\\\");\\n        require(strategyIsActive(strategy), \\\"inactive strategy\\\");\\n        uint256 oldCoverLimitOfStrategy = _activeCoverLimitPerStrategy[strategy];\\n        _activeCoverLimit = _activeCoverLimit - currentCoverLimit + newCoverLimit;\\n        uint256 newCoverLimitOfStrategy = oldCoverLimitOfStrategy - currentCoverLimit + newCoverLimit;\\n        _activeCoverLimitPerStrategy[strategy] = newCoverLimitOfStrategy;\\n        emit ActiveCoverLimitUpdated(strategy, oldCoverLimitOfStrategy, newCoverLimitOfStrategy);\\n    }\\n\\n    /**\\n     * @notice Adds new address to allow updating cover limit amounts.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param updater The address that can update cover limit.\\n    */\\n    function addCoverLimitUpdater(address updater) external override onlyGovernance {\\n        require(updater != address(0x0), \\\"zero address coverlimit updater\\\");\\n        canUpdateCoverLimit[updater] = true;\\n        emit CoverLimitUpdaterAdded(updater);\\n    }\\n\\n    /**\\n     * @notice Removes the cover limit updater.\\n     * @param updater The address of updater to remove.\\n    */\\n    function removeCoverLimitUpdater(address updater) external override onlyGovernance {\\n        require(updater != address(0x0), \\\"zero address coverlimit updater\\\");\\n        delete canUpdateCoverLimit[updater];\\n        emit CoverLimitUpdaterDeleted(updater);\\n    }\\n\\n    /***************************************\\n    RISK MANAGER VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Checks if the given risk strategy is active.\\n     * @param strategy_ The risk strategy.\\n     * @return status True if the strategy is active.\\n     */\\n    function strategyIsActive(address strategy_) public view override returns (bool status) {\\n        return _strategies[strategy_].status == StrategyStatus.ACTIVE;\\n    }\\n\\n    /**\\n    * @notice Return the strategy at an index.\\n    * @dev Enumerable `[1, numStrategies]`.\\n    * @param index_ Index to query.\\n    * @return strategy The product address.\\n    */\\n    function strategyAt(uint256 index_) external view override returns (address strategy) {\\n       return _indexToStrategy[index_];\\n    }\\n\\n    /**\\n     * @notice Returns the number of registered strategies..\\n     * @return count The number of strategies.\\n    */\\n    function numStrategies() external view override returns (uint256 count) {\\n        return _strategyCount;\\n    }\\n\\n    /**\\n     * @notice Returns the risk strategy information.\\n     * @param strategy_ The risk strategy.\\n     * @return id The id of the risk strategy.\\n     * @return weight The risk strategy weight allocation.\\n     * @return status The status of risk strategy.\\n     * @return timestamp The added time of the risk strategy.\\n     *\\n    */\\n    function strategyInfo(address strategy_) external view override returns (uint256 id, uint32 weight, StrategyStatus status, uint256 timestamp) {\\n        Strategy memory strategy = _strategies[strategy_];\\n        return (strategy.id, strategy.weight, strategy.status, strategy.timestamp);\\n    }\\n\\n    /**\\n     * @notice Returns the allocated weight for the risk strategy.\\n     * @param strategy_ The risk strategy.\\n     * @return weight The risk strategy weight allocation.\\n    */\\n    function weightPerStrategy(address strategy_) public view override returns (uint32 weight) {\\n        Strategy memory strategy = _strategies[strategy_];\\n        return strategy.weight;\\n    }\\n\\n    /**\\n     * @notice The maximum amount of cover that Solace as a whole can sell.\\n     * @return cover The max amount of cover in wei.\\n     */\\n    function maxCover() public view override returns (uint256 cover) {\\n        return ICoverageDataProvider(_registry.get(\\\"coverageDataProvider\\\")).maxCover() * MAX_BPS / _partialReservesFactor;\\n    }\\n\\n    /**\\n     * @notice The maximum amount of cover for given strategy can sell.\\n     * @return cover The max amount of cover in wei.\\n     */\\n     function maxCoverPerStrategy(address strategy_) public view override returns (uint256 cover) {\\n        if (!strategyIsActive(strategy_)) return 0;\\n        uint256 maxCoverage = maxCover();\\n        uint32 weight = weightPerStrategy(strategy_);\\n        return maxCoverage = (maxCoverage * weight) / weightSum();\\n    }\\n\\n    /**\\n     * @notice Returns the sum of allocation weights for all strategies.\\n     * @return sum WeightSum.\\n     */\\n    function weightSum() public view override returns (uint32 sum) {\\n        return _weightSum == 0 ? type(uint32).max : _weightSum;\\n    }\\n\\n    /**\\n     * @notice Returns the current amount covered (in wei).\\n     * @return amount The covered amount (in wei).\\n    */\\n    function activeCoverLimit() public view override returns (uint256 amount) {\\n        return _activeCoverLimit;\\n    }\\n\\n    /**\\n     * @notice Returns the current amount covered (in wei).\\n     * @param riskStrategy The risk strategy address.\\n     * @return amount The covered amount (in wei).\\n    */\\n    function activeCoverLimitPerStrategy(address riskStrategy) public view override returns (uint256 amount) {\\n        return _activeCoverLimitPerStrategy[riskStrategy];\\n    }\\n\\n    /***************************************\\n    MIN CAPITAL VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice The minimum amount of capital required to safely cover all policies.\\n     * @return mcr The minimum capital requirement.\\n     */\\n    function minCapitalRequirement() external view override returns (uint256 mcr) {\\n        return activeCoverLimit() * _partialReservesFactor / MAX_BPS;\\n    }\\n\\n    /**\\n     * @notice The minimum amount of capital required to safely cover all policies.\\n     * @dev The strategy could have active policies when it is disabled. Because of that\\n     * we are not adding \\\"strategyIsActive()\\\" require statement.\\n     * @param strategy The risk strategy.\\n     * @return smcr The strategy minimum capital requirement.\\n     */\\n    function minCapitalRequirementPerStrategy(address strategy) public view override returns (uint256 smcr) {\\n        return activeCoverLimitPerStrategy(strategy) * _partialReservesFactor / MAX_BPS;\\n    }\\n\\n    /**\\n     * @notice Multiplier for minimum capital requirement.\\n     * @return factor Partial reserves factor in BPS.\\n     */\\n    function partialReservesFactor() external view override returns (uint16 factor) {\\n        return _partialReservesFactor;\\n    }\\n\\n    /**\\n     * @notice Sets the partial reserves factor.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param partialReservesFactor_ New partial reserves factor in BPS.\\n     */\\n    function setPartialReservesFactor(uint16 partialReservesFactor_) external override onlyGovernance {\\n        _partialReservesFactor = partialReservesFactor_;\\n        emit PartialReservesFactorSet(partialReservesFactor_);\\n    }\\n\\n    /**\\n     * @notice The function checks if the new weight allocation is valid.\\n     * @param strategy_ The strategy address.\\n     * @param weight_ The weight allocation to set.\\n     * @return status True if the weight allocation is valid.\\n    */\\n    function validateAllocation(address strategy_, uint32 weight_) private view returns(bool status) {\\n        Strategy memory riskStrategy = _strategies[strategy_];\\n        uint32 weightsum = _weightSum;\\n        // check if new allocation is valid for the strategy\\n        uint256 smcr = minCapitalRequirementPerStrategy(strategy_);\\n        uint256 mc = maxCover();\\n        weightsum = weightsum + weight_ - riskStrategy.weight;\\n        uint256 newAllocationAmount = (mc * weight_) / weightsum;\\n\\n        if (newAllocationAmount < smcr) return false;\\n\\n        // check other risk strategies\\n        uint256 strategyCount = _strategyCount;\\n        for (uint256 i = strategyCount; i > 0; i--) {\\n            address strategy = _indexToStrategy[i];\\n            riskStrategy = _strategies[strategy];\\n            smcr = minCapitalRequirementPerStrategy(strategy);\\n\\n            if (strategy == strategy_ || riskStrategy.weight == 0 || smcr == 0) continue;\\n            newAllocationAmount = (mc * riskStrategy.weight) / weightsum;\\n            if (newAllocationAmount < smcr) return false;\\n        }\\n        return true;\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport \\\"./../interfaces/utils/IGovernable.sol\\\";\\n\\n/**\\n * @title Governable\\n * @author solace.fi\\n * @notice Enforces access control for important functions to [**governor**](/docs/protocol/governance).\\n *\\n * Many contracts contain functionality that should only be accessible to a privileged user. The most common access control pattern is [OpenZeppelin's `Ownable`](https://docs.openzeppelin.com/contracts/4.x/access-control#ownership-and-ownable). We instead use `Governable` with a few key differences:\\n   * - Transferring the governance role is a two step process. The current governance must [`setPendingGovernance(pendingGovernance_)`](#setpendinggovernance) then the new governance must [`acceptGovernance()`](#acceptgovernance). This is to safeguard against accidentally setting ownership to the wrong address and locking yourself out of your contract.\\n * - `governance` is a constructor argument instead of `msg.sender`. This is especially useful when deploying contracts via a [`SingletonFactory`](./../interfaces/utils/ISingletonFactory).\\n * - We use `lockGovernance()` instead of `renounceOwnership()`. `renounceOwnership()` is a prerequisite for the reinitialization bug because it sets `owner = address(0x0)`. We also use the `governanceIsLocked()` flag.\\n */\\ncontract Governable is IGovernable {\\n\\n    /***************************************\\n    GLOBAL VARIABLES\\n    ***************************************/\\n\\n    // Governor.\\n    address private _governance;\\n\\n    // governance to take over.\\n    address private _pendingGovernance;\\n\\n    bool private _locked;\\n\\n    /**\\n     * @notice Constructs the governable contract.\\n     * @param governance_ The address of the [governor](/docs/protocol/governance).\\n     */\\n    constructor(address governance_) {\\n        require(governance_ != address(0x0), \\\"zero address governance\\\");\\n        _governance = governance_;\\n        _pendingGovernance = address(0x0);\\n        _locked = false;\\n    }\\n\\n    /***************************************\\n    MODIFIERS\\n    ***************************************/\\n\\n    // can only be called by governor\\n    // can only be called while unlocked\\n    modifier onlyGovernance() {\\n        require(!_locked, \\\"governance locked\\\");\\n        require(msg.sender == _governance, \\\"!governance\\\");\\n        _;\\n    }\\n\\n    // can only be called by pending governor\\n    // can only be called while unlocked\\n    modifier onlyPendingGovernance() {\\n        require(!_locked, \\\"governance locked\\\");\\n        require(msg.sender == _pendingGovernance, \\\"!pending governance\\\");\\n        _;\\n    }\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice Address of the current governor.\\n    function governance() public view override returns (address) {\\n        return _governance;\\n    }\\n\\n    /// @notice Address of the governor to take over.\\n    function pendingGovernance() external view override returns (address) {\\n        return _pendingGovernance;\\n    }\\n\\n    /// @notice Returns true if governance is locked.\\n    function governanceIsLocked() external view override returns (bool) {\\n        return _locked;\\n    }\\n\\n    /***************************************\\n    MUTATOR FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Initiates transfer of the governance role to a new governor.\\n     * Transfer is not complete until the new governor accepts the role.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param pendingGovernance_ The new governor.\\n     */\\n    function setPendingGovernance(address pendingGovernance_) external override onlyGovernance {\\n        _pendingGovernance = pendingGovernance_;\\n        emit GovernancePending(pendingGovernance_);\\n    }\\n\\n    /**\\n     * @notice Accepts the governance role.\\n     * Can only be called by the pending governor.\\n     */\\n    function acceptGovernance() external override onlyPendingGovernance {\\n        // sanity check against transferring governance to the zero address\\n        // if someone figures out how to sign transactions from the zero address\\n        // consider the entirety of ethereum to be rekt\\n        require(_pendingGovernance != address(0x0), \\\"zero governance\\\");\\n        address oldGovernance = _governance;\\n        _governance = _pendingGovernance;\\n        _pendingGovernance = address(0x0);\\n        emit GovernanceTransferred(oldGovernance, _governance);\\n    }\\n\\n    /**\\n     * @notice Permanently locks this contract's governance role and any of its functions that require the role.\\n     * This action cannot be reversed.\\n     * Before you call it, ask yourself:\\n     *   - Is the contract self-sustaining?\\n     *   - Is there a chance you will need governance privileges in the future?\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     */\\n    function lockGovernance() external override onlyGovernance {\\n        _locked = true;\\n        // intentionally not using address(0x0), see re-initialization exploit\\n        _governance = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\\n        _pendingGovernance = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\\n        emit GovernanceTransferred(msg.sender, address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));\\n        emit GovernanceLocked();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/risk/ICoverageDataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title ICoverageDataProvider\\n * @author solace.fi\\n * @notice Holds underwriting pool amounts in `USD`. Provides information to the [**Risk Manager**](./RiskManager.sol) that is the maximum amount of cover that `Solace` protocol can sell as a coverage.\\n*/\\ninterface ICoverageDataProvider {\\n    /***************************************\\n     EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when the underwriting pool is set.\\n    event UnderwritingPoolSet(string uwpName, uint256 amount);\\n\\n    /// @notice Emitted when underwriting pool is removed.\\n    event UnderwritingPoolRemoved(string uwpName);\\n\\n    /// @notice Emitted when underwriting pool updater is set.\\n    event UwpUpdaterSet(address uwpUpdater);\\n\\n    /***************************************\\n     MUTUATOR FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n      * @notice Resets the underwriting pool balances.\\n      * @param uwpNames The underwriting pool values to set.\\n      * @param amounts The underwriting pool balances.\\n    */\\n    function reset(string[] calldata uwpNames, uint256[] calldata amounts) external;\\n\\n    /**\\n     * @notice Sets the balance of the given underwriting pool.\\n     * @param uwpName The underwriting pool name to set balance.\\n     * @param amount The balance of the underwriting pool in `USD`.\\n    */\\n    function set(string calldata uwpName, uint256 amount) external;\\n\\n    /**\\n     * @notice Removes the given underwriting pool.\\n     * @param uwpName The underwriting pool name to remove.\\n    */\\n    function remove(string calldata uwpName) external;\\n\\n    /***************************************\\n     VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice The maximum amount of cover in `USD` that Solace as a whole can sell.\\n     * @return cover The max amount of cover in `USD`.\\n    */\\n    function maxCover() external view returns (uint256 cover);\\n\\n    /**\\n     * @notice Returns the balance of the underwriting pool in `USD`.\\n     * @param uwpName The underwriting pool name to get balance.\\n     * @return amount The balance of the underwriting pool in `USD`.\\n    */\\n    function balanceOf(string memory uwpName) external view returns (uint256 amount); \\n\\n    /**\\n     * @notice Returns underwriting pool name for given index.\\n     * @param index The underwriting pool index to get.\\n     * @return uwpName The underwriting pool name.\\n    */\\n    function poolOf(uint256 index) external view returns (string memory uwpName);\\n\\n    /**\\n     * @notice Returns the underwriting pool bot updater address.\\n     * @return uwpUpdater The bot address.\\n    */\\n    function getUwpUpdater() external view returns (address uwpUpdater);\\n\\n    /***************************************\\n     GOVERNANCE FUNCTIONS\\n    ***************************************/\\n    \\n    /**\\n     * @notice Sets the underwriting pool bot updater.\\n     * @param uwpUpdater The bot address to set.\\n    */\\n    function setUwpUpdater(address uwpUpdater) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/utils/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n\\n/**\\n * @title IRegistry\\n * @author solace.fi\\n * @notice Tracks the contracts of the Solaverse.\\n *\\n * [**Governance**](/docs/protocol/governance) can set the contract addresses and anyone can look them up.\\n *\\n * A key is a unique identifier for each contract. Use [`get(key)`](#get) or [`tryGet(key)`](#tryget) to get the address of the contract. Enumerate the keys with [`length()`](#length) and [`getKey(index)`](#getkey).\\n */\\ninterface IRegistry {\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when a record is set.\\n    event RecordSet(string indexed key, address indexed value);\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice The number of unique keys.\\n    function length() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the `value` of a given `key`.\\n     * Reverts if the key is not in the mapping.\\n     * @param key The key to query.\\n     * @param value The value of the key.\\n     */\\n    function get(string calldata key) external view returns (address value);\\n\\n    /**\\n     * @notice Gets the `value` of a given `key`.\\n     * Fails gracefully if the key is not in the mapping.\\n     * @param key The key to query.\\n     * @param success True if the key was found, false otherwise.\\n     * @param value The value of the key or zero if it was not found.\\n     */\\n    function tryGet(string calldata key) external view returns (bool success, address value);\\n\\n    /**\\n     * @notice Gets the `key` of a given `index`.\\n     * @dev Iterable [1,length].\\n     * @param index The index to query.\\n     * @return key The key at that index.\\n     */\\n    function getKey(uint256 index) external view returns (string memory key);\\n\\n    /***************************************\\n    GOVERNANCE FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Sets keys and values.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param keys The keys to set.\\n     * @param values The values to set.\\n     */\\n    function set(string[] calldata keys, address[] calldata values) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/risk/IRiskManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n\\n/**\\n * @title IRiskManager\\n * @author solace.fi\\n * @notice Calculates the acceptable risk, sellable cover, and capital requirements of Solace products and capital pool.\\n *\\n * The total amount of sellable coverage is proportional to the assets in the [**risk backing capital pool**](../Vault). The max cover is split amongst products in a weighting system. [**Governance**](/docs/protocol/governance). can change these weights and with it each product's sellable cover.\\n *\\n * The minimum capital requirement is proportional to the amount of cover sold to [active policies](../PolicyManager).\\n *\\n * Solace can use leverage to sell more cover than the available capital. The amount of leverage is stored as [`partialReservesFactor`](#partialreservesfactor) and is settable by [**governance**](/docs/protocol/governance).\\n */\\ninterface IRiskManager {\\n\\n    /***************************************\\n    TYPE DEFINITIONS\\n    ***************************************/\\n\\n    enum StrategyStatus {\\n       INACTIVE,\\n       ACTIVE\\n    }\\n\\n    struct Strategy {\\n        uint256 id;\\n        uint32 weight;\\n        StrategyStatus status;\\n        uint256 timestamp;\\n    }\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when new strategy is created.\\n    event StrategyAdded(address strategy);\\n\\n    /// @notice Emitted when strategy status is updated.\\n    event StrategyStatusUpdated(address strategy, uint8 status);\\n\\n    /// @notice Emitted when strategy's allocation weight is increased.\\n    event RiskStrategyWeightAllocationIncreased(address strategy, uint32 weight);\\n\\n    /// @notice Emitted when strategy's allocation weight is decreased.\\n    event RiskStrategyWeightAllocationDecreased(address strategy, uint32 weight);\\n\\n    /// @notice Emitted when strategy's allocation weight is set.\\n    event RiskStrategyWeightAllocationSet(address strategy, uint32 weight);\\n\\n    /// @notice Emitted when the partial reserves factor is set.\\n    event PartialReservesFactorSet(uint16 partialReservesFactor);\\n\\n    /// @notice Emitted when the cover limit amount of the strategy is updated.\\n    event ActiveCoverLimitUpdated(address strategy, uint256 oldCoverLimit, uint256 newCoverLimit);\\n\\n    /// @notice Emitted when the cover limit updater is set.\\n    event CoverLimitUpdaterAdded(address updater);\\n\\n    /// @notice Emitted when the cover limit updater is removed.\\n    event CoverLimitUpdaterDeleted(address updater);\\n\\n    /***************************************\\n    RISK MANAGER MUTUTATOR FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Adds a new `Risk Strategy` to the `Risk Manager`. The community votes the strategy for coverage weight allocation.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param strategy_ The address of the risk strategy.\\n     * @return index The index of the risk strategy.\\n    */\\n    function addRiskStrategy(address strategy_) external returns (uint256 index);\\n\\n    /**\\n     * @notice Sets the weight of the `Risk Strategy`.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param strategy_ The address of the risk strategy.\\n     * @param weight_ The value to set.\\n    */\\n    function setWeightAllocation(address strategy_, uint32 weight_) external;\\n\\n    /**\\n     * @notice Sets the status of the `Risk Strategy`.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param strategy_ The address of the risk strategy.\\n     * @param status_ The status to set.\\n    */\\n    function setStrategyStatus(address strategy_, uint8 status_) external;\\n\\n   /**\\n     * @notice Updates the active cover limit amount for the given strategy. \\n     * This function is only called by valid requesters when a new policy is bought or updated.\\n     * @dev The policy manager and soteria will call this function for now.\\n     * @param strategy The strategy address to add cover limit.\\n     * @param currentCoverLimit The current cover limit amount of the strategy's product.\\n     * @param newCoverLimit The new cover limit amount of the strategy's product.\\n    */\\n    function updateActiveCoverLimitForStrategy(address strategy, uint256 currentCoverLimit, uint256 newCoverLimit) external;\\n\\n    /**\\n     * @notice Adds new address to allow updating cover limit amounts.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param updater The address that can update cover limit.\\n    */\\n    function addCoverLimitUpdater(address updater) external ;\\n\\n    /**\\n     * @notice Removes the cover limit updater.\\n     * @param updater The address of updater to remove.\\n    */\\n    function removeCoverLimitUpdater(address updater) external;\\n\\n    /***************************************\\n    RISK MANAGER VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Checks is an address is an active strategy.\\n     * @param strategy_ The risk strategy.\\n     * @return status True if the strategy is active.\\n    */\\n    function strategyIsActive(address strategy_) external view returns (bool status);\\n\\n     /**\\n      * @notice Return the strategy at an index.\\n      * @dev Enumerable `[1, numStrategies]`.\\n      * @param index_ Index to query.\\n      * @return strategy The product address.\\n    */\\n    function strategyAt(uint256 index_) external view returns (address strategy);\\n\\n    /**\\n     * @notice Returns the number of registered strategies..\\n     * @return count The number of strategies.\\n    */\\n    function numStrategies() external view returns (uint256 count);\\n\\n    /**\\n     * @notice Returns the risk strategy information.\\n     * @param strategy_ The risk strategy.\\n     * @return id The id of the risk strategy.\\n     * @return weight The risk strategy weight allocation.\\n     * @return status The status of risk strategy.\\n     * @return timestamp The added time of the risk strategy.\\n     *\\n    */\\n    function strategyInfo(address strategy_) external view returns (uint256 id, uint32 weight, StrategyStatus status, uint256 timestamp);\\n\\n    /**\\n     * @notice Returns the allocated weight for the risk strategy.\\n     * @param strategy_ The risk strategy.\\n     * @return weight The risk strategy weight allocation.\\n    */\\n    function weightPerStrategy(address strategy_) external view returns (uint32 weight);\\n\\n    /**\\n     * @notice The maximum amount of cover for given strategy can sell.\\n     * @return cover The max amount of cover in wei.\\n     */\\n    function maxCoverPerStrategy(address strategy_) external view returns (uint256 cover);\\n\\n    /**\\n     * @notice Returns the current amount covered (in wei).\\n     * @return amount The covered amount (in wei).\\n    */\\n    function activeCoverLimit() external view returns (uint256 amount);\\n\\n    /**\\n     * @notice Returns the current amount covered (in wei).\\n     * @param riskStrategy The risk strategy address.\\n     * @return amount The covered amount (in wei).\\n    */\\n    function activeCoverLimitPerStrategy(address riskStrategy) external view returns (uint256 amount);\\n\\n    /***************************************\\n    MAX COVER VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice The maximum amount of cover that Solace as a whole can sell.\\n     * @return cover The max amount of cover in wei.\\n     */\\n    function maxCover() external view returns (uint256 cover);\\n\\n    /**\\n     * @notice Returns the sum of allocation weights for all strategies.\\n     * @return sum WeightSum.\\n     */\\n    function weightSum() external view returns (uint32 sum);\\n\\n    /***************************************\\n    MIN CAPITAL VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice The minimum amount of capital required to safely cover all policies.\\n     * @return mcr The minimum capital requirement.\\n     */\\n    function minCapitalRequirement() external view returns (uint256 mcr);\\n\\n    /**\\n     * @notice The minimum amount of capital required to safely cover all policies.\\n     * @param strategy_ The risk strategy.\\n     * @return mcr The minimum capital requirement.\\n     */\\n    function minCapitalRequirementPerStrategy(address strategy_) external view returns (uint256 mcr);\\n\\n    /**\\n     * @notice Multiplier for minimum capital requirement.\\n     * @return factor Partial reserves factor in BPS.\\n     */\\n    function partialReservesFactor() external view returns (uint16 factor);\\n\\n    /**\\n     * @notice Sets the partial reserves factor.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param partialReservesFactor_ New partial reserves factor in BPS.\\n     */\\n    function setPartialReservesFactor(uint16 partialReservesFactor_) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/utils/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title IGovernable\\n * @author solace.fi\\n * @notice Enforces access control for important functions to [**governor**](/docs/protocol/governance).\\n *\\n * Many contracts contain functionality that should only be accessible to a privileged user. The most common access control pattern is [OpenZeppelin's `Ownable`](https://docs.openzeppelin.com/contracts/4.x/access-control#ownership-and-ownable). We instead use `Governable` with a few key differences:\\n * - Transferring the governance role is a two step process. The current governance must [`setPendingGovernance(pendingGovernance_)`](#setpendinggovernance) then the new governance must [`acceptGovernance()`](#acceptgovernance). This is to safeguard against accidentally setting ownership to the wrong address and locking yourself out of your contract.\\n * - `governance` is a constructor argument instead of `msg.sender`. This is especially useful when deploying contracts via a [`SingletonFactory`](./ISingletonFactory).\\n * - We use `lockGovernance()` instead of `renounceOwnership()`. `renounceOwnership()` is a prerequisite for the reinitialization bug because it sets `owner = address(0x0)`. We also use the `governanceIsLocked()` flag.\\n */\\ninterface IGovernable {\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when pending Governance is set.\\n    event GovernancePending(address pendingGovernance);\\n    /// @notice Emitted when Governance is set.\\n    event GovernanceTransferred(address oldGovernance, address newGovernance);\\n    /// @notice Emitted when Governance is locked.\\n    event GovernanceLocked();\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice Address of the current governor.\\n    function governance() external view returns (address);\\n\\n    /// @notice Address of the governor to take over.\\n    function pendingGovernance() external view returns (address);\\n\\n    /// @notice Returns true if governance is locked.\\n    function governanceIsLocked() external view returns (bool);\\n\\n    /***************************************\\n    MUTATORS\\n    ***************************************/\\n\\n    /**\\n     * @notice Initiates transfer of the governance role to a new governor.\\n     * Transfer is not complete until the new governor accepts the role.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param pendingGovernance_ The new governor.\\n     */\\n    function setPendingGovernance(address pendingGovernance_) external;\\n\\n    /**\\n     * @notice Accepts the governance role.\\n     * Can only be called by the new governor.\\n     */\\n    function acceptGovernance() external;\\n\\n    /**\\n     * @notice Permanently locks this contract's governance role and any of its functions that require the role.\\n     * This action cannot be reversed.\\n     * Before you call it, ask yourself:\\n     *   - Is the contract self-sustaining?\\n     *   - Is there a chance you will need governance privileges in the future?\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     */\\n    function lockGovernance() external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldCoverLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCoverLimit\",\"type\":\"uint256\"}],\"name\":\"ActiveCoverLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"}],\"name\":\"CoverLimitUpdaterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"}],\"name\":\"CoverLimitUpdaterDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"GovernanceLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingGovernance\",\"type\":\"address\"}],\"name\":\"GovernancePending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGovernance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"partialReservesFactor\",\"type\":\"uint16\"}],\"name\":\"PartialReservesFactorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"weight\",\"type\":\"uint32\"}],\"name\":\"RiskStrategyWeightAllocationDecreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"weight\",\"type\":\"uint32\"}],\"name\":\"RiskStrategyWeightAllocationIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"weight\",\"type\":\"uint32\"}],\"name\":\"RiskStrategyWeightAllocationSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"StrategyAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"StrategyStatusUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeCoverLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"riskStrategy\",\"type\":\"address\"}],\"name\":\"activeCoverLimitPerStrategy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"}],\"name\":\"addCoverLimitUpdater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy_\",\"type\":\"address\"}],\"name\":\"addRiskStrategy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canUpdateCoverLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceIsLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxCover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cover\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy_\",\"type\":\"address\"}],\"name\":\"maxCoverPerStrategy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cover\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minCapitalRequirement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mcr\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"minCapitalRequirementPerStrategy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"smcr\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numStrategies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partialReservesFactor\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"factor\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"}],\"name\":\"removeCoverLimitUpdater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"partialReservesFactor_\",\"type\":\"uint16\"}],\"name\":\"setPartialReservesFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingGovernance_\",\"type\":\"address\"}],\"name\":\"setPendingGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy_\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"status_\",\"type\":\"uint8\"}],\"name\":\"setStrategyStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy_\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"weight_\",\"type\":\"uint32\"}],\"name\":\"setWeightAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"}],\"name\":\"strategyAt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy_\",\"type\":\"address\"}],\"name\":\"strategyInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"weight\",\"type\":\"uint32\"},{\"internalType\":\"enum IRiskManager.StrategyStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy_\",\"type\":\"address\"}],\"name\":\"strategyIsActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentCoverLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newCoverLimit\",\"type\":\"uint256\"}],\"name\":\"updateActiveCoverLimitForStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy_\",\"type\":\"address\"}],\"name\":\"weightPerStrategy\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"weight\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weightSum\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"sum\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RiskManager", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000501ace0e8d16b92236763e2ded7ae3bc2dffa276000000000000000000000000501ace0f576fc4ef9c0380aa46a578ea96b85776", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}