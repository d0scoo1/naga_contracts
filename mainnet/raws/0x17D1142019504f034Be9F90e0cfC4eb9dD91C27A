{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/resolvers/mainnet/v1/main.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"./helpers.sol\\\";\\n\\ncontract InstaVaultResolver is Helpers {\\n    struct VaultInfo {\\n        address vaultAddr;\\n        address vaultDsa;\\n        uint256 revenue;\\n        uint256 revenueFee;\\n        VaultInterface.Ratios ratios;\\n        uint256 lastRevenueExchangePrice;\\n        uint256 exchangePrice;\\n        uint256 totalSupply;\\n        uint256 netCollateral;\\n        uint256 netBorrow;\\n        VaultInterface.BalVariables balances;\\n        uint256 netSupply;\\n        uint256 netBal;\\n    }\\n\\n    function getVaultInfo() public view returns (VaultInfo memory vaultInfo_) {\\n        vaultInfo_.vaultAddr = address(vault);\\n        vaultInfo_.vaultDsa = vault.vaultDsa();\\n        vaultInfo_.revenue = vault.revenue();\\n        vaultInfo_.revenueFee = vault.revenueFee();\\n        vaultInfo_.ratios = vault.ratios();\\n        vaultInfo_.lastRevenueExchangePrice = vault.lastRevenueExchangePrice();\\n        (vaultInfo_.exchangePrice, ) = vault.getCurrentExchangePrice();\\n        vaultInfo_.totalSupply = vault.totalSupply();\\n        (\\n            vaultInfo_.netCollateral,\\n            vaultInfo_.netBorrow,\\n            vaultInfo_.balances,\\n            vaultInfo_.netSupply,\\n            vaultInfo_.netBal\\n        ) = vault.netAssets();\\n    }\\n\\n    function getUserInfo(address user_)\\n        public\\n        view\\n        returns (\\n            VaultInfo memory vaultInfo_,\\n            uint256 vtokenBal_,\\n            uint256 amount_\\n        )\\n    {\\n        vaultInfo_ = getVaultInfo();\\n        vtokenBal_ = vault.balanceOf(user_);\\n        amount_ = (vtokenBal_ * vaultInfo_.exchangePrice) / 1e18;\\n    }\\n\\n    struct RebalanceVariables {\\n        uint256 netCollateral;\\n        uint256 netBorrow;\\n        VaultInterface.BalVariables balances;\\n        uint256 netBal;\\n        uint256 netStEth;\\n        int256 netWeth;\\n        uint256 ratio;\\n        uint256 targetRatioDif;\\n        uint256[] deleverageAmts;\\n        uint256 hf;\\n        bool hfIsOk;\\n    }\\n\\n    // This function gives data around leverage position\\n    function rebalanceOneData(address[] memory vaultsToCheck_)\\n        public\\n        view\\n        returns (\\n            uint256 finalCol_,\\n            uint256 finalDebt_,\\n            address flashTkn_,\\n            uint256 flashAmt_,\\n            uint256 route_,\\n            address[] memory vaults_,\\n            uint256[] memory amts_,\\n            uint256 excessDebt_,\\n            uint256 paybackDebt_,\\n            uint256 totalAmountToSwap_,\\n            uint256 extraWithdraw_,\\n            bool isRisky_\\n        )\\n    {\\n        RebalanceVariables memory v_;\\n        (v_.netCollateral, v_.netBorrow, v_.balances, , v_.netBal) = vault\\n            .netAssets();\\n        if (v_.balances.wethVaultBal <= 1e14) v_.balances.wethVaultBal = 0;\\n        if (v_.balances.stethVaultBal <= 1e14) v_.balances.stethVaultBal = 0;\\n        VaultInterface.Ratios memory ratios_ = vault.ratios();\\n        v_.netStEth =\\n            v_.netCollateral +\\n            v_.balances.stethVaultBal +\\n            v_.balances.stethDsaBal;\\n        v_.netWeth =\\n            int256(v_.balances.wethVaultBal + v_.balances.wethDsaBal) -\\n            int256(v_.netBorrow);\\n        v_.ratio = v_.netWeth < 0\\n            ? (uint256(-v_.netWeth) * 1e4) / v_.netStEth\\n            : 0;\\n        v_.targetRatioDif = 10000 - (ratios_.minLimit - 10); // taking 0.1% more dif for margin\\n        if (v_.ratio < ratios_.minLimitGap) {\\n            // leverage till minLimit <> minLimitGap\\n            // final difference between collateral & debt in percent\\n            finalCol_ = (v_.netBal * 1e4) / v_.targetRatioDif;\\n            finalDebt_ = finalCol_ - v_.netBal;\\n            excessDebt_ = finalDebt_ - v_.netBorrow;\\n            flashTkn_ = wethAddr;\\n            flashAmt_ = (v_.netCollateral / 10) + ((excessDebt_ * 10) / 8); // 10% of current collateral + excessDebt / 0.8\\n            route_ = 5;\\n            totalAmountToSwap_ =\\n                excessDebt_ +\\n                v_.balances.wethVaultBal +\\n                v_.balances.wethDsaBal;\\n            v_.deleverageAmts = getMaxDeleverageAmts(vaultsToCheck_);\\n            (vaults_, amts_, totalAmountToSwap_) = getVaultsToUse(\\n                vaultsToCheck_,\\n                v_.deleverageAmts,\\n                totalAmountToSwap_\\n            );\\n            (, , , , , v_.hf) = IAaveLendingPool(\\n                aaveAddressProvider.getLendingPool()\\n            ).getUserAccountData(vault.vaultDsa());\\n            v_.hfIsOk = v_.hf > 1015 * 1e15;\\n            // only withdraw from aave position if position is safe\\n            if (v_.hfIsOk) {\\n                // keeping as non collateral for easier withdrawals\\n                extraWithdraw_ =\\n                    finalCol_ -\\n                    ((finalDebt_ * 1e4) / (ratios_.maxLimit - 10));\\n            }\\n        } else {\\n            finalCol_ = v_.netStEth;\\n            finalDebt_ = uint256(-v_.netWeth);\\n            paybackDebt_ = v_.balances.wethVaultBal + v_.balances.wethDsaBal;\\n            (, , , , , v_.hf) = IAaveLendingPool(\\n                aaveAddressProvider.getLendingPool()\\n            ).getUserAccountData(vault.vaultDsa());\\n            v_.hfIsOk = v_.hf > 1015 * 1e15;\\n            // only withdraw from aave position if position is safe\\n            if (v_.ratio < (ratios_.maxLimit - 10) && v_.hfIsOk) {\\n                extraWithdraw_ =\\n                    finalCol_ -\\n                    ((finalDebt_ * 1e4) / (ratios_.maxLimit - 10));\\n            }\\n        }\\n        if (v_.ratio > ratios_.maxLimit) {\\n            isRisky_ = true;\\n        }\\n\\n        if (excessDebt_ < 1e14) excessDebt_ = 0;\\n        if (paybackDebt_ < 1e14) paybackDebt_ = 0;\\n        if (totalAmountToSwap_ < 1e14) totalAmountToSwap_ = 0;\\n        if (extraWithdraw_ < 1e14) extraWithdraw_ = 0;\\n    }\\n\\n    function rebalanceTwoData()\\n        public\\n        view\\n        returns (\\n            uint256 finalCol_,\\n            uint256 finalDebt_,\\n            uint256 withdrawAmt_,\\n            address flashTkn_,\\n            uint256 flashAmt_,\\n            uint256 route_,\\n            uint256 saveAmt_\\n        )\\n    {\\n        RebalanceVariables memory v_;\\n        (v_.netCollateral, v_.netBorrow, v_.balances, , v_.netBal) = vault\\n            .netAssets();\\n        if (v_.balances.wethVaultBal <= 1e14) v_.balances.wethVaultBal = 0;\\n        if (v_.balances.stethVaultBal <= 1e14) v_.balances.stethVaultBal = 0;\\n        VaultInterface.Ratios memory ratios_ = vault.ratios();\\n        v_.netStEth =\\n            v_.netCollateral +\\n            v_.balances.stethVaultBal +\\n            v_.balances.stethDsaBal;\\n        v_.netWeth =\\n            int256(v_.balances.wethVaultBal + v_.balances.wethDsaBal) -\\n            int256(v_.netBorrow);\\n        v_.ratio = v_.netWeth < 0\\n            ? (uint256(-v_.netWeth) * 1e4) / v_.netStEth\\n            : 0;\\n        v_.targetRatioDif = 10000 - (ratios_.minLimit - 10); // taking 0.1% more dif for margin\\n        if (v_.ratio > ratios_.maxLimit) {\\n            finalCol_ = (v_.netBal * 1e4) / v_.targetRatioDif;\\n            finalDebt_ = finalCol_ - v_.netBal;\\n            saveAmt_ = v_.netBorrow - finalDebt_;\\n            flashTkn_ = wethAddr;\\n            flashAmt_ = (v_.netCollateral / 10) + ((saveAmt_ * 10) / 8); // 10% of current collateral + saveAmt_ / 0.8\\n            route_ = 5;\\n            (, , , , , v_.hf) = IAaveLendingPool(\\n                aaveAddressProvider.getLendingPool()\\n            ).getUserAccountData(vault.vaultDsa());\\n            v_.hfIsOk = v_.hf > 1015 * 1e15;\\n            // only withdraw from aave position if position is safe\\n            if (v_.hfIsOk) {\\n                // keeping as non collateral for easier withdrawals\\n                withdrawAmt_ =\\n                    finalCol_ -\\n                    ((finalDebt_ * 1e4) / (ratios_.maxLimit - 10));\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/resolvers/mainnet/v1/helpers.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces.sol\\\";\\n\\ncontract Helpers {\\n    VaultInterface public constant vault =\\n        VaultInterface(0xc383a3833A87009fD9597F8184979AF5eDFad019);\\n    IAaveAddressProvider internal constant aaveAddressProvider =\\n        IAaveAddressProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);\\n    address internal constant wethAddr =\\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address internal constant stEthAddr =\\n        0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\\n\\n    function getMaxDeleverageAmt(address vaultAddr_)\\n        internal\\n        view\\n        returns (uint256 amount_)\\n    {\\n        Vault2Interface vault_ = Vault2Interface(vaultAddr_);\\n        address tokenAddr_ = vault_.token();\\n        uint256 tokenDecimals_ = vault_.decimals();\\n        (\\n            ,\\n            uint256 stethCollateral_,\\n            uint256 wethDebt_,\\n            ,\\n            ,\\n            uint256 netTokenBal_\\n        ) = vault_.getVaultBalances();\\n        Vault2Interface.Ratios memory ratios_ = vault_.ratios();\\n        uint256 ethCoveringDebt_ = (stethCollateral_ * ratios_.stEthLimit) /\\n            10000;\\n        uint256 excessDebt_ = ethCoveringDebt_ < wethDebt_\\n            ? wethDebt_ - ethCoveringDebt_\\n            : 0;\\n        uint256 tokenPriceInEth_ = IAavePriceOracle(\\n            aaveAddressProvider.getPriceOracle()\\n        ).getAssetPrice(tokenAddr_);\\n        uint256 netTokenSupplyInEth_ = (netTokenBal_ * tokenPriceInEth_) /\\n            (10**tokenDecimals_);\\n        uint256 currentRatioMin_ = netTokenSupplyInEth_ == 0\\n            ? 0\\n            : (excessDebt_ * 10000) / netTokenSupplyInEth_;\\n        if (currentRatioMin_ > ratios_.minLimit) {\\n            // keeping 0.1% margin for final ratio\\n            amount_ =\\n                ((currentRatioMin_ - (ratios_.minLimitGap + 10)) *\\n                    netTokenSupplyInEth_) /\\n                (10000 - ratios_.stEthLimit);\\n        }\\n    }\\n\\n    function getMaxDeleverageAmts(address[] memory vaults_)\\n        internal\\n        view\\n        returns (uint256[] memory amounts_)\\n    {\\n        amounts_ = new uint256[](vaults_.length);\\n        for (uint256 i = 0; i < vaults_.length; i++) {\\n            amounts_[i] = getMaxDeleverageAmt(vaults_[i]);\\n        }\\n    }\\n\\n    function bubbleSort(address[] memory vaults_, uint256[] memory amounts_)\\n        internal\\n        pure\\n        returns (address[] memory, uint256[] memory)\\n    {\\n        for (uint256 i = 0; i < amounts_.length - 1; i++) {\\n            for (uint256 j = 0; j < amounts_.length - i - 1; j++) {\\n                if (amounts_[j] < amounts_[j + 1]) {\\n                    (\\n                        vaults_[j],\\n                        vaults_[j + 1],\\n                        amounts_[j],\\n                        amounts_[j + 1]\\n                    ) = (\\n                        vaults_[j + 1],\\n                        vaults_[j],\\n                        amounts_[j + 1],\\n                        amounts_[j]\\n                    );\\n                }\\n            }\\n        }\\n        return (vaults_, amounts_);\\n    }\\n\\n    function getTrimmedArrays(\\n        address[] memory vaults_,\\n        uint256[] memory amounts_,\\n        uint256 length_\\n    )\\n        internal\\n        pure\\n        returns (address[] memory finalVaults_, uint256[] memory finalAmts_)\\n    {\\n        finalVaults_ = new address[](length_);\\n        finalAmts_ = new uint256[](length_);\\n        for (uint256 i = 0; i < length_; i++) {\\n            finalVaults_[i] = vaults_[i];\\n            finalAmts_[i] = amounts_[i];\\n        }\\n    }\\n\\n    function getVaultsToUse(\\n        address[] memory vaultsToCheck_,\\n        uint256[] memory deleverageAmts_,\\n        uint256 totalSwapAmt_\\n    )\\n        internal\\n        pure\\n        returns (\\n            address[] memory vaults_,\\n            uint256[] memory amounts_,\\n            uint256 swapAmt_\\n        )\\n    {\\n        (vaults_, amounts_) = bubbleSort(vaultsToCheck_, deleverageAmts_);\\n        swapAmt_ = totalSwapAmt_;\\n        uint256 i;\\n        while (swapAmt_ > 0 && i < vaults_.length && amounts_[i] > 0) {\\n            if (amounts_[i] > swapAmt_) amounts_[i] = swapAmt_;\\n            swapAmt_ -= amounts_[i];\\n            i++;\\n        }\\n        if (i != vaults_.length)\\n            (vaults_, amounts_) = getTrimmedArrays(vaults_, amounts_, i);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/resolvers/mainnet/v1/interfaces.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface VaultInterface {\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function getCurrentExchangePrice()\\n        external\\n        view\\n        returns (uint256 exchangePrice_, uint256 newRevenue_);\\n\\n    struct BalVariables {\\n        uint256 wethVaultBal;\\n        uint256 wethDsaBal;\\n        uint256 stethVaultBal;\\n        uint256 stethDsaBal;\\n        uint256 totalBal;\\n    }\\n\\n    function netAssets()\\n        external\\n        view\\n        returns (\\n            uint256 netCollateral_,\\n            uint256 netBorrow_,\\n            BalVariables memory balances_,\\n            uint256 netSupply_,\\n            uint256 netBal_\\n        );\\n\\n    struct Ratios {\\n        uint16 maxLimit; // Above this withdrawals are not allowed\\n        uint16 minLimit; // After leverage the ratio should be below minLimit & above minLimitGap\\n        uint16 minLimitGap;\\n        // send borrow rate in 4 decimals from UI. In the smart contract it'll convert to 27 decimals which where is 100%\\n        uint128 maxBorrowRate; // maximum borrow rate above this leveraging should not happen\\n    }\\n\\n    // maximum borrow rate. If above this limit then leverage won't happen\\n    function ratios() external view returns (Ratios memory);\\n\\n    function vaultDsa() external view returns (address);\\n\\n    function lastRevenueExchangePrice() external view returns (uint256);\\n\\n    function revenueFee() external view returns (uint256);\\n\\n    function revenue() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface IAaveAddressProvider {\\n    function getPriceOracle() external view returns (address);\\n\\n    function getLendingPool() external view returns (address);\\n}\\n\\ninterface IAavePriceOracle {\\n    function getAssetPrice(address _asset) external view returns (uint256);\\n}\\n\\ninterface IAaveLendingPool {\\n    function getUserAccountData(address) external view returns (uint256, uint256, uint256, uint256, uint256, uint256);\\n}\\n\\ninterface Vault2Interface {\\n    function token() external view returns (address);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function tokenMinLimit() external view returns (uint256);\\n\\n    function atoken() external view returns (address);\\n\\n    function vaultDsa() external view returns (address);\\n\\n    struct Ratios {\\n        uint16 maxLimit; // Above this withdrawals are not allowed\\n        uint16 maxLimitGap;\\n        uint16 minLimit; // After leverage the ratio should be below minLimit & above minLimitGap\\n        uint16 minLimitGap;\\n        uint16 stEthLimit; // if 7500. Meaning stETH collateral covers 75% of the ETH debt. Excess ETH will be covered by token limit.\\n        // send borrow rate in 4 decimals from UI. In the smart contract it'll convert to 27 decimals which where is 100%\\n        uint128 maxBorrowRate; // maximum borrow rate above this leveraging should not happen\\n    }\\n\\n    function ratios() external view returns (Ratios memory);\\n\\n    function getCurrentExchangePrice()\\n        external\\n        view\\n        returns (uint256 exchangePrice_, uint256 newRevenue_);\\n\\n    function lastRevenueExchangePrice() external view returns (uint256);\\n\\n    function revenueFee() external view returns (uint256);\\n\\n    function revenue() external view returns (uint256);\\n\\n    function revenueEth() external view returns (uint256);\\n\\n    function withdrawalFee() external view returns (uint256);\\n\\n    function idealExcessAmt() external view returns (uint256);\\n\\n    function swapFee() external view returns (uint256);\\n\\n    function deleverageFee() external view returns (uint256);\\n\\n    function saveSlippage() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function getVaultBalances()\\n        external\\n        view\\n        returns (\\n            uint256 tokenCollateralAmt_,\\n            uint256 stethCollateralAmt_,\\n            uint256 wethDebtAmt_,\\n            uint256 tokenVaultBal_,\\n            uint256 tokenDSABal_,\\n            uint256 netTokenBal_\\n        );\\n\\n    function getNewProfits() external view returns (uint256 profits_);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vaultAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultDsa\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"revenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revenueFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"maxLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minLimitGap\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"maxBorrowRate\",\"type\":\"uint128\"}],\"internalType\":\"struct VaultInterface.Ratios\",\"name\":\"ratios\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lastRevenueExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netBorrow\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wethVaultBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethDsaBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stethVaultBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stethDsaBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBal\",\"type\":\"uint256\"}],\"internalType\":\"struct VaultInterface.BalVariables\",\"name\":\"balances\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"netSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netBal\",\"type\":\"uint256\"}],\"internalType\":\"struct InstaVaultResolver.VaultInfo\",\"name\":\"vaultInfo_\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"vtokenBal_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vaultAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultDsa\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"revenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revenueFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"maxLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minLimitGap\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"maxBorrowRate\",\"type\":\"uint128\"}],\"internalType\":\"struct VaultInterface.Ratios\",\"name\":\"ratios\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lastRevenueExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netBorrow\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wethVaultBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethDsaBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stethVaultBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stethDsaBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBal\",\"type\":\"uint256\"}],\"internalType\":\"struct VaultInterface.BalVariables\",\"name\":\"balances\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"netSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netBal\",\"type\":\"uint256\"}],\"internalType\":\"struct InstaVaultResolver.VaultInfo\",\"name\":\"vaultInfo_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaultsToCheck_\",\"type\":\"address[]\"}],\"name\":\"rebalanceOneData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"finalCol_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalDebt_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"flashTkn_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flashAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"route_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"vaults_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amts_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"excessDebt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paybackDebt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountToSwap_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraWithdraw_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isRisky_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalanceTwoData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"finalCol_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalDebt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmt_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"flashTkn_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flashAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"route_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveAmt_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract VaultInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "InstaVaultResolver", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}