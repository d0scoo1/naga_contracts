{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.8.4;\r\n\r\n/// @notice Safe ETH and ERC-20 transfer library that gracefully handles missing return values.\r\n/// @author Modified from SolMate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// License-Identifier: AGPL-3.0-only\r\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\nlibrary SafeTransferLib {\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERRORS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    error ETHtransferFailed();\r\n\r\n    error TransferFailed();\r\n\r\n    error TransferFromFailed();\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ETH OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _safeTransferETH(address to, uint256 amount) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // transfer the ETH and store if it succeeded or not\r\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        if (!callStatus) revert ETHtransferFailed();\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERC20 OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // get a pointer to some free memory\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // begin with the function selector\r\n            \r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // mask and append the \"to\" argument\r\n            \r\n            mstore(add(freeMemoryPointer, 36), amount) // finally append the \"amount\" argument - no mask as it's a full 32 byte value\r\n\r\n            // call the token and store if it succeeded or not\r\n            // we use 68 because the calldata length is 4 + 32 * 2\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n        }\r\n\r\n        if (!_didLastOptionalReturnCallSucceed(callStatus)) revert TransferFailed();\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // get a pointer to some free memory\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // begin with the function selector\r\n            \r\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // mask and append the \"from\" argument\r\n            \r\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // mask and append the \"to\" argument\r\n            \r\n            mstore(add(freeMemoryPointer, 68), amount) // finally append the \"amount\" argument - no mask as it's a full 32 byte value\r\n\r\n            // call the token and store if it succeeded or not\r\n            // we use 100 because the calldata length is 4 + 32 * 3\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\r\n        }\r\n\r\n        if (!_didLastOptionalReturnCallSucceed(callStatus)) revert TransferFromFailed();\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            INTERNAL HELPER LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _didLastOptionalReturnCallSucceed(bool callStatus) internal pure returns (bool success) {\r\n        assembly {\r\n            // get how many bytes the call returned\r\n            let returnDataSize := returndatasize()\r\n\r\n            // if the call reverted:\r\n            if iszero(callStatus) {\r\n                // copy the revert message into memory\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // revert with the same message\r\n                revert(0, returnDataSize)\r\n            }\r\n\r\n            switch returnDataSize\r\n            \r\n            case 32 {\r\n                // copy the return data into memory\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // set success to whether it returned true\r\n                success := iszero(iszero(mload(0)))\r\n            }\r\n            case 0 {\r\n                // there was no return data\r\n                success := 1\r\n            }\r\n            default {\r\n                // it returned some malformed input\r\n                success := 0\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Kali DAO tribute escrow interface.\r\ninterface IKaliDAOtribute {\r\n    enum ProposalType {\r\n        MINT, \r\n        BURN, \r\n        CALL, \r\n        VPERIOD,\r\n        GPERIOD, \r\n        QUORUM, \r\n        SUPERMAJORITY, \r\n        TYPE, \r\n        PAUSE, \r\n        EXTENSION,\r\n        ESCAPE,\r\n        DOCS\r\n    }\r\n\r\n    struct ProposalState {\r\n        bool passed;\r\n        bool processed;\r\n    }\r\n\r\n    function proposalStates(uint256 proposal) external view returns (ProposalState memory);\r\n\r\n    function propose(\r\n        ProposalType proposalType,\r\n        string calldata description,\r\n        address[] calldata accounts,\r\n        uint256[] calldata amounts,\r\n        bytes[] calldata payloads\r\n    ) external returns (uint256 proposal);\r\n\r\n    function cancelProposal(uint256 proposal) external;\r\n\r\n    function processProposal(uint256 proposal) external returns (bool didProposalPass, bytes[] memory results);\r\n}\r\n\r\n/// @notice Helper utility that enables calling multiple local methods in a single call.\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol)\r\nabstract contract Multicall {\r\n    function multicall(bytes[] calldata data) public virtual returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        \r\n        // cannot realistically overflow on human timescales\r\n        unchecked {\r\n            for (uint256 i = 0; i < data.length; i++) {\r\n                (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n\r\n                if (!success) {\r\n                    if (result.length < 68) revert();\r\n                    \r\n                    assembly {\r\n                        result := add(result, 0x04)\r\n                    }\r\n                    \r\n                    revert(abi.decode(result, (string)));\r\n                }\r\n                results[i] = result;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Gas-optimized reentrancy protection.\r\n/// @author Modified from OpenZeppelin \r\n/// (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\r\n/// License-Identifier: MIT\r\nabstract contract ReentrancyGuard {\r\n    error Reentrancy();\r\n\r\n    uint256 private constant NOT_ENTERED = 1;\r\n\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private status = NOT_ENTERED;\r\n\r\n    modifier nonReentrant() {\r\n        if (status == ENTERED) revert Reentrancy();\r\n\r\n        status = ENTERED;\r\n\r\n        _;\r\n\r\n        status = NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/// @notice Tribute contract that escrows ETH, ERC-20 or NFT for Kali DAO proposals.\r\ncontract KaliDAOtribute is Multicall, ReentrancyGuard {\r\n    using SafeTransferLib for address;\r\n\r\n    event NewTributeProposal(\r\n        IKaliDAOtribute indexed dao,\r\n        address indexed proposer, \r\n        uint256 indexed proposal, \r\n        address asset, \r\n        bool nft,\r\n        uint256 value\r\n    );\r\n\r\n    event TributeProposalCancelled(IKaliDAOtribute indexed dao, uint256 indexed proposal);\r\n\r\n    event TributeProposalReleased(IKaliDAOtribute indexed dao, uint256 indexed proposal);\r\n    \r\n    error NotProposer();\r\n\r\n    error Sponsored(); \r\n\r\n    error NotProposal();\r\n\r\n    error NotProcessed();\r\n\r\n    mapping(IKaliDAOtribute => mapping(uint256 => Tribute)) public tributes;\r\n\r\n    struct Tribute {\r\n        address proposer;\r\n        address asset;\r\n        bool nft;\r\n        uint256 value;\r\n    }\r\n\r\n    function submitTributeProposal(\r\n        IKaliDAOtribute dao,\r\n        IKaliDAOtribute.ProposalType proposalType, \r\n        string memory description,\r\n        address[] calldata accounts,\r\n        uint256[] calldata amounts,\r\n        bytes[] calldata payloads,\r\n        bool nft,\r\n        address asset, \r\n        uint256 value\r\n    ) public payable nonReentrant virtual {\r\n        // escrow tribute\r\n        if (msg.value != 0) {\r\n            asset = address(0);\r\n            value = msg.value;\r\n            if (nft) nft = false;\r\n        } else {\r\n            asset._safeTransferFrom(msg.sender, address(this), value);\r\n        }\r\n\r\n        uint256 proposal = dao.propose(\r\n            proposalType,\r\n            description,\r\n            accounts,\r\n            amounts,\r\n            payloads\r\n        );\r\n\r\n        tributes[dao][proposal] = Tribute({\r\n            proposer: msg.sender,\r\n            asset: asset,\r\n            nft: nft,\r\n            value: value\r\n        });\r\n\r\n        emit NewTributeProposal(dao, msg.sender, proposal, asset, nft, value);\r\n    }\r\n\r\n    function cancelTributeProposal(IKaliDAOtribute dao, uint256 proposal) public nonReentrant virtual {\r\n        Tribute storage trib = tributes[dao][proposal];\r\n\r\n        if (msg.sender != trib.proposer) revert NotProposer();\r\n\r\n        dao.cancelProposal(proposal);\r\n\r\n        // return tribute from escrow\r\n        if (trib.asset == address(0)) {\r\n            trib.proposer._safeTransferETH(trib.value);\r\n        } else if (!trib.nft) {\r\n            trib.asset._safeTransfer(trib.proposer, trib.value);\r\n        } else {\r\n            trib.asset._safeTransferFrom(address(this), trib.proposer, trib.value);\r\n        }\r\n        \r\n        delete tributes[dao][proposal];\r\n\r\n        emit TributeProposalCancelled(dao, proposal);\r\n    }\r\n\r\n    function releaseTributeProposalAndProcess(IKaliDAOtribute dao, uint256 proposal) public virtual {\r\n        dao.processProposal(proposal);\r\n\r\n        releaseTributeProposal(dao, proposal);\r\n    }\r\n\r\n    function releaseTributeProposal(IKaliDAOtribute dao, uint256 proposal) public nonReentrant virtual {\r\n        Tribute storage trib = tributes[dao][proposal];\r\n\r\n        if (trib.proposer == address(0)) revert NotProposal();\r\n        \r\n        IKaliDAOtribute.ProposalState memory prop = dao.proposalStates(proposal);\r\n\r\n        if (!prop.processed) revert NotProcessed();\r\n\r\n        // release tribute from escrow based on proposal outcome\r\n        if (prop.passed) {\r\n            if (trib.asset == address(0)) {\r\n                address(dao)._safeTransferETH(trib.value);\r\n            } else if (!trib.nft) {\r\n                trib.asset._safeTransfer(address(dao), trib.value);\r\n            } else {\r\n                trib.asset._safeTransferFrom(address(this), address(dao), trib.value);\r\n            }\r\n        } else {\r\n            if (trib.asset == address(0)) {\r\n                trib.proposer._safeTransferETH(trib.value);\r\n            } else if (!trib.nft) {\r\n                trib.asset._safeTransfer(trib.proposer, trib.value);\r\n            } else {\r\n                trib.asset._safeTransferFrom(address(this), trib.proposer, trib.value);\r\n            }\r\n        }\r\n\r\n        delete tributes[dao][proposal];\r\n\r\n        emit TributeProposalReleased(dao, proposal);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"ETHtransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotProcessed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotProposal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotProposer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrancy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Sponsored\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IKaliDAOtribute\",\"name\":\"dao\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"nft\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewTributeProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IKaliDAOtribute\",\"name\":\"dao\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposal\",\"type\":\"uint256\"}],\"name\":\"TributeProposalCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IKaliDAOtribute\",\"name\":\"dao\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposal\",\"type\":\"uint256\"}],\"name\":\"TributeProposalReleased\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IKaliDAOtribute\",\"name\":\"dao\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposal\",\"type\":\"uint256\"}],\"name\":\"cancelTributeProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKaliDAOtribute\",\"name\":\"dao\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposal\",\"type\":\"uint256\"}],\"name\":\"releaseTributeProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKaliDAOtribute\",\"name\":\"dao\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposal\",\"type\":\"uint256\"}],\"name\":\"releaseTributeProposalAndProcess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKaliDAOtribute\",\"name\":\"dao\",\"type\":\"address\"},{\"internalType\":\"enum IKaliDAOtribute.ProposalType\",\"name\":\"proposalType\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"payloads\",\"type\":\"bytes[]\"},{\"internalType\":\"bool\",\"name\":\"nft\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"submitTributeProposal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKaliDAOtribute\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tributes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"nft\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "KaliDAOtribute", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e811ff995cec423fc86d5241c6b608ffb2a8a48725422bb8b6b07d7d976dc8e1"}]}