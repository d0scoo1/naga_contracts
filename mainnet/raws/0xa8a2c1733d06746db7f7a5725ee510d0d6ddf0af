{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier:UNLICENSED\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\nlibrary EnumerableMap {\r\n\r\n    struct MapEntry {\r\n        bytes32 _key;\r\n        bytes32 _value;\r\n    }\r\n\r\n    struct Map {\r\n        MapEntry[] _entries;\r\n\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\r\n        uint256 keyIndex = map._indexes[key];\r\n\r\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\r\n            map._entries.push(MapEntry({ _key: key, _value: value }));\r\n            map._indexes[key] = map._entries.length;\r\n            return true;\r\n        } else {\r\n            map._entries[keyIndex - 1]._value = value;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\r\n        uint256 keyIndex = map._indexes[key];\r\n\r\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\r\n            uint256 toDeleteIndex = keyIndex - 1;\r\n            uint256 lastIndex = map._entries.length - 1;\r\n            MapEntry storage lastEntry = map._entries[lastIndex];\r\n\r\n            map._entries[toDeleteIndex] = lastEntry;\r\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            map._entries.pop();\r\n\r\n            delete map._indexes[key];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\r\n        return map._indexes[key] != 0;\r\n    }\r\n\r\n    struct UintToAddressMap {\r\n        Map _inner;\r\n    }\r\n\r\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\r\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\r\n        return _remove(map._inner, bytes32(key));\r\n    }\r\n\r\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\r\n        return _contains(map._inner, bytes32(key));\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */ \r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC1155 is IERC165 {\r\n\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n    event URI(string value, uint256 indexed id);\r\n    event tokenBaseURI(string value);\r\n\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n    function royaltyFee(uint256 tokenId) external view returns(address[] memory, uint256[] memory);\r\n    function getCreator(uint256 tokenId) external view returns(address);\r\n    function contractOwner() external view returns(address owner); \r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\r\n    function mint(address from, string memory uri, uint256 supply, address[] memory royaltyAddress, uint256[] memory _royaltyFee) external;\r\n    function mintAndTransfer(address from, address to, address[] memory _royaltyAddress, uint256[] memory _royaltyFee, uint256 _supply, string memory _tokenURI, uint256 qty, bytes memory data)external returns(uint256);\r\n}\r\n\r\ninterface IERC1155MetadataURI is IERC1155 {\r\n}\r\n\r\ninterface IERC1155Receiver is IERC165 {\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n}\r\n\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\r\n\r\n    // Mapping from token ID to account balances\r\n    mapping (uint256 => address) private creators;\r\n    mapping(uint256 => royaltyfee) private royalty;\r\n    mapping (uint256 => mapping(address => uint256)) private _balances;\r\n\r\n    // Mapping from account to operator approvals\r\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\r\n    string public tokenURIPrefix = \"https://gateway.pinata.cloud/ipfs/\";\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 => string) private _tokenURIs;\r\n\r\n    EnumerableMap.UintToAddressMap private _tokenOwners;\r\n\r\n    string private _name;\r\n\r\n    string private _symbol;\r\n\r\n    address public transferProxy;\r\n\r\n    uint256 tokenCounter = 1;\r\n\r\n    address public owner;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\r\n\r\n    struct royaltyfee{\r\n        address[] rAddress;\r\n        uint256[] rFee;\r\n    }\r\n\r\n    constructor (string memory name_, string memory symbol_, address _transferProxy) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        owner = msg.sender;\r\n        transferProxy = _transferProxy;\r\n\r\n        _registerInterface(_INTERFACE_ID_ERC1155);\r\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\r\n    }\r\n\r\n    function name() external view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n        * @dev Internal function to set the token URI for a given token.\r\n        * Reverts if the token ID does not exist.\r\n        * @param tokenId uint256 ID of the token to set its URI\r\n        * @param uri string URI to assign\r\n    */    \r\n\r\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\r\n        _tokenURIs[tokenId] = uri;\r\n    }\r\n\r\n    function contractOwner() public view virtual override returns(address){\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n        @notice Get the royalty associated with tokenID.\r\n        @param tokenId     ID of the Token.\r\n        @return        royaltyFee of given ID.\r\n     */\r\n\r\n    function royaltyFee(uint256 tokenId) external view override returns(address[] memory, uint256[] memory) {\r\n        address[] memory addr = royalty[tokenId].rAddress;\r\n        uint256[] memory fee = royalty[tokenId].rFee;\r\n        return (addr, fee) ;\r\n    }\r\n\r\n    /**\r\n        @notice Get the creator of given tokenID.\r\n        @param tokenId     ID of the Token.\r\n        @return        creator of given ID.\r\n     */    \r\n\r\n    function getCreator(uint256 tokenId) external view virtual override returns(address) {\r\n        return creators[tokenId];\r\n    }\r\n\r\n    /**\r\n        * @dev Internal function to set the token URI for all the tokens.\r\n        * @param _tokenURIPrefix string memory _tokenURIPrefix of the tokens.\r\n    */   \r\n\r\n    function _setTokenURIPrefix(string memory _tokenURIPrefix) internal {\r\n        tokenURIPrefix = _tokenURIPrefix;\r\n        emit tokenBaseURI(_tokenURIPrefix);\r\n    }\r\n\r\n    /**\r\n        * @dev Returns an URI for a given token ID.\r\n        * Throws if the token ID does not exist. May return an empty string.\r\n        * @param tokenId uint256 ID of the token to query\r\n    */    \r\n\r\n    function tokenURI(uint256 tokenId) external view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC1155Metadata: URI query for nonexistent token\");\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n        string memory base = tokenURIPrefix;\r\n\r\n        if (bytes(base).length == 0) {\r\n            return _tokenURI;\r\n        }\r\n        if (bytes(_tokenURI).length > 0) {\r\n            return string(abi.encodePacked(base, _tokenURI));\r\n        }\r\n        return string(abi.encodePacked(base, tokenId.toString()));\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _tokenOwners.contains(tokenId);\r\n    }\r\n\r\n    /**\r\n        @notice Get the balance of an account's Tokens.\r\n        @param account  The address of the token holder\r\n        @param tokenId     ID of the Token\r\n        @return        The owner's balance of the Token type requested\r\n     */\r\n\r\n    function balanceOf(address account, uint256 tokenId) external view override returns (uint256) {\r\n        require(_exists(tokenId), \"ERC1155Metadata: balance query for nonexistent token\");\r\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\r\n        return _balances[tokenId][account];\r\n    }\r\n\r\n\r\n    /**\r\n        @notice Get the balance of multiple account/token pairs\r\n        @param accounts The addresses of the token holders\r\n        @param ids    ID of the Tokens\r\n        @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\r\n     */\r\n\r\n    function balanceOfBatch(\r\n        address[] memory accounts,\r\n        uint256[] memory ids\r\n    )\r\n        external\r\n        view\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\r\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    /**\r\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\r\n        @dev MUST emit the ApprovalForAll event on success.\r\n        @param operator  Address to add to the set of authorized operators\r\n        @param approved  True if the operator is approved, false to revoke approval\r\n    */\r\n\r\n    function setApprovalForAll(address operator, bool approved) external virtual override {\r\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n        @notice Queries the approval status of an operator for a given owner.\r\n        @param account     The owner of the Tokens\r\n        @param operator  Address of authorized operator\r\n        @return           True if the operator is approved, false if not\r\n    */\r\n\r\n    function isApprovedForAll(address account, address operator) public view override returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        MUST revert if `_to` is the zero address.\r\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\r\n        MUST revert on any other error.\r\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\r\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\r\n        @param from    Source address\r\n        @param to      Target address\r\n        @param tokenId      ID of the token type\r\n        @param amount   Transfer amount\r\n        @param data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\r\n    */    \r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        uint256 amount,\r\n        bytes memory data\r\n    )\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n        require( _balances[tokenId][from] >= amount,\"ERC1155: insufficient balance for transfer\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(tokenId), _asSingletonArray(amount), data);\r\n        \r\n        _balances[tokenId][from] = _balances[tokenId][from] - amount;\r\n        _balances[tokenId][to] = _balances[tokenId][to] + amount;\r\n\r\n        emit TransferSingle(operator, from, to, tokenId, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, tokenId, amount, data);\r\n    }\r\n\r\n    /**\r\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        MUST revert if `_to` is the zero address.\r\n        MUST revert if length of `_ids` is not the same as length of `_values`.\r\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\r\n        MUST revert on any other error.\r\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\r\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\r\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\r\n        @param from    Source address\r\n        @param to      Target address\r\n        @param tokenIds     IDs of each token type (order and length must match _values array)\r\n        @param amounts  Transfer amounts per token type (order and length must match _ids array)\r\n        @param data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\r\n    */\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory tokenIds,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n    {\r\n        require(tokenIds.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: transfer caller is not owner nor approved\"\r\n        );\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, tokenIds, amounts, data);\r\n\r\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\r\n            uint256 tokenId = tokenIds[i];\r\n            uint256 amount = amounts[i];\r\n            require( _balances[tokenId][from] >= amount,\"ERC1155: insufficient balance for transfer\");\r\n            _balances[tokenId][from] = _balances[tokenId][from] - amount;\r\n            _balances[tokenId][to] = _balances[tokenId][to] + amount;\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, tokenIds, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, tokenIds, amounts, data);\r\n    }\r\n\r\n    function mint(address from, string memory uri, uint256 supply, address[] memory royaltyAddress, uint256[] memory _royaltyFee) external override {\r\n        require(transferProxy == msg.sender, \"Operator: operator doesn't have the role\");\r\n        _mint(from, tokenCounter, supply, uri);\r\n        setRoyaltyFee(tokenCounter, royaltyAddress, _royaltyFee);\r\n        tokenCounter += 1;\r\n    }\r\n\r\n    /**\r\n        * @dev Internal function to mint a new token.\r\n        * Reverts if the given token ID already exists.\r\n        * @param tokenId uint256 ID of the token to be minted\r\n        * @param _supply uint256 supply of the token to be minted\r\n        * @param _uri string memory URI of the token to be minted\r\n    */\r\n\r\n    function _mint(address from, uint256 tokenId, uint256 _supply, string memory _uri) internal {\r\n        require(!_exists(tokenId), \"ERC1155: token already minted\");\r\n        require(_supply != 0, \"Supply should be positive\");\r\n        require(bytes(_uri).length > 0, \"uri should be set\");\r\n\r\n        creators[tokenId] = from;\r\n        _tokenOwners.set(tokenId, from);\r\n        _balances[tokenId][from] = _supply;\r\n        _setTokenURI(tokenId, _uri);\r\n\r\n        emit TransferSingle(from, address(0x0), from, tokenId, _supply);\r\n        emit URI(_uri, tokenId);\r\n    }\r\n\r\n    /**\r\n        * @dev version of {_mint}.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `tokenIds` and `amounts` must have the same length.\r\n    */\r\n\r\n    function _mintBatch(address to, uint256[] memory tokenIds, uint256[] memory amounts, bytes memory data) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n        require(tokenIds.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, tokenIds, amounts, data);\r\n\r\n        for (uint i = 0; i < tokenIds.length; i++) {\r\n            _balances[tokenIds[i]][to] = amounts[i] + _balances[tokenIds[i]][to];\r\n        }\r\n\r\n        emit TransferBatch(operator, address(0), to, tokenIds, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, tokenIds, amounts, data);\r\n    }\r\n\r\n    /**\r\n        * @dev Internal function to burn a specific token.\r\n        * Reverts if the token does not exist.\r\n        * Deprecated, use {ERC721-_burn} instead.\r\n        * @param account owner of the token to burn\r\n        * @param tokenId uint256 ID of the token being burned\r\n        * @param amount uint256 amount of supply being burned\r\n    */    \r\n\r\n    function _burn(address account, uint256 tokenId, uint256 amount) internal virtual {\r\n        require(_exists(tokenId), \"ERC1155Metadata: burn query for nonexistent token\");\r\n        require(account != address(0), \"ERC1155: burn from the zero address\");\r\n        require( _balances[tokenId][account] >= amount,\"ERC1155: insufficient balance for transfer\");\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(tokenId), _asSingletonArray(amount), \"\");\r\n\r\n        _balances[tokenId][account] = _balances[tokenId][account] - amount;\r\n\r\n\r\n        emit TransferSingle(operator, account, address(0), tokenId, amount);\r\n    }\r\n\r\n\r\n    /**\r\n        * @dev version of {_burn}.\r\n        * Requirements:\r\n        * - `ids` and `amounts` must have the same length.\r\n    */\r\n\r\n    function _burnBatch(address account, uint256[] memory tokenIds, uint256[] memory amounts) internal virtual {\r\n        require(account != address(0), \"ERC1155: burn from the zero address\");\r\n        require(tokenIds.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, account, address(0), tokenIds, amounts, \"\");\r\n\r\n        for (uint i = 0; i < tokenIds.length; i++) {\r\n        require( _balances[tokenIds[i]][account] >= amounts[i],\"ERC1155: insufficient balance for transfer\");\r\n            _balances[tokenIds[i]][account] = _balances[tokenIds[i]][account] - amounts[i];\r\n        }\r\n\r\n        emit TransferBatch(operator, account, address(0), tokenIds, amounts);\r\n    }\r\n\r\n    function mintAndTransfer(address from, address to, address[] memory _royaltyAddress, uint256[] memory _royaltyFee, uint256 _supply,string memory _tokenURI, uint256 qty,bytes memory data) external virtual override returns(uint256){\r\n        require(msg.sender == transferProxy,\"ERC1155: caller is not Approved\");\r\n        uint256 itemId = tokenCounter;\r\n        _operatorApprovals[from][transferProxy] = true;\r\n        _mint(from, itemId, _supply, _tokenURI);\r\n        setRoyaltyFee(itemId, _royaltyAddress, _royaltyFee);\r\n        safeTransferFrom(from, to, itemId, qty, data);\r\n        tokenCounter += 1;\r\n        return itemId;\r\n\r\n    }\r\n\r\n    function setRoyaltyFee(uint256 tokenId, address[] memory _royaltyAddress, uint256[] memory _royaltyFee) internal returns(bool) {\r\n        royalty[tokenId].rAddress = _royaltyAddress;\r\n        royalty[tokenId].rFee = _royaltyFee;\r\n        return true;\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory tokenIds,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    )\r\n        internal virtual\r\n    { }\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        uint256 amount,\r\n        bytes memory data\r\n    )\r\n        private\r\n    {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155Received(operator, from, tokenId, amount, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory tokenIds,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    )\r\n        private\r\n    {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, tokenIds, amounts, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\r\n        uint256[] memory array = new uint256[](1);\r\n        array[0] = element;\r\n\r\n        return array;\r\n    }\r\n}\r\n\r\ncontract MolaNFT1155 is ERC1155 {\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor (string memory name, string memory symbol, address _transferProxy) ERC1155 (name, symbol, _transferProxy) {\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /** @dev change the Ownership from current owner to newOwner address\r\n        @param newOwner : newOwner address */    \r\n\r\n    function transferOwnership(address newOwner) external onlyOwner returns(bool){\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        return true;\r\n    }\r\n\r\n    function setBaseURI(string memory _baseURI) external onlyOwner{\r\n         _setTokenURIPrefix(_baseURI);\r\n    }\r\n\r\n    function burn(uint256 tokenId, uint256 supply) external {\r\n        _burn(msg.sender, tokenId, supply);\r\n    }\r\n\r\n    function burnBatch( uint256[] memory tokenIds, uint256[] memory amounts) external {\r\n        _burnBatch(msg.sender, tokenIds, amounts);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_transferProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"tokenBaseURI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"burnBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"royaltyAddress\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_royaltyFee\",\"type\":\"uint256[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_royaltyAddress\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_royaltyFee\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"mintAndTransfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"royaltyFee\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenURIPrefix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MolaNFT1155", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000f32cefb83d0f91610a441356701c9547fa5031a7000000000000000000000000000000000000000000000000000000000000000b4d6f6c614e46543131353500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d4e46544d000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://550f027801f8a18a363dc25d8899a1a86418ab44b1b13d749a66fea973c3c6ed"}]}