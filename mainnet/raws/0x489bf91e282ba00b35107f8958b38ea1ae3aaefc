{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.8.4;\r\n\r\n/// @notice Safe ETH and ERC-20 transfer library that gracefully handles missing return values.\r\n/// @author Modified from SolMate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// License-Identifier: AGPL-3.0-only\r\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\nlibrary SafeTransferLib {\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERRORS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    error ETHtransferFailed();\r\n\r\n    error TransferFailed();\r\n\r\n    error TransferFromFailed();\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ETH OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _safeTransferETH(address to, uint256 amount) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // transfer the ETH and store if it succeeded or not\r\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        if (!callStatus) revert ETHtransferFailed();\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERC20 OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // get a pointer to some free memory\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // begin with the function selector\r\n            \r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // mask and append the \"to\" argument\r\n            \r\n            mstore(add(freeMemoryPointer, 36), amount) // finally append the \"amount\" argument - no mask as it's a full 32 byte value\r\n\r\n            // call the token and store if it succeeded or not\r\n            // we use 68 because the calldata length is 4 + 32 * 2\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n        }\r\n\r\n        if (!_didLastOptionalReturnCallSucceed(callStatus)) revert TransferFailed();\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // get a pointer to some free memory\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // begin with the function selector\r\n            \r\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // mask and append the \"from\" argument\r\n            \r\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // mask and append the \"to\" argument\r\n            \r\n            mstore(add(freeMemoryPointer, 68), amount) // finally append the \"amount\" argument - no mask as it's a full 32 byte value\r\n\r\n            // call the token and store if it succeeded or not\r\n            // we use 100 because the calldata length is 4 + 32 * 3\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\r\n        }\r\n\r\n        if (!_didLastOptionalReturnCallSucceed(callStatus)) revert TransferFromFailed();\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            INTERNAL HELPER LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _didLastOptionalReturnCallSucceed(bool callStatus) internal pure returns (bool success) {\r\n        assembly {\r\n            // get how many bytes the call returned\r\n            let returnDataSize := returndatasize()\r\n\r\n            // if the call reverted:\r\n            if iszero(callStatus) {\r\n                // copy the revert message into memory\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // revert with the same message\r\n                revert(0, returnDataSize)\r\n            }\r\n\r\n            switch returnDataSize\r\n            \r\n            case 32 {\r\n                // copy the return data into memory\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // set success to whether it returned true\r\n                success := iszero(iszero(mload(0)))\r\n            }\r\n            case 0 {\r\n                // there was no return data\r\n                success := 1\r\n            }\r\n            default {\r\n                // it returned some malformed input\r\n                success := 0\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Kali DAO access manager interface.\r\ninterface IKaliAccessManager {\r\n    function listedAccounts(uint256 listId, address account) external returns (bool);\r\n\r\n    function joinList(\r\n        uint256 listId,\r\n        address account,\r\n        bytes32[] calldata merkleProof\r\n    ) external;\r\n}\r\n\r\n/// @notice Kali DAO share manager interface.\r\ninterface IKaliShareManager {\r\n    function mintShares(address to, uint256 amount) external;\r\n\r\n    function burnShares(address from, uint256 amount) external;\r\n}\r\n\r\n/// @notice Helper utility that enables calling multiple local methods in a single call.\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol)\r\nabstract contract Multicall {\r\n    function multicall(bytes[] calldata data) public virtual returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        \r\n        // cannot realistically overflow on human timescales\r\n        unchecked {\r\n            for (uint256 i = 0; i < data.length; i++) {\r\n                (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n\r\n                if (!success) {\r\n                    if (result.length < 68) revert();\r\n                    \r\n                    assembly {\r\n                        result := add(result, 0x04)\r\n                    }\r\n                    \r\n                    revert(abi.decode(result, (string)));\r\n                }\r\n                results[i] = result;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Gas-optimized reentrancy protection.\r\n/// @author Modified from OpenZeppelin \r\n/// (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\r\n/// License-Identifier: MIT\r\nabstract contract ReentrancyGuard {\r\n    error Reentrancy();\r\n\r\n    uint256 private constant NOT_ENTERED = 1;\r\n\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private status = NOT_ENTERED;\r\n\r\n    modifier nonReentrant() {\r\n        if (status == ENTERED) revert Reentrancy();\r\n\r\n        status = ENTERED;\r\n\r\n        _;\r\n\r\n        status = NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/// @notice Crowdsale contract that receives ETH or ERC-20 to mint registered DAO tokens, including merkle access lists.\r\ncontract KaliDAOcrowdsale is Multicall, ReentrancyGuard {\r\n    using SafeTransferLib for address;\r\n\r\n    event ExtensionSet(\r\n        address indexed dao, \r\n        uint256 listId, \r\n        address purchaseToken, \r\n        uint8 purchaseMultiplier, \r\n        uint96 purchaseLimit, \r\n        uint32 saleEnds, \r\n        string details\r\n    );\r\n\r\n    event ExtensionCalled(address indexed dao, address indexed purchaser, uint256 amountOut);\r\n\r\n    error NullMultiplier();\r\n\r\n    error SaleEnded();\r\n\r\n    error NotListed();\r\n\r\n    error PurchaseLimit();\r\n    \r\n    IKaliAccessManager private immutable accessManager;\r\n\r\n    mapping(address => Crowdsale) public crowdsales;\r\n\r\n    struct Crowdsale {\r\n        uint256 listId;\r\n        address purchaseToken;\r\n        uint8 purchaseMultiplier;\r\n        uint96 purchaseLimit;\r\n        uint96 amountPurchased;\r\n        uint32 saleEnds;\r\n        string details;\r\n    }\r\n\r\n    constructor(IKaliAccessManager accessManager_) {\r\n        accessManager = accessManager_;\r\n    }\r\n\r\n    function setExtension(bytes calldata extensionData) public nonReentrant virtual {\r\n        (uint256 listId, address purchaseToken, uint8 purchaseMultiplier, uint96 purchaseLimit, uint32 saleEnds, string memory details) \r\n            = abi.decode(extensionData, (uint256, address, uint8, uint96, uint32, string));\r\n        \r\n        if (purchaseMultiplier == 0) revert NullMultiplier();\r\n\r\n        crowdsales[msg.sender] = Crowdsale({\r\n            listId: listId,\r\n            purchaseToken: purchaseToken,\r\n            purchaseMultiplier: purchaseMultiplier,\r\n            purchaseLimit: purchaseLimit,\r\n            amountPurchased: 0,\r\n            saleEnds: saleEnds,\r\n            details: details\r\n        });\r\n\r\n        emit ExtensionSet(msg.sender, listId, purchaseToken, purchaseMultiplier, purchaseLimit, saleEnds, details);\r\n    }\r\n\r\n    function joinList(uint256 listId, bytes32[] calldata merkleProof) public virtual {\r\n        accessManager.joinList(\r\n            listId,\r\n            msg.sender,\r\n            merkleProof\r\n        );\r\n    }\r\n\r\n    function callExtension(address dao, uint256 amount) public payable nonReentrant virtual returns (uint256 amountOut) {\r\n        Crowdsale storage sale = crowdsales[dao];\r\n\r\n        if (block.timestamp > sale.saleEnds) revert SaleEnded();\r\n\r\n        if (sale.listId != 0) \r\n            if (!accessManager.listedAccounts(sale.listId, msg.sender)) revert NotListed();\r\n\r\n        if (sale.purchaseToken == address(0)) {\r\n            amountOut = msg.value * sale.purchaseMultiplier;\r\n\r\n            if (sale.amountPurchased + amountOut > sale.purchaseLimit) revert PurchaseLimit();\r\n\r\n            // send ETH to DAO\r\n            dao._safeTransferETH(msg.value);\r\n\r\n            sale.amountPurchased += uint96(amountOut);\r\n\r\n            IKaliShareManager(dao).mintShares(msg.sender, amountOut);\r\n        } else {\r\n            // send tokens to DAO\r\n            sale.purchaseToken._safeTransferFrom(msg.sender, dao, amount);\r\n\r\n            amountOut = amount * sale.purchaseMultiplier;\r\n\r\n            if (sale.amountPurchased + amountOut > sale.purchaseLimit) revert PurchaseLimit();\r\n\r\n            sale.amountPurchased += uint96(amountOut);\r\n            \r\n            IKaliShareManager(dao).mintShares(msg.sender, amountOut);\r\n        }\r\n\r\n        emit ExtensionCalled(dao, msg.sender, amountOut);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IKaliAccessManager\",\"name\":\"accessManager_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ETHtransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotListed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NullMultiplier\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PurchaseLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrancy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SaleEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"ExtensionCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"purchaseToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"purchaseMultiplier\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"purchaseLimit\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"saleEnds\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"ExtensionSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"callExtension\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"crowdsales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"purchaseToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"purchaseMultiplier\",\"type\":\"uint8\"},{\"internalType\":\"uint96\",\"name\":\"purchaseLimit\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"amountPurchased\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"saleEnds\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"joinList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extensionData\",\"type\":\"bytes\"}],\"name\":\"setExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "KaliDAOcrowdsale", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "0000000000000000000000007799b86ada91a507b5cbda03638116a26a86358d", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d1b2bc434ded0fa5feb924f1e3d0c226a1dbfacb1f8e59a3fb310fcbb568a091"}]}