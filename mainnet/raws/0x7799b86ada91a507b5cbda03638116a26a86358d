{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.8.4;\r\n\r\n/// @notice Merkle library adapted from (https://github.com/miguelmota/merkletreejs[merkletreejs]).\r\nlibrary MerkleProof {\r\n    /// @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n    /// defined by `root`. For this, a `proof` must be provided, containing\r\n    /// sibling hashes on the branch from the leaf to the root of the tree. Each\r\n    /// pair of leaves and each pair of pre-images are assumed to be sorted.\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        // cannot realistically overflow on human timescales\r\n        unchecked {\r\n            for (uint256 i = 0; i < proof.length; i++) {\r\n                bytes32 proofElement = proof[i];\r\n\r\n                if (computedHash <= proofElement) {\r\n                    // Hash(current computed hash + current element of the proof)\r\n                    computedHash = _efficientHash(computedHash, proofElement);\r\n                } else {\r\n                    // Hash(current element of the proof + current computed hash)\r\n                    computedHash = _efficientHash(proofElement, computedHash);\r\n                }\r\n            }\r\n        }\r\n\r\n        // check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Helper utility that enables calling multiple local methods in a single call.\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol)\r\nabstract contract Multicall {\r\n    function multicall(bytes[] calldata data) public virtual returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        \r\n        // cannot realistically overflow on human timescales\r\n        unchecked {\r\n            for (uint256 i = 0; i < data.length; i++) {\r\n                (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n\r\n                if (!success) {\r\n                    if (result.length < 68) revert();\r\n                    \r\n                    assembly {\r\n                        result := add(result, 0x04)\r\n                    }\r\n                    \r\n                    revert(abi.decode(result, (string)));\r\n                }\r\n                results[i] = result;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Kali DAO access manager.\r\n/// @author Modified from SushiSwap\r\n/// (https://github.com/sushiswap/trident/blob/master/contracts/pool/franchised/WhiteListManager.sol)\r\ncontract KaliAccessManager is Multicall {\r\n    using MerkleProof for bytes32[];\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event ListCreated(uint256 indexed listId, address indexed operator);\r\n\r\n    event AccountListed(uint256 indexed listId, address indexed account, bool approved);\r\n\r\n    event MerkleRootSet(uint256 indexed listId, bytes32 merkleRoot);\r\n\r\n    event ListJoined(uint256 indexed listId, address indexed account);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERRORS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    error NotOperator();\r\n    \r\n    error NoArrayParity();\r\n\r\n    error SignatureExpired();\r\n\r\n    error InvalidSignature();\r\n\r\n    error ListClaimed();\r\n\r\n    error InvalidList();\r\n\r\n    error NotOnList();\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            EIP-712 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    bytes32 internal constant LIST_TYPEHASH =\r\n        keccak256('List(address account,bool approved,uint256 deadline)');\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            LIST STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    mapping(uint256 => address) public operatorOf;\r\n\r\n    mapping(uint256 => bytes32) public merkleRoots;\r\n\r\n    mapping(uint256 => mapping(address => bool)) public listedAccounts;\r\n\r\n    uint256 public listCount;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor() {\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n\r\n        INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            EIP-712 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : _computeDomainSeparator();\r\n    }\r\n\r\n    function _computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                    keccak256(bytes('KaliAccessManager')),\r\n                    keccak256('1'),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            LIST LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function isListed(uint256 listId, address account) public view virtual returns (bool) {\r\n        return listedAccounts[listId][account];\r\n    }\r\n\r\n    function createList(address[] calldata accounts, bytes32 merkleRoot) public virtual {\r\n        uint256 listId = ++listCount;\r\n\r\n        operatorOf[listId] = msg.sender;\r\n\r\n        if (accounts.length != 0) {\r\n            // cannot realistically overflow on human timescales\r\n            unchecked {\r\n                for (uint256 i; i < accounts.length; i++) {\r\n                    _listAccount(listId, accounts[i], true);\r\n                }\r\n            }\r\n\r\n            emit ListCreated(listId, msg.sender);\r\n        }\r\n\r\n        if (merkleRoot != '') {\r\n            merkleRoots[listId] = merkleRoot;\r\n\r\n            emit MerkleRootSet(listId, merkleRoot);\r\n        }\r\n    }\r\n\r\n    function listAccounts(\r\n        uint256 listId,\r\n        address[] calldata accounts,\r\n        bool[] calldata approvals\r\n    ) public virtual {\r\n        if (msg.sender != operatorOf[listId]) revert NotOperator();\r\n\r\n        if (accounts.length != approvals.length) revert NoArrayParity();\r\n\r\n        // cannot realistically overflow on human timescales\r\n        unchecked {\r\n            for (uint256 i; i < accounts.length; i++) {\r\n                _listAccount(listId, accounts[i], approvals[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function listAccountBySig(\r\n        uint256 listId,\r\n        address account,\r\n        bool approved,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        if (block.timestamp > deadline) revert SignatureExpired();\r\n\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR(),\r\n                keccak256(abi.encode(LIST_TYPEHASH, account, approved, deadline))\r\n            )\r\n        );\r\n\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n\r\n        if (recoveredAddress == address(0) || recoveredAddress != operatorOf[listId]) revert InvalidSignature();\r\n\r\n        _listAccount(listId, account, approved);\r\n    }\r\n\r\n    function _listAccount(\r\n        uint256 listId,\r\n        address account,\r\n        bool approved\r\n    ) internal virtual {\r\n        listedAccounts[listId][account] = approved;\r\n\r\n        emit AccountListed(listId, account, approved);\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            MERKLE LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function setMerkleRoot(uint256 listId, bytes32 merkleRoot) public virtual {\r\n        if (msg.sender != operatorOf[listId]) revert NotOperator();\r\n\r\n        merkleRoots[listId] = merkleRoot;\r\n\r\n        emit MerkleRootSet(listId, merkleRoot);\r\n    }\r\n\r\n    function joinList(\r\n        uint256 listId,\r\n        address account,\r\n        bytes32[] calldata merkleProof\r\n    ) public virtual {\r\n        if (isListed(listId, account)) revert ListClaimed();\r\n\r\n        if (merkleRoots[listId] == 0) revert InvalidList();\r\n\r\n        if (!merkleProof.verify(merkleRoots[listId], keccak256(abi.encodePacked(account)))) revert NotOnList();\r\n\r\n        _listAccount(listId, account, true);\r\n\r\n        emit ListJoined(listId, account);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidList\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ListClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoArrayParity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOnList\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOperator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignatureExpired\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"AccountListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ListCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ListJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"MerkleRootSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"createList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"joinList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"listAccountBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"approvals\",\"type\":\"bool[]\"}],\"name\":\"listAccounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"listedAccounts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"merkleRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operatorOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "KaliAccessManager", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://06a889f1ef8d3053455785e597d02436a958e87abec9314841d6d54b8c888335"}]}