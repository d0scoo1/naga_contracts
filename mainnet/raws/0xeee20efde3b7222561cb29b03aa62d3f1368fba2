{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/ERC20PermitEverywhere.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.15;\\n\\n/// @title ERC20PermitEverywhere\\n/// @notice Enables permit-style approvals for all ERC20 tokens,\\n/// regardless of whether they implement EIP2612 or not.\\ncontract ERC20PermitEverywhere {\\n    bytes32 public immutable DOMAIN_SEPARATOR;\\n    bytes32 public immutable TRANSFER_PERMIT_TYPEHASH;\\n\\n    // Permit message to be consumed by executePermitTransferFrom().\\n    struct PermitTransferFrom {\\n        // The token being spent.\\n        address token;\\n        // Who is allowed to execute/burn the permit message.\\n        address spender;\\n        // The maximum amount of `token` `spender` can transfer.\\n        uint256 maxAmount;\\n        // The timestamp beyond which this permit is no longer valid.\\n        uint256 deadline;\\n    }\\n\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice The current nonce for a signer. This value will be incremented\\n    ///         for each executed permit message.\\n    /// @dev Owner -> current nonce.\\n    mapping(address => uint256) public currentNonce;\\n\\n    constructor() {\\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\\n            keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n            keccak256(bytes('ERC20PermitEverywhere')),\\n            keccak256('1.0.0'),\\n            block.chainid,\\n            address(this)\\n        ));\\n        TRANSFER_PERMIT_TYPEHASH =\\n            keccak256('PermitTransferFrom(address token,address spender,uint256 maxAmount,uint256 deadline,uint256 nonce)');\\n    }\\n\\n    /// @notice Increase sender's nonce by `increaseAmount`. This will effectively\\n    ///         cancel any outstanding permits signed with a nonce lower than the\\n    ///         final value.\\n    function increaseNonce(uint256 increaseAmount) external {\\n        currentNonce[msg.sender] += increaseAmount;\\n    }\\n\\n    /// @notice Execute a signed permit message to transfer ERC20 tokens\\n    ///         on behalf of the signer. The signer's nonce will be incremented\\n    ///         during execution, preventing the message from being used again.\\n    /// @param from Permit signer.\\n    /// @param to Recipient of tokens.\\n    /// @param amount Amount of tokens to transfer (may be less than permit amount).\\n    /// @param permit Permit message.\\n    /// @param sig Signature for permit message, signed by `from`.\\n    function executePermitTransferFrom(\\n        address from,\\n        address to,\\n        uint256 amount,\\n        PermitTransferFrom calldata permit,\\n        Signature calldata sig\\n    )\\n        external\\n    {\\n        require(msg.sender == permit.spender, 'SPENDER_NOT_PERMITTED');\\n        require(permit.deadline >= block.timestamp, 'PERMIT_EXPIRED');\\n        require(permit.maxAmount >= amount, 'EXCEEDS_PERMIT_AMOUNT');\\n\\n        require(\\n            from == _getSigner(hashPermit(permit, currentNonce[from]++), sig),\\n            'INVALID_SIGNER'\\n        );\\n\\n        _transferFrom(permit.token, from, to, amount);\\n    }\\n\\n    /// @notice Compute the EIP712 hash of a permit message.\\n    function hashPermit(PermitTransferFrom memory permit, uint256 nonce)\\n        public\\n        view\\n        returns (bytes32 hash)\\n    {\\n        bytes32 domainSeparator = DOMAIN_SEPARATOR;\\n        bytes32 typeHash = TRANSFER_PERMIT_TYPEHASH;\\n        assembly {\\n            // Hash the permit message in-place to compute the struct hash.\\n            if lt(permit, 0x20)  {\\n                invalid()\\n            }\\n            // Overwrite the words above and below the permit object temporarily.\\n            let wordAbove := mload(sub(permit, 0x20))\\n            let wordBelow := mload(add(permit, 0x80))\\n            mstore(sub(permit, 0x20), typeHash)\\n            mstore(add(permit, 0x80), nonce)\\n            let structHash := keccak256(sub(permit, 0x20), 0xC0)\\n            // Restore overwritten words.\\n            mstore(sub(permit, 0x20), wordAbove)\\n            mstore(add(permit, 0x80), wordBelow)\\n\\n            // 0x40 will be overwritten temporarily.\\n            let memPointer := mload(0x40)\\n            // Hash the domain separator and struct hash to compute the final EIP712 hash.\\n            mstore(0x00, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n            mstore(0x02, domainSeparator)\\n            mstore(0x22, structHash)\\n            hash := keccak256(0x00, 0x42)\\n            // Restore 0x40.\\n            mstore(0x40, memPointer)\\n        }\\n    }\\n\\n    function _getSigner(bytes32 hash, Signature calldata sig) private pure returns (address signer) {\\n        signer = ecrecover(hash, sig.v, sig.r, sig.s);\\n        require(signer != address(0), 'INVALID_SIGNATURE');\\n    }\\n\\n    function _transferFrom(address token, address from, address to, uint256 amount) private {\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0x00, 0x23b872dd)\\n            mstore(0x20, from) // Append the \\\"from\\\" argument.\\n            mstore(0x40, to) // Append the \\\"to\\\" argument.\\n            mstore(0x60, amount) // Append the \\\"amount\\\" argument.\\n\\n            if iszero(\\n                and(\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    // We use 0x64 because that's the total length of our calldata (0x04 + 0x20 * 3)\\n                    // Counterintuitively, this call() must be positioned after the or() in the\\n                    // surrounding and() because and() evaluates its arguments from right to left.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                if or(eq(mload(0x00), 0), iszero(returndatasize())) {\\n                    mstore(0x00, hex\\\"08c379a0\\\") // Function selector of the error method.\\n                    mstore(0x04, 0x20) // Offset of the error string.\\n                    mstore(0x24, 26) // Length of the error string.\\n                    mstore(0x44, \\\"ERC20_TRANSFER_FROM_FAILED\\\") // The error string.\\n                    revert(0x00, 0x64) // Revert with (offset, size).\\n                }\\n                // Bubble up revert data if present.\\n                returndatacopy(0x00, 0x00, returndatasize())\\n                revert(0x00, returndatasize())\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"script/=script/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\",\r\n      \"script/=script/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"currentNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC20PermitEverywhere.PermitTransferFrom\",\"name\":\"permit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ERC20PermitEverywhere.Signature\",\"name\":\"sig\",\"type\":\"tuple\"}],\"name\":\"executePermitTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC20PermitEverywhere.PermitTransferFrom\",\"name\":\"permit\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"hashPermit\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"increaseAmount\",\"type\":\"uint256\"}],\"name\":\"increaseNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC20PermitEverywhere", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}