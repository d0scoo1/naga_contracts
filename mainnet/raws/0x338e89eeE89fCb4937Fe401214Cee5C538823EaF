{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"univ3-adapter/adapter/UniV3Adapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.8.10;\\npragma abicoder v1;\\n\\nimport '../token/IERC20.sol';\\nimport '../token/IWETH.sol';\\n\\n/// @title Brink UniV3Adapter\\n/// @notice Deployed once and used by Brink executors to fulfill swaps. Uses V3SwapRouter from Uniswap.\\ncontract UniV3Adapter {\\n  IWETH public weth;\\n  bool public initialized;\\n\\n  /// @dev Contract Address of the Uniswap V3SwapRouter\\n  address constant V3_SWAP_ROUTER_ADDRESS = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\\n\\n  /// @dev Max uint\\n  uint256 MAX_INT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n  /// @dev Adapter Owner\\n  address payable ADAPTER_OWNER = payable(0x71795b2d53Ffbe5b1805FE725538E4f8fBD29e26);\\n\\n  /// @dev Ethereum address representations\\n  IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n  IERC20 private constant _ZERO_ADDRESS = IERC20(0x0000000000000000000000000000000000000000);\\n\\n  /// @dev initialize the contract with WETH address\\n  /// @param _weth Address of weth\\n  function initialize (IWETH _weth) external {\\n    require(!initialized, 'INITIALIZED');\\n    initialized = true;\\n    weth = _weth;\\n  }\\n\\n  /// @dev Makes a call to the Uniswap V3SwapRouter with swap byte data\\n  /// @dev returns the requested tokenOutAmount to Account and keeps the rest\\n  /// @param data swap byte data for Uniswap V3SwapRouter\\n  /// @param tokenIn Address of the token to be swapped\\n  /// @param tokenInAmount Token amount deposited\\n  /// @param tokenOut Address of the token to be returned from the swap\\n  /// @param tokenOutAmount Token amount deposited\\n  /// @param account Address of the account to receive the tokenOut\\n  function uniV3Swap(bytes memory data, IERC20 tokenIn, uint tokenInAmount, IERC20 tokenOut, uint tokenOutAmount, address payable account) external payable {\\n    if (isETH(tokenIn)) {\\n      _routerApproveMax(IERC20(address(weth)), tokenInAmount);\\n      weth.deposit{ value: msg.value }();\\n    } else {\\n      _routerApproveMax(tokenIn, tokenInAmount);\\n    }\\n\\n    assembly {\\n      let result := call(gas(), V3_SWAP_ROUTER_ADDRESS, 0, add(data, 0x20), mload(data), 0, 0)\\n      if eq(result, 0) {\\n        returndatacopy(0, 0, returndatasize())\\n        revert(0, returndatasize())\\n      }\\n    }\\n\\n    if (isETH(tokenOut)) {\\n      weth.withdraw(address(this).balance);\\n      account.transfer(tokenOutAmount);\\n      ADAPTER_OWNER.transfer(address(this).balance);\\n    } else {\\n      tokenOut.transfer(account, tokenOutAmount);\\n      tokenOut.transfer(ADAPTER_OWNER, tokenOut.balanceOf(address(this)));\\n    }\\n  }\\n\\n  function _routerApproveMax(IERC20 token, uint256 amount) internal {\\n    if (token.allowance(address(this), V3_SWAP_ROUTER_ADDRESS) < amount) {\\n      token.approve(V3_SWAP_ROUTER_ADDRESS, MAX_INT);\\n    }\\n  }\\n\\n  /// @dev Checks if IERC20 token address is an ETH representation\\n  /// @param token address of a token\\n  function isETH(IERC20 token) internal pure returns (bool) {\\n    return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\\n  }\\n\\n  receive() external payable { }\\n}\"\r\n    },\r\n    \"univ3-adapter/token/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.8.10;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"univ3-adapter/token/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.8.10;\\n\\ninterface IWETH {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function balanceOf(address) external view returns (uint);\\n\\n    function allowance(address, address) external view returns (uint);\\n\\n    receive() external payable;\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint wad) external;\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function approve(address guy, uint wad) external returns (bool);\\n\\n    function transfer(address dst, uint wad) external returns (bool);\\n\\n    function transferFrom(address src, address dst, uint wad)\\n    external\\n    returns (bool);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"_weth\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenInAmount\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"uniV3Swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UniV3Adapter", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}