{"status": "1", "message": "OK", "result": [{"SourceCode": "// Sources flattened with hardhat v2.8.4 https://hardhat.org\r\n\r\n// File @rari-capital/solmate/src/auth/Auth.sol@v6.2.0\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\r\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\r\nabstract contract Auth {\r\n    event OwnerUpdated(address indexed user, address indexed newOwner);\r\n\r\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\r\n\r\n    address public owner;\r\n\r\n    Authority public authority;\r\n\r\n    constructor(address _owner, Authority _authority) {\r\n        owner = _owner;\r\n        authority = _authority;\r\n\r\n        emit OwnerUpdated(msg.sender, _owner);\r\n        emit AuthorityUpdated(msg.sender, _authority);\r\n    }\r\n\r\n    modifier requiresAuth() {\r\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\r\n\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\r\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\r\n\r\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\r\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\r\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\r\n    }\r\n\r\n    function setAuthority(Authority newAuthority) public virtual {\r\n        // We check if the caller is the owner first because we want to ensure they can\r\n        // always swap out the authority even if it's reverting or using up a lot of gas.\r\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\r\n\r\n        authority = newAuthority;\r\n\r\n        emit AuthorityUpdated(msg.sender, newAuthority);\r\n    }\r\n\r\n    function setOwner(address newOwner) public virtual requiresAuth {\r\n        owner = newOwner;\r\n\r\n        emit OwnerUpdated(msg.sender, newOwner);\r\n    }\r\n}\r\n\r\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\r\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\r\ninterface Authority {\r\n    function canCall(\r\n        address user,\r\n        address target,\r\n        bytes4 functionSig\r\n    ) external view returns (bool);\r\n}\r\n\r\n\r\n// File srcBuild/Voter.sol\r\n\r\n\r\npragma solidity ^0.8.11;\r\n\r\nlibrary Math {\r\n    function min(uint a, uint b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ninterface IListingFee {\r\n    function listing_fee() external view returns (uint);\r\n}\r\n\r\ninterface erc20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function balanceOf(address) external view returns (uint);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    function approve(address spender, uint value) external returns (bool);\r\n}\r\n\r\ninterface ve {\r\n    function token() external view returns (address);\r\n    function balanceOfNFT(uint) external view returns (uint);\r\n    function isApprovedOrOwner(address, uint) external view returns (bool);\r\n    function ownerOf(uint) external view returns (address);\r\n    function transferFrom(address, address, uint) external;\r\n    function attach(uint tokenId) external;\r\n    function detach(uint tokenId) external;\r\n    function voting(uint tokenId) external;\r\n    function abstain(uint tokenId) external;\r\n}\r\n\r\ninterface GaugeFactory {\r\n    function createGauge(address, address, address) external returns (address);\r\n}\r\n\r\ninterface BribeFactory {\r\n    function createBribe() external returns (address);\r\n}\r\n\r\ninterface IGauge {\r\n    function notifyRewardAmount(address token, uint amount) external;\r\n    function stopDeposits() external;\r\n    function openDeposits() external;\r\n    function isDepositsOpen() external view returns (bool);\r\n    function getReward(address account, address[] memory tokens) external;\r\n    function left(address token) external view returns (uint);\r\n}\r\n\r\ninterface IBribe {\r\n    function _deposit(uint amount, uint tokenId) external;\r\n    function _withdraw(uint amount, uint tokenId) external;\r\n    function getRewardForOwner(uint tokenId, address[] memory tokens) external;\r\n}\r\n\r\ninterface IMinter {\r\n    function update_period() external returns (uint);\r\n}\r\n\r\ncontract Voter is Auth {\r\n\r\n    address public immutable _ve; // the ve token that governs these contracts\r\n    address internal immutable base;\r\n    address internal listingLP;\r\n    address internal listingFeeAddr;\r\n    address public immutable gaugefactory;\r\n    address public immutable bribefactory;\r\n    uint internal constant DURATION = 7 days; // rewards are released over 7 days\r\n    address public minter;\r\n    bool public openListing;\r\n    uint public totalWeight; // total voting weight\r\n\r\n    address[] public assets; // all assets viable for incentives\r\n    mapping(address => address) public gauges; // asset => gauge\r\n    mapping(address => address) public assetForGauge; // gauge => asset\r\n    mapping(address => address) public bribes; // gauge => bribe\r\n    mapping(address => int256) public weights; // pool => weight\r\n    mapping(uint => mapping(address => int256)) public votes; // nft => asset => votes\r\n    mapping(uint => address[]) public assetVote; // nft => assets\r\n    mapping(uint => uint) public usedWeights;  // nft => total voting weight of user\r\n    mapping(address => bool) public isGauge;\r\n    mapping(address => bool) public isWhitelisted;\r\n\r\n    event GaugeCreated(address indexed gauge, address creator, address indexed bribe, address indexed pool);\r\n    event Voted(address indexed voter, uint tokenId, int256 weight);\r\n    event Abstained(uint tokenId, int256 weight);\r\n    event Deposit(address indexed lp, address indexed gauge, uint tokenId, uint amount);\r\n    event Withdraw(address indexed lp, address indexed gauge, uint tokenId, uint amount);\r\n    event NotifyReward(address indexed sender, address indexed reward, uint amount);\r\n    event DistributeReward(address indexed sender, address indexed gauge, uint amount);\r\n    event Attach(address indexed owner, address indexed gauge, uint tokenId);\r\n    event Detach(address indexed owner, address indexed gauge, uint tokenId);\r\n    event Whitelisted(address indexed whitelister, address indexed token);\r\n    event DeListed(address indexed delister, address indexed token);\r\n\r\n    constructor(\r\n        address _guardian,\r\n        address _authority,\r\n        address __ve,\r\n        address _gauges,\r\n        address _bribes\r\n    ) Auth(_guardian, Authority(_authority)) {\r\n        _ve = __ve;\r\n        base = ve(__ve).token();\r\n        gaugefactory = _gauges;\r\n        bribefactory = _bribes;\r\n        minter = msg.sender;\r\n        openListing = false;\r\n    }\r\n\r\n    // simple re-entrancy check\r\n    uint internal _unlocked = 1;\r\n    modifier lock() {\r\n        require(_unlocked == 1);\r\n        _unlocked = 2;\r\n        _;\r\n        _unlocked = 1;\r\n    }\r\n\r\n    function initialize(address[] memory _tokens, address _minter) external {\r\n        require(msg.sender == minter);\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            _whitelist(_tokens[i]);\r\n        }\r\n        minter = _minter;\r\n    }\r\n\r\n    function migrateMinter(address newMinter_) external {\r\n        require(msg.sender == minter);\r\n        minter = newMinter_;\r\n    }\r\n\r\n    function setListingFeeAddress(address listingFeeAddress_) external requiresAuth {\r\n        listingFeeAddr = listingFeeAddress_;\r\n    }\r\n\r\n    function listing_fee() public view returns (uint) {\r\n        return IListingFee(listingFeeAddr).listing_fee();\r\n    }\r\n\r\n    function reset(uint _tokenId) external {\r\n        require(ve(_ve).isApprovedOrOwner(msg.sender, _tokenId));\r\n        _reset(_tokenId);\r\n        ve(_ve).abstain(_tokenId);\r\n    }\r\n\r\n    function _reset(uint _tokenId) internal {\r\n        address[] storage _assetVote = assetVote[_tokenId];\r\n        uint _assetVoteCnt = _assetVote.length;\r\n        int256 _totalWeight = 0;\r\n\r\n        for (uint i = 0; i < _assetVoteCnt; i ++) {\r\n            address _asset = _assetVote[i];\r\n            int256 _votes = votes[_tokenId][_asset];\r\n\r\n            if (_votes != 0) {\r\n                _updateFor(gauges[_asset]);\r\n                weights[_asset] -= _votes;\r\n                votes[_tokenId][_asset] -= _votes;\r\n                if (_votes > 0) {\r\n                    IBribe(bribes[gauges[_asset]])._withdraw(uint256(_votes), _tokenId);\r\n                    _totalWeight += _votes;\r\n                } else {\r\n                    _totalWeight -= _votes;\r\n                }\r\n                emit Abstained(_tokenId, _votes);\r\n            }\r\n        }\r\n        totalWeight -= uint256(_totalWeight);\r\n        usedWeights[_tokenId] = 0;\r\n        delete assetVote[_tokenId];\r\n    }\r\n\r\n    function poke(uint _tokenId) external {\r\n        address[] memory _assetVote = assetVote[_tokenId];\r\n        uint _assetCnt = _assetVote.length;\r\n        int256[] memory _weights = new int256[](_assetCnt);\r\n\r\n        for (uint i = 0; i < _assetCnt; i ++) {\r\n            _weights[i] = votes[_tokenId][_assetVote[i]];\r\n        }\r\n\r\n        _vote(_tokenId, _assetVote, _weights);\r\n    }\r\n\r\n    function _vote(uint _tokenId, address[] memory _assetVote, int256[] memory _weights) internal {\r\n        _reset(_tokenId);\r\n        uint _assetCnt = _assetVote.length;\r\n        int256 _weight = int256(ve(_ve).balanceOfNFT(_tokenId));\r\n        int256 _totalVoteWeight = 0;\r\n        int256 _totalWeight = 0;\r\n        int256 _usedWeight = 0;\r\n\r\n        for (uint i = 0; i < _assetCnt; i++) {\r\n            _totalVoteWeight += _weights[i] > 0 ? _weights[i] : -_weights[i];\r\n        }\r\n\r\n        for (uint i = 0; i < _assetCnt; i++) {\r\n            address _asset = _assetVote[i];\r\n            address _gauge = gauges[_asset];\r\n\r\n            if (isGauge[_gauge] && IGauge(_gauge).isDepositsOpen()) {\r\n                int256 _assetWeight = _weights[i] * _weight / _totalVoteWeight;\r\n                require(votes[_tokenId][_asset] == 0);\r\n                require(_assetWeight != 0);\r\n                _updateFor(_gauge);\r\n\r\n                assetVote[_tokenId].push(_asset);\r\n\r\n                weights[_asset] += _assetWeight;\r\n                votes[_tokenId][_asset] += _assetWeight;\r\n                if (_assetWeight > 0) {\r\n                    IBribe(bribes[_gauge])._deposit(uint256(_assetWeight), _tokenId);\r\n                } else {\r\n                    _assetWeight = -_assetWeight;\r\n                }\r\n                _usedWeight += _assetWeight;\r\n                _totalWeight += _assetWeight;\r\n                emit Voted(msg.sender, _tokenId, _assetWeight);\r\n            }\r\n        }\r\n        if (_usedWeight > 0) ve(_ve).voting(_tokenId);\r\n        totalWeight += uint256(_totalWeight);\r\n        usedWeights[_tokenId] = uint256(_usedWeight);\r\n    }\r\n\r\n    function vote(uint tokenId, address[] calldata _assetVote, int256[] calldata _weights) external {\r\n        require(ve(_ve).isApprovedOrOwner(msg.sender, tokenId));\r\n        require(_assetVote.length == _weights.length);\r\n        _vote(tokenId, _assetVote, _weights);\r\n    }\r\n\r\n    function gaugeStopDeposits(address _gauge) external requiresAuth {\r\n        IGauge(_gauge).stopDeposits();\r\n    }\r\n\r\n    function gaugeOpenDeposits(address _gauge) external requiresAuth {\r\n        IGauge(_gauge).openDeposits();\r\n    }\r\n\r\n    function whitelist(address _token) external {\r\n        require(openListing, \"not open for general listing\");\r\n\r\n        _safeTransferFrom(listingLP, msg.sender, owner, listing_fee());\r\n\r\n        _whitelist(_token);\r\n    }\r\n\r\n    function enableOpenListing() external requiresAuth {\r\n        openListing = true;\r\n    }\r\n\r\n    function disableOpenListing() external requiresAuth {\r\n        openListing = false;\r\n    }\r\n\r\n    function removeListing(address _token) external requiresAuth {\r\n        _removeListing(_token);\r\n    }\r\n\r\n    function whitelistAsAuth(address _token) external requiresAuth {\r\n        _whitelist(_token);\r\n    }\r\n\r\n    function _removeListing(address _token) internal {\r\n        require(isWhitelisted[_token]);\r\n        isWhitelisted[_token] = false;\r\n        emit DeListed(msg.sender, _token);\r\n    }\r\n\r\n    function _whitelist(address _token) internal {\r\n        require(!isWhitelisted[_token]);\r\n        isWhitelisted[_token] = true;\r\n        emit Whitelisted(msg.sender, _token);\r\n    }\r\n\r\n    function createGauge(address _asset) external returns (address) {\r\n        require(gauges[_asset] == address(0x0), \"exists\");\r\n        require(isWhitelisted[_asset], \"!whitelisted\");\r\n        address _bribe = BribeFactory(bribefactory).createBribe();\r\n        address _gauge = GaugeFactory(gaugefactory).createGauge(_asset, _bribe, _ve);\r\n        erc20(base).approve(_gauge, type(uint).max);\r\n        bribes[_gauge] = _bribe;\r\n        gauges[_asset] = _gauge;\r\n        assetForGauge[_gauge] = _asset;\r\n        isGauge[_gauge] = true;\r\n        IGauge(_gauge).openDeposits();\r\n        _updateFor(_gauge);\r\n        assets.push(_asset);\r\n        emit GaugeCreated(_gauge, msg.sender, _bribe, _asset);\r\n        return _gauge;\r\n    }\r\n\r\n    function attachTokenToGauge(uint tokenId, address account) external {\r\n        require(isGauge[msg.sender]);\r\n        if (tokenId > 0) ve(_ve).attach(tokenId);\r\n        emit Attach(account, msg.sender, tokenId);\r\n    }\r\n\r\n    function emitDeposit(uint tokenId, address account, uint amount) external {\r\n        require(isGauge[msg.sender]);\r\n        emit Deposit(account, msg.sender, tokenId, amount);\r\n    }\r\n\r\n    function detachTokenFromGauge(uint tokenId, address account) external {\r\n        require(isGauge[msg.sender]);\r\n        if (tokenId > 0) ve(_ve).detach(tokenId);\r\n        emit Detach(account, msg.sender, tokenId);\r\n    }\r\n\r\n    function emitWithdraw(uint tokenId, address account, uint amount) external {\r\n        require(isGauge[msg.sender]);\r\n        emit Withdraw(account, msg.sender, tokenId, amount);\r\n    }\r\n\r\n    function length() external view returns (uint) {\r\n        return assets.length;\r\n    }\r\n\r\n    uint internal index;\r\n    mapping(address => uint) internal supplyIndex;\r\n    mapping(address => uint) public claimable;\r\n\r\n    function notifyRewardAmount(uint amount) external {\r\n        _safeTransferFrom(base, msg.sender, address(this), amount); // transfer the distro in\r\n        uint256 _ratio = amount * 1e18 / totalWeight; // 1e18 adjustment is removed during claim\r\n        if (_ratio > 0) {\r\n            index += _ratio;\r\n        }\r\n        emit NotifyReward(msg.sender, base, amount);\r\n    }\r\n\r\n    function updateFor(address[] memory _gauges) external {\r\n        for (uint i = 0; i < _gauges.length; i++) {\r\n            _updateFor(_gauges[i]);\r\n        }\r\n    }\r\n\r\n    function updateForRange(uint start, uint end) public {\r\n        for (uint i = start; i < end; i++) {\r\n            _updateFor(gauges[assets[i]]);\r\n        }\r\n    }\r\n\r\n    function updateAll() external {\r\n        updateForRange(0, assets.length);\r\n    }\r\n\r\n    function updateGauge(address _gauge) external {\r\n        _updateFor(_gauge);\r\n    }\r\n\r\n    function _updateFor(address _gauge) internal {\r\n        address _asset = assetForGauge[_gauge];\r\n        int256 _supplied = weights[_asset];\r\n        if (_supplied > 0) {\r\n            uint _supplyIndex = supplyIndex[_gauge];\r\n            uint _index = index; // get global index0 for accumulated distro\r\n            supplyIndex[_gauge] = _index; // update _gauge current position to global position\r\n            uint _delta = _index - _supplyIndex; // see if there is any difference that need to be accrued\r\n            if (_delta > 0) {\r\n                uint _share = uint(_supplied) * _delta / 1e18; // add accrued difference for each supplied token\r\n                claimable[_gauge] += _share;\r\n            }\r\n        } else {\r\n            supplyIndex[_gauge] = index; // new users are set to the default global state\r\n        }\r\n    }\r\n\r\n    function claimRewards(address[] memory _gauges, address[][] memory _tokens) external {\r\n        for (uint i = 0; i < _gauges.length; i++) {\r\n            IGauge(_gauges[i]).getReward(msg.sender, _tokens[i]);\r\n        }\r\n    }\r\n\r\n    function claimBribes(address[] memory _bribes, address[][] memory _tokens, uint _tokenId) external {\r\n        require(ve(_ve).isApprovedOrOwner(msg.sender, _tokenId));\r\n        for (uint i = 0; i < _bribes.length; i++) {\r\n            IBribe(_bribes[i]).getRewardForOwner(_tokenId, _tokens[i]);\r\n        }\r\n    }\r\n\r\n    function distribute(address _gauge) public lock {\r\n        IMinter(minter).update_period();\r\n        _updateFor(_gauge);\r\n        uint _claimable = claimable[_gauge];\r\n        if (_claimable > IGauge(_gauge).left(base) && _claimable / DURATION > 0) {\r\n            claimable[_gauge] = 0;\r\n            IGauge(_gauge).notifyRewardAmount(base, _claimable);\r\n            emit DistributeReward(msg.sender, _gauge, _claimable);\r\n        }\r\n    }\r\n\r\n    function distro() external {\r\n        distribute(0, assets.length);\r\n    }\r\n\r\n    function distribute() external {\r\n        distribute(0, assets.length);\r\n    }\r\n\r\n    function distribute(uint start, uint finish) public {\r\n        for (uint x = start; x < finish; x++) {\r\n            distribute(gauges[assets[x]]);\r\n        }\r\n    }\r\n\r\n    function distribute(address[] memory _gauges) external {\r\n        for (uint x = 0; x < _gauges.length; x++) {\r\n            distribute(_gauges[x]);\r\n        }\r\n    }\r\n\r\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        require(token.code.length > 0);\r\n        (bool success, bytes memory data) =\r\n        token.call(abi.encodeWithSelector(erc20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_authority\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"__ve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gauges\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bribes\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"weight\",\"type\":\"int256\"}],\"name\":\"Abstained\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Attach\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delister\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"DeListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Detach\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DistributeReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bribe\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"GaugeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NotifyReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"weight\",\"type\":\"int256\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelister\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_ve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetForGauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assetVote\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"attachTokenToGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bribefactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bribes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bribes\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"_tokens\",\"type\":\"address[][]\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claimBribes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauges\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"_tokens\",\"type\":\"address[][]\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"createGauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"detachTokenFromGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableOpenListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauges\",\"type\":\"address[]\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distro\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emitDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emitWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableOpenListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"gaugeOpenDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"gaugeStopDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugefactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gauges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isGauge\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listing_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMinter_\",\"type\":\"address\"}],\"name\":\"migrateMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openListing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"poke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"removeListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"reset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"listingFeeAddress_\",\"type\":\"address\"}],\"name\":\"setListingFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauges\",\"type\":\"address[]\"}],\"name\":\"updateFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"updateForRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"updateGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usedWeights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_assetVote\",\"type\":\"address[]\"},{\"internalType\":\"int256[]\",\"name\":\"_weights\",\"type\":\"int256[]\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"votes\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"weights\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"whitelistAsAuth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Voter", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004d03fb78bda67a04f1bd6fde5024759d8ce8d866000000000000000000000000cbb46b017e8d785c107e97c56135894b3ead599c000000000000000000000000f2fec13cdb46760e065ddc1df9da16cb87afd61f000000000000000000000000e7d2180f8c4ca8e011173bb260c7e08679afeea1000000000000000000000000994e0f91eef84d64fc1d4e4c283712928915fedd", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ec122a3e74c469ce445aec79439e2a1c7ad8a31baaa4b58f9317f4a6c98a1938"}]}