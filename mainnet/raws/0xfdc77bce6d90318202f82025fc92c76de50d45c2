{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.4;\n\ninterface IPriceCalculator {\n    // 1st arg: initial price [wad]\n    // 2nd arg: seconds since auction start [seconds]\n    // returns: current auction price [wad]\n    function price(uint256, uint256) external view returns (uint256);\n}// Copyright (C) 2020-2021 Maker Ecosystem Growth Holdings, INC.\n\ninterface ICodex {\n    function init(address vault) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address,\n        bytes32,\n        uint256\n    ) external;\n\n    function credit(address) external view returns (uint256);\n\n    function unbackedDebt(address) external view returns (uint256);\n\n    function balances(\n        address,\n        uint256,\n        address\n    ) external view returns (uint256);\n\n    function vaults(address vault)\n        external\n        view\n        returns (\n            uint256 totalNormalDebt,\n            uint256 rate,\n            uint256 debtCeiling,\n            uint256 debtFloor\n        );\n\n    function positions(\n        address vault,\n        uint256 tokenId,\n        address position\n    ) external view returns (uint256 collateral, uint256 normalDebt);\n\n    function globalDebt() external view returns (uint256);\n\n    function globalUnbackedDebt() external view returns (uint256);\n\n    function globalDebtCeiling() external view returns (uint256);\n\n    function delegates(address, address) external view returns (uint256);\n\n    function grantDelegate(address) external;\n\n    function revokeDelegate(address) external;\n\n    function modifyBalance(\n        address,\n        uint256,\n        address,\n        int256\n    ) external;\n\n    function transferBalance(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function transferCredit(\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function modifyCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function transferCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function confiscateCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function settleUnbackedDebt(uint256 debt) external;\n\n    function createUnbackedDebt(\n        address debtor,\n        address creditor,\n        uint256 debt\n    ) external;\n\n    function modifyRate(\n        address vault,\n        address creditor,\n        int256 rate\n    ) external;\n\n    function lock() external;\n}interface IPriceFeed {\n    function peek() external returns (bytes32, bool);\n\n    function read() external view returns (bytes32);\n}\n\ninterface ICollybus {\n    function vaults(address) external view returns (uint128, uint128);\n\n    function spots(address) external view returns (uint256);\n\n    function rates(uint256) external view returns (uint256);\n\n    function rateIds(address, uint256) external view returns (uint256);\n\n    function redemptionPrice() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint128 data\n    ) external;\n\n    function setParam(\n        address vault,\n        uint256 tokenId,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function updateDiscountRate(uint256 rateId, uint256 rate) external;\n\n    function updateSpot(address token, uint256 spot) external;\n\n    function read(\n        address vault,\n        address underlier,\n        uint256 tokenId,\n        uint256 maturity,\n        bool net\n    ) external view returns (uint256 price);\n\n    function lock() external;\n}\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\ninterface IDebtAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function tokenToSellBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function aer() external view returns (address);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(\n        address recipient,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock() external;\n\n    function cancelAuction(uint256 id) external;\n}\ninterface ISurplusAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(uint256 creditToSell, uint256 bid) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 creditToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock(uint256 credit) external;\n\n    function cancelAuction(uint256 id) external;\n}\n\ninterface IAer {\n    function codex() external view returns (ICodex);\n\n    function surplusAuction() external view returns (ISurplusAuction);\n\n    function debtAuction() external view returns (IDebtAuction);\n\n    function debtQueue(uint256) external view returns (uint256);\n\n    function queuedDebt() external view returns (uint256);\n\n    function debtOnAuction() external view returns (uint256);\n\n    function auctionDelay() external view returns (uint256);\n\n    function debtAuctionSellSize() external view returns (uint256);\n\n    function debtAuctionBidSize() external view returns (uint256);\n\n    function surplusAuctionSellSize() external view returns (uint256);\n\n    function surplusBuffer() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function queueDebt(uint256 debt) external;\n\n    function unqueueDebt(uint256 queuedAt) external;\n\n    function settleDebtWithSurplus(uint256 debt) external;\n\n    function settleAuctionedDebt(uint256 debt) external;\n\n    function startDebtAuction() external returns (uint256 auctionId);\n\n    function startSurplusAuction() external returns (uint256 auctionId);\n\n    function transferCredit(address to, uint256 credit) external;\n\n    function lock() external;\n}\ninterface ILimes {\n    function codex() external view returns (ICodex);\n\n    function aer() external view returns (IAer);\n\n    function vaults(address)\n        external\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function live() external view returns (uint256);\n\n    function globalMaxDebtOnAuction() external view returns (uint256);\n\n    function globalDebtOnAuction() external view returns (uint256);\n\n    function setParam(bytes32 param, address data) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        address collateralAuction\n    ) external;\n\n    function liquidationPenalty(address vault) external view returns (uint256);\n\n    function liquidate(\n        address vault,\n        uint256 tokenId,\n        address position,\n        address keeper\n    ) external returns (uint256 auctionId);\n\n    function liquidated(\n        address vault,\n        uint256 tokenId,\n        uint256 debt\n    ) external;\n\n    function lock() external;\n}\n\ninterface CollateralAuctionCallee {\n    function collateralAuctionCall(\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external;\n}\n\ninterface ICollateralAuction {\n    function vaults(address)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            ICollybus,\n            IPriceCalculator\n        );\n\n    function codex() external view returns (ICodex);\n\n    function limes() external view returns (ILimes);\n\n    function aer() external view returns (IAer);\n\n    function feeTip() external view returns (uint64);\n\n    function flatTip() external view returns (uint192);\n\n    function auctionCounter() external view returns (uint256);\n\n    function activeAuctions(uint256) external view returns (uint256);\n\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            address,\n            uint96,\n            uint256\n        );\n\n    function stopped() external view returns (uint256);\n\n    function init(address vault, address collybus) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        address data\n    ) external;\n\n    function startAuction(\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address keeper\n    ) external returns (uint256 auctionId);\n\n    function redoAuction(uint256 auctionId, address keeper) external;\n\n    function takeCollateral(\n        uint256 auctionId,\n        uint256 collateralAmount,\n        uint256 maxPrice,\n        address recipient,\n        bytes calldata data\n    ) external;\n\n    function count() external view returns (uint256);\n\n    function list() external view returns (uint256[] memory);\n\n    function getStatus(uint256 auctionId)\n        external\n        view\n        returns (\n            bool needsRedo,\n            uint256 price,\n            uint256 collateralToSell,\n            uint256 debt\n        );\n\n    function updateAuctionDebtFloor(address vault) external;\n\n    function cancelAuction(uint256 auctionId) external;\n}interface INoLossCollateralAuction {\n    function vaults(address)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            ICollybus,\n            IPriceCalculator\n        );\n\n    function codex() external view returns (ICodex);\n\n    function limes() external view returns (ILimes);\n\n    function aer() external view returns (IAer);\n\n    function feeTip() external view returns (uint64);\n\n    function flatTip() external view returns (uint192);\n\n    function auctionCounter() external view returns (uint256);\n\n    function activeAuctions(uint256) external view returns (uint256);\n\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            address,\n            uint96,\n            uint256\n        );\n\n    function stopped() external view returns (uint256);\n\n    function init(address vault, address collybus) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        address data\n    ) external;\n\n    function startAuction(\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address keeper\n    ) external returns (uint256 auctionId);\n\n    function redoAuction(uint256 auctionId, address keeper) external;\n\n    function takeCollateral(\n        uint256 auctionId,\n        uint256 collateralAmount,\n        uint256 maxPrice,\n        address recipient,\n        bytes calldata data\n    ) external;\n\n    function count() external view returns (uint256);\n\n    function list() external view returns (uint256[] memory);\n\n    function getStatus(uint256 auctionId)\n        external\n        view\n        returns (\n            bool needsRedo,\n            uint256 price,\n            uint256 collateralToSell,\n            uint256 debt\n        );\n\n    function updateAuctionDebtFloor(address vault) external;\n\n    function cancelAuction(uint256 auctionId) external;\n}interface IVault {\n    function codex() external view returns (ICodex);\n\n    function collybus() external view returns (ICollybus);\n\n    function token() external view returns (address);\n\n    function tokenScale() external view returns (uint256);\n\n    function underlierToken() external view returns (address);\n\n    function underlierScale() external view returns (uint256);\n\n    function vaultType() external view returns (bytes32);\n\n    function live() external view returns (uint256);\n\n    function lock() external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function maturity(uint256 tokenId) external returns (uint256);\n\n    function fairPrice(\n        uint256 tokenId,\n        bool net,\n        bool face\n    ) external view returns (uint256);\n\n    function enter(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n\n    function exit(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n}\ninterface IGuarded {\n    function ANY_SIG() external view returns (bytes32);\n\n    function ANY_CALLER() external view returns (address);\n\n    function allowCaller(bytes32 sig, address who) external;\n\n    function blockCaller(bytes32 sig, address who) external;\n\n    function canCall(bytes32 sig, address who) external view returns (bool);\n}\n/// @title Guarded\n/// @notice Mixin implementing an authentication scheme on a method level\nabstract contract Guarded is IGuarded {\n    /// ======== Custom Errors ======== ///\n\n    error Guarded__notRoot();\n    error Guarded__notGranted();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Wildcard for granting a caller to call every guarded method\n    bytes32 public constant override ANY_SIG = keccak256(\"ANY_SIG\");\n    /// @notice Wildcard for granting a caller to call every guarded method\n    address public constant override ANY_CALLER = address(uint160(uint256(bytes32(keccak256(\"ANY_CALLER\")))));\n\n    /// @notice Mapping storing who is granted to which method\n    /// @dev Method Signature => Caller => Bool\n    mapping(bytes32 => mapping(address => bool)) private _canCall;\n\n    /// ======== Events ======== ///\n\n    event AllowCaller(bytes32 sig, address who);\n    event BlockCaller(bytes32 sig, address who);\n\n    constructor() {\n        // set root\n        _setRoot(msg.sender);\n    }\n\n    /// ======== Auth ======== ///\n\n    modifier callerIsRoot() {\n        if (_canCall[ANY_SIG][msg.sender]) {\n            _;\n        } else revert Guarded__notRoot();\n    }\n\n    modifier checkCaller() {\n        if (canCall(msg.sig, msg.sender)) {\n            _;\n        } else revert Guarded__notGranted();\n    }\n\n    /// @notice Grant the right to call method `sig` to `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function allowCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = true;\n        emit AllowCaller(sig, who);\n    }\n\n    /// @notice Revoke the right to call method `sig` from `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should not be able to call `sig` anymore\n    function blockCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = false;\n        emit BlockCaller(sig, who);\n    }\n\n    /// @notice Returns if `who` can call `sig`\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function canCall(bytes32 sig, address who) public view override returns (bool) {\n        return (_canCall[sig][who] || _canCall[ANY_SIG][who] || _canCall[sig][ANY_CALLER]);\n    }\n\n    /// @notice Sets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be set as root\n    function _setRoot(address root) internal {\n        _canCall[ANY_SIG][root] = true;\n        emit AllowCaller(ANY_SIG, root);\n    }\n\n    /// @notice Unsets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be unset as root\n    function _unsetRoot(address root) internal {\n        _canCall[ANY_SIG][root] = false;\n        emit AllowCaller(ANY_SIG, root);\n    }\n}// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n\nuint256 constant MLN = 10**6;\nuint256 constant BLN = 10**9;\nuint256 constant WAD = 10**18;\nuint256 constant RAY = 10**18;\nuint256 constant RAD = 10**18;\n\n/* solhint-disable func-visibility, no-inline-assembly */\n\nerror Math__toInt256_overflow(uint256 x);\n\nfunction toInt256(uint256 x) pure returns (int256) {\n    if (x > uint256(type(int256).max)) revert Math__toInt256_overflow(x);\n    return int256(x);\n}\n\nfunction min(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x <= y ? x : y;\n    }\n}\n\nfunction max(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x >= y ? x : y;\n    }\n}\n\nerror Math__diff_overflow(uint256 x, uint256 y);\n\nfunction diff(uint256 x, uint256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) - int256(y);\n        if (!(int256(x) >= 0 && int256(y) >= 0)) revert Math__diff_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow(uint256 x, uint256 y);\n\nfunction add(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add_overflow(x, y);\n    }\n}\n\nerror Math__add48_overflow(uint256 x, uint256 y);\n\nfunction add48(uint48 x, uint48 y) pure returns (uint48 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add48_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow_signed(uint256 x, int256 y);\n\nfunction add(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x + uint256(y);\n        if (!(y >= 0 || z <= x)) revert Math__add_overflow_signed(x, y);\n        if (!(y <= 0 || z >= x)) revert Math__add_overflow_signed(x, y);\n    }\n}\n\nerror Math__sub_overflow(uint256 x, uint256 y);\n\nfunction sub(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x - y) > x) revert Math__sub_overflow(x, y);\n    }\n}\n\nerror Math__sub_overflow_signed(uint256 x, int256 y);\n\nfunction sub(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x - uint256(y);\n        if (!(y <= 0 || z <= x)) revert Math__sub_overflow_signed(x, y);\n        if (!(y >= 0 || z >= x)) revert Math__sub_overflow_signed(x, y);\n    }\n}\n\nerror Math__mul_overflow(uint256 x, uint256 y);\n\nfunction mul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (!(y == 0 || (z = x * y) / y == x)) revert Math__mul_overflow(x, y);\n    }\n}\n\nerror Math__mul_overflow_signed(uint256 x, int256 y);\n\nfunction mul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) * y;\n        if (int256(x) < 0) revert Math__mul_overflow_signed(x, y);\n        if (!(y == 0 || z / y == int256(x))) revert Math__mul_overflow_signed(x, y);\n    }\n}\n\nfunction wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, y) / WAD;\n    }\n}\n\nfunction wmul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = mul(x, y) / int256(WAD);\n    }\n}\n\nerror Math__div_overflow(uint256 x, uint256 y);\n\nfunction div(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (y == 0) revert Math__div_overflow(x, y);\n        return x / y;\n    }\n}\n\nfunction wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, WAD) / y;\n    }\n}\n\n// optimized version from dss PR #78\nfunction wpow(\n    uint256 x,\n    uint256 n,\n    uint256 b\n) pure returns (uint256 z) {\n    unchecked {\n        assembly {\n            switch n\n            case 0 {\n                z := b\n            }\n            default {\n                switch x\n                case 0 {\n                    z := 0\n                }\n                default {\n                    switch mod(n, 2)\n                    case 0 {\n                        z := b\n                    }\n                    default {\n                        z := x\n                    }\n                    let half := div(b, 2) // for rounding.\n                    for {\n                        n := div(n, 2)\n                    } n {\n                        n := div(n, 2)\n                    } {\n                        let xx := mul(x, x)\n                        if shr(128, x) {\n                            revert(0, 0)\n                        }\n                        let xxRound := add(xx, half)\n                        if lt(xxRound, xx) {\n                            revert(0, 0)\n                        }\n                        x := div(xxRound, b)\n                        if mod(n, 2) {\n                            let zx := mul(z, x)\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                                revert(0, 0)\n                            }\n                            let zxRound := add(zx, half)\n                            if lt(zxRound, zx) {\n                                revert(0, 0)\n                            }\n                            z := div(zxRound, b)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/* solhint-disable func-visibility, no-inline-assembly */\n/// @title NoLossCollateralAuction\n/// @notice Same as CollateralAuction but enforces a floor price of debt / collateral\n/// Uses Clip.sol from DSS (MakerDAO) as a blueprint\n/// Changes from Clip.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract NoLossCollateralAuction is Guarded, INoLossCollateralAuction {\n    /// ======== Custom Errors ======== ///\n\n    error NoLossCollateralAuction__init_vaultAlreadyInit();\n    error NoLossCollateralAuction__checkReentrancy_reentered();\n    error NoLossCollateralAuction__isStopped_stoppedIncorrect();\n    error NoLossCollateralAuction__setParam_unrecognizedParam();\n    error NoLossCollateralAuction__startAuction_zeroDebt();\n    error NoLossCollateralAuction__startAuction_zeroCollateralToSell();\n    error NoLossCollateralAuction__startAuction_zeroUser();\n    error NoLossCollateralAuction__startAuction_overflow();\n    error NoLossCollateralAuction__startAuction_zeroStartPrice();\n    error NoLossCollateralAuction__redoAuction_notRunningAuction();\n    error NoLossCollateralAuction__redoAuction_cannotReset();\n    error NoLossCollateralAuction__redoAuction_zeroStartPrice();\n    error NoLossCollateralAuction__takeCollateral_notRunningAuction();\n    error NoLossCollateralAuction__takeCollateral_needsReset();\n    error NoLossCollateralAuction__takeCollateral_tooExpensive();\n    error NoLossCollateralAuction__takeCollateral_noPartialPurchase();\n    error NoLossCollateralAuction__cancelAuction_notRunningAction();\n\n    /// ======== Storage ======== ///\n\n    // Vault specific configuration data\n    struct VaultConfig {\n        // Multiplicative factor to increase start price [wad]\n        uint256 multiplier;\n        // Time elapsed before auction reset [seconds]\n        uint256 maxAuctionDuration;\n        // Cache (v.debtFloor * v.liquidationPenalty) to prevent excessive SLOADs [wad]\n        uint256 auctionDebtFloor;\n        // Collateral price module\n        ICollybus collybus;\n        // Current price calculator\n        IPriceCalculator calculator;\n    }\n\n    /// @notice Vault Configs\n    /// @dev Vault => Vault Config\n    mapping(address => VaultConfig) public override vaults;\n\n    /// @notice Codex\n    ICodex public immutable override codex;\n    /// @notice Limes\n    ILimes public override limes;\n    /// @notice Aer (Recipient of credit raised in auctions)\n    IAer public override aer;\n    /// @notice Percentage of debt to mint from aer to incentivize keepers [wad]\n    uint64 public override feeTip;\n    /// @notice Flat fee to mint from aer to incentivize keepers [wad]\n    uint192 public override flatTip;\n    /// @notice Total auctions (includes past auctions)\n    uint256 public override auctionCounter;\n    /// @notice Array of active auction ids\n    uint256[] public override activeAuctions;\n\n    // Auction State\n    struct Auction {\n        // Index in activeAuctions array\n        uint256 index;\n        // Debt to sell == Credit to raise [wad]\n        uint256 debt;\n        // collateral to sell [wad]\n        uint256 collateralToSell;\n        // Vault of the liquidated Positions collateral\n        address vault;\n        // TokenId of the liquidated Positions collateral\n        uint256 tokenId;\n        // Owner of the liquidated Position\n        address user;\n        // Auction start time\n        uint96 startsAt;\n        // Starting price [wad]\n        uint256 startPrice;\n    }\n    /// @notice State of auctions\n    /// @dev AuctionId => Auction\n    mapping(uint256 => Auction) public override auctions;\n\n    // reentrancy guard\n    uint256 private entered;\n\n    /// @notice Circuit breaker level\n    /// Levels for circuit breaker\n    /// 0: no breaker\n    /// 1: no new startAuction()\n    /// 2: no new startAuction() or redoAuction()\n    /// 3: no new startAuction(), redoAuction(), or takeCollateral()\n    uint256 public override stopped = 0;\n\n    /// ======== Events ======== ///\n\n    event Init(address vault);\n\n    event SetParam(bytes32 indexed param, uint256 data);\n    event SetParam(bytes32 indexed param, address data);\n\n    event StartAuction(\n        uint256 indexed auctionId,\n        uint256 startPrice,\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address indexed keeper,\n        uint256 tip\n    );\n    event TakeCollateral(\n        uint256 indexed auctionId,\n        uint256 maxPrice,\n        uint256 price,\n        uint256 owe,\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address indexed user\n    );\n    event RedoAuction(\n        uint256 indexed auctionId,\n        uint256 startPrice,\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address indexed keeper,\n        uint256 tip\n    );\n\n    event StopAuction(uint256 auctionId);\n\n    event UpdateAuctionDebtFloor(address indexed vault, uint256 auctionDebtFloor);\n\n    constructor(address codex_, address limes_) Guarded() {\n        codex = ICodex(codex_);\n        limes = ILimes(limes_);\n    }\n\n    modifier checkReentrancy() {\n        if (entered == 0) {\n            entered = 1;\n            _;\n            entered = 0;\n        } else revert NoLossCollateralAuction__checkReentrancy_reentered();\n    }\n\n    modifier isStopped(uint256 level) {\n        if (stopped < level) {\n            _;\n        } else revert NoLossCollateralAuction__isStopped_stoppedIncorrect();\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Initializes a new Vault for which collateral can be auctioned off\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param collybus Address of the Collybus the Vault uses for pricing\n    function init(address vault, address collybus) external override checkCaller {\n        if (vaults[vault].calculator != IPriceCalculator(address(0)))\n            revert NoLossCollateralAuction__init_vaultAlreadyInit();\n        vaults[vault].multiplier = WAD;\n        vaults[vault].collybus = ICollybus(collybus);\n\n        emit Init(vault);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller checkReentrancy {\n        if (param == \"feeTip\")\n            feeTip = uint64(data); // Percentage of debt to incentivize (max: 2^64 - 1 => 18.xxx WAD = 18xx%)\n        else if (param == \"flatTip\")\n            flatTip = uint192(data); // Flat fee to incentivize keepers (max: 2^192 - 1 => 6.277T WAD)\n        else if (param == \"stopped\")\n            stopped = data; // Set breaker (0, 1, 2, or 3)\n        else revert NoLossCollateralAuction__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(bytes32 param, address data) external override checkCaller checkReentrancy {\n        if (param == \"limes\") limes = ILimes(data);\n        else if (param == \"aer\") aer = IAer(data);\n        else revert NoLossCollateralAuction__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external override checkCaller checkReentrancy {\n        if (param == \"multiplier\") vaults[vault].multiplier = data;\n        else if (param == \"maxAuctionDuration\")\n            vaults[vault].maxAuctionDuration = data; // Time elapsed before auction reset\n        else revert NoLossCollateralAuction__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(\n        address vault,\n        bytes32 param,\n        address data\n    ) external override checkCaller checkReentrancy {\n        if (param == \"collybus\") vaults[vault].collybus = ICollybus(data);\n        else if (param == \"calculator\") vaults[vault].calculator = IPriceCalculator(data);\n        else revert NoLossCollateralAuction__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== No Loss Collateral Auction ======== ///\n\n    // get price at maturity\n    function _getPrice(address vault, uint256 tokenId) internal view returns (uint256) {\n        return IVault(vault).fairPrice(tokenId, false, true);\n    }\n\n    /// @notice Starts a collateral auction\n    /// The start price `startPrice` is obtained as follows:\n    ///     startPrice = val * multiplier / redemptionPrice\n    /// Where `val` is the collateral's unitary value in USD, `multiplier` is a\n    /// multiplicative factor to increase the start price, and `redemptionPrice` is a reference per Credit.\n    /// @dev Sender has to be allowed to call this method\n    /// - trusts the caller to transfer collateral to the contract\n    /// - reverts if circuit breaker is set to 1 (no new auctions)\n    /// @param debt Amount of debt to sell / credit to buy [wad]\n    /// @param collateralToSell Amount of collateral to sell [wad]\n    /// @param vault Address of the collaterals Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20) of the collateral\n    /// @param user Address that will receive any leftover collateral\n    /// @param keeper Address that will receive incentives\n    /// @return auctionId Identifier of started auction\n    function startAuction(\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address keeper\n    ) external override checkCaller checkReentrancy isStopped(1) returns (uint256 auctionId) {\n        // Input validation\n        if (debt == 0) revert NoLossCollateralAuction__startAuction_zeroDebt();\n        if (collateralToSell == 0) revert NoLossCollateralAuction__startAuction_zeroCollateralToSell();\n        if (user == address(0)) revert NoLossCollateralAuction__startAuction_zeroUser();\n        unchecked {\n            auctionId = ++auctionCounter;\n        }\n        if (auctionId == 0) revert NoLossCollateralAuction__startAuction_overflow();\n\n        activeAuctions.push(auctionId);\n\n        auctions[auctionId].index = activeAuctions.length - 1;\n\n        auctions[auctionId].debt = debt;\n        auctions[auctionId].collateralToSell = collateralToSell;\n        auctions[auctionId].vault = vault;\n        auctions[auctionId].tokenId = tokenId;\n        auctions[auctionId].user = user;\n        auctions[auctionId].startsAt = uint96(block.timestamp);\n\n        uint256 startPrice;\n        startPrice = wmul(_getPrice(vault, tokenId), vaults[vault].multiplier);\n        if (startPrice <= 0) revert NoLossCollateralAuction__startAuction_zeroStartPrice();\n        auctions[auctionId].startPrice = startPrice;\n\n        // incentive to startAuction auction\n        uint256 _tip = flatTip;\n        uint256 _feeTip = feeTip;\n        uint256 tip;\n        if (_tip > 0 || _feeTip > 0) {\n            tip = add(_tip, wmul(debt, _feeTip));\n            codex.createUnbackedDebt(address(aer), keeper, tip);\n        }\n\n        emit StartAuction(auctionId, startPrice, debt, collateralToSell, vault, tokenId, user, keeper, tip);\n    }\n\n    /// @notice Resets an existing collateral auction\n    /// See `startAuction` above for an explanation of the computation of `startPrice`.\n    /// multiplicative factor to increase the start price, and `redemptionPrice` is a reference per Credit.\n    /// @dev Reverts if circuit breaker is set to 2 (no new auctions and no redos of auctions)\n    /// @param auctionId Id of the auction to reset\n    /// @param keeper Address that will receive incentives\n    function redoAuction(uint256 auctionId, address keeper) external override checkReentrancy isStopped(2) {\n        // Read auction data\n        Auction memory auction = auctions[auctionId];\n\n        if (auction.user == address(0)) revert NoLossCollateralAuction__redoAuction_notRunningAuction();\n\n        // Check that auction needs reset\n        // and compute current price [wad]\n        {\n            (bool done, ) = status(auction);\n            if (!done) revert NoLossCollateralAuction__redoAuction_cannotReset();\n        }\n\n        uint256 debt = auctions[auctionId].debt;\n        uint256 collateralToSell = auctions[auctionId].collateralToSell;\n        auctions[auctionId].startsAt = uint96(block.timestamp);\n\n        uint256 price = _getPrice(auction.vault, auction.tokenId);\n        uint256 startPrice = wmul(price, vaults[auction.vault].multiplier);\n        if (startPrice <= 0) revert NoLossCollateralAuction__redoAuction_zeroStartPrice();\n        auctions[auctionId].startPrice = startPrice;\n\n        // incentive to redoAuction auction\n        uint256 tip;\n        {\n            uint256 _tip = flatTip;\n            uint256 _feeTip = feeTip;\n            if (_tip > 0 || _feeTip > 0) {\n                uint256 _auctionDebtFloor = vaults[auction.vault].auctionDebtFloor;\n                if (debt >= _auctionDebtFloor && wmul(collateralToSell, price) >= _auctionDebtFloor) {\n                    tip = add(_tip, wmul(debt, _feeTip));\n                    codex.createUnbackedDebt(address(aer), keeper, tip);\n                }\n            }\n        }\n\n        emit RedoAuction(\n            auctionId,\n            startPrice,\n            debt,\n            collateralToSell,\n            auction.vault,\n            auction.tokenId,\n            auction.user,\n            keeper,\n            tip\n        );\n    }\n\n    /// @notice Buy up to `collateralAmount` of collateral from the auction indexed by `id`\n    ///\n    /// Auctions will not collect more Credit than their assigned Credit target,`debt`;\n    /// thus, if `collateralAmount` would cost more Credit than `debt` at the current price, the\n    /// amount of collateral purchased will instead be just enough to collect `debt` in Credit.\n    ///\n    /// To avoid partial purchases resulting in very small leftover auctions that will\n    /// never be cleared, any partial purchase must leave at least `CollateralAuction.auctionDebtFloor`\n    /// remaining Credit target. `auctionDebtFloor` is an asynchronously updated value equal to\n    /// (Codex.debtFloor * Limes.liquidationPenalty(vault) / WAD) where the values are understood to be determined\n    /// by whatever they were when CollateralAuction.updateAuctionDebtFloor() was last called. Purchase amounts\n    /// will be minimally decreased when necessary to respect this limit; i.e., if the\n    /// specified `collateralAmount` would leave `debt < auctionDebtFloor` but `debt > 0`, the amount actually\n    /// purchased will be such that `debt == auctionDebtFloor`.\n    ///\n    /// If `debt <= auctionDebtFloor`, partial purchases are no longer possible; that is, the remaining\n    /// collateral can only be purchased entirely, or not at all.\n    ///\n    /// Enforces a price floor of debt / collateral\n    ///\n    /// @dev Reverts if circuit breaker is set to 3 (no new auctions, no redos of auctions and no collateral buying)\n    /// @param auctionId Id of the auction to buy collateral from\n    /// @param collateralAmount Upper limit on amount of collateral to buy [wad]\n    /// @param maxPrice Maximum acceptable price (Credit / collateral) [wad]\n    /// @param recipient Receiver of collateral and external call address\n    /// @param data Data to pass in external call; if length 0, no call is done\n    function takeCollateral(\n        uint256 auctionId, // Auction id\n        uint256 collateralAmount, // Upper limit on amount of collateral to buy [wad]\n        uint256 maxPrice, // Maximum acceptable price (Credit / collateral) [wad]\n        address recipient, // Receiver of collateral and external call address\n        bytes calldata data // Data to pass in external call; if length 0, no call is done\n    ) external override checkReentrancy isStopped(3) {\n        Auction memory auction = auctions[auctionId];\n\n        if (auction.user == address(0)) revert NoLossCollateralAuction__takeCollateral_notRunningAuction();\n\n        uint256 price;\n        {\n            bool done;\n            (done, price) = status(auction);\n\n            // Check that auction doesn't need reset\n            if (done) revert NoLossCollateralAuction__takeCollateral_needsReset();\n            // Ensure price is acceptable to buyer\n            if (maxPrice < price) revert NoLossCollateralAuction__takeCollateral_tooExpensive();\n        }\n\n        uint256 collateralToSell = auction.collateralToSell;\n        uint256 debt = auction.debt;\n        uint256 owe;\n\n        unchecked {\n            {\n                // Purchase as much as possible, up to collateralAmount\n                // collateralSlice <= collateralToSell\n                uint256 collateralSlice = min(collateralToSell, collateralAmount);\n\n                // Credit needed to buy a collateralSlice of this auction\n                owe = wmul(collateralSlice, price);\n\n                // owe can be greater than debt and thus user would pay a premium to the recipient\n\n                if (owe < debt && collateralSlice < collateralToSell) {\n                    // If collateralSlice == collateralToSell => auction completed => debtFloor doesn't matter\n                    uint256 _auctionDebtFloor = vaults[auction.vault].auctionDebtFloor;\n                    if (debt - owe < _auctionDebtFloor) {\n                        // safe as owe < debt\n                        // If debt <= auctionDebtFloor, buyers have to take the entire collateralToSell.\n                        if (debt <= _auctionDebtFloor)\n                            revert NoLossCollateralAuction__takeCollateral_noPartialPurchase();\n                        // Adjust amount to pay\n                        owe = debt - _auctionDebtFloor; // owe' <= owe\n                        // Adjust collateralSlice\n                        // collateralSlice' = owe' / price < owe / price == collateralSlice < collateralToSell\n                        collateralSlice = wdiv(owe, price);\n                    }\n                }\n\n                // Calculate remaining collateralToSell after operation\n                collateralToSell = collateralToSell - collateralSlice;\n\n                // Send collateral to recipient\n                codex.transferBalance(auction.vault, auction.tokenId, address(this), recipient, collateralSlice);\n\n                // Do external call (if data is defined) but to be\n                // extremely careful we don't allow to do it to the two\n                // contracts which the CollateralAuction needs to be authorized\n                ILimes limes_ = limes;\n                if (data.length > 0 && recipient != address(codex) && recipient != address(limes_)) {\n                    CollateralAuctionCallee(recipient).collateralAuctionCall(msg.sender, owe, collateralSlice, data);\n                }\n\n                // Get Credit from caller\n                codex.transferCredit(msg.sender, address(aer), owe);\n\n                // Removes Credit out for liquidation from accumulator\n                // if all collateral has been sold or owe is larger than remaining debt\n                //  then just remove the remaining debt from the accumulator\n                limes_.liquidated(auction.vault, auction.tokenId, (collateralToSell == 0 || debt < owe) ? debt : owe);\n\n                // Calculate remaining debt after operation\n                debt = (owe < debt) ? debt - owe : 0; // safe since owe <= debt\n            }\n        }\n\n        if (collateralToSell == 0) {\n            _remove(auctionId);\n        } else if (debt == 0) {\n            codex.transferBalance(auction.vault, auction.tokenId, address(this), auction.user, collateralToSell);\n            _remove(auctionId);\n        } else {\n            auctions[auctionId].debt = debt;\n            auctions[auctionId].collateralToSell = collateralToSell;\n        }\n\n        emit TakeCollateral(\n            auctionId,\n            maxPrice,\n            price,\n            owe,\n            debt,\n            collateralToSell,\n            auction.vault,\n            auction.tokenId,\n            auction.user\n        );\n    }\n\n    // Removes an auction from the active auctions array\n    function _remove(uint256 auctionId) internal {\n        uint256 _move = activeAuctions[activeAuctions.length - 1];\n        if (auctionId != _move) {\n            uint256 _index = auctions[auctionId].index;\n            activeAuctions[_index] = _move;\n            auctions[_move].index = _index;\n        }\n        activeAuctions.pop();\n        delete auctions[auctionId];\n    }\n\n    /// @notice The number of active auctions\n    /// @return Number of active auctions\n    function count() external view override returns (uint256) {\n        return activeAuctions.length;\n    }\n\n    /// @notice Returns the entire array of active auctions\n    /// @return List of active auctions\n    function list() external view override returns (uint256[] memory) {\n        return activeAuctions;\n    }\n\n    /// @notice Externally returns boolean for if an auction needs a redo and also the current price\n    /// @param auctionId Id of the auction to get the status for\n    /// @return needsRedo If the auction needs a redo (max duration or max discount exceeded)\n    /// @return price Current price of the collateral determined by the calculator [wad]\n    /// @return collateralToSell Amount of collateral left to buy for credit [wad]\n    /// @return debt Amount of debt / credit to sell for collateral [wad]\n    function getStatus(uint256 auctionId)\n        external\n        view\n        override\n        returns (\n            bool needsRedo,\n            uint256 price,\n            uint256 collateralToSell,\n            uint256 debt\n        )\n    {\n        Auction memory auction = auctions[auctionId];\n\n        bool done;\n        (done, price) = status(auction);\n\n        needsRedo = auction.user != address(0) && done;\n        collateralToSell = auction.collateralToSell;\n        debt = auction.debt;\n    }\n\n    // Internally returns boolean for if an auction needs a redo\n    function status(Auction memory auction) internal view returns (bool done, uint256 price) {\n        uint256 floorPrice = wdiv(auction.debt, auction.collateralToSell);\n        price = max(\n            floorPrice,\n            vaults[auction.vault].calculator.price(auction.startPrice, sub(block.timestamp, auction.startsAt))\n        );\n        done = (sub(block.timestamp, auction.startsAt) > vaults[auction.vault].maxAuctionDuration ||\n            price == floorPrice);\n    }\n\n    /// @notice Public function to update the cached vault.debtFloor*vault.liquidationPenalty value\n    /// @param vault Address of the Vault for which to update the auctionDebtFloor variable\n    function updateAuctionDebtFloor(address vault) external override {\n        (, , , uint256 _debtFloor) = ICodex(codex).vaults(vault);\n        uint256 auctionDebtFloor = wmul(_debtFloor, limes.liquidationPenalty(vault));\n        vaults[vault].auctionDebtFloor = auctionDebtFloor;\n        emit UpdateAuctionDebtFloor(vault, auctionDebtFloor);\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Cancels an auction during shutdown or via governance action\n    /// @dev Sender has to be allowed to call this method\n    /// @param auctionId Id of the auction to cancel\n    function cancelAuction(uint256 auctionId) external override checkCaller checkReentrancy {\n        if (auctions[auctionId].user == address(0)) revert NoLossCollateralAuction__cancelAuction_notRunningAction();\n        address vault = auctions[auctionId].vault;\n        uint256 tokenId = auctions[auctionId].tokenId;\n        limes.liquidated(vault, tokenId, auctions[auctionId].debt);\n        codex.transferBalance(vault, tokenId, address(this), msg.sender, auctions[auctionId].collateralToSell);\n        _remove(auctionId);\n        emit StopAuction(auctionId);\n    }\n}// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n\n\n\n/// @title LinearDecrease\n/// @notice Implements a linear decreasing price curve for the collateral auction\n/// Uses LinearDecrease.sol from DSS (MakerDAO) as a blueprint\n/// Changes from LinearDecrease.sol /:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract LinearDecrease is Guarded, IPriceCalculator {\n    /// ======== Custom Errors ======== ///\n\n    error LinearDecrease__setParam_unrecognizedParam();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Seconds after auction start when the price reaches zero [seconds]\n    uint256 public duration;\n\n    /// ======== Events ======== ///\n\n    event SetParam(bytes32 indexed param, uint256 data);\n\n    constructor() Guarded() {}\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external checkCaller {\n        if (param == \"duration\") duration = data;\n        else revert LinearDecrease__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== Pricing ======== ///\n\n    /// @notice Price calculation when price is decreased linearly in proportion to time:\n    /// @dev `duration` The number of seconds after the start of the auction where the price will hit 0\n    /// Note the internal call to mul multiples by WAD, thereby ensuring that the wmul calculation\n    /// which utilizes startPrice and duration (WAD values) is also a WAD value.\n    /// @param startPrice: Initial price [wad]\n    /// @param time Current seconds since the start of the auction [seconds]\n    /// @return Returns y = startPrice * ((duration - time) / duration)\n    function price(uint256 startPrice, uint256 time) external view override returns (uint256) {\n        if (time >= duration) return 0;\n        return wmul(startPrice, wdiv(sub(duration, time), duration));\n    }\n}\n\n/// @title StairstepExponentialDecrease\n/// @notice Implements a stairstep like exponential decreasing price curve for the collateral auction\n/// Uses StairstepExponentialDecrease.sol from DSS (MakerDAO) as a blueprint\n/// Changes from StairstepExponentialDecrease.sol /:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract StairstepExponentialDecrease is Guarded, IPriceCalculator {\n    /// ======== Custom Errors ======== ///\n\n    error StairstepExponentialDecrease__setParam_factorGtWad();\n    error StairstepExponentialDecrease__setParam_unrecognizedParam();\n\n    /// ======== Storage ======== ///\n    /// @notice Length of time between price drops [seconds]\n    uint256 public step;\n    /// @notice Per-step multiplicative factor [wad]\n    uint256 public factor;\n\n    /// ======== Events ======== ///\n\n    event SetParam(bytes32 indexed param, uint256 data);\n\n    // `factor` and `step` values must be correctly set for this contract to return a valid price\n    constructor() Guarded() {}\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external checkCaller {\n        if (param == \"factor\") {\n            if (data > WAD) revert StairstepExponentialDecrease__setParam_factorGtWad();\n            factor = data;\n        } else if (param == \"step\") step = data;\n        else revert StairstepExponentialDecrease__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== Pricing ======== ///\n\n    /// @notice Price calculation when price is decreased stairstep like, exponential in proportion to time:\n    /// @dev `step` seconds between a price drop,\n    /// `factor` factor encodes the percentage to decrease per step.\n    ///   For efficiency, the values is set as (1 - (% value / 100)) * WAD\n    ///   So, for a 1% decrease per step, factor would be (1 - 0.01) * WAD\n    /// @param startPrice: Initial price [wad]\n    /// @param time Current seconds since the start of the auction [seconds]\n    /// @return Returns startPrice * (factor ^ time)\n    function price(uint256 startPrice, uint256 time) external view override returns (uint256) {\n        return wmul(startPrice, wpow(factor, time / step, WAD));\n    }\n}\n\n/// @title ExponentialDecrease\n/// @notice Implements a linear decreasing price curve for the collateral auction\n/// While an equivalent function can be obtained by setting step = 1 in StairstepExponentialDecrease,\n/// this continous (i.e. per-second) exponential decrease has be implemented as it is more gas-efficient\n/// than using the stairstep version with step = 1 (primarily due to 1 fewer SLOAD per price calculation).\n///\n/// Uses ExponentialDecrease.sol from DSS (MakerDAO) as a blueprint\n/// Changes from ExponentialDecrease.sol /:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract ExponentialDecrease is Guarded, IPriceCalculator {\n    /// ======== Custom Errors ======== ///\n\n    error ExponentialDecrease__setParam_factorGtWad();\n    error ExponentialDecrease__setParam_unrecognizedParam();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Per-second multiplicative factor [wad]\n    uint256 public factor;\n\n    /// ======== Events ======== ///\n\n    event SetParam(bytes32 indexed param, uint256 data);\n\n    // `factor` value must be correctly set for this contract to return a valid price\n    constructor() Guarded() {}\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external checkCaller {\n        if (param == \"factor\") {\n            if (data > WAD) revert ExponentialDecrease__setParam_factorGtWad();\n            factor = data;\n        } else revert ExponentialDecrease__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== Pricing ======== ///\n\n    /// @notice Price calculation when price is decreased exponentially in proportion to time:\n    /// @dev `factor`: factor encodes the percentage to decrease per second.\n    ///   For efficiency, the values is set as (1 - (% value / 100)) * WAD\n    ///   So, for a 1% decrease per second, factor would be (1 - 0.01) * WAD\n    /// @param startPrice: Initial price [wad]\n    /// @param time Current seconds since the start of the auction [seconds]\n    /// @return Returns startPrice * (factor ^ time)\n    function price(uint256 startPrice, uint256 time) external view override returns (uint256) {\n        return wmul(startPrice, wpow(factor, time, WAD));\n    }\n}\ncontract Delayed {\n    error Delayed__setParam_notDelayed();\n    error Delayed__delay_invalidEta();\n    error Delayed__execute_unknown();\n    error Delayed__execute_stillDelayed();\n    error Delayed__execute_executionError();\n\n    mapping(bytes32 => bool) public queue;\n    uint256 public delay;\n\n    event SetParam(bytes32 param, uint256 data);\n    event Queue(address target, bytes data, uint256 eta);\n    event Unqueue(address target, bytes data, uint256 eta);\n    event Execute(address target, bytes data, uint256 eta);\n\n    constructor(uint256 delay_) {\n        delay = delay_;\n        emit SetParam(\"delay\", delay_);\n    }\n\n    function _setParam(bytes32 param, uint256 data) internal {\n        if (param == \"delay\") delay = data;\n        emit SetParam(param, data);\n    }\n\n    function _delay(\n        address target,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        if (eta < block.timestamp + delay) revert Delayed__delay_invalidEta();\n        queue[keccak256(abi.encode(target, data, eta))] = true;\n        emit Queue(target, data, eta);\n    }\n\n    function _skip(\n        address target,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        queue[keccak256(abi.encode(target, data, eta))] = false;\n        emit Unqueue(target, data, eta);\n    }\n\n    function execute(\n        address target,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes memory out) {\n        bytes32 callHash = keccak256(abi.encode(target, data, eta));\n\n        if (!queue[callHash]) revert Delayed__execute_unknown();\n        if (block.timestamp < eta) revert Delayed__execute_stillDelayed();\n\n        queue[callHash] = false;\n\n        bool ok;\n        (ok, out) = target.call(data);\n        if (!ok) revert Delayed__execute_executionError();\n\n        emit Execute(target, data, eta);\n    }\n}interface IGuard {\n    function isGuard() external view returns (bool);\n}\n\nabstract contract BaseGuard is Delayed, IGuard {\n    /// ======== Custom Errors ======== ///\n\n    error BaseGuard__isSenatus_notSenatus();\n    error BaseGuard__isGuardian_notGuardian();\n    error BaseGuard__isDelayed_notSelf(address, address);\n    error BaseGuard__inRange_notInRange();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Address of the DAO\n    address public immutable senatus;\n    /// @notice Address of the guardian\n    address public guardian;\n\n    constructor(\n        address senatus_,\n        address guardian_,\n        uint256 delay\n    ) Delayed(delay) {\n        senatus = senatus_;\n        guardian = guardian_;\n    }\n\n    modifier isSenatus() {\n        if (msg.sender != senatus) revert BaseGuard__isSenatus_notSenatus();\n        _;\n    }\n\n    modifier isGuardian() {\n        if (msg.sender != guardian) revert BaseGuard__isGuardian_notGuardian();\n        _;\n    }\n\n    modifier isDelayed() {\n        if (msg.sender != address(this)) revert BaseGuard__isDelayed_notSelf(msg.sender, address(this));\n        _;\n    }\n\n    /// @notice Callback method which allows Guard to check if he has sufficient rights over the corresponding contract\n    /// @return bool True if he has sufficient rights\n    function isGuard() external view virtual override returns (bool);\n\n    /// @notice Updates the address of the guardian\n    /// @dev Can only be called by Senatus\n    /// @param guardian_ Address of the new guardian\n    function setGuardian(address guardian_) external isSenatus {\n        guardian = guardian_;\n    }\n\n    /// ======== Capabilities ======== ///\n\n    /// @notice Updates the time which has to elapse for certain parameter updates\n    /// @dev Can only be called by Senatus\n    /// @param delay Time which has to elapse before parameter can be updated [seconds]\n    function setDelay(uint256 delay) external isSenatus {\n        _setParam(\"delay\", delay);\n    }\n\n    /// @notice Schedule method call for methods which have to be delayed\n    /// @dev Can only be called by the guardian\n    /// @param data Call data\n    function schedule(bytes calldata data) external isGuardian {\n        _delay(address(this), data, block.timestamp + delay);\n    }\n\n    /// ======== Helper Methods ======== ///\n\n    /// @notice Checks if `value` is at least equal to `min_` or at most equal to `max`\n    /// @dev Revers if check failed\n    /// @param value Value to check\n    /// @param min_ Min. value for `value`\n    /// @param max Max. value for `value`\n    function _inRange(\n        uint256 value,\n        uint256 min_,\n        uint256 max\n    ) internal pure {\n        if (max < value || value < min_) revert BaseGuard__inRange_notInRange();\n    }\n}\n/// @title AuctionGuard\n/// @notice Contract which guards parameter updates for `CollateralAuction`\ncontract AuctionGuard is BaseGuard {\n    /// ======== Custom Errors ======== ///\n\n    error AuctionGuard__isGuard_cantCall();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Address of CollateralAuction\n    NoLossCollateralAuction public immutable collateralAuction;\n\n    constructor(\n        address senatus,\n        address guardian,\n        uint256 delay,\n        address collateralAuction_\n    ) BaseGuard(senatus, guardian, delay) {\n        collateralAuction = NoLossCollateralAuction(collateralAuction_);\n    }\n\n    function isGuard() external view override returns (bool) {\n        if (!collateralAuction.canCall(collateralAuction.ANY_SIG(), address(this)))\n            revert AuctionGuard__isGuard_cantCall();\n        return true;\n    }\n\n    /// ======== Capabilities ======== ///\n\n    /// @notice Sets the `feeTip` parameter on CollateralAuction\n    /// @dev Can only be called by the guardian. Checks if the value is in the allowed range.\n    /// @param feeTip See. CollateralAuction\n    function setFeeTip(uint256 feeTip) external isGuardian {\n        _inRange(feeTip, 0, 1 * WAD);\n        collateralAuction.setParam(\"feeTip\", feeTip);\n    }\n\n    /// @notice Sets the `flatTip` parameter on CollateralAuction\n    /// @dev Can only be called by the guardian. Checks if the value is in the allowed range.\n    /// @param flatTip See. CollateralAuction\n    function setFlatTip(uint256 flatTip) external isGuardian {\n        _inRange(flatTip, 0, 10_000 * WAD);\n        collateralAuction.setParam(\"flatTip\", flatTip);\n    }\n\n    /// @notice Sets the `level` parameter on CollateralAuction\n    /// @dev Can only be called by the guardian. Checks if the value is in the allowed range.\n    /// @param level See. CollateralAuction\n    function setStopped(uint256 level) external isGuardian {\n        _inRange(level, 0, 3);\n        collateralAuction.setParam(\"stopped\", level);\n    }\n\n    /// @notice Sets the `limes` parameter on CollateralAuction after the `delay` has passed.\n    /// @dev Can only be called by the guardian. After `delay` has passed it can be `execute`'d.\n    /// @param limes See. CollateralAuction\n    function setLimes(address limes) external isDelayed {\n        collateralAuction.setParam(\"limes\", limes);\n    }\n\n    /// @notice Sets the `aer` parameter on CollateralAuction after the `delay` has passed.\n    /// @dev Can only be called by the guardian. After `delay` has passed it can be `execute`'d.\n    /// @param aer See. CollateralAuction\n    function setAer(address aer) external isDelayed {\n        collateralAuction.setParam(\"aer\", aer);\n    }\n\n    /// @notice Sets the `multiplier` parameter on CollateralAuction\n    /// @dev Can only be called by the guardian. Checks if the value is in the allowed range.\n    /// @param multiplier See. CollateralAuction\n    function setMultiplier(address vault, uint256 multiplier) external isGuardian {\n        _inRange(multiplier, 0.9e18, 2 * WAD);\n        collateralAuction.setParam(vault, \"multiplier\", multiplier);\n    }\n\n    /// @notice Sets the `maxAuctionDuration` parameter on CollateralAuction and updates the `duration`\n    /// on corresponding PriceCalculator\n    /// @dev Can only be called by the guardian. Checks if the value is in the allowed range.\n    /// @param maxAuctionDuration See. CollateralAuction\n    function setMaxAuctionDuration(address vault, uint256 maxAuctionDuration) external isGuardian {\n        _inRange(maxAuctionDuration, 3 hours, 5 days);\n        collateralAuction.setParam(vault, \"maxAuctionDuration\", maxAuctionDuration);\n        (, , , , IPriceCalculator calculator) = collateralAuction.vaults(vault);\n        LinearDecrease(address(calculator)).setParam(\"duration\", maxAuctionDuration);\n    }\n\n    /// @notice Sets the `collybus` parameter on CollateralAuction after the `delay` has passed.\n    /// @dev Can only be called by the guardian. After `delay` has passed it can be `execute`'d.\n    /// @param vault Address of the vault for which to set the parameter\n    /// @param collybus See. CollateralAuction\n    function setCollybus(address vault, address collybus) external isDelayed {\n        collateralAuction.setParam(vault, \"collybus\", collybus);\n    }\n\n    /// @notice Sets the `calculator` parameter on CollateralAuction after the `delay` has passed.\n    /// @dev Can only be called by the guardian. After `delay` has passed it can be `execute`'d.\n    /// @param vault Address of the vault for which to set the parameter\n    /// @param calculator See. CollateralAuction\n    function setCalculator(address vault, address calculator) external isDelayed {\n        collateralAuction.setParam(vault, \"calculator\", calculator);\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"senatus\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralAuction_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AuctionGuard__isGuard_cantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseGuard__inRange_notInRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"BaseGuard__isDelayed_notSelf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseGuard__isGuardian_notGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseGuard__isSenatus_notSenatus\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Delayed__delay_invalidEta\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Delayed__execute_executionError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Delayed__execute_stillDelayed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Delayed__execute_unknown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Delayed__setParam_notDelayed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"Execute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"Queue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"param\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"SetParam\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"Unqueue\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"collateralAuction\",\"outputs\":[{\"internalType\":\"contract NoLossCollateralAuction\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"out\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGuard\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"queue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"schedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"senatus\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aer\",\"type\":\"address\"}],\"name\":\"setAer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"calculator\",\"type\":\"address\"}],\"name\":\"setCalculator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collybus\",\"type\":\"address\"}],\"name\":\"setCollybus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"setDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feeTip\",\"type\":\"uint256\"}],\"name\":\"setFeeTip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"flatTip\",\"type\":\"uint256\"}],\"name\":\"setFlatTip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guardian_\",\"type\":\"address\"}],\"name\":\"setGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"limes\",\"type\":\"address\"}],\"name\":\"setLimes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAuctionDuration\",\"type\":\"uint256\"}],\"name\":\"setMaxAuctionDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"name\":\"setMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"setStopped\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AuctionGuard", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "8000", "ConstructorArguments": "000000000000000000000000a55e0d3d697c4692e9c37bc3a7062b1beceef45b000000000000000000000000245bd99c7379df6740332d06530da7dedb062d61000000000000000000000000000000000000000000000000000000000002a300000000000000000000000000a50d5b25e29a8fa7e94da10698fe5100f0eb0cc5", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}