{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/base/governance/Bookkeeper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\nimport \\\"./ControllableV2.sol\\\";\\r\\nimport \\\"../interface/IBookkeeper.sol\\\";\\r\\nimport \\\"../interface/ISmartVault.sol\\\";\\r\\nimport \\\"../interface/IStrategy.sol\\\";\\r\\nimport \\\"../interface/IStrategySplitter.sol\\\";\\r\\n\\r\\n/// @title Contract for holding statistical info and doesn't affect any funds.\\r\\n/// @dev Only non critical functions. Use with TetuProxy\\r\\n/// @author belbix\\r\\ncontract Bookkeeper is IBookkeeper, Initializable, ControllableV2 {\\r\\n\\r\\n  /// @notice Version of the contract\\r\\n  /// @dev Should be incremented when contract is changed\\r\\n  string public constant VERSION = \\\"1.2.0\\\";\\r\\n\\r\\n  // DO NOT CHANGE NAMES OR ORDERING!\\r\\n  /// @dev Add when Controller register vault\\r\\n  address[] public _vaults;\\r\\n  /// @dev Add when Controller register strategy\\r\\n  address[] public _strategies;\\r\\n  /// @inheritdoc IBookkeeper\\r\\n  mapping(address => uint256) public override targetTokenEarned;\\r\\n  mapping(address => HardWork) private _lastHardWork;\\r\\n  /// @inheritdoc IBookkeeper\\r\\n  mapping(address => mapping(address => uint256)) public override vaultUsersBalances;\\r\\n  /// @inheritdoc IBookkeeper\\r\\n  mapping(address => mapping(address => mapping(address => uint256))) public override userEarned;\\r\\n  /// @inheritdoc IBookkeeper\\r\\n  mapping(address => uint256) public override vaultUsersQuantity;\\r\\n  /// @dev Hold last price per full share change for a given user\\r\\n  mapping(address => PpfsChange) private _lastPpfsChange;\\r\\n  /// @dev Stored any FundKeeper earnings by tokens\\r\\n  mapping(address => uint256) public override fundKeeperEarned;\\r\\n  /// @dev Hold reward notified amounts for vaults\\r\\n  mapping(address => mapping(address => uint256[])) public override vaultRewards;\\r\\n  /// @dev Length of vault rewards arrays\\r\\n  mapping(address => mapping(address => uint256)) public override vaultRewardsLength;\\r\\n  /// @dev Strategy earned values stored per each reward notification\\r\\n  mapping(address => uint256[]) public override strategyEarnedSnapshots;\\r\\n  /// @dev Timestamp when snapshot created. Has the same length as strategy snapshots\\r\\n  mapping(address => uint256[]) public override strategyEarnedSnapshotsTime;\\r\\n  /// @dev Snapshot lengths\\r\\n  mapping(address => uint256) public override strategyEarnedSnapshotsLength;\\r\\n\\r\\n  /// @notice Vault added\\r\\n  event RegisterVault(address value);\\r\\n  /// @notice Vault removed\\r\\n  event RemoveVault(address value);\\r\\n  /// @notice Strategy added\\r\\n  event RegisterStrategy(address value);\\r\\n  /// @notice Strategy removed\\r\\n  event RemoveStrategy(address value);\\r\\n  /// @notice Strategy earned this TETU amount during doHardWork call\\r\\n  event RegisterStrategyEarned(address indexed strategy, uint256 amount);\\r\\n  /// @notice FundKeeper earned this USDC amount during doHardWork call\\r\\n  event RegisterFundKeeperEarned(address indexed token, uint256 amount);\\r\\n  /// @notice User deposit/withdraw action\\r\\n  event RegisterUserAction(address indexed user, uint256 amount, bool deposit);\\r\\n  /// @notice User claim reward\\r\\n  event RegisterUserEarned(address indexed user, address vault, address token, uint256 amount);\\r\\n  /// @notice Vault's PricePer Full Share changed\\r\\n  event RegisterPpfsChange(address indexed vault, uint256 oldValue, uint256 newValue);\\r\\n  /// @notice Reward distribution registered\\r\\n  event RewardDistribution(address indexed vault, address token, uint256 amount, uint256 time);\\r\\n\\r\\n  /// @notice Initialize contract after setup it as proxy implementation\\r\\n  /// @dev Use it only once after first logic setup\\r\\n  /// @param _controller Controller address\\r\\n  function initialize(address _controller) external initializer {\\r\\n    ControllableV2.initializeControllable(_controller);\\r\\n  }\\r\\n\\r\\n  /// @dev Only registered strategy allowed\\r\\n  modifier onlyStrategy() {\\r\\n    require(IController(_controller()).strategies(msg.sender), \\\"B: Only exist strategy\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /// @dev Allow operation only for Controller\\r\\n  modifier onlyController() {\\r\\n    require(_controller() == msg.sender, \\\"B: Not controller\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n\\r\\n  /// @dev Allow operation only for Controller or Governance\\r\\n  modifier onlyControllerOrGovernance() {\\r\\n    require(_isController(msg.sender) || _isGovernance(msg.sender), \\\"B: Not controller or gov\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /// @dev Only FeeRewardForwarder contract allowed\\r\\n  modifier onlyFeeRewardForwarderOrStrategy() {\\r\\n    require(IController(_controller()).feeRewardForwarder() == msg.sender\\r\\n      || IController(_controller()).strategies(msg.sender), \\\"B: Only exist forwarder or strategy\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /// @dev Only registered vault allowed\\r\\n  modifier onlyVault() {\\r\\n    require(IController(_controller()).vaults(msg.sender), \\\"B: Only exist vault\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /// @notice Add Vault if it doesn't exist. Only Controller sender allowed\\r\\n  /// @param _vault Vault address\\r\\n  function addVault(address _vault) public override onlyController {\\r\\n    require(isVaultExist(_vault), \\\"B: Vault is not registered in controller\\\");\\r\\n    _vaults.push(_vault);\\r\\n    emit RegisterVault(_vault);\\r\\n  }\\r\\n\\r\\n  /// @notice Add Strategy if it doesn't exist. Only Controller sender allowed\\r\\n  /// @param _strategy Strategy address\\r\\n  function addStrategy(address _strategy) public override onlyController {\\r\\n    require(isStrategyExist(_strategy), \\\"B: Strategy is not registered in controller\\\");\\r\\n    _strategies.push(_strategy);\\r\\n    emit RegisterStrategy(_strategy);\\r\\n  }\\r\\n\\r\\n  /// @notice Only Strategy action. Save TETU earned values\\r\\n  /// @dev It should represent 100% of earned rewards including all fees.\\r\\n  /// @param _targetTokenAmount Earned amount\\r\\n  function registerStrategyEarned(uint256 _targetTokenAmount) external override onlyStrategy {\\r\\n    targetTokenEarned[msg.sender] = targetTokenEarned[msg.sender] + _targetTokenAmount;\\r\\n\\r\\n    _lastHardWork[msg.sender] = HardWork(\\r\\n      msg.sender,\\r\\n      block.number,\\r\\n      block.timestamp,\\r\\n      _targetTokenAmount\\r\\n    );\\r\\n    emit RegisterStrategyEarned(msg.sender, _targetTokenAmount);\\r\\n  }\\r\\n\\r\\n  /// @notice Only FeeRewardForwarder action. Save Fund Token earned value for given token\\r\\n  /// @param _fundTokenAmount Earned amount\\r\\n  function registerFundKeeperEarned(address _token, uint256 _fundTokenAmount) external override onlyFeeRewardForwarderOrStrategy {\\r\\n    fundKeeperEarned[_token] = fundKeeperEarned[_token] + _fundTokenAmount;\\r\\n    emit RegisterFundKeeperEarned(_token, _fundTokenAmount);\\r\\n  }\\r\\n\\r\\n  /// ---------DEPRECATED----------------\\r\\n  /// @notice FeeRewardForwarder action.\\r\\n  ///         Register Price Per Full Share change for given vault\\r\\n  /// @param vault Vault address\\r\\n  /// @param value Price Per Full Share change\\r\\n  function registerPpfsChange(address vault, uint256 value)\\r\\n  external override onlyFeeRewardForwarderOrStrategy {\\r\\n    PpfsChange memory lastPpfs = _lastPpfsChange[vault];\\r\\n    _lastPpfsChange[vault] = PpfsChange(\\r\\n      vault,\\r\\n      block.number,\\r\\n      block.timestamp,\\r\\n      value,\\r\\n      lastPpfs.block,\\r\\n      lastPpfs.time,\\r\\n      lastPpfs.value\\r\\n    );\\r\\n    emit RegisterPpfsChange(vault, lastPpfs.value, value);\\r\\n  }\\r\\n\\r\\n  /// @notice Vault action.\\r\\n  ///         Register reward distribution\\r\\n  /// @param vault Vault address\\r\\n  /// @param rewardToken Reward token address\\r\\n  /// @param amount Reward amount\\r\\n  function registerRewardDistribution(address vault, address rewardToken, uint256 amount)\\r\\n  external override onlyVault {\\r\\n    vaultRewards[vault][rewardToken].push(amount);\\r\\n    vaultRewardsLength[vault][rewardToken] = vaultRewards[vault][rewardToken].length;\\r\\n\\r\\n    address strategy = ISmartVault(vault).strategy();\\r\\n    if (IStrategy(strategy).platform() == IStrategy.Platform.STRATEGY_SPLITTER) {\\r\\n      address[] memory subStrategies = IStrategySplitter(strategy).allStrategies();\\r\\n      for (uint i; i < subStrategies.length; i++) {\\r\\n        address subStrategy = subStrategies[i];\\r\\n\\r\\n        uint currentEarned = targetTokenEarned[subStrategy];\\r\\n        uint currentLength = strategyEarnedSnapshotsLength[subStrategy];\\r\\n        if (currentLength > 0) {\\r\\n          uint prevEarned = strategyEarnedSnapshots[subStrategy][currentLength - 1];\\r\\n          if (currentEarned == prevEarned) {\\r\\n            // don't write zero values\\r\\n            continue;\\r\\n          }\\r\\n        }\\r\\n\\r\\n        strategyEarnedSnapshots[subStrategy].push(currentEarned);\\r\\n        strategyEarnedSnapshotsTime[subStrategy].push(block.timestamp);\\r\\n        strategyEarnedSnapshotsLength[subStrategy] = strategyEarnedSnapshots[subStrategy].length;\\r\\n      }\\r\\n    } else {\\r\\n      uint currentEarned = targetTokenEarned[strategy];\\r\\n      uint currentLength = strategyEarnedSnapshotsLength[strategy];\\r\\n      if (currentLength > 0) {\\r\\n        uint prevEarned = strategyEarnedSnapshots[strategy][currentLength - 1];\\r\\n        // don't write zero values\\r\\n        if (currentEarned != prevEarned) {\\r\\n          strategyEarnedSnapshots[strategy].push(currentEarned);\\r\\n          strategyEarnedSnapshotsTime[strategy].push(block.timestamp);\\r\\n          strategyEarnedSnapshotsLength[strategy] = strategyEarnedSnapshots[strategy].length;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    emit RewardDistribution(vault, rewardToken, amount, block.timestamp);\\r\\n  }\\r\\n\\r\\n  /// @notice Vault action. Register user's deposit/withdraw\\r\\n  /// @dev Should register any mint/burn of the share token\\r\\n  /// @param _user User address\\r\\n  /// @param _amount Share amount for deposit/withdraw\\r\\n  /// @param _deposit true = deposit, false = withdraw\\r\\n  function registerUserAction(address _user, uint256 _amount, bool _deposit)\\r\\n  external override onlyVault {\\r\\n    if (vaultUsersBalances[msg.sender][_user] == 0) {\\r\\n      vaultUsersQuantity[msg.sender] = vaultUsersQuantity[msg.sender] + 1;\\r\\n    }\\r\\n    if (_deposit) {\\r\\n      vaultUsersBalances[msg.sender][_user] = vaultUsersBalances[msg.sender][_user] + _amount;\\r\\n    } else {\\r\\n      // avoid overflow if we missed something\\r\\n      // in this unreal case better do nothing\\r\\n      if (vaultUsersBalances[msg.sender][_user] >= _amount) {\\r\\n        vaultUsersBalances[msg.sender][_user] = vaultUsersBalances[msg.sender][_user] - _amount;\\r\\n      }\\r\\n    }\\r\\n    if (vaultUsersBalances[msg.sender][_user] == 0) {\\r\\n      vaultUsersQuantity[msg.sender] = vaultUsersQuantity[msg.sender] - 1;\\r\\n    }\\r\\n    emit RegisterUserAction(_user, _amount, _deposit);\\r\\n  }\\r\\n\\r\\n  /// @notice Vault action. Register any share token transfer.\\r\\n  ///         Burn/mint ignored - should be handled in registerUserAction()\\r\\n  /// @param from Sender address\\r\\n  /// @param to Recipient address\\r\\n  /// @param amount Transaction amount\\r\\n  function registerVaultTransfer(address from, address to, uint256 amount) external override onlyVault {\\r\\n    // in this unreal cases better to do nothing\\r\\n    if (vaultUsersBalances[msg.sender][from] < amount || amount == 0) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // don't count mint and burn - it should be covered in registerUserAction\\r\\n    if (from == address(0) || to == address(0)) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // decrease sender balance\\r\\n    vaultUsersBalances[msg.sender][from] = vaultUsersBalances[msg.sender][from] - amount;\\r\\n\\r\\n    // if recipient didn't have balance - increase user quantity\\r\\n    if (vaultUsersBalances[msg.sender][to] == 0) {\\r\\n      vaultUsersQuantity[msg.sender] = vaultUsersQuantity[msg.sender] + 1;\\r\\n    }\\r\\n    // increase recipient balance\\r\\n    vaultUsersBalances[msg.sender][to] = vaultUsersBalances[msg.sender][to] + amount;\\r\\n\\r\\n    // if sender sent all amount decrease user quantity\\r\\n    if (vaultUsersBalances[msg.sender][from] == 0) {\\r\\n      vaultUsersQuantity[msg.sender] = vaultUsersQuantity[msg.sender] - 1;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Only Vault can call it. Register user's claimed amount of given token\\r\\n  /// @param _user User address\\r\\n  /// @param _vault Vault address\\r\\n  /// @param _rt Reward Token address\\r\\n  /// @param _amount Claimed amount\\r\\n  function registerUserEarned(address _user, address _vault, address _rt, uint256 _amount)\\r\\n  external override onlyVault {\\r\\n    userEarned[_user][_vault][_rt] = userEarned[_user][_vault][_rt] + _amount;\\r\\n    emit RegisterUserEarned(_user, _vault, _rt, _amount);\\r\\n  }\\r\\n\\r\\n  /// @notice Return vaults array\\r\\n  /// @dev This function should not be use in any critical logics because DoS possible\\r\\n  /// @return Array of all registered vaults\\r\\n  function vaults() external override view returns (address[] memory) {\\r\\n    return _vaults;\\r\\n  }\\r\\n\\r\\n  /// @notice Return vaults array length\\r\\n  /// @return Length of Array of all registered vaults\\r\\n  function vaultsLength() external override view returns (uint256) {\\r\\n    return _vaults.length;\\r\\n  }\\r\\n\\r\\n  /// @notice Return strategy array\\r\\n  /// @dev This function should not be use in any critical logics because DoS possible\\r\\n  /// @return Array of all registered strategies\\r\\n  function strategies() external override view returns (address[] memory) {\\r\\n    return _strategies;\\r\\n  }\\r\\n\\r\\n  /// @notice Return strategies array length\\r\\n  /// @return Length of Array of all registered strategies\\r\\n  function strategiesLength() external override view returns (uint256) {\\r\\n    return _strategies.length;\\r\\n  }\\r\\n\\r\\n  /// @notice Return info about last doHardWork call for given vault\\r\\n  /// @param strategy Strategy address\\r\\n  /// @return HardWork struct with result\\r\\n  function lastHardWork(address strategy) external view override returns (HardWork memory) {\\r\\n    return _lastHardWork[strategy];\\r\\n  }\\r\\n\\r\\n  /// @notice Return info about last PricePerFullShare change for given vault\\r\\n  /// @param vault Vault address\\r\\n  /// @return PpfsChange struct with result\\r\\n  function lastPpfsChange(address vault) external view override returns (PpfsChange memory) {\\r\\n    return _lastPpfsChange[vault];\\r\\n  }\\r\\n\\r\\n  /// @notice Return true for registered Vault\\r\\n  /// @param _value Vault address\\r\\n  /// @return true if Vault registered\\r\\n  function isVaultExist(address _value) internal view returns (bool) {\\r\\n    return IController(_controller()).isValidVault(_value);\\r\\n  }\\r\\n\\r\\n  /// @notice Return true for registered Strategy\\r\\n  /// @param _value Strategy address\\r\\n  /// @return true if Strategy registered\\r\\n  function isStrategyExist(address _value) internal view returns (bool) {\\r\\n    return IController(_controller()).isValidStrategy(_value);\\r\\n  }\\r\\n\\r\\n  /// @notice Governance action. Remove given Vault from vaults array\\r\\n  /// @param index Index of vault in the vault array\\r\\n  function removeFromVaults(uint256 index) external onlyControllerOrGovernance {\\r\\n    require(index < _vaults.length, \\\"B: Wrong index\\\");\\r\\n    emit RemoveVault(_vaults[index]);\\r\\n    _vaults[index] = _vaults[_vaults.length - 1];\\r\\n    _vaults.pop();\\r\\n  }\\r\\n\\r\\n  /// @notice Governance action. Remove given Strategy from strategies array\\r\\n  /// @param index Index of strategy in the strategies array\\r\\n  function removeFromStrategies(uint256 index) external onlyControllerOrGovernance {\\r\\n    require(index < _strategies.length, \\\"B: Wrong index\\\");\\r\\n    emit RemoveStrategy(_strategies[index]);\\r\\n    _strategies[index] = _strategies[_strategies.length - 1];\\r\\n    _strategies.pop();\\r\\n  }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/base/governance/ControllableV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\nimport \\\"../../openzeppelin/Initializable.sol\\\";\\r\\nimport \\\"../interface/IControllable.sol\\\";\\r\\nimport \\\"../interface/IControllableExtended.sol\\\";\\r\\nimport \\\"../interface/IController.sol\\\";\\r\\n\\r\\n/// @title Implement basic functionality for any contract that require strict control\\r\\n///        V2 is optimised version for less gas consumption\\r\\n/// @dev Can be used with upgradeable pattern.\\r\\n///      Require call initializeControllable() in any case.\\r\\n/// @author belbix\\r\\nabstract contract ControllableV2 is Initializable, IControllable, IControllableExtended {\\r\\n\\r\\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.controller\\\")) - 1);\\r\\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created\\\")) - 1);\\r\\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created_block\\\")) - 1);\\r\\n\\r\\n  event ContractInitialized(address controller, uint ts, uint block);\\r\\n\\r\\n  /// @notice Initialize contract after setup it as proxy implementation\\r\\n  ///         Save block.timestamp in the \\\"created\\\" variable\\r\\n  /// @dev Use it only once after first logic setup\\r\\n  /// @param __controller Controller address\\r\\n  function initializeControllable(address __controller) public initializer {\\r\\n    _setController(__controller);\\r\\n    _setCreated(block.timestamp);\\r\\n    _setCreatedBlock(block.number);\\r\\n    emit ContractInitialized(__controller, block.timestamp, block.number);\\r\\n  }\\r\\n\\r\\n  /// @dev Return true if given address is controller\\r\\n  function isController(address _value) external override view returns (bool) {\\r\\n    return _isController(_value);\\r\\n  }\\r\\n\\r\\n  function _isController(address _value) internal view returns (bool) {\\r\\n    return _value == _controller();\\r\\n  }\\r\\n\\r\\n  /// @notice Return true if given address is setup as governance in Controller\\r\\n  function isGovernance(address _value) external override view returns (bool) {\\r\\n    return _isGovernance(_value);\\r\\n  }\\r\\n\\r\\n  function _isGovernance(address _value) internal view returns (bool) {\\r\\n    return IController(_controller()).governance() == _value;\\r\\n  }\\r\\n\\r\\n  // ************* SETTERS/GETTERS *******************\\r\\n\\r\\n  /// @notice Return controller address saved in the contract slot\\r\\n  function controller() external view override returns (address) {\\r\\n    return _controller();\\r\\n  }\\r\\n\\r\\n  function _controller() internal view returns (address result) {\\r\\n    bytes32 slot = _CONTROLLER_SLOT;\\r\\n    assembly {\\r\\n      result := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev Set a controller address to contract slot\\r\\n  function _setController(address _newController) private {\\r\\n    require(_newController != address(0));\\r\\n    bytes32 slot = _CONTROLLER_SLOT;\\r\\n    assembly {\\r\\n      sstore(slot, _newController)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Return creation timestamp\\r\\n  /// @return ts Creation timestamp\\r\\n  function created() external view override returns (uint256 ts) {\\r\\n    bytes32 slot = _CREATED_SLOT;\\r\\n    assembly {\\r\\n      ts := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev Filled only once when contract initialized\\r\\n  /// @param _value block.timestamp\\r\\n  function _setCreated(uint256 _value) private {\\r\\n    bytes32 slot = _CREATED_SLOT;\\r\\n    assembly {\\r\\n      sstore(slot, _value)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Return creation block number\\r\\n  /// @return ts Creation block number\\r\\n  function createdBlock() external view returns (uint256 ts) {\\r\\n    bytes32 slot = _CREATED_BLOCK_SLOT;\\r\\n    assembly {\\r\\n      ts := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev Filled only once when contract initialized\\r\\n  /// @param _value block.number\\r\\n  function _setCreatedBlock(uint256 _value) private {\\r\\n    bytes32 slot = _CREATED_BLOCK_SLOT;\\r\\n    assembly {\\r\\n      sstore(slot, _value)\\r\\n    }\\r\\n  }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/base/interface/IBookkeeper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\ninterface IBookkeeper {\\r\\n\\r\\n  struct PpfsChange {\\r\\n    address vault;\\r\\n    uint256 block;\\r\\n    uint256 time;\\r\\n    uint256 value;\\r\\n    uint256 oldBlock;\\r\\n    uint256 oldTime;\\r\\n    uint256 oldValue;\\r\\n  }\\r\\n\\r\\n  struct HardWork {\\r\\n    address strategy;\\r\\n    uint256 block;\\r\\n    uint256 time;\\r\\n    uint256 targetTokenAmount;\\r\\n  }\\r\\n\\r\\n  function addVault(address _vault) external;\\r\\n\\r\\n  function addStrategy(address _strategy) external;\\r\\n\\r\\n  function registerStrategyEarned(uint256 _targetTokenAmount) external;\\r\\n\\r\\n  function registerFundKeeperEarned(address _token, uint256 _fundTokenAmount) external;\\r\\n\\r\\n  function registerUserAction(address _user, uint256 _amount, bool _deposit) external;\\r\\n\\r\\n  function registerVaultTransfer(address from, address to, uint256 amount) external;\\r\\n\\r\\n  function registerUserEarned(address _user, address _vault, address _rt, uint256 _amount) external;\\r\\n\\r\\n  function registerPpfsChange(address vault, uint256 value) external;\\r\\n\\r\\n  function registerRewardDistribution(address vault, address token, uint256 amount) external;\\r\\n\\r\\n  function vaults() external view returns (address[] memory);\\r\\n\\r\\n  function vaultsLength() external view returns (uint256);\\r\\n\\r\\n  function strategies() external view returns (address[] memory);\\r\\n\\r\\n  function strategiesLength() external view returns (uint256);\\r\\n\\r\\n  function lastPpfsChange(address vault) external view returns (PpfsChange memory);\\r\\n\\r\\n  /// @notice Return total earned TETU tokens for strategy\\r\\n  /// @dev Should be incremented after strategy rewards distribution\\r\\n  /// @param strategy Strategy address\\r\\n  /// @return Earned TETU tokens\\r\\n  function targetTokenEarned(address strategy) external view returns (uint256);\\r\\n\\r\\n  /// @notice Return share(xToken) balance of given user\\r\\n  /// @dev Should be calculated for each xToken transfer\\r\\n  /// @param vault Vault address\\r\\n  /// @param user User address\\r\\n  /// @return User share (xToken) balance\\r\\n  function vaultUsersBalances(address vault, address user) external view returns (uint256);\\r\\n\\r\\n  /// @notice Return earned token amount for given token and user\\r\\n  /// @dev Fills when user claim rewards\\r\\n  /// @param user User address\\r\\n  /// @param vault Vault address\\r\\n  /// @param token Token address\\r\\n  /// @return User's earned tokens amount\\r\\n  function userEarned(address user, address vault, address token) external view returns (uint256);\\r\\n\\r\\n  function lastHardWork(address vault) external view returns (HardWork memory);\\r\\n\\r\\n  /// @notice Return users quantity for given Vault\\r\\n  /// @dev Calculation based in Bookkeeper user balances\\r\\n  /// @param vault Vault address\\r\\n  /// @return Users quantity\\r\\n  function vaultUsersQuantity(address vault) external view returns (uint256);\\r\\n\\r\\n  function fundKeeperEarned(address vault) external view returns (uint256);\\r\\n\\r\\n  function vaultRewards(address vault, address token, uint256 idx) external view returns (uint256);\\r\\n\\r\\n  function vaultRewardsLength(address vault, address token) external view returns (uint256);\\r\\n\\r\\n  function strategyEarnedSnapshots(address strategy, uint256 idx) external view returns (uint256);\\r\\n\\r\\n  function strategyEarnedSnapshotsTime(address strategy, uint256 idx) external view returns (uint256);\\r\\n\\r\\n  function strategyEarnedSnapshotsLength(address strategy) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/base/interface/ISmartVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\ninterface ISmartVault {\\r\\n\\r\\n  function setStrategy(address _strategy) external;\\r\\n\\r\\n  function changeActivityStatus(bool _active) external;\\r\\n\\r\\n  function changeProtectionMode(bool _active) external;\\r\\n\\r\\n  function changePpfsDecreaseAllowed(bool _value) external;\\r\\n\\r\\n  function setLockPeriod(uint256 _value) external;\\r\\n\\r\\n  function setLockPenalty(uint256 _value) external;\\r\\n\\r\\n  function setToInvest(uint256 _value) external;\\r\\n\\r\\n  function doHardWork() external;\\r\\n\\r\\n  function rebalance() external;\\r\\n\\r\\n  function disableLock() external;\\r\\n\\r\\n  function notifyTargetRewardAmount(address _rewardToken, uint256 reward) external;\\r\\n\\r\\n  function notifyRewardWithoutPeriodChange(address _rewardToken, uint256 reward) external;\\r\\n\\r\\n  function deposit(uint256 amount) external;\\r\\n\\r\\n  function depositAndInvest(uint256 amount) external;\\r\\n\\r\\n  function depositFor(uint256 amount, address holder) external;\\r\\n\\r\\n  function withdraw(uint256 numberOfShares) external;\\r\\n\\r\\n  function exit() external;\\r\\n\\r\\n  function getAllRewards() external;\\r\\n\\r\\n  function getReward(address rt) external;\\r\\n\\r\\n  function underlying() external view returns (address);\\r\\n\\r\\n  function strategy() external view returns (address);\\r\\n\\r\\n  function getRewardTokenIndex(address rt) external view returns (uint256);\\r\\n\\r\\n  function getPricePerFullShare() external view returns (uint256);\\r\\n\\r\\n  function underlyingUnit() external view returns (uint256);\\r\\n\\r\\n  function duration() external view returns (uint256);\\r\\n\\r\\n  function underlyingBalanceInVault() external view returns (uint256);\\r\\n\\r\\n  function underlyingBalanceWithInvestment() external view returns (uint256);\\r\\n\\r\\n  function underlyingBalanceWithInvestmentForHolder(address holder) external view returns (uint256);\\r\\n\\r\\n  function availableToInvestOut() external view returns (uint256);\\r\\n\\r\\n  function earned(address rt, address account) external view returns (uint256);\\r\\n\\r\\n  function earnedWithBoost(address rt, address account) external view returns (uint256);\\r\\n\\r\\n  function rewardPerToken(address rt) external view returns (uint256);\\r\\n\\r\\n  function lastTimeRewardApplicable(address rt) external view returns (uint256);\\r\\n\\r\\n  function rewardTokensLength() external view returns (uint256);\\r\\n\\r\\n  function active() external view returns (bool);\\r\\n\\r\\n  function rewardTokens() external view returns (address[] memory);\\r\\n\\r\\n  function periodFinishForToken(address _rt) external view returns (uint256);\\r\\n\\r\\n  function rewardRateForToken(address _rt) external view returns (uint256);\\r\\n\\r\\n  function lastUpdateTimeForToken(address _rt) external view returns (uint256);\\r\\n\\r\\n  function rewardPerTokenStoredForToken(address _rt) external view returns (uint256);\\r\\n\\r\\n  function userRewardPerTokenPaidForToken(address _rt, address account) external view returns (uint256);\\r\\n\\r\\n  function rewardsForToken(address _rt, address account) external view returns (uint256);\\r\\n\\r\\n  function userLastWithdrawTs(address _user) external view returns (uint256);\\r\\n\\r\\n  function userLastDepositTs(address _user) external view returns (uint256);\\r\\n\\r\\n  function userBoostTs(address _user) external view returns (uint256);\\r\\n\\r\\n  function userLockTs(address _user) external view returns (uint256);\\r\\n\\r\\n  function addRewardToken(address rt) external;\\r\\n\\r\\n  function removeRewardToken(address rt) external;\\r\\n\\r\\n  function stop() external;\\r\\n\\r\\n  function ppfsDecreaseAllowed() external view returns (bool);\\r\\n\\r\\n  function lockPeriod() external view returns (uint256);\\r\\n\\r\\n  function lockPenalty() external view returns (uint256);\\r\\n\\r\\n  function toInvest() external view returns (uint256);\\r\\n\\r\\n  function depositFeeNumerator() external view returns (uint256);\\r\\n\\r\\n  function lockAllowed() external view returns (bool);\\r\\n\\r\\n  function protectionMode() external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/base/interface/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\ninterface IStrategy {\\r\\n\\r\\n  enum Platform {\\r\\n    UNKNOWN, // 0\\r\\n    TETU, // 1\\r\\n    QUICK, // 2\\r\\n    SUSHI, // 3\\r\\n    WAULT, // 4\\r\\n    IRON, // 5\\r\\n    COSMIC, // 6\\r\\n    CURVE, // 7\\r\\n    DINO, // 8\\r\\n    IRON_LEND, // 9\\r\\n    HERMES, // 10\\r\\n    CAFE, // 11\\r\\n    TETU_SWAP, // 12\\r\\n    SPOOKY, // 13\\r\\n    AAVE_LEND, //14\\r\\n    AAVE_MAI_BAL, // 15\\r\\n    GEIST, //16\\r\\n    HARVEST, //17\\r\\n    SCREAM_LEND, //18\\r\\n    KLIMA, //19\\r\\n    VESQ, //20\\r\\n    QIDAO, //21\\r\\n    SUNFLOWER, //22\\r\\n    NACHO, //23\\r\\n    STRATEGY_SPLITTER, //24\\r\\n    TOMB, //25\\r\\n    TAROT, //26\\r\\n    BEETHOVEN, //27\\r\\n    IMPERMAX, //28\\r\\n    TETU_SF, //29\\r\\n    ALPACA, //30\\r\\n    MARKET, //31\\r\\n    UNIVERSE, //32\\r\\n    MAI_BAL, //33\\r\\n    UMA, //34\\r\\n    SPHERE, //35\\r\\n    BALANCER, //36\\r\\n    SLOT_37, //37\\r\\n    SLOT_38, //38\\r\\n    SLOT_39, //39\\r\\n    SLOT_40, //40\\r\\n    SLOT_41, //41\\r\\n    SLOT_42, //42\\r\\n    SLOT_43, //43\\r\\n    SLOT_44, //44\\r\\n    SLOT_45, //45\\r\\n    SLOT_46, //46\\r\\n    SLOT_47, //47\\r\\n    SLOT_48, //48\\r\\n    SLOT_49, //49\\r\\n    SLOT_50 //50\\r\\n  }\\r\\n\\r\\n  // *************** GOVERNANCE ACTIONS **************\\r\\n  function STRATEGY_NAME() external view returns (string memory);\\r\\n\\r\\n  function withdrawAllToVault() external;\\r\\n\\r\\n  function withdrawToVault(uint256 amount) external;\\r\\n\\r\\n  function salvage(address recipient, address token, uint256 amount) external;\\r\\n\\r\\n  function doHardWork() external;\\r\\n\\r\\n  function investAllUnderlying() external;\\r\\n\\r\\n  function emergencyExit() external;\\r\\n\\r\\n  function pauseInvesting() external;\\r\\n\\r\\n  function continueInvesting() external;\\r\\n\\r\\n  // **************** VIEWS ***************\\r\\n  function rewardTokens() external view returns (address[] memory);\\r\\n\\r\\n  function underlying() external view returns (address);\\r\\n\\r\\n  function underlyingBalance() external view returns (uint256);\\r\\n\\r\\n  function rewardPoolBalance() external view returns (uint256);\\r\\n\\r\\n  function buyBackRatio() external view returns (uint256);\\r\\n\\r\\n  function unsalvageableTokens(address token) external view returns (bool);\\r\\n\\r\\n  function vault() external view returns (address);\\r\\n\\r\\n  function investedUnderlyingBalance() external view returns (uint256);\\r\\n\\r\\n  function platform() external view returns (Platform);\\r\\n\\r\\n  function assets() external view returns (address[] memory);\\r\\n\\r\\n  function pausedInvesting() external view returns (bool);\\r\\n\\r\\n  function readyToClaim() external view returns (uint256[] memory);\\r\\n\\r\\n  function poolTotalAmount() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/base/interface/IStrategySplitter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\ninterface IStrategySplitter {\\r\\n\\r\\n  function strategies(uint idx) external view returns (address);\\r\\n\\r\\n  function strategiesRatios(address strategy) external view returns (uint);\\r\\n\\r\\n  function withdrawRequestsCalls(address user) external view returns (uint);\\r\\n\\r\\n  function addStrategy(address _strategy) external;\\r\\n\\r\\n  function removeStrategy(address _strategy) external;\\r\\n\\r\\n  function setStrategyRatios(address[] memory _strategies, uint[] memory _ratios) external;\\r\\n\\r\\n  function strategiesInited() external view returns (bool);\\r\\n\\r\\n  function needRebalance() external view returns (uint);\\r\\n\\r\\n  function wantToWithdraw() external view returns (uint);\\r\\n\\r\\n  function maxCheapWithdraw() external view returns (uint);\\r\\n\\r\\n  function strategiesLength() external view returns (uint);\\r\\n\\r\\n  function allStrategies() external view returns (address[] memory);\\r\\n\\r\\n  function strategyRewardTokens() external view returns (address[] memory);\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/openzeppelin/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\r\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\r\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\r\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\r\\n *\\r\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\r\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\r\\n *\\r\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\r\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\r\\n */\\r\\nabstract contract Initializable {\\r\\n  /**\\r\\n   * @dev Indicates that the contract has been initialized.\\r\\n   */\\r\\n  bool private _initialized;\\r\\n\\r\\n  /**\\r\\n   * @dev Indicates that the contract is in the process of being initialized.\\r\\n   */\\r\\n  bool private _initializing;\\r\\n\\r\\n  /**\\r\\n   * @dev Modifier to protect an initializer function from being invoked twice.\\r\\n   */\\r\\n  modifier initializer() {\\r\\n    require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\r\\n\\r\\n    bool isTopLevelCall = !_initializing;\\r\\n    if (isTopLevelCall) {\\r\\n      _initializing = true;\\r\\n      _initialized = true;\\r\\n    }\\r\\n\\r\\n    _;\\r\\n\\r\\n    if (isTopLevelCall) {\\r\\n      _initializing = false;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/base/interface/IControllable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\ninterface IControllable {\\r\\n\\r\\n  function isController(address _contract) external view returns (bool);\\r\\n\\r\\n  function isGovernance(address _contract) external view returns (bool);\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/base/interface/IControllableExtended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/// @dev This interface contains additional functions for Controllable class\\r\\n///      Don't extend the exist Controllable for the reason of huge coherence\\r\\ninterface IControllableExtended {\\r\\n\\r\\n  function created() external view returns (uint256 ts);\\r\\n\\r\\n  function controller() external view returns (address adr);\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/base/interface/IController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\ninterface IController {\\r\\n\\r\\n  function addVaultsAndStrategies(address[] memory _vaults, address[] memory _strategies) external;\\r\\n\\r\\n  function addStrategy(address _strategy) external;\\r\\n\\r\\n  function governance() external view returns (address);\\r\\n\\r\\n  function dao() external view returns (address);\\r\\n\\r\\n  function bookkeeper() external view returns (address);\\r\\n\\r\\n  function feeRewardForwarder() external view returns (address);\\r\\n\\r\\n  function mintHelper() external view returns (address);\\r\\n\\r\\n  function rewardToken() external view returns (address);\\r\\n\\r\\n  function fundToken() external view returns (address);\\r\\n\\r\\n  function psVault() external view returns (address);\\r\\n\\r\\n  function fund() external view returns (address);\\r\\n\\r\\n  function distributor() external view returns (address);\\r\\n\\r\\n  function announcer() external view returns (address);\\r\\n\\r\\n  function vaultController() external view returns (address);\\r\\n\\r\\n  function whiteList(address _target) external view returns (bool);\\r\\n\\r\\n  function vaults(address _target) external view returns (bool);\\r\\n\\r\\n  function strategies(address _target) external view returns (bool);\\r\\n\\r\\n  function psNumerator() external view returns (uint256);\\r\\n\\r\\n  function psDenominator() external view returns (uint256);\\r\\n\\r\\n  function fundNumerator() external view returns (uint256);\\r\\n\\r\\n  function fundDenominator() external view returns (uint256);\\r\\n\\r\\n  function isAllowedUser(address _adr) external view returns (bool);\\r\\n\\r\\n  function isDao(address _adr) external view returns (bool);\\r\\n\\r\\n  function isHardWorker(address _adr) external view returns (bool);\\r\\n\\r\\n  function isRewardDistributor(address _adr) external view returns (bool);\\r\\n\\r\\n  function isPoorRewardConsumer(address _adr) external view returns (bool);\\r\\n\\r\\n  function isValidVault(address _vault) external view returns (bool);\\r\\n\\r\\n  function isValidStrategy(address _strategy) external view returns (bool);\\r\\n\\r\\n  function rebalance(address _strategy) external;\\r\\n\\r\\n  // ************ DAO ACTIONS *************\\r\\n  function setPSNumeratorDenominator(uint256 numerator, uint256 denominator) external;\\r\\n\\r\\n  function setFundNumeratorDenominator(uint256 numerator, uint256 denominator) external;\\r\\n\\r\\n  function changeWhiteListStatus(address[] calldata _targets, bool status) external;\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 150\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"ContractInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RegisterFundKeeperEarned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"RegisterPpfsChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"RegisterStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RegisterStrategyEarned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"deposit\",\"type\":\"bool\"}],\"name\":\"RegisterUserAction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RegisterUserEarned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"RegisterVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"RemoveStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"RemoveVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"RewardDistribution\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_strategies\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_vaults\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"addStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"addVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"created\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createdBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"fundKeeperEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"__controller\",\"type\":\"address\"}],\"name\":\"initializeControllable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"isController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"isGovernance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"lastHardWork\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTokenAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IBookkeeper.HardWork\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"lastPpfsChange\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"internalType\":\"struct IBookkeeper.PpfsChange\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fundTokenAmount\",\"type\":\"uint256\"}],\"name\":\"registerFundKeeperEarned\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"registerPpfsChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"registerRewardDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_targetTokenAmount\",\"type\":\"uint256\"}],\"name\":\"registerStrategyEarned\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_deposit\",\"type\":\"bool\"}],\"name\":\"registerUserAction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"registerUserEarned\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"registerVaultTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"removeFromStrategies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"removeFromVaults\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategies\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategiesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"strategyEarnedSnapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"strategyEarnedSnapshotsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"strategyEarnedSnapshotsTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"targetTokenEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vaultRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vaultRewardsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vaultUsersBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vaultUsersQuantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaults\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Bookkeeper", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "150", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}