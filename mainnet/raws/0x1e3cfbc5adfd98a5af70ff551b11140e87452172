{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"cache/solpp-generated-contracts/Proxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Upgradeable.sol\\\";\\nimport \\\"./UpgradeableMaster.sol\\\";\\n\\n/// @title Proxy Contract\\n/// @dev NOTICE: Proxy must implement UpgradeableMaster interface to prevent calling some function of it not by master of proxy\\n/// @author Matter Labs\\ncontract Proxy is Upgradeable, UpgradeableMaster, Ownable {\\n    /// @dev Storage position of \\\"target\\\" (actual implementation address: keccak256('eip1967.proxy.implementation') - 1)\\n    bytes32 private constant targetPosition = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /// @notice Contract constructor\\n    /// @dev Calls Ownable contract constructor and initialize target\\n    /// @param target Initial implementation address\\n    /// @param targetInitializationParameters Target initialization parameters\\n    constructor(address target, bytes memory targetInitializationParameters) Ownable(msg.sender) {\\n        setTarget(target);\\n        (bool initializationSuccess, ) =\\n        getTarget().delegatecall(abi.encodeWithSignature(\\\"initialize(bytes)\\\", targetInitializationParameters));\\n        require(initializationSuccess, \\\"uin11\\\"); // uin11 - target initialization failed\\n    }\\n\\n    /// @notice Intercepts initialization calls\\n    function initialize(bytes calldata) external pure {\\n        revert(\\\"ini11\\\"); // ini11 - interception of initialization call\\n    }\\n\\n    /// @notice Intercepts upgrade calls\\n    function upgrade(bytes calldata) external pure {\\n        revert(\\\"upg11\\\"); // upg11 - interception of upgrade call\\n    }\\n\\n    /// @notice Returns target of contract\\n    /// @return target Actual implementation address\\n    function getTarget() public view returns (address target) {\\n        bytes32 position = targetPosition;\\n        assembly {\\n            target := sload(position)\\n        }\\n    }\\n\\n    /// @notice Sets new target of contract\\n    /// @param _newTarget New actual implementation address\\n    function setTarget(address _newTarget) internal {\\n        bytes32 position = targetPosition;\\n        assembly {\\n            sstore(position, _newTarget)\\n        }\\n    }\\n\\n    /// @notice Upgrades target\\n    /// @param newTarget New target\\n    /// @param newTargetUpgradeParameters New target upgrade parameters\\n    function upgradeTarget(address newTarget, bytes calldata newTargetUpgradeParameters) external override {\\n        requireMaster(msg.sender);\\n\\n        setTarget(newTarget);\\n        (bool upgradeSuccess, ) =\\n        getTarget().delegatecall(abi.encodeWithSignature(\\\"upgrade(bytes)\\\", newTargetUpgradeParameters));\\n        require(upgradeSuccess, \\\"ufu11\\\"); // ufu11 - target upgrade failed\\n    }\\n\\n    /// @notice Performs a delegatecall to the contract implementation\\n    /// @dev Fallback function allowing to perform a delegatecall to the given implementation\\n    /// This function will return whatever the implementation call returns\\n    function _fallback() internal {\\n        address _target = getTarget();\\n        assembly {\\n            // The pointer to the free memory slot\\n            let ptr := mload(0x40)\\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\\n            calldatacopy(ptr, 0x0, calldatasize())\\n            // Delegatecall method of the implementation contract, returns 0 on error\\n            let result := delegatecall(gas(), _target, ptr, calldatasize(), 0x0, 0)\\n            // Get the size of the last return data\\n            let size := returndatasize()\\n            // Copy the size length of bytes from return data at zero position to pointer position\\n            returndatacopy(ptr, 0x0, size)\\n            // Depending on result value\\n            switch result\\n                case 0 {\\n                    // End execution and revert state changes\\n                    revert(ptr, size)\\n                }\\n                default {\\n                    // Return data with length of size at pointers position\\n                    return(ptr, size)\\n                }\\n        }\\n    }\\n\\n    /// @notice Will run when no functions matches call data\\n    fallback() external payable {\\n        _fallback();\\n    }\\n\\n    /// @notice Same as fallback but called when calldata is empty\\n    receive() external payable {\\n        _fallback();\\n    }\\n\\n    /// UpgradeableMaster functions\\n    /// @notice Notice period before activation preparation status of upgrade mode\\n    function getNoticePeriod() external override returns (uint256) {\\n        (bool success, bytes memory result) = getTarget().delegatecall(abi.encodeWithSignature(\\\"getNoticePeriod()\\\"));\\n        require(success, \\\"unp11\\\"); // unp11 - upgradeNoticePeriod delegatecall failed\\n        return abi.decode(result, (uint256));\\n    }\\n\\n    /// @notice Notifies proxy contract that notice period started\\n    function upgradeNoticePeriodStarted() external override {\\n        requireMaster(msg.sender);\\n        (bool success, ) = getTarget().delegatecall(abi.encodeWithSignature(\\\"upgradeNoticePeriodStarted()\\\"));\\n        require(success, \\\"nps11\\\"); // nps11 - upgradeNoticePeriodStarted delegatecall failed\\n    }\\n\\n    /// @notice Notifies proxy contract that upgrade preparation status is activated\\n    function upgradePreparationStarted() external override {\\n        requireMaster(msg.sender);\\n        (bool success, ) = getTarget().delegatecall(abi.encodeWithSignature(\\\"upgradePreparationStarted()\\\"));\\n        require(success, \\\"ups11\\\"); // ups11 - upgradePreparationStarted delegatecall failed\\n    }\\n\\n    /// @notice Notifies proxy contract that upgrade canceled\\n    function upgradeCanceled() external override {\\n        requireMaster(msg.sender);\\n        (bool success, ) = getTarget().delegatecall(abi.encodeWithSignature(\\\"upgradeCanceled()\\\"));\\n        require(success, \\\"puc11\\\"); // puc11 - upgradeCanceled delegatecall failed\\n    }\\n\\n    /// @notice Notifies proxy contract that upgrade finishes\\n    function upgradeFinishes() external override {\\n        requireMaster(msg.sender);\\n        (bool success, ) = getTarget().delegatecall(abi.encodeWithSignature(\\\"upgradeFinishes()\\\"));\\n        require(success, \\\"puf11\\\"); // puf11 - upgradeFinishes delegatecall failed\\n    }\\n\\n    /// @notice Checks that contract is ready for upgrade\\n    /// @return bool flag indicating that contract is ready for upgrade\\n    function isReadyForUpgrade() external override returns (bool) {\\n        (bool success, bytes memory result) = getTarget().delegatecall(abi.encodeWithSignature(\\\"isReadyForUpgrade()\\\"));\\n        require(success, \\\"rfu11\\\"); // rfu11 - readyForUpgrade delegatecall failed\\n        return abi.decode(result, (bool));\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Ownable Contract\\n/// @author Matter Labs\\n// NO CHANGE\\ncontract Ownable {\\n    /// @dev Storage position of the masters address (keccak256('eip1967.proxy.admin') - 1)\\n    bytes32 private constant masterPosition = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /// @notice Contract constructor\\n    /// @dev Sets msg sender address as masters address\\n    /// @param masterAddress Master address\\n    constructor(address masterAddress) {\\n        setMaster(masterAddress);\\n    }\\n\\n    /// @notice Check if specified address is master\\n    /// @param _address Address to check\\n    function requireMaster(address _address) internal view {\\n        require(_address == getMaster(), \\\"1c\\\"); // oro11 - only by master\\n    }\\n\\n    /// @notice Returns contract masters address\\n    /// @return master Master's address\\n    function getMaster() public view returns (address master) {\\n        bytes32 position = masterPosition;\\n        assembly {\\n            master := sload(position)\\n        }\\n    }\\n\\n    /// @dev Sets new masters address\\n    /// @param _newMaster New master's address\\n    function setMaster(address _newMaster) internal {\\n        bytes32 position = masterPosition;\\n        assembly {\\n            sstore(position, _newMaster)\\n        }\\n    }\\n\\n    /// @notice Transfer mastership of the contract to new master\\n    /// @param _newMaster New masters address\\n    function transferMastership(address _newMaster) external {\\n        requireMaster(msg.sender);\\n        require(_newMaster != address(0), \\\"1d\\\"); // otp11 - new masters address can't be zero address\\n        setMaster(_newMaster);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Upgradeable.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Interface of the upgradeable contract\\n/// @author Matter Labs\\ninterface Upgradeable {\\n    /// @notice Upgrades target of upgradeable contract\\n    /// @param newTarget New target\\n    /// @param newTargetInitializationParameters New target initialization parameters\\n    function upgradeTarget(address newTarget, bytes calldata newTargetInitializationParameters) external;\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/UpgradeableMaster.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Interface of the upgradeable master contract (defines notice period duration and allows finish upgrade during preparation of it)\\n/// @author Matter Labs\\ninterface UpgradeableMaster {\\n    /// @notice Notice period before activation preparation status of upgrade mode\\n    function getNoticePeriod() external returns (uint256);\\n\\n    /// @notice Notifies contract that notice period started\\n    function upgradeNoticePeriodStarted() external;\\n\\n    /// @notice Notifies contract that upgrade preparation status is activated\\n    function upgradePreparationStarted() external;\\n\\n    /// @notice Notifies contract that upgrade canceled\\n    function upgradeCanceled() external;\\n\\n    /// @notice Notifies contract that upgrade finishes\\n    function upgradeFinishes() external;\\n\\n    /// @notice Checks that contract is ready for upgrade\\n    /// @return bool flag indicating that contract is ready for upgrade\\n    function isReadyForUpgrade() external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"targetInitializationParameters\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"getMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"master\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNoticePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTarget\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isReadyForUpgrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMaster\",\"type\":\"address\"}],\"name\":\"transferMastership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeCanceled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeFinishes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeNoticePeriodStarted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradePreparationStarted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"newTargetUpgradeParameters\",\"type\":\"bytes\"}],\"name\":\"upgradeTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Proxy", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000aae5ec8ac85ec1b14d802a4b2e4d7494f2fe2202000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000005f23802a4730e532f4d0d976073cf1abc8897852000000000000000000000000e672cca0a07ff67516c7024ace2803aeda9f86e5000000000000000000000000907851ebb1c888c4c07ed9b6e1e04f03a563d85a000000000000000000000000467c9776a6a5cf752f00177c48dba8471aefccb1000000000000000000000000cb4c185cc1bc048742d3b6ab760efd2d3592c58f19071dafab61174610e07cbad3338b84835f1107c7df10e62ca7faa345d64d20", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xaae5ec8ac85ec1b14d802a4b2e4d7494f2fe2202", "SwarmSource": ""}]}