{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/mint/MerkleMintAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\nimport \\\"./BaseMinter.sol\\\";\\n\\ncontract MerkleMintAuthorizer is BaseMinter {\\n  uint256 private immutable _userMintLimit;\\n  mapping(address => uint256) private _userMintCount;\\n\\n  bytes32 private immutable _merkleRoot;\\n  uint256 private immutable _userMintPrice;\\n\\n  constructor(\\n    address entryPoint,\\n    string memory mintName,\\n    uint256 totalMintLimit,\\n    uint256 userMintLimit,\\n    bytes32 merkleRoot,\\n    uint256 userMintPrice,\\n    uint256 startTime,\\n    uint256 endTime\\n  ) BaseMinter(entryPoint, mintName, totalMintLimit, startTime, endTime) {\\n    _userMintLimit = userMintLimit;\\n    _merkleRoot = merkleRoot;\\n    _userMintPrice = userMintPrice;\\n  }\\n\\n  function getProofRequired() external view override returns (bool) {\\n    return _merkleRoot != bytes32(0);\\n  }\\n\\n  function getUserMintPrice(address, bytes32[] memory) external view override returns (uint256) {\\n    return _userMintPrice;\\n  }\\n\\n  function getUserMintLimit(address, bytes32[] memory) external view override returns (uint256) {\\n    return _userMintLimit;\\n  }\\n\\n  function getUserMintCount(address user) external view override returns (uint256) {\\n    return _userMintCount[user];\\n  }\\n\\n  function authorizeMint(\\n    address sender,\\n    uint256 value,\\n    uint256 number,\\n    bytes32[] memory proof\\n  ) external override {\\n    _authorizeMint(number);\\n\\n    uint256 newMintCount = _userMintCount[sender] + number;\\n    require(newMintCount <= _userMintLimit, \\\"Trying to mint more than allowed\\\");\\n    _userMintCount[sender] = newMintCount;\\n\\n    require(_merkleRoot == bytes32(0) || MerkleProof.verify(\\n              proof, _merkleRoot, keccak256(abi.encodePacked(sender))),\\n            \\\"Merkle proof failed\\\");\\n\\n    // We can't use \\\"Insufficient funds\\\" because ethers-io makes\\n    // some assumptions about specific error strings and throws an error\\n    // when it sees one...\\n    //   see: https://github.com/NomicFoundation/hardhat/issues/2489\\n    require(value >= _userMintPrice * number, \\\"Insufficient payment\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = _efficientHash(computedHash, proofElement);\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = _efficientHash(proofElement, computedHash);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mint/BaseMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\\\";\\n\\nimport \\\"./IRebelsMintAuthorizer.sol\\\";\\nimport \\\"./IRebelsMintInfo.sol\\\";\\n\\nabstract contract BaseMinter is IRebelsMintAuthorizer, IRebelsMintInfo, ERC165Storage {\\n  address private immutable _entryPoint;\\n  string private _mintName;\\n\\n  uint256 internal immutable _totalMintLimit;\\n  uint256 internal _totalMintCount;\\n\\n  uint256 internal immutable _startTime;\\n  uint256 internal immutable _endTime;\\n\\n  constructor(\\n    address entryPoint,\\n    string memory mintName,\\n    uint256 totalMintLimit,\\n    uint256 startTime,\\n    uint256 endTime\\n  ) {\\n    require(startTime < endTime);\\n\\n    _entryPoint = entryPoint;\\n    _mintName = mintName;\\n    _totalMintLimit = totalMintLimit;\\n    _startTime = startTime;\\n    _endTime = endTime;\\n\\n    _registerInterface(type(IRebelsMintAuthorizer).interfaceId);\\n    _registerInterface(type(IRebelsMintInfo).interfaceId);\\n  }\\n\\n  function getMintName() external view override returns (string memory) {\\n    return _mintName;\\n  }\\n\\n  function getMintActive() public view override returns (bool) {\\n    return _startTime <= block.timestamp && block.timestamp < _endTime;\\n  }\\n\\n  function getMintStartTime() external view override returns (uint256) {\\n    return _startTime;\\n  }\\n\\n  function getMintEndTime() external view override returns (uint256) {\\n    return _endTime;\\n  }\\n\\n  function getTotalMintLimit() external view override returns (uint256) {\\n    return _totalMintLimit;\\n  }\\n\\n  function getTotalMintCount() external view override returns (uint256) {\\n    return _totalMintCount;\\n  }\\n\\n  function _authorizeMint(\\n    uint256 number\\n  ) internal {\\n    require(msg.sender == _entryPoint);\\n\\n    require(getMintActive(), \\\"Mint is not active\\\");\\n\\n    uint256 newTotalMintCount = _totalMintCount + number;\\n    require(newTotalMintCount <= _totalMintLimit,\\n            \\\"Trying to mint more than total allowed\\\");\\n    _totalMintCount = newTotalMintCount;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Storage.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC165.sol\\\";\\n\\n/**\\n * @dev Storage based implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165Storage is ERC165 {\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mint/IRebelsMintAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\ninterface IRebelsMintAuthorizer {\\n  function authorizeMint(\\n    address sender,\\n    uint256 value,\\n    uint256 number,\\n    bytes32[] memory senderData\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/mint/IRebelsMintInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\ninterface IRebelsMintInfo {\\n  function getMintName() external view returns (string memory);\\n  function getMintActive() external view returns (bool);\\n  function getMintStartTime() external view returns (uint256);\\n  function getMintEndTime() external view returns (uint256);\\n\\n  function getProofRequired() external view returns (bool);\\n  function getTotalMintLimit() external view returns (uint256);\\n  function getTotalMintCount() external view returns (uint256);\\n\\n  function getUserMintPrice(address user, bytes32[] memory senderData) external view returns (uint256);\\n  function getUserMintLimit(address user, bytes32[] memory senderData) external view returns (uint256);\\n  function getUserMintCount(address user) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"entryPoint\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"mintName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalMintLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userMintLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"userMintPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"authorizeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProofRequired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMintCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMintLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserMintCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"name\":\"getUserMintLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"name\":\"getUserMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MerkleMintAuthorizer", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000e9fca552b9eb110c2d170962af740725f71f5644000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000014b6000000000000000000000000000000000000000000000000000000000000000244d6923ff7f8b2e687988a32d98aebcb4136ef15b04061921bfbed9c15d1d911000000000000000000000000000000000000000000000000011c37937e0800000000000000000000000000000000000000000000000000000000000062a658800000000000000000000000000000000000000000000000000000000062a8fb80000000000000000000000000000000000000000000000000000000000000000c507269766174652053616c650000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}