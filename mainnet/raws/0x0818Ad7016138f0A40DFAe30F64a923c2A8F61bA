{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/ChainlinkConversionPath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport './legacy_openzeppelin/contracts/access/roles/WhitelistAdminRole.sol';\\n\\ninterface ERC20fraction {\\n    function decimals() external view returns (uint8);\\n}\\n\\ninterface AggregatorFraction {\\n    function decimals() external view returns (uint8);\\n\\n    function latestAnswer() external view returns (int256);\\n\\n    function latestTimestamp() external view returns (uint256);\\n}\\n\\n/**\\n * @title ChainlinkConversionPath\\n *\\n * @notice ChainlinkConversionPath is a contract computing currency conversion rates based on Chainlink aggretators\\n */\\ncontract ChainlinkConversionPath is WhitelistAdminRole {\\n    uint256 constant PRECISION = 1e18;\\n    uint256 constant NATIVE_TOKEN_DECIMALS = 18;\\n    uint256 constant FIAT_DECIMALS = 8;\\n    address public nativeTokenHash;\\n\\n    /**\\n     * @param _nativeTokenHash hash of the native token\\n     */\\n    constructor(address _nativeTokenHash) {\\n        nativeTokenHash = _nativeTokenHash;\\n    }\\n\\n    // Mapping of Chainlink aggregators (input currency => output currency => contract address)\\n    // input & output currencies are the addresses of the ERC20 contracts OR the sha3(\\\"currency code\\\")\\n    mapping(address => mapping(address => address)) public allAggregators;\\n\\n    // declare a new aggregator\\n    event AggregatorUpdated(address _input, address _output, address _aggregator);\\n\\n    /**\\n     * @notice Update an aggregator\\n     * @param _input address representing the input currency\\n     * @param _output address representing the output currency\\n     * @param _aggregator address of the aggregator contract\\n     */\\n    function updateAggregator(\\n        address _input,\\n        address _output,\\n        address _aggregator\\n    ) external onlyWhitelistAdmin {\\n        allAggregators[_input][_output] = _aggregator;\\n        emit AggregatorUpdated(_input, _output, _aggregator);\\n    }\\n\\n    /**\\n     * @notice Update a list of aggregators\\n     * @param _inputs list of addresses representing the input currencies\\n     * @param _outputs list of addresses representing the output currencies\\n     * @param _aggregators list of addresses of the aggregator contracts\\n     */\\n    function updateAggregatorsList(\\n        address[] calldata _inputs,\\n        address[] calldata _outputs,\\n        address[] calldata _aggregators\\n    ) external onlyWhitelistAdmin {\\n        require(_inputs.length == _outputs.length, 'arrays must have the same length');\\n        require(_inputs.length == _aggregators.length, 'arrays must have the same length');\\n\\n        // For every conversions of the path\\n        for (uint256 i; i < _inputs.length; i++) {\\n            allAggregators[_inputs[i]][_outputs[i]] = _aggregators[i];\\n            emit AggregatorUpdated(_inputs[i], _outputs[i], _aggregators[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes the conversion of an amount through a list of intermediate conversions\\n     * @param _amountIn Amount to convert\\n     * @param _path List of addresses representing the currencies for the intermediate conversions\\n     * @return result The result after all the conversions\\n     * @return oldestRateTimestamp The oldest timestamp of the path\\n     */\\n    function getConversion(uint256 _amountIn, address[] calldata _path)\\n        external\\n        view\\n        returns (uint256 result, uint256 oldestRateTimestamp)\\n    {\\n        (uint256 rate, uint256 timestamp, uint256 decimals) = getRate(_path);\\n\\n        // initialize the result\\n        result = (_amountIn * rate) / decimals;\\n\\n        oldestRateTimestamp = timestamp;\\n    }\\n\\n    /**\\n     * @notice Computes the conversion rate from a list of currencies\\n     * @param _path List of addresses representing the currencies for the conversions\\n     * @return rate The rate\\n     * @return oldestRateTimestamp The oldest timestamp of the path\\n     * @return decimals of the conversion rate\\n     */\\n    function getRate(address[] memory _path)\\n        public\\n        view\\n        returns (\\n            uint256 rate,\\n            uint256 oldestRateTimestamp,\\n            uint256 decimals\\n        )\\n    {\\n        // initialize the result with 18 decimals (for more precision)\\n        rate = PRECISION;\\n        decimals = PRECISION;\\n        oldestRateTimestamp = block.timestamp;\\n\\n        // For every conversion of the path\\n        for (uint256 i; i < _path.length - 1; i++) {\\n            (\\n                AggregatorFraction aggregator,\\n                bool reverseAggregator,\\n                uint256 decimalsInput,\\n                uint256 decimalsOutput\\n            ) = getAggregatorAndDecimals(_path[i], _path[i + 1]);\\n\\n            // store the latest timestamp of the path\\n            uint256 currentTimestamp = aggregator.latestTimestamp();\\n            if (currentTimestamp < oldestRateTimestamp) {\\n                oldestRateTimestamp = currentTimestamp;\\n            }\\n\\n            // get the rate of the current step\\n            uint256 currentRate = uint256(aggregator.latestAnswer());\\n            // get the number of decimals of the current rate\\n            uint256 decimalsAggregator = uint256(aggregator.decimals());\\n\\n            // mul with the difference of decimals before the current rate computation (for more precision)\\n            if (decimalsAggregator > decimalsInput) {\\n                rate = rate * (10**(decimalsAggregator - decimalsInput));\\n            }\\n            if (decimalsAggregator < decimalsOutput) {\\n                rate = rate * (10**(decimalsOutput - decimalsAggregator));\\n            }\\n\\n            // Apply the current rate (if path uses an aggregator in the reverse way, div instead of mul)\\n            if (reverseAggregator) {\\n                rate = (rate * (10**decimalsAggregator)) / currentRate;\\n            } else {\\n                rate = (rate * currentRate) / (10**decimalsAggregator);\\n            }\\n\\n            // div with the difference of decimals AFTER the current rate computation (for more precision)\\n            if (decimalsAggregator < decimalsInput) {\\n                rate = rate / (10**(decimalsInput - decimalsAggregator));\\n            }\\n            if (decimalsAggregator > decimalsOutput) {\\n                rate = rate / (10**(decimalsAggregator - decimalsOutput));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets aggregators and decimals of two currencies\\n     * @param _input input Address\\n     * @param _output output Address\\n     * @return aggregator to get the rate between the two currencies\\n     * @return reverseAggregator true if the aggregator returned give the rate from _output to _input\\n     * @return decimalsInput decimals of _input\\n     * @return decimalsOutput decimals of _output\\n     */\\n    function getAggregatorAndDecimals(address _input, address _output)\\n        private\\n        view\\n        returns (\\n            AggregatorFraction aggregator,\\n            bool reverseAggregator,\\n            uint256 decimalsInput,\\n            uint256 decimalsOutput\\n        )\\n    {\\n        // Try to get the right aggregator for the conversion\\n        aggregator = AggregatorFraction(allAggregators[_input][_output]);\\n        reverseAggregator = false;\\n\\n        // if no aggregator found we try to find an aggregator in the reverse way\\n        if (address(aggregator) == address(0x00)) {\\n            aggregator = AggregatorFraction(allAggregators[_output][_input]);\\n            reverseAggregator = true;\\n        }\\n\\n        require(address(aggregator) != address(0x00), 'No aggregator found');\\n\\n        // get the decimals for the two currencies\\n        decimalsInput = getDecimals(_input);\\n        decimalsOutput = getDecimals(_output);\\n    }\\n\\n    /**\\n     * @notice Gets decimals from an address currency\\n     * @param _addr address to check\\n     * @return decimals number of decimals\\n     */\\n    function getDecimals(address _addr) private view returns (uint256 decimals) {\\n        // by default we assume it is fiat\\n        decimals = FIAT_DECIMALS;\\n        // if address is the hash of the ETH currency\\n        if (_addr == nativeTokenHash) {\\n            decimals = NATIVE_TOKEN_DECIMALS;\\n        } else if (isContract(_addr)) {\\n            // otherwise, we get the decimals from the erc20 directly\\n            decimals = ERC20fraction(_addr).decimals();\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if an address is a contract\\n     * @param _addr Address to check\\n     * @return true if the address hosts a contract, false otherwise\\n     */\\n    function isContract(address _addr) private view returns (bool) {\\n        uint32 size;\\n        // solium-disable security/no-inline-assembly\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return (size > 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/legacy_openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/Context.sol';\\nimport \\\"../Roles.sol\\\";\\n\\n/**\\n * @title WhitelistAdminRole\\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\\n */\\nabstract contract WhitelistAdminRole is Context {\\n    using Roles for Roles.Role;\\n\\n    event WhitelistAdminAdded(address indexed account);\\n    event WhitelistAdminRemoved(address indexed account);\\n\\n    Roles.Role private _whitelistAdmins;\\n\\n    constructor () {\\n        _addWhitelistAdmin(_msgSender());\\n    }\\n\\n    modifier onlyWhitelistAdmin() {\\n        require(isWhitelistAdmin(_msgSender()), \\\"WhitelistAdminRole: caller does not have the WhitelistAdmin role\\\");\\n        _;\\n    }\\n\\n    function isWhitelistAdmin(address account) public view returns (bool) {\\n        return _whitelistAdmins.has(account);\\n    }\\n\\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\\n        _addWhitelistAdmin(account);\\n    }\\n\\n    function renounceWhitelistAdmin() public {\\n        _removeWhitelistAdmin(_msgSender());\\n    }\\n\\n    function _addWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.add(account);\\n        emit WhitelistAdminAdded(account);\\n    }\\n\\n    function _removeWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.remove(account);\\n        emit WhitelistAdminRemoved(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/legacy_openzeppelin/contracts/access/Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address => bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account's access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nativeTokenHash\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"}],\"name\":\"AggregatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allAggregators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"}],\"name\":\"getConversion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldestRateTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"}],\"name\":\"getRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldestRateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeTokenHash\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"}],\"name\":\"updateAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_inputs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_outputs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_aggregators\",\"type\":\"address[]\"}],\"name\":\"updateAggregatorsList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ChainlinkConversionPath", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000f5af88e117747e87fc5929f2ff87221b1447652e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}