{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/IERC721.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/AxolittlesStakingV2.sol\r\n\r\n\r\npragma solidity ^0.8.10;\r\n/// @title Interface to interact with Bubbles contract.\r\ninterface IBubbles {\r\n    function mint(address recipient, uint256 amount) external;\r\n}\r\n\r\n/// @author The Axolittles Team\r\n/// @title Contract V2 for staking axos to receive $BUBBLE\r\ncontract AxolittlesStakingV2 is Ownable {\r\n    address public AXOLITTLES = 0xf36446105fF682999a442b003f2224BcB3D82067;\r\n    address public TOKEN = 0x58f46F627C88a3b217abc80563B9a726abB873ba;\r\n    address public STAKING_V1 = 0x1cA6e4643062e67CCd555fB4F64Bee603340e0ea;\r\n    bool public stakingPaused;\r\n    bool public isVariableReward = true;\r\n    uint256 public stakeTarget = 6000;\r\n    // Amount of $BUBBLE generated each block, contains 18 decimals.\r\n    uint256 public emissionPerBlock = 15000000000000000;\r\n    uint256 internal totalStaked;\r\n\r\n    /// @notice struct per owner address to store:\r\n    /// a. previously calced rewards, b. number staked, and block since last reward calculation.\r\n    struct staker {\r\n        // number of axolittles currently staked\r\n        uint256 numStaked;\r\n        // block since calcedReward was last updated\r\n        uint256 blockSinceLastCalc;\r\n        // previously calculated rewards\r\n        uint256 calcedReward;\r\n    }\r\n\r\n    mapping(address => staker) public stakers;\r\n    mapping(uint256 => address) public stakedAxos;\r\n\r\n    constructor() {}\r\n\r\n    event Stake(address indexed owner, uint256[] tokenIds);\r\n    event Unstake(address indexed owner, uint256[] tokenIds);\r\n    event Claim(address indexed owner, uint256 totalReward);\r\n    event SetStakingPaused(bool _stakingPaused);\r\n    event SetVariableReward(bool _isVariableReward);\r\n    event SetStakeTarget(uint256 stakeTarget);\r\n    event AdminTransfer(uint256[] tokenIds);\r\n\r\n    /// @notice Function to stake axos. Transfers axos from sender to this contract.\r\n    function stake(uint256[] memory tokenIds) external {\r\n        require(!stakingPaused, \"Staking is paused\");\r\n        require(tokenIds.length > 0, \"Nothing to stake\");\r\n        stakers[msg.sender].calcedReward = _checkRewardInternal(msg.sender);\r\n        stakers[msg.sender].numStaked += tokenIds.length;\r\n        stakers[msg.sender].blockSinceLastCalc = block.number;\r\n        totalStaked += tokenIds.length;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            IERC721(AXOLITTLES).transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                tokenIds[i]\r\n            );\r\n            stakedAxos[tokenIds[i]] = msg.sender;\r\n        }\r\n        emit Stake(msg.sender, tokenIds);\r\n    }\r\n\r\n    /// @notice Function to unstake axos. Transfers axos from this contract back to sender address.\r\n    function unstake(uint256[] memory tokenIds) external {\r\n        require(tokenIds.length > 0, \"Nothing to unstake\");\r\n        require(\r\n            tokenIds.length <= stakers[msg.sender].numStaked,\r\n            \"Not your axo!\"\r\n        );\r\n        stakers[msg.sender].calcedReward = _checkRewardInternal(msg.sender);\r\n        stakers[msg.sender].numStaked -= tokenIds.length;\r\n        stakers[msg.sender].blockSinceLastCalc = block.number;\r\n        totalStaked -= tokenIds.length;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            require(msg.sender == stakedAxos[tokenIds[i]], \"Not your axo!\");\r\n            delete stakedAxos[tokenIds[i]];\r\n            IERC721(AXOLITTLES).transferFrom(\r\n                address(this),\r\n                msg.sender,\r\n                tokenIds[i]\r\n            );\r\n        }\r\n        emit Unstake(msg.sender, tokenIds);\r\n    }\r\n\r\n    /// @notice Function to claim $BUBBLE.\r\n    function claim() external {\r\n        uint256 totalReward = _checkRewardInternal(msg.sender);\r\n        require(totalReward > 0, \"Nothing to claim\");\r\n        stakers[msg.sender].blockSinceLastCalc = block.number;\r\n        stakers[msg.sender].calcedReward = 0;\r\n        IBubbles(TOKEN).mint(msg.sender, totalReward);\r\n        emit Claim(msg.sender, totalReward);\r\n    }\r\n\r\n    /// @notice Function to check rewards per staker address\r\n    function checkReward(address _staker_address)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _checkRewardInternal(_staker_address);\r\n    }\r\n\r\n    /// @notice Internal function to check rewards per staker address\r\n    function _checkRewardInternal(address _staker_address)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 newReward = stakers[_staker_address].numStaked *\r\n            emissionPerBlock *\r\n            (block.number - stakers[_staker_address].blockSinceLastCalc);\r\n        if (isVariableReward) {\r\n            uint256 bothStaked = totalStaked +\r\n                IERC721(AXOLITTLES).balanceOf(STAKING_V1);\r\n            if (bothStaked >= stakeTarget) {\r\n                newReward *= 2;\r\n            } else {\r\n                newReward = (newReward * bothStaked) / stakeTarget;\r\n            }\r\n        }\r\n        return stakers[_staker_address].calcedReward + newReward;\r\n    }\r\n\r\n    //ADMIN FUNCTIONS\r\n    /// @notice Function to change address of NFT\r\n    function setAxolittlesAddress(address _axolittlesAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        AXOLITTLES = _axolittlesAddress;\r\n    }\r\n\r\n    /// @notice Function to change address of reward token\r\n    function setTokenAddress(address _tokenAddress) external onlyOwner {\r\n        TOKEN = _tokenAddress;\r\n    }\r\n\r\n    /// @notice Function to change amount of $BUBBLE generated each block per axo\r\n    function setEmissionPerBlock(uint256 _emissionPerBlock) external onlyOwner {\r\n        emissionPerBlock = _emissionPerBlock;\r\n    }\r\n\r\n    /// @notice Function to prevent further staking\r\n    function setStakingPaused(bool _isPaused) external onlyOwner {\r\n        stakingPaused = _isPaused;\r\n        emit SetStakingPaused(stakingPaused);\r\n    }\r\n\r\n    ///@notice Function to turn on variable rewards\r\n    function setVariableReward(bool _isVariableReward) external onlyOwner {\r\n        require(isVariableReward != _isVariableReward, \"Nothing changed\");\r\n        isVariableReward = _isVariableReward;\r\n        emit SetVariableReward(isVariableReward);\r\n    }\r\n\r\n    ///@notice Function to change stake target for variable rewards\r\n    function setStakeTarget(uint256 _stakeTarget) external onlyOwner {\r\n        require(_stakeTarget > 0, \"Please don't break the math!\");\r\n        stakeTarget = _stakeTarget;\r\n        emit SetStakeTarget(stakeTarget);\r\n    }\r\n\r\n    /// @notice Function for admin to transfer axos out of contract back to original owner\r\n    function adminTransfer(uint256[] memory tokenIds) external onlyOwner {\r\n        require(tokenIds.length > 0, \"Nothing to unstake\");\r\n        totalStaked -= tokenIds.length;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            address owner = stakedAxos[tokenIds[i]];\r\n            require(owner != address(0), \"Axo not found\");\r\n            stakers[owner].numStaked--;\r\n            delete stakedAxos[tokenIds[i]];\r\n            IERC721(AXOLITTLES).transferFrom(address(this), owner, tokenIds[i]);\r\n        }\r\n        emit AdminTransfer(tokenIds);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"AdminTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeTarget\",\"type\":\"uint256\"}],\"name\":\"SetStakeTarget\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_stakingPaused\",\"type\":\"bool\"}],\"name\":\"SetStakingPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isVariableReward\",\"type\":\"bool\"}],\"name\":\"SetVariableReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AXOLITTLES\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKING_V1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"adminTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker_address\",\"type\":\"address\"}],\"name\":\"checkReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emissionPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isVariableReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_axolittlesAddress\",\"type\":\"address\"}],\"name\":\"setAxolittlesAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_emissionPerBlock\",\"type\":\"uint256\"}],\"name\":\"setEmissionPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeTarget\",\"type\":\"uint256\"}],\"name\":\"setStakeTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isPaused\",\"type\":\"bool\"}],\"name\":\"setStakingPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isVariableReward\",\"type\":\"bool\"}],\"name\":\"setVariableReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakedAxos\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockSinceLastCalc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calcedReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AxolittlesStakingV2", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2fe54989526072d23d33e76dc86d5bef17787baabbd0428dcfaeeb1852b1d86f"}]}