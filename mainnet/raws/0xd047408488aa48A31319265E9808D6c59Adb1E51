{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/price/BeanstalkPrice.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport { SafeMath } from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"./CurvePrice.sol\\\";\\nimport \\\"./UniswapPrice.sol\\\";\\nimport \\\"./BeanLUSDPrice.sol\\\";\\n\\ncontract BeanstalkPrice is UniswapPrice, CurvePrice, BeanLUSDPrice {\\n\\n    using SafeMath for uint256;\\n\\n    struct Prices {\\n        uint256 price;\\n        uint256 liquidity;\\n        int deltaB;\\n        P.Pool[] ps;\\n    }\\n\\n    function price() external view returns (Prices memory p) {\\n        p.ps = new P.Pool[](3);\\n        p.ps[0] = getCurve();\\n        p.ps[1] = getUniswap();\\n        p.ps[2] = getBeanLUSDCurve();\\n\\n\\n        for (uint256 i = 0; i < p.ps.length; i++) {\\n            p.price += p.ps[i].price * p.ps[i].liquidity;\\n            p.liquidity += p.ps[i].liquidity;\\n            p.deltaB += p.ps[i].deltaB;\\n        }\\n        p.price /= p.liquidity;\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/price/CurvePrice.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport { SafeMath } from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport {P} from \\\"./P.sol\\\";\\nimport \\\"./libraries/LibMetaCurve.sol\\\";\\nimport \\\"./libraries/LibCurve.sol\\\";\\n\\n// interface IERC20 {\\n//     function decimals() external view returns (uint8);\\n// }\\n\\n// interface IMeta3Curve {\\n    // function A_precise() external view returns (uint256);\\n    // function get_balances() external view returns (uint256[2] memory);\\n    // function get_price_cumulative_last() external view returns (uint256[2] memory);\\n    // function block_timestamp_last() external view returns (uint256);\\n    // // function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\\n    // function get_dy_underlying(int128 i, int128 j, uint256 dx, uint256[2] calldata _balances) external view returns (uint256);\\n    // function get_dy(int128 i, int128 j, uint256 dx, uint256[2] calldata _balances) external view returns (uint256);\\n// }\\n\\ncontract CurvePrice {\\n\\n    using SafeMath for uint256;\\n\\n    //-------------------------------------------------------------------------------------------------------------------\\n    // Mainnet\\n    address private constant POOL = 0x3a70DfA7d2262988064A2D051dd47521E43c9BdD;\\n    address private constant CRV3_POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\\n    //-------------------------------------------------------------------------------------------------------------------\\n    // Ropsten\\n    // address private constant POOL = 0x9ED0380C5dedadd3b2a32f5D5FD6B3929f8d39d9;\\n    // address private constant CRV3_POOL = 0x6412bbCeEf0b384B7f8142BDafeFE119178F1E22;\\n    //-------------------------------------------------------------------------------------------------------------------\\n\\n    uint256 private constant A_PRECISION = 100; \\n    uint256 private constant N_COINS  = 2;\\n    uint256 private constant RATE_MULTIPLIER = 10 ** 30;\\n    uint256 private constant PRECISION = 1e18;\\n    uint256 private constant i = 0;\\n    uint256 private constant j = 1;\\n    address[2] private tokens = [0xDC59ac4FeFa32293A95889Dc396682858d52e5Db, 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490];\\n\\n    function getCurve() public view returns (P.Pool memory pool) {\\n        pool.pool = POOL;\\n        pool.tokens = tokens;\\n        uint256[2] memory balances = IMeta3Curve(POOL).get_balances();\\n        pool.balances = balances;\\n        uint256[2] memory rates = getRates();\\n        uint256[2] memory xp = LibCurve.getXP(balances, rates);\\n        uint256 a = IMeta3Curve(POOL).A_precise();\\n        uint256 D = getD(xp, a);\\n\\n        pool.price = LibCurve.getCurvePrice(xp, rates, a, D);\\n        rates[0] = rates[0].mul(pool.price).div(1e6);\\n        pool.liquidity = getCurveUSDValue(balances, rates);\\n        pool.deltaB = getCurveDeltaB(balances[0], D);\\n    }\\n\\n    function getCurveDeltaB(uint256 balance, uint256 D) private pure returns (int deltaB) {\\n        uint256 pegBeans = D / 2 / 1e12;\\n        deltaB = int256(pegBeans) - int256(balance);\\n    }\\n\\n    function getCurveUSDValue(uint256[2] memory balances, uint256[2] memory rates) private pure returns (uint) {\\n        uint256[2] memory value = LibCurve.getXP(balances, rates);\\n        return (value[0] + value[1]) / 1e12;\\n    }\\n\\n    function getD(uint256[2] memory xp, uint256 a) private pure returns (uint D) {\\n        \\n        /*  \\n        * D invariant calculation in non-overflowing integer operations\\n        * iteratively\\n        *\\n        * A * sum(x_i) * n**n + D = A * D * n**n + D**(n+1) / (n**n * prod(x_i))\\n        *\\n        * Converging solution:\\n        * D[j+1] = (A * n**n * sum(x_i) - D[j]**(n+1) / (n**n prod(x_i))) / (A * n**n - 1)\\n        */\\n        uint256 S;\\n        uint256 Dprev;\\n        for (uint _i = 0; _i < xp.length; _i++) {\\n            S += xp[_i];\\n        }\\n        if (S == 0) return 0;\\n\\n        D = S;\\n        uint256 Ann = a * N_COINS;\\n        for (uint _i = 0; _i < 256; _i++) {\\n            uint256 D_P = D;\\n            for (uint _j = 0; _j < xp.length; _j++) {\\n                D_P = D_P * D / (xp[_j] * N_COINS);  // If division by 0, this will be borked: only withdrawal will work. And that is good\\n            }\\n            Dprev = D;\\n            D = (Ann * S / A_PRECISION + D_P * N_COINS) * D / ((Ann - A_PRECISION) * D / A_PRECISION + (N_COINS + 1) * D_P);\\n            // Equality with the precision of 1\\n            if (D > Dprev && D - Dprev <= 1) return D;\\n            else if (Dprev - D <= 1) return D;\\n        }\\n        // convergence typically occurs in 4 rounds or less, this should be unreachable!\\n        // if it does happen the pool is borked and LPs can withdraw via `remove_liquidity`\\n        require(false, \\\"Price: Convergence false\\\");\\n    }\\n\\n    function getRates() private view returns (uint256[2] memory rates) {\\n        uint8 decimals = IERC20(tokens[0]).decimals();\\n        return [10**(36-decimals), I3Curve(CRV3_POOL).get_virtual_price()];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/price/UniswapPrice.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport { SafeMath } from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"./P.sol\\\";\\nimport \\\"./libraries/LibHelpers.sol\\\";\\n\\ninterface IUniswapV2Pair {\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n}\\n\\ncontract UniswapPrice {\\n\\n    using SafeMath for uint256;\\n\\n    //-------------------------------------------------------------------------------------------------------------------\\n    // Mainnet\\n    address private constant USDC_ETH_ADDRESS = 0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc;\\n    address private constant ETH_BEAN_ADDRESS = 0x87898263B6C5BABe34b4ec53F22d98430b91e371;\\n    address[2] private TOKENS = [0xDC59ac4FeFa32293A95889Dc396682858d52e5Db, 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2];\\n    //-------------------------------------------------------------------------------------------------------------------\\n    // Ropsten\\n    // address private constant USDC_ETH_ADDRESS = 0x681A4164703351d6AceBA9D7038b573b444d3353;\\n    // address private constant ETH_BEAN_ADDRESS = 0x298c5f1f902c5bDc2936eb44b3E0E8675F40B8db;\\n    // address[2] private TOKENS = [0xDC59ac4FeFa32293A95889Dc396682858d52e5Db, 0xc778417E063141139Fce010982780140Aa0cD5Ab];\\n    //-------------------------------------------------------------------------------------------------------------------\\n    \\n    function getUniswap() public view returns (P.Pool memory pool) {\\n        pool.pool = ETH_BEAN_ADDRESS;\\n        pool.tokens = TOKENS;\\n        // Bean, Eth\\n        uint256[2] memory reserves = _reserves();\\n        pool.balances = reserves;\\n        // USDC, Eth\\n        uint256[2] memory pegReserves = _pegReserves();\\n\\n        uint256[2] memory prices = getUniswapPrice(reserves, pegReserves);\\n        pool.price = prices[0];\\n        pool.liquidity = getUniswapUSDValue(reserves, prices);\\n        pool.deltaB = getUniswapDeltaB(reserves, pegReserves);\\n    }\\n    \\n    function getUniswapPrice(uint256[2] memory reserves, uint256[2] memory pegReserves) private pure returns (uint256[2] memory prices) {\\n        prices[1] = uint256(pegReserves[0]).mul(1e18).div(pegReserves[1]);\\n        prices[0] = reserves[1].mul(prices[1]).div(reserves[0]).div(1e12);\\n    }\\n\\n    function getUniswapUSDValue(uint256[2] memory balances, uint256[2] memory rates) private pure returns (uint) {\\n        return (balances[0].mul(rates[0]) + balances[1].mul(rates[1]).div(1e12)).div(1e6);\\n    }\\n\\n    function getUniswapDeltaB(uint256[2] memory reserves, uint256[2] memory pegReserves) private pure returns (int256) {\\n        uint256 newBeans = LibHelpers.sqrt(reserves[1].mul(reserves[0]).mul(pegReserves[0]).div(pegReserves[1]));\\n        return int256(newBeans) - int256(reserves[0]);\\n    }\\n\\n    function _reserves() private view returns (uint256[2] memory reserves) {\\n        (uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(ETH_BEAN_ADDRESS).getReserves();\\n        reserves = [uint256(reserve1), uint256(reserve0)];\\n    }\\n\\n    function _pegReserves() private view returns (uint256[2] memory reserves) {\\n        (uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(USDC_ETH_ADDRESS).getReserves();\\n        reserves = [uint256(reserve0), uint256(reserve1)];\\n    }\\n\\n    function sqrt(uint y) private pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/price/BeanLUSDPrice.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport { SafeMath } from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport {P} from \\\"./P.sol\\\";\\nimport \\\"./libraries/LibMetaCurve.sol\\\";\\nimport \\\"./libraries/LibHelpers.sol\\\";\\n\\ninterface IPlainPool {\\n    function A_precise() external view returns (uint256);\\n    function get_balances() external view returns (uint256[2] memory);\\n    // function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\\n    function get_dy_underlying(int128 i, int128 j, uint256 dx, uint256[2] calldata _balances) external view returns (uint256);\\n    function get_dy(int128 i, int128 j, uint256 dx, uint256[2] calldata _balances) external view returns (uint256);\\n}\\n\\ncontract BeanLUSDPrice {\\n\\n    using SafeMath for uint256;\\n\\n    //-------------------------------------------------------------------------------------------------------------------\\n    // Mainnet\\n    address private constant POOL = 0xD652c40fBb3f06d6B58Cb9aa9CFF063eE63d465D;\\n    address private constant BEAN_3CRV_POOL = 0x3a70DfA7d2262988064A2D051dd47521E43c9BdD;\\n    address private constant LUSD_3CRV_POOL = 0xEd279fDD11cA84bEef15AF5D39BB4d4bEE23F0cA;\\n    address private constant CRV3_POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\\n    //-------------------------------------------------------------------------------------------------------------------\\n    // Ropsten\\n    // address private constant POOL = TODO: Deploy BEAN_LUSD_POOL\\n    // address private constant BEAN_3CRV_POOL = 0x9ED0380C5dedadd3b2a32f5D5FD6B3929f8d39d9;\\n    // address private constant LUSD_3CRV_POOL = TODO: Deploy LUSD_CRV_POOL\\n    // address private constant CRV3_POOL = 0x6412bbCeEf0b384B7f8142BDafeFE119178F1E22;\\n    //-------------------------------------------------------------------------------------------------------------------\\n\\n    uint256 private constant A_PRECISION = 100; \\n    uint256 private constant N_COINS  = 2;\\n    uint256 private constant RATE_MULTIPLIER = 10 ** 30;\\n    uint256 private constant PRECISION = 1e18;\\n    uint256 private constant LUSD_RM = 1e24;\\n    uint256 private constant i = 0;\\n    uint256 private constant j = 1;\\n    uint256[2] private decimals = [6, 18];\\n    address[2] private tokens = [0xDC59ac4FeFa32293A95889Dc396682858d52e5Db, 0x5f98805A4E8be255a32880FDeC7F6728C6568bA0];\\n\\n    function getBeanLUSDCurve() public view returns (P.Pool memory pool) {\\n        pool.pool = POOL;\\n        pool.tokens = tokens;\\n\\n        uint256 bean3CrvPrice = LibMetaCurve.price(BEAN_3CRV_POOL, decimals[0]);\\n        uint256 lusd3CrvPrice = LibMetaCurve.price(LUSD_3CRV_POOL, decimals[1]);\\n\\n        uint256[2] memory balances = IPlainPool(POOL).get_balances();\\n        pool.balances = balances;\\n        uint256[2] memory rates = getPlainRates();\\n        uint256[2] memory xp = LibCurve.getXP(balances, rates);\\n        uint256 a = IPlainPool(POOL).A_precise();\\n        uint256 D = LibCurve.getD(xp, a);\\n        uint256 poolPrice = LibCurve.getCurvePrice(xp, rates, a, D);\\n        pool.price = poolPrice.mul(lusd3CrvPrice).div(1e18);\\n        pool.liquidity = getBeanLUSDCurveUSDValue(balances, [bean3CrvPrice*1e12, lusd3CrvPrice]);\\n        uint256 targetPrice = LUSD_RM.div(lusd3CrvPrice);\\n        pool.deltaB = getPlainPoolDeltaB(xp, D, a, targetPrice, poolPrice);\\n    }\\n\\n    struct DeltaB {\\n        uint256 pegBeans;\\n        int256 currentBeans;\\n        int256 deltaBToPeg;\\n        int256 deltaPriceToTarget;\\n        int256 deltaPriceToPeg;\\n        int256 estDeltaB;\\n        uint256 kBeansAtPeg; \\n    }\\n\\n    function getPlainPoolDeltaB(uint256[2] memory xp, uint256 D, uint256 a, uint256 targetPrice, uint256 poolPrice) private pure returns (int deltaB) {\\n        DeltaB memory db;\\n        db.currentBeans = int256(xp[0]);\\n        db.pegBeans = D / 2;\\n        db.deltaBToPeg = int256(db.pegBeans) - db.currentBeans;\\n        db.kBeansAtPeg = LibHelpers.sqrt(db.pegBeans * db.pegBeans * 1e6 / targetPrice);\\n\\n        uint256 prevPrice;\\n        uint256 x;\\n        uint256 x2;\\n\\n        for (uint256 k = 0; k < 256; k++) {\\n\\n            db.deltaPriceToTarget = int256(targetPrice) - int256(poolPrice);\\n            db.deltaPriceToPeg = 1e6 - int256(poolPrice);\\n            db.deltaBToPeg = int256(db.pegBeans) - int256(xp[0]);\\n            db.estDeltaB = (db.deltaBToPeg * int256(db.deltaPriceToTarget * 1e18 / db.deltaPriceToPeg)) / 1e18;\\n            x = uint256(int256(xp[0]) + db.estDeltaB);\\n            x2 = LibCurve.getY(x, xp, a, D);\\n            xp[0] = x;\\n            xp[1] = x2;\\n            prevPrice = poolPrice;\\n            poolPrice = LibCurve.getCurvePrice(xp, [RATE_MULTIPLIER, RATE_MULTIPLIER], a, D);\\n            if (prevPrice > poolPrice) {\\n                if (prevPrice - poolPrice <= 1) break;\\n            }\\n            else if (poolPrice - prevPrice <= 1) break;\\n        }\\n        deltaB = (int256(xp[0]) - db.currentBeans) / 1e12;\\n    }\\n\\n    function getBeanLUSDCurveUSDValue(uint256[2] memory balances, uint256[2] memory rates) private pure returns (uint) {\\n        uint256[2] memory value = LibCurve.getXP(balances, rates);\\n        return value[0] + (value[1] / 1e12);\\n    }\\n\\n    function getPlainRates() private view returns (uint256[2] memory rates) {\\n        return [10 ** (36-decimals[0]), 10 ** (36-decimals[1])];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/price/P.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ncontract P {\\n    struct Pool {\\n        address pool;\\n        address[2] tokens;\\n        uint256[2] balances;\\n        uint256 price;\\n        uint256 liquidity;\\n        int256 deltaB;\\n    }\\n\\n    struct Prices {\\n        address pool;\\n        address[] tokens;\\n        uint256 price;\\n        uint256 liquidity;\\n        int deltaB;\\n        P.Pool[] ps;\\n    }\\n}\"\r\n    },\r\n    \"contracts/price/libraries/LibMetaCurve.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: MIT\\n**/\\n\\npragma solidity ^0.8.4;\\n\\nimport { SafeMath } from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"./LibCurve.sol\\\";\\n\\ninterface I3Curve {\\n    function get_virtual_price() external view returns (uint256);\\n}\\n\\ninterface IMeta3Curve {\\n    function A_precise() external view returns (uint256);\\n    function get_previous_balances() external view returns (uint256[2] memory);\\n    function get_virtual_price() external view returns (uint256);\\n    function get_balances() external view returns (uint256[2] memory);\\n    function get_price_cumulative_last() external view returns (uint256[2] memory);\\n    function block_timestamp_last() external view returns (uint256);\\n    // function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\\n    function get_dy_underlying(int128 i, int128 j, uint256 dx, uint256[2] calldata _balances) external view returns (uint256);\\n    function get_dy(int128 i, int128 j, uint256 dx, uint256[2] calldata _balances) external view returns (uint256);\\n    \\n}\\n\\nlibrary LibMetaCurve {\\n    using SafeMath for uint256;\\n\\n    uint256 private constant A_PRECISION = 100;\\n    address private constant CRV3_POOL = address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);\\n    uint256 private constant N_COINS  = 2;\\n    uint256 private constant PRECISION = 1e18;\\n    uint256 private constant STEP = 1e6;\\n    uint256 private constant MAX_DECIMALS = 18;\\n    uint256 private constant i = 0;\\n    uint256 private constant j = 1;\\n\\n    function price(address pool, uint256 decimals) internal view returns (uint256 p) {\\n        uint256 a = IMeta3Curve(pool).A_precise();\\n        uint256[2] memory balances = IMeta3Curve(pool).get_previous_balances();\\n        uint256[2] memory xp = getXP(balances, 10 ** MAX_DECIMALS.sub(decimals));\\n        uint256 D =  LibCurve.getD(xp, a);\\n        p = LibCurve.getPrice(xp, a, D, 10**decimals);\\n    }\\n\\n    function getXP(uint256[2] memory balances, uint256 padding) internal view returns (uint256[2] memory xp) {\\n        xp = LibCurve.getXP(balances, padding, I3Curve(CRV3_POOL).get_virtual_price());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/price/libraries/LibCurve.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: MIT\\n**/\\n\\npragma solidity ^0.8.4;\\n\\nimport { SafeMath } from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n}\\n\\nlibrary LibCurve {\\n    using SafeMath for uint256;\\n\\n    uint256 private constant A_PRECISION = 100;\\n    uint256 private constant N_COINS  = 2;\\n    uint256 private constant PRECISION = 1e18;\\n    uint256 private constant MAX_DECIMALS = 18;\\n    uint256 private constant i = 0;\\n    uint256 private constant j = 1;\\n\\n    function getPrice(uint256[2] memory xp, uint256 a, uint256 D, uint256 padding) internal pure returns (uint) {\\n        uint256 x = xp[i] + padding;\\n        uint256 y = getY(x, xp, a, D);\\n        uint256 dy = xp[j] - y - 1;\\n        return dy;\\n    }\\n\\n    function getCurvePrice(uint256[2] memory xp, uint256[2] memory rates, uint256 a, uint256 D) internal pure returns (uint) {\\n        uint256 x = xp[i] + (1 * rates[i] / PRECISION);\\n        uint256 y = LibCurve.getY(x, xp, a, D);\\n        uint256 dy = xp[j] - y - 1;\\n        return dy / 1e6;\\n    }\\n\\n    function getY(uint256 x, uint256[2] memory xp, uint256 a, uint256 D) internal pure returns (uint256 y) {\\n        // Solution is taken from pool contract: 0x3a70DfA7d2262988064A2D051dd47521E43c9BdD\\n        uint256 S_ = 0;\\n        uint256 _x = 0;\\n        uint256 y_prev = 0;\\n        uint256 c = D;\\n        uint256 Ann = a * N_COINS;\\n\\n        for (uint256 _i = 0; _i < N_COINS; _i++) {\\n            if (_i == i) _x = x;\\n            else if (_i != j) _x = xp[_i];\\n            else continue;\\n            S_ += _x;\\n            c = c * D / (_x * N_COINS);\\n        }\\n\\n        c = c * D * A_PRECISION / (Ann * N_COINS);\\n        uint256 b = S_ + D * A_PRECISION / Ann; // - D\\n        y = D;\\n\\n        for (uint256 _i = 0; _i < 255; _i++) {\\n            y_prev = y;\\n            y = (y*y + c) / (2 * y + b - D);\\n            if (y > y_prev && y - y_prev <= 1) return y;\\n            else if (y_prev - y <= 1) return y;\\n        }\\n        require(false, \\\"Price: Convergence false\\\");\\n    }\\n\\n    function getD(uint256[2] memory xp, uint256 a) internal pure returns (uint D) {\\n        // Solution is taken from pool contract: 0x3a70DfA7d2262988064A2D051dd47521E43c9BdD\\n        uint256 S;\\n        uint256 Dprev;\\n        for (uint _i = 0; _i < xp.length; _i++) {\\n            S += xp[_i];\\n        }\\n        if (S == 0) return 0;\\n\\n        D = S;\\n        uint256 Ann = a * N_COINS;\\n        for (uint _i = 0; _i < 256; _i++) {\\n            uint256 D_P = D;\\n            for (uint _j = 0; _j < xp.length; _j++) {\\n                D_P = D_P * D / (xp[_j] * N_COINS);\\n            }\\n            Dprev = D;\\n            D = (Ann * S / A_PRECISION + D_P * N_COINS) * D / ((Ann - A_PRECISION) * D / A_PRECISION + (N_COINS + 1) * D_P);\\n            if (D > Dprev && D - Dprev <= 1) return D;\\n            else if (Dprev - D <= 1) return D;\\n        }\\n        require(false, \\\"Price: Convergence false\\\");\\n        return 0;\\n    }\\n\\n    function getXP(uint256[2] memory balances, uint256 padding, uint256 rate) internal pure returns (uint256[2] memory xp) {\\n        xp[0] = balances[0].mul(padding);\\n        xp[1] = balances[1].mul(rate).div(PRECISION);\\n    }\\n\\n    function getXP(uint256[2] memory balances, uint256[2] memory rates) internal pure returns (uint256[2] memory xp) {\\n        xp[0] = balances[0].mul(rates[0]).div(PRECISION);\\n        xp[1] = balances[1].mul(rates[1]).div(PRECISION);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/price/libraries/LibHelpers.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: MIT\\n**/\\n\\npragma solidity ^0.8.4;\\n\\nlibrary LibHelpers {\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"getBeanLUSDCurve\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address[2]\",\"name\":\"tokens\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"balances\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"deltaB\",\"type\":\"int256\"}],\"internalType\":\"struct P.Pool\",\"name\":\"pool\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurve\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address[2]\",\"name\":\"tokens\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"balances\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"deltaB\",\"type\":\"int256\"}],\"internalType\":\"struct P.Pool\",\"name\":\"pool\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUniswap\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address[2]\",\"name\":\"tokens\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"balances\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"deltaB\",\"type\":\"int256\"}],\"internalType\":\"struct P.Pool\",\"name\":\"pool\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"deltaB\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address[2]\",\"name\":\"tokens\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"balances\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"deltaB\",\"type\":\"int256\"}],\"internalType\":\"struct P.Pool[]\",\"name\":\"ps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct BeanstalkPrice.Prices\",\"name\":\"p\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BeanstalkPrice", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}