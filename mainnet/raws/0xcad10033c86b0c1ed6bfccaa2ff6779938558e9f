{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.11;\r\n\r\n/**\r\n * @title Library for working with strings\r\n * @author yearn.finance\r\n */\r\n\r\nlibrary String {\r\n    /**\r\n     * @notice Search for a needle in a haystack\r\n     * @param haystack The string to search\r\n     * @param needle The string to search for\r\n     */\r\n    function startsWith(string memory haystack, string memory needle)\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return indexOfStringInString(needle, haystack) == 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Find the index of a string in another string\r\n     * @param needle The string to search for\r\n     * @param haystack The string to search\r\n     * @return Returns -1 if no match is found, otherwise returns the index of the match\r\n     */\r\n    function indexOfStringInString(string memory needle, string memory haystack)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        bytes memory _needle = bytes(needle);\r\n        bytes memory _haystack = bytes(haystack);\r\n        if (_haystack.length < _needle.length) {\r\n            return -1;\r\n        }\r\n        bool _match;\r\n        for (\r\n            uint256 haystackIdx;\r\n            haystackIdx < _haystack.length;\r\n            haystackIdx++\r\n        ) {\r\n            for (uint256 needleIdx; needleIdx < _needle.length; needleIdx++) {\r\n                uint8 needleChar = uint8(_needle[needleIdx]);\r\n                if (haystackIdx + needleIdx >= _haystack.length) {\r\n                    return -1;\r\n                }\r\n                uint8 haystackChar = uint8(_haystack[haystackIdx + needleIdx]);\r\n                if (needleChar == haystackChar) {\r\n                    _match = true;\r\n                    if (needleIdx == _needle.length - 1) {\r\n                        return int256(haystackIdx);\r\n                    }\r\n                } else {\r\n                    _match = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * @notice Check to see if two strings are exactly equal\r\n     * @dev Supports strings of arbitrary length\r\n     * @param input0 First string to compare\r\n     * @param input1 Second string to compare\r\n     * @return Returns true if strings are exactly equal, false if not\r\n     */\r\n    function equal(string memory input0, string memory input1)\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint256 input0Length = bytes(input0).length;\r\n        uint256 input1Length = bytes(input1).length;\r\n        uint256 maxLength;\r\n        if (input0Length > input1Length) {\r\n            maxLength = input0Length;\r\n        } else {\r\n            maxLength = input1Length;\r\n        }\r\n        uint256 numberOfRowsToCompare = (maxLength / 32) + 1;\r\n        bytes32 input0Bytes32;\r\n        bytes32 input1Bytes32;\r\n        for (uint256 rowIdx; rowIdx < numberOfRowsToCompare; rowIdx++) {\r\n            uint256 offset = 0x20 * (rowIdx + 1);\r\n            assembly {\r\n                input0Bytes32 := mload(add(input0, offset))\r\n                input1Bytes32 := mload(add(input1, offset))\r\n            }\r\n            if (input0Bytes32 != input1Bytes32) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Convert ASCII to integer\r\n     * @param input Integer as a string (ie. \"345\")\r\n     * @param base Base to use for the conversion (10 for decimal)\r\n     * @return output Returns uint256 representation of input string\r\n     * @dev Based on GemERC721 utility but includes a fix\r\n     */\r\n    function atoi(string memory input, uint8 base)\r\n        public\r\n        pure\r\n        returns (uint256 output)\r\n    {\r\n        require(base == 2 || base == 8 || base == 10 || base == 16);\r\n        bytes memory buf = bytes(input);\r\n        for (uint256 idx = 0; idx < buf.length; idx++) {\r\n            uint8 digit = uint8(buf[idx]) - 0x30;\r\n            if (digit > 10) {\r\n                digit -= 7;\r\n            }\r\n            require(digit < base);\r\n            output *= base;\r\n            output += digit;\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * @notice Convert integer to ASCII\r\n     * @param input Integer as a string (ie. \"345\")\r\n     * @param base Base to use for the conversion (10 for decimal)\r\n     * @return output Returns string representation of input integer\r\n     * @dev Based on GemERC721 utility but includes a fix\r\n     */\r\n    function itoa(uint256 input, uint8 base)\r\n        public\r\n        pure\r\n        returns (string memory output)\r\n    {\r\n        require(base == 2 || base == 8 || base == 10 || base == 16);\r\n        if (input == 0) {\r\n            return \"0\";\r\n        }\r\n        bytes memory buf = new bytes(256);\r\n        uint256 idx = 0;\r\n        while (input > 0) {\r\n            uint8 digit = uint8(input % base);\r\n            uint8 ascii = digit + 0x30;\r\n            if (digit > 9) {\r\n                ascii += 7;\r\n            }\r\n            buf[idx++] = bytes1(ascii);\r\n            input /= base;\r\n        }\r\n        uint256 length = idx;\r\n        for (idx = 0; idx < length / 2; idx++) {\r\n            buf[idx] ^= buf[length - 1 - idx];\r\n            buf[length - 1 - idx] ^= buf[idx];\r\n            buf[idx] ^= buf[length - 1 - idx];\r\n        }\r\n        output = string(buf);\r\n    }\r\n\r\n    /**\r\n     * @notice Convert a string to lowercase\r\n     * @param input Input string\r\n     * @return Returns the string in lowercase\r\n     */\r\n    function lowercase(string memory input)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory _input = bytes(input);\r\n        for (uint256 inputIdx = 0; inputIdx < _input.length; inputIdx++) {\r\n            uint8 character = uint8(_input[inputIdx]);\r\n            if (character >= 65 && character <= 90) {\r\n                character += 0x20;\r\n                _input[inputIdx] = bytes1(character);\r\n            }\r\n        }\r\n        return string(_input);\r\n    }\r\n\r\n    /**\r\n     * @notice Convert a string to uppercase\r\n     * @param input Input string\r\n     * @return Returns the string in uppercase\r\n     */\r\n    function uppercase(string memory input)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory _input = bytes(input);\r\n        for (uint256 inputIdx = 0; inputIdx < _input.length; inputIdx++) {\r\n            uint8 character = uint8(_input[inputIdx]);\r\n            if (character >= 97 && character <= 122) {\r\n                character -= 0x20;\r\n                _input[inputIdx] = bytes1(character);\r\n            }\r\n        }\r\n        return string(_input);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine whether or not haystack contains needle\r\n     * @param haystack The string to search\r\n     * @param needle The substring to search for\r\n     * @return Returns true if needle exists in haystack, false if not\r\n     */\r\n    function contains(string memory haystack, string memory needle)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return indexOfStringInString(needle, haystack) >= 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Convert bytes32 to string and remove padding\r\n     * @param _bytes32 The input bytes32 data to convert\r\n     * @return Returns the string representation of the bytes32 data\r\n     */\r\n    function bytes32ToString(bytes32 _bytes32)\r\n        public\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        uint8 i = 0;\r\n        while (i < 32 && _bytes32[i] != 0) {\r\n            i++;\r\n        }\r\n        bytes memory bytesArray = new bytes(i);\r\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\r\n            bytesArray[i] = _bytes32[i];\r\n        }\r\n        return string(bytesArray);\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public ownerAddress;\r\n\r\n    constructor() {\r\n        ownerAddress = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == ownerAddress, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function setOwnerAddress(address _ownerAddress) public onlyOwner {\r\n        ownerAddress = _ownerAddress;\r\n    }\r\n}\r\n\r\n\r\ncontract AddressesProvider is Ownable {\r\n    mapping(uint256 => address) addressMap;\r\n    mapping(uint256 => string) addressIdMap;\r\n    uint256 addressesLength;\r\n\r\n    struct AddressMetadata {\r\n        string addrId;\r\n        address addr;\r\n    }\r\n\r\n    function setAddress(AddressMetadata memory addressMetadata)\r\n        public\r\n        onlyOwner\r\n    {\r\n        string memory addressId = addressMetadata.addrId;\r\n        address addr = addressMetadata.addr;\r\n        uint256 upsertPosition = addressesLength;\r\n        int256 addressPosition = addressPositionById(addressId);\r\n        if (addressPosition >= 0) {\r\n            upsertPosition = uint256(addressPosition);\r\n        } else {\r\n            addressIdMap[upsertPosition] = addressId;\r\n            addressesLength++;\r\n        }\r\n        addressMap[upsertPosition] = addr;\r\n    }\r\n\r\n    function setAddresses(AddressMetadata[] memory _addressesMetadata)\r\n        public\r\n        onlyOwner\r\n    {\r\n        for (\r\n            uint256 addressMetadataIdx;\r\n            addressMetadataIdx < _addressesMetadata.length;\r\n            addressMetadataIdx++\r\n        ) {\r\n            AddressMetadata memory addressMetadata = _addressesMetadata[\r\n                addressMetadataIdx\r\n            ];\r\n            setAddress(addressMetadata);\r\n        }\r\n    }\r\n\r\n    function addressPositionById(string memory addressId)\r\n        public\r\n        view\r\n        returns (int256)\r\n    {\r\n        for (uint256 addressIdx; addressIdx < addressesLength; addressIdx++) {\r\n            string memory currentAddressId = addressIdMap[addressIdx];\r\n            if (String.equal(addressId, currentAddressId)) {\r\n                return int256(addressIdx);\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    function addressById(string memory addressId)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return addressMap[uint256(addressPositionById(addressId))];\r\n    }\r\n\r\n    function addresses() external view returns (address[] memory) {\r\n        address[] memory _addresses = new address[](addressesLength);\r\n        for (uint256 addressIdx; addressIdx < addressesLength; addressIdx++) {\r\n            _addresses[addressIdx] = addressMap[addressIdx];\r\n        }\r\n        return _addresses;\r\n    }\r\n\r\n    function addressesIds() external view returns (string[] memory) {\r\n        string[] memory _addressesIds = new string[](addressesLength);\r\n        for (uint256 addressIdx; addressIdx < addressesLength; addressIdx++) {\r\n            _addressesIds[addressIdx] = addressIdMap[addressIdx];\r\n        }\r\n        return _addressesIds;\r\n    }\r\n\r\n    function addressesMetadata()\r\n        external\r\n        view\r\n        returns (AddressMetadata[] memory)\r\n    {\r\n        AddressMetadata[] memory _addressesMetadata = new AddressMetadata[](\r\n            addressesLength\r\n        );\r\n        for (uint256 addressIdx; addressIdx < addressesLength; addressIdx++) {\r\n            _addressesMetadata[addressIdx] = AddressMetadata({\r\n                addrId: addressIdMap[addressIdx],\r\n                addr: addressMap[addressIdx]\r\n            });\r\n        }\r\n        return _addressesMetadata;\r\n    }\r\n\r\n    function addressesMetadataByIdStartsWith(string memory addressIdSubstring)\r\n        external\r\n        view\r\n        returns (AddressMetadata[] memory)\r\n    {\r\n        AddressMetadata[] memory _addressesMetadata = new AddressMetadata[](\r\n            addressesLength\r\n        );\r\n        uint256 _addressesLength;\r\n        for (uint256 addressIdx; addressIdx < addressesLength; addressIdx++) {\r\n            string memory addressId = addressIdMap[addressIdx];\r\n            bool foundMatch = String.startsWith(addressId, addressIdSubstring);\r\n            if (foundMatch) {\r\n                _addressesMetadata[_addressesLength] = AddressMetadata({\r\n                    addrId: addressIdMap[addressIdx],\r\n                    addr: addressMap[addressIdx]\r\n                });\r\n                _addressesLength++;\r\n            }\r\n        }\r\n        bytes memory encodedAddresses = abi.encode(_addressesMetadata);\r\n        assembly {\r\n            mstore(add(encodedAddresses, 0x40), _addressesLength)\r\n        }\r\n        AddressMetadata[] memory filteredAddresses = abi.decode(\r\n            encodedAddresses,\r\n            (AddressMetadata[])\r\n        );\r\n        return filteredAddresses;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"input\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"base\",\"type\":\"uint8\"}],\"name\":\"atoi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_bytes32\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"input0\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"input1\",\"type\":\"string\"}],\"name\":\"equal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"needle\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"haystack\",\"type\":\"string\"}],\"name\":\"indexOfStringInString\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"base\",\"type\":\"uint8\"}],\"name\":\"itoa\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"output\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"haystack\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"needle\",\"type\":\"string\"}],\"name\":\"startsWith\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "String", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://af9467c4cc893a3b434c48334d3221c7f46dbd6e7179c4fcdc0d7806dfed07be"}]}