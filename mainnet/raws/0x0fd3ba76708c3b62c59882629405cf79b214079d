{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface IRelayer {\n    enum RelayerType {\n        DiscountRate,\n        SpotPrice,\n        COUNT\n    }\n\n    function execute() external returns (bool);\n\n    function executeWithRevert() external;\n}interface IOracle {\n    function value() external view returns (int256, bool);\n\n    function update() external returns (bool);\n}// Lightweight interface for Collybus\n// Source: https://github.com/fiatdao/fiat-lux/blob/f49a9457fbcbdac1969c35b4714722f00caa462c/src/interfaces/ICollybus.sol\ninterface ICollybus {\n    function updateDiscountRate(uint256 tokenId_, uint256 rate_) external;\n\n    function updateSpot(address token_, uint256 spot_) external;\n}/// @title Guarded\n/// @notice Mixin implementing an authentication scheme on a method level\nabstract contract Guarded {\n    /// ======== Custom Errors ======== ///\n\n    error Guarded__notRoot();\n    error Guarded__notGranted();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Wildcard for granting a caller to call every guarded method\n    bytes32 public constant ANY_SIG = keccak256(\"ANY_SIG\");\n    /// @notice Wildcard for granting a caller to call every guarded method\n    address public constant ANY_CALLER =\n        address(uint160(uint256(bytes32(keccak256(\"ANY_CALLER\")))));\n\n    /// @notice Mapping storing who is granted to which method\n    /// @dev Method Signature => Caller => Bool\n    mapping(bytes32 => mapping(address => bool)) private _canCall;\n\n    /// ======== Events ======== ///\n\n    event AllowCaller(bytes32 sig, address who);\n    event BlockCaller(bytes32 sig, address who);\n\n    constructor() {\n        // set root\n        _setRoot(msg.sender);\n    }\n\n    /// ======== Auth ======== ///\n\n    modifier callerIsRoot() {\n        if (_canCall[ANY_SIG][msg.sender]) {\n            _;\n        } else revert Guarded__notRoot();\n    }\n\n    modifier checkCaller() {\n        if (canCall(msg.sig, msg.sender)) {\n            _;\n        } else revert Guarded__notGranted();\n    }\n\n    /// @notice Grant the right to call method `sig` to `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig_ Method signature (4Byte)\n    /// @param who_ Address of who should be able to call `sig`\n    function allowCaller(bytes32 sig_, address who_) public callerIsRoot {\n        _canCall[sig_][who_] = true;\n        emit AllowCaller(sig_, who_);\n    }\n\n    /// @notice Revoke the right to call method `sig` from `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig_ Method signature (4Byte)\n    /// @param who_ Address of who should not be able to call `sig` anymore\n    function blockCaller(bytes32 sig_, address who_) public callerIsRoot {\n        _canCall[sig_][who_] = false;\n        emit BlockCaller(sig_, who_);\n    }\n\n    /// @notice Returns if `who` can call `sig`\n    /// @param sig_ Method signature (4Byte)\n    /// @param who_ Address of who should be able to call `sig`\n    function canCall(bytes32 sig_, address who_) public view returns (bool) {\n        return (_canCall[sig_][who_] ||\n            _canCall[ANY_SIG][who_] ||\n            _canCall[sig_][ANY_CALLER]);\n    }\n\n    /// @notice Sets the root user (granted `ANY_SIG`)\n    /// @param root_ Address of who should be set as root\n    function _setRoot(address root_) internal {\n        _canCall[ANY_SIG][root_] = true;\n        emit AllowCaller(ANY_SIG, root_);\n    }\n}\n/// @notice The Relayer contract manages the relationship between an oracle and Collybus.\n/// The Relayer manages an Oracle for which it controls the update flow and via execute() calls\n/// pushes data to Collybus when it's needed\n/// @dev The Relayer should be the single entity that updates the oracle so that the Relayer and the Oracle\n/// are value synched. The same is true for the Relayer-Collybus relationship as we do not interrogate the Collybus\n/// for the current value and use a storage cached last updated value.\ncontract Relayer is Guarded, IRelayer {\n    /// @notice Emitter during executeWithRevert() if the oracle is not updated successfully\n    error Relayer__executeWithRevert_noUpdate(RelayerType relayerType);\n\n    /// @notice Emitted when trying to set a parameter that does not exist\n    error Relayer__setParam_unrecognizedParam(bytes32 param);\n\n    event SetParam(bytes32 param, uint256 value);\n    event UpdateOracle(address oracle, int256 value, bool valid);\n    event UpdatedCollybus(bytes32 tokenId, uint256 rate, RelayerType);\n\n    /// ======== Storage ======== ///\n\n    address public immutable collybus;\n    RelayerType public immutable relayerType;\n    address public immutable oracle;\n    bytes32 public immutable encodedTokenId;\n\n    uint256 public minimumPercentageDeltaValue;\n    int256 private _lastUpdateValue;\n\n    /// @param collybusAddress_ Address of the collybus\n    /// @param type_ Relayer type, DiscountRate or SpotPrice\n    /// @param oracleAddress_ The address of the oracle used by the Relayer\n    /// @param encodedTokenId_ Encoded token Id that will be used to push values to Collybus\n    /// uint256 for discount rate, address for spot price\n    /// @param minimumPercentageDeltaValue_ Minimum delta value used to determine when to\n    /// push data to Collybus\n    constructor(\n        address collybusAddress_,\n        RelayerType type_,\n        address oracleAddress_,\n        bytes32 encodedTokenId_,\n        uint256 minimumPercentageDeltaValue_\n    ) {\n        collybus = collybusAddress_;\n        relayerType = type_;\n        oracle = oracleAddress_;\n        encodedTokenId = encodedTokenId_;\n        minimumPercentageDeltaValue = minimumPercentageDeltaValue_;\n        _lastUpdateValue = 0;\n    }\n\n    /// @notice Sets a Relayer parameter\n    /// Supported parameters are:\n    /// - minimumPercentageDeltaValue\n    /// @param param_ The identifier of the parameter that should be updated\n    /// @param value_ The new value\n    /// @dev Reverts if parameter is not found\n    function setParam(bytes32 param_, uint256 value_) public checkCaller {\n        if (param_ == \"minimumPercentageDeltaValue\") {\n            minimumPercentageDeltaValue = value_;\n        } else revert Relayer__setParam_unrecognizedParam(param_);\n\n        emit SetParam(param_, value_);\n    }\n\n    /// @notice Updates the oracle and pushes the updated data to Collybus if the\n    /// delta change in value is bigger than the minimum threshold value.\n    /// @return Whether the Collybus was updated or not\n    function execute() public override(IRelayer) returns (bool) {\n        // We always update the oracles before retrieving the rates\n        bool oracleUpdated = IOracle(oracle).update();\n        (int256 oracleValue, bool isValid) = IOracle(oracle).value();\n\n        // If the oracle was not updated, the value is invalid or the delta condition is not met, we can exit early\n        if (\n            !oracleUpdated ||\n            !isValid ||\n            !checkDeviation(\n                _lastUpdateValue,\n                oracleValue,\n                minimumPercentageDeltaValue\n            )\n        ) {\n            // Collybus was not updated so we return false\n            return false;\n        }\n\n        _lastUpdateValue = oracleValue;\n\n        if (relayerType == RelayerType.DiscountRate) {\n            ICollybus(collybus).updateDiscountRate(\n                uint256(encodedTokenId),\n                uint256(oracleValue)\n            );\n        } else if (relayerType == RelayerType.SpotPrice) {\n            ICollybus(collybus).updateSpot(\n                address(uint160(uint256(encodedTokenId))),\n                uint256(oracleValue)\n            );\n        }\n\n        emit UpdatedCollybus(encodedTokenId, uint256(oracleValue), relayerType);\n\n        // Collybus was updated\n        return true;\n    }\n\n    /// @notice The function will call `execute()` and will revert if the oracle was not updated\n    /// @dev This method is needed for services that run on each block and only call the method if it doesn't fail\n    function executeWithRevert() public override(IRelayer) {\n        if (!execute()) {\n            revert Relayer__executeWithRevert_noUpdate(relayerType);\n        }\n    }\n\n    /// @notice Returns true if the percentage difference between the two values is bigger than the `percentage`\n    /// @param baseValue_ The value that the percentage is based on\n    /// @param newValue_ The new value\n    /// @param percentage_ The percentage threshold value (100% = 100_00, 50% = 50_00, etc)\n    function checkDeviation(\n        int256 baseValue_,\n        int256 newValue_,\n        uint256 percentage_\n    ) public pure returns (bool) {\n        int256 deviation = (baseValue_ * int256(percentage_)) / 100_00;\n\n        if (\n            baseValue_ + deviation <= newValue_ ||\n            baseValue_ - deviation >= newValue_\n        ) return true;\n\n        return false;\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collybusAddress_\",\"type\":\"address\"},{\"internalType\":\"enum IRelayer.RelayerType\",\"name\":\"type_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"oracleAddress_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"encodedTokenId_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"minimumPercentageDeltaValue_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Guarded__notGranted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Guarded__notRoot\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum IRelayer.RelayerType\",\"name\":\"relayerType\",\"type\":\"uint8\"}],\"name\":\"Relayer__executeWithRevert_noUpdate\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"param\",\"type\":\"bytes32\"}],\"name\":\"Relayer__setParam_unrecognizedParam\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sig\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AllowCaller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sig\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"BlockCaller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"param\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetParam\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"name\":\"UpdateOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IRelayer.RelayerType\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"UpdatedCollybus\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ANY_CALLER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ANY_SIG\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sig_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"who_\",\"type\":\"address\"}],\"name\":\"allowCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sig_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"who_\",\"type\":\"address\"}],\"name\":\"blockCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sig_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"who_\",\"type\":\"address\"}],\"name\":\"canCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"baseValue_\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"newValue_\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"percentage_\",\"type\":\"uint256\"}],\"name\":\"checkDeviation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collybus\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"encodedTokenId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executeWithRevert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumPercentageDeltaValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayerType\",\"outputs\":[{\"internalType\":\"enum IRelayer.RelayerType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"param_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"}],\"name\":\"setParam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Relayer", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "8000", "ConstructorArguments": "000000000000000000000000d503383ffabbec8eb85eaed448fe1ffec0a8148a0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000dc7509b74a397ad4b2405da877442d901d535037000000000000000000000000ed279fdd11ca84beef15af5d39bb4d4bee23f0ca0000000000000000000000000000000000000000000000000000000000000019", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}