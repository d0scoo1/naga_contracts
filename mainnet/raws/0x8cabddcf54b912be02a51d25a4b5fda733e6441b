{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface ITreasury {\\r\\n    function updateTaxesAccrued(uint taxType, uint amt) external;\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external;\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external;\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\nstruct Slot0 {\\r\\n    // the current price\\r\\n    uint160 sqrtPriceX96;\\r\\n    // the current tick\\r\\n    int24 tick;\\r\\n    // the most-recently updated index of the observations array\\r\\n    uint16 observationIndex;\\r\\n    // the current maximum number of observations that are being stored\\r\\n    uint16 observationCardinality;\\r\\n    // the next maximum number of observations to store, triggered in observations.write\\r\\n    uint16 observationCardinalityNext;\\r\\n    // the current protocol fee as a percentage of the swap fee taken on withdrawal\\r\\n    // represented as an integer denominator (1/x)%\\r\\n    uint8 feeProtocol;\\r\\n    // whether the pool is locked\\r\\n    bool unlocked;\\r\\n}\\r\\n\\r\\ninterface IUniPool {\\r\\n    function slot0() external returns(Slot0 memory slot0);\\r\\n    function liquidity() external returns(uint128 liquidity);\\r\\n    function fee() external returns(uint24 fee);\\r\\n    function token0() external returns(address token0);\\r\\n    function token1() external returns(address token1);\\r\\n    function tickSpacing() external returns(int24 tickSpacing);\\r\\n    function tickBitmap(int16 i) external payable returns(uint256 o);\\r\\n}\\r\\n\\r\\n\\r\\ninterface ILiquidityPoolV4 {\\r\\n\\r\\n}\\r\\n\\r\\ninterface IDapperTri {\\r\\n    function get_paid(\\r\\n        address[3] memory _route, \\r\\n        uint8[3] memory _exchanges, \\r\\n        uint24[4] memory _poolFees, \\r\\n        address _borrow, \\r\\n        uint _borrowAmt\\r\\n    ) external;\\r\\n}\\r\\n\\r\\nstruct ExactInputSingleParams {\\r\\n    address tokenIn;\\r\\n    address tokenOut;\\r\\n    uint24 fee;\\r\\n    address recipient;\\r\\n    uint256 deadline;\\r\\n    uint256 amountIn;\\r\\n    uint256 amountOutMinimum;\\r\\n    uint160 sqrtPriceLimitX96;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function getAmountsOut(\\r\\n        uint amountIn, \\r\\n        address[] calldata path\\r\\n    ) external view returns (uint[] memory amounts);\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n}\\r\\n\\r\\ninterface IUniswapQuoterV3 {\\r\\n    function quoteExactInputSingle(\\r\\n        address tokenIn,\\r\\n        address tokenOut,\\r\\n        uint24 fee,\\r\\n        uint256 amountIn,\\r\\n        uint160 sqrtPriceLimitX96\\r\\n    ) external view returns (uint256 amountOut);\\r\\n}\\r\\n\\r\\ninterface IUniswapRouterV3 {\\r\\n    function exactInputSingle(\\r\\n        ExactInputSingleParams calldata params\\r\\n    ) external payable returns (uint256 amountOut);\\r\\n}\\r\\n\\r\\n// https://etherscan.io/address/0x2F9EC37d6CcFFf1caB21733BdaDEdE11c823cCB0#code\\r\\ninterface IBancorNetwork {\\r\\n     function conversionPath(\\r\\n         IERC20 _sourceToken, \\r\\n         IERC20 _targetToken\\r\\n    ) external view returns (address[] memory);\\r\\n    function convert(\\r\\n        address[] memory path,\\r\\n        uint256 sourceAmount,\\r\\n        uint256 minReturn\\r\\n    ) external payable returns (uint256);\\r\\n    function convertByPath(\\r\\n        address[] memory path,\\r\\n        uint256 sourceAmount,\\r\\n        uint256 minReturn,\\r\\n        address payable beneficiary,\\r\\n        address affiliate,\\r\\n        uint256 affiliateFee\\r\\n    ) external payable returns (uint256);\\r\\n    function rateByPath(\\r\\n        address[] memory path, \\r\\n        uint256 sourceAmount\\r\\n    ) external view returns (uint256);\\r\\n}\\r\\n\\r\\n// https://etherscan.io/address/0x8301ae4fc9c624d1d396cbdaa1ed877821d7c511#code (ETH/CRV)\\r\\n// https://etherscan.io/address/0xDC24316b9AE028F1497c275EB9192a3Ea0f67022#code (ETH/stETH)\\r\\ninterface ICRVMetaPool {\\r\\n    // i = token_from\\r\\n    // j = token_to\\r\\n    // dx = token_from_change\\r\\n    // min_dy = token_to_min_receive\\r\\n    // function get_dy(int128 i, int128 j, uint256 dx) external view returns(uint256); \\r\\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns(uint256); \\r\\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external payable returns(uint256); \\r\\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy, bool use_eth) external payable returns(uint256);\\r\\n    function exchange_underlying(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external payable returns(uint256);\\r\\n    function add_liquidity(uint256[] memory amounts_in, uint256 min_mint_amount) external payable returns(uint256);\\r\\n    function remove_liquidity(uint256 amount, uint256[] memory min_amounts_out) external returns(uint256[] memory);\\r\\n}\\r\\n\\r\\ninterface ICRV {\\r\\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external payable; \\r\\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy, bool use_eth) external payable;\\r\\n}\\r\\n\\r\\ninterface ICRV_PP_128_NP {\\r\\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\\r\\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns(uint256);\\r\\n}\\r\\ninterface ICRV_PP_256_NP {\\r\\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy, bool use_eth) external;\\r\\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns(uint256);\\r\\n}\\r\\ninterface ICRV_PP_256_P {\\r\\n    function exchange_underlying(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external payable returns(uint256);\\r\\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns(uint256);\\r\\n}\\r\\ninterface ICRV_MP_256 {\\r\\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external payable returns(uint256);\\r\\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external payable returns(uint256);\\r\\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns(uint256);\\r\\n}\\r\\n\\r\\ninterface ICRVSBTC {\\r\\n    // i = token_from\\r\\n    // j = token_to\\r\\n    // dx = token_from_change\\r\\n    // min_dy = token_to_min_receive\\r\\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns(uint256); \\r\\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns(uint256); \\r\\n    function add_liquidity(uint256[3] memory amounts_in, uint256 min_mint_amount) external;\\r\\n    function remove_liquidity(uint256 amount, uint256[3] memory min_amounts_out) external;\\r\\n    function remove_liquidity_one_coin(uint256 token_amount, int128 index, uint min_amount) external;\\r\\n}\\r\\n\\r\\ninterface ICRVSBTC_CRV {\\r\\n    // i = token_from\\r\\n    // j = token_to\\r\\n    // dx = token_from_change\\r\\n    // min_dy = token_to_min_receive\\r\\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns(uint256); \\r\\n    // function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns(uint256);\\r\\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy, address _receiver) external; \\r\\n    function add_liquidity(uint256[3] memory amounts_in, uint256 min_mint_amount) external;\\r\\n    function remove_liquidity(uint256 amount, uint256[3] memory min_amounts_out) external;\\r\\n    function remove_liquidity_one_coin(uint256 token_amount, int128 index, uint min_amount) external;\\r\\n}\\r\\n\\r\\n// https://etherscan.io/address/0xd9e1ce17f2641f24ae83637ab66a2cca9c378b9f#code\\r\\ninterface ISushiRouter {\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function getAmountsOut(\\r\\n        uint amountIn, \\r\\n        address[] calldata path\\r\\n    ) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\n// https://etherscan.io/address/0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0#code\\r\\ninterface IWSTETH {\\r\\n    function wrap(uint256 _stETHAmount) external returns (uint256);\\r\\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IVault {\\r\\n    function flashLoan(\\r\\n        IFlashLoanRecipient recipient,\\r\\n        IERC20[] memory tokens,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory userData\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ninterface IFlashLoanRecipient {\\r\\n    function receiveFlashLoan(\\r\\n        IERC20[] memory tokens,\\r\\n        uint256[] memory amounts,\\r\\n        uint256[] memory feeAmounts,\\r\\n        bytes memory userData\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ninterface IWETH {\\r\\n    function deposit() external payable;\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function withdraw(uint) external;\\r\\n}\"},\"TaxToken.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\nimport { ITreasury, IUniswapV2Factory, IUniswapV2Router01 } from \\\"./ERC20.sol\\\";\\r\\n\\r\\n/// @dev    The TaxToken is responsible for supporting generic ERC20 functionality including ERC20Pausable functionality.\\r\\n///         The TaxToken will generate taxes on transfer() and transferFrom() calls for non-whitelisted addresses.\\r\\n///         The Admin can specify the tax fee in basis points for buys, sells, and transfers.\\r\\n///         The TaxToken will forward all taxes generated to a Treasury\\r\\ncontract TaxToken {\\r\\n \\r\\n    // ---------------\\r\\n    // State Variables\\r\\n    // ---------------\\r\\n\\r\\n    // ERC20 Basic\\r\\n    uint256 _totalSupply;\\r\\n    uint8 private _decimals;\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    // ERC20 Pausable\\r\\n    bool private _paused;  // ERC20 Pausable state\\r\\n\\r\\n    // Extras\\r\\n    address public owner;\\r\\n    address public treasury;\\r\\n    address public UNIV2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\n\\r\\n    bool public taxesRemoved;   /// @dev Once true, taxes are permanently set to 0 and CAN NOT be increased in the future.\\r\\n\\r\\n    uint256 public maxWalletSize;\\r\\n    uint256 public maxTxAmount;\\r\\n\\r\\n    // ERC20 Mappings\\r\\n    mapping(address =\\u003e uint256) balances;                       // Track balances.\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) allowed;    // Track allowances.\\r\\n\\r\\n    // Extras Mappings\\r\\n    mapping(address =\\u003e bool) public blacklist;          /// @dev If an address is blacklisted, they cannot perform transfer() or transferFrom().\\r\\n    mapping(address =\\u003e bool) public whitelist;          /// @dev Any transfer that involves a whitelisted address, will not incur a tax.\\r\\n    mapping(address =\\u003e uint) public senderTaxType;      /// @dev  Identifies tax type for msg.sender of transfer() call.\\r\\n    mapping(address =\\u003e uint) public receiverTaxType;    /// @dev  Identifies tax type for _to of transfer() call.\\r\\n    mapping(uint =\\u003e uint) public basisPointsTax;        /// @dev  Mapping between taxType and basisPoints (taxed).\\r\\n\\r\\n\\r\\n\\r\\n    // -----------\\r\\n    // Constructor\\r\\n    // -----------\\r\\n\\r\\n    /// @notice Initializes the TaxToken.\\r\\n    /// @param  totalSupplyInput    The total supply of this token (this value is multipled by 10**decimals in constructor).\\r\\n    /// @param  nameInput           The name of this token.\\r\\n    /// @param  symbolInput         The symbol of this token.\\r\\n    /// @param  decimalsInput       The decimal precision of this token.\\r\\n    /// @param  maxWalletSizeInput  The maximum wallet size (this value is multipled by 10**decimals in constructor).\\r\\n    /// @param  maxTxAmountInput    The maximum tx size (this value is multipled by 10**decimals in constructor).\\r\\n    constructor(\\r\\n        uint totalSupplyInput, \\r\\n        string memory nameInput, \\r\\n        string memory symbolInput, \\r\\n        uint8 decimalsInput,\\r\\n        uint256 maxWalletSizeInput,\\r\\n        uint256 maxTxAmountInput\\r\\n    ) {\\r\\n        _paused = false;    // ERC20 Pausable global state variable, initial state is not paused (\\\"unpaused\\\").\\r\\n        _name = nameInput;\\r\\n        _symbol = symbolInput;\\r\\n        _decimals = decimalsInput;\\r\\n        _totalSupply = totalSupplyInput * 10**_decimals;\\r\\n\\r\\n        // Create a uniswap pair for this new token\\r\\n        address UNISWAP_V2_PAIR = IUniswapV2Factory(\\r\\n            IUniswapV2Router01(UNIV2_ROUTER).factory()\\r\\n        ).createPair(address(this), IUniswapV2Router01(UNIV2_ROUTER).WETH());\\r\\n \\r\\n        senderTaxType[UNISWAP_V2_PAIR] = 1;\\r\\n        receiverTaxType[UNISWAP_V2_PAIR] = 2;\\r\\n\\r\\n        owner = msg.sender;                                         // The \\\"owner\\\" is the \\\"admin\\\" of this contract.\\r\\n        balances[msg.sender] = totalSupplyInput * 10**_decimals;    // Initial liquidity, allocated entirely to \\\"owner\\\".\\r\\n        maxWalletSize = maxWalletSizeInput * 10**_decimals;\\r\\n        maxTxAmount = maxTxAmountInput * 10**_decimals;      \\r\\n    }\\r\\n\\r\\n \\r\\n\\r\\n    // ---------\\r\\n    // Modifiers\\r\\n    // ---------\\r\\n\\r\\n    /// @dev whenNotPausedUni() is used if the contract MUST be paused (\\\"paused\\\").\\r\\n    modifier whenNotPausedUni(address a) {\\r\\n        require(!paused() || whitelist[a], \\\"ERR: Contract is currently paused.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev whenNotPausedDual() is used if the contract MUST be paused (\\\"paused\\\").\\r\\n    modifier whenNotPausedDual(address from, address to) {\\r\\n        require(!paused() || whitelist[from] || whitelist[to], \\\"ERR: Contract is currently paused.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev whenNotPausedTri() is used if the contract MUST be paused (\\\"paused\\\").\\r\\n    modifier whenNotPausedTri(address from, address to, address sender) {\\r\\n        require(!paused() || whitelist[from] || whitelist[to] || whitelist[sender], \\\"ERR: Contract is currently paused.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev whenPaused() is used if the contract MUST NOT be paused (\\\"unpaused\\\").\\r\\n    modifier whenPaused() {\\r\\n        require(paused(), \\\"ERR: Contract is not currently paused.\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /// @dev onlyOwner() is used if msg.sender MUST be owner.\\r\\n    modifier onlyOwner {\\r\\n       require(msg.sender == owner, \\\"ERR: TaxToken.sol, onlyOwner()\\\"); \\r\\n       _;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    // ------\\r\\n    // Events\\r\\n    // ------\\r\\n\\r\\n    event Paused(address account);          /// @dev Emitted when the pause is triggered by `account`.\\r\\n    event Unpaused(address account);        /// @dev Emitted when the pause is lifted by `account`.\\r\\n\\r\\n    /// @dev Emitted when approve() is called.\\r\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);   \\r\\n \\r\\n    /// @dev Emitted during transfer() or transferFrom().\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\r\\n    event TransferTax(address indexed _from, address indexed _to, uint256 _value, uint256 _taxType);\\r\\n\\r\\n\\r\\n\\r\\n    // ---------\\r\\n    // Functions\\r\\n    // ---------\\r\\n\\r\\n\\r\\n    // ~ ERC20 View ~\\r\\n    \\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _owner) public view returns (uint256 balance) {\\r\\n        return balances[_owner];\\r\\n    }\\r\\n \\r\\n    // ~ ERC20 transfer(), transferFrom(), approve() ~\\r\\n\\r\\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\\r\\n        allowed[msg.sender][_spender] = _amount;\\r\\n        emit Approval(msg.sender, _spender, _amount);\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    function transfer(address _to, uint256 _amount) public whenNotPausedDual(msg.sender, _to) returns (bool success) {  \\r\\n\\r\\n        // taxType 0 =\\u003e Xfer Tax\\r\\n        // taxType 1 =\\u003e Buy Tax\\r\\n        // taxType 2 =\\u003e Sell Tax\\r\\n        uint _taxType;\\r\\n\\r\\n        if (balances[msg.sender] \\u003e= _amount \\u0026\\u0026 (!blacklist[msg.sender] \\u0026\\u0026 !blacklist[_to])) {\\r\\n\\r\\n            // Take a tax from them if neither party is whitelisted.\\r\\n            if (!whitelist[_to] \\u0026\\u0026 !whitelist[msg.sender] \\u0026\\u0026 _amount \\u003c= maxTxAmount) {\\r\\n\\r\\n                // Determine, if not the default 0, tax type of transfer.\\r\\n                if (senderTaxType[msg.sender] != 0) {\\r\\n                    _taxType = senderTaxType[msg.sender];\\r\\n                }\\r\\n\\r\\n                if (receiverTaxType[_to] != 0) {\\r\\n                    _taxType = receiverTaxType[_to];\\r\\n                }\\r\\n\\r\\n                // Calculate taxAmt and sendAmt.\\r\\n                uint _taxAmt = _amount * basisPointsTax[_taxType] / 10000;\\r\\n                uint _sendAmt = _amount * (10000 - basisPointsTax[_taxType]) / 10000;\\r\\n\\r\\n                if (balances[_to] + _sendAmt \\u003c= maxWalletSize) {\\r\\n\\r\\n                    balances[msg.sender] -= _amount;\\r\\n                    balances[_to] += _sendAmt;\\r\\n                    balances[treasury] += _taxAmt;\\r\\n\\r\\n                    require(_taxAmt + _sendAmt \\u003e= _amount * 999999999 / 1000000000, \\\"Critical error, math.\\\");\\r\\n                \\r\\n                    // Update accounting in Treasury.\\r\\n                    ITreasury(treasury).updateTaxesAccrued(\\r\\n                        _taxType, _taxAmt\\r\\n                    );\\r\\n                    \\r\\n                    emit Transfer(msg.sender, _to, _sendAmt);\\r\\n                    emit TransferTax(msg.sender, treasury, _taxAmt, _taxType);\\r\\n\\r\\n                    return true;\\r\\n                }\\r\\n\\r\\n                else {\\r\\n                    return false;\\r\\n                }\\r\\n\\r\\n            }\\r\\n\\r\\n            else if (!whitelist[_to] \\u0026\\u0026 !whitelist[msg.sender] \\u0026\\u0026 _amount \\u003e maxTxAmount) {\\r\\n                return false;\\r\\n            }\\r\\n\\r\\n            else {\\r\\n                balances[msg.sender] -= _amount;\\r\\n                balances[_to] += _amount;\\r\\n                emit Transfer(msg.sender, _to, _amount);\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n \\r\\n    function transferFrom(address _from, address _to, uint256 _amount) public whenNotPausedTri(_from, _to, msg.sender) returns (bool success) {\\r\\n\\r\\n        // taxType 0 =\\u003e Xfer Tax\\r\\n        // taxType 1 =\\u003e Buy Tax\\r\\n        // taxType 2 =\\u003e Sell Tax\\r\\n        uint _taxType;\\r\\n\\r\\n        if (\\r\\n            balances[_from] \\u003e= _amount \\u0026\\u0026 \\r\\n            allowed[_from][msg.sender] \\u003e= _amount \\u0026\\u0026 \\r\\n            _amount \\u003e 0 \\u0026\\u0026 balances[_to] + _amount \\u003e balances[_to] \\u0026\\u0026 \\r\\n            _amount \\u003c= maxTxAmount \\u0026\\u0026 (!blacklist[_from] \\u0026\\u0026 !blacklist[_to])\\r\\n        ) {\\r\\n            \\r\\n            // Reduce allowance.\\r\\n            allowed[_from][msg.sender] -= _amount;\\r\\n\\r\\n            // Take a tax from them if neither party is whitelisted.\\r\\n            if (!whitelist[_to] \\u0026\\u0026 !whitelist[_from] \\u0026\\u0026 _amount \\u003c= maxTxAmount) {\\r\\n\\r\\n                // Determine, if not the default 0, tax type of transfer.\\r\\n                if (senderTaxType[_from] != 0) {\\r\\n                    _taxType = senderTaxType[_from];\\r\\n                }\\r\\n\\r\\n                if (receiverTaxType[_to] != 0) {\\r\\n                    _taxType = receiverTaxType[_to];\\r\\n                }\\r\\n\\r\\n                // Calculate taxAmt and sendAmt.\\r\\n                uint _taxAmt = _amount * basisPointsTax[_taxType] / 10000;\\r\\n                uint _sendAmt = _amount * (10000 - basisPointsTax[_taxType]) / 10000;\\r\\n\\r\\n                if (balances[_to] + _sendAmt \\u003c= maxWalletSize || _taxType == 2) {\\r\\n\\r\\n                    balances[_from] -= _amount;\\r\\n                    balances[_to] += _sendAmt;\\r\\n                    balances[treasury] += _taxAmt;\\r\\n\\r\\n                    require(_taxAmt + _sendAmt == _amount, \\\"Critical error, math.\\\");\\r\\n                \\r\\n                    // Update accounting in Treasury.\\r\\n                    ITreasury(treasury).updateTaxesAccrued(\\r\\n                        _taxType, _taxAmt\\r\\n                    );\\r\\n                    \\r\\n                    emit Transfer(_from, _to, _sendAmt);\\r\\n                    emit TransferTax(_from, treasury, _taxAmt, _taxType);\\r\\n\\r\\n                    return true;\\r\\n                }\\r\\n                \\r\\n                else {\\r\\n                    return false;\\r\\n                }\\r\\n\\r\\n            }\\r\\n\\r\\n            else if (!whitelist[_to] \\u0026\\u0026 !whitelist[_from] \\u0026\\u0026 _amount \\u003e maxTxAmount) {\\r\\n                return false;\\r\\n            }\\r\\n\\r\\n            // Skip taxation if either party is whitelisted (_from or _to).\\r\\n            else {\\r\\n                balances[_from] -= _amount;\\r\\n                balances[_to] += _amount;\\r\\n                emit Transfer(_from, _to, _amount);\\r\\n                return true;\\r\\n            }\\r\\n\\r\\n        }\\r\\n        else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\\r\\n        return allowed[_owner][_spender];\\r\\n    }\\r\\n\\r\\n\\r\\n    // ~ ERC20 Pausable ~\\r\\n\\r\\n    /// @notice Pause the contract, blocks transfer() and transferFrom().\\r\\n    /// @dev    Contract MUST NOT be paused to call this, caller must be \\\"owner\\\".\\r\\n    function pause() public onlyOwner whenNotPausedUni(msg.sender) {\\r\\n        _paused = true;\\r\\n        emit Paused(msg.sender);\\r\\n    }\\r\\n\\r\\n    /// @notice Unpause the contract.\\r\\n    /// @dev    Contract MUST be puased to call this, caller must be \\\"owner\\\".\\r\\n    function unpause() public onlyOwner whenPaused {\\r\\n        _paused = false;\\r\\n        emit Unpaused(msg.sender);\\r\\n    }\\r\\n\\r\\n    /// @return _paused Indicates whether the contract is paused (true) or not paused (false).\\r\\n    function paused() public view virtual returns (bool) {\\r\\n        return _paused;\\r\\n    }\\r\\n\\r\\n    \\r\\n    // ~ TaxType \\u0026 Fee Management ~\\r\\n\\r\\n    /// @notice     Used to store the LP Pair to differ type of transaction. Will be used to mark a BUY.\\r\\n    /// @dev        _taxType must be lower than 3 because there can only be 3 tax types; buy, sell, \\u0026 send.\\r\\n    /// @param      _sender This value is the PAIR address.\\r\\n    /// @param      _taxType This value must be be 0, 1, or 2. Best to correspond value with the BUY tax type.\\r\\n    function updateSenderTaxType(address _sender, uint _taxType) public onlyOwner {\\r\\n        require(_taxType \\u003c 3, \\\"err _taxType must be less than 3\\\");\\r\\n        senderTaxType[_sender] = _taxType;\\r\\n    }\\r\\n\\r\\n    /// @notice     Used to store the LP Pair to differ type of transaction. Will be used to mark a SELL.\\r\\n    /// @dev        _taxType must be lower than 3 because there can only be 3 tax types; buy, sell, \\u0026 send.\\r\\n    /// @param      _receiver This value is the PAIR address.\\r\\n    /// @param      _taxType This value must be be 0, 1, or 2. Best to correspond value with the SELL tax type.\\r\\n    function updateReceiverTaxType(address _receiver, uint _taxType) public onlyOwner {\\r\\n        require(_taxType \\u003c 3, \\\"err _taxType must be less than 3\\\");\\r\\n        receiverTaxType[_receiver] = _taxType;\\r\\n    }\\r\\n\\r\\n    /// @notice     Used to map the tax type 0, 1 or 2 with it\\u0027s corresponding tax percentage.\\r\\n    /// @dev        Must be lower than 2000 which is equivalent to 20%.\\r\\n    /// @param      _taxType This value is the tax type. Has to be 0, 1, or 2.\\r\\n    /// @param      _bpt This is the corresponding percentage that is taken for royalties. 1200 = 12%.\\r\\n    function adjustBasisPointsTax(uint _taxType, uint _bpt) public onlyOwner {\\r\\n        require(_bpt \\u003c= 2000, \\\"err TaxToken.sol _bpt \\u003e 2000 (20%)\\\");\\r\\n        require(!taxesRemoved, \\\"err TaxToken.sol taxation has been removed\\\");\\r\\n        basisPointsTax[_taxType] = _bpt;\\r\\n    }\\r\\n\\r\\n    /// @notice Permanently remove taxes from this contract.\\r\\n    /// @dev    An input is required here for sanity-check, given importance of this function call (and irreversible nature).\\r\\n    /// @param  _key This value MUST equal 42 for function to execute.\\r\\n    function permanentlyRemoveTaxes(uint _key) public onlyOwner {\\r\\n        require(_key == 42, \\\"err TaxToken.sol _key != 42\\\");\\r\\n        basisPointsTax[0] = 0;\\r\\n        basisPointsTax[1] = 0;\\r\\n        basisPointsTax[2] = 0;\\r\\n        taxesRemoved = true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ~ Admin ~\\r\\n\\r\\n    /// @notice This is used to change the owner\\u0027s wallet address. Used to give ownership to another wallet.\\r\\n    /// @param  _owner is the new owner address.\\r\\n    function transferOwnership(address _owner) public onlyOwner {\\r\\n        owner = _owner;\\r\\n    }\\r\\n\\r\\n    /// @notice Set the treasury (contract)) which receives taxes generated through transfer() and transferFrom().\\r\\n    /// @param  _treasury is the contract address of the treasury.\\r\\n    function setTreasury(address _treasury) public onlyOwner {\\r\\n        treasury = _treasury;\\r\\n    }\\r\\n\\r\\n    /// @notice Adjust maxTxAmount value (maximum amount transferrable in a single transaction).\\r\\n    /// @dev    Does not affect whitelisted wallets.\\r\\n    /// @param  _maxTxAmount is the max amount of tokens that can be transacted at one time for a non-whitelisted wallet.\\r\\n    function updateMaxTxAmount(uint256 _maxTxAmount) public onlyOwner {\\r\\n        maxTxAmount = (_maxTxAmount * 10**_decimals);\\r\\n    }\\r\\n\\r\\n    /// @notice This function is used to set the max amount of tokens a wallet can hold.\\r\\n    /// @dev    Does not affect whitelisted wallets.\\r\\n    /// @param  _maxWalletSize is the max amount of tokens that can be held on a non-whitelisted wallet.\\r\\n    function updateMaxWalletSize(uint256 _maxWalletSize) public onlyOwner {\\r\\n        maxWalletSize = (_maxWalletSize * 10**_decimals);\\r\\n    }\\r\\n\\r\\n    /// @notice This function is used to add wallets to the whitelist mapping.\\r\\n    /// @dev    Whitelisted wallets are not affected by maxWalletSize, maxTxAmount, and taxes.\\r\\n    /// @param  _wallet is the wallet address that will have their whitelist status modified.\\r\\n    /// @param  _whitelist use True to whitelist a wallet, otherwise use False to remove wallet from whitelist.\\r\\n    function modifyWhitelist(address _wallet, bool _whitelist) public onlyOwner {\\r\\n        whitelist[_wallet] = _whitelist;\\r\\n    }\\r\\n\\r\\n    /// @notice This function is used to add or remove wallets from the blacklist.\\r\\n    /// @dev    Blacklisted wallets cannot perform transfer() or transferFrom().\\r\\n    /// @param  _wallet is the wallet address that will have their blacklist status modified.\\r\\n    /// @param  _blacklist use True to blacklist a wallet, otherwise use False to remove wallet from blacklist.\\r\\n    function modifyBlacklist(address _wallet, bool _blacklist) public onlyOwner {\\r\\n        blacklist[_wallet] = _blacklist;\\r\\n    }\\r\\n    \\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupplyInput\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"nameInput\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbolInput\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimalsInput\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maxWalletSizeInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTxAmountInput\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_taxType\",\"type\":\"uint256\"}],\"name\":\"TransferTax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"UNIV2_ROUTER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_taxType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bpt\",\"type\":\"uint256\"}],\"name\":\"adjustBasisPointsTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"basisPointsTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_blacklist\",\"type\":\"bool\"}],\"name\":\"modifyBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_whitelist\",\"type\":\"bool\"}],\"name\":\"modifyWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_key\",\"type\":\"uint256\"}],\"name\":\"permanentlyRemoveTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"receiverTaxType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"senderTaxType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxesRemoved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTxAmount\",\"type\":\"uint256\"}],\"name\":\"updateMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxWalletSize\",\"type\":\"uint256\"}],\"name\":\"updateMaxWalletSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_taxType\",\"type\":\"uint256\"}],\"name\":\"updateReceiverTaxType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_taxType\",\"type\":\"uint256\"}],\"name\":\"updateSenderTaxType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TaxToken", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000011e1a30000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000009896800000000000000000000000000000000000000000000000000000000011e1a300000000000000000000000000000000000000000000000000000000000000000c526f79616c20526963686573000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000035258320000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7ccf312d49798bc45eec5cc80bef87f78084ea4b604d9363e2da29d567746380"}]}