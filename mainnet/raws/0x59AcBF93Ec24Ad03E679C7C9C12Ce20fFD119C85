{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/DopamineHonoraryTab.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\nimport { IDopamineHonoraryTab } from \\\"./interfaces/IDopamineHonoraryTab.sol\\\";\\nimport { IOpenSeaProxyRegistry } from \\\"./interfaces/IOpenSeaProxyRegistry.sol\\\";\\nimport { ERC721H } from \\\"./erc721/ERC721H.sol\\\";\\nimport \\\"./Errors.sol\\\";\\n\\n/// @title Dopamine honorary ERC-721 membership tab\\n/// @notice Dopamine honorary tabs are vanity tabs for friends of Dopamine.\\ncontract DopamineHonoraryTab is ERC721H, IDopamineHonoraryTab {\\n\\n    /// @notice The address administering minting and metadata settings.\\n    address public owner;\\n\\n    /// @notice The OS registry address - allowlisted for gasless OS approvals.\\n    IOpenSeaProxyRegistry public proxyRegistry;\\n\\n    /// @notice The URI each tab initially points to for metadata resolution.\\n    /// @dev Before drop completion, `tokenURI()` resolves to \\\"{baseURI}/{id}\\\".\\n    string public baseURI = \\\"https://api.dopamine.xyz/honoraries/metadata/\\\";\\n\\n    /// @notice The permanent URI tabs will point to on collection finality.\\n    /// @dev After drop completion, `tokenURI()` directs to \\\"{storageURI}/{id}\\\".\\n    string public storageURI;\\n\\n    /// @notice Restricts a function call to address `owner`.\\n    modifier onlyOwner() {\\n        if (msg.sender != owner) {\\n            revert OwnerOnly();\\n        }\\n        _;\\n    }\\n\\n    /// @notice Instantiates a new Dopamine honorary membership tab contract.\\n    /// @param proxyRegistry_ The OpenSea proxy registry address.\\n    /// @param reserve_ Address to which EIP-2981 royalties direct to.\\n    /// @param royalties_ Royalties sent to `reserve_` on sales, in bips.\\n    constructor(\\n        IOpenSeaProxyRegistry proxyRegistry_,\\n        address reserve_,\\n        uint96 royalties_\\n    ) ERC721H(\\\"Dopamine Honorary Tabs\\\", \\\"HDOPE\\\") {\\n        owner = msg.sender;\\n        proxyRegistry = proxyRegistry_;\\n        _setRoyalties(reserve_, royalties_);\\n    }\\n\\n    /// @inheritdoc IDopamineHonoraryTab\\n    function mint(address to) external onlyOwner {\\n        return _mint(owner, to);\\n    }\\n\\n    /// @inheritdoc IDopamineHonoraryTab\\n    function contractURI() external view returns (string memory)  {\\n        return string(abi.encodePacked(baseURI, \\\"contract\\\"));\\n    }\\n\\n    /// @inheritdoc IDopamineHonoraryTab\\n    function setOwner(address newOwner) external onlyOwner {\\n        owner = newOwner;\\n        emit OwnerChanged(owner, newOwner);\\n    }\\n\\n    /// @inheritdoc IDopamineHonoraryTab\\n    function setBaseURI(string calldata newBaseURI) external onlyOwner {\\n        baseURI = newBaseURI;\\n        emit BaseURISet(newBaseURI);\\n    }\\n\\n    /// @inheritdoc IDopamineHonoraryTab\\n    function setStorageURI(string calldata newStorageURI) external onlyOwner {\\n        storageURI = newStorageURI;\\n        emit StorageURISet(newStorageURI);\\n    }\\n\\n    /// @inheritdoc IDopamineHonoraryTab\\n    function setRoyalties(\\n        address receiver,\\n        uint96 royalties\\n    ) external onlyOwner {\\n        _setRoyalties(receiver, royalties);\\n    }\\n\\n    /// @inheritdoc ERC721H\\n    /// @dev Before all honoraries are minted, the token URI for tab of id `id`\\n    ///  defaults to {baseURI}/{id}. Once all honoraries are minted, this will\\n    ///  be replaced with a decentralized storage URI (Arweave / IPFS) given by\\n    ///  {storageURI}/{id}. If `id` does not exist, this function reverts.\\n    /// @param id The id of the NFT being queried.\\n    function tokenURI(uint256 id)\\n        public\\n        view\\n        virtual\\n        override(ERC721H)\\n        returns (string memory)\\n    {\\n        if (ownerOf[id] == address(0)) {\\n            revert TokenNonExistent();\\n        }\\n\\n        string memory uri = storageURI;\\n        if (bytes(uri).length == 0) {\\n            uri = baseURI;\\n        }\\n        return string(abi.encodePacked(uri, _toString(id)));\\n    }\\n\\n    /// @dev Ensures OS proxy is allowlisted for operating on behalf of owners.\\n    /// @inheritdoc ERC721H\\n    function isApprovedForAll(address owner, address operator)\\n    public\\n    view\\n        override\\n        returns (bool)\\n    {\\n        return\\n            proxyRegistry.proxies(owner) == operator ||\\n            _operatorApprovals[owner][operator];\\n    }\\n\\n    /// @dev Converts a uint256 into a string.\\n    /// @param value A positive uint256 value.\\n    function _toString(uint256 value) internal pure returns (string memory) {\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IDopamineHonoraryTab.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\nimport \\\"./IDopamineHonoraryTabEvents.sol\\\";\\n\\n/// @title Dopamine ERC-721 honorary membership tab interface\\ninterface IDopamineHonoraryTab is IDopamineHonoraryTabEvents {\\n\\n    /// @notice Mints an honorary Dopamine tab to address `to`.\\n    /// @dev This function is only callable by the owner address.\\n    function mint(address to) external;\\n\\n    /// @notice Gets the owner address, which controls minting and metadata.\\n    function owner() external view returns (address);\\n\\n    /// @notice Retrieves a URI describing the overall contract-level metadata.\\n    /// @return A string URI pointing to the tab contract metadata.\\n    function contractURI() external view returns (string memory);\\n\\n    /// @notice Sets the owner address to `newOwner`.\\n    /// @param newOwner The address of the new owner.\\n    /// @dev This function is only callable by the owner address.\\n    function setOwner(address newOwner) external;\\n\\n    /// @notice Sets the base URI to `newBaseURI`.\\n    /// @param newBaseURI The new base metadata URI to set for the collection.\\n    /// @dev This function is only callable by the owner address.\\n    function setBaseURI(string calldata newBaseURI) external;\\n\\n    /// @notice Sets the permanent storage URI to `newStorageURI`.\\n    /// @param newStorageURI The new permanent URI to set for the collection.\\n    /// @dev This function is only callable by the owner address.\\n    function setStorageURI(string calldata newStorageURI) external;\\n\\n    /// @notice Sets the EIP-2981 royalties for the NFT collection.\\n    /// @param receiver Address to which royalties will be received.\\n    /// @param royalties The amount of royalties to receive, in bips.\\n    /// @dev This function is only callable by the owner address.\\n    function setRoyalties(address receiver, uint96 royalties) external;\\n\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOpenSeaProxyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @title OpenSea proxy registry interface\\ninterface IOpenSeaProxyRegistry {\\n\\n    /// @notice Returns the proxy account associated with an OS user address.\\n    function proxies(address) external view returns (address);\\n\\n}\\n\"\r\n    },\r\n    \"src/erc721/ERC721H.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// Transfer & minting methods derive from ERC721.sol of solmate.\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC721Metadata} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport {IERC2981} from \\\"../interfaces/IERC2981.sol\\\";\\n\\nimport \\\"../Errors.sol\\\";\\n\\n/// @title ERC-721 contract built for Dopamine honorary tabs.\\n/// @notice This is a minimal ERC-721 implementation that supports the metadata\\n///  extension, total supply tracking, and EIP-2981 royalties.\\n/// @dev This ERC-721 implementation is optimized for mints and transfers of\\n///  individual NFTs, as opposed to mints and transfers of NFT batches.\\ncontract ERC721H is IERC721, IERC721Metadata, IERC2981 {\\n\\n    /// @notice The name of this NFT collection.\\n    string public name;\\n\\n    /// @notice The abbreviated name of this NFT collection.\\n    string public symbol;\\n\\n    /// @notice The total number of NFTs in circulation.\\n    uint256 public totalSupply;\\n\\n    /// @notice Gets the number of NFTs owned by an address.\\n    /// @dev This implementation does not throw for zero-address queries.\\n    mapping(address => uint256) public balanceOf;\\n\\n    /// @notice Gets the assigned owner of an address.\\n    /// @dev This implementation does not throw for NFTs of the zero address.\\n    mapping(uint256 => address) public ownerOf;\\n\\n    /// @notice Gets the approved address for an NFT.\\n    /// @dev This implementation does not throw for zero-address queries.\\n    mapping(uint256 => address) public getApproved;\\n\\n    /// @dev Checks for an owner if an address is an authorized operator.\\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\\n\\n    // EIP-2981 collection-wide royalties information.\\n    RoyaltiesInfo internal _royaltiesInfo;\\n\\n    // EIP-165 identifiers for all supported interfaces.\\n    bytes4 private constant _ERC165_INTERFACE_ID = 0x01ffc9a7;\\n    bytes4 private constant _ERC721_INTERFACE_ID = 0x80ac58cd;\\n    bytes4 private constant _ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\\n    bytes4 private constant _ERC2981_METADATA_INTERFACE_ID = 0x2a55205a;\\n\\n    /// @notice Instantiates a new ERC-721 contract.\\n    /// @param name_ The name of the NFT.\\n    /// @param symbol_ The abbreviated name of the NFT.\\n    constructor(\\n        string memory name_,\\n        string memory symbol_\\n    ) {\\n        name = name_;\\n        symbol = symbol_;\\n    }\\n\\n    /// @notice Transfers NFT of id `id` from address `from` to address `to`,\\n    ///  with safety checks ensuring `to` is capable of receiving the NFT.\\n    /// @dev Safety checks are only performed if `to` is a smart contract.\\n    /// @param from The existing owner address of the NFT to be transferred.\\n    /// @param to The address of the new owner of the NFT to be transferred.\\n    /// @param id The id of the NFT being transferred.\\n    /// @param data Additional transfer data to pass to the receiving contract.\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) external {\\n        transferFrom(from, to, id);\\n\\n        if (\\n            to.code.length != 0 &&\\n                IERC721Receiver(to).onERC721Received(msg.sender, from, id, data)\\n                !=\\n                IERC721Receiver.onERC721Received.selector\\n        ) {\\n            revert SafeTransferUnsupported();\\n        }\\n    }\\n\\n    /// @notice Transfers NFT of id `id` from address `from` to address `to`,\\n    ///  with safety checks ensuring `to` is capable of receiving the NFT.\\n    /// @dev Safety checks are only performed if `to` is a smart contract.\\n    /// @param from The existing owner address of the NFT to be transferred.\\n    /// @param to The address of the new owner of the NFT to be transferred.\\n    /// @param id The id of the NFT being transferred.\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        transferFrom(from, to, id);\\n\\n        if (\\n            to.code.length != 0 &&\\n                IERC721Receiver(to).onERC721Received(msg.sender, from, id, \\\"\\\")\\n                !=\\n                IERC721Receiver.onERC721Received.selector\\n        ) {\\n            revert SafeTransferUnsupported();\\n        }\\n    }\\n\\n    /// @inheritdoc IERC2981\\n    function royaltyInfo(\\n        uint256,\\n        uint256 salePrice\\n    ) external view returns (address, uint256) {\\n        RoyaltiesInfo memory royaltiesInfo = _royaltiesInfo;\\n        uint256 royalties = (salePrice * royaltiesInfo.royalties) / 10000;\\n        return (royaltiesInfo.receiver, royalties);\\n    }\\n\\n    /// @notice Transfers NFT of id `id` from address `from` to address `to`,\\n    ///  without performing any safety checks.\\n    /// @dev Existence of an NFT is inferred by having a non-zero owner address.\\n    ///  Transfers clear owner approvals, but `Approval` events are omitted.\\n    /// @param from The existing owner address of the NFT to be transferred.\\n    /// @param to The address of the new owner of the NFT to be transferred.\\n    /// @param id The id of the NFT being transferred.\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public {\\n        if (from != ownerOf[id]) {\\n            revert OwnerInvalid();\\n        }\\n\\n        if (\\n            msg.sender != from &&\\n            msg.sender != getApproved[id] &&\\n            !_operatorApprovals[from][msg.sender]\\n        ) {\\n            revert SenderUnauthorized();\\n        }\\n\\n        if (to == address(0)) {\\n            revert ReceiverInvalid();\\n        }\\n\\n        delete getApproved[id];\\n\\n        unchecked {\\n            balanceOf[from]--;\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n        emit Transfer(from, to, id);\\n    }\\n\\n    /// @notice Sets approved address of NFT of id `id` to address `approved`.\\n    /// @param approved The new approved address for the NFT.\\n    /// @param id The id of the NFT to approve.\\n    function approve(address approved, uint256 id) public virtual {\\n        address owner = ownerOf[id];\\n\\n        if (msg.sender != owner && !_operatorApprovals[owner][msg.sender]) {\\n            revert SenderUnauthorized();\\n        }\\n\\n        getApproved[id] = approved;\\n        emit Approval(owner, approved, id);\\n    }\\n\\n    /// @notice Checks if `operator` is an authorized operator for `owner`.\\n    /// @param owner The address of the owner.\\n    /// @param operator The address for the owner's operator.\\n    /// @return True if `operator` is approved operator of `owner`, else false.\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual returns (bool)\\n    {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /// @notice Sets the operator for `msg.sender` to `operator`.\\n    /// @param operator The operator address that will manage the sender's NFTs.\\n    /// @param approved Whether operator is allowed to operate on sender's NFTs.\\n    function setApprovalForAll(address operator, bool approved) public {\\n        _operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /// @notice Returns the metadata URI associated with the NFT of id `id`.\\n    /// @return A string URI pointing to the metadata of the queried NFT.\\n    function tokenURI(uint256) public view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /// @notice Checks if interface of identifier `id` is supported.\\n    /// @param id The EIP-165 interface identifier.\\n    /// @return True if interface id `id` is supported, false otherwise.\\n    function supportsInterface(bytes4 id) public pure virtual returns (bool) {\\n        return\\n            id == _ERC165_INTERFACE_ID ||\\n            id == _ERC721_INTERFACE_ID ||\\n            id == _ERC721_METADATA_INTERFACE_ID ||\\n            id == _ERC2981_METADATA_INTERFACE_ID;\\n    }\\n\\n    /// @notice Mints NFT of id `totalSupply + 1` to address `to`.\\n    /// @param creator Address to which NFT creation attribution is assigned.\\n    /// @param to Address receiving the minted NFT.\\n    function _mint(address creator, address to) internal {\\n        if (to == address(0)) {\\n            revert ReceiverInvalid();\\n        }\\n\\n        unchecked {\\n            totalSupply++;\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[totalSupply] = to;\\n        emit Transfer(address(0), creator, totalSupply);\\n        emit Transfer(creator, to, totalSupply);\\n    }\\n\\n    /// @notice Sets EIP-2981 royalty information for NFTs in the collection.\\n    /// @param receiver Address which will receive token royalties.\\n    /// @param royalties Amount of royalties to be sent, in bips.\\n    function _setRoyalties(address receiver, uint96 royalties) internal {\\n        if (royalties > 10000) {\\n            revert RoyaltiesTooHigh();\\n        }\\n        if (receiver == address(0)) {\\n            revert ReceiverInvalid();\\n        }\\n        _royaltiesInfo = RoyaltiesInfo(receiver, royalties);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"src/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n// This file is a shared repository of all errors used in Dopamine's contracts.\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                               DopamineTab                               ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Configured drop delay is invalid.\\nerror DropDelayInvalid();\\n\\n/// @notice Drop hit allocated capacity.\\nerror DropMaxCapacity();\\n\\n/// @notice No such drop exists.\\nerror DropNonExistent();\\n\\n/// @notice Action cannot be completed as a current drop is ongoing.\\nerror DropOngoing();\\n\\n/// @notice Configured drop size is invalid.\\nerror DropSizeInvalid();\\n\\n/// @notice Insufficient time passed since the last drop was created.\\nerror DropTooEarly();\\n\\n/// @notice Configured allowlist size is too large.\\nerror DropAllowlistOverCapacity();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                          Dopamine Auction House                          ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Auction has already been settled.\\nerror AuctionAlreadySettled();\\n\\n/// @notice The NFT specified in the auction bid is invalid.\\nerror AuctionBidInvalid();\\n\\n/// @notice Bid placed was too low.\\nerror AuctionBidTooLow();\\n\\n/// @notice Auction duration set is invalid.\\nerror AuctionDurationInvalid();\\n\\n/// @notice The auction has expired.\\nerror AuctionExpired();\\n\\n/// @notice Operation cannot be performed as auction is not yet suspended.\\nerror AuctionNotSuspended();\\n\\n/// @notice Operation cannot be performed as auction is already suspended.\\nerror AuctionAlreadySuspended();\\n\\n/// @notice Auction has yet to complete.\\nerror AuctionOngoing();\\n\\n/// @notice Reserve price set is invalid.\\nerror AuctionReservePriceInvalid();\\n\\n/// @notice Time buffer set is invalid.\\nerror AuctionTimeBufferInvalid();\\n\\n/// @notice Treasury split is invalid as it must be in the range [0, 100].\\nerror AuctionTreasurySplitInvalid();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                              Miscellaneous                               ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Mismatch between input arrays.\\nerror ArityMismatch();\\n\\n/// @notice Block number being queried is invalid.\\nerror BlockInvalid();\\n\\n/// @notice Reentrancy vulnerability.\\nerror FunctionReentrant();\\n\\n/// @notice Number does not fit into 32 bytes.\\nerror Uint32ConversionInvalid();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                                 Upgrades                                 ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Contract already initialized.\\nerror ContractAlreadyInitialized();\\n\\n/// @notice Upgrade is unauthorized.\\nerror UpgradeUnauthorized();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                                 EIP-712                                  ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Signature has expired.\\nerror SignatureExpired();\\n\\n/// @notice Signature is invalid.\\nerror SignatureInvalid();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                                 EIP-721                                  ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Originating address does not own the NFT.\\nerror OwnerInvalid();\\n\\n/// @notice Receiving address cannot be the zero address.\\nerror ReceiverInvalid();\\n\\n/// @notice Receiving contract does not implement the EIP-721 wallet interface.\\nerror SafeTransferUnsupported();\\n\\n/// @notice Sender is not NFT owner, approved address, or owner operator.\\nerror SenderUnauthorized();\\n\\n/// @notice NFT collection has hit maximum supply capacity.\\nerror SupplyMaxCapacity();\\n\\n/// @notice Token has already minted.\\nerror TokenAlreadyMinted();\\n\\n/// @notice NFT does not exist.\\nerror TokenNonExistent();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                              Administrative                              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Function callable only by the admin.\\nerror AdminOnly();\\n\\n/// @notice Function callable only by the minter.\\nerror MinterOnly();\\n\\n/// @notice Function callable only by the owner.\\nerror OwnerOnly();\\n\\n/// @notice Function callable only by the pending owner.\\nerror PendingAdminOnly();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                                Governance                                ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Invalid number of actions proposed.\\nerror ProposalActionCountInvalid();\\n\\n/// @notice Proposal has already been settled.\\nerror ProposalAlreadySettled();\\n\\n/// @notice Inactive proposals may not be voted for.\\nerror ProposalInactive();\\n\\n/// @notice Proposal has failed to or has yet to be queued.\\nerror ProposalNotYetQueued();\\n\\n/// @notice Quorum threshold is invalid.\\nerror ProposalQuorumThresholdInvalid();\\n\\n/// @notice Proposal threshold is invalid.\\nerror ProposalThresholdInvalid();\\n\\n/// @notice Proposal has failed to or has yet to pass.\\nerror ProposalUnpassed();\\n\\n/// @notice A proposal is currently running and must be settled first.\\nerror ProposalUnsettled();\\n\\n/// @notice Voting delay set is invalid.\\nerror ProposalVotingDelayInvalid();\\n\\n/// @notice Voting period set is invalid.\\nerror ProposalVotingPeriodInvalid();\\n\\n/// @notice Only the proposer may invoke this action.\\nerror ProposerOnly();\\n\\n/// @notice Function callable only by the vetoer.\\nerror VetoerOnly();\\n\\n/// @notice Veto power has been revoked.\\nerror VetoPowerRevoked();\\n\\n/// @notice Proposal vote has already been cast.\\nerror VoteAlreadyCast();\\n\\n/// @notice Vote type is not valid.\\nerror VoteInvalid();\\n\\n/// @notice Voting power insufficient.\\nerror VotingPowerInsufficient();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                                 Timelock                                 ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Invalid set timelock delay.\\nerror TimelockDelayInvalid();\\n\\n/// @notice Function callable only by the timelock itself.\\nerror TimelockOnly();\\n\\n/// @notice Duplicate transaction queued.\\nerror TransactionAlreadyQueued();\\n\\n/// @notice Transaction is not yet queued.\\nerror TransactionNotYetQueued();\\n\\n/// @notice Transaction executed prematurely.\\nerror TransactionPremature();\\n\\n/// @notice Transaction execution was reverted.\\nerror TransactionReverted();\\n\\n/// @notice Transaction is stale.\\nerror TransactionStale();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                             Merkle Whitelist                             ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Proof for claim is invalid.\\nerror ProofInvalid();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                           EIP-2981 Royalties                             ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Royalties are set too high.\\nerror RoyaltiesTooHigh();\\n\"\r\n    },\r\n    \"src/interfaces/IDopamineHonoraryTabEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @title Dopamine ERC-721 honorary membership tab events interface\\ninterface IDopamineHonoraryTabEvents {\\n\\n    /// @notice Emits when the Dopamine tab base URI is set to `baseUri`.\\n    /// @param baseURI The base URI of the tab contract, as a string.\\n    event BaseURISet(string baseURI);\\n\\n    /// @notice Emits when owner is changed from `oldOwner` to `newOwner`.\\n    /// @param oldOwner The address of the previous owner.\\n    /// @param newOwner The address of the new owner.\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @notice Emits when the Dopamine tab storage URI is set to `StorageUri`.\\n    /// @param storageURI The storage URI of the tab contract, as a string.\\n    event StorageURISet(string storageURI);\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @title Interface for the ERC-2981 royalties standard.\\ninterface IERC2981 {\\n\\n/// @notice RoyaltiesInfo stores token royalties information.\\nstruct RoyaltiesInfo {\\n\\n    /// @notice The address to which royalties will be directed.\\n    address receiver;\\n\\n    /// @notice The royalties amount, in bips.\\n    uint96 royalties;\\n\\n}\\n\\n    /// @notice Returns the address to which royalties are received along with\\n    ///  the royalties amount to be paid to them for a given sale price.\\n    /// @param id The id of the NFT being queried for royalties information.\\n    /// @param salePrice The sale price of the NFT, in some unit of exchange.\\n    /// @return receiver The address of the royalties receiver.\\n    /// @return royaltyAmount The royalty payment to be made given `salePrice`.\\n    function royaltyInfo(\\n        uint256 id,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IOpenSeaProxyRegistry\",\"name\":\"proxyRegistry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reserve_\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"royalties_\",\"type\":\"uint96\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OwnerInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReceiverInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoyaltiesTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferUnsupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderUnauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNonExistent\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"BaseURISet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"storageURI\",\"type\":\"string\"}],\"name\":\"StorageURISet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyRegistry\",\"outputs\":[{\"internalType\":\"contract IOpenSeaProxyRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"royalties\",\"type\":\"uint96\"}],\"name\":\"setRoyalties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newStorageURI\",\"type\":\"string\"}],\"name\":\"setStorageURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"storageURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"id\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DopamineHonoraryTab", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000a5409ec958c83c3f309868babaca7c86dcb077c100000000000000000000000086abc3aff51f98bf635b78d87c2136a1c6a2757e00000000000000000000000000000000000000000000000000000000000002ee", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}