{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.0;\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract LCXVestingToken is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address private immutable LCX_TOKEN; // Contract Address of LCX Token\r\n    address private SaleContract; // Contract Address of Sale Tiamond\r\n\r\n    struct VestedToken {\r\n        uint256 cliff;\r\n        uint256 start;\r\n        uint256 duration;\r\n        uint256 releasedToken;\r\n        uint256 totalToken;\r\n        bool revoked;\r\n    }\r\n\r\n    // mapped with token id\r\n    mapping(address => VestedToken) public vestedUser;\r\n\r\n    modifier onlySaleContract(){\r\n        require(SaleContract == _msgSender(), \"Only Sale Contract can call\");\r\n        _;\r\n    }\r\n\r\n    event TokenReleased(address indexed account, uint256 amount);\r\n    event VestingRevoked(address indexed account);\r\n    event SetSaleContractAddress(address);\r\n\r\n    constructor(address _lcxAddress){\r\n        require(_lcxAddress != address(0), \"Address should not be zero address\");\r\n        LCX_TOKEN = _lcxAddress;\r\n    }\r\n\r\n    function setSaleAddress(address _saleAddress) external onlyOwner {\r\n        require(_saleAddress != address(0), \"Must be an address\");\r\n        SaleContract = _saleAddress;\r\n        emit SetSaleContractAddress(_saleAddress);\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev this will set the beneficiary with vesting\r\n     * parameters provided\r\n     * @param account address of the beneficiary for vesting\r\n     * @param amount  totalToken to be vested\r\n     * @param cliff In seconds of one period in vesting\r\n     * @param duration In seconds of total vesting\r\n     * @param startAt UNIX timestamp in seconds from where vesting will start\r\n     */\r\n    function setVesting(\r\n        address account,\r\n        uint256 amount,\r\n        uint256 cliff,\r\n        uint256 duration,\r\n        uint256 startAt\r\n    ) external onlySaleContract returns (bool) {\r\n        VestedToken storage vested = vestedUser[account];\r\n        if (vested.start > 0) {\r\n            require(vested.revoked, \"Account vesting is still going on\");\r\n            uint256 unclaimedTokens = _vestedAmount(account).sub(\r\n                vested.releasedToken\r\n            );\r\n            require(unclaimedTokens == 0, \"Account vesting is still going on\");\r\n        }\r\n        IERC20(LCX_TOKEN).transferFrom(_msgSender(), address(this), amount);\r\n        _setVesting(account, amount, cliff, duration, startAt);\r\n        return true;\r\n    }\r\n\r\n    function userDetails(address account)\r\n        external\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        return (vestedUser[account].duration, vestedUser[account].totalToken);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested.\r\n     * @param account address of the user\r\n     */\r\n    function vestedToken(address account) external view returns (uint256) {\r\n        return _vestedAmount(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n     * @param account address of user\r\n     */\r\n    function releasableToken(address account) external view returns (uint256) {\r\n        return _vestedAmount(account).sub(vestedUser[account].releasedToken);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set default vesting parameters\r\n     * @param account address of the beneficiary for vesting\r\n     * @param amount  totalToken to be vested\r\n     * @param cliff In seconds of one period in vestin\r\n     * @param duration In seconds of total vesting duration\r\n     * @param startAt UNIX timestamp in seconds from where vesting will start\r\n     *\r\n     */\r\n    function _setVesting(\r\n        address account,\r\n        uint256 amount,\r\n        uint256 cliff,\r\n        uint256 duration,\r\n        uint256 startAt\r\n    ) internal {\r\n        require(account != address(0), \"Address should not be zero address\");\r\n        require(startAt >= block.timestamp, \"Vesting should start after current block time\");\r\n        require(cliff <= duration, \"Cliff should be less that duration\");\r\n        VestedToken storage vested = vestedUser[account];\r\n        vested.cliff = cliff;\r\n        vested.start = startAt;\r\n        vested.duration = duration;\r\n        vested.totalToken = amount;\r\n        vested.releasedToken = 0;\r\n        vested.revoked = false;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers vested tokens to beneficiary.\r\n     * anyone can release their token\r\n     */\r\n    function releaseMyToken() external returns (bool) {\r\n        releaseToken(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers vested tokens to the given account.\r\n     * @param account address of the vested user\r\n     */\r\n    function releaseToken(address account) public {\r\n        require(account != address(0), \"Address should not be zero address\");\r\n        VestedToken storage vested = vestedUser[account];\r\n        uint256 unreleasedToken = _releasableAmount(account); // total releasable token currently\r\n        require(unreleasedToken > 0, \"No unreleased tokens in vesting\");\r\n        vested.releasedToken = vested.releasedToken.add(unreleasedToken);\r\n        IERC20(LCX_TOKEN).transfer(account, unreleasedToken);\r\n        emit TokenReleased(account, unreleasedToken);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n     * @param account address of user\r\n     */\r\n    function _releasableAmount(address account)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _vestedAmount(account).sub(vestedUser[account].releasedToken);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested.\r\n     * @param account address of the user\r\n     */\r\n    function _vestedAmount(address account) internal view returns (uint256) {\r\n        VestedToken storage vested = vestedUser[account];\r\n        uint256 totalToken = vested.totalToken;\r\n        if (block.timestamp < vested.start.add(vested.cliff)) {\r\n            return 0;\r\n        } else if (\r\n            block.timestamp >= vested.start.add(vested.duration) ||\r\n            vested.revoked\r\n        ) {\r\n            return totalToken;\r\n        } else {\r\n            uint256 numberOfPeriods = (block.timestamp.sub(vested.start)).div(\r\n                vested.cliff\r\n            );\r\n            return\r\n                totalToken.mul(numberOfPeriods.mul(vested.cliff)).div(\r\n                    vested.duration\r\n                );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to revoke the vesting. Tokens already vested\r\n     * remain in the contract, the rest are returned to the owner.\r\n     * @param account address in which the vesting is revoked\r\n     */\r\n    function revoke(address account) external onlyOwner returns (bool) {\r\n        VestedToken storage vested = vestedUser[account];\r\n        require(!vested.revoked, \"Already revoked\");\r\n        uint256 balance = vested.totalToken;\r\n        uint256 vestedAmount = _vestedAmount(account);\r\n        uint256 refund = balance.sub(vestedAmount);\r\n        require(refund > 0, \"Refund amount should be more than zero\");\r\n        vested.revoked = true;\r\n        vested.totalToken = vestedAmount;\r\n        IERC20(LCX_TOKEN).transfer(owner(), refund);\r\n        emit VestingRevoked(account);\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lcxAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"SetSaleContractAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"VestingRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"releasableToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseMyToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"releaseToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_saleAddress\",\"type\":\"address\"}],\"name\":\"setSaleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAt\",\"type\":\"uint256\"}],\"name\":\"setVesting\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"userDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"vestedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vestedUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasedToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalToken\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revoked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LCXVestingToken", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000037a54aab062628c9bbae1fdb1583c195585fe41", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://754217ac43dc0c0691531be91abdf9f9ae40389cb45ee299e21976c4b5fc3429"}]}