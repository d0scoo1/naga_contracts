{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TreasuryExtender.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\n// interfaces\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/ITreasury.sol\\\";\\nimport \\\"./interfaces/IAllocator.sol\\\";\\nimport \\\"./interfaces/ITreasuryExtender.sol\\\";\\n\\n// types\\nimport \\\"./types/OlympusAccessControlledV2.sol\\\";\\n\\n// libraries\\nimport \\\"./libraries/SafeERC20.sol\\\";\\n\\nerror TreasuryExtender_AllocatorOffline();\\nerror TreasuryExtender_AllocatorNotActivated();\\nerror TreasuryExtender_AllocatorNotOffline();\\nerror TreasuryExtender_AllocatorRegistered(uint256 id);\\nerror TreasuryExtender_OnlyAllocator(uint256 id, address sender);\\nerror TreasuryExtender_MaxAllocation(uint256 allocated, uint256 limit);\\n\\n/**\\n * @title Treasury Extender\\n * @notice\\n *  This contract serves as an accounting and management contract which\\n *  will interact with the Olympus Treasury to fund Allocators.\\n *\\n *  Accounting:\\n *  For each Allocator there are multiple deposit IDs referring to individual tokens,\\n *  for each deposit ID we record 5 distinct values grouped into 3 fields,\\n *  together grouped as AllocatorData:\\n *\\n *  AllocatorLimits { allocated, loss } - This is the maximum amount\\n *  an Allocator should have allocated at any point, and also the maximum\\n *  loss an allocator should experience without automatically shutting down.\\n *\\n *  AllocatorPerformance { gain, loss } - This is the current gain (total - allocated)\\n *  and the loss the Allocator sustained over its time of operation.\\n *\\n *  AllocatorHoldings { allocated } - This is the amount of tokens an Allocator\\n *  has currently been allocated by the Extender.\\n *\\n *  Important: The above is only tracked in the underlying token specified by the ID,\\n *  (see BaseAllocator.sol) while rewards are retrievable by the standard ERC20 functions.\\n *  The point is that we only exactly track that which exits the Treasury.\\n */\\ncontract TreasuryExtender is OlympusAccessControlledV2, ITreasuryExtender {\\n    using SafeERC20 for IERC20;\\n\\n    // The Olympus Treasury.\\n    ITreasury public immutable treasury;\\n\\n    // Enumerable Allocators according to deposit IDs.\\n    /// @dev NOTE: Allocator enumeration starts from index 1.\\n    IAllocator[] public allocators;\\n\\n    // Get an an Allocator's Data for for an Allocator and deposit ID\\n    mapping(IAllocator => mapping(uint256 => AllocatorData)) public allocatorData;\\n\\n    constructor(address treasuryAddress, address authorityAddress)\\n        OlympusAccessControlledV2(IOlympusAuthority(authorityAddress))\\n    {\\n        treasury = ITreasury(treasuryAddress);\\n        // This nonexistent allocator at address(0) is pushed\\n        // as a placeholder so enumeration may start from index 1.\\n        allocators.push(IAllocator(address(0)));\\n    }\\n\\n    //// CHECKS\\n\\n    function _allocatorActivated(AllocatorStatus status) internal pure {\\n        if (AllocatorStatus.ACTIVATED != status) revert TreasuryExtender_AllocatorNotActivated();\\n    }\\n\\n    function _allocatorOffline(AllocatorStatus status) internal pure {\\n        if (AllocatorStatus.OFFLINE != status) revert TreasuryExtender_AllocatorNotOffline();\\n    }\\n\\n    function _onlyAllocator(\\n        IAllocator byStatedId,\\n        address sender,\\n        uint256 id\\n    ) internal pure {\\n        if (IAllocator(sender) != byStatedId) revert TreasuryExtender_OnlyAllocator(id, sender);\\n    }\\n\\n    //// FUNCTIONS\\n\\n    /**\\n     * @notice\\n     *  Registers an Allocator. Adds a deposit id and prepares storage slots for writing.\\n     *  Does not activate the Allocator.\\n     * @dev\\n     *  Calls `addId` from `IAllocator` with the index of the deposit in `allocators`\\n     * @param newAllocator the Allocator to be registered\\n     */\\n    function registerDeposit(address newAllocator) external override onlyGuardian {\\n        // reads\\n        IAllocator allocator = IAllocator(newAllocator);\\n\\n        // effects\\n        allocators.push(allocator);\\n\\n        uint256 id = allocators.length - 1;\\n\\n        // interactions\\n        allocator.addId(id);\\n\\n        // events\\n        emit NewDepositRegistered(newAllocator, address(allocator.tokens()[allocator.tokenIds(id)]), id);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Sets an Allocators AllocatorLimits.\\n     *  AllocatorLimits is part of AllocatorData, variable meanings follow:\\n     *  allocated - The maximum amount a Guardian may allocate this Allocator from Treasury.\\n     *  loss - The maximum loss amount this Allocator can take.\\n     * @dev\\n     *  Can only be called while the Allocator is offline.\\n     * @param id the deposit id to set AllocatorLimits for\\n     * @param limits the AllocatorLimits to set\\n     */\\n    function setAllocatorLimits(uint256 id, AllocatorLimits calldata limits) external override onlyGuardian {\\n        IAllocator allocator = allocators[id];\\n\\n        // checks\\n        _allocatorOffline(allocator.status());\\n\\n        // effects\\n        allocatorData[allocator][id].limits = limits;\\n\\n        // events\\n        emit AllocatorLimitsChanged(id, limits.allocated, limits.loss);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Reports an Allocators status to the Extender.\\n     *  Updates Extender state accordingly.\\n     * @dev\\n     *  Can only be called while the Allocator is activated or migrating.\\n     *  The idea is that first the Allocator updates its own state, then\\n     *  it reports this state to the Extender, which then updates its own state.\\n     *\\n     *  There is 3 different combinations the Allocator may report:\\n     *\\n     *  (gain + loss) == 0, the Allocator will NEVER report this state\\n     *  gain > loss, gain is reported and incremented but allocated not.\\n     *  loss > gain, loss is reported, allocated and incremented.\\n     *  loss == gain == type(uint128).max , migration case, zero out gain, loss, allocated\\n     *\\n     *  NOTE: please take care to properly calculate loss by, say, only reporting loss above a % threshold\\n     *        of allocated. This is to serve as a low pass filter of sorts to ignore noise in price movements.\\n     *  NOTE: when migrating the next Allocator should report his state to the Extender, in say an `_activate` call.\\n     *\\n     * @param id the deposit id of the token to report state for\\n     * @param gain the gain the Allocator has made in allocated token\\n     * @param loss the loss the Allocator has sustained in allocated token\\n     */\\n    function report(\\n        uint256 id,\\n        uint128 gain,\\n        uint128 loss\\n    ) external override {\\n        // reads\\n        IAllocator allocator = allocators[id];\\n        AllocatorData storage data = allocatorData[allocator][id];\\n        AllocatorPerformance memory perf = data.performance;\\n        AllocatorStatus status = allocator.status();\\n\\n        // checks\\n        _onlyAllocator(allocator, msg.sender, id);\\n        if (status == AllocatorStatus.OFFLINE) revert TreasuryExtender_AllocatorOffline();\\n\\n        // EFFECTS\\n        if (gain >= loss) {\\n            // MIGRATION\\n            // according to above gain must equal loss because\\n            // gain can't be larger than max uint128 value\\n            if (loss == type(uint128).max) {\\n                AllocatorData storage newAllocatorData = allocatorData[allocators[allocators.length - 1]][id];\\n\\n                newAllocatorData.holdings.allocated = data.holdings.allocated;\\n                newAllocatorData.performance.gain = data.performance.gain;\\n                data.holdings.allocated = 0;\\n\\n                perf.gain = 0;\\n                perf.loss = 0;\\n\\n                emit AllocatorReportedMigration(id);\\n\\n                // GAIN\\n            } else {\\n                perf.gain += gain;\\n\\n                emit AllocatorReportedGain(id, gain);\\n            }\\n\\n            // LOSS\\n        } else {\\n            data.holdings.allocated -= loss;\\n\\n            perf.loss += loss;\\n\\n            emit AllocatorReportedLoss(id, loss);\\n        }\\n\\n        data.performance = perf;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Requests funds from the Olympus Treasury to fund an Allocator.\\n     * @dev\\n     *  Can only be called while the Allocator is activated.\\n     *  Can only be called by the Guardian.\\n     *\\n     *  This function is going to allocate an `amount` of deposit id tokens to the Allocator and\\n     *  properly record this in storage. This done so that at any point, we know exactly\\n     *  how much was initially allocated and also how much value is allocated in total.\\n     *\\n     *  The related functions are `getAllocatorAllocated` and `getTotalValueAllocated`.\\n     *\\n     *  To note is also the `_allocatorBelowLimit` check.\\n     * @param id the deposit id of the token to fund allocator with\\n     * @param amount the amount of token to withdraw, the token is known in the Allocator\\n     */\\n    function requestFundsFromTreasury(uint256 id, uint256 amount) external override onlyGuardian {\\n        // reads\\n        IAllocator allocator = allocators[id];\\n        AllocatorData memory data = allocatorData[allocator][id];\\n        address token = address(allocator.tokens()[allocator.tokenIds(id)]);\\n        uint256 value = treasury.tokenValue(token, amount);\\n\\n        // checks\\n        _allocatorActivated(allocator.status());\\n        _allocatorBelowLimit(data, amount);\\n\\n        // interaction (withdrawing)\\n        treasury.manage(token, amount);\\n\\n        // effects\\n        allocatorData[allocator][id].holdings.allocated += amount;\\n\\n        // interaction (depositing)\\n        IERC20(token).safeTransfer(address(allocator), amount);\\n\\n        // events\\n        emit AllocatorFunded(id, amount, value);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Returns funds from an Allocator to the Treasury.\\n     * @dev\\n     *  External hook: Logic is handled in the internal function.\\n     *  Can only be called by the Guardian.\\n     *\\n     *  This function is going to withdraw `amount` of allocated token from an Allocator\\n     *  back to the Treasury. Prior to calling this function, `deallocate` should be called,\\n     *  in order to prepare the funds for withdrawal.\\n     *\\n     *  The maximum amount which can be withdrawn is `gain` + `allocated`.\\n     *  `allocated` is decremented first after which `gain` is decremented in the case\\n     *  that `allocated` is not sufficient.\\n     * @param id the deposit id of the token to fund allocator with\\n     * @param amount the amount of token to withdraw, the token is known in the Allocator\\n     */\\n    function returnFundsToTreasury(uint256 id, uint256 amount) external override onlyGuardian {\\n        // reads\\n        IAllocator allocator = allocators[id];\\n        uint256 allocated = allocatorData[allocator][id].holdings.allocated;\\n        uint128 gain = allocatorData[allocator][id].performance.gain;\\n        address token = address(allocator.tokens()[allocator.tokenIds(id)]);\\n\\n        if (amount > allocated) {\\n            amount -= allocated;\\n            if (amount > gain) {\\n                amount = allocated + gain;\\n                gain = 0;\\n            } else {\\n                // yes, amount should never > gain, we have safemath\\n                gain -= uint128(amount);\\n                amount += allocated;\\n            }\\n            allocated = 0;\\n        } else {\\n            allocated -= amount;\\n        }\\n\\n        uint256 value = treasury.tokenValue(token, amount);\\n\\n        // checks\\n        _allowTreasuryWithdrawal(IERC20(token));\\n\\n        // interaction (withdrawing)\\n        IERC20(token).safeTransferFrom(address(allocator), address(this), amount);\\n\\n        // effects\\n        allocatorData[allocator][id].holdings.allocated = allocated;\\n        if (allocated == 0) allocatorData[allocator][id].performance.gain = gain;\\n\\n        // interaction (depositing)\\n        assert(treasury.deposit(amount, token, value) == 0);\\n\\n        // events\\n        emit AllocatorWithdrawal(id, amount, value);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Returns rewards from an Allocator to the Treasury.\\n     *  Also see `_returnRewardsToTreasury`.\\n     * @dev\\n     *  External hook: Logic is handled in the internal function.\\n     *  Can only be called by the Guardian.\\n     * @param id the deposit id of the token to fund allocator with\\n     * @param token the address of the reward token to withdraw\\n     * @param amount the amount of the reward token to withdraw\\n     */\\n    function returnRewardsToTreasury(\\n        uint256 id,\\n        address token,\\n        uint256 amount\\n    ) external {\\n        _returnRewardsToTreasury(allocators[id], IERC20(token), amount);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Returns rewards from an Allocator to the Treasury.\\n     *  Also see `_returnRewardsToTreasury`.\\n     * @dev\\n     *  External hook: Logic is handled in the internal function.\\n     *  Can only be called by the Guardian.\\n     * @param allocatorAddress the address of the Allocator to returns rewards from\\n     * @param token the address of the reward token to withdraw\\n     * @param amount the amount of the reward token to withdraw\\n     */\\n    function returnRewardsToTreasury(\\n        address allocatorAddress,\\n        address token,\\n        uint256 amount\\n    ) external {\\n        _returnRewardsToTreasury(IAllocator(allocatorAddress), IERC20(token), amount);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Get an Allocators address by it's ID.\\n     * @dev\\n     *  Our first Allocator is at index 1, NOTE: 0 is a placeholder.\\n     * @param id the id of the allocator, NOTE: valid interval: 1 =< id < allocators.length\\n     * @return allocatorAddress the allocator's address\\n     */\\n    function getAllocatorByID(uint256 id) external view override returns (address allocatorAddress) {\\n        allocatorAddress = address(allocators[id]);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Get the total number of Allocators ever registered.\\n     * @dev\\n     *  Our first Allocator is at index 1, 0 is a placeholder.\\n     * @return total number of allocators ever registered\\n     */\\n    function getTotalAllocatorCount() external view returns (uint256) {\\n        return allocators.length;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Get an Allocators limits.\\n     * @dev\\n     *  For an explanation of AllocatorLimits, see `setAllocatorLimits`\\n     * @return the Allocator's limits\\n     */\\n    function getAllocatorLimits(uint256 id) external view override returns (AllocatorLimits memory) {\\n        return allocatorData[allocators[id]][id].limits;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Get an Allocators performance.\\n     * @dev\\n     *  An Allocator's performance is the amount of `gain` and `loss` it has sustained in its\\n     *  lifetime. `gain` is the amount of allocated tokens (underlying) acquired, while\\n     *  `loss` is the amount lost. `gain` and `loss` are incremented separately.\\n     *  Thus, overall performance can be gauged as gain - loss\\n     * @return the Allocator's performance\\n     */\\n    function getAllocatorPerformance(uint256 id) external view override returns (AllocatorPerformance memory) {\\n        return allocatorData[allocators[id]][id].performance;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Get an Allocators amount allocated.\\n     * @dev\\n     *  This is simply the amount of `token` which was allocated to the allocator.\\n     * @return the Allocator's amount allocated\\n     */\\n    function getAllocatorAllocated(uint256 id) external view override returns (uint256) {\\n        return allocatorData[allocators[id]][id].holdings.allocated;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Returns rewards from an Allocator to the Treasury.\\n     * @dev\\n     *  External hook: Logic is handled in the internal function.\\n     *  Can only be called by the Guardian.\\n     *\\n     *  The assumption is that the reward tokens being withdrawn are going to be\\n     *  either deposited into the contract OR harvested into allocated (underlying).\\n     *\\n     *  For this reason we don't need anything other than `balanceOf`.\\n     * @param allocator the Allocator to returns rewards from\\n     * @param token the reward token to withdraw\\n     * @param amount the amount of the reward token to withdraw\\n     */\\n    function _returnRewardsToTreasury(\\n        IAllocator allocator,\\n        IERC20 token,\\n        uint256 amount\\n    ) internal onlyGuardian {\\n        // reads\\n        uint256 balance = token.balanceOf(address(allocator));\\n        amount = (balance < amount) ? balance : amount;\\n        uint256 value = treasury.tokenValue(address(token), amount);\\n\\n        // checks\\n        _allowTreasuryWithdrawal(token);\\n\\n        // interactions\\n        token.safeTransferFrom(address(allocator), address(this), amount);\\n        assert(treasury.deposit(amount, address(token), value) == 0);\\n\\n        // events\\n        emit AllocatorRewardsWithdrawal(address(allocator), amount, value);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Approve treasury for withdrawing if token has not been approved.\\n     * @param token Token to approve.\\n     */\\n    function _allowTreasuryWithdrawal(IERC20 token) internal {\\n        if (token.allowance(address(this), address(treasury)) == 0) token.approve(address(treasury), type(uint256).max);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Check if token is below limit for allocation and if not approve it.\\n     * @param data allocator data to check limits and amount allocated\\n     * @param amount amount of tokens to allocate\\n     */\\n    function _allocatorBelowLimit(AllocatorData memory data, uint256 amount) internal pure {\\n        uint256 newAllocated = data.holdings.allocated + amount;\\n        if (newAllocated > data.limits.allocated)\\n            revert TreasuryExtender_MaxAllocation(newAllocated, data.limits.allocated);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface ITreasury {\\n    function deposit(\\n        uint256 _amount,\\n        address _token,\\n        uint256 _profit\\n    ) external returns (uint256);\\n\\n    function withdraw(uint256 _amount, address _token) external;\\n\\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\\n\\n    function mint(address _recipient, uint256 _amount) external;\\n\\n    function manage(address _token, uint256 _amount) external;\\n\\n    function incurDebt(uint256 amount_, address token_) external;\\n\\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\\n\\n    function excessReserves() external view returns (uint256);\\n\\n    function baseSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAllocator.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\n// interfaces\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ITreasuryExtender.sol\\\";\\nimport \\\"./IOlympusAuthority.sol\\\";\\n\\nenum AllocatorStatus {\\n    OFFLINE,\\n    ACTIVATED,\\n    MIGRATING\\n}\\n\\nstruct AllocatorInitData {\\n    IOlympusAuthority authority;\\n    ITreasuryExtender extender;\\n    IERC20[] tokens;\\n}\\n\\n/**\\n * @title Interface for the BaseAllocator\\n * @dev\\n *  These are the standard functions that an Allocator should implement. A subset of these functions\\n *  is implemented in the `BaseAllocator`. Similar to those implemented, if for some reason the developer\\n *  decides to implement a dedicated base contract, or not at all and rather a dedicated Allocator contract\\n *  without base, imitate the functionalities implemented in it.\\n */\\ninterface IAllocator {\\n    /**\\n     * @notice\\n     *  Emitted when the Allocator is deployed.\\n     */\\n    event AllocatorDeployed(address authority, address extender);\\n\\n    /**\\n     * @notice\\n     *  Emitted when the Allocator is activated.\\n     */\\n    event AllocatorActivated();\\n\\n    /**\\n     * @notice\\n     *  Emitted when the Allocator is deactivated.\\n     */\\n    event AllocatorDeactivated(bool panic);\\n\\n    /**\\n     * @notice\\n     *  Emitted when the Allocators loss limit is violated.\\n     */\\n    event LossLimitViolated(uint128 lastLoss, uint128 dloss, uint256 estimatedTotalAllocated);\\n\\n    /**\\n     * @notice\\n     *  Emitted when a Migration is executed.\\n     * @dev\\n     *  After this also `AllocatorDeactivated` should follow.\\n     */\\n    event MigrationExecuted(address allocator);\\n\\n    /**\\n     * @notice\\n     *  Emitted when Ether is received by the contract.\\n     * @dev\\n     *  Only the Guardian is able to send the ether.\\n     */\\n    event EtherReceived(uint256 amount);\\n\\n    function update(uint256 id) external;\\n\\n    function deallocate(uint256[] memory amounts) external;\\n\\n    function prepareMigration() external;\\n\\n    function migrate() external;\\n\\n    function activate() external;\\n\\n    function deactivate(bool panic) external;\\n\\n    function addId(uint256 id) external;\\n\\n    function name() external view returns (string memory);\\n\\n    function ids() external view returns (uint256[] memory);\\n\\n    function tokenIds(uint256 id) external view returns (uint256);\\n\\n    function version() external view returns (string memory);\\n\\n    function status() external view returns (AllocatorStatus);\\n\\n    function tokens() external view returns (IERC20[] memory);\\n\\n    function utilityTokens() external view returns (IERC20[] memory);\\n\\n    function rewardTokens() external view returns (IERC20[] memory);\\n\\n    function amountAllocated(uint256 id) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasuryExtender.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\nstruct AllocatorPerformance {\\n    uint128 gain;\\n    uint128 loss;\\n}\\n\\nstruct AllocatorLimits {\\n    uint128 allocated;\\n    uint128 loss;\\n}\\n\\nstruct AllocatorHoldings {\\n    uint256 allocated;\\n}\\n\\nstruct AllocatorData {\\n    AllocatorHoldings holdings;\\n    AllocatorLimits limits;\\n    AllocatorPerformance performance;\\n}\\n\\n/**\\n * @title Interface for the TreasuryExtender\\n */\\ninterface ITreasuryExtender {\\n    /**\\n     * @notice\\n     *  Emitted when a new Deposit is registered.\\n     */\\n    event NewDepositRegistered(address allocator, address token, uint256 id);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator is funded\\n     */\\n    event AllocatorFunded(uint256 id, uint256 amount, uint256 value);\\n\\n    /**\\n     * @notice\\n     *  Emitted when allocated funds are withdrawn from an Allocator\\n     */\\n    event AllocatorWithdrawal(uint256 id, uint256 amount, uint256 value);\\n\\n    /**\\n     * @notice\\n     *  Emitted when rewards are withdrawn from an Allocator\\n     */\\n    event AllocatorRewardsWithdrawal(address allocator, uint256 amount, uint256 value);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator reports a gain\\n     */\\n    event AllocatorReportedGain(uint256 id, uint128 gain);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator reports a loss\\n     */\\n    event AllocatorReportedLoss(uint256 id, uint128 loss);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator reports a migration\\n     */\\n    event AllocatorReportedMigration(uint256 id);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator limits are modified\\n     */\\n    event AllocatorLimitsChanged(uint256 id, uint128 allocationLimit, uint128 lossLimit);\\n\\n    function registerDeposit(address newAllocator) external;\\n\\n    function setAllocatorLimits(uint256 id, AllocatorLimits memory limits) external;\\n\\n    function report(\\n        uint256 id,\\n        uint128 gain,\\n        uint128 loss\\n    ) external;\\n\\n    function requestFundsFromTreasury(uint256 id, uint256 amount) external;\\n\\n    function returnFundsToTreasury(uint256 id, uint256 amount) external;\\n\\n    function returnRewardsToTreasury(\\n        uint256 id,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    function getTotalAllocatorCount() external view returns (uint256);\\n\\n    function getAllocatorByID(uint256 id) external view returns (address);\\n\\n    function getAllocatorAllocated(uint256 id) external view returns (uint256);\\n\\n    function getAllocatorLimits(uint256 id) external view returns (AllocatorLimits memory);\\n\\n    function getAllocatorPerformance(uint256 id) external view returns (AllocatorPerformance memory);\\n}\\n\"\r\n    },\r\n    \"contracts/types/OlympusAccessControlledV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\nimport \\\"../interfaces/IOlympusAuthority.sol\\\";\\n\\nerror UNAUTHORIZED();\\nerror AUTHORITY_INITIALIZED();\\n\\n/// @dev Reasoning for this contract = modifiers literaly copy code\\n/// instead of pointing towards the logic to execute. Over many\\n/// functions this bloats contract size unnecessarily.\\n/// imho modifiers are a meme.\\nabstract contract OlympusAccessControlledV2 {\\n    /* ========== EVENTS ========== */\\n\\n    event AuthorityUpdated(IOlympusAuthority authority);\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IOlympusAuthority public authority;\\n\\n    /* ========== Constructor ========== */\\n\\n    constructor(IOlympusAuthority _authority) {\\n        authority = _authority;\\n        emit AuthorityUpdated(_authority);\\n    }\\n\\n    /* ========== \\\"MODIFIERS\\\" ========== */\\n\\n    modifier onlyGovernor {\\n\\t_onlyGovernor();\\n\\t_;\\n    }\\n\\n    modifier onlyGuardian {\\n\\t_onlyGuardian();\\n\\t_;\\n    }\\n\\n    modifier onlyPolicy {\\n\\t_onlyPolicy();\\n\\t_;\\n    }\\n\\n    modifier onlyVault {\\n\\t_onlyVault();\\n\\t_;\\n    }\\n\\n    /* ========== GOV ONLY ========== */\\n\\n    function initializeAuthority(IOlympusAuthority _newAuthority) internal {\\n        if (authority != IOlympusAuthority(address(0))) revert AUTHORITY_INITIALIZED();\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n\\n    function setAuthority(IOlympusAuthority _newAuthority) external {\\n        _onlyGovernor();\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n\\n    /* ========== INTERNAL CHECKS ========== */\\n\\n    function _onlyGovernor() internal view {\\n        if (msg.sender != authority.governor()) revert UNAUTHORIZED();\\n    }\\n\\n    function _onlyGuardian() internal view {\\n        if (msg.sender != authority.guardian()) revert UNAUTHORIZED();\\n    }\\n\\n    function _onlyPolicy() internal view {\\n        if (msg.sender != authority.policy()) revert UNAUTHORIZED();\\n    }\\n\\n    function _onlyVault() internal view {\\n        if (msg.sender != authority.vault()) revert UNAUTHORIZED();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.5;\\n\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\\n/// Taken from Solmate\\nlibrary SafeERC20 {\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        (bool success, ) = to.call{value: amount}(new bytes(0));\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOlympusAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IOlympusAuthority {\\n    /* ========== EVENTS ========== */\\n\\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n\\n    event GovernorPulled(address indexed from, address indexed to);\\n    event GuardianPulled(address indexed from, address indexed to);\\n    event PolicyPulled(address indexed from, address indexed to);\\n    event VaultPulled(address indexed from, address indexed to);\\n\\n    /* ========== VIEW ========== */\\n\\n    function governor() external view returns (address);\\n\\n    function guardian() external view returns (address);\\n\\n    function policy() external view returns (address);\\n\\n    function vault() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasuryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"authorityAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"TreasuryExtender_AllocatorNotActivated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TreasuryExtender_AllocatorNotOffline\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TreasuryExtender_AllocatorOffline\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"allocated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"TreasuryExtender_MaxAllocation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"TreasuryExtender_OnlyAllocator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNAUTHORIZED\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AllocatorFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"allocationLimit\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"lossLimit\",\"type\":\"uint128\"}],\"name\":\"AllocatorLimitsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"gain\",\"type\":\"uint128\"}],\"name\":\"AllocatorReportedGain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"loss\",\"type\":\"uint128\"}],\"name\":\"AllocatorReportedLoss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"AllocatorReportedMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"allocator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AllocatorRewardsWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AllocatorWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IOlympusAuthority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"allocator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"NewDepositRegistered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IAllocator\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allocatorData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"allocated\",\"type\":\"uint256\"}],\"internalType\":\"struct AllocatorHoldings\",\"name\":\"holdings\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"allocated\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"loss\",\"type\":\"uint128\"}],\"internalType\":\"struct AllocatorLimits\",\"name\":\"limits\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"gain\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"loss\",\"type\":\"uint128\"}],\"internalType\":\"struct AllocatorPerformance\",\"name\":\"performance\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allocators\",\"outputs\":[{\"internalType\":\"contract IAllocator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAllocatorAllocated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAllocatorByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"allocatorAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAllocatorLimits\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"allocated\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"loss\",\"type\":\"uint128\"}],\"internalType\":\"struct AllocatorLimits\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAllocatorPerformance\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"gain\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"loss\",\"type\":\"uint128\"}],\"internalType\":\"struct AllocatorPerformance\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalAllocatorCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAllocator\",\"type\":\"address\"}],\"name\":\"registerDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"gain\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"loss\",\"type\":\"uint128\"}],\"name\":\"report\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"requestFundsFromTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"returnFundsToTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"allocatorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"returnRewardsToTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"returnRewardsToTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"allocated\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"loss\",\"type\":\"uint128\"}],\"internalType\":\"struct AllocatorLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"name\":\"setAllocatorLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"_newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"contract ITreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TreasuryExtender", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "0000000000000000000000009a315bdf513367c0377fb36545857d12e85813ef0000000000000000000000001c21f8ea7e39e2ba00bc12d2968d63f4acb38b7a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}