{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TZWAP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/**\\n*                                                                                  \\n..................................................................            \\n.                                                                .            \\n.  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::  .            \\n.  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::  .            \\n.  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::  .            \\n.  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::  .            \\n.  ::::::::::::::::::::--:.......:-==--:...::==::::::::::::::::  .            \\n.  ::::::::::::::::::--.    .:::.:--+=::::::--::-::::::::::::::  .            \\n.  :::::::::::::::::+:    ::.    .:--+=-===:..:--=-::::::::::::  .            \\n.  :::::::::::::::--     ..     .:-----=--. .:-=-:---::::::::::  .            \\n.  ::::::::::::::-.      .-::::.:+=====-=::---===--.:-:::::::::  .            \\n.  :::::::::::::-.   ...:...::::==+===::+=:-:::===:-=-==-::::::  .            \\n.  ::::::::::::=:.  :..:    ...---=-:::--=-:-=--::..:---+-:::::  .            \\n.  :::::::::::=:.. .::---...#+*@%%@-...:-==--=+*@@#-.:-=+::::::  .            \\n.  ::::::::::--..........::-%%#@=.%#    --=--:@+@#.+.   +::::::  .            \\n.  ::::::::::=..........:--:.-=*#%@=   ..=-=:-@#%@%%:.:-=::::::  .            \\n.  :::::::::-+=--:...:-:....-=========--:-=+**+:....::=-:::::::  .            \\n.  ::::::::--+==-:::-:..:::::------::--:..:::.-:.  ::::=-::::::  .            \\n.  ::::::::= ---. .:::..::::::--:-==--:::--:... ..     :+=:::::  .            \\n.  :::::::-: .:-:.:=++=-:::::::--=---------:.. ... .:--:*#-::::  .            \\n.  ::::::-=..  ::..-----=-::::---:--=---==--:..:. :---=*#=:::::  .            \\n.  :::::-: -   ....::.   .:::::=*####*****++====--++*##%-::::::  .            \\n.  ::::-.   :::....:.     .::::::+######################+::::::  .            \\n.  :::-.    .------:::::::::======+####################+:::::::  .            \\n.  ::-#=.     --++=-:=:::::-======++++*****+++++++=--:=::::::::  .            \\n.  ::#@@@%+:  ::  .-==-----*====::--:::-::   .:.:...:-=::::::::  .            \\n.  :=@@@@@@@@#-   --:...--++=-+....:..-*=-....:-::::-%@%+::::::  .            \\n.  :%@@@@@@@@@:::...:-=+-:. .--::-::..:+=:.  :==-.:: @@@@@*-:::  .            \\n.  =@@@@@@@@@+. .:..---:...:=:*@@@@@@@@@@@@@@@@@@@@+.@@@@@@@+::  .            \\n.  %@@@@@@@@@:..  .::::--:..:%@@@@@@@@@@@@@@@@@@@@@@#@@@@@@@@#-  .            \\n.  @@@@@@@@%-      .:::.:=#@=:%@@@#-.  -=:-=+*%@@@@@@@@@@@@@@@@  .            \\n.  @@@@@@@@@..        :#@@@@@%-:+@@.   ..  =-+%@@@@@@@@@@@@@@@@. .            \\n.  @@@@@@@@@%:...     :@@@@@@@@@@@@@=  :.:%@@@@@@@@@@@@@@@@@@@@. .            \\n.  @@@@@@@@@@@%+-:-*#@@@@@@@@@@@@@@#-  .. -@@@@@@@@@@@@@@@@@@@@. .            \\n.  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%. :. #@@@@@@@@@@@@@@@@@@@@. .            \\n.                                                                .            \\n..................................................................            \\n\\n            \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557    \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \\n            \u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\\n              \u2588\u2588\u2551     \u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\\n              \u2588\u2588\u2551    \u2588\u2588\u2588\u2554\u255d  \u2588\u2588\u2551\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d \\n              \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2554\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551     \\n              \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u255d\u255a\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d     \\n                                                      \\n                TZWAP: On-chain TWAP Service\\n*/\\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {I1inchAggregationRouterV4} from './interfaces/I1inchAggregationRouterV4.sol';\\nimport {IChainlinkOracle} from './interfaces/IChainlinkOracle.sol';\\nimport {ICustomPriceOracle} from './interfaces/ICustomPriceOracle.sol';\\nimport {IWETH9} from './interfaces/IWETH9.sol';\\nimport {IERC20} from'./interfaces/IERC20.sol';\\nimport {ISafeERC20} from './interfaces/ISafeERC20.sol';\\n\\n\\ncontract TZWAP is Ownable, Pausable {\\n\\n  using ISafeERC20 for IERC20;\\n\\n  I1inchAggregationRouterV4 public aggregationRouterV4;\\n  IWETH9 public weth;\\n\\n  // Min TWAP interval in seconds\\n  uint public minInterval = 60;\\n\\n  // Min number of intervals for a TWAP order\\n  uint public minNumOfIntervals = 3;\\n\\n  // Precision for all % math\\n  uint public percentagePrecision =  10 ** 5;\\n\\n  // Auto-incrementing of orders\\n  uint public orderCount;\\n  // TWAP orders mapped to auto-incrementing ID\\n  mapping (uint => TWAPOrder) public orders;\\n  // IDs of TWAP orders for a certain user address\\n  mapping (address => uint[]) public userOrders;\\n  // Fills for TWAP orders\\n  mapping (uint => Fill[]) public fills;\\n  // Token addresses mapped to oracles\\n  mapping (address => Oracle) public oracles;\\n  // Whitelisted addresses who can interact with fillOrder\\n  mapping (address => bool) public whitelist;\\n\\n  // If true only whitelisted addresses can interact with fillOrder\\n  bool public isWhitelistActive;\\n\\n  struct Oracle {\\n    // Address of oracle\\n    address oracleAddress;\\n    // Toggled to false if oracle is not chainlink\\n    bool isChainlink;\\n  }\\n\\n  struct TWAPOrder {\\n    // Order creator\\n    address creator;\\n    // Token to swap from\\n    address srcToken;\\n    // Token to swap to\\n    address dstToken;\\n    // How often a swap should be made\\n    uint interval;\\n    // srcToken to swap per interval\\n    uint tickSize;\\n    // Total srcToken to swap\\n    uint total;\\n    // Min fees in % to be paid per swap interval\\n    uint minFees;\\n    // Max fees in % to be paid per swap interval\\n    uint maxFees;\\n    // Creation timestamp\\n    uint created;\\n    // Toggled to true when an order is killed\\n    bool killed;\\n  }\\n  \\n  struct Fill {\\n    // Address that called fill\\n    address filler;\\n    // Amount of ticks filled\\n    uint ticksFilled;\\n    // Amount of srcToken spent\\n    uint srcTokensSwapped;\\n    // Amount of dstToken received\\n    uint dstTokensReceived;\\n    // Fees collected\\n    uint fees;\\n    // Time of last fill\\n    uint timestamp;\\n  }\\n\\n  // 1inch swaps structs\\n\\n  struct swapParams {\\n    address caller;\\n    I1inchAggregationRouterV4.SwapDescription desc;\\n    bytes data;\\n  }\\n\\n  struct unoswapParams {\\n    address srcToken;\\n    uint256 amount;\\n    uint256 minReturn;\\n    bytes32[] pools;\\n  }\\n\\n  struct uniswapV3Params {\\n    uint256 amount;\\n    uint256 minReturn;\\n    uint256[] pools;\\n  }\\n\\n  event LogNewOrder(uint id);\\n  event LogNewFill(uint id, uint fillIndex);\\n  event LogOrderKilled(uint id);\\n\\n  constructor(\\n    address payable _aggregationRouterV4Address,\\n    address payable _wethAddress\\n  ) {\\n    aggregationRouterV4 = I1inchAggregationRouterV4(_aggregationRouterV4Address);\\n    weth = IWETH9(_wethAddress);\\n    isWhitelistActive = true;\\n  }\\n\\n  receive() external payable {}\\n\\n  /**\\n  * Creates a new TWAP order\\n  * @param order Order params\\n  * @return Whether order was created\\n  */\\n  function newOrder(\\n    TWAPOrder memory order\\n  )\\n  payable\\n  public\\n  whenNotPaused\\n  returns (bool) {\\n    require(order.srcToken != address(0), \\\"Invalid srcToken address\\\");\\n    require(order.dstToken != address(0), \\\"Invalid dstToken address\\\");\\n    require(order.interval >= minInterval, \\\"Invalid interval\\\");\\n    require(order.tickSize > 0, \\\"Invalid tickSize\\\");\\n    require(order.total > order.tickSize && order.total % order.tickSize == 0, \\\"Invalid total\\\");\\n    require(order.total / order.tickSize > minNumOfIntervals, \\\"Number of intervals is too less\\\");\\n    order.creator = msg.sender;\\n    order.created = block.timestamp;\\n    order.killed = false;\\n\\n    if (order.srcToken == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\\n      require(msg.value == order.total, \\\"Invalid msg value\\\");\\n      weth.deposit{value: msg.value}();\\n      order.srcToken = address(weth);\\n    }\\n    else {\\n      require(IERC20(order.srcToken).transferFrom(msg.sender, address(this), order.total));\\n    }\\n\\n    require(oracles[order.srcToken].oracleAddress != address(0) && oracles[order.dstToken].oracleAddress != address(0), \\\"Oracle is missing\\\");\\n\\n    orders[orderCount++] = order;\\n    userOrders[msg.sender].push(orderCount - 1);\\n    emit LogNewOrder(orderCount - 1);\\n\\n    return true;\\n  }\\n\\n  /**\\n  * Fills an active order\\n  * @param id Order ID\\n  * @param swapType 0: swap() 1: unoswap() 2: uniswapV3SwapTo()\\n  * @param _swapParams Default 1inch swap\\n  * @param _unoswapParams 1inch swap through only sushi or uni v2\\n  * @param _uniswapV3Params 1inch swap through only uni v3\\n  * @return Whether order was filled\\n  */\\n  function fillOrder(\\n    uint id,\\n    uint swapType,\\n    swapParams calldata _swapParams,\\n    unoswapParams calldata _unoswapParams,\\n    uniswapV3Params calldata _uniswapV3Params\\n  )\\n  public\\n  whenNotPaused\\n  returns (uint) {\\n    if (isWhitelistActive)\\n      require(whitelist[msg.sender] == true, \\\"Not whitelisted\\\");\\n\\n    require(orders[id].created != 0, \\\"Invalid order\\\");\\n    require(!orders[id].killed, \\\"Order was killed\\\");\\n    require(getSrcTokensSwappedForOrder(id) < orders[id].total, \\\"Order is already filled\\\");\\n\\n    uint ticksToFill = getTicksToFill(id);\\n\\n    require(ticksToFill > 0, \\\"Interval must pass before next fill\\\");\\n\\n    // store it before we update array\\n    uint timeElapsed = getTimeElapsedSinceLastFill(id);\\n\\n    fills[id].push(\\n      Fill({\\n        filler: msg.sender, \\n        ticksFilled: ticksToFill, \\n        srcTokensSwapped: 0, // Update after swap\\n        dstTokensReceived: 0, // Update after swap\\n        fees: 0, // Update after swap\\n        timestamp: block.timestamp\\n      })\\n    );\\n\\n    _executeSwap(id, ticksToFill, swapType, _swapParams, _unoswapParams, _uniswapV3Params);\\n\\n    _setFeesAndDistribute(id, timeElapsed);\\n\\n    emit LogNewFill(id, fills[id].length - 1);\\n\\n    return fills[id][fills[id].length - 1].fees;\\n  }\\n\\n  /**\\n  * Execute post-swap checks and updates\\n  */\\n  function _ensureSwapValidityAndUpdate(\\n    uint id,\\n    uint256 srcTokensSwapped,\\n    uint256 dstTokensReceived\\n  )\\n  internal {\\n    // Estimate amount to receive using oracles\\n    uint srcTokenPriceInUsd;\\n    uint dstTokenPriceInUsd;\\n\\n    if (oracles[orders[id].srcToken].isChainlink)\\n      srcTokenPriceInUsd = uint(IChainlinkOracle(oracles[orders[id].srcToken].oracleAddress).latestAnswer());\\n    else\\n      srcTokenPriceInUsd = ICustomPriceOracle(oracles[orders[id].srcToken].oracleAddress).getPriceInUSD();\\n\\n    if (oracles[orders[id].dstToken].isChainlink)\\n      dstTokenPriceInUsd = uint(IChainlinkOracle(oracles[orders[id].dstToken].oracleAddress).latestAnswer());\\n    else\\n      dstTokenPriceInUsd = ICustomPriceOracle(oracles[orders[id].dstToken].oracleAddress).getPriceInUSD();\\n\\n    // 10% max slippage\\n    uint srcTokenDecimals = IERC20(orders[id].srcToken).decimals();\\n    uint dstTokenDecimals = IERC20(orders[id].dstToken).decimals();\\n    uint minDstTokenReceived = (900 * srcTokensSwapped * srcTokenPriceInUsd * (10 ** dstTokenDecimals)) / (1000 * dstTokenPriceInUsd * (10 ** srcTokenDecimals));\\n\\n    require(dstTokensReceived > minDstTokenReceived, \\\"Tokens received are not enough\\\");\\n\\n    fills[id][fills[id].length - 1].srcTokensSwapped = srcTokensSwapped;\\n    fills[id][fills[id].length - 1].dstTokensReceived = dstTokensReceived;\\n  }\\n\\n  /**\\n  * Set fees and distribute\\n  */\\n  function _setFeesAndDistribute(\\n    uint id,\\n    uint timeElapsed\\n  )\\n  internal {\\n    uint timeElapsedSinceCallable;\\n\\n    if (fills[id].length > 1)\\n      timeElapsedSinceCallable = timeElapsed - orders[id].interval;\\n    else\\n      timeElapsedSinceCallable = timeElapsed;\\n\\n    uint minFeesAmount = (fills[id][fills[id].length - 1].dstTokensReceived / fills[id][fills[id].length - 1].ticksFilled) * orders[id].minFees / percentagePrecision;\\n    uint maxFeesAmount = (fills[id][fills[id].length - 1].dstTokensReceived / fills[id][fills[id].length - 1].ticksFilled) * orders[id].maxFees / percentagePrecision;\\n\\n    fills[id][fills[id].length - 1].fees = Math.min(maxFeesAmount, minFeesAmount * ((1000 + timeElapsedSinceCallable / 6) / 1000));\\n    // minFees + 0.1% every 6 secs\\n\\n    IERC20(orders[id].dstToken).safeTransfer(\\n      msg.sender,\\n      fills[id][fills[id].length - 1].fees\\n    );\\n\\n    IERC20(orders[id].dstToken).safeTransfer(\\n      orders[id].creator,\\n      fills[id][fills[id].length - 1].dstTokensReceived - fills[id][fills[id].length - 1].fees\\n    );\\n  }\\n\\n\\n  /**\\n  * Execute swap\\n  */\\n  function _executeSwap(\\n    uint id,\\n    uint ticksToFill,\\n    uint swapType,\\n    swapParams calldata _swapParams,\\n    unoswapParams calldata _unoswapParams,\\n    uniswapV3Params calldata _uniswapV3Params\\n  ) internal {\\n    uint preSwapSrcTokenBalance = IERC20(orders[id].srcToken).balanceOf(address(this));\\n    uint preSwapDstTokenBalance = IERC20(orders[id].dstToken).balanceOf(address(this));\\n\\n    if (IERC20(orders[id].srcToken).allowance(address(this), address(aggregationRouterV4)) == 0)\\n      IERC20(orders[id].srcToken).safeIncreaseAllowance(address(aggregationRouterV4), 2**256 - 1);\\n\\n    if (swapType == 0) aggregationRouterV4.swap(_swapParams.caller, _swapParams.desc, _swapParams.data);\\n    else if (swapType == 1) aggregationRouterV4.unoswap(_unoswapParams.srcToken, _unoswapParams.amount, _unoswapParams.minReturn, _unoswapParams.pools);\\n    else aggregationRouterV4.uniswapV3Swap(_uniswapV3Params.amount, _uniswapV3Params.minReturn, _uniswapV3Params.pools);\\n\\n    uint256 srcTokensSwapped = preSwapSrcTokenBalance - IERC20(orders[id].srcToken).balanceOf(address(this));\\n    uint256 dstTokensReceived = IERC20(orders[id].dstToken).balanceOf(address(this)) - preSwapDstTokenBalance;\\n\\n    _ensureSwapValidityAndUpdate(id, srcTokensSwapped, dstTokensReceived);\\n\\n    require(srcTokensSwapped == ticksToFill * orders[id].tickSize, \\\"Invalid amount\\\");\\n    require(getSrcTokensSwappedForOrder(id) <= orders[id].total, \\\"Overbought\\\");\\n}\\n\\n  /**\\n  * Kills an active order\\n  * @param id Order ID\\n  * @return Whether order was killed\\n  */\\n  function killOrder(\\n    uint id\\n  )\\n  public\\n  whenNotPaused\\n  returns (bool) {\\n    require(msg.sender == orders[id].creator, \\\"Invalid sender\\\");\\n    require(!orders[id].killed, \\\"Order already killed\\\");\\n    orders[id].killed = true;\\n    IERC20(orders[id].srcToken).safeTransfer(\\n      orders[id].creator, \\n      orders[id].total - getSrcTokensSwappedForOrder(id)\\n    );\\n    emit LogOrderKilled(id);\\n    return true;\\n  }\\n\\n  /**\\n  * Returns total DST tokens received for an order\\n  * @param id Order ID\\n  * @return Total DST tokens received for an order\\n  */\\n  function getDstTokensReceivedForOrder(uint id)\\n  public\\n  view\\n  returns (uint) {\\n    require(orders[id].created != 0, \\\"Invalid order\\\");\\n    uint dstTokensReceived = 0;\\n    for (uint i = 0; i < fills[id].length; i++) \\n      dstTokensReceived += fills[id][i].dstTokensReceived;\\n    return dstTokensReceived;\\n  }\\n\\n  /**\\n  * Returns seconds passed since last fill\\n  * @param id Order ID\\n  * @return number of seconds\\n  */\\n  function getTimeElapsedSinceLastFill(uint id)\\n  public\\n  view\\n  returns (uint) {\\n    uint timeElapsed;\\n\\n    if (fills[id].length > 0) {\\n      timeElapsed = block.timestamp - fills[id][fills[id].length - 1].timestamp;\\n    } else\\n      timeElapsed = block.timestamp - orders[id].created;\\n\\n    return timeElapsed;\\n  }\\n\\n  /**\\n  * Returns total SRC tokens received for an order\\n  * @param id Order ID\\n  * @return Total SRC tokens received for an order\\n  */\\n  function getSrcTokensSwappedForOrder(uint id)\\n  public\\n  view\\n  returns (uint) {\\n    require(orders[id].created != 0, \\\"Invalid order\\\");\\n    uint srcTokensSwapped = 0;\\n    for (uint i = 0; i < fills[id].length; i++) \\n      srcTokensSwapped += fills[id][i].srcTokensSwapped;\\n    return srcTokensSwapped;\\n  }\\n\\n  /**\\n  * Returns total number of ticks filled of a certain order\\n  * @param id Order ID\\n  * @return number of ticks filled\\n  */\\n  function getTicksFilled(uint id)\\n  public\\n  view\\n  returns (uint) {\\n    require(orders[id].created != 0, \\\"Invalid order\\\");\\n    uint ticksFilled = 0;\\n    for (uint i = 0; i < fills[id].length; i++)\\n      ticksFilled += fills[id][i].ticksFilled;\\n    return ticksFilled;\\n  }\\n\\n  /**\\n  * Get the number of ticks that is possible to fill\\n  * @param id Order ID\\n  * @return number of ticks that can be filled\\n  */\\n  function getTicksToFill(uint id)\\n  public view\\n  returns (uint) {\\n    uint timeElapsed = getTimeElapsedSinceLastFill(id);\\n\\n    uint ticksToFill = timeElapsed / orders[id].interval;\\n    uint ticksFilled = getTicksFilled(id);\\n    uint maxTicksFillable = (orders[id].total / orders[id].tickSize) - ticksFilled;\\n\\n    if (ticksToFill >= maxTicksFillable) return maxTicksFillable;\\n    else return ticksToFill;\\n  }\\n\\n  /**\\n  * Get the required amount of token that is possible to swap\\n  * @param id Order ID\\n  * @return amount of srcToken that can be swapped\\n  */\\n  function getSrcTokensToSwap(uint id)\\n  public view\\n  returns (uint) {\\n    return getTicksToFill(id) * orders[id].tickSize;\\n  }\\n\\n  /**\\n  * Returns whether an order is active\\n  * @param id Order ID\\n  * @return Whether order is active\\n  */\\n  function isOrderActive(uint id) \\n  public\\n  view\\n  returns (bool) {\\n    return orders[id].created != 0 && \\n      !orders[id].killed && \\n      getSrcTokensSwappedForOrder(id) < orders[id].total;\\n  }\\n\\n  function addOracle(address token, Oracle memory oracle)\\n  public\\n  onlyOwner\\n  {\\n    // This is required to make it impossible to exploit 1inch params even for contract owner\\n    require(oracles[token].oracleAddress == address(0), \\\"Oracles cannot be updated\\\");\\n\\n    oracles[token] = oracle;\\n  }\\n\\n  function toggleWhitelist(bool value)\\n  public\\n  onlyOwner\\n  {\\n    isWhitelistActive = value;\\n  }\\n\\n  function addToWhitelist(address authorized)\\n  public\\n  onlyOwner\\n  {\\n    whitelist[authorized] = true;\\n  }\\n\\n  function removeFromWhitelist(address authorized)\\n  public\\n  onlyOwner\\n  {\\n    whitelist[authorized] = false;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/I1inchAggregationRouterV4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.7.0 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\ninterface I1inchAggregationRouterV4 {\\n  struct SwapDescription {\\n    address srcToken;\\n    address dstToken;\\n    address srcReceiver;\\n    address dstReceiver;\\n    uint256 amount;\\n    uint256 minReturnAmount;\\n    uint256 flags;\\n    bytes permit;\\n  }\\n\\n  event OrderFilledRFQ(bytes32 orderHash,uint256 makingAmount) ;\\n\\n  event OwnershipTransferred(address indexed previousOwner,address indexed newOwner) ;\\n\\n  event Swapped(address sender,address srcToken,address dstToken,address dstReceiver,uint256 spentAmount,uint256 returnAmount) ;\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32) ;\\n\\n  function LIMIT_ORDER_RFQ_TYPEHASH() external view returns (bytes32) ;\\n\\n  function cancelOrderRFQ(uint256 orderInfo) external;\\n\\n  function destroy() external;\\n\\n  function fillOrderRFQ(LimitOrderProtocolRFQ.OrderRFQ memory order,bytes memory signature,uint256 makingAmount,uint256 takingAmount) external payable returns (uint256 , uint256) ;\\n\\n  function fillOrderRFQTo(LimitOrderProtocolRFQ.OrderRFQ memory order,bytes memory signature,uint256 makingAmount,uint256 takingAmount,address target) external payable returns (uint256 , uint256) ;\\n\\n  function fillOrderRFQToWithPermit(LimitOrderProtocolRFQ.OrderRFQ memory order,bytes memory signature,uint256 makingAmount,uint256 takingAmount,address target,bytes memory permit) external  returns (uint256 , uint256) ;\\n\\n  function invalidatorForOrderRFQ(address maker,uint256 slot) external view returns (uint256) ;\\n\\n  function owner() external view returns (address) ;\\n\\n  function renounceOwnership() external;\\n\\n  function rescueFunds(address token,uint256 amount) external;\\n\\n  function swap(address caller,SwapDescription memory desc,bytes memory data) external payable returns (uint256 returnAmount, uint256 gasLeft);\\n\\n  function transferOwnership(address newOwner) external;\\n\\n  function uniswapV3Swap(uint256 amount,uint256 minReturn,uint256[] memory pools) external payable returns (uint256 returnAmount) ;\\n\\n  function uniswapV3SwapCallback(int256 amount0Delta,int256 amount1Delta,bytes memory ) external;\\n\\n  function uniswapV3SwapTo(address recipient,uint256 amount,uint256 minReturn,uint256[] memory pools) external payable returns (uint256 returnAmount) ;\\n\\n  function uniswapV3SwapToWithPermit(address recipient,address srcToken,uint256 amount,uint256 minReturn,uint256[] memory pools,bytes memory permit) external  returns (uint256 returnAmount) ;\\n\\n  function unoswap(address srcToken,uint256 amount,uint256 minReturn,bytes32[] memory pools) external payable returns (uint256 returnAmount) ;\\n\\n  function unoswapWithPermit(address srcToken,uint256 amount,uint256 minReturn,bytes32[] memory pools,bytes memory permit) external  returns (uint256 returnAmount) ;\\n\\n  receive () external payable;\\n}\\n\\ninterface LimitOrderProtocolRFQ {\\n  struct OrderRFQ {\\n    uint256 info;\\n    address makerAsset;\\n    address takerAsset;\\n    address maker;\\n    address allowedSender;\\n    uint256 makingAmount;\\n    uint256 takingAmount;\\n  }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IChainlinkOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\ninterface IChainlinkOracle {\\n    function latestAnswer() external view returns (int256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ICustomPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\ninterface ICustomPriceOracle {\\n    function getPriceInUSD() external returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IWETH9.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\ninterface IWETH9 {\\n    function deposit() external payable;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the decimals.\\n     */\\n    function decimals() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IAddress.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary ISafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_aggregationRouterV4Address\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_wethAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fillIndex\",\"type\":\"uint256\"}],\"name\":\"LogNewFill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogNewOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogOrderKilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"oracleAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isChainlink\",\"type\":\"bool\"}],\"internalType\":\"struct TZWAP.Oracle\",\"name\":\"oracle\",\"type\":\"tuple\"}],\"name\":\"addOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorized\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aggregationRouterV4\",\"outputs\":[{\"internalType\":\"contract I1inchAggregationRouterV4\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapType\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permit\",\"type\":\"bytes\"}],\"internalType\":\"struct I1inchAggregationRouterV4.SwapDescription\",\"name\":\"desc\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct TZWAP.swapParams\",\"name\":\"_swapParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"pools\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct TZWAP.unoswapParams\",\"name\":\"_unoswapParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"pools\",\"type\":\"uint256[]\"}],\"internalType\":\"struct TZWAP.uniswapV3Params\",\"name\":\"_uniswapV3Params\",\"type\":\"tuple\"}],\"name\":\"fillOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fills\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ticksFilled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"srcTokensSwapped\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dstTokensReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getDstTokensReceivedForOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getSrcTokensSwappedForOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getSrcTokensToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTicksFilled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTicksToFill\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTimeElapsedSinceLastFill\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isOrderActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWhitelistActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"killOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minNumOfIntervals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tickSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"created\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"killed\",\"type\":\"bool\"}],\"internalType\":\"struct TZWAP.TWAPOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"newOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"oracles\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"oracleAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isChainlink\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tickSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"created\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"killed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentagePrecision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorized\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"toggleWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userOrders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH9\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TZWAP", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000001111111254fb6c44bac0bed2854e76f90643097d000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}