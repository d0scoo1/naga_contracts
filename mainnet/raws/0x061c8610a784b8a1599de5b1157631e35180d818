{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/allocators/RariFuseAllocator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.10;\\n\\n// interfaces\\nimport \\\"./interfaces/RariInterfaces.sol\\\";\\n\\n// types\\nimport {BaseAllocator, AllocatorInitData} from \\\"../types/BaseAllocator.sol\\\";\\n\\n/// @dev function argument\\nstruct fData {\\n    fToken f;\\n    uint96 idTroller;\\n    IERC20 base;\\n    IERC20 rT;\\n}\\n\\nstruct ProtocolSpecificData {\\n    address treasury;\\n    address rewards;\\n}\\n\\nstruct FuseAllocatorInitData {\\n    AllocatorInitData base;\\n    ProtocolSpecificData spec;\\n}\\n\\ncontract RariFuseAllocator is BaseAllocator {\\n    address public treasury;\\n\\n    RewardsDistributorDelegate internal _rewards;\\n\\n    fToken[] internal _fTokens;\\n    IERC20[] internal _rewardTokens;\\n\\n    RariTroller[] internal _trollers;\\n\\n    constructor(FuseAllocatorInitData memory fuseData) BaseAllocator(fuseData.base) {\\n        _rewards = RewardsDistributorDelegate(fuseData.spec.rewards);\\n        treasury = fuseData.spec.treasury;\\n    }\\n\\n    function _update(uint256 id) internal override returns (uint128 gain, uint128 loss) {\\n        // reads\\n        uint256 index = tokenIds[id];\\n        fToken f = _fTokens[index];\\n        IERC20Metadata b = IERC20Metadata(address(_tokens[index]));\\n        RewardsDistributorDelegate rewards = _rewards;\\n        uint256 balance = b.balanceOf(address(this));\\n\\n        // interactions\\n        if (rewards.compAccrued(address(this)) > 0) rewards.claimRewards(address(this));\\n\\n        if (balance > 0) {\\n            b.approve(address(f), balance);\\n            f.mint(balance);\\n        }\\n\\n        // effects\\n        uint256 former = extender.getAllocatorAllocated(id) + extender.getAllocatorPerformance(id).gain;\\n        uint256 current = _worth(f, b);\\n\\n        if (current >= former) gain = uint128(current - former);\\n        else loss = uint128(former - current);\\n    }\\n\\n    function deallocate(uint256[] memory amounts) public override onlyGuardian {\\n        uint256 length = amounts.length;\\n\\n        for (uint256 i; i < length; i++) {\\n            fToken f = _fTokens[i];\\n\\n            uint256 balance = f.balanceOf(address(this));\\n\\n            if (balance > 0) {\\n                if (amounts[i] == type(uint256).max) f.redeem(balance);\\n                else f.redeemUnderlying(amounts[i]);\\n            }\\n        }\\n    }\\n\\n    function _deactivate(bool panic) internal override {\\n        _deallocateAll();\\n\\n        if (panic) {\\n            uint256 length = _fTokens.length;\\n\\n            for (uint256 i; i < length; i++) {\\n                fToken f = _fTokens[i];\\n                IERC20 u = _tokens[i];\\n                uint256 balance = f.balanceOf(address(this));\\n\\n                if (balance > 0) {\\n                    f.redeem(balance);\\n                    u.transfer(treasury, u.balanceOf(address(this)));\\n                }\\n            }\\n\\n            length = _rewardTokens.length;\\n\\n            for (uint256 i; i < length; i++) {\\n                IERC20 rT = _rewardTokens[i];\\n                uint256 balance = rT.balanceOf(address(this));\\n\\n                if (balance > 0) {\\n                    rT.transfer(treasury, balance);\\n                }\\n            }\\n        }\\n    }\\n\\n    function _prepareMigration() internal override {\\n        RewardsDistributorDelegate rewards = _rewards;\\n        if (rewards.compAccrued(address(this)) > 0) rewards.claimRewards(address(this));\\n    }\\n\\n    function amountAllocated(uint256 id) public view override returns (uint256) {\\n        uint256 index = tokenIds[id];\\n        IERC20Metadata b = IERC20Metadata(address(_tokens[index]));\\n        fToken f = _fTokens[index];\\n        return _worth(f.exchangeRateStored(), f.balanceOf(address(this)), b) + b.balanceOf(address(this));\\n    }\\n\\n    function rewardTokens() public view override returns (IERC20[] memory) {\\n        return _rewardTokens;\\n    }\\n\\n    function utilityTokens() public view override returns (IERC20[] memory) {\\n        uint256 length = _fTokens.length;\\n        IERC20[] memory uTokens = new IERC20[](length);\\n        for (uint256 i; i < length; i++) uTokens[i] = _fTokens[i];\\n        return uTokens;\\n    }\\n\\n    function name() external pure override returns (string memory) {\\n        return \\\"RariFuseAllocator\\\";\\n    }\\n\\n    //// start of functions specific for allocator\\n\\n    function setTreasury(address newTreasury) external onlyGuardian {\\n        treasury = newTreasury;\\n    }\\n\\n    function setRewards(address newRewards) external onlyGuardian {\\n        _rewards = RewardsDistributorDelegate(newRewards);\\n    }\\n\\n    /// @notice Add a fuse pool by adding the troller.\\n    /// @dev The troller is a comptroller, which is a contract that has all the data and allows entering markets in regards to a fuse pool.\\n    /// @param troller the trollers' address\\n    function fusePoolAdd(address troller) external onlyGuardian {\\n        _trollers.push(RariTroller(troller));\\n    }\\n\\n    /// @notice Add data for depositing an underlying token in a fuse pool.\\n    /// @dev The data fields are described above in the struct `fData` specific for this contract.\\n    /// @param data the data necessary for another token to be allocated, check the struct in code\\n    function fDataAdd(fData calldata data) external onlyGuardian {\\n        // reads\\n        address[] memory fInput = new address[](1);\\n        fInput[0] = address(data.f);\\n\\n        // interaction\\n        _trollers[data.idTroller].enterMarkets(fInput);\\n\\n        data.base.approve(address(extender), type(uint256).max);\\n        data.f.approve(address(extender), type(uint256).max);\\n\\n        // effect\\n        _fTokens.push(data.f);\\n        _tokens.push(data.base);\\n\\n        if (data.rT != IERC20(address(0))) {\\n            _rewardTokens.push(data.rT);\\n            data.rT.approve(address(extender), type(uint256).max);\\n        }\\n    }\\n\\n    /// @dev logic is directly from fuse docs\\n    function _worth(fToken f, IERC20Metadata b) internal returns (uint256) {\\n        return (f.exchangeRateCurrent() * f.balanceOf(address(this))) / (10**uint256(b.decimals()));\\n    }\\n\\n    function _worth(\\n        uint256 exchangeRate,\\n        uint256 fBalance,\\n        IERC20Metadata b\\n    ) internal view returns (uint256) {\\n        return (exchangeRate * fBalance) / (10**uint256(b.decimals()));\\n    }\\n\\n    function _deallocateAll() internal {\\n        uint256[] memory input = new uint256[](_fTokens.length);\\n        for (uint256 i; i < input.length; i++) input[i] = type(uint256).max;\\n        deallocate(input);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/allocators/interfaces/RariInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.10;\\n\\nimport \\\"../../interfaces/IERC20Metadata.sol\\\";\\n\\n// if you don't call the function the compiler won't bloat code\\n// so just take the entire interface so people don't have to add later\\ninterface fToken is IERC20Metadata {\\n    function mint(uint256 mintAmount) external;\\n\\n    function mint() external payable; // ether\\n\\n    function redeem(uint256 redeemTokens) external returns (uint256);\\n\\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\\n\\n    function borrow(uint256 borrowAmount) external returns (uint256);\\n\\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\\n\\n    function repayBorrow() external payable; // ether\\n\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\\n\\n    function repayBorrowBehalf(address borrower) external payable; // ether\\n\\n    function liquidateBorrow(\\n        address borrower,\\n        uint256 amount,\\n        address collateral\\n    ) external returns (uint256);\\n\\n    function exchangeRateCurrent() external returns (uint256);\\n\\n    function exchangeRateStored() external view returns (uint256);\\n\\n    function getCash() external view returns (uint256);\\n\\n    function totalBorrowsCurrent() external view returns (uint256);\\n\\n    function borrowBalanceCurrent(address account) external view returns (uint256);\\n\\n    function borrowRatePerBlock() external view returns (uint256);\\n\\n    function balanceOfUnderlying(address account) external view returns (uint256);\\n\\n    function supplyRatePerBlock() external view returns (uint256);\\n\\n    function totalReserves() external view returns (uint256);\\n\\n    function reserveFactorMantissa() external view returns (uint256);\\n}\\n\\ninterface RariTroller {\\n    function enterMarkets(address[] calldata fTokens) external returns (uint256[] memory);\\n\\n    function allMarkets(uint256) external view returns (address);\\n\\n    function getAllMarkets() external view returns (address[] memory);\\n\\n    function exitMarket(address fToken) external returns (uint256);\\n\\n    function getAssetsIn(address account) external view returns (address[] memory);\\n\\n    function markets(address fTokenAddress)\\n        external\\n        view\\n        returns (\\n            bool,\\n            uint256,\\n            bool\\n        );\\n\\n    function getAccountLiquidity(address account)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function closeFactorMantissa() external view returns (uint256);\\n\\n    function liquidationIncentiveMantissa() external view returns (uint256);\\n}\\n\\nstruct FusePool {\\n    string name;\\n    address creator;\\n    address comptroller;\\n    uint256 blockPosted;\\n    uint256 timestampPosted;\\n}\\n\\ninterface FusePoolDirectory {\\n    function pools(uint256)\\n        external\\n        view\\n        returns (\\n            string memory name,\\n            address creator,\\n            address comptroller,\\n            uint256 blockPosted,\\n            uint256 timestampPosted\\n        );\\n\\n    function getPoolsByAccount(address account) external returns (uint256[] memory, FusePool[] memory);\\n}\\n\\nstruct FusePoolAsset {\\n    address fToken;\\n    address underlyingToken;\\n    string underlyingName;\\n    string underlyingSymbol;\\n    uint256 underlyingDecimals;\\n    uint256 underlyingBalance;\\n    uint256 supplyRatePerBlock;\\n    uint256 borrowRatePerBlock;\\n    uint256 totalSupply;\\n    uint256 totalBorrow;\\n    uint256 supplyBalance;\\n    uint256 borrowBalance;\\n    uint256 liquidity;\\n    bool membership;\\n    uint256 exchangeRate;\\n    uint256 underlyingPrice;\\n    address oracle;\\n    uint256 collateralFactor;\\n    uint256 reserveFactor;\\n    uint256 adminFee;\\n    uint256 fuseFee;\\n}\\n\\nstruct FusePoolUser {\\n    address account;\\n    uint256 totalBorrow;\\n    uint256 totalCollateral;\\n    uint256 health;\\n    FusePoolAsset[] assets;\\n}\\n\\nstruct CTokenOwnership {\\n    address cToken;\\n    address admin;\\n    bool adminHasRights;\\n    bool fuseAdminHasRight;\\n}\\n\\n// frankly useless for us I don't understand why former wasn't documented\\ninterface FusePoolLens {\\n    function getPublicPoolsWithData()\\n        external\\n        view\\n        returns (\\n            uint256[] memory,\\n            FusePool[] memory,\\n            uint256[] memory,\\n            uint256[] memory,\\n            address[][] memory,\\n            string[][] memory,\\n            bool[] memory\\n        );\\n\\n    function getPoolsByAccountWithData(address account)\\n        external\\n        view\\n        returns (\\n            uint256[] memory,\\n            FusePool[] memory,\\n            uint256[] memory,\\n            uint256[] memory,\\n            address[][] memory,\\n            string[][] memory,\\n            bool[] memory\\n        );\\n\\n    function getPoolSummary(address comptroller)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            address[] memory,\\n            string[] memory\\n        );\\n\\n    function getPoolAssetsWithData(address comptroller) external view returns (FusePoolAsset[] memory);\\n\\n    function getPublicPoolUsersWithData(uint256 maxHealth)\\n        external\\n        view\\n        returns (\\n            address[] memory,\\n            FusePoolUser[][] memory,\\n            uint256[] memory,\\n            uint256[] memory,\\n            bool\\n        );\\n\\n    function getPoolUsersWithData(address comptroller, uint256 maxHealth)\\n        external\\n        view\\n        returns (\\n            FusePoolUser[] memory,\\n            uint256,\\n            uint256\\n        );\\n\\n    function getPoolsBySupplier(address account) external view returns (uint256[] memory, FusePool[] memory);\\n\\n    function getPoolsBySupplierWithData(address account)\\n        external\\n        view\\n        returns (\\n            uint256[] memory,\\n            FusePool[] memory,\\n            uint256[] memory,\\n            uint256[] memory,\\n            address[][] memory,\\n            string[][] memory,\\n            bool[] memory\\n        );\\n\\n    function getUserSummary(address account)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            bool\\n        );\\n\\n    function getPoolUserSummary(address comptroller, address account) external view returns (uint256, uint256);\\n\\n    function getWhitelistedPoolsByAccount(address account) external view returns (uint256[] memory, FusePool[] memory);\\n\\n    function getWhitelistedPoolsByAccountWithData(address account)\\n        external\\n        returns (\\n            uint256[] memory,\\n            FusePool[] memory,\\n            uint256[] memory,\\n            uint256[] memory,\\n            address[][] memory,\\n            string[][] memory,\\n            bool[] memory\\n        );\\n\\n    function getPoolOwnership(address comptroller)\\n        external\\n        returns (\\n            address,\\n            bool,\\n            bool,\\n            CTokenOwnership[] memory\\n        );\\n}\\n\\n// TRIBE rewards\\ninterface RewardsDistributorDelegate {\\n    function claimRewards(address holder) external;\\n\\n    function compAccrued(address) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/types/BaseAllocator.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\n// interfaces\\nimport \\\"../interfaces/IAllocator.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\n\\n// types\\nimport \\\"../types/OlympusAccessControlledV2.sol\\\";\\n\\n// libraries\\nimport \\\"../libraries/SafeERC20.sol\\\";\\n\\nerror BaseAllocator_AllocatorNotActivated();\\nerror BaseAllocator_AllocatorNotOffline();\\nerror BaseAllocator_Migrating();\\nerror BaseAllocator_NotMigrating();\\nerror BaseAllocator_OnlyExtender(address sender);\\n\\n/**\\n * @title BaseAllocator\\n * @notice\\n *  This abstract contract serves as a template for writing new Olympus Allocators.\\n *  Many of the functionalities regarding handling of Treasury funds by the Guardian have\\n *  been delegated to the `TreasuryExtender` contract, and thus an explanation for them can be found\\n *  in `TreasuryExtender.sol`.\\n *\\n *  The main purpose of this abstract contract and the `IAllocator` interface is to provide\\n *  a unified framework for how an Allocator should behave. Below an explanation of how\\n *  we expect an Allocator to behave in general, mentioning the most important points.\\n *\\n *  Activation:\\n *   - An Allocator is first deployed with all necessary arguments.\\n *     Thereafter, each deposit is registered with the `TreasuryExtender`.\\n *     This assigns a unique id for each deposit (set of allocations) in an Allocator.\\n *   - Next, the Allocators allocation and loss limits are set via the extender function.\\n *   - Finally, the Allocator is activated by calling `activate`.\\n *\\n *  Runtime:\\n *   The Allocator is in communication with the Extender, it must inform the Extender\\n *   what the status of the tokens is which were allocated. We only care about noting down\\n *   their status in the Extender. A quick summary of the important functions on this topic:\\n *\\n *   - `update(uint256 id)` is the main function that deals with state reporting, where\\n *     `_update(uint256 id)` is the internal function to implement, which should update Allocator\\n *     internal state. `update(uint256 id)` then continues to report the Allocators state via `report`\\n *     to the extender. `_update(uint256 id)` should handle _investment_ of funds present in Contract.\\n *\\n *   - `deallocate` should handle allocated token withdrawal, preparing the tokens to be withdrawn\\n *     by the Extender. It is not necessary to handle approvals for this token, because it is automatically\\n *     approved in the constructor. For other token withdrawals, it is assumed that reward tokens will\\n *     either be sold into underlying (allocated) or that they will simply rest in the Contract, being reward tokens.\\n *     Please also check function documentation.\\n *\\n *   - `rewardTokens` and `utilityTokens` should return the above mentioned simple reward tokens for the former case,\\n *     while utility tokens should be those tokens which are continously reinvested or otherwise used by the contract\\n *     in order to accrue more rewards. A reward token can also be a utility token, but then one must prepare them\\n *     separately for withdrawal if they are to be returned to the treasury.\\n *\\n *  Migration & Deactivation:\\n *   - `prepareMigration()` together with the virtual `_prepareMigration()` sets the state of the Allocator into\\n *     MIGRATING, disabling further token deposits, enabling only withdrawals, and preparing all funds for withdrawal.\\n *\\n *   - `migrate` then executes the migration and also deactivates the Allocator.\\n *\\n *   - `deactivate` sets `status` to OFFLINE, meaning it simply deactivates the Allocator. It can be passed\\n *     a panic boolean, meaning it handles deactivation logic in `deactivate`. The Allocator panic deactivates if\\n *     this state if the loss limit is reached via `update`. The Allocator can otherwise also simply be deactivated\\n *     and funds transferred back to the Treasury.\\n *\\n *  This was a short summary of the Allocator lifecycle.\\n */\\nabstract contract BaseAllocator is OlympusAccessControlledV2, IAllocator {\\n    using SafeERC20 for IERC20;\\n\\n    // Indices which represent the ids of the deposits in the `TreasuryExtender`\\n    uint256[] internal _ids;\\n\\n    // The allocated (underlying) tokens of the Allocator\\n    IERC20[] internal _tokens;\\n\\n    // From deposit id to the token's id\\n    mapping(uint256 => uint256) public tokenIds;\\n\\n    // Allocator status: OFFLINE, ACTIVATED, MIGRATING\\n    AllocatorStatus public status;\\n\\n    // The extender with which the Allocator communicates.\\n    ITreasuryExtender public immutable extender;\\n\\n    constructor(AllocatorInitData memory data) OlympusAccessControlledV2(data.authority) {\\n        _tokens = data.tokens;\\n        extender = data.extender;\\n\\n        for (uint256 i; i < data.tokens.length; i++) {\\n            data.tokens[i].approve(address(data.extender), type(uint256).max);\\n        }\\n\\n        emit AllocatorDeployed(address(data.authority), address(data.extender));\\n    }\\n\\n    /////// MODIFIERS\\n\\n    modifier onlyExtender {\\n\\t_onlyExtender(msg.sender);\\n\\t_;\\n    }\\n\\n    modifier onlyActivated {\\n\\t_onlyActivated(status);\\n\\t_;\\n    }\\n\\n    modifier onlyOffline {\\n\\t_onlyOffline(status);\\n\\t_;\\n    }\\n\\n    modifier notMigrating {\\n\\t_notMigrating(status);\\n\\t_;\\n    }\\n\\n    modifier isMigrating {\\n\\t_isMigrating(status);\\n\\t_;\\n    }\\n\\n    /////// VIRTUAL FUNCTIONS WHICH NEED TO BE IMPLEMENTED\\n    /////// SORTED BY EXPECTED COMPLEXITY AND DEPENDENCY\\n\\n    /**\\n     * @notice\\n     *  Updates an Allocators state.\\n     * @dev\\n     *  This function should be implemented by the developer of the Allocator.\\n     *  This function should fulfill the following purposes:\\n     *   - invest token specified by deposit id\\n     *   - handle rebalancing / harvesting for token as needed\\n     *   - calculate gain / loss for token and return those values\\n     *   - handle any other necessary runtime calculations, such as fees etc.\\n     *\\n     *  In essence, this function should update the main runtime state of the Allocator\\n     *  so that everything is properly invested, harvested, accounted for.\\n     * @param id the id of the deposit in the `TreasuryExtender`\\n     */\\n    function _update(uint256 id) internal virtual returns (uint128 gain, uint128 loss);\\n\\n    /**\\n     * @notice\\n     *  Deallocates tokens, prepares tokens for return to the Treasury.\\n     * @dev\\n     *  This function should deallocate (withdraw) `amounts` of each token so that they may be withdrawn\\n     *  by the TreasuryExtender. Otherwise, this function may also prepare the withdraw if it is time-bound.\\n     * @param amounts is the amount of each of token from `_tokens` to withdraw\\n     */\\n    function deallocate(uint256[] memory amounts) public virtual;\\n\\n    /**\\n     * @notice\\n     *  Handles deactivation logic for the Allocator.\\n     */\\n    function _deactivate(bool panic) internal virtual;\\n\\n    /**\\n     * @notice\\n     *  Handles migration preparatory logic.\\n     * @dev\\n     *  Within this function, the developer should arrange the withdrawal of all assets for migration.\\n     *  A useful function, say, to be passed into this could be `deallocate` with all of the amounts,\\n     *  so with n places for n-1 utility tokens + 1 allocated token, maxed out.\\n     */\\n    function _prepareMigration() internal virtual;\\n\\n    /**\\n     * @notice\\n     *  Should estimate total amount of Allocated tokens\\n     * @dev\\n     *  The difference between this and `treasury.getAllocatorAllocated`, is that the latter is a static\\n     *  value recorded during reporting, but no data is available on _new_ amounts after reporting.\\n     *  Thus, this should take into consideration the new amounts. This can be used for say aTokens.\\n     * @param id the id of the deposit in `TreasuryExtender`\\n     */\\n    function amountAllocated(uint256 id) public view virtual returns (uint256);\\n\\n    /**\\n     * @notice\\n     *  Should return all reward token addresses\\n     */\\n    function rewardTokens() public view virtual returns (IERC20[] memory);\\n\\n    /**\\n     * @notice\\n     *  Should return all utility token addresses\\n     */\\n    function utilityTokens() public view virtual returns (IERC20[] memory);\\n\\n    /**\\n     * @notice\\n     *  Should return the Allocator name\\n     */\\n    function name() external view virtual returns (string memory);\\n\\n    /////// IMPLEMENTATION OPTIONAL\\n\\n    /**\\n     * @notice\\n     *  Should handle activation logic\\n     * @dev\\n     *  If there is a need to handle any logic during activation, this is the function you should implement it into\\n     */\\n    function _activate() internal virtual {}\\n\\n    /////// FUNCTIONS\\n\\n    /**\\n     * @notice\\n     *  Updates an Allocators state and reports to `TreasuryExtender` if necessary.\\n     * @dev\\n     *  Can only be called by the Guardian.\\n     *  Can only be called while the Allocator is activated.\\n     *\\n     *  This function should update the Allocators internal state via `_update`, which should in turn\\n     *  return the `gain` and `loss` the Allocator has sustained in underlying allocated `token` from `_tokens`\\n     *  decided by the `id`.\\n     *  Please check the docs on `_update` to see what its function should be.\\n     *\\n     *  `_lossLimitViolated` checks if the Allocators is above its loss limit and deactivates it in case\\n     *  of serious losses. The loss limit should be set to some value which is unnacceptable to be lost\\n     *  in the case of normal runtime and thus require a panic shutdown, whatever it is defined to be.\\n     *\\n     *  Lastly, the Allocator reports its state to the Extender, which handles gain, loss, allocated logic.\\n     *  The documentation on this can be found in `TreasuryExtender.sol`.\\n     * @param id the id of the deposit in `TreasuryExtender`\\n     */\\n    function update(uint256 id) external override onlyGuardian onlyActivated {\\n        // effects\\n        // handle depositing, harvesting, compounding logic inside of _update()\\n        // if gain is in allocated then gain > 0 otherwise gain == 0\\n        // we only use so we know initia\\n        // loss always in allocated\\n        (uint128 gain, uint128 loss) = _update(id);\\n\\n        if (_lossLimitViolated(id, loss)) {\\n            deactivate(true);\\n            return;\\n        }\\n\\n        // interactions\\n        // there is no interactions happening inside of report\\n        // so allocator has no state changes to make after it\\n        if (gain + loss > 0) extender.report(id, gain, loss);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Prepares the Allocator for token migration.\\n     * @dev\\n     *  This function prepares the Allocator for token migration by calling the to-be-implemented\\n     *  `_prepareMigration`, which should logically withdraw ALL allocated (1) + utility AND reward tokens\\n     *  from the contract. The ALLOCATED token and THE UTILITY TOKEN is going to be migrated, while the REWARD\\n     *  tokens can be withdrawn by the Extender to the Treasury.\\n     */\\n    function prepareMigration() external override onlyGuardian notMigrating {\\n        // effects\\n        _prepareMigration();\\n\\n        status = AllocatorStatus.MIGRATING;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Migrates the allocated and all utility tokens to the next Allocator.\\n     * @dev\\n     *  The allocated token and the utility tokens will be migrated by this function, while it is\\n     *  assumed that the reward tokens are either simply kept or already harvested into the underlying\\n     *  essentially being the edge case of this contract. This contract is also going to report to the\\n     *  Extender that a migration happened and as such it is important to follow the proper sequence of\\n     *  migrating.\\n     *\\n     *  Steps to migrate:\\n     *   - FIRST call `_prepareMigration()` to prepare funds for migration.\\n     *   - THEN deploy the new Allocator and activate it according to the normal procedure.\\n     *     NOTE: This is to be done RIGHT BEFORE migration as to avoid allocating to the wrong allocator.\\n     *   - FINALLY call migrate. This is going to migrate the funds to the LAST allocator registered.\\n     *   - Check if everything went fine.\\n     *\\n     *  End state should be that allocator amounts have been swapped for allocators, that gain + loss is netted out 0\\n     *  for original allocator, and that the new allocators gain has been set to the original allocators gain.\\n     *  We don't transfer the loss because we have the information how much was initially invested + gain,\\n     *  and the new allocator didn't cause any loss thus we don't really need to add to it.\\n     */\\n    function migrate() external override onlyGuardian isMigrating {\\n        // reads\\n        IERC20[] memory utilityTokensArray = utilityTokens();\\n        address newAllocator = extender.getAllocatorByID(extender.getTotalAllocatorCount() - 1);\\n\\tuint256 idLength = _ids.length;\\n\\tuint256 utilLength = utilityTokensArray.length;\\n\\n        // interactions\\n        for (uint256 i; i < idLength; i++) {\\n            IERC20 token = _tokens[i];\\n\\n            token.safeTransfer(newAllocator, token.balanceOf(address(this)));\\n            extender.report(_ids[i], type(uint128).max, type(uint128).max);\\n        }\\n\\n        for (uint256 i; i < utilLength; i++) {\\n            IERC20 utilityToken = utilityTokensArray[i];\\n            utilityToken.safeTransfer(newAllocator, utilityToken.balanceOf(address(this)));\\n        }\\n\\n        // turn off Allocator\\n        deactivate(false);\\n\\n        emit MigrationExecuted(newAllocator);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Activates the Allocator.\\n     * @dev\\n     *  Only the Guardian can call this.\\n     *\\n     *  Add any logic you need during activation, say interactions with Extender or something else,\\n     *  in the virtual method `_activate`.\\n     */\\n    function activate() external override onlyGuardian onlyOffline {\\n        // effects\\n        _activate();\\n        status = AllocatorStatus.ACTIVATED;\\n\\n        emit AllocatorActivated();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Adds a deposit ID to the Allocator.\\n     * @dev\\n     *  Only the Extender calls this.\\n     * @param id id to add to the allocator\\n     */\\n    function addId(uint256 id) external override onlyExtender {\\n        _ids.push(id);\\n        tokenIds[id] = _ids.length - 1;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Returns all deposit IDs registered with the Allocator.\\n     * @return the deposit IDs registered\\n     */\\n    function ids() external view override returns (uint256[] memory) {\\n        return _ids;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Returns all tokens registered with the Allocator.\\n     * @return the tokens\\n     */\\n    function tokens() external view override returns (IERC20[] memory) {\\n        return _tokens;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Deactivates the Allocator.\\n     * @dev\\n     *  Only the Guardian can call this.\\n     *\\n     *  Add any logic you need during deactivation, say interactions with Extender or something else,\\n     *  in the virtual method `_deactivate`. Be careful to specifically use the internal or public function\\n     *  depending on what you need.\\n     * @param panic should panic logic be executed\\n     */\\n    function deactivate(bool panic) public override onlyGuardian {\\n        // effects\\n        _deactivate(panic);\\n        status = AllocatorStatus.OFFLINE;\\n\\n        emit AllocatorDeactivated(panic);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Getter for Allocator version.\\n     * @return Returns the Allocators version.\\n     */\\n    function version() public pure override returns (string memory) {\\n        return \\\"v2.0.0\\\";\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check if the loss limit has been violated by the Allocator.\\n     * @dev\\n     *  Called as part of `update`. The rule is that the already sustained loss + newly sustained\\n     *  has to be larger or equal to the limit to break the contract.\\n     * @param id deposit id as in `TreasuryExtender`\\n     * @param loss the amount of newly sustained loss\\n     * @return true if the the loss limit has been broken\\n     */\\n    function _lossLimitViolated(uint256 id, uint128 loss) internal returns (bool) {\\n        // read\\n        uint128 lastLoss = extender.getAllocatorPerformance(id).loss;\\n\\n        // events\\n        if ((loss + lastLoss) >= extender.getAllocatorLimits(id).loss) {\\n            emit LossLimitViolated(lastLoss, loss, amountAllocated(tokenIds[id]));\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if sender is extender.\\n     */\\n    function _onlyExtender(address sender) internal view {\\n        if (sender != address(extender)) revert BaseAllocator_OnlyExtender(sender);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is activated.\\n     */\\n    function _onlyActivated(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus != AllocatorStatus.ACTIVATED) revert BaseAllocator_AllocatorNotActivated();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is offline.\\n     */\\n    function _onlyOffline(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus != AllocatorStatus.OFFLINE) revert BaseAllocator_AllocatorNotOffline();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is not migrating.\\n     */\\n    function _notMigrating(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus == AllocatorStatus.MIGRATING) revert BaseAllocator_Migrating();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is migrating.\\n     */\\n    function _isMigrating(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus != AllocatorStatus.MIGRATING) revert BaseAllocator_NotMigrating();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAllocator.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\n// interfaces\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ITreasuryExtender.sol\\\";\\nimport \\\"./IOlympusAuthority.sol\\\";\\n\\nenum AllocatorStatus {\\n    OFFLINE,\\n    ACTIVATED,\\n    MIGRATING\\n}\\n\\nstruct AllocatorInitData {\\n    IOlympusAuthority authority;\\n    ITreasuryExtender extender;\\n    IERC20[] tokens;\\n}\\n\\n/**\\n * @title Interface for the BaseAllocator\\n * @dev\\n *  These are the standard functions that an Allocator should implement. A subset of these functions\\n *  is implemented in the `BaseAllocator`. Similar to those implemented, if for some reason the developer\\n *  decides to implement a dedicated base contract, or not at all and rather a dedicated Allocator contract\\n *  without base, imitate the functionalities implemented in it.\\n */\\ninterface IAllocator {\\n    /**\\n     * @notice\\n     *  Emitted when the Allocator is deployed.\\n     */\\n    event AllocatorDeployed(address authority, address extender);\\n\\n    /**\\n     * @notice\\n     *  Emitted when the Allocator is activated.\\n     */\\n    event AllocatorActivated();\\n\\n    /**\\n     * @notice\\n     *  Emitted when the Allocator is deactivated.\\n     */\\n    event AllocatorDeactivated(bool panic);\\n\\n    /**\\n     * @notice\\n     *  Emitted when the Allocators loss limit is violated.\\n     */\\n    event LossLimitViolated(uint128 lastLoss, uint128 dloss, uint256 estimatedTotalAllocated);\\n\\n    /**\\n     * @notice\\n     *  Emitted when a Migration is executed.\\n     * @dev\\n     *  After this also `AllocatorDeactivated` should follow.\\n     */\\n    event MigrationExecuted(address allocator);\\n\\n    /**\\n     * @notice\\n     *  Emitted when Ether is received by the contract.\\n     * @dev\\n     *  Only the Guardian is able to send the ether.\\n     */\\n    event EtherReceived(uint256 amount);\\n\\n    function update(uint256 id) external;\\n\\n    function deallocate(uint256[] memory amounts) external;\\n\\n    function prepareMigration() external;\\n\\n    function migrate() external;\\n\\n    function activate() external;\\n\\n    function deactivate(bool panic) external;\\n\\n    function addId(uint256 id) external;\\n\\n    function name() external view returns (string memory);\\n\\n    function ids() external view returns (uint256[] memory);\\n\\n    function tokenIds(uint256 id) external view returns (uint256);\\n\\n    function version() external view returns (string memory);\\n\\n    function status() external view returns (AllocatorStatus);\\n\\n    function tokens() external view returns (IERC20[] memory);\\n\\n    function utilityTokens() external view returns (IERC20[] memory);\\n\\n    function rewardTokens() external view returns (IERC20[] memory);\\n\\n    function amountAllocated(uint256 id) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface ITreasury {\\n    function deposit(\\n        uint256 _amount,\\n        address _token,\\n        uint256 _profit\\n    ) external returns (uint256);\\n\\n    function withdraw(uint256 _amount, address _token) external;\\n\\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\\n\\n    function mint(address _recipient, uint256 _amount) external;\\n\\n    function manage(address _token, uint256 _amount) external;\\n\\n    function incurDebt(uint256 amount_, address token_) external;\\n\\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\\n\\n    function excessReserves() external view returns (uint256);\\n\\n    function baseSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/types/OlympusAccessControlledV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\nimport \\\"../interfaces/IOlympusAuthority.sol\\\";\\n\\nerror UNAUTHORIZED();\\nerror AUTHORITY_INITIALIZED();\\n\\n/// @dev Reasoning for this contract = modifiers literaly copy code\\n/// instead of pointing towards the logic to execute. Over many\\n/// functions this bloats contract size unnecessarily.\\n/// imho modifiers are a meme.\\nabstract contract OlympusAccessControlledV2 {\\n    /* ========== EVENTS ========== */\\n\\n    event AuthorityUpdated(IOlympusAuthority authority);\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IOlympusAuthority public authority;\\n\\n    /* ========== Constructor ========== */\\n\\n    constructor(IOlympusAuthority _authority) {\\n        authority = _authority;\\n        emit AuthorityUpdated(_authority);\\n    }\\n\\n    /* ========== \\\"MODIFIERS\\\" ========== */\\n\\n    modifier onlyGovernor {\\n\\t_onlyGovernor();\\n\\t_;\\n    }\\n\\n    modifier onlyGuardian {\\n\\t_onlyGuardian();\\n\\t_;\\n    }\\n\\n    modifier onlyPolicy {\\n\\t_onlyPolicy();\\n\\t_;\\n    }\\n\\n    modifier onlyVault {\\n\\t_onlyVault();\\n\\t_;\\n    }\\n\\n    /* ========== GOV ONLY ========== */\\n\\n    function initializeAuthority(IOlympusAuthority _newAuthority) internal {\\n        if (authority != IOlympusAuthority(address(0))) revert AUTHORITY_INITIALIZED();\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n\\n    function setAuthority(IOlympusAuthority _newAuthority) external {\\n        _onlyGovernor();\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n\\n    /* ========== INTERNAL CHECKS ========== */\\n\\n    function _onlyGovernor() internal view {\\n        if (msg.sender != authority.governor()) revert UNAUTHORIZED();\\n    }\\n\\n    function _onlyGuardian() internal view {\\n        if (msg.sender != authority.guardian()) revert UNAUTHORIZED();\\n    }\\n\\n    function _onlyPolicy() internal view {\\n        if (msg.sender != authority.policy()) revert UNAUTHORIZED();\\n    }\\n\\n    function _onlyVault() internal view {\\n        if (msg.sender != authority.vault()) revert UNAUTHORIZED();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.5;\\n\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\\n/// Taken from Solmate\\nlibrary SafeERC20 {\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        (bool success, ) = to.call{value: amount}(new bytes(0));\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasuryExtender.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\nstruct AllocatorPerformance {\\n    uint128 gain;\\n    uint128 loss;\\n}\\n\\nstruct AllocatorLimits {\\n    uint128 allocated;\\n    uint128 loss;\\n}\\n\\nstruct AllocatorHoldings {\\n    uint256 allocated;\\n}\\n\\nstruct AllocatorData {\\n    AllocatorHoldings holdings;\\n    AllocatorLimits limits;\\n    AllocatorPerformance performance;\\n}\\n\\n/**\\n * @title Interface for the TreasuryExtender\\n */\\ninterface ITreasuryExtender {\\n    /**\\n     * @notice\\n     *  Emitted when a new Deposit is registered.\\n     */\\n    event NewDepositRegistered(address allocator, address token, uint256 id);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator is funded\\n     */\\n    event AllocatorFunded(uint256 id, uint256 amount, uint256 value);\\n\\n    /**\\n     * @notice\\n     *  Emitted when allocated funds are withdrawn from an Allocator\\n     */\\n    event AllocatorWithdrawal(uint256 id, uint256 amount, uint256 value);\\n\\n    /**\\n     * @notice\\n     *  Emitted when rewards are withdrawn from an Allocator\\n     */\\n    event AllocatorRewardsWithdrawal(address allocator, uint256 amount, uint256 value);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator reports a gain\\n     */\\n    event AllocatorReportedGain(uint256 id, uint128 gain);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator reports a loss\\n     */\\n    event AllocatorReportedLoss(uint256 id, uint128 loss);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator reports a migration\\n     */\\n    event AllocatorReportedMigration(uint256 id);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator limits are modified\\n     */\\n    event AllocatorLimitsChanged(uint256 id, uint128 allocationLimit, uint128 lossLimit);\\n\\n    function registerDeposit(address newAllocator) external;\\n\\n    function setAllocatorLimits(uint256 id, AllocatorLimits memory limits) external;\\n\\n    function report(\\n        uint256 id,\\n        uint128 gain,\\n        uint128 loss\\n    ) external;\\n\\n    function requestFundsFromTreasury(uint256 id, uint256 amount) external;\\n\\n    function returnFundsToTreasury(uint256 id, uint256 amount) external;\\n\\n    function returnRewardsToTreasury(\\n        uint256 id,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    function getTotalAllocatorCount() external view returns (uint256);\\n\\n    function getAllocatorByID(uint256 id) external view returns (address);\\n\\n    function getAllocatorAllocated(uint256 id) external view returns (uint256);\\n\\n    function getAllocatorLimits(uint256 id) external view returns (AllocatorLimits memory);\\n\\n    function getAllocatorPerformance(uint256 id) external view returns (AllocatorPerformance memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOlympusAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IOlympusAuthority {\\n    /* ========== EVENTS ========== */\\n\\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n\\n    event GovernorPulled(address indexed from, address indexed to);\\n    event GuardianPulled(address indexed from, address indexed to);\\n    event PolicyPulled(address indexed from, address indexed to);\\n    event VaultPulled(address indexed from, address indexed to);\\n\\n    /* ========== VIEW ========== */\\n\\n    function governor() external view returns (address);\\n\\n    function guardian() external view returns (address);\\n\\n    function policy() external view returns (address);\\n\\n    function vault() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"authority\",\"type\":\"address\"},{\"internalType\":\"contract ITreasuryExtender\",\"name\":\"extender\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"internalType\":\"struct AllocatorInitData\",\"name\":\"base\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewards\",\"type\":\"address\"}],\"internalType\":\"struct ProtocolSpecificData\",\"name\":\"spec\",\"type\":\"tuple\"}],\"internalType\":\"struct FuseAllocatorInitData\",\"name\":\"fuseData\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BaseAllocator_AllocatorNotActivated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseAllocator_AllocatorNotOffline\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseAllocator_Migrating\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseAllocator_NotMigrating\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"BaseAllocator_OnlyExtender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNAUTHORIZED\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AllocatorActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"panic\",\"type\":\"bool\"}],\"name\":\"AllocatorDeactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"extender\",\"type\":\"address\"}],\"name\":\"AllocatorDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IOlympusAuthority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"lastLoss\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"dloss\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"estimatedTotalAllocated\",\"type\":\"uint256\"}],\"name\":\"LossLimitViolated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"allocator\",\"type\":\"address\"}],\"name\":\"MigrationExecuted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"addId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"amountAllocated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"panic\",\"type\":\"bool\"}],\"name\":\"deactivate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"deallocate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extender\",\"outputs\":[{\"internalType\":\"contract ITreasuryExtender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract fToken\",\"name\":\"f\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"idTroller\",\"type\":\"uint96\"},{\"internalType\":\"contract IERC20\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"rT\",\"type\":\"address\"}],\"internalType\":\"struct fData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"fDataAdd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"troller\",\"type\":\"address\"}],\"name\":\"fusePoolAdd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ids\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prepareMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"_newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRewards\",\"type\":\"address\"}],\"name\":\"setRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"enum AllocatorStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"utilityTokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "RariFuseAllocator", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000600000000000000000000000009a315bdf513367c0377fb36545857d12e85813ef00000000000000000000000073f16f0c0cd1a078a54894974c5c054d8dc1a3d70000000000000000000000001c21f8ea7e39e2ba00bc12d2968d63f4acb38b7a000000000000000000000000b32ad041f23eafd682f57fce31d3ea4fd92d17af00000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}