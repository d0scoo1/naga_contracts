{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.4;\r\n\r\n// import \"hardhat/console.sol\";\r\ninterface IMOLOCH {\r\n    // brief interface for moloch dao v2\r\n\r\n    function depositToken() external view returns (address);\r\n\r\n    function tokenWhitelist(address token) external view returns (bool);\r\n\r\n    function shamans(address token) external view returns (bool);\r\n\r\n    function totalShares() external view returns (uint256);\r\n\r\n    function getProposalFlags(uint256 proposalId)\r\n        external\r\n        view\r\n        returns (bool[6] memory);\r\n\r\n    function getUserTokenBalance(address user, address token)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function members(address user)\r\n        external\r\n        view\r\n        returns (\r\n            address,\r\n            uint256,\r\n            uint256,\r\n            bool,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function memberAddressByDelegateKey(address user)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function userTokenBalances(address user, address token)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function cancelProposal(uint256 proposalId) external;\r\n\r\n    function submitProposal(\r\n        address applicant,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 tributeOffered,\r\n        address tributeToken,\r\n        uint256 paymentRequested,\r\n        address paymentToken,\r\n        string calldata details\r\n    ) external returns (uint256);\r\n\r\n    function withdrawBalance(address token, uint256 amount) external;\r\n\r\n    function collectTokens(address) external;\r\n\r\n    struct Proposal {\r\n        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals (doubles as guild kick target for gkick proposals)\r\n        address proposer; // the account that submitted the proposal (can be non-member)\r\n        address sponsor; // the member that sponsored the proposal (moving it into the queue)\r\n        uint256 sharesRequested; // the # of shares the applicant is requesting\r\n        uint256 lootRequested; // the amount of loot the applicant is requesting\r\n        uint256 tributeOffered; // amount of tokens offered as tribute\r\n        address tributeToken; // tribute token contract reference\r\n        uint256 paymentRequested; // amount of tokens requested as payment\r\n        address paymentToken; // payment token contract reference\r\n        uint256 startingPeriod; // the period in which voting can start for this proposal\r\n        uint256 yesVotes; // the total number of YES votes for this proposal\r\n        uint256 noVotes; // the total number of NO votes for this proposal\r\n        bool[6] flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\r\n        string details; // proposal details - could be IPFS hash, plaintext, or JSON\r\n        uint256 maxTotalSharesAndLootAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\r\n    }\r\n\r\n    function proposals(uint256 proposalId)\r\n        external\r\n        view\r\n        returns (\r\n            address,\r\n            address,\r\n            address,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            address,\r\n            uint256,\r\n            address,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function setSharesLoot(\r\n        address[] calldata,\r\n        uint256[] calldata,\r\n        uint256[] calldata,\r\n        bool mint\r\n    ) external;\r\n\r\n    function setSingleSharesLoot(\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bool\r\n    ) external;\r\n\r\n    function setShaman(address, bool) external;\r\n}\r\n\r\ninterface IWRAPPER {\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract Yeeter is ReentrancyGuard {\r\n    event YeetReceived(\r\n        address indexed contributorAddress,\r\n        uint256 amount,\r\n        address moloch,\r\n        uint256 lootToGive,\r\n        uint256 lootToPlatform\r\n    );\r\n    mapping(address => uint256) public deposits;\r\n    uint256 public maxTarget;\r\n    uint256 public raiseEndTime;\r\n    uint256 public raiseStartTime;\r\n    uint256 public maxUnitsPerAddr;\r\n    uint256 public pricePerUnit;\r\n    uint256 public lootPerUnit;\r\n    bool public initialized;\r\n\r\n    uint256 public platformFee;\r\n\r\n    uint256 public balance;\r\n    IMOLOCH public moloch;\r\n    IWRAPPER public wrapper;\r\n\r\n    YeetSummoner factory;\r\n\r\n    function init(\r\n        address _moloch,\r\n        address payable _wrapper,\r\n        uint256 _maxTarget, // max raise target\r\n        uint256 _raiseEndTime,\r\n        uint256 _raiseStartTime,\r\n        uint256 _maxUnits, // per individual\r\n        uint256 _pricePerUnit\r\n    ) public {\r\n        require(!initialized, \"already initialized\");\r\n        initialized = true;\r\n        moloch = IMOLOCH(_moloch);\r\n        wrapper = IWRAPPER(_wrapper);\r\n        maxTarget = _maxTarget;\r\n        raiseEndTime = _raiseEndTime;\r\n        raiseStartTime = _raiseStartTime;\r\n        maxUnitsPerAddr = _maxUnits;\r\n        pricePerUnit = _pricePerUnit;\r\n\r\n        factory = YeetSummoner(msg.sender);\r\n    }\r\n\r\n    function initTemplate() public {\r\n        initialized = true;\r\n    }\r\n\r\n    function yeetyeet() public payable nonReentrant {\r\n        require(address(moloch) != address(0), \"!init\");\r\n        require(msg.value >= pricePerUnit, \"< minimum\");\r\n        require(balance < maxTarget, \"Max Target reached\"); // balance plus newvalue\r\n        require(block.timestamp < raiseEndTime, \"Time is up\");\r\n        require(block.timestamp > raiseStartTime, \"Not Started\");\r\n        require(moloch.shamans(address(this)), \"Shaman not whitelisted\");\r\n        require(\r\n            moloch.tokenWhitelist(address(wrapper)),\r\n            \"Wrapper not whitelisted\"\r\n        );\r\n        uint256 numUnits = msg.value / pricePerUnit; // floor units\r\n        uint256 newValue = numUnits * pricePerUnit;\r\n\r\n        // if some one yeets over max should we give them the max and return leftover.\r\n        require(\r\n            deposits[msg.sender] + newValue <= maxUnitsPerAddr * pricePerUnit,\r\n            \"Can not deposit more than max\"\r\n        );\r\n\r\n        // wrap\r\n        (bool success, ) = address(wrapper).call{value: newValue}(\"\");\r\n        require(success, \"Wrap failed\");\r\n        // send to dao\r\n        require(wrapper.transfer(address(moloch), newValue), \"Transfer failed\");\r\n\r\n        if (msg.value > newValue) {\r\n            // Return the extra money to the minter.\r\n            (bool success2, ) = msg.sender.call{value: msg.value - newValue}(\r\n                \"\"\r\n            );\r\n            require(success2, \"Transfer failed\");\r\n        }\r\n        // TODO: check\r\n        deposits[msg.sender] = deposits[msg.sender] + newValue;\r\n\r\n        balance = balance + newValue;\r\n\r\n        uint256 lootToGive = (numUnits * factory.lootPerUnit());\r\n        uint256 lootToPlatform = (numUnits * factory.platformFee());\r\n\r\n        moloch.setSingleSharesLoot(msg.sender, 0, lootToGive, true);\r\n        if (lootToPlatform > 0) {\r\n            moloch.setSingleSharesLoot(\r\n                factory.owner(),\r\n                0,\r\n                lootToPlatform,\r\n                true\r\n            );\r\n        }\r\n\r\n        moloch.collectTokens(address(wrapper));\r\n\r\n        // amount of loot? fees?\r\n        emit YeetReceived(\r\n            msg.sender,\r\n            newValue,\r\n            address(moloch),\r\n            lootToGive,\r\n            lootToPlatform\r\n        );\r\n    }\r\n\r\n    receive() external payable {\r\n        yeetyeet();\r\n    }\r\n\r\n    function goalReached() public view returns (bool) {\r\n        return balance >= maxTarget;\r\n    }\r\n}\r\n\r\ncontract CloneFactory {\r\n    // implementation of eip-1167 - see https://eips.ethereum.org/EIPS/eip-1167\r\n    function createClone(address target) internal returns (address result) {\r\n        bytes20 targetBytes = bytes20(target);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(\r\n                clone,\r\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\r\n            )\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(\r\n                add(clone, 0x28),\r\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\r\n            )\r\n            result := create(0, clone, 0x37)\r\n        }\r\n    }\r\n}\r\n\r\ncontract YeetSummoner is CloneFactory, Ownable {\r\n    address payable public template;\r\n    mapping(uint256 => address) public yeeters;\r\n    uint256 public yeetIdx = 0;\r\n\r\n    uint256 public platformFee = 3; // fee of 3.09%\r\n    uint256 public lootPerUnit = 100;\r\n\r\n    event PlatformFeeUpdate(uint256 platformFee, uint256 lootPerUnit);\r\n\r\n    event SummonYeetComplete(\r\n        address indexed moloch,\r\n        address yeeter,\r\n        address wrapper,\r\n        uint256 maxTarget,\r\n        uint256 raiseEndTime,\r\n        uint256 raiseStartTime,\r\n        uint256 maxUnits,\r\n        uint256 pricePerUnit,\r\n        string details\r\n    );\r\n\r\n    constructor(address payable _template) {\r\n        template = _template;\r\n        Yeeter _yeeter = Yeeter(_template);\r\n        _yeeter.initTemplate();\r\n    }\r\n\r\n    function summonYeet(\r\n        address _moloch,\r\n        address payable _wrapper,\r\n        uint256 _maxTarget,\r\n        uint256 _raiseEndTime,\r\n        uint256 _raiseStartTime,\r\n        uint256 _maxUnits,\r\n        uint256 _pricePerUnit,\r\n        string calldata _details\r\n    ) public returns (address) {\r\n        Yeeter yeeter = Yeeter(payable(createClone(template)));\r\n\r\n        yeeter.init(\r\n            _moloch,\r\n            _wrapper,\r\n            _maxTarget,\r\n            _raiseEndTime,\r\n            _raiseStartTime,\r\n            _maxUnits,\r\n            _pricePerUnit\r\n        );\r\n        yeetIdx = yeetIdx + 1;\r\n        yeeters[yeetIdx] = address(yeeter);\r\n\r\n        emit SummonYeetComplete(\r\n            _moloch,\r\n            address(yeeter),\r\n            _wrapper,\r\n            _maxTarget,\r\n            _raiseEndTime,\r\n            _raiseStartTime,\r\n            _maxUnits,\r\n            _pricePerUnit,\r\n            _details\r\n        );\r\n\r\n        return address(yeeter);\r\n    }\r\n\r\n    // owner only functions\r\n    function setConfig(uint256 _platformFee, uint256 _lootPerUnit)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(_lootPerUnit > 0, \"Can not be 0\");\r\n        platformFee = _platformFee;\r\n        lootPerUnit = _lootPerUnit;\r\n        emit PlatformFeeUpdate(platformFee, lootPerUnit);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"moloch\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lootToGive\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lootToPlatform\",\"type\":\"uint256\"}],\"name\":\"YeetReceived\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"goalReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_moloch\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_wrapper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_raiseEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_raiseStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxUnits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pricePerUnit\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lootPerUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxUnitsPerAddr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moloch\",\"outputs\":[{\"internalType\":\"contract IMOLOCH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pricePerUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raiseEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raiseStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapper\",\"outputs\":[{\"internalType\":\"contract IWRAPPER\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yeetyeet\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Yeeter", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9b5d672929041a252c6a84960772cddb3020759060a677f416ccafaeb37a598d"}]}