{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"sol/LW77x7.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport './LTNT.sol';\\nimport 'base64-sol/base64.sol';\\nimport './lib/Rando.sol';\\n\\n/**\\n\\n          ___  ___      ___        __   __        __  \\n|     /\\\\   |  |__  |\\\\ |  |   |  | /  \\\\ |__) |__/ /__` \\n|___ /~~\\\\  |  |___ | \\\\|  |  .|/\\\\| \\\\__/ |  \\\\ |  \\\\ .__/ \\n                                                      \\n\\\"77x7\\\", troels_a, 2021\\n\\n\\n*/\\n\\ncontract LW77x7 is ERC1155, ERC1155Supply, Ownable {\\n\\n    using Counters for Counters.Counter;\\n\\n    // Constants\\n    string public constant NAME = \\\"Latent Works \\\\xc2\\\\xb7 77x7\\\";\\n    string public constant DESCRIPTION = \\\"latent.works\\\";\\n    uint public constant MAX_WORKS = 77;\\n    uint public constant MAX_EDITIONS = 7;\\n\\n    // Works\\n    Counters.Counter private _id_tracker;\\n    uint private _released = 0;\\n    uint private _editions = 0;\\n    uint private _minted = 0;\\n    uint private _curr_edition = 0;\\n    uint private _price = 0.07 ether;\\n    mapping(uint => string) private _seeds;\\n    mapping(uint => mapping(uint => address)) private _minters;\\n    mapping(uint => mapping(uint => uint)) private _timestamps;\\n\\n    struct Work {\\n      uint token_id;\\n      string name;\\n      string description;\\n      string image;\\n      string[7] iterations;\\n      string[7] colors;\\n    }\\n\\n\\n    // Canvas\\n    mapping(uint256 => string[]) private _palettes;\\n\\n    constructor() ERC1155(\\\"\\\") {\\n\\n      _palettes[1] = [\\\"#82968c\\\",\\\"#6a706e\\\",\\\"#ffd447\\\",\\\"#ff5714\\\",\\\"#170312\\\",\\\"#0cf574\\\",\\\"#f9b4ed\\\"];\\n      _palettes[2] = [\\\"#f59ca9\\\",\\\"#775253\\\",\\\"#01fdf6\\\",\\\"#cff27e\\\",\\\"#294d4a\\\",\\\"#0cf574\\\",\\\"#0e103d\\\"];\\n      _palettes[3] = ['rgba(90, 232, 89, 0.706)', 'rgba(255, 98, 98, 0.706)', 'rgba(79, 42, 109, 0.706)', 'rgba(0, 255, 208, 0.769)', 'pink', '#888', 'black'];\\n\\n    }\\n\\n\\n    // State\\n    function getAvailable() public view returns (uint){\\n      return (_released - _minted);\\n    }\\n\\n    function getMinted() public view returns (uint){\\n      return _minted;\\n    }\\n\\n    function getEditions() public view returns(uint){\\n      return _editions;\\n    }\\n\\n    function getCurrentEdition() public view returns(uint){\\n        return _curr_edition;\\n    }\\n    \\n\\n    // Minting\\n    function releaseEdition(address[] memory to) public onlyOwner {\\n      require(_editions < MAX_EDITIONS, 'MAX_EDITIONS_RELEASED');\\n      _released = _released+MAX_WORKS;\\n      _editions++;\\n      for(uint256 i = 0; i < to.length; i++){\\n        _mintTo(to[i]);\\n      }\\n    }\\n\\n    function mint() public payable returns (uint) {\\n      require(msg.value >= _price, \\\"VALUE_TOO_LOW\\\");\\n      require((getAvailable() > 0), \\\"NOT_AVAILABLE\\\");\\n      return _mintTo(msg.sender);\\n    }\\n\\n    function _mintTo(address to) private returns(uint){\\n      \\n      _id_tracker.increment();\\n\\n      uint256 token_id = _id_tracker.current();\\n\\n      if(token_id == 1)\\n        _curr_edition++;\\n\\n      uint edition = getCurrentEdition();\\n\\n      if(edition == 1){\\n        _seeds[token_id] = string(abi.encodePacked(Strings.toString(token_id), block.timestamp, block.difficulty));\\n      }\\n\\n      _mint(to, token_id, 1, \\\"\\\");\\n      _minted++;\\n      _minters[token_id][edition] = to;\\n      _timestamps[token_id][edition] = block.timestamp;\\n\\n      if(token_id == MAX_WORKS){\\n        _id_tracker.reset();\\n      }\\n\\n      return token_id;\\n\\n    }\\n\\n\\n    // Media and metadata\\n    function _getIterationSeed(uint token_id, uint iteration) private view returns(string memory){\\n      return string(abi.encodePacked(_seeds[token_id], Strings.toString(iteration)));\\n    }\\n\\n    function _getPaletteIndex(uint token_id) private view returns(uint) {\\n      return Rando.number(string(abi.encodePacked(_seeds[token_id], 'P')), 1, 3);\\n    }\\n\\n    function getPalette(uint token_id) public view returns(string[] memory){\\n      uint index = _getPaletteIndex(token_id);\\n      return _palettes[index];\\n    }\\n\\n    function getColor(uint token_id, uint iteration) public view returns(string memory){\\n      string[] memory palette = getPalette(token_id);\\n      return palette[Rando.number(string(abi.encodePacked(_getIterationSeed(token_id, iteration), 'C')), 1, 7)];\\n    }\\n\\n    function getMinter(uint token_id, uint edition) public view returns(address){\\n      return _minters[token_id][edition];\\n    }\\n\\n    function getWork(uint token_id) public view returns(Work memory){\\n      \\n      string[7] memory iterations;\\n      string[7] memory colors;\\n\\n      uint supply = totalSupply(token_id);\\n      uint i = 0;\\n      while(i < supply){\\n        iterations[i] = getSVG(token_id, i+1, true);\\n        i++;\\n      }\\n\\n      i = 0;\\n      while(i < supply){\\n        colors[i] = getColor(token_id, i);\\n        i++;\\n      }\\n\\n      return Work(\\n        token_id,\\n        string(abi.encodePacked(\\\"Latent Work #\\\", Strings.toString(token_id))),\\n        DESCRIPTION,\\n        getSVG(token_id, supply, true),\\n        iterations,\\n        colors\\n      );\\n\\n    }\\n\\n    function _getElement(uint token_id, uint iteration, string memory filter) private view returns(string memory){\\n      \\n      string memory svgSeed = _getIterationSeed(token_id, iteration);\\n      string memory C = getColor(token_id, iteration);\\n      uint X = Rando.number(string(abi.encodePacked(svgSeed, 'X')), 10, 90);\\n      uint Y = Rando.number(string(abi.encodePacked(svgSeed, 'Y')), 10, 90);\\n      uint R = Rando.number(string(abi.encodePacked(svgSeed, 'R')), 5, 70);\\n\\n      return string(abi.encodePacked('<circle cx=\\\"',Strings.toString(X),'%\\\" cy=\\\"',Strings.toString(Y),'%\\\" r=\\\"',Strings.toString(R),'%\\\" filter=\\\"url(#',filter,')\\\" fill=\\\"',C,'\\\"></circle>'));\\n\\n    }\\n\\n\\n    function _getWatermark(uint token_id, uint iteration) private view returns (string memory) {\\n      return string(abi.encodePacked('<style>.txt{font: normal 12px monospace;fill: white;}</style><rect width=\\\"90\\\" height=\\\"30\\\" x=\\\"0\\\" y=\\\"747\\\" fill=\\\"#000\\\" class=\\\"box\\\"></rect><text x=\\\"12\\\" y=\\\"766\\\" class=\\\"txt\\\">#',(token_id < 10 ? string(abi.encodePacked('0', Strings.toString(token_id))) : Strings.toString(token_id)),' \\\\xc2\\\\xb7 ',Strings.toString(iteration),'/',Strings.toString(MAX_EDITIONS),'</text><text x=\\\"103\\\" y=\\\"766\\\" class=\\\"txt\\\">',Strings.toString(_timestamps[token_id][iteration]),'</text>'));\\n    }\\n\\n\\n    function getSVG(uint256 token_id, uint iteration, bool mark) public view returns (string memory){\\n\\n        require(iteration <= totalSupply(token_id), 'EDITION_NOT_MINTED');\\n\\n        string[4] memory parts;\\n\\n        string memory elements = string(abi.encodePacked(_getElement(token_id, 70, \\\"f1\\\"), _getElement(token_id, 700, \\\"f1\\\")));\\n        uint i;\\n        while(i < iteration){\\n          elements = string(abi.encodePacked(elements, _getElement(token_id, i, \\\"f0\\\")));\\n          i++;\\n        }\\n\\n        uint size = 777;\\n        string memory view_box_size = Strings.toString(size);\\n        string memory blur = Strings.toString(size/(iteration+1));\\n\\n        parts[0] = string(abi.encodePacked('<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 ',view_box_size,' ',view_box_size,'\\\"><defs><rect id=\\\"bg\\\" width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"#fff\\\" /><clipPath id=\\\"clip\\\"><use xlink:href=\\\"#bg\\\"/></clipPath><filter id=\\\"f0\\\" width=\\\"300%\\\" height=\\\"300%\\\" x=\\\"-100%\\\" y=\\\"-100%\\\"><feGaussianBlur in=\\\"SourceGraphic\\\" stdDeviation=\\\"',blur,'\\\"/></filter><filter id=\\\"f1\\\" width=\\\"300%\\\" height=\\\"300%\\\" x=\\\"-100%\\\" y=\\\"-100%\\\"><feGaussianBlur in=\\\"SourceGraphic\\\" stdDeviation=\\\"700\\\"/></filter></defs><rect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"#fff\\\" />'));\\n        parts[1] = string(abi.encodePacked('<g clip-path=\\\"url(#clip)\\\"><use xlink:href=\\\"#bg\\\"/>', elements, '</g>'));\\n        parts[2] = mark ? _getWatermark(token_id, iteration) : '';\\n        parts[3] = '</svg>';\\n\\n        string memory output = string(abi.encodePacked('data:image/svg+xml;base64,', Base64.encode(bytes(string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3]))))));\\n\\n        return output;\\n\\n    }\\n\\n    function uri(uint256 token_id) virtual public view override returns (string memory) {\\n        \\n        require(exists(token_id), 'INVALID_ID');\\n        Work memory work = getWork(token_id);\\n\\n        string memory json = Base64.encode(bytes(string(abi.encodePacked('{\\\"name\\\": \\\"', work.name, '\\\", \\\"description\\\": \\\"', work.description, '\\\", \\\"image\\\": \\\"', work.image, '\\\"}'))));\\n\\n        return string(abi.encodePacked('data:application/json;base64,', json));\\n\\n    }\\n\\n    // Balance\\n    function withdrawAll() public payable onlyOwner {\\n      require(payable(msg.sender).send(address(this).balance));\\n    }\\n\\n\\n    // Required overrides\\n\\n    function _beforeTokenTransfer(address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual override(ERC1155, ERC1155Supply){\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n    }\\n\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal override (ERC1155) {\\n        super._mint(account, id, amount, data);\\n    }\\n\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal override (ERC1155) {\\n        super._mintBatch(to, ids, amounts, data);\\n    }\\n\\n    function _burn(address account, uint256 id, uint256 amount) internal override (ERC1155) {\\n        super._burn(account, id, amount);\\n    }\\n\\n    function _burnBatch(address to, uint256[] memory ids, uint256[] memory amounts) internal override (ERC1155) {\\n        super._burnBatch(to, ids, amounts);\\n    }\\n\\n}\\n\\n\\n\\n\\ncontract LW77x7_LTNTIssuer is LTNTIssuer, Ownable {\\n\\n  LW77x7 public immutable _77x7;\\n  LTNT public immutable _ltnt;\\n  address private _caller;\\n\\n  mapping(uint => uint) private _iterations;\\n\\n  constructor(address seven7x7_, address ltnt_) {\\n    _77x7 = LW77x7(seven7x7_);\\n    _ltnt = LTNT(ltnt_);\\n  }\\n\\n  function issuerInfo(uint id_, LTNT.Param memory param_) public override view returns(LTNT.IssuerInfo memory){\\n    return LTNT.IssuerInfo(\\n      '77x7', _77x7.getSVG(param_._uint, _iterations[id_], true)\\n    );\\n  }\\n\\n  function issueTo(address to_, LTNT.Param memory param_, bool stamp_) public returns(uint) {\\n    require(msg.sender == _caller, 'ONLY_CALLER');\\n    uint id_ = _ltnt.issueTo(to_, param_, stamp_);\\n    _iterations[id_] = 7;\\n    return id_;\\n  }\\n\\n  function setCaller(address caller_) public onlyOwner {\\n    _caller = caller_;\\n  }\\n\\n  function setIteration(uint id_, uint iteration_) public {\\n    require(msg.sender == _ltnt.ownerOf(id_), 'NOT_OWNER');\\n    require(iteration_ > 0 && iteration_ < 8, 'ITERATION_OUT_OF_RANGE');\\n    _iterations[id_] = iteration_;\\n  }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/ERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor(string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _balances[id][to] += amount;\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1155.sol\\\";\\n\\n/**\\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\\n *\\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\\n * clearly identified. Note: While a totalSupply of 1 might mean the\\n * corresponding is an NFT, there is no guarantees that no other token with the\\n * same id are not going to be minted.\\n */\\nabstract contract ERC1155Supply is ERC1155 {\\n    mapping(uint256 => uint256) private _totalSupply;\\n\\n    /**\\n     * @dev Total amount of tokens in with a given id.\\n     */\\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\\n        return _totalSupply[id];\\n    }\\n\\n    /**\\n     * @dev Indicates whether any token exist with a given id, or not.\\n     */\\n    function exists(uint256 id) public view virtual returns (bool) {\\n        return ERC1155Supply.totalSupply(id) > 0;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_beforeTokenTransfer}.\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        if (from == address(0)) {\\n            for (uint256 i = 0; i < ids.length; ++i) {\\n                _totalSupply[ids[i]] += amounts[i];\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            for (uint256 i = 0; i < ids.length; ++i) {\\n                uint256 id = ids[i];\\n                uint256 amount = amounts[i];\\n                uint256 supply = _totalSupply[id];\\n                require(supply >= amount, \\\"ERC1155: burn amount exceeds totalSupply\\\");\\n                unchecked {\\n                    _totalSupply[id] = supply - amount;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"sol/LTNT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./LTNTFont.sol\\\";\\nimport \\\"base64-sol/base64.sol\\\";\\n\\n\\n//////////////////////////////////\\n//\\n//\\n// LTNT\\n// Passport NFTs for Latent Works\\n//\\n//\\n//////////////////////////////////\\n\\n\\n/// @title LTNT\\n/// @author troels_a\\n\\ncontract LTNT is ERC721, Ownable {\\n    \\n    struct Param {\\n        uint _uint;\\n        address _address;\\n        string _string;\\n        bool _bool;\\n    }\\n\\n    struct IssuerInfo {\\n        string name;\\n        string image;\\n    }\\n\\n    struct Issuer {\\n        address location;\\n        Param param;\\n    }\\n\\n    event Issued(uint indexed id, address indexed to);\\n    event Stamped(uint indexed id, address indexed stamper);\\n\\n    LTNT_Meta private _ltnt_meta;\\n\\n    address[] private _issuers; ///@dev array of addresses registered as issuers\\n    mapping(uint => mapping(address => bool)) private _stamps; ///@dev (ltnt => (issuer => is stamped?))\\n    mapping(uint => mapping(address => Param)) private _params; ///@dev (ltnt => (issuer => stamp parameters));\\n    mapping(uint => Issuer) private _issuer_for_id; ///@dev (ltnt => issuer) - the Issuer for a given LTNT\\n    \\n    uint private _ids; ///@dev LTNT _id counter\\n\\n    /// @dev pass address of onchain fonts to the constructor\\n    constructor(address regular_, address italic_) ERC721(\\\"Latents\\\", \\\"LTNT\\\"){\\n\\n        LTNT_Meta ltnt_meta_ = new LTNT_Meta(address(this), regular_, italic_);\\n        _ltnt_meta = LTNT_Meta(address(ltnt_meta_));\\n\\n    }\\n\\n\\n\\n\\n    /// @notice Require a given address to be a registered issuer\\n    /// @param caller_ the address to check for issuer privilegies\\n    function _reqOnlyIssuer(address caller_) private view {\\n        require(isIssuer(caller_), 'ONLY_ISSUER');\\n    }\\n\\n\\n\\n    /// @notice Issue a token to the address\\n    /// @param to_ the address to issue the LTNT to\\n    /// @param param_ a Param struct of parameters associated with the token\\n    /// @param stamp_ boolean determining wether the newly issued LTNT should be stamped by the issuer\\n    /// @return uint the id of the newly issued LTNT\\n    function issueTo(address to_, Param memory param_, bool stamp_) public returns(uint){ _reqOnlyIssuer(msg.sender);\\n        \\n        _ids++;\\n        _safeMint(to_, _ids);\\n        _issuer_for_id[_ids] = Issuer(msg.sender, param_);\\n\\n        emit Issued(_ids, to_);\\n        \\n        if(stamp_)\\n            _stamp(_ids, msg.sender, param_);\\n\\n        return _ids;\\n\\n    }\\n\\n\\n\\n    /// @dev Lets a registered issuer stamp a given LTNT\\n    /// @param id_ the ID of the LTNT to stamp\\n    /// @param param_ a Param struct with any associated params\\n    function stamp(uint id_, Param memory param_) public { _reqOnlyIssuer(msg.sender);\\n        _stamp(id_, msg.sender, param_);\\n    }\\n\\n\\n\\n    /// @dev internal stamping mechanism\\n    /// @param id_ the id of the LTNT to stamp\\n    /// @param issuer_ the address of the issuer stamping the LTNT\\n    /// @param param_ a Param struct with stamp parameters\\n    function _stamp(uint id_, address issuer_, Param memory param_) private {\\n        _stamps[id_][issuer_] = true;\\n        _params[id_][issuer_] = param_;\\n        emit Stamped(_ids, issuer_);\\n    }\\n\\n    /// @dev checks if a given id_ is stamped by address_\\n    /// @param id_ the ID of the LTNT to check\\n    /// @param address_ the address of the stamper\\n    /// @return bool indicating wether LTNT is stamped\\n    function hasStamp(uint id_, address address_) public view returns(bool){\\n        return _stamps[id_][address_];\\n    }\\n\\n    /// @dev get params for a given stamp on a LTNT\\n    /// @param id_ the id of the LTNT\\n    /// @param address_ the address of the stamper\\n    /// @return Param the param to return\\n    function getStampParams(uint id_, address address_) public view returns(Param memory){\\n        return _params[id_][address_];\\n    }\\n\\n    /// @dev Get the addresses of the issuers that have stamped a given LTNT\\n    /// @param id_ the ID of the LTNT to fetch stamps for\\n    /// @return addresses an array of issuer addresses that have stamped the LTNT\\n    function getStamps(uint id_) public view returns(address[] memory){\\n        \\n        // First count the stamps\\n        uint count;\\n        for(uint i = 0; i < _issuers.length; i++){\\n            if(_stamps[id_][_issuers[i]])\\n                ++count;\\n        }\\n\\n        // Init a stamps_ array with the right length from count_\\n        address[] memory stamps_ = new address[](count);\\n\\n        // Loop over the issuers and save stampers in stamps_\\n        count = 0;\\n        for(uint i = 0; i < _issuers.length; i++){\\n            if(_stamps[id_][_issuers[i]]){\\n                stamps_[count] = _issuers[i];\\n                ++count;\\n            }\\n        }\\n\\n        return stamps_;\\n\\n    }\\n\\n    /// @dev list all issuer addresses\\n    /// @return addresses list of all issuers\\n    function getIssuers() public view returns(address[] memory){\\n        return _issuers;\\n    }\\n\\n    /// @dev get the issuer of a LTNT\\n    function getIssuerFor(uint id_) public view returns(LTNT.Issuer memory){\\n        return _issuer_for_id[id_];\\n    }\\n\\n    /// @dev set the meta contract\\n    /// @param address_ the address of the meta contract\\n    function setMetaContract(address address_) public onlyOwner {\\n        _ltnt_meta = LTNT_Meta(address_);\\n    }\\n\\n    /// @dev get the meta contract\\n    /// @return LTNT_Meta the meta contract currently in use\\n    function getMetaContract() public view returns(LTNT_Meta) {\\n        return _ltnt_meta;\\n    }\\n\\n    /// @notice register an issuer address\\n    /// @param address_ the address of the issuer to add\\n    function addIssuer(address address_) public onlyOwner {\\n        _issuers.push(address_);\\n    }\\n    \\n\\n    /// @notice determine if an address is a LW project\\n    /// @param address_ the address of the issuer\\n    /// @return bool indicating wether the address is an issuer or not\\n    function isIssuer(address address_) public view returns(bool){\\n        for(uint i = 0; i < _issuers.length; i++) {\\n            if(_issuers[i] == address_)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n\\n    /// @notice the ERC721 tokenURI for a given LTNT\\n    /// @param id_ the id of the LTNT\\n    /// @return json_ base64 encoded data URI containing the JSON metadata\\n    function tokenURI(uint id_) public view override returns(string memory json_){\\n        return _ltnt_meta.getJSON(id_, true);\\n    }\\n\\n\\n}\\n\\n\\n/// @title A title that should describe the contract/interface\\n/// @author troels_a\\n/// @dev Handles meta for this contract\\ncontract LTNT_Meta {\\n\\n    LTNT public immutable _ltnt;\\n\\n    ///@dev latent fonts\\n    XanhMonoRegularLatin public immutable _xanh_regular;\\n    XanhMonoItalicLatin public immutable _xanh_italic;\\n\\n    constructor(address ltnt_, address regular_, address italic_){\\n\\n        _ltnt = LTNT(ltnt_);\\n        _xanh_regular = XanhMonoRegularLatin(regular_);\\n        _xanh_italic = XanhMonoItalicLatin(italic_);\\n\\n    }\\n\\n    /// @notice return image string for id_\\n    /// @param id_ the id of the LTNT to retrieve the image for\\n    /// @param encode_ encode output as base64 uri\\n    /// @return string the image string\\n    function getImage(uint id_, bool encode_) public view returns(string memory){\\n\\n        LTNT.Issuer memory issuer_for_id_ = _ltnt.getIssuerFor(id_);\\n        LTNT.IssuerInfo memory issuer_info_ = LTNTIssuer(issuer_for_id_.location).issuerInfo(id_, issuer_for_id_.param);\\n        LTNT.IssuerInfo memory stamper_;\\n        LTNT.Param memory stamp_param_;\\n        address[] memory issuers_ = _ltnt.getIssuers();\\n\\n        bytes memory stamps_svg_;\\n        string memory delay_;\\n        uint stamp_count_;\\n        bool has_stamp_;\\n\\n        for(uint i = 0; i < issuers_.length; i++) {\\n\\n            delay_ = Strings.toString(i*150);\\n            stamp_param_ = _ltnt.getStampParams(id_,issuers_[i]);\\n            stamper_ = LTNTIssuer(issuers_[i]).issuerInfo(id_, stamp_param_);\\n            has_stamp_ = _ltnt.hasStamp(id_, issuers_[i]);\\n\\n            stamps_svg_ = abi.encodePacked(stamps_svg_, '<text class=\\\"txt italic\\\" fill-opacity=\\\"0\\\" y=\\\"',Strings.toString(25*i),'\\\">',stamper_.name,' <animate attributeName=\\\"fill-opacity\\\" values=\\\"0;',has_stamp_ ? '1' : '0.4','\\\" dur=\\\"500ms\\\" repeatCount=\\\"1\\\" begin=\\\"',delay_,'ms\\\" fill=\\\"freeze\\\"/></text>');\\n            if(has_stamp_)\\n                ++stamp_count_;\\n\\n        }\\n\\n        bytes memory image_;\\n        image_ = abi.encodePacked(\\n            '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 600 1000\\\" preserveAspectRatio=\\\"xMinYMin meet\\\">',\\n                '<defs><style>', _xanh_regular.fontFace(), _xanh_italic.fontFace(),' .txt {font-family: \\\"Xanh Mono\\\"; font-size:20px; font-weight: normal; letter-spacing: 0.01em; fill: white;} .italic {font-style: italic;} .large {font-size: 55px;} .small {font-size: 12px;}</style><rect ry=\\\"30\\\" rx=\\\"30\\\" id=\\\"bg\\\" height=\\\"1000\\\" width=\\\"600\\\" fill=\\\"black\\\"/></defs>',\\n                '<use href=\\\"#bg\\\"/>',\\n                '<g transform=\\\"translate(65, 980) rotate(-90)\\\">',\\n                    '<text class=\\\"txt large italic\\\">Latent Works</text>',\\n                '</g>',\\n                '<g transform=\\\"translate(537, 21) rotate(90)\\\">',\\n                    '<text class=\\\"txt large italic\\\">LTNT #',Strings.toString(id_),'</text>',\\n                '</g>',\\n                '<g transform=\\\"translate(517, 22) rotate(90)\\\">',\\n                    '<text class=\\\"txt small\\\">Issued by ',issuer_info_.name,unicode' \u00b7 ', Strings.toString(stamp_count_) , stamp_count_ > 1 ? ' stamps' : ' stamp', '</text>',\\n                '</g>'\\n                '<g transform=\\\"translate(25, 25)\\\">',\\n                    '<image width=\\\"300\\\" href=\\\"', issuer_info_.image, '\\\"/>',\\n                '</g>',\\n                '<g transform=\\\"translate(343, 41)\\\">',\\n                    stamps_svg_,\\n                '</g>',\\n                '<g transform=\\\"translate(509, 980)\\\">',\\n                    '<text class=\\\"txt small\\\">latent.works</text>',\\n                '</g>',\\n            '</svg>'\\n        );\\n\\n        if(encode_)\\n            image_ = abi.encodePacked('data:image/svg+xml;base64,', Base64.encode(image_));\\n\\n        return string(image_);\\n\\n    }\\n\\n\\n    /// @notice return base64 encoded JSON metadata for id_\\n    /// @param id_ the id of the LTNT to retrieve the image for\\n    /// @param encode_ encode output as base64 uri\\n    /// @return string the image string\\n    function getJSON(uint id_, bool encode_) public view returns(string memory) {\\n        \\n        LTNT.Issuer memory issuer_for_id_ = _ltnt.getIssuerFor(id_);\\n        LTNT.IssuerInfo memory issuer_info_ = LTNTIssuer(issuer_for_id_.location).issuerInfo(id_, issuer_for_id_.param);\\n\\n        bytes memory json_ = abi.encodePacked(\\n            '{',\\n                '\\\"name\\\":\\\"LTNT #',Strings.toString(id_),'\\\", ',\\n                '\\\"image\\\": \\\"', getImage(id_, true),'\\\", ',\\n                '\\\"description\\\": \\\"latent.works\\\",',\\n                '\\\"attributes\\\": [',\\n                    '{\\\"trait_type\\\": \\\"Stamps\\\", \\\"value\\\": ',Strings.toString(_ltnt.getStamps(id_).length),'},',\\n                    '{\\\"trait_type\\\": \\\"Issuer\\\", \\\"value\\\": \\\"', issuer_info_.name, '\\\"}',\\n                ']',\\n            '}'\\n        );\\n\\n        if(encode_)\\n            json_ = abi.encodePacked('data:application/json;base64,', Base64.encode(json_));\\n        \\n        return string(json_);\\n\\n    }\\n\\n}\\n\\n\\n/// @title LTNTIssuer\\n/// @author troels_a\\n/// @dev LTNTIssuers implement this contract and use issuerInfo to pass info to LTNT main contract\\nabstract contract LTNTIssuer {\\n    function issuerInfo(uint id_, LTNT.Param memory param_) external virtual view returns(LTNT.IssuerInfo memory);\\n}\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"sol/lib/Rando.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.2;\\n\\nlibrary Rando {\\n\\n    function number(string memory seed, uint min, uint max) internal pure returns (uint) {\\n      if (max <= min) return min;\\n        return (uint256(keccak256(abi.encodePacked(seed))) % (max - min)) + min;\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"sol/LTNTFont.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.2;\\n\\ncontract XanhMonoRegularLatin {\\n    function fontFace() public pure returns(string memory){\\n        return \\\"@font-face { font-family: 'Xanh Mono'; font-style: normal; font-weight: 400; font-display: swap; src: url(data:font/woff2;base64,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) format('woff2'); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; }\\\";\\n    }\\n}\\n\\ncontract XanhMonoItalicLatin {\\n    function fontFace() public pure returns(string memory){\\n        return \\\"@font-face { font-family: 'Xanh Mono'; font-style: italic; font-weight: 400; font-display: swap; src: url(data:font/woff2;base64,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) format('woff2'); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; }\\\";\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"seven7x7_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ltnt_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_77x7\",\"outputs\":[{\"internalType\":\"contract LW77x7\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ltnt\",\"outputs\":[{\"internalType\":\"contract LTNT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_uint\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_string\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"internalType\":\"struct LTNT.Param\",\"name\":\"param_\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"stamp_\",\"type\":\"bool\"}],\"name\":\"issueTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_uint\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_string\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"internalType\":\"struct LTNT.Param\",\"name\":\"param_\",\"type\":\"tuple\"}],\"name\":\"issuerInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"image\",\"type\":\"string\"}],\"internalType\":\"struct LTNT.IssuerInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller_\",\"type\":\"address\"}],\"name\":\"setCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iteration_\",\"type\":\"uint256\"}],\"name\":\"setIteration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LW77x7_LTNTIssuer", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ef7c89f051ac48885b240eb53934b04fcf3339ab0000000000000000000000006f2ff40f793776aa559644f52e58d83e21871ec3", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}