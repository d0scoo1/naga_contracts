{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/meta.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {Base64} from \\\"./base64.sol\\\";\\nstruct NFTDetails {\\n        bytes1 elementId;\\n        uint32 mass;\\n        uint32 immunity;\\n        uint32 power;\\n        uint32 experience;\\n    }\\n\\nstruct Element {\\n        bytes name;\\n     \\n        bytes1[] parents;\\n        uint32 supply;\\n        uint32 supplyMass;\\n        uint8 tier;\\n    }\\n\\nlibrary Meta {\\n\\n    string public constant description= \\\"The Game of Building, Fighting and Owning Powerful Creatures on 'Planet EO'.\\\";\\n\\n    function getMeta(uint256 tokenId,uint256 artWeight, NFTDetails memory metadata, Element memory element, string memory external_url, string memory meta_url) public pure returns (string memory) {\\n        bytes memory byteString  = abi.encodePacked(\\\"{\\\");\\n        \\n        byteString = abi.encodePacked(\\n          byteString,\\n          _pushJsonStringAttribute(\\\"name\\\", string(abi.encodePacked(string(element.name),' [',toString(metadata.mass),'] #', toString(tokenId)))  , true));\\n        byteString = abi.encodePacked(\\n          byteString,\\n          _pushJsonStringAttribute(\\\"description\\\",string( description)  , true));\\n        byteString = abi.encodePacked(\\n          byteString,\\n          _pushJsonStringAttribute(\\\"external_url\\\",string(external_url)  , true));\\n\\n        // Image URls\\n        bytes memory elementFileName=isLowerCase(metadata.elementId)?abi.encodePacked(\\\"_\\\",metadata.elementId):abi.encodePacked(metadata.elementId);\\n        string memory parameters=string(abi.encodePacked(\\n                \\\"element=\\\",elementFileName,\\n                \\\"&experience=\\\",toString(metadata.experience),\\n                \\\"&mass=\\\",toString(metadata.mass),\\n                \\\"&immunity=\\\",toString(metadata.immunity),\\n                \\\"&power=\\\",toString(metadata.power),\\n                \\\"&level=\\\",toString(artWeight),\\n                \\\"&tier=\\\",toString(element.tier)));\\n          byteString = abi.encodePacked(\\n          byteString,\\n          _pushJsonStringAttribute(\\\"animation_url\\\",string(abi.encodePacked(meta_url,\\\"html/\\\",elementFileName,\\\".html?\\\",  parameters))  , true));\\n\\n         \\n       // elementFileName=abi.encodePacked( elementFileName,\\\"-\\\", toString(artWeight));\\n         \\n        byteString = abi.encodePacked(\\n          byteString,\\n          _pushJsonStringAttribute(\\\"image\\\",string(abi.encodePacked(meta_url,\\\"images/\\\",elementFileName,\\\"-\\\", toString(artWeight),\\\".png\\\"))  , true));\\n              \\n        // Attributes\\n        byteString = abi.encodePacked(byteString,'\\\"attributes\\\": [' );\\n        byteString = abi.encodePacked(\\n            byteString,\\n            _pushJsonTraitNumber(\\\"Mass\\\", toString(metadata.mass) , true));\\n        byteString = abi.encodePacked(\\n            byteString,\\n            _pushJsonTraitNumber(\\\"Immunity\\\", toString(metadata.immunity) , true));\\n        byteString = abi.encodePacked(\\n            byteString,\\n            _pushJsonTraitNumber(\\\"Power\\\", toString(metadata.power) , true));\\n        byteString = abi.encodePacked(\\n            byteString,\\n            _pushJsonTraitNumber(\\\"Experience\\\", toString(metadata.experience) , true));\\n        byteString = abi.encodePacked(\\n            byteString,\\n            '{\\\"trait_type\\\":\\\"Tier\\\", \\\"value\\\":', toString(element.tier),  ', \\\"display_type\\\":\\\"number\\\"},');\\n        byteString = abi.encodePacked(\\n            byteString,\\n            _pushJsonTraitString(\\\"Tier Name\\\",string( abi.encodePacked(\\\"Tier \\\",toString(element.tier)) ), false));\\n         byteString = abi.encodePacked(byteString,']}' );\\n\\n         string memory base64Json = Base64.encode(byteString);\\n        return string(abi.encodePacked('data:application/json;base64,', base64Json));\\n        // return string(byteString);\\n    }\\n\\n     \\n\\n    function _getString(string memory _str) private pure returns (string memory){\\n        return string(abi.encodePacked(_str));\\n    }\\n    function _getField(string memory _str) private pure returns (string memory){\\n        return string(abi.encodePacked(_str));\\n    }\\n    function _pushJsonStringAttribute(string memory key, string memory value, bool insertComma) private pure returns (string memory) {\\n        return string(abi.encodePacked('\\\"', key, '\\\": \\\"', value, '\\\"', insertComma ? ',' : ''));\\n    }\\n    function _pushJsonTraitNumber(string memory trait_type, string memory trait_value, bool insertComma) private pure returns (string memory) {\\n        return string(abi.encodePacked(\\n            '{\\\"trait_type\\\":\\\"', trait_type, '\\\", \\\"value\\\":', trait_value,   insertComma ? '},' : '}'\\n            ));\\n    }\\n    function _pushJsonTraitString(string memory trait_type, string memory trait_value, bool insertComma) private pure returns (string memory) {\\n        return string(abi.encodePacked(\\n            '{\\\"trait_type\\\":\\\"', trait_type, '\\\", \\\"value\\\":\\\"', trait_value, '\\\"' , insertComma ? '},' : '}'\\n            ));\\n    }\\n\\n    function isLowerCase(bytes1 _id) public pure returns(bool){\\n        bytes memory allowed = bytes(\\\"abcdefghijklmnopqrstuvwxyz\\\"); \\n        for(uint j=0; j<allowed.length; j++){\\n            if(_id==allowed[j] ){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n \\n\\n}\"\r\n    },\r\n    \"contracts/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n \"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"artWeight\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes1\",\"name\":\"elementId\",\"type\":\"bytes1\"},{\"internalType\":\"uint32\",\"name\":\"mass\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"immunity\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"power\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"experience\",\"type\":\"uint32\"}],\"internalType\":\"struct NFTDetails\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes1[]\",\"name\":\"parents\",\"type\":\"bytes1[]\"},{\"internalType\":\"uint32\",\"name\":\"supply\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"supplyMass\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"}],\"internalType\":\"struct Element\",\"name\":\"element\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"external_url\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"meta_url\",\"type\":\"string\"}],\"name\":\"getMeta\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes1\",\"name\":\"_id\",\"type\":\"bytes1\"}],\"name\":\"isLowerCase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "Meta", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}