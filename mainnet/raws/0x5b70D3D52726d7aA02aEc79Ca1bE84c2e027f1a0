{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/EuclidFormula.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//\\n//  ********  **     **    ******   **        **  *******  \\n// /**/////  /**    /**   **////** /**       /** /**////** \\n// /**       /**    /**  **    //  /**       /** /**    /**\\n// /*******  /**    /** /**        /**       /** /**    /**\\n// /**////   /**    /** /**        /**       /** /**    /**\\n// /**       /**    /** //**    ** /**       /** /**    ** \\n// /******** //*******   //******  /******** /** /*******  \\n// ////////   ///////     //////   ////////  //  ///////   \\n//\\n// by collect-code 2022\\n// https://collect-code.com/\\n//\\npragma solidity ^0.8.2;\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./IEuclidRandomizer.sol\\\";\\nimport \\\"./IEuclidFormula.sol\\\";\\n\\ncontract EuclidFormula is IEuclidFormula {\\n\\tusing Strings for uint32;\\n\\n\\tIEuclidRandomizer randomizer;\\n\\n\\tconstructor(address randomizer_) {\\n\\t\\trandomizer = IEuclidRandomizer(randomizer_);\\n\\t}\\n\\n\\tfunction generateFormula(uint128 hash, uint256 tokenId) public view override returns (string memory) {\\n\\t\\tIEuclidRandomizer.RandomizerState memory rnd = randomizer.initialize(hash);\\n\\t\\tuint8[6] memory supplyData = supplyDataFromTokenId(tokenId);\\n\\t\\tbytes memory formula;\\n\\t\\t// palette\\n\\t\\trnd = randomizer.getInt(rnd, supplyData[0]);\\n\\t\\tuint32 pa = rnd.value;\\n\\t\\tformula = abi.encodePacked(formula, 'pa', pa.toString());\\n\\t\\t// shape count\\n\\t\\trnd = randomizer.getIntRange(rnd, supplyData[2], supplyData[3]+1);\\n\\t\\tuint32 shapeCount = rnd.value;\\n\\t\\t// attribute draw\\n\\t\\tuint32 drawCount = 9 + 3 * shapeCount;\\n\\t\\tuint32[] memory indices = new uint32[](drawCount);\\n\\t\\tuint32[] memory draw = new uint32[](supplyData[5]);\\n\\t\\tfor (uint32 i = 0; i < indices.length ; i++) indices[i] = i;\\n\\t\\tfor (uint32 i = 0; i < draw.length ; i++) {\\n\\t\\t\\trnd = randomizer.getIntRange(rnd, i, uint32(indices.length));\\n\\t\\t\\tdraw[i] = indices[rnd.value];\\n\\t\\t\\tindices[rnd.value] = i;\\n\\t\\t}\\n\\t\\tuint8 drawing;\\n\\t\\tbytes1 propValue;\\n\\t\\t// prop: bg\\n\\t\\t(rnd, propValue) = drawProp(rnd, drawing++, draw, bytes(pa==0?'01234568A':pa==1?'0123678A':pa==2?'02459':pa==3?'499999':pa==4?'02345A':pa==5?'01345A':pa==6?'0123457A':pa==7?'012367A':pa==8?'045':'012345678A'));\\n\\t\\tformula = abi.encodePacked(formula, '.bg', propValue);\\n\\t\\t// prop: ma\\n\\t\\t(rnd, propValue) = drawProp(rnd, drawing++, draw, bytes(pa==3?'0000112':'00001123'));\\n\\t\\tformula = abi.encodePacked(formula, '.ma', propValue);\\n\\t\\t// prop: tr\\n\\t\\t(rnd, propValue) = drawProp(rnd, drawing++, draw, bytes(pa==1?'022233':pa==3?'01122233':'011222334566'));\\n\\t\\tformula = abi.encodePacked(formula, '.tr', propValue);\\n\\t\\t(rnd, propValue) = drawProp(rnd, drawing++, draw, bytes(pa==0?'01111':pa==3?'01111':pa==6?'02223':pa==7?'02223':'011113'));\\n\\t\\tformula = abi.encodePacked(formula, propValue);\\n\\t\\t(rnd, propValue) = drawProp(rnd, drawing++, draw, bytes(pa==3?'00':'0000003333334'));\\n\\t\\tformula = abi.encodePacked(formula, propValue);\\n\\t\\t(rnd, propValue) = drawProp(rnd, drawing++, draw, bytes(pa==3?'00':'0000001111'));\\n\\t\\tformula = abi.encodePacked(formula, propValue);\\n\\t\\t(rnd, propValue) = drawProp(rnd, drawing++, draw, '0000000123');\\n\\t\\tformula = abi.encodePacked(formula, propValue);\\n\\t\\t// prop: fx\\n\\t\\t(rnd, propValue) = drawProp(rnd, drawing++, draw, bytes(pa==3?'0111111244445555':pa==6?'0111111244445555':pa==8?'5155544':'01111112344445555'));\\n\\t\\tformula = abi.encodePacked(formula, '.fx', propValue);\\n\\t\\t(rnd, propValue) = drawProp(rnd, drawing++, draw, bytes(pa==1?'02':pa==2?'02':pa==3?'02':pa==6?'013':'012'));\\n\\t\\tformula = abi.encodePacked(formula, propValue);\\n\\t\\t// prop: rn\\n\\t\\t(rnd, propValue) = randomizeProp(rnd, 0, '0123456789ABCDEF');\\n\\t\\tformula = abi.encodePacked(formula, '.rn', propValue);\\n\\t\\t(rnd, propValue) = randomizeProp(rnd, 0, '0123456789ABCDEF');\\n\\t\\tformula = abi.encodePacked(formula, propValue);\\n\\t\\t// randomize shapes\\n\\t\\tfor (uint32 i = 0; i < shapeCount ; i++) {\\n\\t\\t\\t// shape type\\n\\t\\t\\tbytes1 baseShape;\\n\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\tbaseShape = bytes('CTQP')[tokenId % supplyData[1]];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trnd = randomizer.getInt(rnd, supplyData[1]);\\n\\t\\t\\t\\tbaseShape = bytes('CTQP')[rnd.value];\\n\\t\\t\\t}\\n\\t\\t\\trnd = randomizer.getInt(rnd, supplyData[4]);\\n\\t\\t\\tbytes1 shapeVariant = bytes(baseShape=='T'?'04261537':baseShape=='Q'?'00112200':baseShape=='P'?'56678865':'00000000')[rnd.value];\\n\\t\\t\\tformula = abi.encodePacked(formula, '.sh', baseShape, shapeVariant);\\n\\t\\t\\tif (i > 0) {\\n\\t\\t\\t\\t// prop: fr\\n\\t\\t\\t\\t(rnd, propValue) = randomizeProp(rnd, 0, 'FFCCMMMMMMMIIAAA');\\n\\t\\t\\t\\tformula = abi.encodePacked(formula, 'fr', propValue);\\n\\t\\t\\t\\t(rnd, propValue) = randomizeProp(rnd, 0, '0123456789ABCDEF');\\n\\t\\t\\t\\tformula = abi.encodePacked(formula, propValue);\\n\\t\\t\\t\\t(rnd, propValue) = randomizeProp(rnd, 0, '0123456789ABCDEF');\\n\\t\\t\\t\\tformula = abi.encodePacked(formula, propValue);\\n\\t\\t\\t\\t(rnd, propValue) = randomizeProp(rnd, 0, '0123456789ABCDEF');\\n\\t\\t\\t\\tformula = abi.encodePacked(formula, propValue);\\n\\t\\t\\t}\\n\\t\\t\\t// prop: in\\n\\t\\t\\t(rnd, propValue) = randomizeProp(rnd, 0, 'SDDT');\\n\\t\\t\\tformula = abi.encodePacked(formula, 'in', propValue);\\n\\t\\t\\t(rnd, propValue) = randomizeProp(rnd, 0, '0123456789ABCDEF');\\n\\t\\t\\tformula = abi.encodePacked(formula, propValue);\\n\\t\\t\\t(rnd, propValue) = randomizeProp(rnd, 0, '0123456789ABCDEF');\\n\\t\\t\\tformula = abi.encodePacked(formula, propValue);\\n\\t\\t\\t// prop: st\\n\\t\\t\\t(rnd, propValue) = drawProp(rnd, drawing++, draw, '012');\\n\\t\\t\\tformula = abi.encodePacked(formula, 'st', propValue);\\n\\t\\t\\t(rnd, propValue) = drawProp(rnd, drawing++, draw, '0123');\\n\\t\\t\\tformula = abi.encodePacked(formula, propValue);\\n\\t\\t\\t(rnd, propValue) = drawProp(rnd, drawing++, draw, '011223');\\n\\t\\t\\tformula = abi.encodePacked(formula, propValue);\\n\\t\\t\\t// prop: rn\\n\\t\\t\\t(rnd, propValue) = randomizeProp(rnd, 0, '0123456789ABCDEF');\\n\\t\\t\\tformula = abi.encodePacked(formula, 'rn', propValue);\\n\\t\\t\\t(rnd, propValue) = randomizeProp(rnd, 0, '0123456789ABCDEF');\\n\\t\\t\\tformula = abi.encodePacked(formula, propValue);\\n\\t\\t}\\n\\t\\t// done!\\n\\t\\treturn string(formula);\\n\\t}\\n\\t\\n\\tfunction supplyDataFromTokenId(uint256 tokenId) public pure returns (uint8[6] memory) {\\n\\t\\tif (tokenId > 714) return [9, 4, 2, 5, 8, 12];\\n\\t\\tif (tokenId > 273) return [7, 4, 1, 4, 8, 11];\\n\\t\\tif (tokenId > 104) return [5, 4, 1, 3, 8, 10];\\n\\t\\tif (tokenId > 40) return [4, 4, 1, 2, 4, 9];\\n\\t\\tif (tokenId > 15) return [3, 4, 1, 2, 2, 8];\\n\\t\\tif (tokenId > 6) return [2, 3, 1, 1, 1, 7];\\n\\t\\tif (tokenId > 2) return [1, 3, 1, 1, 1, 6];\\n\\t\\treturn [1, 3, 1, 1, 1, 5];\\n\\t}\\n\\t\\n\\tfunction drawProp(IEuclidRandomizer.RandomizerState memory rnd, uint8 drawing, uint32[] memory draw, bytes memory values) internal view returns(IEuclidRandomizer.RandomizerState memory, bytes1) {\\n\\t\\tuint8 i = 0;\\n\\t\\tfor (; i < draw.length; i++) if (drawing == draw[i]) break;\\n\\t\\tif (i == draw.length) return (rnd, values[0]);\\n\\t\\treturn randomizeProp(rnd, 1, values);\\n\\t}\\n\\t\\n\\tfunction randomizeProp(IEuclidRandomizer.RandomizerState memory rnd, uint32 startIndex, bytes memory values) internal view returns(IEuclidRandomizer.RandomizerState memory, bytes1) {\\n\\t\\trnd = randomizer.getIntRange(rnd, startIndex, uint32(values.length));\\n\\t\\treturn (rnd, values[rnd.value]);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"/contracts/IEuclidRandomizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//\\n//  ********  **     **    ******   **        **  *******  \\n// /**/////  /**    /**   **////** /**       /** /**////** \\n// /**       /**    /**  **    //  /**       /** /**    /**\\n// /*******  /**    /** /**        /**       /** /**    /**\\n// /**////   /**    /** /**        /**       /** /**    /**\\n// /**       /**    /** //**    ** /**       /** /**    ** \\n// /******** //*******   //******  /******** /** /*******  \\n// ////////   ///////     //////   ////////  //  ///////   \\n//\\n// by collect-code 2022\\n// https://collect-code.com/\\n//\\npragma solidity ^0.8.2;\\n\\ninterface IEuclidRandomizer {\\n\\n\\tstruct RandomizerState {\\n\\t\\tuint32[4] state;\\n\\t\\tuint32 value;\\n\\t}\\n\\n\\tfunction makeSeed(address contractAddress, address senderAddress, uint blockNumber, uint256 tokenNumber) external view returns (uint128) ;\\n\\tfunction initialize(uint128 seed) external pure returns (RandomizerState memory);\\n\\tfunction initialize(bytes16 seed) external pure returns (RandomizerState memory);\\n\\tfunction getNextValue(RandomizerState memory self) external pure returns (RandomizerState memory);\\n\\tfunction getInt(RandomizerState memory self, uint32 maxExclusive) external pure returns (RandomizerState memory);\\n\\tfunction getIntRange(RandomizerState memory self, uint32 minInclusive, uint32 maxExclusive) external pure returns (RandomizerState memory);\\n}\\n\"\r\n    },\r\n    \"/contracts/IEuclidFormula.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//\\n//  ********  **     **    ******   **        **  *******  \\n// /**/////  /**    /**   **////** /**       /** /**////** \\n// /**       /**    /**  **    //  /**       /** /**    /**\\n// /*******  /**    /** /**        /**       /** /**    /**\\n// /**////   /**    /** /**        /**       /** /**    /**\\n// /**       /**    /** //**    ** /**       /** /**    ** \\n// /******** //*******   //******  /******** /** /*******  \\n// ////////   ///////     //////   ////////  //  ///////   \\n//\\n// by collect-code 2022\\n// https://collect-code.com/\\n//\\npragma solidity ^0.8.2;\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./IEuclidRandomizer.sol\\\";\\n\\ninterface IEuclidFormula {\\n\\tfunction generateFormula(uint128 hash, uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"randomizer_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"hash\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"generateFormula\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"supplyDataFromTokenId\",\"outputs\":[{\"internalType\":\"uint8[6]\",\"name\":\"\",\"type\":\"uint8[6]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "EuclidFormula", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000c0e28d054a6b412bb520a5447d450ed70c0a3694", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}