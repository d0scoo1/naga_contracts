{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/v1/markets/eth/opensea/OpenSeaMarketV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\ninterface IOpenSea {\\r\\n    /**\\r\\n     * @dev Call atomicMatch - Solidity ABI encoding limitation workaround, hopefully temporary.\\r\\n     */\\r\\n    function atomicMatch_(\\r\\n        address[14] memory addrs,\\r\\n        uint[18] memory uints,\\r\\n        uint8[8] memory feeMethodsSidesKindsHowToCalls,\\r\\n        bytes memory calldataBuy,\\r\\n        bytes memory calldataSell,\\r\\n        bytes memory replacementPatternBuy,\\r\\n        bytes memory replacementPatternSell,\\r\\n        bytes memory staticExtradataBuy,\\r\\n        bytes memory staticExtradataSell,\\r\\n        uint8[2] memory vs,\\r\\n        bytes32[5] memory rssMetadata\\r\\n    ) external payable;\\r\\n}\\r\\n\\r\\nlibrary OpenSeaMarketV2 {\\r\\n\\r\\n    address public constant OPENSEA = 0x7f268357A8c2552623316e2562D90e642bB538E5;\\r\\n\\r\\n    struct OpenSeaBuy {\\r\\n        address[14] addrs;\\r\\n        uint[18] uints;\\r\\n        uint8[8] feeMethodsSidesKindsHowToCalls;\\r\\n        bytes calldataBuy;\\r\\n        bytes calldataSell;\\r\\n        bytes replacementPatternBuy;\\r\\n        bytes replacementPatternSell;\\r\\n        bytes staticExtradataBuy;\\r\\n        bytes staticExtradataSell;\\r\\n        uint8[2] vs;\\r\\n        bytes32[5] rssMetadata;\\r\\n    }\\r\\n\\r\\n    function buyAssetsForEth(OpenSeaBuy[] memory openSeaBuys, bool revertIfTrxFails) public {\\r\\n        for (uint256 i = 0; i < openSeaBuys.length; i++) {\\r\\n            _buyAssetForEth(openSeaBuys[i], revertIfTrxFails);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _buyAssetForEth(OpenSeaBuy memory _openSeaBuy, bool _revertIfTrxFails) internal {\\r\\n        bytes memory _data = abi.encodeWithSelector(IOpenSea.atomicMatch_.selector, _openSeaBuy.addrs, _openSeaBuy.uints, _openSeaBuy.feeMethodsSidesKindsHowToCalls, _openSeaBuy.calldataBuy, _openSeaBuy.calldataSell, _openSeaBuy.replacementPatternBuy, _openSeaBuy.replacementPatternSell, _openSeaBuy.staticExtradataBuy, _openSeaBuy.staticExtradataSell, _openSeaBuy.vs, _openSeaBuy.rssMetadata);\\r\\n        (bool success, ) = OPENSEA.call{value:_openSeaBuy.uints[4]}(_data);\\r\\n        if (!success && _revertIfTrxFails) {\\r\\n            // Copy revert reason from call\\r\\n            assembly {\\r\\n                returndatacopy(0, 0, returndatasize())\\r\\n                revert(0, returndatasize())\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"OPENSEA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OpenSeaMarketV2", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}