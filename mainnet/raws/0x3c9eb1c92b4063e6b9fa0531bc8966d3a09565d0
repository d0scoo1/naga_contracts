{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.8.4;\r\n\r\n/// @notice Safe ETH and ERC-20 transfer library that gracefully handles missing return values.\r\n/// @author Modified from SolMate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// License-Identifier: AGPL-3.0-only\r\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\nlibrary SafeTransferLib {\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERRORS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    error ETHtransferFailed();\r\n\r\n    error TransferFailed();\r\n\r\n    error TransferFromFailed();\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ETH OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _safeTransferETH(address to, uint256 amount) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // transfer the ETH and store if it succeeded or not\r\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        if (!callStatus) revert ETHtransferFailed();\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERC20 OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // get a pointer to some free memory\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // begin with the function selector\r\n            \r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // mask and append the \"to\" argument\r\n            \r\n            mstore(add(freeMemoryPointer, 36), amount) // finally append the \"amount\" argument - no mask as it's a full 32 byte value\r\n\r\n            // call the token and store if it succeeded or not\r\n            // we use 68 because the calldata length is 4 + 32 * 2\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n        }\r\n\r\n        if (!_didLastOptionalReturnCallSucceed(callStatus)) revert TransferFailed();\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // get a pointer to some free memory\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // begin with the function selector\r\n            \r\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // mask and append the \"from\" argument\r\n            \r\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // mask and append the \"to\" argument\r\n            \r\n            mstore(add(freeMemoryPointer, 68), amount) // finally append the \"amount\" argument - no mask as it's a full 32 byte value\r\n\r\n            // call the token and store if it succeeded or not\r\n            // we use 100 because the calldata length is 4 + 32 * 3\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\r\n        }\r\n\r\n        if (!_didLastOptionalReturnCallSucceed(callStatus)) revert TransferFromFailed();\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            INTERNAL HELPER LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _didLastOptionalReturnCallSucceed(bool callStatus) internal pure returns (bool success) {\r\n        assembly {\r\n            // get how many bytes the call returned\r\n            let returnDataSize := returndatasize()\r\n\r\n            // if the call reverted:\r\n            if iszero(callStatus) {\r\n                // copy the revert message into memory\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // revert with the same message\r\n                revert(0, returnDataSize)\r\n            }\r\n\r\n            switch returnDataSize\r\n            \r\n            case 32 {\r\n                // copy the return data into memory\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // set success to whether it returned true\r\n                success := iszero(iszero(mload(0)))\r\n            }\r\n            case 0 {\r\n                // there was no return data\r\n                success := 1\r\n            }\r\n            default {\r\n                // it returned some malformed input\r\n                success := 0\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Minimal ERC-20 interface.\r\ninterface IERC20minimal { \r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function burnFrom(address from, uint256 amount) external;\r\n}\r\n\r\n/// @notice Gas-optimized reentrancy protection.\r\n/// @author Modified from OpenZeppelin \r\n/// (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\r\n/// License-Identifier: MIT\r\nabstract contract ReentrancyGuard {\r\n    error Reentrancy();\r\n\r\n    uint256 private constant NOT_ENTERED = 1;\r\n\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private status = NOT_ENTERED;\r\n\r\n    modifier nonReentrant() {\r\n        if (status == ENTERED) revert Reentrancy();\r\n\r\n        status = ENTERED;\r\n\r\n        _;\r\n\r\n        status = NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/// @notice Redemption contract that transfers registered tokens from Kali DAO in proportion to burnt DAO tokens.\r\ncontract KaliDAOredemption is ReentrancyGuard {\r\n    using SafeTransferLib for address;\r\n\r\n    event ExtensionSet(address indexed dao, address[] tokens, uint256 indexed redemptionStart);\r\n\r\n    event ExtensionCalled(address indexed dao, address indexed member, uint256 indexed amountBurned);\r\n\r\n    event TokensAdded(address indexed dao, address[] tokens);\r\n\r\n    event TokensRemoved(address indexed dao, uint256[] tokenIndex);\r\n\r\n    error NullTokens();\r\n\r\n    error NotStarted();\r\n\r\n    mapping(address => address[]) public redeemables;\r\n\r\n    mapping(address => uint256) public redemptionStarts;\r\n\r\n    function getRedeemables(address dao) public view virtual returns (address[] memory tokens) {\r\n        tokens = redeemables[dao];\r\n    }\r\n\r\n    function setExtension(bytes calldata extensionData) public nonReentrant virtual {\r\n        (address[] memory tokens, uint256 redemptionStart) = abi.decode(extensionData, (address[], uint256));\r\n\r\n        if (tokens.length == 0) revert NullTokens();\r\n\r\n        // if redeemables are already set, this call will be interpreted as reset\r\n        if (redeemables[msg.sender].length != 0) delete redeemables[msg.sender];\r\n        \r\n        // cannot realistically overflow on human timescales\r\n        unchecked {\r\n            for (uint256 i; i < tokens.length; i++) {\r\n                redeemables[msg.sender].push(tokens[i]);\r\n            }\r\n        }\r\n\r\n        redemptionStarts[msg.sender] = redemptionStart;\r\n\r\n        emit ExtensionSet(msg.sender, tokens, redemptionStart);\r\n    }\r\n\r\n    function callExtension(\r\n        address account, \r\n        uint256 amount, \r\n        bytes calldata\r\n    ) public nonReentrant virtual returns (bool mint, uint256 amountOut) {\r\n        if (block.timestamp < redemptionStarts[msg.sender]) revert NotStarted();\r\n\r\n        for (uint256 i; i < redeemables[msg.sender].length;) {\r\n            // calculate fair share of given token for redemption\r\n            uint256 amountToRedeem = amount * \r\n                IERC20minimal(redeemables[msg.sender][i]).balanceOf(msg.sender) / \r\n                IERC20minimal(msg.sender).totalSupply();\r\n            \r\n            // `transferFrom` DAO to redeemer\r\n            if (amountToRedeem != 0) {\r\n                address(redeemables[msg.sender][i])._safeTransferFrom(\r\n                    msg.sender, \r\n                    account, \r\n                    amountToRedeem\r\n                );\r\n            }\r\n\r\n            // cannot realistically overflow on human timescales\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        // placeholder values to conform to interface and disclaim mint\r\n        (mint, amountOut) = (false, amount);\r\n\r\n        emit ExtensionCalled(msg.sender, account, amount);\r\n    }\r\n\r\n    function addTokens(address[] calldata tokens) public nonReentrant virtual {\r\n        // cannot realistically overflow on human timescales\r\n        unchecked {\r\n            for (uint256 i; i < tokens.length; i++) {\r\n                redeemables[msg.sender].push(tokens[i]);\r\n            }\r\n        }\r\n\r\n        emit TokensAdded(msg.sender, tokens);\r\n    }\r\n\r\n    function removeTokens(uint256[] calldata tokenIndex) public nonReentrant virtual {\r\n        for (uint256 i; i < tokenIndex.length; i++) {\r\n            // move last token to replace indexed spot and pop array to remove last token\r\n            redeemables[msg.sender][tokenIndex[i]] = \r\n                redeemables[msg.sender][redeemables[msg.sender].length - 1];\r\n\r\n            redeemables[msg.sender].pop();\r\n        }\r\n\r\n        emit TokensRemoved(msg.sender, tokenIndex);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"NotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NullTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrancy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amountBurned\",\"type\":\"uint256\"}],\"name\":\"ExtensionCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"redemptionStart\",\"type\":\"uint256\"}],\"name\":\"ExtensionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"TokensAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIndex\",\"type\":\"uint256[]\"}],\"name\":\"TokensRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"addTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"callExtension\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"mint\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"getRedeemables\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"redeemables\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"redemptionStarts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIndex\",\"type\":\"uint256[]\"}],\"name\":\"removeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extensionData\",\"type\":\"bytes\"}],\"name\":\"setExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "KaliDAOredemption", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://846e3f170860a39b6aec6d128759da101c27aaf5fb683103ec17bedb4bf5a940"}]}