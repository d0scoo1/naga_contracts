{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/protocol/CoordinationPaymentChannels.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"./CanReclaimTokens.sol\\\";\\n\\n\\n\\ncontract CoordinationPaymentChannels is CanReclaimTokens {\\n    using SafeERC20 for IERC20;\\n\\n    IERC20 constant ROOK = IERC20(0xfA5047c9c78B8877af97BDcb85Db743fD7313d4a);\\n    bytes constant public INSTANT_WITHDRAWAL_COMMITMENT_DATA = bytes(\\\"INSTANT\\\");\\n\\n    // This keypair is responsible for signing stake commitments\\n    address public coordinator;\\n    // This keypair is responsible for signing user claim commitments\\n    address public claimGenerator;\\n    \\n    /* coordinator <-> keeper payment channels\\n     * The Coordinator and Keepers transact off-chain using these payment channels in a series of auctions\\n     * hosted by the Coordinator. The values stored in these variables reflect the latest on-chain state for a\\n     * payment channel, but the actual state of the payment channels is likely to be more recent than what is on\\n     * chain. The Coordinator and keeepers will pass signed commitments back and forth dictating what the current state\\n     * of the payment channel is.\\n     * A payment channel is keyed by a Keeper's stake address. \\n     * Note a keeper may have multiple payment channels / stake addresses.\\n     */\\n    // The amount of Rook a keeper's stake address has staked. This determines their maximum spending power.\\n    mapping (address => uint256) public stakedAmount;\\n    // This nonce is used to give an ordering to the off-chain stake commitments and to prevent replays on-chain.\\n    mapping (address => uint256) public stakeNonce;\\n    // The total amount of Rook a keeper has currently spent. Cannot be greater than stakedAmount.\\n    mapping (address => uint256) public stakeSpent;\\n    // Used to prevent channel reuse edge cases if a stake address closes their channel and opens another.\\n    mapping (address => uint256) public channelNonce;\\n    // Used to track the expiration of withdrawal timelocks.\\n    mapping (bytes32 => uint256) public withdrawalTimelockTimestamp;\\n\\n    /* claim generator -> user payment channels\\n     * The Claim Generator will generate claims using the Keeper bids from the Coordinator auctions. Claim amounts are\\n     * calculated as a percentage of the bid amounts determined by the DAO. Given that bids are signed by Keepers and\\n     * the Claim Generator, and they are available publicly, claim amount correcntess is easily verifiable off-chain.\\n     *\\n     * userClaimedAmount tracks how much a user has claimed to date. A user's outstanding claim amount is given by\\n     * subtracting userClaimedAmount from their most recent claim commitment generated by the Claim Generator.\\n     */\\n    mapping (address => uint256) public userClaimedAmount;\\n\\n\\n    /* Total amount of claimable Rook. Accrues when commitments are submitted to `initiateTimelockedWithdrawal`,\\n     * `executeInstantWithdrawal`, and `settleSpentStake` and when `addClaimable` is called.\\n     */\\n    uint256 public totalClaimableAmount;\\n\\n    event Staked(address indexed _stakeAddress, uint256 _channelNonce, uint256 _amount);\\n    event Claimed(address indexed _claimAddress, uint256 _amount);\\n    event CoordinatorChanged(address indexed _oldCoordinator, address indexed _newCoordinator);\\n    event ClaimGeneratorChanged(address indexed _oldClaimGenerator, address indexed _newClaimGenerator);\\n    event StakeWithdrawn(address indexed _stakeAddress, uint256 _channelNonce, uint256 _amount);\\n    event TimelockedWithdrawalInitiated(\\n        address indexed _stakeAddress, \\n        uint256 _stakeSpent, \\n        uint256 _stakeNonce, \\n        uint256 _channelNonce, \\n        uint256 _withdrawalTimelock);\\n    event AddedClaimable(uint256 _amount);\\n    event Settled(uint256 _refundedAmount, uint256 _accruedAmount);\\n\\n    /* Represents a payment channel state. The Coordinator and Keepers will sign commitments to agree upon the current\\n     * Note, the `data` field is used off-chain to hold the hash of the previous commitment to ensure that the \\n     * Coordinator and Keeper state for the payment channel is always consistent. The only time any assertions are made\\n     * on its value is `executeInstantWithdrawal` when it should equal `INSTANT_WITHDRAWAL_COMMITMENT_DATA`.\\n     */\\n    struct StakeCommitment {\\n        address stakeAddress;\\n        uint256 stakeSpent;\\n        uint256 stakeNonce;\\n        uint256 channelNonce;\\n        bytes data;\\n        bytes stakeAddressSignature;\\n        bytes coordinatorSignature;\\n    }\\n\\n    /// @notice Retreives the payment channel state for the provided stake address.\\n    function getStakerState(\\n        address _stakeAddress\\n    ) public view returns (\\n        uint256 _stakedAmount, \\n        uint256 _stakeNonce, \\n        uint256 _stakeSpent, \\n        uint256 _channelNonce, \\n        uint256 _withdrawalTimelock\\n    ) {\\n        return (\\n            stakedAmount[_stakeAddress], \\n            stakeNonce[_stakeAddress], \\n            stakeSpent[_stakeAddress], \\n            channelNonce[_stakeAddress], \\n            getCurrentWithdrawalTimelock(_stakeAddress));\\n    }\\n\\n    /** @notice Calculate the commitment hash used for signatures for a particular stake payment channel state.\\n      * @dev The Coordinator and Keepers transact off-chain by passing signed commitments back and forth. Signed stake \\n      *      commitments are submitted on-chain only to perform settlements and withdrawals.\\n      */\\n    function stakeCommitmentHash(\\n        address _stakeAddress, \\n        uint256 _stakeSpent, \\n        uint256 _stakeNonce, \\n        uint256 _channelNonce, \\n        bytes memory _data\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encode(_stakeAddress, _stakeSpent, _stakeNonce, _channelNonce, _data));\\n    }\\n\\n    function stakeCommitmentHash(\\n        StakeCommitment memory _commitment\\n    ) internal pure returns (bytes32) {\\n        return stakeCommitmentHash(\\n            _commitment.stakeAddress, \\n            _commitment.stakeSpent, \\n            _commitment.stakeNonce, \\n            _commitment.channelNonce, \\n            _commitment.data);\\n    }\\n\\n    /** @notice Calculate the commitment hash used for signatures for a particular claim payment channel state.\\n      *         Signed claim commitments are generated by the claim generator and used by users to perform claims.\\n      */\\n    function claimCommitmentHash(\\n        address _claimAddress, \\n        uint256 _earningsToDate\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encode(_claimAddress, _earningsToDate));\\n    }\\n\\n    /** @notice Calculate the key to the entry in the withdrawalTimelockTimestamp map for a particular stake\\n      *         payment channel state.\\n      */\\n    function withdrawalTimelockKey(\\n        address _stakeAddress, \\n        uint256 _stakeSpent, \\n        uint256 _stakeNonce, \\n        uint256 _channelNonce\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encode(_stakeAddress, _stakeSpent, _stakeNonce, _channelNonce));\\n    }\\n\\n    /** @notice Get the withdrawal timelock expiration for a payment channel. A return value of 0 indicates no timelock.\\n      * @dev The withdrawal timelock allows the Coordinator to withdrawals with newer commitments.\\n      */\\n    function getCurrentWithdrawalTimelock(\\n        address _stakeAddress\\n    ) public view returns (uint256) {\\n        return withdrawalTimelockTimestamp[\\n            withdrawalTimelockKey(\\n                _stakeAddress, \\n                stakeSpent[_stakeAddress], \\n                stakeNonce[_stakeAddress], \\n                channelNonce[_stakeAddress])];\\n    }\\n\\n    constructor(address _coordinator, address _claimGenerator) {\\n        coordinator = _coordinator;\\n        claimGenerator = _claimGenerator;\\n        blacklistRecoverableToken(address(ROOK));\\n        emit CoordinatorChanged(address(0), _coordinator);\\n        emit ClaimGeneratorChanged(address(0), _claimGenerator);\\n    }\\n\\n    /** @notice Update the Coordinator address. This keypair is responsible for signing stake commitments.\\n      * @dev To migrate Coordinator addresses, any commitments signed by the old Coordinator must be resigned by the\\n      *      new Coordinator address.\\n      */ \\n    function updateCoordinatorAddress(\\n        address _newCoordinator\\n    ) external onlyOperator {\\n        emit CoordinatorChanged(coordinator, _newCoordinator);\\n        coordinator = _newCoordinator;\\n    }\\n\\n    /** @notice Update the claimGenerator address. This keypair is responsible to for signing user claim commitments.\\n      * @dev To migrate claimGenerator addresses, any commitments signed by the old Claim address must be resigned by\\n      *      the new claimGenerator address.\\n      */\\n    function updateClaimGeneratorAddress(\\n        address _newClaimGenerator\\n    ) external onlyOperator {\\n        emit ClaimGeneratorChanged(claimGenerator, _newClaimGenerator);\\n        claimGenerator = _newClaimGenerator;\\n    }\\n\\n    /** @notice Add Rook to the payment channel of msg.sender. Cannot be done while in a timelocked withdrawal.\\n      * @dev Withdrawal of stake will require a signature from the Coordinator.\\n      */\\n    function stake(\\n        uint256 _amount\\n    ) public {\\n        require(getCurrentWithdrawalTimelock(msg.sender) == 0, \\\"cannot stake while in withdrawal\\\");\\n        ROOK.safeTransferFrom(msg.sender, address(this), _amount);\\n        stakedAmount[msg.sender] += _amount;\\n        emit Staked(msg.sender, channelNonce[msg.sender], stakedAmount[msg.sender]);\\n    }\\n\\n    /** @notice Used to add claimable Rook to the contract.\\n      * @dev Since claimable Rook otherwise only accrues on withdrawal or settlement of Rook, this can be used create a\\n      *      buffer of immediately claimable Rook so users do not need to wait for a Keeper to withdraw or for someone\\n      *      to call the `settleSpentStake` function. This can also be used to amend deficits from overgenerous claims.\\n      */\\n    function addClaimable(\\n        uint256 _amount\\n    ) public {\\n        ROOK.safeTransferFrom(msg.sender, address(this), _amount);\\n        totalClaimableAmount += _amount;\\n        emit AddedClaimable(_amount);\\n    }\\n\\n    /** @dev The stakeSpent for a payment channel will increase when a stake address makes payments and decrease\\n      *      when the Coordinator issues refunds. This function changes the totalClaimableAmount of Rook on the contract\\n      *      accordingly.\\n      */\\n    function adjustTotalClaimableAmountByStakeSpentChange(\\n        uint256 _oldStakeSpent, \\n        uint256 _newStakeSpent\\n    ) internal {\\n        if (_newStakeSpent < _oldStakeSpent) {\\n            // If a stake address's new stakeSpent is less than their previously stored stakeSpent, then a refund was \\n            // issued to the stakeAddress. We \\\"refund\\\" this rook to the stakeAddress by subtracting \\n            // the difference from totalClaimableAmount.\\n            uint256 refundAmount = _oldStakeSpent - _newStakeSpent;\\n            require(totalClaimableAmount >= refundAmount, \\\"not enough claimable rook to refund\\\");\\n            totalClaimableAmount -= refundAmount;\\n        } else {\\n            // Otherwise we accrue any unsettled spent stake to totalClaimableAmount.\\n            totalClaimableAmount += _newStakeSpent - _oldStakeSpent;\\n        }\\n    }\\n\\n    /** @notice Used to settle spent stake for a payment channel to accrue claimable rook. \\n      * @dev Note anyone can call this function since it requires a signature from both keepers and the coordinator.\\n      *      It will primarily be used by the coordinator but a user who would like to claim Rook immediately when there\\n      *      is no claimable Rook may also call this to accrue claimable rook.\\n      * @param _commitments is a list of StakeCommitments. There should be one entry for each payment channel being\\n      *        settled and it should be the latest commitment for that channel. We only care about the most recent\\n      *        state for a payment channel, so evenif there are multiple commitments for a payment channel that have not\\n      *        been submitted on-chain, only the latest needs to be submitted. The resulting contract state will be the\\n      *        same regardless.\\n      */\\n    function settleSpentStake(\\n        StakeCommitment[] memory _commitments\\n    ) external {\\n        uint256 claimableRookToAccrue = 0;\\n        uint256 claimableRookToRefund = 0;\\n        for (uint i=0; i< _commitments.length; i++) {\\n            StakeCommitment memory commitment = _commitments[i];\\n            // Initiating withdrawal settles the spent stake in the payment channel. Thus we disable settling spent\\n            // stake using this function for a payment channel in withdrawal. Proper settlement of the payment channel\\n            // should be handled by the withdrawal process.\\n            require(getCurrentWithdrawalTimelock(commitment.stakeAddress) == 0, \\\"cannot settle while in withdrawal\\\");\\n            require(commitment.stakeSpent <= stakedAmount[commitment.stakeAddress], \\\"cannot spend more than is staked\\\");\\n            require(commitment.stakeNonce > stakeNonce[commitment.stakeAddress], \\\"stake nonce is too old\\\");\\n            require(commitment.channelNonce == channelNonce[commitment.stakeAddress], \\\"incorrect channel nonce\\\");\\n\\n            address recoveredStakeAddress = ECDSA.recover(\\n                ECDSA.toEthSignedMessageHash(stakeCommitmentHash(commitment)), \\n                commitment.stakeAddressSignature);\\n            require(recoveredStakeAddress == commitment.stakeAddress, \\\"recovered address is not the stake address\\\");\\n            address recoveredCoordinatorAddress =  ECDSA.recover(\\n                ECDSA.toEthSignedMessageHash(stakeCommitmentHash(commitment)), \\n                commitment.coordinatorSignature);\\n            require(recoveredCoordinatorAddress == coordinator, \\\"recovered address is not the coordinator\\\");\\n\\n            if (commitment.stakeSpent < stakeSpent[commitment.stakeAddress]) {\\n                // If a stake address's new stakeSpent is less than their previously stored stakeSpent, then a refund was \\n                // issued to the stakeAddress. We \\\"refund\\\" this rook to the stakeAddress by subtracting \\n                // the difference from totalClaimableAmount.\\n                claimableRookToRefund += stakeSpent[commitment.stakeAddress] - commitment.stakeSpent;\\n            } else {\\n                // Otherwise we accrue any unsettled spent stake to totalClaimableAmount\\n                claimableRookToAccrue += commitment.stakeSpent - stakeSpent[commitment.stakeAddress];\\n            }\\n            stakeNonce[commitment.stakeAddress] = commitment.stakeNonce;\\n            stakeSpent[commitment.stakeAddress] = commitment.stakeSpent;\\n        }\\n        adjustTotalClaimableAmountByStakeSpentChange(claimableRookToRefund, claimableRookToAccrue);\\n        emit Settled(claimableRookToRefund, claimableRookToAccrue);\\n    }\\n\\n    /** @notice Initiate or challenge withdrawal, which can be completed after a 7 day timelock expires.\\n      * @dev Used by the stake addresses to withdraw from and close the payment channel. Also used by the Coordinator to\\n      *      challenge a withdrawal. The most recent commitment for the payment channel that has been signed by both the\\n      *      stake address and the Coordinator should be used for the withdrawal. In order to prevent Keepers from\\n      *      immediately exiting with an old commitment, potentially taking Rook they do not own, there is a 7 day\\n      *      timelock on being able to complete the withdrawal. If the Coordinator has a more recent commitment, they\\n      *      will submit it to this function resetting the timelock.\\n      */\\n    function initiateTimelockedWithdrawal(\\n        StakeCommitment memory _commitment\\n    ) external {\\n        // This is to prevent people who are not the payment channel owner from initiating the withdrawal process.\\n        if (getCurrentWithdrawalTimelock(_commitment.stakeAddress) == 0) {\\n            require(msg.sender == _commitment.stakeAddress, \\\"only stakeAddress can start the withdrawal process\\\");\\n        }\\n        require(_commitment.stakeSpent <= stakedAmount[_commitment.stakeAddress], \\\"cannot spend more than is staked\\\");\\n        // The stakeNonce may have been seen in settleSpentStake so we must allow >= to here.\\n        // Note this means a malicious or compromised Coordinator has the ability to indefinitely reset the timelock.\\n        // This is fine since we can just change the Coordinator address.\\n        require(_commitment.stakeNonce >= stakeNonce[_commitment.stakeAddress], \\\"stake nonce is too old\\\");\\n        require(_commitment.channelNonce == channelNonce[_commitment.stakeAddress], \\\"incorrect channel nonce\\\");\\n        require(msg.sender == _commitment.stakeAddress || msg.sender == coordinator, \\n            \\\"only callable by stakeAdddress or coordinator\\\");\\n        \\n        address recoveredStakeAddress = ECDSA.recover(\\n            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)), \\n            _commitment.stakeAddressSignature);\\n        require(recoveredStakeAddress == _commitment.stakeAddress, \\\"recovered address is not the stake address\\\");\\n        address recoveredCoordinatorAddress =  ECDSA.recover(\\n            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)), \\n            _commitment.coordinatorSignature);\\n        require(recoveredCoordinatorAddress == coordinator, \\\"recovered address is not the coordinator\\\");\\n\\n        adjustTotalClaimableAmountByStakeSpentChange(stakeSpent[_commitment.stakeAddress], _commitment.stakeSpent);\\n        stakeNonce[_commitment.stakeAddress] = _commitment.stakeNonce;\\n        stakeSpent[_commitment.stakeAddress] = _commitment.stakeSpent;\\n\\n        // Initiate the timelock\\n        withdrawalTimelockTimestamp[\\n            withdrawalTimelockKey(\\n                _commitment.stakeAddress, \\n                _commitment.stakeSpent, \\n                _commitment.stakeNonce, \\n                _commitment.channelNonce\\n            )] = block.timestamp + 7 days;\\n\\n        emit TimelockedWithdrawalInitiated(\\n            _commitment.stakeAddress, \\n            _commitment.stakeSpent, \\n            _commitment.stakeNonce, \\n            _commitment.channelNonce, \\n            block.timestamp + 7 days);\\n    }\\n\\n    /** @notice Withdraw remaining stake from the payment channel after the withdrawal timelock has concluded.\\n      * @dev Closing the payment channel zeros out all payment channel state for the stake address aside from the\\n      *      channelNonce which is incremented. This is to prevent any channel reuse edge cases. A stake address that\\n      *      has closed their payment channel and withdrawn is able to create a new payment channel by staking Rook. \\n      */\\n    function executeTimelockedWithdrawal(\\n        address _stakeAddress\\n    ) public {\\n        uint256 _channelNonce = channelNonce[_stakeAddress];\\n        require(getCurrentWithdrawalTimelock(_stakeAddress) > 0, \\\"must initiate timelocked withdrawal first\\\");\\n        require(block.timestamp > getCurrentWithdrawalTimelock(_stakeAddress), \\\"still in withdrawal timelock\\\");\\n        \\n        uint256 withdrawalAmount = stakedAmount[_stakeAddress] - stakeSpent[_stakeAddress];\\n        stakeNonce[_stakeAddress] = 0;\\n        stakeSpent[_stakeAddress] = 0;\\n        stakedAmount[_stakeAddress] = 0;\\n        channelNonce[_stakeAddress] += 1;\\n\\n        ROOK.safeTransfer(_stakeAddress, withdrawalAmount);\\n\\n        emit StakeWithdrawn(_stakeAddress, _channelNonce, withdrawalAmount);\\n    }\\n\\n    /** @notice Instantly withdraw remaining stake in payment channel.\\n      * @dev To perform an instant withdrawal a Keeper will ask the coordinator for an instant withdrawal signature. \\n      *      This `data` field in the commitment used to produce the signature should be populated with \\n      *      `INSTANT_WITHDRAWAL_COMMITMENT_DATA`. We don't want a compromised Coordinator to instantly settle the \\n      *      channel with an old commitment, so we also require a stakeAddress instant withdrawal signature.\\n      *      Closing the payment channel zeros out all payment channel state for the stake address aside from the\\n      *      channelNonce which is incremented. This is to prevent any channel reuse edge cases. A stake address that\\n      *      has closed their payment channel and withdrawn is able to create a new payment channel by staking Rook.\\n      */\\n    function executeInstantWithdrawal(\\n        StakeCommitment memory _commitment\\n    ) external {\\n        require(msg.sender == _commitment.stakeAddress, \\\"only stakeAddress can perform instant withdrawal\\\");\\n        require(_commitment.stakeSpent <= stakedAmount[_commitment.stakeAddress], \\\"cannot spend more than is staked\\\");\\n        // The stakeNonce may have been seen in settleSpentStake so we must allow >= to here.\\n        // Note this means a malicious or compromised Coordinator has the ability to indefinitely reset the timelock.\\n        // This is fine since we can just change the Coordinator address.\\n        require(_commitment.stakeNonce >= stakeNonce[_commitment.stakeAddress], \\\"stake nonce is too old\\\");\\n        require(_commitment.channelNonce == channelNonce[_commitment.stakeAddress], \\\"incorrect channel nonce\\\");\\n        require(keccak256(_commitment.data) == keccak256(INSTANT_WITHDRAWAL_COMMITMENT_DATA), \\\"incorrect data payload\\\");\\n\\n        address recoveredStakeAddress =  ECDSA.recover(\\n            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)), \\n            _commitment.stakeAddressSignature);\\n        require(recoveredStakeAddress == _commitment.stakeAddress, \\\"recovered address is not the stake address\\\");\\n        address recoveredCoordinatorAddress =  ECDSA.recover(\\n            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)), \\n            _commitment.coordinatorSignature);\\n        require(recoveredCoordinatorAddress == coordinator, \\\"recovered address is not the coordinator\\\");\\n        \\n        adjustTotalClaimableAmountByStakeSpentChange(stakeSpent[_commitment.stakeAddress], _commitment.stakeSpent);\\n        uint256 withdrawalAmount = stakedAmount[_commitment.stakeAddress] - _commitment.stakeSpent;\\n        stakeNonce[_commitment.stakeAddress] = 0;\\n        stakeSpent[_commitment.stakeAddress] = 0;\\n        stakedAmount[_commitment.stakeAddress] = 0;\\n        channelNonce[_commitment.stakeAddress] += 1;\\n\\n        ROOK.safeTransfer(_commitment.stakeAddress, withdrawalAmount);\\n\\n        emit StakeWithdrawn(_commitment.stakeAddress, _commitment.channelNonce, withdrawalAmount);\\n    }\\n\\n    /** @notice Claim accumulated earnings. Claim amounts are determined off-chain and signed by the claimGenerator \\n      *         address. Claim amounts are calculated as a pre-determined percentage of a Keeper's bid, and Keeper bids \\n      *         are signed by both Keepers and the Coordinator, so claim amount correctness is easily verifiable \\n      *         off-chain by consumers even if it is not verified on-chain.\\n      * @dev Note that it is not feasible to verify claim amount correctness on-chain as the total claim amount for\\n      *      a user can be the sum of claims generated from any number of bid commitments. Claimers only rely on the \\n      *      claim generator to calculate the claim as a percentage of Keeper bids correctly and this is easily \\n      *      verifiable by consumers off-chain given the signed bid commitments are public.\\n      *      A user has claimable Rook if the Claim Generator has generated a commitment for them where `earningsToDate`\\n      *      is greater than `userClaimedAmount[_claimAddress]`.\\n      */\\n    function claim(\\n        address _claimAddress, \\n        uint256 _earningsToDate,\\n        bytes memory _claimGeneratorSignature\\n    ) external {\\n        require(_earningsToDate > userClaimedAmount[_claimAddress], \\\"nothing to claim\\\");\\n\\n        address recoveredClaimGeneratorAddress = ECDSA.recover(\\n            ECDSA.toEthSignedMessageHash(claimCommitmentHash(_claimAddress, _earningsToDate)), \\n            _claimGeneratorSignature);\\n        require(recoveredClaimGeneratorAddress == claimGenerator, \\\"recoveredClaimGeneratorAddress is not the account manager\\\");\\n\\n        uint256 claimAmount = _earningsToDate - userClaimedAmount[_claimAddress];\\n        require(claimAmount <= totalClaimableAmount, \\\"claim amount exceeds balance on contract\\\");\\n        userClaimedAmount[_claimAddress] = _earningsToDate;\\n        totalClaimableAmount -= claimAmount;\\n\\n        ROOK.safeTransfer(_claimAddress, claimAmount);\\n        emit Claimed(_claimAddress, claimAmount);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n        } else if (signature.length == 64) {\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                let vs := mload(add(signature, 0x40))\\n                r := mload(add(signature, 0x20))\\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n                v := add(shr(255, vs), 27)\\n            }\\n        } else {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/CanReclaimTokens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./KRoles.sol\\\";\\n\\ncontract CanReclaimTokens is KRoles {\\n    using SafeERC20 for IERC20;\\n\\n    mapping(address => bool) private recoverableTokensBlacklist;\\n\\n    function blacklistRecoverableToken(address _token) public onlyOperator {\\n        recoverableTokensBlacklist[_token] = true;\\n    }\\n\\n    /// @notice Allow the owner of the contract to recover funds accidentally\\n    /// sent to the contract. To withdraw ETH, the token should be set to `0x0`.\\n    function recoverTokens(address _token) external onlyOperator {\\n        require(\\n            !recoverableTokensBlacklist[_token],\\n            \\\"CanReclaimTokens: token is not recoverable\\\"\\n        );\\n\\n        if (_token == address(0x0)) {\\n           (bool success,) = msg.sender.call{ value: address(this).balance }(\\\"\\\");\\n            require(success, \\\"Transfer Failed\\\");\\n        } else {\\n            IERC20(_token).safeTransfer(\\n                msg.sender,\\n                IERC20(_token).balanceOf(address(this))\\n            );\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/KRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\ncontract KRoles is AccessControl {\\n    bytes32 public constant OPERATOR_ROLE = keccak256(\\\"OPERATOR_ROLE\\\");\\n\\n    event OperatorAdded(address indexed account);\\n    event OperatorRemoved(address indexed account);\\n\\n    constructor() {\\n        /// Note, given that it is possible for both the DEFAULT_ADMIN_ROLE and OPERATOR_ROLE to renounce their roles,\\n        /// the contract can reach a state where there are not operators or admins. Users of inherting contracts should\\n        /// be sure to avoid reaching this state, as they will be permanently locked out of using any functions relying\\n        /// on the `onlyOperator` modifier for access control.\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _setupRole(OPERATOR_ROLE, _msgSender());\\n        _setRoleAdmin (OPERATOR_ROLE, DEFAULT_ADMIN_ROLE) ;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(isOperator(_msgSender()), \\\"OperatorRole: caller does not have the Operator role\\\");\\n        _;\\n    }\\n\\n    function isOperator(address account) public view returns (bool) {\\n        return hasRole(OPERATOR_ROLE, account);\\n    }\\n\\n    function addOperator(address account) public {\\n        _addOperator(account);\\n    }\\n\\n    /** @notice Renounces operator role of msg.sender. Note that it is possible for all operators to be renounced, which\\n      * will lock functions relying on the `onlyOperator` modifier for access control.\\n      */\\n    function renounceOperator() public virtual {\\n        _renounceOperator(msg.sender);\\n    }\\n\\n    function _addOperator(address account) internal {\\n        grantRole(OPERATOR_ROLE, account);\\n        emit OperatorAdded(account);\\n    }\\n\\n    function _renounceOperator(address account) internal {\\n        renounceRole(OPERATOR_ROLE, account);\\n        emit OperatorRemoved(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n    function grantRole(bytes32 role, address account) external;\\n    function revokeRole(bytes32 role, address account) external;\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping (address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if(!hasRole(role, account)) {\\n            revert(string(abi.encodePacked(\\n                \\\"AccessControl: account \\\",\\n                Strings.toHexString(uint160(account), 20),\\n                \\\" is missing role \\\",\\n                Strings.toHexString(uint256(role), 32)\\n            )));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coordinator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_claimGenerator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"AddedClaimable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldClaimGenerator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newClaimGenerator\",\"type\":\"address\"}],\"name\":\"ClaimGeneratorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_claimAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldCoordinator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newCoordinator\",\"type\":\"address\"}],\"name\":\"CoordinatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_refundedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_accruedAmount\",\"type\":\"uint256\"}],\"name\":\"Settled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_stakeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_channelNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"StakeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_stakeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_channelNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_stakeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeSpent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_channelNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_withdrawalTimelock\",\"type\":\"uint256\"}],\"name\":\"TimelockedWithdrawalInitiated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INSTANT_WITHDRAWAL_COMMITMENT_DATA\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPERATOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addClaimable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"blacklistRecoverableToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"channelNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_claimAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_earningsToDate\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_claimGeneratorSignature\",\"type\":\"bytes\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_claimAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_earningsToDate\",\"type\":\"uint256\"}],\"name\":\"claimCommitmentHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimGenerator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coordinator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"stakeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"channelNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"stakeAddressSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"coordinatorSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct CoordinationPaymentChannels.StakeCommitment\",\"name\":\"_commitment\",\"type\":\"tuple\"}],\"name\":\"executeInstantWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeAddress\",\"type\":\"address\"}],\"name\":\"executeTimelockedWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeAddress\",\"type\":\"address\"}],\"name\":\"getCurrentWithdrawalTimelock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeAddress\",\"type\":\"address\"}],\"name\":\"getStakerState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_channelNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawalTimelock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"stakeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"channelNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"stakeAddressSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"coordinatorSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct CoordinationPaymentChannels.StakeCommitment\",\"name\":\"_commitment\",\"type\":\"tuple\"}],\"name\":\"initiateTimelockedWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"stakeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"channelNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"stakeAddressSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"coordinatorSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct CoordinationPaymentChannels.StakeCommitment[]\",\"name\":\"_commitments\",\"type\":\"tuple[]\"}],\"name\":\"settleSpentStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_channelNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"stakeCommitmentHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeSpent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newClaimGenerator\",\"type\":\"address\"}],\"name\":\"updateClaimGeneratorAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCoordinator\",\"type\":\"address\"}],\"name\":\"updateCoordinatorAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userClaimedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_channelNonce\",\"type\":\"uint256\"}],\"name\":\"withdrawalTimelockKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawalTimelockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CoordinationPaymentChannels", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000002f82fb86e59292a4c9f5875c2e90111746d229b00000000000000000000000002f82fb86e59292a4c9f5875c2e90111746d229b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}