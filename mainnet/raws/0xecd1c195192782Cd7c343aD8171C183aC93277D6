{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/RpYieldCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\n\\nimport './IRaid.sol';\\n\\n/**\\n * @title Raid Party pending rewards batch collection\\n * @author xanewok.eth\\n * @dev\\n *\\n * Batch claiming can be optionally:\\n * - (`taxed` prefix) taxed by an external entity such as guilds and/or\\n * - (`To` suffix) collected into a single address to save on gas.\\n *\\n * Because $CFTI is an ERC-20 token, we still need to approve this contract\\n * from each account where we will draw the funds from for spending in order to\\n * move the funds - however, since this contract will be (probably) fully\\n * authorized to manage the funds, we need to be extra careful where those funds\\n * will be withdrawn.\\n *\\n * To address this issue, we introduce a concept of *operators* (poor man's\\n * ERC-777 operators) which are authorized accounts that can act (and withdraw\\n * tokens, among others) on behalf of the token *owner* accounts via this contract.\\n *\\n */\\ncontract RpYieldCollector is Context, Ownable {\\n    uint256 public _collectedFee;\\n    IERC20 public immutable _confetti;\\n    IRaid public immutable _raid;\\n    uint16 public constant BP_PRECISION = 1e4;\\n    uint16 public _feeBasisPoints = 50; // 0.5%\\n\\n    // For each account, a mapping of its operators.\\n    mapping(address => mapping(address => bool)) private _operators;\\n\\n    constructor(address confetti, address raid) {\\n        _confetti = IERC20(confetti);\\n        _raid = IRaid(raid);\\n    }\\n\\n    function setFee(uint16 amount) public onlyOwner {\\n        require(amount <= 100, \\\"Fee is never going to be more than 1%\\\");\\n        _feeBasisPoints = amount;\\n    }\\n\\n    function withdrawFee() public onlyOwner {\\n        _confetti.transfer(msg.sender, _collectedFee);\\n        _collectedFee = 0;\\n    }\\n\\n    /// @notice Claims RP pending rewards for each wallet in a single transaction\\n    function claimMultipleRewards(address[] calldata wallets) public {\\n        // NOTE: It's safe to simply collect pending rewards for given wallets,\\n        // - worst case we simply pay for their gas fees lol\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            _raid.claimRewards(wallets[i]);\\n        }\\n    }\\n\\n    /// @notice Claims RP pending rewards for each wallet in a single transaction\\n    function taxedClaimMultipleRewards(\\n        address[] calldata wallets,\\n        uint16 taxBasisPoints,\\n        address taxRecipient\\n    ) public authorized(wallets) {\\n        require(\\n            taxBasisPoints + _feeBasisPoints <= BP_PRECISION,\\n            \\\"Can't collect over 100%\\\"\\n        );\\n        require(taxRecipient != address(0x0), \\\"Tax recipient can't be zero\\\");\\n\\n        // Firstly, claim all the pending rewards for the wallets\\n        uint256 claimedRewards = getPendingRewards(wallets);\\n        claimMultipleRewards(wallets);\\n\\n        // Secondly, collect the tax and the service fee from the rewards.\\n        // To save on gas, we try to minimize the amount of token transfers.\\n        uint256 tax = (claimedRewards * taxBasisPoints) / BP_PRECISION;\\n        amortizedCollectFrom(wallets, taxRecipient, tax);\\n        // To save on gas, fees are accumulated and pulled when needed.\\n        uint256 fee = (claimedRewards * _feeBasisPoints) / BP_PRECISION;\\n        amortizedCollectFrom(wallets, address(this), fee);\\n        _collectedFee += fee;\\n    }\\n\\n    /// @dev You should read `isApproved` first to make sure each wallet has ERC20 approval\\n    function claimMultipleRewardsTo(\\n        address[] calldata wallets,\\n        address recipient\\n    ) public authorized(wallets) returns (uint256) {\\n        // TODO:\\n        uint256 totalClaimedRewards = 0;\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            uint256 pendingRewards = _raid.getPendingRewards(wallets[i]);\\n            totalClaimedRewards += pendingRewards;\\n\\n            _raid.claimRewards(wallets[i]);\\n            _confetti.transferFrom(wallets[i], address(this), pendingRewards);\\n        }\\n\\n        uint256 fee = (totalClaimedRewards * _feeBasisPoints) / BP_PRECISION;\\n        _confetti.transfer(recipient, totalClaimedRewards - fee);\\n        _collectedFee += fee;\\n\\n        return totalClaimedRewards - fee;\\n    }\\n\\n    /// @notice Claims rewards from the wallets to a single wallet, while also\\n    /// collecting a tax. Tax is in basis points, i.e. value of 100 means the\\n    /// tax is 1%, value of 10 means 0.1% etc.\\n    function taxedClaimMultipleRewardsTo(\\n        address[] calldata wallets,\\n        address recipient,\\n        uint16 taxBasisPoints,\\n        address taxRecipient\\n    ) public authorized(wallets) {\\n        require(\\n            taxBasisPoints + _feeBasisPoints <= BP_PRECISION,\\n            \\\"Can't collect over 100%\\\"\\n        );\\n        require(taxRecipient != address(0x0), \\\"Tax recipient can't be zero\\\");\\n\\n        uint256 claimedRewards = 0;\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            uint256 pendingRewards = _raid.getPendingRewards(wallets[i]);\\n            claimedRewards += pendingRewards;\\n\\n            _raid.claimRewards(wallets[i]);\\n            _confetti.transferFrom(wallets[i], address(this), pendingRewards);\\n        }\\n\\n        uint256 tax = (claimedRewards * taxBasisPoints) / BP_PRECISION;\\n        uint256 fee = (claimedRewards * _feeBasisPoints) / BP_PRECISION;\\n        if (tax > 0) {\\n            _confetti.transfer(taxRecipient, tax);\\n        }\\n        _collectedFee += fee;\\n\\n        // Finally, send the claimed reward to the recipient\\n        _confetti.transfer(recipient, claimedRewards - tax - fee);\\n    }\\n\\n    /// @notice Bundles all of the tokens at the `recipient` address, optionally\\n    /// claiming any pending rewards.\\n    function bundleTokens(\\n        address[] calldata wallets,\\n        address recipient,\\n        bool alsoClaim\\n    ) public authorized(wallets) {\\n        if (alsoClaim) {\\n            uint256 claimedRewards = getPendingRewards(wallets);\\n            claimMultipleRewards(wallets);\\n\\n            uint256 fee = (claimedRewards * _feeBasisPoints) / BP_PRECISION;\\n            amortizedCollectFrom(wallets, address(this), fee);\\n            _collectedFee += fee;\\n        }\\n\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            if (wallets[i] != recipient) {\\n                uint256 amount = _confetti.balanceOf(wallets[i]);\\n                _confetti.transferFrom(wallets[i], recipient, amount);\\n            }\\n        }\\n    }\\n\\n    // To minimize the amount of ERC-20 token transfers (which are costly), we\\n    // use a greedy algorithm of sending as much as we can until we transfer\\n    // a total, specified amount.\\n    // NOTE: The caller must ensure that wallets are safe to transfer from by the\\n    // transaction sender.\\n    function amortizedCollectFrom(\\n        address[] calldata wallets,\\n        address recipient,\\n        uint256 amount\\n    ) private {\\n        uint256 collected = 0;\\n        for (uint256 i = 0; i < wallets.length && collected < amount; i++) {\\n            uint256 collectedNow = Math.min(\\n                _confetti.balanceOf(wallets[i]),\\n                amount - collected\\n            );\\n\\n            _confetti.transferFrom(wallets[i], recipient, collectedNow);\\n            collected += collectedNow;\\n        }\\n    }\\n\\n    /// @notice Returns whether given wallets authorized this contract to move at least\\n    /// their current pending rewards\\n    function isApproved(address[] calldata wallets)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            uint256 pendingRewards = _raid.getPendingRewards(wallets[i]);\\n            if (\\n                _confetti.allowance(wallets[i], address(this)) < pendingRewards\\n            ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /// @notice Convenient function that returns total pending rewards for given wallets\\n    function getPendingRewards(address[] calldata wallets)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 sum = 0;\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            sum += _raid.getPendingRewards(wallets[i]);\\n        }\\n        return sum;\\n    }\\n\\n    // Ensure that the transaction sender is authorized to move the funds\\n    // from these wallets\\n    modifier authorized(address[] calldata wallets) {\\n        require(\\n            isOperatorForWallets(_msgSender(), wallets),\\n            \\\"Not authorized to manage wallets\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @notice Returns whether the transaction sender can manage given wallets\\n    function isOperatorForWallets(address operator, address[] calldata wallets)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            if (!isOperatorFor(operator, wallets[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    // ERC-777-inspired operators.\\n    function isOperatorFor(address operator, address tokenHolder)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return operator == tokenHolder || _operators[tokenHolder][operator];\\n    }\\n\\n    /// @notice Authorize a given address to move funds in the name of the\\n    /// transaction sender.\\n    function authorizeOperator(address operator) public {\\n        require(_msgSender() != operator, \\\"authorizing self as operator\\\");\\n\\n        _operators[_msgSender()][operator] = true;\\n\\n        emit AuthorizedOperator(operator, _msgSender());\\n    }\\n\\n    /// @notice Revoke a given address to move funds in the name of the\\n    /// transaction sender.\\n    function revokeOperator(address operator) public {\\n        require(operator != _msgSender(), \\\"revoking self as operator\\\");\\n\\n        delete _operators[_msgSender()][operator];\\n\\n        emit RevokedOperator(operator, _msgSender());\\n    }\\n\\n    event AuthorizedOperator(\\n        address indexed operator,\\n        address indexed tokenHolder\\n    );\\n    event RevokedOperator(\\n        address indexed operator,\\n        address indexed tokenHolder\\n    );\\n}\\n\"\r\n    },\r\n    \"/contracts/IRaid.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IRaid {\\n    function claimRewards(address user) external;\\n\\n    function getPendingRewards(address user) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"confetti\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"raid\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BP_PRECISION\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_collectedFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_confetti\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_feeBasisPoints\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_raid\",\"outputs\":[{\"internalType\":\"contract IRaid\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"alsoClaim\",\"type\":\"bool\"}],\"name\":\"bundleTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"claimMultipleRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"claimMultipleRewardsTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"getPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"isApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"isOperatorForWallets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"amount\",\"type\":\"uint16\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"uint16\",\"name\":\"taxBasisPoints\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"taxRecipient\",\"type\":\"address\"}],\"name\":\"taxedClaimMultipleRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"taxBasisPoints\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"taxRecipient\",\"type\":\"address\"}],\"name\":\"taxedClaimMultipleRewardsTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RpYieldCollector", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000cfef8857e9c80e3440a823971420f7fa5f62f020000000000000000000000000fa209a705a4da0a240aa355c889ed0995154d7eb", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}