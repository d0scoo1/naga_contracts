{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"UniswapSwapRouter02ACL.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\ninterface IV3SwapRouter {\\n\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n}\\n\\n// for cobo safe module v0.3.0\\ncontract SwapRouter02AccessControl {\\n\\n    address public safeAddress;\\n    address public safeModule;\\n\\n    bytes32 private _checkedRole;\\n\\n    mapping(address => bool) _tokenWhitelist;\\n\\n    constructor(address _safeAddress, address _safeModule) {\\n        require(_safeAddress != address(0), \\\"invalid safe address\\\");\\n        require(_safeModule!= address(0), \\\"invalid module address\\\");\\n        safeAddress = _safeAddress;\\n        safeModule = _safeModule;\\n        // WETH\\n        _tokenWhitelist[0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2] = true;\\n        // BIT\\n        _tokenWhitelist[0x1A4b46696b2bB4794Eb3D4c26f1c55F9170fa4C5] = true;\\n    }\\n\\n    modifier onlySelf() {\\n        require(address(this) == msg.sender, \\\"Caller is not inner\\\");\\n        _;\\n    }\\n\\n    modifier onlyModule() {\\n        require(safeModule == msg.sender, \\\"Caller is not the module\\\");\\n        _;\\n    }\\n\\n    function check(bytes32 _role, bytes calldata data) external onlyModule returns (bool) {\\n        _checkedRole = _role;\\n        (bool success,) = address(this).staticcall(data);\\n        return success;\\n    }\\n\\n    fallback() external {}\\n\\n    // ACL methods\\n\\n    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to) external view onlySelf {\\n        require(path.length >= 2, \\\"Invalid Path\\\");\\n        require(_tokenWhitelist[path[0]], \\\"Token is not allowed\\\");\\n        require(_tokenWhitelist[path[path.length - 1]], \\\"Token is not allowed\\\");\\n        require(to == safeAddress, \\\"To address is not allowed\\\");\\n    }\\n            \\n\\n    function swapTokensForExactTokens(uint256 amountOut, uint256 amountInMax, address[] calldata path, address to) external view onlySelf {\\n        require(path.length >= 2, \\\"Invalid Path\\\");\\n        require(_tokenWhitelist[path[0]], \\\"Token is not allowed\\\");\\n        require(_tokenWhitelist[path[path.length - 1]], \\\"Token is not allowed\\\");\\n        require(to == safeAddress, \\\"To address is not allowed\\\");\\n    }\\n\\n    function exactInputSingle(IV3SwapRouter.ExactInputSingleParams calldata params) external view onlySelf {\\n        require(_tokenWhitelist[params.tokenIn], \\\"Token is not allowed\\\");\\n        require(_tokenWhitelist[params.tokenOut], \\\"Token is not allowed\\\");\\n        require(params.recipient == safeAddress, \\\"Recipient is not allowed\\\");\\n    }\\n\\n    function exactOutputSingle(IV3SwapRouter.ExactOutputSingleParams calldata params) external view onlySelf {\\n        require(_tokenWhitelist[params.tokenIn], \\\"Token is not allowed\\\");\\n        require(_tokenWhitelist[params.tokenOut], \\\"Token is not allowed\\\");\\n        require(params.recipient == safeAddress, \\\"Recipient is not allowed\\\");\\n    }\\n            \\n}\\n\\n// for cobo safe module v0.4.0\\ncontract SwapRouter02WithValueAccessControl {\\n\\n    address public safeAddress;\\n    address public safeModule;\\n\\n    bytes32 private _checkedRole;\\n    uint256 private _checkedValue;\\n\\n    mapping(address => bool) _tokenWhitelist;\\n\\n    constructor(address _safeAddress, address _safeModule) {\\n        require(_safeAddress != address(0), \\\"invalid safe address\\\");\\n        require(_safeModule!= address(0), \\\"invalid module address\\\");\\n        safeAddress = _safeAddress;\\n        safeModule = _safeModule;\\n        // WETH\\n        _tokenWhitelist[0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2] = true;\\n        // BIT\\n        _tokenWhitelist[0x1A4b46696b2bB4794Eb3D4c26f1c55F9170fa4C5] = true;\\n    }\\n\\n    modifier onlySelf() {\\n        require(address(this) == msg.sender, \\\"Caller is not inner\\\");\\n        _;\\n    }\\n\\n    modifier onlyModule() {\\n        require(safeModule == msg.sender, \\\"Caller is not the module\\\");\\n        _;\\n    }\\n\\n    function check(bytes32 _role, uint256 _value, bytes calldata data) external onlyModule returns (bool) {\\n        _checkedRole = _role;\\n        _checkedValue = _value;\\n        (bool success,) = address(this).staticcall(data);\\n        return success;\\n    }\\n\\n    fallback() external {\\n        revert(\\\"Unauthorized access\\\");\\n    }\\n\\n    // ACL methods\\n\\n    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to) external view onlySelf {\\n        require(_checkedValue == 0, \\\"Invalid value\\\");\\n        require(path.length >= 2, \\\"Invalid Path\\\");\\n        require(_tokenWhitelist[path[0]], \\\"Token is not allowed\\\");\\n        require(_tokenWhitelist[path[path.length - 1]], \\\"Token is not allowed\\\");\\n        require(to == safeAddress, \\\"To address is not allowed\\\");\\n    }\\n\\n\\n    function swapTokensForExactTokens(uint256 amountOut, uint256 amountInMax, address[] calldata path, address to) external view onlySelf {\\n        require(_checkedValue == 0, \\\"Invalid value\\\");\\n        require(path.length >= 2, \\\"Invalid Path\\\");\\n        require(_tokenWhitelist[path[0]], \\\"Token is not allowed\\\");\\n        require(_tokenWhitelist[path[path.length - 1]], \\\"Token is not allowed\\\");\\n        require(to == safeAddress, \\\"To address is not allowed\\\");\\n    }\\n\\n    function exactInputSingle(IV3SwapRouter.ExactInputSingleParams calldata params) external view onlySelf {\\n        require(_checkedValue == 0, \\\"Invalid value\\\");\\n        require(_tokenWhitelist[params.tokenIn], \\\"Token is not allowed\\\");\\n        require(_tokenWhitelist[params.tokenOut], \\\"Token is not allowed\\\");\\n        require(params.recipient == safeAddress, \\\"Recipient is not allowed\\\");\\n    }\\n\\n    function exactOutputSingle(IV3SwapRouter.ExactOutputSingleParams calldata params) external view onlySelf {\\n        require(_checkedValue == 0, \\\"Invalid value\\\");\\n        require(_tokenWhitelist[params.tokenIn], \\\"Token is not allowed\\\");\\n        require(_tokenWhitelist[params.tokenOut], \\\"Token is not allowed\\\");\\n        require(params.recipient == safeAddress, \\\"Recipient is not allowed\\\");\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"UniswapSwapRouter02ACL.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_safeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_safeModule\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct IV3SwapRouter.ExactInputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactInputSingle\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct IV3SwapRouter.ExactOutputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactOutputSingle\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SwapRouter02WithValueAccessControl", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000089ed30ba4dd03014f7ae7e3858c11bd937b63402000000000000000000000000f7833e7bdb859311d0a6e2e6c480f12bcb1ad419", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}