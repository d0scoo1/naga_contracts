{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Minters/BuyCharactersPhased.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\n/*\\r\\n\\r\\n\u2584\u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2593 \u2588\u2588\u2591 \u2588\u2588 \u2593\u2588\u2588\u2588\u2588\u2588     \u2588\u2588\u2591 \u2588\u2588 \u2593\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2593  \u2588\u2588\u2588\u2588\u2588\u2588 \u2584\u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2593\\r\\n\u2593  \u2588\u2588\u2592 \u2593\u2592\u2593\u2588\u2588\u2591 \u2588\u2588\u2592\u2593\u2588   \u2580    \u2593\u2588\u2588\u2591 \u2588\u2588\u2592\u2593\u2588   \u2580 \u2593\u2588\u2588\u2592\u2592\u2588\u2588    \u2592 \u2593  \u2588\u2588\u2592 \u2593\u2592\\r\\n\u2592 \u2593\u2588\u2588\u2591 \u2592\u2591\u2592\u2588\u2588\u2580\u2580\u2588\u2588\u2591\u2592\u2588\u2588\u2588      \u2592\u2588\u2588\u2580\u2580\u2588\u2588\u2591\u2592\u2588\u2588\u2588   \u2592\u2588\u2588\u2592\u2591 \u2593\u2588\u2588\u2584   \u2592 \u2593\u2588\u2588\u2591 \u2592\u2591\\r\\n\u2591 \u2593\u2588\u2588\u2593 \u2591 \u2591\u2593\u2588 \u2591\u2588\u2588 \u2592\u2593\u2588  \u2584    \u2591\u2593\u2588 \u2591\u2588\u2588 \u2592\u2593\u2588  \u2584 \u2591\u2588\u2588\u2591  \u2592   \u2588\u2588\u2592\u2591 \u2593\u2588\u2588\u2593 \u2591 \\r\\n  \u2592\u2588\u2588\u2592 \u2591 \u2591\u2593\u2588\u2592\u2591\u2588\u2588\u2593\u2591\u2592\u2588\u2588\u2588\u2588\u2592   \u2591\u2593\u2588\u2592\u2591\u2588\u2588\u2593\u2591\u2592\u2588\u2588\u2588\u2588\u2592\u2591\u2588\u2588\u2591\u2592\u2588\u2588\u2588\u2588\u2588\u2588\u2592\u2592  \u2592\u2588\u2588\u2592 \u2591 \\r\\n  \u2592 \u2591\u2591    \u2592 \u2591\u2591\u2592\u2591\u2592\u2591\u2591 \u2592\u2591 \u2591    \u2592 \u2591\u2591\u2592\u2591\u2592\u2591\u2591 \u2592\u2591 \u2591\u2591\u2593  \u2592 \u2592\u2593\u2592 \u2592 \u2591  \u2592 \u2591\u2591   \\r\\n    \u2591     \u2592 \u2591\u2592\u2591 \u2591 \u2591 \u2591  \u2591    \u2592 \u2591\u2592\u2591 \u2591 \u2591 \u2591  \u2591 \u2592 \u2591\u2591 \u2591\u2592  \u2591 \u2591    \u2591    \\r\\n  \u2591       \u2591  \u2591\u2591 \u2591   \u2591       \u2591  \u2591\u2591 \u2591   \u2591    \u2592 \u2591\u2591  \u2591  \u2591    \u2591      \\r\\n          \u2591  \u2591  \u2591   \u2591  \u2591    \u2591  \u2591  \u2591   \u2591  \u2591 \u2591        \u2591           \\r\\n                                                                \\r\\n*/\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\r\\n\\r\\nimport \\\"../Models/PaymentsShared.sol\\\";\\r\\nimport \\\"../Interfaces/I_TokenCharacter.sol\\\"; \\r\\n\\r\\ncontract BuyCharactersPhased is Ownable, PaymentsShared {\\r\\n\\r\\n    using ECDSA for bytes32;\\r\\n\\r\\n    //phases\\r\\n    enum PHASE{ PAUSED, ONE, TWO, PUBLIC }\\r\\n    PHASE public currentPhase = PHASE.PAUSED;\\r\\n\\r\\n    uint256 public constant MAX_MINTABLE = 10000;\\r\\n    uint256 public TOKEN_PRICE = 0.09 ether;\\r\\n\\r\\n    uint256 public P1_TOKENS_PER_MINT = 1;\\r\\n    uint256 public MINTS_PER_TRANSACTION = 5;\\r\\n\\r\\n    I_TokenCharacter tokenCharacter;\\r\\n    \\r\\n    //events\\r\\n    event SalePhaseChanged(uint256 newStage);\\r\\n\\r\\n    //Allowlist verification\\r\\n    address authority;\\r\\n    string salt = \\\"ALLOW_LIST_HEIST\\\";\\r\\n\\r\\n    mapping(address => uint8) public ALMints;\\r\\n\\r\\n    constructor(address _tokenCharacterAddress, address signer) {\\r\\n        tokenCharacter = I_TokenCharacter(_tokenCharacterAddress);\\r\\n        authority = signer;\\r\\n    }\\r\\n\\r\\n    function buy(uint8 amountToBuy, bytes memory signature) external payable {\\r\\n\\r\\n        require(amountToBuy > 0, \\\"Buy at least 1\\\");\\r\\n        require(msg.sender == tx.origin,\\\"EOA only\\\");\\r\\n\\r\\n        //check price and soft supply\\r\\n        require(msg.value >= TOKEN_PRICE * amountToBuy,\\\"Not enough ETH\\\");\\r\\n        require(tokenCharacter.totalSupply() + amountToBuy < MAX_MINTABLE + 1,\\\"Sold out\\\");\\r\\n\\r\\n        //phase 1: AL + wallet limit\\r\\n        if (currentPhase == PHASE.ONE)\\r\\n        {\\r\\n            require(verifySignature(signature, msg.sender), \\\"Wrong signature\\\");\\r\\n            require(ALMints[msg.sender] + amountToBuy < P1_TOKENS_PER_MINT + 1,\\\"Over AL allocation\\\");\\r\\n            ALMints[msg.sender] += amountToBuy;\\r\\n        }\\r\\n        //phase 2: AL + transaction limit\\r\\n        else if (currentPhase == PHASE.TWO)\\r\\n        {\\r\\n            require (amountToBuy < MINTS_PER_TRANSACTION + 1,\\\"Over max per transaction\\\");\\r\\n            require(verifySignature(signature, msg.sender), \\\"Wrong signature\\\");\\r\\n        }\\r\\n        //phase 3: public + transaction limit\\r\\n        else if (currentPhase == PHASE.PUBLIC)\\r\\n        {\\r\\n            require(amountToBuy < MINTS_PER_TRANSACTION + 1,\\\"Over max per transaction\\\");\\r\\n        }\\r\\n        else \\r\\n        {\\r\\n            revert(\\\"Sale is not live\\\");\\r\\n        }\\r\\n\\r\\n        //Do minting\\r\\n        tokenCharacter.Mint(amountToBuy, msg.sender);\\r\\n\\r\\n    }\\r\\n\\r\\n    function getPrice() external view returns (uint256) {\\r\\n      return TOKEN_PRICE;\\r\\n    }\\r\\n\\r\\n    //Variables\\r\\n    function setPrice(uint256 newPrice) external onlyOwner {\\r\\n      TOKEN_PRICE = newPrice;\\r\\n    }\\r\\n\\r\\n    function setPhase1Amount(uint256 newAmount) external onlyOwner {\\r\\n      P1_TOKENS_PER_MINT = newAmount;\\r\\n    }\\r\\n\\r\\n    function setTransactionLimit(uint256 newAmount) external onlyOwner {\\r\\n      MINTS_PER_TRANSACTION = newAmount;\\r\\n    }\\r\\n\\r\\n    //Allowlist minting\\r\\n    function verifySignature (bytes memory signature, address senderAddress)\\r\\n        internal view returns (bool)\\r\\n    {\\r\\n        //generate message, hash it, and compare signature\\r\\n        bytes memory message = abi.encodePacked(senderAddress,salt);\\r\\n        bytes32 messagehash = keccak256(message);\\r\\n        address signingAddress = messagehash.toEthSignedMessageHash().recover(signature);\\r\\n\\r\\n        return signingAddress == authority;\\r\\n    }\\r\\n\\r\\n    function setSalt(string memory newSalt) external onlyOwner {\\r\\n        salt = newSalt;\\r\\n    }\\r\\n\\r\\n    function setSigner(address newSigningAddress) external onlyOwner {\\r\\n        authority = newSigningAddress;\\r\\n    }\\r\\n\\r\\n    //Start phases and pause \\r\\n    function pauseSale() external onlyOwner {\\r\\n      currentPhase = PHASE.PAUSED;\\r\\n      emit SalePhaseChanged(uint256(currentPhase));\\r\\n    }\\r\\n\\r\\n    function getPhase() external view returns (uint256) {\\r\\n      return uint256(currentPhase);\\r\\n    }\\r\\n\\r\\n    function getWalletMints(address minter) external view returns (uint256) {\\r\\n      return ALMints[minter];\\r\\n    }\\r\\n\\r\\n    function startPhaseOne() external onlyOwner {\\r\\n      currentPhase = PHASE.ONE;\\r\\n      emit SalePhaseChanged(uint256(currentPhase));\\r\\n    }\\r\\n\\r\\n    function startPhaseTwo() external onlyOwner {\\r\\n      currentPhase = PHASE.TWO;\\r\\n      emit SalePhaseChanged(uint256(currentPhase));\\r\\n    }\\r\\n\\r\\n    function startPublicSale() external onlyOwner {\\r\\n      currentPhase = PHASE.PUBLIC;\\r\\n      emit SalePhaseChanged(uint256(currentPhase));\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Models/PaymentsShared.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\n//simple payments handling for splitting between fixed wallets\\r\\ncontract PaymentsShared is Ownable, ReentrancyGuard {\\r\\n\\r\\n    address WalletA = 0x0939D5c0DAb578ae7DA3cf11bfd4b7e5dc53CD45;\\r\\n    address WalletB = 0x670c38d686DA822bcc96c565ceE1DD7E007D1544;\\r\\n    address WalletC = 0x42D2339cA21C7D5df409326068c5CE5975dB5A39;\\r\\n    address WalletD = 0xBa643BE38D25867E2062890ee5D42aA6879F5586;\\r\\n\\r\\n    //payments\\r\\n    function withdrawAll() external nonReentrant onlyOwner {          \\r\\n\\r\\n        uint256 ticks = address(this).balance / 1000;\\r\\n\\r\\n        (bool success, ) = WalletA.call{value: ticks * 250}(\\\"\\\"); //25%\\r\\n        require(success, \\\"Transfer failed.\\\");\\r\\n\\r\\n        payable(WalletB).transfer(ticks * 100); //10%\\r\\n        payable(WalletC).transfer(ticks * 325); //32.5%\\r\\n        payable(WalletD).transfer(address(this).balance); //32.5%\\r\\n    }\\r\\n\\r\\n    function withdrawSafety() external onlyOwner {\\r\\n        payable(owner()).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/Interfaces/I_TokenCharacter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\n//Interface for characters NFT\\r\\ninterface I_TokenCharacter {\\r\\n\\r\\n    function Mint(uint8, address) external; //amount, to\\r\\n    \\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function setApprovalForAll(address, bool) external;  //address, operator\\r\\n    function transferFrom(address, address, uint256) external;\\r\\n    function ownerOf(uint256) external view returns (address); //who owns this token\\r\\n    function _ownerOf16(uint16) external view returns (address);\\r\\n\\r\\n    function addController(address) external;\\r\\n\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenCharacterAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStage\",\"type\":\"uint256\"}],\"name\":\"SalePhaseChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ALMints\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_MINTABLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINTS_PER_TRANSACTION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"P1_TOKENS_PER_MINT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"amountToBuy\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPhase\",\"outputs\":[{\"internalType\":\"enum BuyCharactersPhased.PHASE\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPhase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"getWalletMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"setPhase1Amount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newSalt\",\"type\":\"string\"}],\"name\":\"setSalt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSigningAddress\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"setTransactionLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startPhaseOne\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startPhaseTwo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startPublicSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawSafety\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BuyCharactersPhased", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000092a8ee8abf1e24791c68af6fc3ae9effbd8650080000000000000000000000003f53dc2eb1635e0f0fb3769b401aced21634a894", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}