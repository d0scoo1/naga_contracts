{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"LoveModule.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSE\\n\\n\\n/*\\n                              \\n    (%#(//(#      ,%(///#%,   \\n  %#,,,,,,,,*## #(,,,,,,,,.#( \\n (%////////////#//////////**% \\n /%///(((((Nahiko's(((((((//# \\n  %#(((((((((((((((((((((((## \u00d2\\n   #%##((((((((((((((((((##/  \\n     %%###((((((((((((###%    \\n       %%###((((((((##%%      \\n         %%%###((###%%        \\n           #%%%%%%%*          \\n             .%%%             \\n            \\n*/\\n\\n\\npragma solidity ^0.8.9;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\\n\\nimport './NiftyForge/INiftyForge721.sol';\\nimport './NiftyForge/Modules/NFBaseModule.sol';\\nimport './NiftyForge/Modules/INFModuleTokenURI.sol';\\nimport './NiftyForge/Modules/INFModuleWithRoyalties.sol';\\n\\n/// @title NahikosGameModule\\n/// @author Simon Fremaux (@dievardump) & Nahiko\\ncontract LoveModule is\\n    Ownable,\\n    NFBaseModule,\\n    INFModuleTokenURI,\\n    INFModuleWithRoyalties\\n{\\n    // this is because minting is secured with a Signature\\n    using Strings for uint256;\\n\\n    // link to the skin URI\\n    string public skinURI;\\n\\n    // link to the bones URI\\n    string public bonesURI;\\n\\n    // contract on which this module is made to mint\\n    address public nftContract;\\n\\n    // init the phase associated to the different phases (Skin, Flesh, Bones, Mind)\\n    uint _phase;\\n\\n    // variable to contain the local tokenId\\n    uint256 public tokenId;\\n\\n\\n    address public rendererAddress;\\n\\n    /// @notice constructor\\n    /// @param nftContract_ contract on which we mint\\n    /// @param rendererAddress_ contract containing the code to render the final phase\\n    constructor(\\n        address nftContract_,\\n        address rendererAddress_\\n    ) NFBaseModule(\\\"\\\") {\\n        nftContract = nftContract_;\\n        rendererAddress = rendererAddress_;\\n        _phase = 1;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(INFModuleWithRoyalties).interfaceId ||\\n            interfaceId == type(INFModuleTokenURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    function tokenURI(uint256 tokenId_)\\n        public\\n        view\\n        override\\n        returns (string memory)\\n    {\\n        return tokenURI(msg.sender, tokenId_);\\n    }\\n\\n    function tokenURI(address, uint256)\\n        public\\n        view\\n        override\\n        returns (string memory)\\n    {\\n        bytes memory uriString;\\n\\n        if(_phase == 3){\\n            string memory rendered = ICaller(rendererAddress).render(address(this));\\n            uriString = abi.encodePacked(\\\"data:application/json;utf8,{\\\\\\\"description\\\\\\\":\\\\\\\"\\\\xE2\\\\x9D\\\\xA4\\\\xEF\\\\xB8\\\\x8F\\\\\\\",\\\\\\\"name\\\\\\\":\\\\\\\"Anatomy Of Love\\\\\\\",\\\\\\\"attributes\\\\\\\":[{\\\\\\\"trait_type\\\\\\\":\\\\\\\"Phase\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"The Mind\\\\\\\"}],\\\\\\\"image\\\\\\\":\\\\\\\"data:image/svg+xml;base64,\\\",rendered,\\\"\\\\\\\"}\\\");\\n        }\\n\\n        else if(_phase == 2){\\n            uriString = abi.encodePacked(\\\"data:application/json;utf8,{\\\\\\\"description\\\\\\\":\\\\\\\"\\\\xE2\\\\x9D\\\\xA4\\\\xEF\\\\xB8\\\\x8F\\\\\\\",\\\\\\\"name\\\\\\\":\\\\\\\"Anatomy Of Love\\\\\\\",\\\\\\\"attributes\\\\\\\":[{\\\\\\\"trait_type\\\\\\\":\\\\\\\"Phase\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"The Bones\\\\\\\"}],\\\\\\\"animation_url\\\\\\\":\\\\\\\"\\\",bonesURI,\\\"\\\\\\\"}\\\");\\n        }\\n        \\n        else if(_phase == 1){\\n            uriString = abi.encodePacked(\\\"data:application/json;utf8,{\\\\\\\"description\\\\\\\":\\\\\\\"\\\\xE2\\\\x9D\\\\xA4\\\\xEF\\\\xB8\\\\x8F\\\\\\\",\\\\\\\"name\\\\\\\":\\\\\\\"Anatomy Of Love\\\\\\\",\\\\\\\"attributes\\\\\\\":[{\\\\\\\"trait_type\\\\\\\":\\\\\\\"Phase\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"The Skin\\\\\\\"}],\\\\\\\"image\\\\\\\":\\\\\\\"\\\",skinURI,\\\"\\\\\\\"}\\\");\\n        }\\n\\n        return string(uriString);\\n    }\\n\\n    function mint() external onlyOwner {\\n        require(tokenId == 0, \\\"AlreadyMinted\\\");\\n        // INiftyForge721.mint(address to, string memory uri, address feeRecipient, uint256 feeAmount, address transferTo ) external returns (uint256 tokenId);\\n        tokenId = INiftyForge721(nftContract).mint(owner(), '',  address(0), 0, address(0));\\n    }\\n\\n    /// @inheritdoc\\tINFModuleWithRoyalties\\n    function royaltyInfo(uint256 tokenId_)\\n        public\\n        view\\n        override\\n        returns (address, uint256)\\n    {\\n        return royaltyInfo(msg.sender, tokenId_);\\n    }\\n\\n    /// @inheritdoc    INFModuleWithRoyalties\\n    function royaltyInfo(address, uint256)\\n        public\\n        view\\n        override\\n        returns (address, uint256)\\n    {\\n        return (owner(), 500);\\n    }\\n\\n\\n\\n    /// @notice Setter for nfts contract\\n    /// @param nftContract_ the contract containing the registry\\n    function setNFTContract(address nftContract_) external onlyOwner {\\n        nftContract = nftContract_;\\n    }\\n\\n\\n    /// @notice Setter for the skin URI\\n    /// @param skinURI_ the parameter containing the link\\n    function setSkinURI(string memory skinURI_) external onlyOwner {\\n        skinURI = skinURI_;\\n    }\\n\\n    /// @notice Setter for the skin URI\\n    /// @param bonesURI_ the parameter containing the link\\n    function setbonesURI(string memory bonesURI_) external onlyOwner {\\n        bonesURI = bonesURI_;\\n    }\\n\\n    /// @notice Setter for the phase of Anatomy\\n    /// @param newPhase the new phase to be put on\\n    function setphase(uint8 newPhase) external onlyOwner{\\n        _phase = newPhase;\\n    }\\n\\n    event LoveDeclared(address indexed LoveSender, address indexed LoveReceiver);\\n\\n    function DeclareMyLove(address LoveReceiver) public {  \\n        emit LoveDeclared(msg.sender, LoveReceiver);\\n        //emit both the lovers's love\\n    }\\n\\n    /// @notice The function containing the painting of a heart on the NFT. The token is the canvas.\\n    function heart() public {\\n        require(false,\\\"nope\\\");\\n        assembly{\\n            sstore(69, 0xa00000a00000a00000ffffffffffffffffffa00000a00000a00000)\\n\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffff)\\n\\n            sstore(69, 0x0000ff0000ff0000ff0000a00000ffffffa00000ff0000ff0000ff0000a00000)\\n\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffff)\\n\\n            sstore(69, 0xa00000a00000a00000ffffffffffffffffffa00000a00000a00000)\\n\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffff) \\n            \\n            sstore(69, 0xa00000a00000a00000ffffffffffffffffffa00000a00000a00000)\\n\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffff) \\n            \\n            sstore(69, 0xa00000a00000a00000ffffffffffffffffffa00000a00000a00000) \\n\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffff000000ffffff) //first black dot of the heart black\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) \\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffff0000001111ff0000000fff) //second heart line black/red/black\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffff) \\n            \\n            sstore(69, 0xa00000a00000a00000ffffffffffffffffffa00000a00000a00000)\\n\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0x0000001110001111ff1111ff1111ff000000000abcffffffffffdfffffff) //third heart line black/red/red/red/black\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffff) \\n            sstore(69, 0xfffffff1100110000ff0000ff0000ff0000ff0000ff001100fffffffffff) //fourth heart line black/red/red/red/red/red/black\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffff) \\n            \\n            sstore(69, 0xa00000a00000a00000ffffffffffffffffffa00000a00000a00000)\\n\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffff)\\n            sstore(69, 0x1aa1100001100ff1100ff1100ff1100ff1100ff1100ff1111ff111111fff) //fifth line black/red/red/red/red/red/red/red/black\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0x1aa1100001100ff1100ff1100ff1100ff1100ff1100ff1111ff111111fff) //sixth line same as fifth\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffff) \\n            \\n            sstore(69, 0xa00000a00000a00000ffffffffffffffffffa00000a00000a00000)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffff)\\n            sstore(69, 0x1aa1100001100ff1100ff1100ff1100111100ff1100ff1111ff111111fff) //seventh line black/red/red/red/black/red/red/red/black\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xaFFFFFF110022110022110022FFFFFF110022110022111122FFFFFFfffff) //last line white/black/black/black/white/black/black/black/white\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffff) \\n            \\n            sstore(69, 0xa00000a00000a00000ffffffffffffffffffa00000a00000a00000)\\n\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffff) \\n            \\n            sstore(69, 0xa00000a00000a00000ffffffffffffffffffa00000a00000a00000)\\n\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffff) \\n            \\n            sstore(69, 0xa00000a00000a00000ffffffffffffffffffa00000a00000a00000)\\n\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            sstore(69, 0xffffffffffffffffffffffffffffffffffffff)\\n            \\n        }\\n    }\\n    \\n}\\n\\ninterface ICaller{\\n    function render(address addressToRender) external view returns(string memory);\\n}\\n\"\r\n    },\r\n    \"NiftyForge/Modules/INFModuleWithRoyalties.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport './INFModule.sol';\\n\\ninterface INFModuleWithRoyalties is INFModule {\\n    /// @notice Return royalties (recipient, basisPoint) for tokenId\\n    /// @dev Contrary to EIP2981, modules are expected to return basisPoint for second parameters\\n    ///      This in order to allow right royalties on marketplaces not supporting 2981 (like Rarible)\\n    /// @param tokenId token to check\\n    /// @return recipient and basisPoint for this tokenId\\n    function royaltyInfo(uint256 tokenId)\\n        external\\n        view\\n        returns (address recipient, uint256 basisPoint);\\n\\n    /// @notice Return royalties (recipient, basisPoint) for tokenId\\n    /// @dev Contrary to EIP2981, modules are expected to return basisPoint for second parameters\\n    ///      This in order to allow right royalties on marketplaces not supporting 2981 (like Rarible)\\n    /// @param registry registry to check id of\\n    /// @param tokenId token to check\\n    /// @return recipient and basisPoint for this tokenId </p>\\n    function royaltyInfo(address registry, uint256 tokenId)\\n        external\\n        view\\n        returns (address recipient, uint256 basisPoint);\\n}\"\r\n    },\r\n    \"NiftyForge/Modules/INFModuleTokenURI.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport './INFModule.sol';\\n\\ninterface INFModuleTokenURI is INFModule {\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    function tokenURI(address registry, uint256 tokenId)\\n        external\\n        view\\n        returns (string memory);\\n}\"\r\n    },\r\n    \"NiftyForge/Modules/NFBaseModule.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\\nimport './INFModule.sol';\\n\\n/// @title NFBaseModule\\n/// @author Simon Fremaux (@dievardump)\\ncontract NFBaseModule is INFModule, ERC165 {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    EnumerableSet.AddressSet internal _attached;\\n\\n    event NewContractURI(string contractURI);\\n\\n    string private _contractURI;\\n\\n    modifier onlyAttached(address registry) {\\n        require(_attached.contains(registry), '!NOT_ATTACHED!');\\n        _;\\n    }\\n\\n    constructor(string memory contractURI_) {\\n        _setContractURI(contractURI_);\\n    }\\n\\n    /// @inheritdoc\\tINFModule\\n    function contractURI() external view override returns (string memory) {\\n        return _contractURI;\\n    }\\n\\n    /// @inheritdoc\\tINFModule\\n    function onAttach() external override returns (bool) {\\n        if (_attached.add(msg.sender)) {\\n            return true;\\n        }\\n\\n        revert('!ALREADY_ATTACHED!');\\n    }\\n\\n    /// @notice this contract doesn't really care if it's enabled or not\\n    ///         since trying to mint on a contract where it's not enabled will fail\\n    /// @inheritdoc\\tINFModule\\n    function onEnable() external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    /// @inheritdoc\\tINFModule\\n    function onDisable() external override {}\\n\\n    function _setContractURI(string memory contractURI_) internal {\\n        _contractURI = contractURI_;\\n        emit NewContractURI(contractURI_);\\n    }\\n}\"\r\n    },\r\n    \"NiftyForge/INiftyForge721.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/// @title INiftyForge721\\n/// @author Simon Fremaux (@dievardump)\\ninterface INiftyForge721 {\\n    struct ModuleInit {\\n        address module;\\n        bool enabled;\\n        bool minter;\\n    }\\n\\n    /// @notice totalSupply access\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice helper to know if everyone can mint or only minters\\n    function isMintingOpenToAll() external view returns (bool);\\n\\n    /// @notice Toggle minting open to all state\\n    /// @param isOpen if the new state is open or not\\n    function setMintingOpenToAll(bool isOpen) external;\\n\\n    /// @notice Mint token to `to` with `uri`\\n    /// @param to address of recipient\\n    /// @param uri token metadata uri\\n    /// @param feeRecipient the recipient of royalties\\n    /// @param feeAmount the royalties amount. From 0 to 10000\\n    ///        where 10000 == 100.00%; 1000 == 10.00%; 250 == 2.50%\\n    /// @param transferTo the address to transfer the NFT to after mint\\n    ///        this is used when we want to mint the NFT to the creator address\\n    ///        before transferring it to a recipient\\n    /// @return tokenId the tokenId\\n    function mint(\\n        address to,\\n        string memory uri,\\n        address feeRecipient,\\n        uint256 feeAmount,\\n        address transferTo\\n    ) external returns (uint256 tokenId);\\n\\n    /// @notice Mint batch tokens to `to[i]` with `uri[i]`\\n    /// @param to array of address of recipients\\n    /// @param uris array of token metadata uris\\n    /// @param feeRecipients the recipients of royalties for each id\\n    /// @param feeAmounts the royalties amounts for each id. From 0 to 10000\\n    ///        where 10000 == 100.00%; 1000 == 10.00%; 250 == 2.50%\\n    /// @return tokenIds the tokenIds\\n    function mintBatch(\\n        address[] memory to,\\n        string[] memory uris,\\n        address[] memory feeRecipients,\\n        uint256[] memory feeAmounts\\n    ) external returns (uint256[] memory tokenIds);\\n\\n    /// @notice Mint `tokenId` to to` with `uri`\\n    ///         Because not all tokenIds have incremental ids\\n    ///         be careful with this function, it does not increment lastTokenId\\n    ///         and expects the minter to actually know what it is doing.\\n    ///         this also means, this function does not verify _maxTokenId\\n    /// @param to address of recipient\\n    /// @param uri token metadata uri\\n    /// @param tokenId token id wanted\\n    /// @param feeRecipient the recipient of royalties\\n    /// @param feeAmount the royalties amount. From 0 to 10000\\n    ///        where 10000 == 100.00%; 1000 == 10.00%; 250 == 2.50%\\n    /// @param transferTo the address to transfer the NFT to after mint\\n    ///        this is used when we want to mint the NFT to the creator address\\n    ///        before transferring it to a recipient\\n    /// @return tokenId the tokenId\\n    function mint(\\n        address to,\\n        string memory uri,\\n        uint256 tokenId_,\\n        address feeRecipient,\\n        uint256 feeAmount,\\n        address transferTo\\n    ) external returns (uint256 tokenId);\\n\\n    /// @notice Mint batch tokens to `to[i]` with `uris[i]`\\n    ///         Because not all tokenIds have incremental ids\\n    ///         be careful with this function, it does not increment lastTokenId\\n    ///         and expects the minter to actually know what it's doing.\\n    ///         this also means, this function does not verify _maxTokenId\\n    /// @param to array of address of recipients\\n    /// @param uris array of token metadata uris\\n    /// @param tokenIds array of token ids wanted\\n    /// @param feeRecipients the recipients of royalties for each id\\n    /// @param feeAmounts the royalties amounts for each id. From 0 to 10000\\n    ///        where 10000 == 100.00%; 1000 == 10.00%; 250 == 2.50%\\n    /// @return tokenIds the tokenIds\\n    function mintBatch(\\n        address[] memory to,\\n        string[] memory uris,\\n        uint256[] memory tokenIds,\\n        address[] memory feeRecipients,\\n        uint256[] memory feeAmounts\\n    ) external returns (uint256[] memory);\\n\\n    /// @notice Attach a module\\n    /// @param module a module to attach\\n    /// @param enabled if the module is enabled by default\\n    /// @param canModuleMint if the module has to be given the minter role\\n    function attachModule(\\n        address module,\\n        bool enabled,\\n        bool canModuleMint\\n    ) external;\\n\\n    /// @dev Allows owner to enable a module\\n    /// @param module to enable\\n    /// @param canModuleMint if the module has to be given the minter role\\n    function enableModule(address module, bool canModuleMint) external;\\n\\n    /// @dev Allows owner to disable a module\\n    /// @param module to disable\\n    function disableModule(address module, bool keepListeners) external;\\n\\n    /// @notice function that returns a string that can be used to render the current token\\n    /// @param tokenId tokenId\\n    /// @return the URI to render token\\n    function renderTokenURI(uint256 tokenId)\\n        external\\n        view\\n        returns (string memory);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"NiftyForge/Modules/INFModule.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/introspection/IERC165.sol';\\n\\ninterface INFModule is IERC165 {\\n    /// @notice Called by a Token Registry whenever the module is Attached\\n    /// @return if the attach worked\\n    function onAttach() external returns (bool);\\n\\n    /// @notice Called by a Token Registry whenever the module is Enabled\\n    /// @return if the enabling worked\\n    function onEnable() external returns (bool);\\n\\n    /// @notice Called by a Token Registry whenever the module is Disabled\\n    function onDisable() external;\\n\\n    /// @notice returns an URI with information about the module\\n    /// @return the URI where to find information about the module\\n    function contractURI() external view returns (string memory);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rendererAddress_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"LoveSender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"LoveReceiver\",\"type\":\"address\"}],\"name\":\"LoveDeclared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"}],\"name\":\"NewContractURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"LoveReceiver\",\"type\":\"address\"}],\"name\":\"DeclareMyLove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonesURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"heart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onAttach\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onDisable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rendererAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract_\",\"type\":\"address\"}],\"name\":\"setNFTContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"skinURI_\",\"type\":\"string\"}],\"name\":\"setSkinURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"bonesURI_\",\"type\":\"string\"}],\"name\":\"setbonesURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newPhase\",\"type\":\"uint8\"}],\"name\":\"setphase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"skinURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LoveModule", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ab088f80f425ceafdb950c1b5d50f8d59382377800000000000000000000000017dbcb356318b08783ac5837690bb91939b107dd", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}