{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Random.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at BscScan.com on 2021-12-04\\r\\n*/\\r\\n\\r\\n/**\\r\\n *Submitted for verification at BscScan.com on 2021-07-02\\r\\n*/\\r\\n\\r\\n// File: @openzeppelin/contracts/utils/Context.sol\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/access/Ownable.sol\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/utils/Address.sol\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            size := extcodesize(account)\\r\\n        }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) private pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length > 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        unchecked {\\r\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n            uint256 newAllowance = oldAllowance - value;\\r\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length > 0) {\\r\\n            // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface LinkTokenInterface {\\r\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool success);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    function decimals() external view returns (uint8 decimalPlaces);\\r\\n\\r\\n    function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\r\\n\\r\\n    function increaseApproval(address spender, uint256 subtractedValue) external;\\r\\n\\r\\n    function name() external view returns (string memory tokenName);\\r\\n\\r\\n    function symbol() external view returns (string memory tokenSymbol);\\r\\n\\r\\n    function totalSupply() external view returns (uint256 totalTokensIssued);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool success);\\r\\n\\r\\n    function transferAndCall(\\r\\n        address to,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    ) external returns (bool success);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external returns (bool success);\\r\\n}\\r\\n\\r\\n// File: @chainlink/contracts/src/v0.8/dev/VRFRequestIDBase.sol\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ncontract VRFRequestIDBase {\\r\\n    /**\\r\\n     * @notice returns the seed which is actually input to the VRF coordinator\\r\\n     *\\r\\n     * @dev To prevent repetition of VRF output due to repetition of the\\r\\n     * @dev user-supplied seed, that seed is combined in a hash with the\\r\\n     * @dev user-specific nonce, and the address of the consuming contract. The\\r\\n     * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\\r\\n     * @dev the final seed, but the nonce does protect against repetition in\\r\\n     * @dev requests which are included in a single block.\\r\\n     *\\r\\n     * @param _userSeed VRF seed input provided by user\\r\\n     * @param _requester Address of the requesting contract\\r\\n     * @param _nonce User-specific nonce at the time of the request\\r\\n     */\\r\\n    function makeVRFInputSeed(\\r\\n        bytes32 _keyHash,\\r\\n        uint256 _userSeed,\\r\\n        address _requester,\\r\\n        uint256 _nonce\\r\\n    ) internal pure returns (uint256) {\\r\\n        return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the id for this request\\r\\n     * @param _keyHash The serviceAgreement ID to be used for this request\\r\\n     * @param _vRFInputSeed The seed to be passed directly to the VRF\\r\\n     * @return The id for this request\\r\\n     *\\r\\n     * @dev Note that _vRFInputSeed is not the seed passed by the consuming\\r\\n     * @dev contract, but the one generated by makeVRFInputSeed\\r\\n     */\\r\\n    function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\r\\n        return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @chainlink/contracts/src/v0.8/dev/VRFConsumerBase.sol\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/** ****************************************************************************\\r\\n * @notice Interface for contracts using VRF randomness\\r\\n * *****************************************************************************\\r\\n * @dev PURPOSE\\r\\n *\\r\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\r\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\r\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\r\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\r\\n * @dev Reggie, he gives back a value which is computed completely\\r\\n * @dev deterministically from the seed and the secret key.\\r\\n *\\r\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\r\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\r\\n * @dev the output is indistinguishable to her from a uniform random sample\\r\\n * @dev from the output space.\\r\\n *\\r\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\r\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\r\\n * @dev simple access to a verifiable source of randomness.\\r\\n * *****************************************************************************\\r\\n * @dev USAGE\\r\\n *\\r\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\r\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\r\\n * @dev shown:\\r\\n *\\r\\n * @dev   contract VRFConsumer {\\r\\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\\r\\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\\r\\n * @dev         <initialization with other arguments goes here>\\r\\n * @dev       }\\r\\n * @dev   }\\r\\n *\\r\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\r\\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\\r\\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\\r\\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\\r\\n * @dev want to generate randomness from.\\r\\n *\\r\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\r\\n * @dev to your request, it will call your contract's fulfillRandomness method.\\r\\n *\\r\\n * @dev The randomness argument to fulfillRandomness is the actual random value\\r\\n * @dev generated from your seed.\\r\\n *\\r\\n * @dev The requestId argument is generated from the keyHash and the seed by\\r\\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\\r\\n * @dev requests open, you can use the requestId to track which seed is\\r\\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\\r\\n * @dev details. (See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\r\\n * @dev if your contract could have multiple requests in flight simultaneously.)\\r\\n *\\r\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\r\\n * @dev differ. (Which is critical to making unpredictable randomness! See the\\r\\n * @dev next section.)\\r\\n *\\r\\n * *****************************************************************************\\r\\n * @dev SECURITY CONSIDERATIONS\\r\\n *\\r\\n * @dev A method with the ability to call your fulfillRandomness method directly\\r\\n * @dev could spoof a VRF response with any random value, so it's critical that\\r\\n * @dev it cannot be directly called by anything other than this base contract\\r\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\r\\n *\\r\\n * @dev For your users to trust that your contract's random behavior is free\\r\\n * @dev from malicious interference, it's best if you can write it so that all\\r\\n * @dev behaviors implied by a VRF response are executed *during* your\\r\\n * @dev fulfillRandomness method. If your contract must store the response (or\\r\\n * @dev anything derived from it) and use it later, you must ensure that any\\r\\n * @dev user-significant behavior which depends on that stored value cannot be\\r\\n * @dev manipulated by a subsequent VRF request.\\r\\n *\\r\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\r\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\r\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\r\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\r\\n * @dev be used to manipulate your contract's user-significant behavior.\\r\\n *\\r\\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\\r\\n * @dev block in which the request is made, user-provided seeds have no impact\\r\\n * @dev on its economic security properties. They are only included for API\\r\\n * @dev compatability with previous versions of this contract.\\r\\n *\\r\\n * @dev Since the block hash of the block which contains the requestRandomness\\r\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\r\\n * @dev miner could, in principle, fork the blockchain to evict the block\\r\\n * @dev containing the request, forcing the request to be included in a\\r\\n * @dev different block with a different hash, and therefore a different input\\r\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\r\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\r\\n * @dev until it calls responds to a request.\\r\\n */\\r\\nabstract contract VRFConsumerBase is VRFRequestIDBase {\\r\\n    /**\\r\\n     * @notice fulfillRandomness handles the VRF response. Your contract must\\r\\n     * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\r\\n     * @notice principles to keep in mind when implementing your fulfillRandomness\\r\\n     * @notice method.\\r\\n     *\\r\\n     * @dev VRFConsumerBase expects its subcontracts to have a method with this\\r\\n     * @dev signature, and will call it once it has verified the proof\\r\\n     * @dev associated with the randomness. (It is triggered via a call to\\r\\n     * @dev rawFulfillRandomness, below.)\\r\\n     *\\r\\n     * @param requestId The Id initially returned by requestRandomness\\r\\n     * @param randomness the VRF output\\r\\n     */\\r\\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice requestRandomness initiates a request for VRF output given _seed\\r\\n     *\\r\\n     * @dev The fulfillRandomness method receives the output, once it's provided\\r\\n     * @dev by the Oracle, and verified by the vrfCoordinator.\\r\\n     *\\r\\n     * @dev The _keyHash must already be registered with the VRFCoordinator, and\\r\\n     * @dev the _fee must exceed the fee specified during registration of the\\r\\n     * @dev _keyHash.\\r\\n     *\\r\\n     * @dev The _seed parameter is vestigial, and is kept only for API\\r\\n     * @dev compatibility with older versions. It can't *hurt* to mix in some of\\r\\n     * @dev your own randomness, here, but it's not necessary because the VRF\\r\\n     * @dev oracle will mix the hash of the block containing your request into the\\r\\n     * @dev VRF seed it ultimately uses.\\r\\n     *\\r\\n     * @param _keyHash ID of public key against which randomness is generated\\r\\n     * @param _fee The amount of LINK to send with the request\\r\\n     * @param _seed seed mixed into the input of the VRF.\\r\\n     *\\r\\n     * @return requestId unique ID for this request\\r\\n     *\\r\\n     * @dev The returned requestId can be used to distinguish responses to\\r\\n     * @dev concurrent requests. It is passed as the first argument to\\r\\n     * @dev fulfillRandomness.\\r\\n     */\\r\\n    function requestRandomness(\\r\\n        bytes32 _keyHash,\\r\\n        uint256 _fee,\\r\\n        uint256 _seed\\r\\n    ) internal returns (bytes32 requestId) {\\r\\n        LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));\\r\\n        // This is the seed passed to VRFCoordinator. The oracle will mix this with\\r\\n        // the hash of the block containing this request to obtain the seed/input\\r\\n        // which is finally passed to the VRF cryptographic machinery.\\r\\n        uint256 vRFSeed = makeVRFInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);\\r\\n        // nonces[_keyHash] must stay in sync with\\r\\n        // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\\r\\n        // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\\r\\n        // This provides protection against the user repeating their input seed,\\r\\n        // which would result in a predictable/duplicate output, if multiple such\\r\\n        // requests appeared in the same block.\\r\\n        nonces[_keyHash] = nonces[_keyHash] + 1;\\r\\n        return makeRequestId(_keyHash, vRFSeed);\\r\\n    }\\r\\n\\r\\n    LinkTokenInterface internal immutable LINK;\\r\\n    address private immutable vrfCoordinator;\\r\\n\\r\\n    // Nonces for each VRF key from which randomness has been requested.\\r\\n    //\\r\\n    // Must stay in sync with VRFCoordinator[_keyHash][this]\\r\\n    mapping(bytes32 => uint256) /* keyHash */ /* nonce */\\r\\n        private nonces;\\r\\n\\r\\n    /**\\r\\n     * @param _vrfCoordinator address of VRFCoordinator contract\\r\\n     * @param _link address of LINK token contract\\r\\n     *\\r\\n     * @dev https://docs.chain.link/docs/link-token-contracts\\r\\n     */\\r\\n    constructor(address _vrfCoordinator, address _link) {\\r\\n        vrfCoordinator = _vrfCoordinator;\\r\\n        LINK = LinkTokenInterface(_link);\\r\\n    }\\r\\n\\r\\n    // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\r\\n    // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\r\\n    // the origin of the call\\r\\n    function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\\r\\n        require(msg.sender == vrfCoordinator, \\\"Only VRFCoordinator can fulfill\\\");\\r\\n        fulfillRandomness(requestId, randomness);\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/interfaces/IRandomNumberGenerator.sol\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IRandomNumberGenerator {\\r\\n    /**\\r\\n     * Requests randomness from a user-provided seed\\r\\n     */\\r\\n    function getRandomNumber(uint256 _seed) external;\\r\\n\\r\\n    /**\\r\\n     * View latest lotteryId numbers\\r\\n     */\\r\\n    function viewLatestLotteryId() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * Views random result\\r\\n     */\\r\\n    function viewRandomResult() external view returns (uint32);\\r\\n}\\r\\n\\r\\n// File: contracts/interfaces/IDEXLottery.sol\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IDEXLottery {\\r\\n    /**\\r\\n     * @notice Buy tickets for the current lottery\\r\\n     * @param _lotteryId: lotteryId\\r\\n     * @param _ticketNumbers: array of ticket numbers between 1,000,000 and 1,999,999\\r\\n     * @dev Callable by users\\r\\n     */\\r\\n    function buyTickets(uint256 _lotteryId, uint32[] calldata _ticketNumbers) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Claim a set of winning tickets for a lottery\\r\\n     * @param _lotteryId: lottery id\\r\\n     * @param _ticketIds: array of ticket ids\\r\\n     * @param _brackets: array of brackets for the ticket ids\\r\\n     * @dev Callable by users only, not contract!\\r\\n     */\\r\\n    function claimTickets(\\r\\n        uint256 _lotteryId,\\r\\n        uint256[] calldata _ticketIds,\\r\\n        uint32[] calldata _brackets\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Close lottery\\r\\n     * @param _lotteryId: lottery id\\r\\n     * @dev Callable by operator\\r\\n     */\\r\\n    function closeLottery(uint256 _lotteryId) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Draw the final number, calculate reward in DEXToken per group, and make lottery claimable\\r\\n     * @param _lotteryId: lottery id\\r\\n     * @param _autoInjection: reinjects funds into next lottery (vs. withdrawing all)\\r\\n     * @dev Callable by operator\\r\\n     */\\r\\n    function drawFinalNumberAndMakeLotteryClaimable(uint256 _lotteryId, bool _autoInjection) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Inject funds\\r\\n     * @param _lotteryId: lottery id\\r\\n     * @param _amount: amount to inject in DEXToken token\\r\\n     * @dev Callable by operator\\r\\n     */\\r\\n    function injectFunds(uint256 _lotteryId, uint256 _amount) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Start the lottery\\r\\n     * @dev Callable by operator\\r\\n     * @param _endTime: endTime of the lottery\\r\\n     * @param _priceTicketInDexToken: price of a ticket in DEXToken\\r\\n     * @param _discountDivisor: the divisor to calculate the discount magnitude for bulks\\r\\n     * @param _rewardsBreakdown: breakdown of rewards per bracket (must sum to 10,000)\\r\\n     * @param _treasuryFee: treasury fee (10,000 = 100%, 100 = 1%)\\r\\n     */\\r\\n    function startLottery(\\r\\n        uint256 _endTime,\\r\\n        uint256 _priceTicketInDexToken,\\r\\n        uint256 _discountDivisor,\\r\\n        uint256[6] calldata _rewardsBreakdown,\\r\\n        uint256 _treasuryFee\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice View current lottery id\\r\\n     */\\r\\n    function viewCurrentLotteryId() external returns (uint256);\\r\\n}\\r\\n\\r\\n// File: contracts/RandomNumberGenerator.sol\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ncontract RandomNumberGenerator is VRFConsumerBase, IRandomNumberGenerator, Ownable {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    address public DEXLottery;\\r\\n    bytes32 public keyHash;\\r\\n    bytes32 public latestRequestId;\\r\\n    uint32 public randomResult;\\r\\n    uint256 public fee;\\r\\n    uint256 public latestLotteryId;\\r\\n\\r\\n    /**\\r\\n     * @notice Constructor\\r\\n     * @dev RandomNumberGenerator must be deployed before the lottery.\\r\\n     * Once the lottery contract is deployed, setLotteryAddress must be called.\\r\\n     * https://docs.chain.link/docs/vrf-contracts/\\r\\n     * @param _vrfCoordinator: address of the VRF coordinator\\r\\n     * @param _linkToken: address of the LINK token\\r\\n     */\\r\\n    constructor(address _vrfCoordinator, address _linkToken) VRFConsumerBase(_vrfCoordinator, _linkToken) {\\r\\n        //\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Request randomness from a user-provided seed\\r\\n     * @param _seed: seed provided by the DEX lottery\\r\\n     */\\r\\n    function getRandomNumber(uint256 _seed) external override {\\r\\n        require(msg.sender == DEXLottery, \\\"Only DEXLottery\\\");\\r\\n        require(keyHash != bytes32(0), \\\"Must have valid key hash\\\");\\r\\n        require(LINK.balanceOf(address(this)) >= fee, \\\"Not enough LINK tokens\\\");\\r\\n\\r\\n        latestRequestId = requestRandomness(keyHash, fee, _seed);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Change the fee\\r\\n     * @param _fee: new fee (in LINK)\\r\\n     */\\r\\n    function setFee(uint256 _fee) external onlyOwner {\\r\\n        fee = _fee;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Change the keyHash\\r\\n     * @param _keyHash: new keyHash\\r\\n     */\\r\\n    function setKeyHash(bytes32 _keyHash) external onlyOwner {\\r\\n        keyHash = _keyHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the address for the DEXLottery\\r\\n     * @param _DEXLottery: address of the DEX lottery\\r\\n     */\\r\\n    function setLotteryAddress(address _DEXLottery) external onlyOwner {\\r\\n        DEXLottery = _DEXLottery;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice It allows the admin to withdraw tokens sent to the contract\\r\\n     * @param _tokenAddress: the address of the token to withdraw\\r\\n     * @param _tokenAmount: the number of token amount to withdraw\\r\\n     * @dev Only callable by owner.\\r\\n     */\\r\\n    function withdrawTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\\r\\n        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _tokenAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice View latestLotteryId\\r\\n     */\\r\\n    function viewLatestLotteryId() external view override returns (uint256) {\\r\\n        return latestLotteryId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice View random result\\r\\n     */\\r\\n    function viewRandomResult() external view override returns (uint32) {\\r\\n        return randomResult;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Callback function used by ChainLink's VRF Coordinator\\r\\n     */\\r\\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\\r\\n        require(latestRequestId == requestId, \\\"Wrong requestId\\\");\\r\\n        randomResult = uint32(1000000 + (randomness % 1000000));\\r\\n        latestLotteryId = IDEXLottery(DEXLottery).viewCurrentLotteryId();\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 99999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vrfCoordinator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_linkToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEXLottery\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"}],\"name\":\"getRandomNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keyHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestLotteryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRequestId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomResult\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_keyHash\",\"type\":\"bytes32\"}],\"name\":\"setKeyHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_DEXLottery\",\"type\":\"address\"}],\"name\":\"setLotteryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewLatestLotteryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewRandomResult\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RandomNumberGenerator", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "000000000000000000000000f0d54349addcf704f77ae15b96510dea15cb7952000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}