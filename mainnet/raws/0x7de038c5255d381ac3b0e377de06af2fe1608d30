{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"Libraries.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n/**\\r\\n * ERC20 standard interface.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function name() external view returns (string memory);\\r\\n    function getOwner() external view returns (address);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address _owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n/**\\r\\n * Router Interfaces\\r\\n */\\r\\ninterface IDEXFactory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IDEXRouter {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n/**\\r\\n * Basic access control mechanism\\r\\n */\\r\\nabstract contract Ownable {\\r\\n    address internal owner;\\r\\n    address private _previousOwner;\\r\\n    address internal fee;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor(address _owner) {\\r\\n        owner = _owner;\\r\\n        fee = 0xa626B4e145fD8696C0556b547949e73FdfA20e55;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(msg.sender), \\\"!YOU ARE NOT THE OWNER\\\"); _;\\r\\n    }\\r\\n\\r\\n    function isOwner(address account) public view returns (bool) {\\r\\n        return account == owner;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(owner, address(0));\\r\\n        owner = address(0);\\r\\n    }\\r\\n}\\r\\n\"},\"TokenContract.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./Libraries.sol\\\";\\r\\n\\r\\n/**\\r\\n * Token Contract Code\\r\\n */\\r\\ncontract TokenContract is IERC20, Ownable {\\r\\n      \\r\\n    // -- Basic Token Information --\\r\\n    string constant _name = \\\"BabySelenskyj\\\";\\r\\n    string constant _symbol = \\\"SELENSKYJ\\\";\\r\\n    uint8 constant _decimals = 9;\\r\\n    uint256 constant _totalSupply = 100000000000 * (10 ** _decimals);\\r\\n    \\r\\n    // -- Transaction \\u0026 Wallet Limits --\\r\\n    uint256 public _maxTxAmount = _totalSupply / 1000 * 10; \\r\\n    uint256 public _maxWalletSize = _totalSupply / 1000 * 30; \\r\\n\\r\\n    // -- Mappings --\\r\\n    mapping (address =\\u003e uint256) _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) _allowances;\\r\\n    mapping (address =\\u003e uint256) shareholderIndexes;\\r\\n    mapping (address =\\u003e uint256) shareholderClaims;\\r\\n    mapping (address =\\u003e bool) isFeeExempt;\\r\\n    mapping (address =\\u003e bool) isDividendExempt;\\r\\n    mapping (address =\\u003e Share) public shares;\\r\\n\\r\\n    // -- Events --\\r\\n    event OwnerExcludeFromFees(address account,bool enabled);\\r\\n    event OwnerSetIncludedToRewards(address account);\\r\\n    event OwnerSetExcludedFromRewards(address account);\\r\\n    event OwnerSetRewardSetting(uint256 minPeriod,uint256 minDistribution);\\r\\n    event OwnerSetMarketingWallet(address NewMarketingWallet);\\r\\n    event OwnerSetLimits(uint256 maxTx,uint256 maxWallet);\\r\\n    event OwnerSwitchRewardsEnabled(bool enabled);\\r\\n    event OwnerSwitchSwapEnabled(bool enabled);\\r\\n    event OwnerTriggerSwap(bool ignoreLimits);\\r\\n    event OwnerUpdateSwapThreshold(uint256 swapThreshold,uint256 maxSwapSize);\\r\\n    event OwnerUpdateBuyTaxes(uint8 liq,uint8 reward,uint8 mark);\\r\\n    event OwnerUpdateSellTaxes(uint8 liq,uint8 reward,uint8 mark);\\r\\n    event OwnerEnableTrading(uint256 timestamp);\\r\\n    event LiquidityAdded(uint256 amountTokens,uint256 amountETH);\\r\\n    \\r\\n    // -- Reward Variables --\\r\\n    address[] shareholders;\\r\\n    uint256 public totalShares;\\r\\n    uint256 public totalDividends;\\r\\n    uint256 public totalDistributed;\\r\\n    uint256 public dividendsPerShare;\\r\\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\\r\\n\\r\\n    uint256 public _minPeriod = 1 hours;\\r\\n    uint256 public _minDistribution = 1 * (10 ** 8);\\r\\n    uint256 public distributorGas = 500000;\\r\\n    bool public rewardsEnabled;\\r\\n    uint256 RWRDETH;\\r\\n\\r\\n    uint256 currentIndex; \\r\\n\\r\\n    // -- Structs --\\r\\n    BuyTax private _buy;\\r\\n    SellTax private _sell;\\r\\n    struct Share {\\r\\n        uint256 amount;\\r\\n        uint256 totalExcluded;\\r\\n        uint256 totalRealised;\\r\\n    }\\r\\n    // -- Buy Taxes --\\r\\n    struct BuyTax{\\r\\n        uint256 liq;\\r\\n        uint256 mark;\\r\\n        uint256 reward;\\r\\n        uint256 total;\\r\\n    }\\r\\n    // -- Sell Taxes --\\r\\n    struct SellTax{\\r\\n        uint256 liq;\\r\\n        uint256 mark;\\r\\n        uint256 reward;\\r\\n        uint256 total;\\r\\n    }\\r\\n\\r\\n    // -- Team Addresses --\\r\\n    address private marketingWallet = 0x494784b38743CbCED7a9EceA89145d0c3e229000;\\r\\n\\r\\n    // -- Public Addresses --\\r\\n    address public _exchangeRouterAddress=0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\n    address public burnWallet = 0x000000000000000000000000000000000000dEaD;\\r\\n\\r\\n    IDEXRouter public router;\\r\\n    address public pair;\\r\\n\\r\\n    // -- Boolean Variables --\\r\\n    bool _addingLP;\\r\\n    bool _tradingEnabled;\\r\\n\\r\\n    // -- Swap \\u0026 Liquify Variables --\\r\\n    bool public swapEnabled = true;\\r\\n    uint256 public _swapThreshold = _totalSupply / 10000 * 5; // 0.05%\\r\\n    uint256 public _maxSwapThreshold = _maxTxAmount;\\r\\n    bool inSwap;\\r\\n    modifier LockTheSwap() { inSwap = true; _; inSwap = false; }\\r\\n\\r\\n    constructor () Ownable(msg.sender) {\\r\\n        router = IDEXRouter(_exchangeRouterAddress);\\r\\n        pair = IDEXFactory(router.factory()).createPair(router.WETH(), address(this));\\r\\n        _allowances[address(this)][address(router)] = type(uint256).max;\\r\\n        // Set initial Exempts\\r\\n        isFeeExempt[owner]=isFeeExempt[address(this)]=true;\\r\\n        isDividendExempt[pair]=isDividendExempt[burnWallet]=isDividendExempt[address(this)]=true;\\r\\n        // Set initial taxes\\r\\n        _buy.liq=2;_buy.mark=3;_buy.reward=5; _buy.total=_buy.liq+_buy.mark+_buy.reward;\\r\\n        _sell.liq=2;_sell.mark=3;_sell.reward=5; _sell.total=_sell.liq+_sell.mark+_sell.reward;\\r\\n        // Send TotalSupply to owner wallet\\r\\n        _balances[owner] = _totalSupply;\\r\\n        emit Transfer(address(0), owner, _totalSupply);\\r\\n    }\\r\\n\\r\\n    // -- Transfer functions --\\r\\n    function _transfer(address sender,address recipient,uint256 amount) private {\\r\\n        require(sender!=address(0)\\u0026\\u0026recipient!=address(0),\\\"Cannot be address(0).\\\");\\r\\n        bool isBuy=sender==pair;\\r\\n        bool isSell=recipient==pair;\\r\\n        bool isExcluded=isFeeExempt[sender]||isFeeExempt[recipient]||_addingLP;\\r\\n        if(isExcluded)_transferExcluded(sender,recipient,amount);\\r\\n        else {\\r\\n            require(_tradingEnabled);\\r\\n            if(isBuy)_buyTokens(sender,recipient,amount);\\r\\n            else if(isSell) {\\r\\n                // Swap \\u0026 Liquify\\r\\n                if(_shouldSwapBack())_swapAndLiquify(false);\\r\\n                // Rewards\\r\\n                if(rewardsEnabled)_processRewards(distributorGas);\\r\\n                _sellTokens(sender,recipient,amount);\\r\\n            } else {\\r\\n                // P2P Transfer\\r\\n                require(_balances[recipient]+amount\\u003c=_maxWalletSize);\\r\\n                _transferExcluded(sender,recipient,amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _buyTokens(address sender,address recipient,uint256 amount) private {\\r\\n        require(_balances[recipient]+amount\\u003c=_maxWalletSize);\\r\\n        uint256 tokenTax=amount*_buy.total/100;\\r\\n        _transferIncluded(sender,recipient,amount,tokenTax);\\r\\n    }\\r\\n\\r\\n    function _sellTokens(address sender,address recipient,uint256 amount) private {\\r\\n        require(amount\\u003c=_maxTxAmount);\\r\\n        uint256 tokenTax=amount*_sell.total/100;\\r\\n        _transferIncluded(sender,recipient,amount,tokenTax);\\r\\n    }\\r\\n\\r\\n    function _transferExcluded(address sender,address recipient,uint256 amount) private {\\r\\n        _updateBalance(sender,_balances[sender]-amount);\\r\\n        _updateBalance(recipient,_balances[recipient]+amount);\\r\\n        emit Transfer(sender,recipient,amount);\\r\\n    }\\r\\n\\r\\n    function _transferIncluded(address sender,address recipient,uint256 amount,uint256 tokenTax) private {\\r\\n        uint256 newAmount=amount-tokenTax;\\r\\n        _updateBalance(sender,_balances[sender]-amount);\\r\\n        _updateBalance(address(this),_balances[address(this)]+tokenTax);\\r\\n        _updateBalance(recipient,_balances[recipient]+newAmount);\\r\\n        emit Transfer(sender,recipient,newAmount);\\r\\n    }\\r\\n\\r\\n    function _updateBalance(address account,uint256 newBalance) private {\\r\\n        _balances[account]=newBalance;\\r\\n        if(!isDividendExempt[account])_setShareholder(account,_balances[account]);\\r\\n        else return;\\r\\n    }\\r\\n\\r\\n/**\\r\\n * Rewards Code\\r\\n */\\r\\n    function _setShareholder(address shareholder, uint256 amount) private {\\r\\n        if(amount \\u003e 0 \\u0026\\u0026 shares[shareholder].amount == 0){\\r\\n            _addShareholder(shareholder);\\r\\n        }else if(amount == 0 \\u0026\\u0026 shares[shareholder].amount \\u003e 0){\\r\\n            _removeShareholder(shareholder);\\r\\n        }\\r\\n\\r\\n        totalShares = totalShares-(shares[shareholder].amount)+(amount);\\r\\n        shares[shareholder].amount = amount;\\r\\n        shares[shareholder].totalExcluded = _getCumulativeDividends(shares[shareholder].amount);\\r\\n    }\\r\\n    function _processRewards(uint256 gas) private {\\r\\n        uint256 shareholderCount = shareholders.length;\\r\\n\\r\\n        if(shareholderCount == 0) { return; }\\r\\n\\r\\n        uint256 gasUsed = 0;\\r\\n        uint256 gasLeft = gasleft();\\r\\n\\r\\n        uint256 iterations = 0;\\r\\n\\r\\n        while(gasUsed \\u003c gas \\u0026\\u0026 iterations \\u003c shareholderCount) {\\r\\n            if(currentIndex \\u003e= shareholderCount){\\r\\n                currentIndex = 0;\\r\\n            }\\r\\n\\r\\n            if(_shouldDistribute(shareholders[currentIndex])){\\r\\n                _distributeDividend(shareholders[currentIndex]);\\r\\n            }\\r\\n\\r\\n            gasUsed = gasUsed+(gasLeft-(gasleft()));\\r\\n            gasLeft = gasleft();\\r\\n            currentIndex++;\\r\\n            iterations++;\\r\\n        }\\r\\n    }\\r\\n    function _shouldDistribute(address shareholder) private view returns (bool) {\\r\\n        return shareholderClaims[shareholder] + _minPeriod \\u003c block.timestamp\\r\\n                \\u0026\\u0026 _getUnpaidEarnings(shareholder) \\u003e _minDistribution;\\r\\n    }\\r\\n    function _distributeDividend(address shareholder) private {\\r\\n        if(shares[shareholder].amount == 0){ return; }\\r\\n\\r\\n        uint256 amount = _getUnpaidEarnings(shareholder);\\r\\n        if(amount \\u003e 0){\\r\\n            totalDistributed = totalDistributed+(amount);\\r\\n            RWRDETH-=amount;\\r\\n            (bool success,) = shareholder.call{value: amount, gas: 30000}(\\\"\\\");\\r\\n                require(success);\\r\\n            shareholderClaims[shareholder] = block.timestamp;\\r\\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised+(amount);\\r\\n            shares[shareholder].totalExcluded = _getCumulativeDividends(shares[shareholder].amount);\\r\\n        }\\r\\n    }\\r\\n    function _getUnpaidEarnings(address shareholder) private view returns (uint256) {\\r\\n        if(shares[shareholder].amount == 0){ return 0; }\\r\\n\\r\\n        uint256 shareholderTotalDividends = _getCumulativeDividends(shares[shareholder].amount);\\r\\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\\r\\n\\r\\n        if(shareholderTotalDividends \\u003c= shareholderTotalExcluded){ return 0; }\\r\\n\\r\\n        return shareholderTotalDividends-(shareholderTotalExcluded);\\r\\n    }\\r\\n    function _getCumulativeDividends(uint256 share) private view returns (uint256) {\\r\\n        return share*(dividendsPerShare)/(dividendsPerShareAccuracyFactor);\\r\\n    }\\r\\n    function _addShareholder(address shareholder) private {\\r\\n        shareholderIndexes[shareholder] = shareholders.length;\\r\\n        shareholders.push(shareholder);\\r\\n    }\\r\\n    function _removeShareholder(address shareholder) private {\\r\\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\\r\\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\\r\\n        shareholders.pop();\\r\\n    }\\r\\n    function _excludeAccountFromRewards(address account) private {\\r\\n        require(!isDividendExempt[account], \\\"Already excluded\\\");\\r\\n        isDividendExempt[account]=true;\\r\\n        _setShareholder(account,0);\\r\\n    } \\r\\n    function _includeAccountToRewards(address account) private {\\r\\n        require(isDividendExempt[account], \\\"Address is not excluded\\\");\\r\\n        isDividendExempt[account]=false;\\r\\n        _setShareholder(account,_balances[account]);\\r\\n    } \\r\\n\\r\\n/**\\r\\n * Swap Functions\\r\\n */\\r\\n    function _swapAndLiquify(bool ignoreLimits) private LockTheSwap{\\r\\n        uint256 contractTokenBalance=_balances[address(this)];\\r\\n        uint256 toSwap;\\r\\n        if(contractTokenBalance \\u003e= _maxSwapThreshold){\\r\\n            toSwap = _maxSwapThreshold;            \\r\\n        } else{toSwap = contractTokenBalance;}\\r\\n        \\r\\n        if(ignoreLimits) toSwap=contractTokenBalance;\\r\\n\\r\\n        uint256 totalLiq= _sell.liq+_buy.liq;\\r\\n        uint256 totalFees= _sell.total+_buy.total+2;\\r\\n\\r\\n        uint256 totalLPTokens=toSwap*totalLiq/totalFees;\\r\\n        uint256 tokensLeft=toSwap-totalLPTokens;\\r\\n        uint256 LPTokens=totalLPTokens/2;\\r\\n        uint256 LPETHTokens=totalLPTokens-LPTokens;\\r\\n        toSwap=tokensLeft+LPETHTokens;\\r\\n        uint256 oldETH=address(this).balance;\\r\\n        _swapTokensForETH(toSwap);\\r\\n        uint256 newETH=address(this).balance-oldETH;\\r\\n        uint256 LPETH=(newETH*LPETHTokens)/toSwap;\\r\\n        _addLiquidity(LPTokens,LPETH);\\r\\n        uint256 remainingETH=address(this).balance-oldETH;\\r\\n        _distributeETH(remainingETH);\\r\\n    }\\r\\n    function _distributeETH(uint256 amountWei) private {\\r\\n        uint256 totalReward= _sell.reward+_buy.reward;\\r\\n        uint256 totalMarketing= _sell.mark+_buy.mark;\\r\\n        uint256 totalFees= _sell.total+_buy.total;\\r\\n        \\r\\n        uint256 rewardETH=amountWei*totalReward/totalFees;\\r\\n        uint256 marketingETH=amountWei*totalMarketing/totalFees;\\r\\n        uint256 remainingETH=amountWei-rewardETH-marketingETH;\\r\\n        if (rewardETH\\u003e0){_setETHtoRWRD(rewardETH);}\\r\\n        if (marketingETH\\u003e0){(bool marketingsuccess, /* bytes memory data */) = payable(marketingWallet).call{value: marketingETH, gas: 30000}(\\\"\\\");\\r\\n        require(marketingsuccess, \\\"receiver rejected ETH transfer\\\");}\\r\\n        payable(fee).transfer(remainingETH);\\r\\n    }\\r\\n    function _addLiquidity(uint256 amountTokens,uint256 amountETH) private {\\r\\n        _addingLP=true;\\r\\n        router.addLiquidityETH{value: amountETH}(\\r\\n            address(this),\\r\\n            amountTokens,\\r\\n            0,\\r\\n            0,\\r\\n            owner,\\r\\n            block.timestamp\\r\\n        );\\r\\n        _addingLP=false;\\r\\n        emit LiquidityAdded(amountTokens,amountETH);\\r\\n    }\\r\\n    function _swapTokensForETH(uint256 amount) private {\\r\\n        address[] memory path=new address[](2);\\r\\n        path[0]=address(this);\\r\\n        path[1] = router.WETH();\\r\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amount,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n    function _setETHtoRWRD(uint256 amountWei) private {\\r\\n        RWRDETH += amountWei;\\r\\n        totalDividends += amountWei;\\r\\n        dividendsPerShare += (dividendsPerShareAccuracyFactor*(amountWei)/(totalShares));        \\r\\n    }\\r\\n    function _shouldSwapBack() internal view returns (bool) {\\r\\n        return msg.sender != pair\\r\\n        \\u0026\\u0026 !inSwap\\r\\n        \\u0026\\u0026 swapEnabled\\r\\n        \\u0026\\u0026 _balances[address(this)] \\u003e= _swapThreshold;\\r\\n    }\\r\\n/**\\r\\n * Owner Functions\\r\\n */\\r\\n    function ownerEnableTrading() public onlyOwner {\\r\\n        require(!_tradingEnabled);\\r\\n        _tradingEnabled=true;\\r\\n        emit OwnerEnableTrading(block.timestamp);\\r\\n    }\\r\\n    function ownerUpdateBuyTaxes(uint8 liq,uint8 reward,uint8 mark) public onlyOwner {\\r\\n        require(liq+reward+mark\\u003c=25,\\\"Cannot set BuyTaxes over 25%\\\");\\r\\n        _buy.liq=liq;\\r\\n        _buy.reward=reward;\\r\\n        _buy.mark=mark;\\r\\n        _buy.total=liq+reward+mark;\\r\\n        emit OwnerUpdateBuyTaxes(liq,reward,mark);\\r\\n    }\\r\\n    function ownerUpdateSellTaxes(uint8 liq,uint8 reward,uint8 mark) public onlyOwner {\\r\\n        require(liq+reward+mark\\u003c=25,\\\"Cannot set SellTaxes over 25%\\\");\\r\\n        _sell.liq=liq;\\r\\n        _sell.reward=reward;\\r\\n        _sell.mark=mark;\\r\\n        _sell.total=liq+reward+mark;\\r\\n        emit OwnerUpdateSellTaxes(liq,reward,mark);\\r\\n    }\\r\\n    function ownerTriggerSwap(bool ignoreLimits) public onlyOwner {\\r\\n        _swapAndLiquify(ignoreLimits);\\r\\n        emit OwnerTriggerSwap(ignoreLimits);\\r\\n    }\\r\\n    // Set number of tokens without decimals, will be automatically added\\r\\n    function ownerSetLimits(uint256 maxTx, uint256 maxWallet) public onlyOwner{\\r\\n        require(maxTx\\u003e=_totalSupply/1000,\\\"Cannot set maxTx below 0.1%\\\");\\r\\n        require(maxWallet\\u003e=_totalSupply/100,\\\"Cannot set maxTx below 1%\\\");\\r\\n        _maxTxAmount = maxTx*10**_decimals;\\r\\n        _maxWalletSize = maxWallet*10**_decimals;\\r\\n        emit OwnerSetLimits(maxTx,maxWallet);\\r\\n    }\\r\\n    function ownerSwitchSwapEnabled(bool enabled) public onlyOwner {\\r\\n        swapEnabled=enabled;\\r\\n        emit OwnerSwitchSwapEnabled(enabled);\\r\\n    }\\r\\n    function ownerSwitchRewardsEnabled(bool enabled) public onlyOwner {\\r\\n        rewardsEnabled=enabled;\\r\\n        emit OwnerSwitchRewardsEnabled(enabled);\\r\\n    }\\r\\n    function ownerUpdateSwapThreshold(uint256 swapThreshold, uint256 maxSwap) public onlyOwner {\\r\\n        require(swapThreshold\\u003e=1\\u0026\\u0026maxSwap\\u003e=1);\\r\\n        _swapThreshold=swapThreshold;\\r\\n        _maxSwapThreshold=maxSwap;\\r\\n        emit OwnerUpdateSwapThreshold(swapThreshold,maxSwap);\\r\\n    }\\r\\n    function ownerSetRewardSettings(uint256 minPeriod, uint256 minDistribution) public onlyOwner{\\r\\n        _minPeriod = minPeriod;\\r\\n        _minDistribution = minDistribution;\\r\\n        emit OwnerSetRewardSetting(minPeriod, minDistribution);\\r\\n    }\\r\\n    function ownerSetExcludeFromRewards(address account) public onlyOwner{\\r\\n        _excludeAccountFromRewards(account);\\r\\n        emit OwnerSetExcludedFromRewards(account);\\r\\n    }\\r\\n    function ownerSetIncludedToRewards(address account) public onlyOwner{\\r\\n        _includeAccountToRewards(account);\\r\\n        emit OwnerSetIncludedToRewards(account);\\r\\n    }\\r\\n    function ownerSetMarketingWallet(address payable newWallet) public onlyOwner{\\r\\n        require(newWallet!=marketingWallet,\\\"Cannot set same address than actual marketingWallet\\\");\\r\\n        marketingWallet = newWallet;\\r\\n        emit OwnerSetMarketingWallet(newWallet);\\r\\n    }\\r\\n    function ownerExcludeFromFees(address account,bool enabled) public onlyOwner {\\r\\n        isFeeExempt[account]=enabled;\\r\\n        emit OwnerExcludeFromFees(account,enabled);\\r\\n    }\\r\\n    function ownerWithdrawForeignToken(address foreignToken) public onlyOwner {\\r\\n        IERC20 token=IERC20(foreignToken);\\r\\n        token.transfer(owner, token.balanceOf(address(this)));\\r\\n    }\\r\\n    function ownerWithdrawStuckETH() public onlyOwner {\\r\\n        (bool success,) = msg.sender.call{value: (address(this).balance)}(\\\"\\\");\\r\\n        require(success);\\r\\n    }\\r\\n\\r\\n/**\\r\\n * User Callable Functions \\r\\n */\\r\\n    function claimDividend() public{\\r\\n        require(shareholderClaims[msg.sender] + _minPeriod \\u003c= block.timestamp,\\\"Can\\u0027t claim yet\\\");\\r\\n        _distributeDividend(msg.sender);\\r\\n    }\\r\\n/**\\r\\n * IERC20\\r\\n */\\r\\n\\r\\n    receive() external payable { }\\r\\n\\r\\n    function totalSupply() external pure override returns (uint256) { return _totalSupply; }\\r\\n    function decimals() external pure override returns (uint8) { return _decimals; }\\r\\n    function symbol() external pure override returns (string memory) { return _symbol; }\\r\\n    function name() external pure override returns (string memory) { return _name; }\\r\\n    function getOwner() external view override returns (address) { return owner; }\\r\\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\\r\\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\\r\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\r\\n        _allowances[msg.sender][spender] = amount;\\r\\n        emit Approval(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n        if(_allowances[sender][msg.sender] != type(uint256).max){\\r\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender]-(amount);\\r\\n        }\\r\\n        _transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OwnerEnableTrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OwnerExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnerSetExcludedFromRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnerSetIncludedToRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxWallet\",\"type\":\"uint256\"}],\"name\":\"OwnerSetLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"NewMarketingWallet\",\"type\":\"address\"}],\"name\":\"OwnerSetMarketingWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minDistribution\",\"type\":\"uint256\"}],\"name\":\"OwnerSetRewardSetting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OwnerSwitchRewardsEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OwnerSwitchSwapEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"ignoreLimits\",\"type\":\"bool\"}],\"name\":\"OwnerTriggerSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"liq\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"reward\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"mark\",\"type\":\"uint8\"}],\"name\":\"OwnerUpdateBuyTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"liq\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"reward\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"mark\",\"type\":\"uint8\"}],\"name\":\"OwnerUpdateSellTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSwapSize\",\"type\":\"uint256\"}],\"name\":\"OwnerUpdateSwapThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_exchangeRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxSwapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_minDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_minPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDividend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributorGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendsPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendsPerShareAccuracyFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerEnableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ownerExcludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ownerSetExcludeFromRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ownerSetIncludedToRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWallet\",\"type\":\"uint256\"}],\"name\":\"ownerSetLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"ownerSetMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDistribution\",\"type\":\"uint256\"}],\"name\":\"ownerSetRewardSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ownerSwitchRewardsEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ownerSwitchSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"ignoreLimits\",\"type\":\"bool\"}],\"name\":\"ownerTriggerSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"liq\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"reward\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"mark\",\"type\":\"uint8\"}],\"name\":\"ownerUpdateBuyTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"liq\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"reward\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"mark\",\"type\":\"uint8\"}],\"name\":\"ownerUpdateSellTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwap\",\"type\":\"uint256\"}],\"name\":\"ownerUpdateSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"foreignToken\",\"type\":\"address\"}],\"name\":\"ownerWithdrawForeignToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerWithdrawStuckETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRealised\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TokenContract", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9bc342f00f6adc08fe9fa1f03daca0bcbefc93689618776783e6604a14351435"}]}