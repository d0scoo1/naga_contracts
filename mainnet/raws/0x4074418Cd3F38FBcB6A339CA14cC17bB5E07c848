{"status": "1", "message": "OK", "result": [{"SourceCode": "/**\r\n *Submitted for verification at polygonscan.com on 2022-03-31\r\n*/\r\n\r\n/**\r\n *Submitted for verification at polygonscan.com on 2022-03-22\r\n*/\r\n\r\n\r\n// Sources flattened with hardhat v2.4.1 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol@v3.4.1-solc-0.7\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/proxy/Initializable.sol@v3.4.1-solc-0.7\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.4.24 <0.8.0;\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(\r\n            _initializing || _isConstructor() || !_initialized,\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function _isConstructor() private view returns (bool) {\r\n        return !AddressUpgradeable.isContract(address(this));\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol@v3.4.1-solc-0.7\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuardUpgradeable is Initializable {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    function __ReentrancyGuard_init() internal initializer {\r\n        __ReentrancyGuard_init_unchained();\r\n    }\r\n\r\n    function __ReentrancyGuard_init_unchained() internal initializer {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n    uint256[49] private __gap;\r\n}\r\n\r\n// File contracts/roles/FoundationTreasuryNode.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @notice A mixin that stores a reference to the Foundation treasury contract.\r\n */\r\nabstract contract FoundationTreasuryNode is Initializable {\r\n    using AddressUpgradeable for address payable;\r\n\r\n    address payable private treasury;\r\n\r\n    /**\r\n     * @dev Called once after the initial deployment to set the Foundation treasury address.\r\n     */\r\n    function _initializeFoundationTreasuryNode(address payable _treasury)\r\n        internal\r\n        initializer\r\n    {\r\n        require(\r\n            _treasury.isContract(),\r\n            \"FoundationTreasuryNode: Address is not a contract\"\r\n        );\r\n        treasury = _treasury;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address of the Foundation treasury.\r\n     */\r\n    function getFoundationTreasury() public view returns (address payable) {\r\n        return treasury;\r\n    }\r\n\r\n    // `______gap` is added to each mixin to allow adding new data slots or additional mixins in an upgrade-safe way.\r\n    uint256[2000] private __gap;\r\n}\r\n\r\n// File contracts/interfaces/IAdminRole.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @notice Interface for AdminRole which wraps the default admin role from\r\n * OpenZeppelin's AccessControl for easy integration.\r\n */\r\ninterface IAdminRole {\r\n    function isAdmin(address account) external view returns (bool);\r\n}\r\n\r\n// File contracts/roles/FoundationAdminRole.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @notice Allows a contract to leverage the admin role defined by the Foundation treasury.\r\n */\r\nabstract contract FoundationAdminRole is FoundationTreasuryNode {\r\n    // This file uses 0 data slots (other than what's included via FoundationTreasuryNode)\r\n\r\n    modifier onlyFoundationAdmin() {\r\n        require(\r\n            _isFoundationAdmin(),\r\n            \"FoundationAdminRole: caller does not have the Admin role\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function _isFoundationAdmin() internal view returns (bool) {\r\n        return IAdminRole(getFoundationTreasury()).isAdmin(msg.sender);\r\n    }\r\n}\r\n\r\n// File contracts/interfaces/IOperatorRole.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @notice Interface for OperatorRole which wraps a role from\r\n * OpenZeppelin's AccessControl for easy integration.\r\n */\r\ninterface IOperatorRole {\r\n    function isOperator(address account) external view returns (bool);\r\n}\r\n\r\n// File contracts/roles/FoundationOperatorRole.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @notice Allows a contract to leverage the operator role defined by the Foundation treasury.\r\n */\r\nabstract contract FoundationOperatorRole is FoundationTreasuryNode {\r\n    // This file uses 0 data slots (other than what's included via FoundationTreasuryNode)\r\n\r\n    function _isFoundationOperator() internal view returns (bool) {\r\n        return IOperatorRole(getFoundationTreasury()).isOperator(msg.sender);\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol@v3.4.1-solc-0.7\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165Upgradeable {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol@v3.4.1-solc-0.7\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721Upgradeable is IERC165Upgradeable {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File contracts/mixins/NFTMarketCore.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @notice A place for common modifiers and functions used by various NFTMarket mixins, if any.\r\n * @dev This also leaves a gap which can be used to add a new mixin to the top of the inheritance tree.\r\n */\r\nabstract contract NFTMarketCore {\r\n    /**\r\n     * @dev If the auction did not have an escrowed seller to return, this falls back to return the current owner.\r\n     * This allows functions to calculate the correct fees before the NFT has been listed in auction.\r\n     */\r\n    function _getSellerFor(address nftContract, uint256 tokenId)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (address payable)\r\n    {\r\n        return payable(IERC721Upgradeable(nftContract).ownerOf(tokenId));\r\n    }\r\n\r\n    // 50 slots were consumed by adding ReentrancyGuardUpgradeable\r\n    uint256[950] private ______gap;\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol@v3.4.1-solc-0.7\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMathUpgradeable {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File contracts/mixins/SendValueWithFallbackWithdraw.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @notice Attempt to send ETH and if the transfer fails or runs out of gas, store the balance\r\n * for future withdrawal instead.\r\n */\r\nabstract contract SendValueWithFallbackWithdraw is ReentrancyGuardUpgradeable {\r\n    using AddressUpgradeable for address payable;\r\n    using SafeMathUpgradeable for uint256;\r\n\r\n    mapping(address => uint256) private pendingWithdrawals;\r\n\r\n    event WithdrawPending(address indexed user, uint256 amount);\r\n    event Withdrawal(address indexed user, uint256 amount);\r\n\r\n    /**\r\n     * @notice Returns how much funds are available for manual withdraw due to failed transfers.\r\n     */\r\n    function getPendingWithdrawal(address user) public view returns (uint256) {\r\n        return pendingWithdrawals[user];\r\n    }\r\n\r\n    /**\r\n     * @notice Allows a user to manually withdraw funds which originally failed to transfer to themselves.\r\n     */\r\n    function withdraw() public {\r\n        withdrawFor(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows anyone to manually trigger a withdrawal of funds which originally failed to transfer for a user.\r\n     */\r\n    function withdrawFor(address payable user) public nonReentrant {\r\n        uint256 amount = pendingWithdrawals[user];\r\n        require(amount > 0, \"No funds are pending withdrawal\");\r\n        pendingWithdrawals[user] = 0;\r\n        user.sendValue(amount);\r\n        emit Withdrawal(user, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Attempt to send a user ETH with a reasonably low gas limit of 20k,\r\n     * which is enough to send to contracts as well.\r\n     */\r\n    function _sendValueWithFallbackWithdrawWithLowGasLimit(\r\n        address payable user,\r\n        uint256 amount\r\n    ) internal {\r\n        _sendValueWithFallbackWithdraw(user, amount, 20000);\r\n    }\r\n\r\n    /**\r\n     * @dev Attempt to send a user or contract ETH with a moderate gas limit of 90k,\r\n     * which is enough for a 5-way split.\r\n     */\r\n    function _sendValueWithFallbackWithdrawWithMediumGasLimit(\r\n        address payable user,\r\n        uint256 amount\r\n    ) internal {\r\n        _sendValueWithFallbackWithdraw(user, amount, 210000);\r\n    }\r\n\r\n    /**\r\n     * @dev Attempt to send a user or contract ETH and if it fails store the amount owned for later withdrawal.\r\n     */\r\n    function _sendValueWithFallbackWithdraw(\r\n        address payable user,\r\n        uint256 amount,\r\n        uint256 gasLimit\r\n    ) private {\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n        // Cap the gas to prevent consuming all available gas to block a tx from completing successfully\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, ) = user.call{value: amount, gas: gasLimit}(\"\");\r\n        if (!success) {\r\n            // Record failed sends for a withdrawal later\r\n            // Transfers could fail if sent to a multisig with non-trivial receiver logic\r\n            // solhint-disable-next-line reentrancy\r\n            pendingWithdrawals[user] = pendingWithdrawals[user].add(amount);\r\n            emit WithdrawPending(user, amount);\r\n        }\r\n    }\r\n\r\n    uint256[499] private ______gap;\r\n}\r\n\r\n// File contracts/interfaces/IFNDNFT721.sol\r\n\r\n// solhint-disable\r\n\r\npragma solidity ^0.7.0;\r\n\r\ninterface IFNDNFT721 {\r\n    function tokenCreator(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address payable);\r\n\r\n    function getTokenCreatorPaymentAddress(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address payable);\r\n}\r\n\r\n// File contracts/mixins/NFTMarketCreators.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @notice A mixin for associating creators to NFTs.\r\n * @dev In the future this may store creators directly in order to support NFTs created on a different platform.\r\n */\r\nabstract contract NFTMarketCreators is\r\n    ReentrancyGuardUpgradeable // Adding this unused mixin to help with linearization\r\n{\r\n    /**\r\n     * @dev If the creator is not available then 0x0 is returned. Downstream this indicates that the creator\r\n     * fee should be sent to the current seller instead.\r\n     * This may apply when selling NFTs that were not minted on Foundation.\r\n     */\r\n    function _getCreator(address nftContract, uint256 tokenId)\r\n        internal\r\n        view\r\n        returns (address payable)\r\n    {\r\n        try IFNDNFT721(nftContract).tokenCreator(tokenId) returns (\r\n            address payable creator\r\n        ) {\r\n            return creator;\r\n        } catch {\r\n            return address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the creator and a destination address for any payments to the creator,\r\n     * returns address(0) if the creator is unknown.\r\n     */\r\n    function _getCreatorAndPaymentAddress(address nftContract, uint256 tokenId)\r\n        internal\r\n        view\r\n        returns (address payable, address payable)\r\n    {\r\n        address payable creator = _getCreator(nftContract, tokenId);\r\n        try\r\n            IFNDNFT721(nftContract).getTokenCreatorPaymentAddress(tokenId)\r\n        returns (address payable tokenCreatorPaymentAddress) {\r\n            if (tokenCreatorPaymentAddress != address(0)) {\r\n                return (creator, tokenCreatorPaymentAddress);\r\n            }\r\n        } catch // solhint-disable-next-line no-empty-blocks\r\n        {\r\n            // Fall through to return (creator, creator) below\r\n        }\r\n        return (creator, creator);\r\n    }\r\n\r\n    // 500 slots were added via the new SendValueWithFallbackWithdraw mixin\r\n    uint256[500] private ______gap;\r\n}\r\n\r\n// File contracts/mixins/Constants.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Constant values shared across mixins.\r\n */\r\nabstract contract Constants {\r\n    uint256 internal constant BASIS_POINTS = 10000;\r\n}\r\n\r\n// File contracts/mixins/NFTMarketFees.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @notice A mixin to distribute funds when an NFT is sold.\r\n */\r\nabstract contract NFTMarketFees is\r\n    Constants,\r\n    Initializable,\r\n    FoundationTreasuryNode,\r\n    NFTMarketCore,\r\n    NFTMarketCreators,\r\n    SendValueWithFallbackWithdraw\r\n{\r\n    using SafeMathUpgradeable for uint256;\r\n\r\n    event MarketFeesUpdated(\r\n        uint256 primaryFoundationFeeBasisPoints,\r\n        uint256 secondaryFoundationFeeBasisPoints,\r\n        uint256 secondaryCreatorFeeBasisPoints\r\n    );\r\n\r\n    uint256 private _primaryFoundationFeeBasisPoints;\r\n    uint256 private _secondaryFoundationFeeBasisPoints;\r\n    uint256 private _secondaryCreatorFeeBasisPoints;\r\n\r\n    mapping(address => mapping(uint256 => bool))\r\n        private nftContractToTokenIdToFirstSaleCompleted;\r\n\r\n    /**\r\n     * @notice Returns true if the given NFT has not been sold in this market previously and is being sold by the creator.\r\n     */\r\n    function getIsPrimary(address nftContract, uint256 tokenId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            _getIsPrimary(\r\n                nftContract,\r\n                tokenId,\r\n                _getCreator(nftContract, tokenId),\r\n                _getSellerFor(nftContract, tokenId)\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev A helper that determines if this is a primary sale given the current seller.\r\n     * This is a minor optimization to use the seller if already known instead of making a redundant lookup call.\r\n     */\r\n    function _getIsPrimary(\r\n        address nftContract,\r\n        uint256 tokenId,\r\n        address creator,\r\n        address seller\r\n    ) private view returns (bool) {\r\n        return\r\n            !nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] &&\r\n            creator == seller;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current fee configuration in basis points.\r\n     */\r\n    function getFeeConfig()\r\n        public\r\n        view\r\n        returns (\r\n            uint256 primaryFoundationFeeBasisPoints,\r\n            uint256 secondaryFoundationFeeBasisPoints,\r\n            uint256 secondaryCreatorFeeBasisPoints\r\n        )\r\n    {\r\n        return (\r\n            _primaryFoundationFeeBasisPoints,\r\n            _secondaryFoundationFeeBasisPoints,\r\n            _secondaryCreatorFeeBasisPoints\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns how funds will be distributed for a sale at the given price point.\r\n     * @dev This could be used to present exact fee distributing on listing or before a bid is placed.\r\n     */\r\n    function getFees(\r\n        address nftContract,\r\n        uint256 tokenId,\r\n        uint256 price\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint256 foundationFee,\r\n            uint256 creatorSecondaryFee,\r\n            uint256 ownerRev\r\n        )\r\n    {\r\n        (foundationFee, , creatorSecondaryFee, , ownerRev) = _getFees(\r\n            nftContract,\r\n            tokenId,\r\n            _getSellerFor(nftContract, tokenId),\r\n            price\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates how funds should be distributed for the given sale details.\r\n     * If this is a primary sale, the creator revenue will appear as `ownerRev`.\r\n     */\r\n    function _getFees(\r\n        address nftContract,\r\n        uint256 tokenId,\r\n        address payable seller,\r\n        uint256 price\r\n    )\r\n        private\r\n        view\r\n        returns (\r\n            uint256 foundationFee,\r\n            address payable creatorSecondaryFeeTo,\r\n            uint256 creatorSecondaryFee,\r\n            address payable ownerRevTo,\r\n            uint256 ownerRev\r\n        )\r\n    {\r\n        // The tokenCreatorPaymentAddress replaces the creator as the fee recipient.\r\n        (\r\n            address payable creator,\r\n            address payable tokenCreatorPaymentAddress\r\n        ) = _getCreatorAndPaymentAddress(nftContract, tokenId);\r\n        uint256 foundationFeeBasisPoints;\r\n        if (_getIsPrimary(nftContract, tokenId, creator, seller)) {\r\n            foundationFeeBasisPoints = _primaryFoundationFeeBasisPoints;\r\n            // On a primary sale, the creator is paid the remainder via `ownerRev`.\r\n            ownerRevTo = tokenCreatorPaymentAddress;\r\n        } else {\r\n            foundationFeeBasisPoints = _secondaryFoundationFeeBasisPoints;\r\n\r\n            // If there is no creator then funds go to the seller instead.\r\n            if (tokenCreatorPaymentAddress != address(0)) {\r\n                // SafeMath is not required when dividing by a constant value > 0.\r\n                creatorSecondaryFee =\r\n                    price.mul(_secondaryCreatorFeeBasisPoints) /\r\n                    BASIS_POINTS;\r\n                creatorSecondaryFeeTo = tokenCreatorPaymentAddress;\r\n            }\r\n\r\n            if (seller == creator) {\r\n                ownerRevTo = tokenCreatorPaymentAddress;\r\n            } else {\r\n                ownerRevTo = seller;\r\n            }\r\n        }\r\n        // SafeMath is not required when dividing by a constant value > 0.\r\n        foundationFee = price.mul(foundationFeeBasisPoints) / BASIS_POINTS;\r\n        ownerRev = price.sub(foundationFee).sub(creatorSecondaryFee);\r\n    }\r\n\r\n    /**\r\n     * @dev Distributes funds to foundation, creator, and NFT owner after a sale.\r\n     */\r\n    function _distributeFunds(\r\n        address nftContract,\r\n        uint256 tokenId,\r\n        address payable seller,\r\n        uint256 price\r\n    )\r\n        internal\r\n        returns (\r\n            uint256 foundationFee,\r\n            uint256 creatorFee,\r\n            uint256 ownerRev\r\n        )\r\n    {\r\n        address payable creatorFeeTo;\r\n        address payable ownerRevTo;\r\n        (\r\n            foundationFee,\r\n            creatorFeeTo,\r\n            creatorFee,\r\n            ownerRevTo,\r\n            ownerRev\r\n        ) = _getFees(nftContract, tokenId, seller, price);\r\n\r\n        // Anytime fees are distributed that indicates the first sale is complete,\r\n        // which will not change state during a secondary sale.\r\n        // This must come after the `_getFees` call above as this state is considered in the function.\r\n        nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] = true;\r\n\r\n        _sendValueWithFallbackWithdrawWithLowGasLimit(\r\n            getFoundationTreasury(),\r\n            foundationFee\r\n        );\r\n        _sendValueWithFallbackWithdrawWithMediumGasLimit(\r\n            creatorFeeTo,\r\n            creatorFee\r\n        );\r\n        _sendValueWithFallbackWithdrawWithMediumGasLimit(ownerRevTo, ownerRev);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows Foundation to change the market fees.\r\n     */\r\n    function _updateMarketFees(\r\n        uint256 primaryFoundationFeeBasisPoints,\r\n        uint256 secondaryFoundationFeeBasisPoints,\r\n        uint256 secondaryCreatorFeeBasisPoints\r\n    ) internal {\r\n        require(\r\n            primaryFoundationFeeBasisPoints < BASIS_POINTS,\r\n            \"NFTMarketFees: Fees >= 100%\"\r\n        );\r\n        require(\r\n            secondaryFoundationFeeBasisPoints.add(\r\n                secondaryCreatorFeeBasisPoints\r\n            ) < BASIS_POINTS,\r\n            \"NFTMarketFees: Fees >= 100%\"\r\n        );\r\n        _primaryFoundationFeeBasisPoints = primaryFoundationFeeBasisPoints;\r\n        _secondaryFoundationFeeBasisPoints = secondaryFoundationFeeBasisPoints;\r\n        _secondaryCreatorFeeBasisPoints = secondaryCreatorFeeBasisPoints;\r\n\r\n        emit MarketFeesUpdated(\r\n            primaryFoundationFeeBasisPoints,\r\n            secondaryFoundationFeeBasisPoints,\r\n            secondaryCreatorFeeBasisPoints\r\n        );\r\n    }\r\n\r\n    uint256[1000] private ______gap;\r\n}\r\n\r\n// File contracts/mixins/NFTMarketAuction.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @notice An abstraction layer for auctions.\r\n * @dev This contract can be expanded with reusable calls and data as more auction types are added.\r\n */\r\nabstract contract NFTMarketAuction {\r\n    /**\r\n     * @dev A global id for auctions of any type.\r\n     */\r\n    uint256 private nextAuctionId;\r\n\r\n    function _initializeNFTMarketAuction() internal {\r\n        nextAuctionId = 1;\r\n    }\r\n\r\n    function _getNextAndIncrementAuctionId() internal returns (uint256) {\r\n        return nextAuctionId++;\r\n    }\r\n\r\n    uint256[1000] private ______gap;\r\n}\r\n\r\n// File @openzeppelin/contracts/cryptography/ECDSA.sol@v3.1.0-solc-0.7\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (\r\n            uint256(s) >\r\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\r\n        ) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            revert(\"ECDSA: invalid signature 'v' value\");\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\r\n     * JSON-RPC method.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\r\n            );\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v3.1.0-solc-0.7\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n\r\n            bytes32 accountHash\r\n         = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\r\n            data\r\n        );\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v3.1.0-solc-0.7\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = byte(uint8(48 + (temp % 10)));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File contracts/interfaces/IERC1271.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Interface of the ERC1271 standard signature validation method for\r\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\r\n *\r\n * from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/interfaces/IERC1271.sol\r\n */\r\ninterface IERC1271 {\r\n    /**\r\n     * @dev Should return whether the signature provided is valid for the provided data\r\n     * @param hash      Hash of the data to be signed\r\n     * @param signature Signature byte array associated with _data\r\n     */\r\n    function isValidSignature(bytes32 hash, bytes memory signature)\r\n        external\r\n        view\r\n        returns (bytes4 magicValue);\r\n}\r\n\r\n// File contracts/mixins/AccountMigration.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @notice Checks for a valid signature authorizing the migration of an account to a new address.\r\n * @dev This is shared by both the FNDNFT721 and FNDNFTMarket, and the same signature authorizes both.\r\n */\r\nabstract contract AccountMigration is FoundationOperatorRole {\r\n    // From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/utils/cryptography\r\n    function _isValidSignatureNow(\r\n        address signer,\r\n        bytes32 hash,\r\n        bytes memory signature\r\n    ) private view returns (bool) {\r\n        if (Address.isContract(signer)) {\r\n            try IERC1271(signer).isValidSignature(hash, signature) returns (\r\n                bytes4 magicValue\r\n            ) {\r\n                return magicValue == IERC1271(signer).isValidSignature.selector;\r\n            } catch {\r\n                return false;\r\n            }\r\n        } else {\r\n            return ECDSA.recover(hash, signature) == signer;\r\n        }\r\n    }\r\n\r\n    // From https://ethereum.stackexchange.com/questions/8346/convert-address-to-string\r\n    function _toAsciiString(address x) private pure returns (string memory) {\r\n        bytes memory s = new bytes(42);\r\n        s[0] = \"0\";\r\n        s[1] = \"x\";\r\n        for (uint256 i = 0; i < 20; i++) {\r\n            bytes1 b = bytes1(uint8(uint256(uint160(x)) / (2**(8 * (19 - i)))));\r\n            bytes1 hi = bytes1(uint8(b) / 16);\r\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\r\n            s[2 * i + 2] = _char(hi);\r\n            s[2 * i + 3] = _char(lo);\r\n        }\r\n        return string(s);\r\n    }\r\n\r\n    function _char(bytes1 b) private pure returns (bytes1 c) {\r\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\r\n        else return bytes1(uint8(b) + 0x57);\r\n    }\r\n\r\n    // From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/utils/cryptography/ECDSA.sol\r\n    // Modified to accept messages (instead of the message hash)\r\n    function _toEthSignedMessage(bytes memory message)\r\n        private\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19Ethereum Signed Message:\\n\",\r\n                    Strings.toString(message.length),\r\n                    message\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Confirms the msg.sender is a Foundation operator and that the signature provided is valid.\r\n     * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`\r\n     * signed by the original account.\r\n     */\r\n    modifier onlyAuthorizedAccountMigration(\r\n        address originalAddress,\r\n        address newAddress,\r\n        bytes memory signature\r\n    ) {\r\n        require(\r\n            _isFoundationOperator(),\r\n            \"AccountMigration: Caller is not an operator\"\r\n        );\r\n        bytes32 hash = _toEthSignedMessage(\r\n            abi.encodePacked(\r\n                \"I authorize Foundation to migrate my account to \",\r\n                _toAsciiString(newAddress)\r\n            )\r\n        );\r\n        require(\r\n            _isValidSignatureNow(originalAddress, hash, signature),\r\n            \"AccountMigration: Signature must be from the original account\"\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n// File contracts/mixins/NFTMarketReserveAuction.sol\r\n\r\npragma solidity 0.7.6;\r\n\r\n// pragma abicoder v2; // solhint-disable-line\r\n\r\n/**\r\n * @notice Manages a reserve price auction for NFTs.\r\n */\r\nabstract contract NFTMarketReserveAuction is\r\n    Constants,\r\n    FoundationAdminRole,\r\n    AccountMigration,\r\n    NFTMarketCore,\r\n    ReentrancyGuardUpgradeable,\r\n    SendValueWithFallbackWithdraw,\r\n    NFTMarketFees,\r\n    NFTMarketAuction\r\n{\r\n    using SafeMathUpgradeable for uint256;\r\n\r\n    struct ReserveAuction {\r\n        address nftContract;\r\n        uint256 tokenId;\r\n        address payable seller;\r\n        uint256 duration;\r\n        uint256 extensionDuration;\r\n        uint256 endTime;\r\n        address payable bidder;\r\n        uint256 amount;\r\n    }\r\n\r\n    mapping(address => mapping(uint256 => uint256))\r\n        private nftContractToTokenIdToAuctionId;\r\n    mapping(uint256 => ReserveAuction) private auctionIdToAuction;\r\n\r\n    uint256 private _minPercentIncrementInBasisPoints;\r\n\r\n    // This variable was used in an older version of the contract, left here as a gap to ensure upgrade compatibility\r\n    uint256 private ______gap_was_maxBidIncrementRequirement;\r\n\r\n    uint256 private _duration;\r\n\r\n    // These variables were used in an older version of the contract, left here as gaps to ensure upgrade compatibility\r\n    uint256 private ______gap_was_extensionDuration;\r\n    uint256 private ______gap_was_goLiveDate;\r\n\r\n    // Cap the max duration so that overflows will not occur\r\n    uint256 private constant MAX_MAX_DURATION = 1000 days;\r\n\r\n    uint256 private constant EXTENSION_DURATION = 15 minutes;\r\n\r\n    uint256 fee;\r\n    address payable Adminaddress;\r\n\r\n    event ReserveAuctionConfigUpdated(\r\n        uint256 minPercentIncrementInBasisPoints,\r\n        uint256 maxBidIncrementRequirement,\r\n        uint256 duration,\r\n        uint256 extensionDuration,\r\n        uint256 goLiveDate\r\n    );\r\n\r\n    event ReserveAuctionCreated(\r\n        address indexed seller,\r\n        address indexed nftContract,\r\n        uint256 indexed tokenId,\r\n        uint256 duration,\r\n        uint256 extensionDuration,\r\n        uint256 reservePrice,\r\n        uint256 auctionId\r\n    );\r\n    event ReserveAuctionUpdated(\r\n        uint256 indexed auctionId,\r\n        uint256 reservePrice\r\n    );\r\n    event ReserveAuctionCanceled(uint256 indexed auctionId);\r\n    event ReserveAuctionBidPlaced(\r\n        uint256 indexed auctionId,\r\n        address indexed bidder,\r\n        uint256 amount,\r\n        uint256 endTime\r\n    );\r\n    event ReserveAuctionFinalized(\r\n        uint256 indexed auctionId,\r\n        address indexed seller,\r\n        address indexed bidder,\r\n        uint256 f8nFee,\r\n        uint256 creatorFee,\r\n        uint256 ownerRev\r\n    );\r\n    event ReserveAuctionCanceledByAdmin(\r\n        uint256 indexed auctionId,\r\n        string reason\r\n    );\r\n    event ReserveAuctionSellerMigrated(\r\n        uint256 indexed auctionId,\r\n        address indexed originalSellerAddress,\r\n        address indexed newSellerAddress\r\n    );\r\n\r\n    modifier onlyValidAuctionConfig(uint256 reservePrice) {\r\n        require(\r\n            reservePrice > 0,\r\n            \"NFTMarketReserveAuction: Reserve price must be at least 1 wei\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns auction details for a given auctionId.\r\n     */\r\n    function getReserveAuction(uint256 auctionId)\r\n        public\r\n        view\r\n        returns (ReserveAuction memory)\r\n    {\r\n        return auctionIdToAuction[auctionId];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the auctionId for a given NFT, or 0 if no auction is found.\r\n     * @dev If an auction is canceled, it will not be returned. However the auction may be over and pending finalization.\r\n     */\r\n    function getReserveAuctionIdFor(address nftContract, uint256 tokenId)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return nftContractToTokenIdToAuctionId[nftContract][tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the seller that put a given NFT into escrow,\r\n     * or bubbles the call up to check the current owner if the NFT is not currently in escrow.\r\n     */\r\n    function _getSellerFor(address nftContract, uint256 tokenId)\r\n        internal\r\n        view\r\n        virtual\r\n        override\r\n        returns (address payable)\r\n    {\r\n        address payable seller = auctionIdToAuction[\r\n            nftContractToTokenIdToAuctionId[nftContract][tokenId]\r\n        ]\r\n        .seller;\r\n        if (seller == address(0)) {\r\n            return super._getSellerFor(nftContract, tokenId);\r\n        }\r\n        return seller;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current configuration for reserve auctions.\r\n     */\r\n    function getReserveAuctionConfig()\r\n        public\r\n        view\r\n        returns (uint256 minPercentIncrementInBasisPoints, uint256 duration)\r\n    {\r\n        minPercentIncrementInBasisPoints = _minPercentIncrementInBasisPoints;\r\n        duration = _duration;\r\n    }\r\n\r\n    function _initializeNFTMarketReserveAuction() internal {\r\n        _duration = 1 days; // A sensible default value\r\n    }\r\n\r\n    function _updateReserveAuctionConfig(\r\n        uint256 minPercentIncrementInBasisPoints,\r\n        uint256 duration\r\n    ) internal {\r\n        require(\r\n            minPercentIncrementInBasisPoints <= BASIS_POINTS,\r\n            \"NFTMarketReserveAuction: Min increment must be <= 100%\"\r\n        );\r\n        // Cap the max duration so that overflows will not occur\r\n        require(\r\n            duration <= MAX_MAX_DURATION,\r\n            \"NFTMarketReserveAuction: Duration must be <= 1000 days\"\r\n        );\r\n        require(\r\n            duration >= EXTENSION_DURATION,\r\n            \"NFTMarketReserveAuction: Duration must be >= EXTENSION_DURATION\"\r\n        );\r\n        _minPercentIncrementInBasisPoints = minPercentIncrementInBasisPoints;\r\n        _duration = duration;\r\n\r\n        // We continue to emit unused configuration variables to simplify the subgraph integration.\r\n        emit ReserveAuctionConfigUpdated(\r\n            minPercentIncrementInBasisPoints,\r\n            0,\r\n            duration,\r\n            EXTENSION_DURATION,\r\n            0\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Creates an auction for the given NFT.\r\n     * The NFT is held in escrow until the auction is finalized or canceled.\r\n     */\r\n\r\n      function getadminaddress(address payable adminaddress, uint256 FEE) external payable returns(address, uint256){\r\n     Adminaddress = adminaddress ;\r\n     fee = FEE ;\r\n     return (Adminaddress,fee);\r\n }\r\n\r\n\r\n    function createReserveAuction(\r\n        address nftContract,\r\n        uint256 tokenId,\r\n        uint256 reservePrice,\r\n        uint256 time\r\n    ) public onlyValidAuctionConfig(reservePrice) nonReentrant {\r\n        // If an auction is already in progress then the NFT would be in escrow and the modifier would have failed\r\n        uint256 auctionId = _getNextAndIncrementAuctionId();\r\n        _duration =  time * 1 days;\r\n        nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;\r\n        auctionIdToAuction[auctionId] = ReserveAuction(\r\n            nftContract,\r\n            tokenId,\r\n            msg.sender,\r\n            _duration,\r\n            EXTENSION_DURATION,\r\n            0, // endTime is only known once the reserve price is met\r\n            address(0), // bidder is only known once a bid has been placed\r\n            reservePrice\r\n        );\r\n\r\n        IERC721Upgradeable(nftContract).transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            tokenId\r\n        );\r\n\r\n        emit ReserveAuctionCreated(\r\n            msg.sender,\r\n            nftContract,\r\n            tokenId,\r\n            _duration,\r\n            EXTENSION_DURATION,\r\n            reservePrice,\r\n            auctionId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice If an auction has been created but has not yet received bids, the configuration\r\n     * such as the reservePrice may be changed by the seller.\r\n     */\r\n    function updateReserveAuction(uint256 auctionId, uint256 reservePrice)\r\n        public\r\n        onlyValidAuctionConfig(reservePrice)\r\n    {\r\n        ReserveAuction storage auction = auctionIdToAuction[auctionId];\r\n        require(\r\n            auction.seller == msg.sender,\r\n            \"NFTMarketReserveAuction: Not your auction\"\r\n        );\r\n        require(\r\n            auction.endTime == 0,\r\n            \"NFTMarketReserveAuction: Auction in progress\"\r\n        );\r\n\r\n        auction.amount = reservePrice;\r\n\r\n        emit ReserveAuctionUpdated(auctionId, reservePrice);\r\n    }\r\n\r\n    /**\r\n     * @notice If an auction has been created but has not yet received bids, it may be canceled by the seller.\r\n     * The NFT is returned to the seller from escrow.\r\n     */\r\n    function cancelReserveAuction(uint256 auctionId) public nonReentrant {\r\n        ReserveAuction memory auction = auctionIdToAuction[auctionId];\r\n        require(\r\n            auction.seller == msg.sender,\r\n            \"NFTMarketReserveAuction: Not your auction\"\r\n        );\r\n        require(\r\n            auction.endTime == 0,\r\n            \"NFTMarketReserveAuction: Auction in progress\"\r\n        );\r\n\r\n        delete nftContractToTokenIdToAuctionId[auction.nftContract][\r\n            auction.tokenId\r\n        ];\r\n        delete auctionIdToAuction[auctionId];\r\n\r\n        IERC721Upgradeable(auction.nftContract).transferFrom(\r\n            address(this),\r\n            auction.seller,\r\n            auction.tokenId\r\n        );\r\n\r\n        emit ReserveAuctionCanceled(auctionId);\r\n    }\r\n\r\n    /**\r\n     * @notice A bidder may place a bid which is at least the value defined by `getMinBidAmount`.\r\n     * If this is the first bid on the auction, the countdown will begin.\r\n     * If there is already an outstanding bid, the previous bidder will be refunded at this time\r\n     * and if the bid is placed in the final moments of the auction, the countdown may be extended.\r\n     */\r\n    function placeBid(uint256 auctionId) public payable nonReentrant {\r\n        ReserveAuction storage auction = auctionIdToAuction[auctionId];\r\n        require(\r\n            auction.amount != 0,\r\n            \"NFTMarketReserveAuction: Auction not found\"\r\n        );\r\n        Adminaddress.transfer(msg.value * fee/100);\r\n        if (auction.endTime == 0) {\r\n            // If this is the first bid, ensure it's >= the reserve price\r\n            require(\r\n                auction.amount <= msg.value,\r\n                \"NFTMarketReserveAuction: Bid must be at least the reserve price\"\r\n            );\r\n        } else {\r\n            // If this bid outbids another, confirm that the bid is at least x% greater than the last\r\n            require(\r\n                auction.endTime >= block.timestamp,\r\n                \"NFTMarketReserveAuction: Auction is over\"\r\n            );\r\n            require(\r\n                auction.bidder != msg.sender,\r\n                \"NFTMarketReserveAuction: You already have an outstanding bid\"\r\n            );\r\n            uint256 minAmount = _getMinBidAmountForReserveAuction(\r\n                auction.amount\r\n            );\r\n            require(\r\n                msg.value >= minAmount,\r\n                \"NFTMarketReserveAuction: Bid amount too low\"\r\n            );\r\n        }\r\n\r\n        if (auction.endTime == 0) {\r\n            auction.amount = (msg.value  - (msg.value * fee / 100));\r\n            auction.bidder = msg.sender;\r\n            // On the first bid, the endTime is now + duration\r\n            auction.endTime = block.timestamp + auction.duration;\r\n        } else {\r\n            // Cache and update bidder state before a possible reentrancy (via the value transfer)\r\n            uint256 originalAmount = auction.amount;\r\n            address payable originalBidder = auction.bidder;\r\n            auction.amount = (msg.value  - (msg.value * fee / 100));\r\n            auction.bidder = msg.sender;\r\n\r\n            // When a bid outbids another, check to see if a time extension should apply.\r\n            if (auction.endTime - block.timestamp < auction.extensionDuration) {\r\n                auction.endTime = block.timestamp + auction.extensionDuration;\r\n            }\r\n\r\n            // Refund the previous bidder\r\n            _sendValueWithFallbackWithdrawWithLowGasLimit(\r\n                originalBidder,\r\n                originalAmount\r\n            );\r\n        }\r\n\r\n        emit ReserveAuctionBidPlaced(\r\n            auctionId,\r\n            msg.sender,\r\n            msg.value,\r\n            auction.endTime\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Once the countdown has expired for an auction, anyone can settle the auction.\r\n     * This will send the NFT to the highest bidder and distribute funds.\r\n     */\r\n    function finalizeReserveAuction(uint256 auctionId) public nonReentrant {\r\n        ReserveAuction memory auction = auctionIdToAuction[auctionId];\r\n        require(\r\n            auction.endTime > 0,\r\n            \"NFTMarketReserveAuction: Auction was already settled\"\r\n        );\r\n        require(\r\n            auction.endTime < block.timestamp,\r\n            \"NFTMarketReserveAuction: Auction still in progress\"\r\n        );\r\n\r\n        delete nftContractToTokenIdToAuctionId[auction.nftContract][\r\n            auction.tokenId\r\n        ];\r\n        delete auctionIdToAuction[auctionId];\r\n\r\n        IERC721Upgradeable(auction.nftContract).transferFrom(\r\n            address(this),\r\n            auction.bidder,\r\n            auction.tokenId\r\n        );\r\n\r\n        (\r\n            uint256 f8nFee,\r\n            uint256 creatorFee,\r\n            uint256 ownerRev\r\n        ) = _distributeFunds(\r\n            auction.nftContract,\r\n            auction.tokenId,\r\n            auction.seller,\r\n            auction.amount\r\n        );\r\n\r\n        emit ReserveAuctionFinalized(\r\n            auctionId,\r\n            auction.seller,\r\n            auction.bidder,\r\n            f8nFee,\r\n            creatorFee,\r\n            ownerRev\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the minimum amount a bidder must spend to participate in an auction.\r\n     */\r\n    function getMinBidAmount(uint256 auctionId) public view returns (uint256) {\r\n        ReserveAuction storage auction = auctionIdToAuction[auctionId];\r\n        if (auction.endTime == 0) {\r\n            return auction.amount;\r\n        }\r\n        return _getMinBidAmountForReserveAuction(auction.amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Determines the minimum bid amount when outbidding another user.\r\n     */\r\n    function _getMinBidAmountForReserveAuction(uint256 currentBidAmount)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 minIncrement = currentBidAmount.mul(\r\n            _minPercentIncrementInBasisPoints\r\n        ) / BASIS_POINTS;\r\n        if (minIncrement == 0) {\r\n            // The next bid must be at least 1 wei greater than the current.\r\n            return currentBidAmount.add(1);\r\n        }\r\n        return minIncrement.add(currentBidAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows Foundation to cancel an auction, refunding the bidder and returning the NFT to the seller.\r\n     * This should only be used for extreme cases such as DMCA takedown requests. The reason should always be provided.\r\n     */\r\n    function adminCancelReserveAuction(uint256 auctionId, string memory reason)\r\n        public\r\n        onlyFoundationAdmin\r\n    {\r\n        require(\r\n            bytes(reason).length > 0,\r\n            \"NFTMarketReserveAuction: Include a reason for this cancellation\"\r\n        );\r\n        ReserveAuction memory auction = auctionIdToAuction[auctionId];\r\n        require(\r\n            auction.amount > 0,\r\n            \"NFTMarketReserveAuction: Auction not found\"\r\n        );\r\n\r\n        delete nftContractToTokenIdToAuctionId[auction.nftContract][\r\n            auction.tokenId\r\n        ];\r\n        delete auctionIdToAuction[auctionId];\r\n\r\n        IERC721Upgradeable(auction.nftContract).transferFrom(\r\n            address(this),\r\n            auction.seller,\r\n            auction.tokenId\r\n        );\r\n        if (auction.bidder != address(0)) {\r\n            _sendValueWithFallbackWithdrawWithMediumGasLimit(\r\n                auction.bidder,\r\n                auction.amount\r\n            );\r\n        }\r\n\r\n        emit ReserveAuctionCanceledByAdmin(auctionId, reason);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows an NFT owner and Foundation to work together in order to update the seller\r\n     * for auctions they have listed to a new account.\r\n     * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`\r\n     * signed by the original account.\r\n     * @dev This will gracefully skip any auctions that have already been finalized.\r\n     */\r\n    function adminAccountMigration(\r\n        uint256[] calldata listedAuctionIds,\r\n        address originalAddress,\r\n        address payable newAddress,\r\n        bytes calldata signature\r\n    )\r\n        public\r\n        onlyAuthorizedAccountMigration(originalAddress, newAddress, signature)\r\n    {\r\n        for (uint256 i = 0; i < listedAuctionIds.length; i++) {\r\n            uint256 auctionId = listedAuctionIds[i];\r\n            ReserveAuction storage auction = auctionIdToAuction[auctionId];\r\n            // The seller would be 0 if it was finalized before this call\r\n            if (auction.seller != address(0)) {\r\n                require(\r\n                    auction.seller == originalAddress,\r\n                    \"NFTMarketReserveAuction: Auction not created by that address\"\r\n                );\r\n                auction.seller = newAddress;\r\n                emit ReserveAuctionSellerMigrated(\r\n                    auctionId,\r\n                    originalAddress,\r\n                    newAddress\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    uint256[1000] private ______gap;\r\n}\r\n\r\n// File contracts/FNDNFTMarket.sol\r\n\r\n/*\r\n  \uff65\r\n   *\u3000\u2605\r\n      \uff65 \uff61\r\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\r\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\r\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\r\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\r\n\u200b\r\n                      `                     .-:::::-.`              `-::---...```\r\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\r\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\r\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\r\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\r\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\r\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\r\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\r\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\r\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\r\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\r\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\r\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\r\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\r\n                                              `````\r\n   *\u3000\r\n      \uff65 \uff61\r\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\r\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\r\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\r\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\r\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\r\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\r\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\r\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\r\n\u3000\uff65\uff9f*\uff61\u2605\uff65\r\n \u2606\u2234\uff61\u3000*\r\n\uff65 \uff61\r\n*/\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2; // solhint-disable-line\r\n\r\n/**\r\n * @title A market for NFTs on Foundation.\r\n * @dev This top level file holds no data directly to ease future upgrades.\r\n */\r\ncontract WallexMarket is\r\n    FoundationTreasuryNode,\r\n    FoundationAdminRole,\r\n    FoundationOperatorRole,\r\n    AccountMigration,\r\n    NFTMarketCore,\r\n    ReentrancyGuardUpgradeable,\r\n    NFTMarketCreators,\r\n    SendValueWithFallbackWithdraw,\r\n    NFTMarketFees,\r\n    NFTMarketAuction,\r\n    NFTMarketReserveAuction\r\n{\r\n    /**\r\n     * @notice Called once to configure the contract after the initial deployment.\r\n     * @dev This farms the initialize call out to inherited contracts as needed.\r\n     */\r\n    function initialize(address payable treasury) public initializer {\r\n        FoundationTreasuryNode._initializeFoundationTreasuryNode(treasury);\r\n        NFTMarketAuction._initializeNFTMarketAuction();\r\n        NFTMarketReserveAuction._initializeNFTMarketReserveAuction();\r\n    }\r\n\r\n    /**\r\n     * @notice Allows Foundation to update the market configuration.\r\n     */\r\n    function adminUpdateConfig(\r\n        uint256 minPercentIncrementInBasisPoints,\r\n        uint256 duration,\r\n        uint256 primaryF8nFeeBasisPoints,\r\n        uint256 secondaryF8nFeeBasisPoints,\r\n        uint256 secondaryCreatorFeeBasisPoints\r\n    ) public onlyFoundationAdmin {\r\n        _updateReserveAuctionConfig(minPercentIncrementInBasisPoints, duration);\r\n        _updateMarketFees(\r\n            primaryF8nFeeBasisPoints,\r\n            secondaryF8nFeeBasisPoints,\r\n            secondaryCreatorFeeBasisPoints\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Checks who the seller for an NFT is, this will check escrow or return the current owner if not in escrow.\r\n     * This is a no-op function required to avoid compile errors.\r\n     */\r\n    function _getSellerFor(address nftContract, uint256 tokenId)\r\n        internal\r\n        view\r\n        virtual\r\n        override(NFTMarketCore, NFTMarketReserveAuction)\r\n        returns (address payable)\r\n    {\r\n        return super._getSellerFor(nftContract, tokenId);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"primaryFoundationFeeBasisPoints\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"secondaryFoundationFeeBasisPoints\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"secondaryCreatorFeeBasisPoints\",\"type\":\"uint256\"}],\"name\":\"MarketFeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionBidPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"ReserveAuctionCanceledByAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minPercentIncrementInBasisPoints\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxBidIncrementRequirement\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"extensionDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"goLiveDate\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionConfigUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"extensionDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"f8nFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creatorFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownerRev\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"originalSellerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newSellerAddress\",\"type\":\"address\"}],\"name\":\"ReserveAuctionSellerMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"listedAuctionIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"originalAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"newAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"adminAccountMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"adminCancelReserveAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minPercentIncrementInBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"primaryF8nFeeBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondaryF8nFeeBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondaryCreatorFeeBasisPoints\",\"type\":\"uint256\"}],\"name\":\"adminUpdateConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"cancelReserveAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"createReserveAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"finalizeReserveAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"primaryFoundationFeeBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondaryFoundationFeeBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondaryCreatorFeeBasisPoints\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"getFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"foundationFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creatorSecondaryFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ownerRev\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFoundationTreasury\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getIsPrimary\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getMinBidAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getPendingWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getReserveAuction\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extensionDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct NFTMarketReserveAuction.ReserveAuction\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserveAuctionConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minPercentIncrementInBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getReserveAuctionIdFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adminaddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"FEE\",\"type\":\"uint256\"}],\"name\":\"getadminaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"placeBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"}],\"name\":\"updateReserveAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"withdrawFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WallexMarket", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ced7f462f1132dfc8547b8cd79ea39228b1bb842492ebe5d7bcbc4d7ff84b2e3"}]}