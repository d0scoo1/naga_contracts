{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MintverseWord.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport './libraries/ERC721A.sol';\\nimport \\\"./interfaces/IWord.sol\\\";\\nimport \\\"./interfaces/IMintverseWord.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/*\\n * \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2557    \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \\n * \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d    \u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\\n * \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2557      \u2588\u2588\u2551 \u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\\n * \u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551   \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d      \u2588\u2588\u2551\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\\n * \u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551    \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u255a\u2588\u2588\u2588\u2554\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\\n * \u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d   \u255a\u2550\u255d     \u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d     \u255a\u2550\u2550\u255d\u255a\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \\n *                                                                                                        @ryanycw                                                                                                             \\n *                                                                                                                                                                                     \\n *      \u7b2c\u4e8c\u5b87\u5b99\u8fad\u5178 \u9444\u9020\u5ba3\u8a00\\n *   1. \u5373\u4f7f\u820a\u4e16\u754c\u7684\u6587\u660e\u5df2\u7d93\u6ec5\u4ea1\uff0c\u6211\u5011\u4ecd\u76f8\u4fe1\u6587\u5b57\u4fdd\u5b58\u4e86\u66fe\u6709\u7684\u5b87\u5b99\u3002\\n *   2. \u6211\u5011\u4e0d\u6392\u65a5\u5d84\u65b0\u7684\u7576\u4ee3\u6587\u660e\uff0c\u53ea\u662f\u76f8\u4fe1\u53e4\u8001\u7684\u7b26\u865f\u88e1\uff0c\u4ecd\u542b\u6709\u820a\u4e16\u754c\u4eba\u985e\u7368\u5f97\u4e4b\u5967\u79d8\u3002\\n *   3. \u6211\u5011\u4e0d\u76f8\u4fe1\u65b0\u4e16\u754c\u8207\u820a\u4e16\u754c\u4e4b\u9593\uff0c\u662f\u6beb\u7121\u95dc\u806f\u7684\u5169\u500b\u6587\u660e\u3002\\n *   4. \u6211\u5011\u76f8\u4fe1\u5728\u6700\u7c21\u55ae\u7684\u7dda\u689d\u88e1\uff0c\u6709\u6700\u8c50\u6eff\u7684\u5f62\u8c61\u3001\u984f\u8272\u8207\u5834\u666f\u3002\\n *   5. \u6211\u5011\u78ba\u77e5\u4e00\u5207\u6700\u8907\u96dc\u7684\u601d\u60f3\uff0c\u5fc5\u4ee5\u6700\u55ae\u7d14\u7684\u97f3\u7bc0\u7d44\u6210\u3002\\n *   6. \u6211\u5011\u76f8\u4fe1\u6587\u5b57\u6c38\u4e0d\u8870\u4ea1\uff0c\u53ea\u662f\u6c89\u7761\u3002\u559a\u9192\u6587\u5b57\u7684\u65b9\u5f0f\uff0c\u4fbf\u662f\u91cb\u7fa9\u3001\u8fa8\u6790\u3001\u5b9a\u7fa9\u3001\u5340\u5206\u22ef\u22ef\u3002\\n *   7. \u6211\u5011\u4e0d\u57f7\u8457\u65bc\u300c\u6b63\u78ba\u300d\uff0c\u6211\u5011\u66f4\u4fe1\u4efb\u300c\u60f3\u50cf\u300d\u3002\u56e0\u70ba\uff0c\u5f9e\u7dda\u689d\u806f\u60f3\u7269\u8c61\uff0c\u97f3\u7bc0\u6355\u6349\u6982\u5ff5\uff0c\u6b63\u662f\u4eba\u985e\u6587\u660e\u7684\u8f1d\u714c\u8d77\u9ede\u3002\\n *   8. \u5b83\u662f\u4ec0\u9ebc\u610f\u601d\uff1b\u5b83\u4e0d\u662f\u4ec0\u9ebc\u610f\u601d\u2014\u2014\u9019\u4e9b\u90fd\u5f88\u91cd\u8981\u3002\u4f46\u6700\u91cd\u8981\u7684\u662f\uff1a\u5b83\u300c\u9084\u53ef\u4ee5\u300d\u662f\u4ec0\u9ebc\u610f\u601d\uff1f\\n *   9. \u6211\u5011\u71b1\u611b\u885d\u7a81\uff0c\u64c1\u62b1\u77db\u76fe\uff0c\u56e0\u70ba\u6fc0\u70c8\u78b0\u649e\u6240\u80fd\u5f15\u51fa\u7684\u5967\u79d8\uff0c\u9060\u52dd\u65bc\u773e\u53e3\u4e00\u8072\u7684\u610f\u898b\u3002   \\n *  10. \u6211\u5011\u5805\u6c7a\u76f8\u4fe1\uff1a\u5728\u6211\u5011\u964d\u751f\u7fa4\u805a\u7684\u7b2c\u4e00\u5b87\u5b99\u4e4b\u5916\u3001\u4e4b\u9593\u3001\u4e4b\u524d\u3001\u4e4b\u5f8c\uff0c\u9084\u6709\u4e00\u500b\u503c\u5f97\u6211\u5011\u7aae\u76e1\u60f3\u50cf\u529b\u53bb\u63a2\u7d22\u7684\u7b2c\u4e8c\u5b87\u5b99\u3002\\n */ \\n\\ncontract IMintverseWordStorage is IWord {\\n    // Metadata Variables\\n    mapping(uint256 => TokenInfo) public tokenItem;\\n    // Mint Record Variables\\n    mapping(address => bool) public mintedByAddress;\\n    mapping(address => bool) public purchaseDictionaryCheckByAddress;\\n    mapping(address => uint256) public whitelistMintAmount;\\n    // Phase Limitation Variables\\n    bool public mintWhitelistEnable;\\n    bool public mintPublicEnable;\\n    uint256 public mintWhitelistTimestamp;\\n    uint256 public mintPublicTimestamp;\\n    uint48 public revealTimestamp;\\n    // Mint Record Variables\\n    uint16 public totalDictionary;\\n\\tuint16 public totalWordGiveaway;\\n    uint16 public totalWordWhitelist;\\n    // Mint Limitation Variables\\n    uint256 public MAX_MINTVERSE_RANDOM_WORD;\\n    uint256 public MAX_MINTVERSE_GIVEAWAY_WORD;\\n    uint256 public MAX_MINTVERSE_DICTIONARY;\\n    uint256 public DICT_ADDON_PRICE;\\n    uint48 public WORD_EXPIRATION_TIME;\\n    uint16 public HEAD_RANDOM_WORDID;\\n    uint16 public TAIL_RANDOM_WORDID;\\n    uint16 public SETTLE_HEAD_TOKENID;\\n    uint16 public DESIGNATED_WORDID_OFFSET;\\n    // Governance Variables\\n\\taddress public treasury;\\n    string public baseTokenURI;\\n    // Mapping Off-Chain Storage\\n    string public legalDocumentURI;\\n    string public systemMechanismDocumentURI;\\n    string public animationCodeDocumentURI;\\n    string public visualRebuildDocumentURI;\\n    string public ERC721ATechinalDocumentURI;\\n    string public wordIdMappingDocumnetURI;\\n    string public partOfSpeechIdMappingDocumentURI;\\n    string public categoryIdMappingDocumentURI;\\n    string public metadataMappingDocumentURI;\\n}\\n\\ncontract MintverseWord is IMintverseWord, IMintverseWordStorage, Ownable, EIP712, ERC721A {\\n\\n    using SafeMath for uint16;\\n    using SafeMath for uint48;\\n    using SafeMath for uint256;\\n\\tusing Strings for uint256;\\n\\n    constructor()\\n    EIP712(\\\"MintverseWord\\\", \\\"1.0.0\\\")\\n    ERC721A(\\\"MintverseWord\\\", \\\"MVW\\\")     \\n    {\\n        mintWhitelistEnable = true;\\n        mintPublicEnable = true;\\n        mintWhitelistTimestamp = 1651752000;\\n        mintPublicTimestamp = 1652155200;\\n        revealTimestamp = 1652068800;\\n\\n        MAX_MINTVERSE_RANDOM_WORD = 1900;\\n        MAX_MINTVERSE_GIVEAWAY_WORD = 200;\\n        MAX_MINTVERSE_DICTIONARY = 185;\\n        DICT_ADDON_PRICE = 0.15 ether;\\n        WORD_EXPIRATION_TIME = 42 hours;\\n        TAIL_RANDOM_WORDID = 1900;\\n        SETTLE_HEAD_TOKENID = TAIL_RANDOM_WORDID;\\n        DESIGNATED_WORDID_OFFSET = uint16(TAIL_RANDOM_WORDID.mul(2));\\n\\n        treasury = 0xbA53C6831B496c8a40c02A3c2d1366DfC6503F4e;\\n        baseTokenURI = \\\"https://api.mintverse.world/word/metadata/\\\";\\n        legalDocumentURI = \\\"\\\";\\n        systemMechanismDocumentURI = \\\"\\\";\\n        animationCodeDocumentURI = \\\"\\\";\\n        visualRebuildDocumentURI = \\\"\\\";\\n        ERC721ATechinalDocumentURI = \\\"\\\";\\n        wordIdMappingDocumnetURI = \\\"\\\";\\n        partOfSpeechIdMappingDocumentURI = \\\"\\\";\\n        categoryIdMappingDocumentURI = \\\"\\\";\\n        metadataMappingDocumentURI = \\\"\\\";\\n    }\\n\\n    /**\\n     * Modifiers\\n     */\\n    modifier onlyTokenOwner(uint256 tokenId) {\\n        require(ownershipOf(tokenId).addr == msg.sender, \\\"Can't define - Not the word owner\\\");\\n        _;\\n    }\\n\\n    modifier mintWhitelistActive() {\\n\\t\\trequire(mintWhitelistEnable == true, \\\"Can't mint - WL mint phase hasn't enable\\\");\\n        require(block.timestamp >= mintWhitelistTimestamp, \\\"Can't mint - WL mint phase hasn't started\\\");\\n        _;\\n    }\\n\\n    modifier mintPublicActive() {\\n\\t\\trequire(mintPublicEnable == true, \\\"Can't mint - Public mint phase hasn't enable\\\");\\n        require(block.timestamp >= mintPublicTimestamp, \\\"Can't mint - Public mint phase hasn't started\\\");\\n        _;\\n    }\\n    \\n    modifier callerIsUser() {\\n        require(tx.origin == msg.sender, \\\"Invalid caller - Caller is a Contract\\\");\\n        _;\\n    }\\n\\n    modifier wordNotExpired(uint256 tokenId){\\n        require((block.timestamp > tokenItem[tokenId].mintTime) || tokenItem[tokenId].defined, \\\"Invalid Block Time - Mint time shouldn't be larger than current time\\\");\\n        require((block.timestamp <= (tokenItem[tokenId].mintTime + WORD_EXPIRATION_TIME)) || tokenItem[tokenId].defined, \\\"Invalid Block Time - This token is expired\\\");\\n        _;\\n    }\\n\\n    /**\\n     * Verify Functions\\n     */\\n    /** @dev Verify if a address is eligible to mint a specific amount\\n     * @param SIGNATURE Signature used to verify the minter address and amount of claimable tokens\\n     */\\n    function verify(\\n        uint256 maxQuantity,\\n        bytes calldata SIGNATURE\\n    ) \\n        public \\n        override\\n        view \\n        returns(bool)\\n    {\\n        address recoveredAddr = ECDSA.recover(_hashTypedDataV4(keccak256(abi.encode(keccak256(\\\"NFT(address addressForClaim,uint256 maxQuantity)\\\"), _msgSender(), maxQuantity))), SIGNATURE);\\n        return owner() == recoveredAddr;\\n    }\\n\\n    /**\\n     * Mint Functions\\n     */\\n    /** @dev Record dictionary addon for a an address as owner\\n     * @param to Address to record dictionary addon\\n     * @param addon True if recording giveaway dictionary to the \\\"to\\\" address, otherwise false\\n     */\\n    function mintGiveawayDictionary(\\n        address to, \\n        bool addon\\n    ) \\n        external\\n        override\\n        onlyOwner\\n    {   \\n        _mintGiveawayDictionary(to, addon);\\n    }\\n\\n    /** @dev Mint word token to an address with specific amount of tokens as owner\\n     * @param to Address to transfer the tokens\\n     * @param wordId Designated wordId of the giveaway tokens\\n     * @param mintTimestamp Timestamp to start the countdown for expiration\\n     */\\n    function mintGiveawayWord(\\n        address to, \\n        uint16 wordId,\\n        uint48 mintTimestamp\\n    ) \\n        external\\n        override\\n        onlyOwner\\n    {   \\n        require(totalWordGiveaway.add(1) <= MAX_MINTVERSE_GIVEAWAY_WORD, \\\"Exceed maximum word amount\\\");\\n        totalWordGiveaway = uint16(totalWordGiveaway.add(1));\\n        _mintDesignatedWord(to, wordId, mintTimestamp);\\n\\n\\t\\temit mintWordEvent(to, 1, totalSupply());\\n    }\\n\\n    /** @dev Mint word token as Whitelisted Address\\n     * @param quantity Amount of tokens the address wants to mint\\n     * @param maxClaimNum Maximum amount of word tokens the address can mint\\n     * @param addon True if recording giveaway dictionary to the \\\"to\\\" address, otherwise false\\n     * @param SIGNATURE Signature used to verify the minter address and amount of claimable tokens\\n     */\\n    function mintWhitelistWord(\\n        uint256 quantity,\\n        uint256 maxClaimNum, \\n        bool addon,\\n        bytes calldata SIGNATURE\\n    ) \\n        external \\n        payable\\n        override\\n        mintWhitelistActive\\n        callerIsUser\\n    {\\n        require(verify(maxClaimNum, SIGNATURE), \\\"Can't claim - Not eligible\\\");\\n        require(_getRandomWordMintCnt().add(quantity) <= MAX_MINTVERSE_RANDOM_WORD, \\\"Exceed maximum word amount\\\");\\n        require(quantity > 0 && whitelistMintAmount[msg.sender].add(quantity) <= maxClaimNum, \\\"Exceed maximum mintable whitelist amount\\\");\\n        \\n        mintedByAddress[msg.sender] = true;\\n        whitelistMintAmount[msg.sender] = whitelistMintAmount[msg.sender].add(quantity);\\n        totalWordWhitelist = uint16(totalWordWhitelist.add(quantity));\\n        _mintPublicDictionary(msg.sender, addon);\\n\\n        for(uint16 index=0; index < quantity; index++) {\\n            _mintRandomWord(msg.sender);\\n        }\\n        \\n        emit mintWordEvent(msg.sender, quantity, totalSupply());\\n    }\\n\\n    /** @dev Mint word token as Public Address\\n     * @param addon True if recording giveaway dictionary to the \\\"to\\\" address, otherwise false\\n     */\\n    function mintPublicWord(\\n        bool addon\\n    )\\n        external\\n        payable \\n        override\\n        mintPublicActive\\n        callerIsUser\\n    {\\n        require(mintedByAddress[msg.sender]==false, \\\"Already minted you naughty, leave some word for others\\\");\\n        require(_getRandomWordMintCnt().add(1) <= MAX_MINTVERSE_RANDOM_WORD, \\\"Exceed maximum word amount\\\");\\n            \\n        mintedByAddress[msg.sender] = true;\\n        _mintPublicDictionary(msg.sender, addon);\\n        _mintRandomWord(msg.sender);\\n\\n        emit mintWordEvent(msg.sender, 1, totalSupply());\\n    }\\n\\n    /** @dev Calculate the token counts for random words, which is total supply substract the giveaway amount\\n     */\\n    function _getRandomWordMintCnt()\\n        private\\n        view\\n        returns(uint16 randomWordMintCnt)\\n    {\\n        return uint16(totalSupply().sub(totalWordGiveaway));\\n    }\\n\\n    /** @dev Calculate the token timestamp for expiration calculation\\n     *       If the mint timestamp is before reveal, then set at reveal\\n     *       If the mint timestamp is after reveal, then set at mint current time\\n     */\\n    function _getCurWordTimestamp()\\n        private\\n        view\\n        returns(uint48 curWordTimestamp)\\n    {\\n        if(block.timestamp <= revealTimestamp) return revealTimestamp;\\n        else return uint48(block.timestamp);\\n    }\\n\\n    /** @dev Calculate the token's corresponding wordId\\n     *       If the random token count is smaller than the initial maximum random count, then circulate with the maximum random count - (0 - 1899)\\n     *       If the token is minted after some tokens are dead, then start from the end of the maximum random count - (1900 - 3799)\\n     */\\n    function _getCurWordId()\\n        private\\n        view\\n        returns(uint16 curWordId)\\n    {\\n        if(_getRandomWordMintCnt() < TAIL_RANDOM_WORDID) return HEAD_RANDOM_WORDID % TAIL_RANDOM_WORDID;\\n        else return uint16(_getRandomWordMintCnt());\\n    }\\n\\n    /** @dev Set the initial point of the random wordId mapping, using the 1st minter's address and the timestamp\\n     */\\n    function _setHeadWordId()\\n        private\\n    {\\n        HEAD_RANDOM_WORDID = uint16(uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender)))) % TAIL_RANDOM_WORDID;\\n    }\\n\\n    /** @dev Called by #mintWhitelistWord and #mintPublicWord to mint random words\\n     * @param to Address to mint the tokens to\\n     */\\n    function _mintRandomWord(address to)\\n        private\\n    {\\n        if((totalSupply() - totalWordGiveaway) == 0) _setHeadWordId();\\n\\n        HEAD_RANDOM_WORDID = uint16(HEAD_RANDOM_WORDID.add(1));\\n        _mintWord(to, _getCurWordId(), _getCurWordTimestamp());\\n    }\\n\\n    /** @dev Called by #mintGiveawayWord to mint the designated words\\n     * @param to Address to mint the tokens to\\n     * @param designatedWordId Designated wordId of the giveaway tokens\\n     * @param mintTimestamp Timestamp to start the countdown for expiration, since the receiver might not be able to start \\n     */\\n    function _mintDesignatedWord(\\n        address to, \\n        uint16 designatedWordId,\\n        uint48 mintTimestamp\\n    )\\n        private\\n    {\\n        require(designatedWordId >= DESIGNATED_WORDID_OFFSET, \\\"Invalid wordId - This Id belongs to random Id\\\");\\n        _mintWord(to, designatedWordId, mintTimestamp);\\n    }\\n\\n    /** @dev Called by #_mintDesignatedWord and #_mintRandomWord to mint tokens\\n     * @param to Address to mint the tokens to\\n     * @param wordId wordId of the tokens\\n     * @param mintTimestamp Timestamp to start the countdown for expiration, since the receiver might not be able to start \\n     */\\n    function _mintWord(\\n        address to,\\n        uint16 wordId,\\n        uint48 mintTimestamp\\n    )\\n        private\\n    {\\n        string memory nullString;\\n\\n        _safeMint(to, 1);\\n\\n        tokenItem[totalSupply().sub(1)] = TokenInfo(nullString, nullString, nullString, wordId, 1, 1, 1, mintTimestamp, false);\\n    }\\n    \\n    /** @dev Called by #mintGiveawayWord to record dictionary addon of an address\\n     * @param to Address to record dictionary addon\\n     * @param addon True or False, of whether the address wants to purchase the addon\\n     */\\n    function _mintPublicDictionary(\\n        address to,\\n        bool addon\\n    )\\n        private\\n    {\\n        _mintDictionary(to, addon, false);\\n    }\\n\\n    /** @dev Called by #mintPublicWord and #mintWhitelistWord to record giveaway dictionary addon of an address\\n     * @param to Address to record dictionary addon\\n     * @param addon True or False, of whether the address wants to purchase the addon\\n     */\\n    function _mintGiveawayDictionary(\\n        address to,\\n        bool addon\\n    )\\n        private\\n    {\\n        _mintDictionary(to, addon, true);\\n    }\\n\\n    /** @dev Called by #_mintPublicDictionary and #_mintGiveawayDictionary to record dictionary addon of an address\\n     * @param to Address to record dictionary addon\\n     * @param addon True or False, whether the address wants to purchase the addon\\n     * @param giveaway True or False, whether to check the msg.value \\n     *\\n     * A = Purchase addon dictionary\\n     * B = Check addon status if caller address purchased already\\n     * T_A, T_B => No need msg.value, No modification of addon status\\n     * F_A, T_B => No need msg.value, No modification of addon status\\n     * T_A, F_B => Need msg.value, Modification of addon status\\n     * F_A, F_B => No need msg.value, No modification of addon status\\n     *\\n     */\\n    function _mintDictionary(\\n        address to,\\n        bool addon,\\n        bool giveaway\\n    )\\n        private\\n    {\\n        require(totalDictionary.add(1) <= MAX_MINTVERSE_DICTIONARY, \\\"Exceed maximum dictionary amount\\\");\\n        if((addon == true) && !(purchaseDictionaryCheckByAddress[to])) {\\n            if(giveaway == false) require(msg.value == DICT_ADDON_PRICE, \\\"Not the right amount of ether\\\");\\n            totalDictionary = uint16(totalDictionary.add(1));\\n            purchaseDictionaryCheckByAddress[to] = addon;\\n        }\\n    }\\n\\n    /**\\n     * Define Functions\\n     */\\n    /** @dev Define word token as token owner wants\\n     * @param tokenId TokenId that the token owner wants to define\\n     * @param definer \u9444\u9020\u8005\\n     * @param partOfSpeech1 \u8a5e\u60271\\n     * @param partOfSpeech2 \u8a5e\u60272\\n     * @param relatedWord \u540c\u7fa9\u8a5e\\n     * @param description \u8a6e\u91cb\\n     */\\n    function defineWord(\\n        uint256 tokenId, \\n        string calldata definer, \\n        uint8 partOfSpeech1,\\n        uint8 partOfSpeech2,\\n        string calldata relatedWord, \\n        string calldata description\\n    )\\n        external \\n        override\\n        onlyTokenOwner(tokenId)\\n        wordNotExpired(tokenId)\\n    {\\n        tokenItem[tokenId].definerPart = definer;\\n        tokenItem[tokenId].relatedWordPart = relatedWord;\\n        tokenItem[tokenId].descriptionPart = description;\\n        tokenItem[tokenId].partOfSpeechPart1 = partOfSpeech1;\\n        tokenItem[tokenId].partOfSpeechPart2 = partOfSpeech2;\\n        tokenItem[tokenId].defined = true;\\n        if (tokenItem[tokenId].categoryPart == 2) tokenItem[tokenId].categoryPart = 1;\\n\\n        emit wordDefinedEvent(tokenId);\\n    }\\n\\n    /**\\n     * Getter Functions\\n     */\\n    /** @dev Retrieve word definition metadata by tokenId\\n     * @param tokenId TokenId which caller wants to get its metadata\\n     */\\n    function getTokenProperties(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (\\n            string memory definer, \\n            uint256 wordId,\\n            uint256 categoryId,\\n            uint256 partOfSpeechId1,\\n            uint256 partOfSpeechId2,\\n            string memory relatedWord,\\n            string memory description\\n        )\\n    {   \\n        return (\\n            tokenItem[tokenId].definerPart,\\n            tokenItem[tokenId].wordPart,\\n            tokenItem[tokenId].categoryPart,\\n            tokenItem[tokenId].partOfSpeechPart1,\\n            tokenItem[tokenId].partOfSpeechPart2,\\n            tokenItem[tokenId].relatedWordPart,\\n            tokenItem[tokenId].descriptionPart\\n        );\\n    }\\n\\n    /** @dev Retrieve expiration timestamp of a token by tokenId\\n     * @param tokenId TokenId which caller wants to get its expiration timestamp\\n     */\\n    function getTokenExpirationTime(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns(uint256 expirationTime)\\n    {\\n        return tokenItem[tokenId].mintTime.add(WORD_EXPIRATION_TIME);\\n    }\\n\\n    /** @dev Retrieve the status whether a token has been written by tokenId\\n     * @param tokenId TokenId which caller wants to get its status of written or not\\n     */\\n    function getTokenStatus(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns(bool writtenOrNot)\\n    {\\n        return tokenItem[tokenId].defined;\\n    }\\n\\n    /** @dev Retrieve all word definition metadatas by owner address\\n     * @param owner Address which caller wants to get all of its metadatas of tokens\\n     */\\n    function getTokenPropertiesByOwner(address owner) \\n        public \\n        view \\n        override\\n        returns (TokenInfo[] memory tokenInfos)\\n    {\\n        uint256 tokenCount = balanceOf(owner);\\n        if (tokenCount == 0) {\\n            // Return an empty array\\n            return new TokenInfo[](0);\\n        } else {\\n            TokenInfo[] memory result = new TokenInfo[](tokenCount);\\n            for (uint256 index = 0; index < tokenCount; index++) {\\n                uint256 tokenId = tokenOfOwnerByIndex(owner, index);\\n                result[index] = tokenItem[tokenId];\\n            }\\n            return result;\\n        }\\n    }\\n\\n    /** @dev Retrieve all expiration timestamps by owner address\\n     * @param owner Address which caller wants to get all of its expiration timestamps of tokens\\n     */\\n    function getTokenExpirationTimeByOwner(address owner) \\n        public \\n        view \\n        override\\n        returns (uint256[] memory expirationTimes)\\n    {\\n        uint256 tokenCount = balanceOf(owner);\\n        if (tokenCount == 0) {\\n            // Return an empty array\\n            return new uint256[](0);\\n        } else {\\n            uint256[] memory result = new uint256[](tokenCount);\\n            for (uint256 index = 0; index < tokenCount; index++) {\\n                uint256 tokenId = tokenOfOwnerByIndex(owner, index);\\n                result[index] = tokenItem[tokenId].mintTime.add(WORD_EXPIRATION_TIME);\\n            }\\n            return result;\\n        }\\n    }\\n\\n    /** @dev Retrieve all defined status of the word tokens by owner address\\n     * @param owner Address which caller wants to get all its word token defined statuses\\n     */\\n    function getTokenStatusByOwner(address owner) \\n        public \\n        view \\n        override\\n        returns (bool[] memory writtenOrNot)\\n    {\\n        uint256 tokenCount = balanceOf(owner);\\n        if (tokenCount == 0) {\\n            // Return an empty array\\n            return new bool[](0);\\n        } else {\\n            bool[] memory result = new bool[](tokenCount);\\n            for (uint256 index = 0; index < tokenCount; index++) {\\n                uint256 tokenId = tokenOfOwnerByIndex(owner, index);\\n                result[index] = tokenItem[tokenId].defined;\\n            }\\n            return result;\\n        }\\n    }\\n\\n    /** @dev Retrieve if a address has purchased the dictionary\\n     * @param owner Address which caller wants to get if it has purchased the dictionary\\n     */\\n    function getAddonStatusByOwner(address owner) \\n        public \\n        view \\n        override\\n        returns (bool addon)\\n    {\\n        return purchaseDictionaryCheckByAddress[owner];\\n    }\\n\\n    /**\\n     * Token Functions\\n     */\\n    /** @dev Retrieve token URI to get the metadata of a token\\n     * @param tokenId TokenId which caller wants to get the metadata of\\n     */\\n\\tfunction tokenURI(uint256 tokenId) \\n        public \\n        view \\n        override \\n        returns (string memory curTokenURI) \\n    {\\n\\t\\trequire(_exists(tokenId), \\\"Token doesn't exist\\\");\\n\\t\\treturn string(abi.encodePacked(baseTokenURI, tokenId.toString()));\\n\\t}\\n\\n    /** @dev Retrieve all tokenIds of a given address\\n     * @param owner Address which caller wants to get all of its tokenIds\\n     */\\n    function tokensOfOwner(address owner) \\n        external \\n        view \\n        override\\n        returns(uint256[] memory) \\n    {\\n        uint256 tokenCount = balanceOf(owner);\\n        if (tokenCount == 0) {\\n            // Return an empty array\\n            return new uint256[](0);\\n        } else {\\n            uint256[] memory result = new uint256[](tokenCount);\\n            for (uint256 index = 0; index < tokenCount; index++) {\\n                result[index] = tokenOfOwnerByIndex(owner, index);\\n            }\\n            return result;\\n        }\\n    }\\n\\n    /** @dev Retrieve dictionary tokens supply amount\\n     */\\n    function getTotalDictionary() \\n        public\\n        view\\n        override \\n        returns (uint256 amount)\\n    {\\n        return uint256(totalDictionary);\\n    }\\n\\n    /** @dev Retrieve all tokenIds of a given address\\n     * @param startTokenId Address which caller wants to get all of its tokenIds\\n     * @param endTokenId test\\n     * If the token is undefined & have passed 42 hours after mint time, then we settle the token\\n     */\\n    function settleExpiredWord(\\n        uint256 startTokenId, \\n        uint256 endTokenId\\n    )\\n        override\\n        external\\n        onlyOwner\\n    {\\n        for(uint256 index = startTokenId; index <= endTokenId; index++) {\\n            if(!(tokenItem[index].defined) && (block.timestamp > (tokenItem[index].mintTime + WORD_EXPIRATION_TIME))) {\\n                emit moveWordToTheBack(SETTLE_HEAD_TOKENID, tokenItem[index].wordPart);\\n                SETTLE_HEAD_TOKENID = uint16(SETTLE_HEAD_TOKENID.add(1));\\n                MAX_MINTVERSE_RANDOM_WORD = MAX_MINTVERSE_RANDOM_WORD.add(1);\\n            }\\n        }\\n    }\\n\\n    /** @dev Set the status of whitelist mint phase and its starting time\\n     * @param _hasWLMintStarted True if the whitelist mint phase have started, otherwise false\\n     * @param _wlMintTimestamp After this timestamp the whitelist mint phase will be enabled\\n     */\\n    function setWLMintPhase(\\n        bool _hasWLMintStarted, \\n        uint256 _wlMintTimestamp\\n    ) \\n        override \\n        external \\n        onlyOwner \\n    {\\n        mintWhitelistEnable = _hasWLMintStarted;\\n        mintWhitelistTimestamp = _wlMintTimestamp;\\n    }\\n\\n    /** @dev Set the status of public mint phase and its starting time\\n     * @param _hasPublicMintStarted True if the public mint phase have started, otherwise false\\n     * @param _publicMintTimestamp After this timestamp the public mint phase will be enabled\\n     */\\n    function setPublicMintPhase(\\n        bool _hasPublicMintStarted, \\n        uint256 _publicMintTimestamp\\n    ) \\n        override \\n        external \\n        onlyOwner \\n    {\\n        mintPublicEnable = _hasPublicMintStarted;\\n        mintPublicTimestamp = _publicMintTimestamp;\\n    }\\n\\n    /** @dev Set the price to purchase dictionary tokens.\\n     * @param price New price that caller wants to set as the price of dictionary tokens\\n     */\\n    function setDictPrice(uint256 price) \\n        override \\n        external \\n        onlyOwner \\n    {\\n        DICT_ADDON_PRICE = price;\\n    }\\n\\n    /** @dev Set the timestamp to start the expiration countdown\\n     * @param newRevealTimestamp Timestamp to set as the new reveal timestamp\\n     */\\n    function setRevealTimestamp(uint48 newRevealTimestamp)\\n        override\\n        external\\n        onlyOwner\\n    {\\n        revealTimestamp = newRevealTimestamp;\\n    }\\n\\n    /** @dev Set the timestamp period use to calculate if a token is expired\\n     * @param newExpirationPeriod Timestamp to set as the new expiration period\\n     */\\n    function setExpirationTime(uint48 newExpirationPeriod)\\n        override\\n        external\\n        onlyOwner\\n    {\\n        WORD_EXPIRATION_TIME = newExpirationPeriod;\\n    }\\n\\n    /** @dev Set the categoryId of a specific token\\n     * @param tokenId TokenId that owner wants to set categoryId\\n     * @param categoryId CategoryId that owner wants to set the token to\\n     */\\n    function setCategoryByTokenId(\\n        uint256 tokenId, \\n        uint8 categoryId\\n    ) \\n        override\\n        external\\n        onlyOwner\\n    {\\n        tokenItem[tokenId].categoryPart = categoryId;\\n    }\\n\\n    /** @dev Set the maximum supply of random word tokens.\\n     * @param amount Maximum amount of random word tokens\\n     */\\n    function setMaxRandomWordTokenAmt(uint256 amount) \\n        override \\n        external \\n        onlyOwner \\n    {\\n        MAX_MINTVERSE_RANDOM_WORD = amount;\\n    }\\n\\n    /** @dev Set the maximum supply of giveaway word tokens.\\n     * @param amount Maximum amount of giveaway word tokens\\n     */\\n    function setMaxGiveawayWordTokenAmt(uint256 amount)\\n        override \\n        external \\n        onlyOwner \\n    {\\n        MAX_MINTVERSE_GIVEAWAY_WORD = amount;\\n    }\\n\\n    /** @dev Set the maximum supply of dictionary tokens.\\n     * @param amount Maximum amount of dictionary tokens\\n     */\\n    function setMaxDictAmt(uint256 amount) \\n        override \\n        external \\n        onlyOwner \\n    {\\n        MAX_MINTVERSE_DICTIONARY = amount;\\n    }\\n\\n    /** @dev Set the index of the head of random word token\\n     * @param index New index to set as the head index\\n     */\\n    function setHeadRandomWordId(uint16 index) \\n        override \\n        external \\n        onlyOwner\\n    {\\n        HEAD_RANDOM_WORDID = index;\\n    }\\n\\n    /** @dev Set the index of the tail of random word token\\n     * @param index New index to set as the tail index\\n     */\\n    function setTailRandomWordId(uint16 index)\\n        override \\n        external \\n        onlyOwner\\n    {\\n        TAIL_RANDOM_WORDID = index;\\n    }\\n\\n    /** @dev Set the index of the head of settle word token\\n     * @param index New index to set as the settle head index\\n     */\\n    function setSettleHeadRandomWordId(uint16 index)\\n        override \\n        external \\n        onlyOwner\\n    {\\n        SETTLE_HEAD_TOKENID = index;\\n    }   \\n\\n    /** @dev Set the offset amount of the designated wordId\\n     * @param offsetAmount Amount to set as the new offset amount\\n     */\\n    function setWordIdOffset(uint16 offsetAmount)\\n        override \\n        external \\n        onlyOwner\\n    {\\n        DESIGNATED_WORDID_OFFSET = offsetAmount;\\n    }\\n\\n    /** @dev Set the wordId of a specific token\\n     * @param tokenId TokenId that owner wants to set its wordId\\n     * @param wordId WordId that owner wants to set its tokens to\\n     */\\n    function setTokenWordIdByTokenId(\\n        uint256 tokenId, \\n        uint16 wordId\\n    )\\n        override \\n        external \\n        onlyOwner\\n    {\\n        tokenItem[tokenId].wordPart = wordId;\\n    }\\n\\n    /** @dev Set the timestamp of a specific token\\n     * @param tokenId TokenId that owner wants to set its mint timestamp\\n     * @param mintTimestamp Mint timestamp that owner wants to set its tokens to\\n     */\\n    function setTokenMintTimeByTokenId(\\n        uint256 tokenId, \\n        uint48 mintTimestamp\\n    ) \\n        override \\n        external \\n        onlyOwner\\n    {\\n        tokenItem[tokenId].mintTime = mintTimestamp;\\n    }\\n\\n    /** @dev Set the defined status of a specific token\\n     * @param tokenId TokenId that owner wants to set its defined status\\n     * @param definedOrNot Defined status that owner wants to set its tokens to\\n     */\\n    function setTokenDefineStatusByTokenId(\\n        uint256 tokenId, \\n        bool definedOrNot\\n    )\\n        override \\n        external \\n        onlyOwner\\n    {\\n        tokenItem[tokenId].defined = definedOrNot;\\n    }\\n\\n    /** @dev Set the URI for tokenURI, which returns the metadata of token.\\n     * @param newBaseTokenURI New URI that caller wants to set as tokenURI\\n     */\\n    function setBaseTokenURI(string calldata newBaseTokenURI) \\n        override \\n        external \\n        onlyOwner \\n    {\\n\\t\\tbaseTokenURI = newBaseTokenURI;\\n\\t}\\n\\n    /** @dev Set the URI for legalDocumentURI, which returns the URI of legal document.\\n     * @param newLegalDocumentURI New URI that caller wants to set as legalDocumentURI\\n     */\\n    function setLegalDocumentURI(string calldata newLegalDocumentURI) \\n        override \\n        external \\n        onlyOwner \\n    {\\n\\t\\tlegalDocumentURI = newLegalDocumentURI;\\n\\t}\\n\\n    /** @dev Set the URI for systemMechanismDocumentURI, which returns the URI of system mechanicsm document.\\n     * @param newSystemMechanismDocumentURI New URI that caller wants to set as systemMechanismDocumentURI\\n     */\\n    function setSystemMechanismDocumentURI(string calldata newSystemMechanismDocumentURI) \\n        override \\n        external \\n        onlyOwner \\n    {\\n\\t\\tsystemMechanismDocumentURI = newSystemMechanismDocumentURI;\\n\\t}\\n\\n    /** @dev Set the URI for animationCodeDocumentURI, which returns the URI of animation code.\\n     * @param newAnimationCodeDocumentURI New URI that caller wants to set as animationCodeDocumentURI\\n     */\\n    function setAnimationCodeDocumentURI(string calldata newAnimationCodeDocumentURI) \\n        override \\n        external \\n        onlyOwner \\n    {\\n\\t\\tanimationCodeDocumentURI = newAnimationCodeDocumentURI;\\n\\t}\\n\\n    /** @dev Set the URI for visualRebuildDocumentURI, which returns the URI of visual rebuild document.\\n     * @param newVisualRebuildDocumentURI New URI that caller wants to set as visualRebuildDocumentURI\\n     */\\n    function setVisualRebuildDocumentURI(string calldata newVisualRebuildDocumentURI) \\n        override \\n        external \\n        onlyOwner \\n    {\\n\\t\\tvisualRebuildDocumentURI = newVisualRebuildDocumentURI;\\n\\t}\\n\\n    /** @dev Set the URI for ERC721ATechinalDocumentURI, which returns the URI of ERC721A technical document.\\n     * @param newERC721ATechinalDocumentURI New URI that caller wants to set as ERC721ATechinalDocumentURI\\n     */\\n    function setERC721ATechinalDocumentURI(string calldata newERC721ATechinalDocumentURI) \\n        override \\n        external \\n        onlyOwner \\n    {\\n\\t\\tERC721ATechinalDocumentURI = newERC721ATechinalDocumentURI;\\n\\t}\\n\\n    /** @dev Set the URI for wordIdMappingDocumnetURI, which returns the URI of wordId mapping document.\\n     * @param newWordIdMappingDocumnetURI New URI that caller wants to set as wordIdMappingDocumnetURI\\n     */\\n    function setWordIdMappingDocumnetURI(string calldata newWordIdMappingDocumnetURI) \\n        override \\n        external \\n        onlyOwner \\n    {\\n\\t\\twordIdMappingDocumnetURI = newWordIdMappingDocumnetURI;\\n\\t}\\n\\n    /** @dev Set the URI for partOfSpeechIdMappingDocumentURI, which returns the URI of partOfSpeechId mapping document.\\n     * @param newPartOfSpeechIdMappingDocumentURI New URI that caller wants to set as partOfSpeechIdMappingDocumentURI\\n     */\\n    function setPartOfSpeechIdMappingDocumentURI(string calldata newPartOfSpeechIdMappingDocumentURI) \\n        override \\n        external \\n        onlyOwner \\n    {\\n\\t\\tpartOfSpeechIdMappingDocumentURI = newPartOfSpeechIdMappingDocumentURI;\\n\\t}\\n\\n    /** @dev Set the URI for categoryIdMappingDocumentURI, which returns the URI of categoryId mapping document.\\n     * @param newCategoryIdMappingDocumentURI New URI that caller wants to set as categoryIdMappingDocumentURI\\n     */\\n    function setCategoryIdMappingDocumentURI(string calldata newCategoryIdMappingDocumentURI) \\n        override \\n        external \\n        onlyOwner \\n    {\\n\\t\\tcategoryIdMappingDocumentURI = newCategoryIdMappingDocumentURI;\\n\\t}\\n\\n    /** @dev Set the URI for metadataMappingDocumentURI, which returns the URI of metadata mapping document.\\n     * @param newMetadataMappingDocumentURI New URI that caller wants to set as metadataMappingDocumentURI\\n     */\\n    function setMetadataMappingDocumentURI(string calldata newMetadataMappingDocumentURI) \\n        override \\n        external \\n        onlyOwner \\n    {\\n\\t\\tmetadataMappingDocumentURI = newMetadataMappingDocumentURI;\\n\\t}\\n\\n    /** @dev Set the address that act as treasury and recieve all the fund from token contract.\\n     * @param _treasury New address that caller wants to set as the treasury address\\n     */\\n    function setTreasury(address _treasury) \\n        override \\n        external \\n        onlyOwner \\n    {\\n        require(_treasury != address(0), \\\"Invalid address - Zero address\\\");\\n        treasury = _treasury;\\n    }\\n\\n    /**\\n     * Withdrawal Functions\\n     */\\n    /** @dev Set the maximum supply of dictionary tokens.\\n     */\\n\\tfunction withdrawAll() \\n        override \\n        external \\n        payable \\n        onlyOwner \\n    {\\n\\t\\tpayable(treasury).transfer(address(this).balance);\\n\\t}\\n}\"\r\n    },\r\n    \"contracts/libraries/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\\nimport '@openzeppelin/contracts/utils/Address.sol';\\nimport '@openzeppelin/contracts/utils/Context.sol';\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\\n\\nerror ApprovalCallerNotOwnerNorApproved();\\nerror ApprovalQueryForNonexistentToken();\\nerror ApproveToCaller();\\nerror ApprovalToCurrentOwner();\\nerror BalanceQueryForZeroAddress();\\nerror MintedQueryForZeroAddress();\\nerror BurnedQueryForZeroAddress();\\nerror MintToZeroAddress();\\nerror MintZeroQuantity();\\nerror OwnerIndexOutOfBounds();\\nerror OwnerQueryForNonexistentToken();\\nerror TokenIndexOutOfBounds();\\nerror TransferCallerNotOwnerNorApproved();\\nerror TransferFromIncorrectOwner();\\nerror TransferToNonERC721ReceiverImplementer();\\nerror TransferToZeroAddress();\\nerror URIQueryForNonexistentToken();\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata and Enumerable extension. Built to optimize for lower gas during batch mints.\\n *\\n * Assumes serials are sequentially minted starting at 0 (e.g. 0, 1, 2, 3..).\\n *\\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n *\\n * Assumes that the maximum token id cannot exceed 2**128 - 1 (max value of uint128).\\n */\\ncontract ERC721A is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Compiler will pack this into a single 256bit word.\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n    }\\n\\n    // Compiler will pack this into a single 256bit word.\\n    struct AddressData {\\n        // Realistically, 2**64-1 is more than enough.\\n        uint64 balance;\\n        // Keeps track of mint count with minimal overhead for tokenomics.\\n        uint64 numberMinted;\\n        // Keeps track of burn count with minimal overhead for tokenomics.\\n        uint64 numberBurned;\\n    }\\n\\n    // Compiler will pack the following \\n    // _currentIndex and _burnCounter into a single 256bit word.\\n    \\n    // The tokenId of the next token to be minted.\\n    uint128 internal _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint128 internal _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.\\n    mapping(uint256 => TokenOwnership) internal _ownerships;\\n\\n    // Mapping owner address to address data\\n    mapping(address => AddressData) private _addressData;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than _currentIndex times\\n        unchecked {\\n            return _currentIndex - _burnCounter;    \\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     * This read function is O(totalSupply). If calling from a separate contract, be sure to test gas first.\\n     * It may also degrade with extremely large collection sizes (e.g >> 10000), test for your use case.\\n     */\\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\\n        uint256 numMintedSoFar = _currentIndex;\\n        uint256 tokenIdsIdx;\\n\\n        // Counter overflow is impossible as the loop breaks when\\n        // uint256 i is equal to another uint256 numMintedSoFar.\\n        unchecked {\\n            for (uint256 i; i < numMintedSoFar; i++) {\\n                TokenOwnership memory ownership = _ownerships[i];\\n                if (!ownership.burned) {\\n                    if (tokenIdsIdx == index) {\\n                        return i;\\n                    }\\n                    tokenIdsIdx++;\\n                }\\n            }\\n        }\\n        revert TokenIndexOutOfBounds();\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     * This read function is O(totalSupply). If calling from a separate contract, be sure to test gas first.\\n     * It may also degrade with extremely large collection sizes (e.g >> 10000), test for your use case.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\\n        if (index >= balanceOf(owner)) revert OwnerIndexOutOfBounds();\\n        uint256 numMintedSoFar = _currentIndex;\\n        uint256 tokenIdsIdx;\\n        address currOwnershipAddr;\\n\\n        // Counter overflow is impossible as the loop breaks when\\n        // uint256 i is equal to another uint256 numMintedSoFar.\\n        unchecked {\\n            for (uint256 i; i < numMintedSoFar; i++) {\\n                TokenOwnership memory ownership = _ownerships[i];\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    if (tokenIdsIdx == index) {\\n                        return i;\\n                    }\\n                    tokenIdsIdx++;\\n                }\\n            }\\n        }\\n\\n        // Execution should never reach this point.\\n        revert();\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            interfaceId == type(IERC721Enumerable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return uint256(_addressData[owner].balance);\\n    }\\n\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        if (owner == address(0)) revert MintedQueryForZeroAddress();\\n        return uint256(_addressData[owner].numberMinted);\\n    }\\n\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        if (owner == address(0)) revert BurnedQueryForZeroAddress();\\n        return uint256(_addressData[owner].numberBurned);\\n    }\\n\\n    /**\\n     * Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\\n     */\\n    function ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (curr < _currentIndex) {\\n                TokenOwnership memory ownership = _ownerships[curr];\\n                if (!ownership.burned) {\\n                    if (ownership.addr != address(0)) {\\n                        return ownership;\\n                    }\\n                    // Invariant: \\n                    // There will always be an ownership that has an address and is not burned \\n                    // before an ownership that does not have an address and is not burned.\\n                    // Hence, curr will not underflow.\\n                    while (true) {\\n                        curr--;\\n                        ownership = _ownerships[curr];\\n                        if (ownership.addr != address(0)) {\\n                            return ownership;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return ownershipOf(tokenId).addr;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public override {\\n        address owner = ERC721A.ownerOf(tokenId);\\n        if (to == owner) revert ApprovalToCurrentOwner();\\n\\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\\n            revert ApprovalCallerNotOwnerNorApproved();\\n        }\\n\\n        _approve(to, tokenId, owner);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public override {\\n        if (operator == _msgSender()) revert ApproveToCaller();\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        _transfer(from, to, tokenId);\\n        if (!_checkOnERC721Received(from, to, tokenId, _data)) {\\n            revert TransferToNonERC721ReceiverImplementer();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return tokenId < _currentIndex && !_ownerships[tokenId].burned;\\n    }\\n\\n    function _safeMint(address to, uint256 quantity) internal {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal {\\n        _mint(to, quantity, _data, true);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data,\\n        bool safe\\n    ) internal {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // balance or numberMinted overflow if current value of either + quantity > 3.4e38 (2**128) - 1\\n        // updatedIndex overflows if _currentIndex + quantity > 3.4e38 (2**128) - 1\\n        unchecked {\\n            _addressData[to].balance += uint64(quantity);\\n            _addressData[to].numberMinted += uint64(quantity);\\n\\n            _ownerships[startTokenId].addr = to;\\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\\n\\n            uint256 updatedIndex = startTokenId;\\n\\n            for (uint256 i; i < quantity; i++) {\\n                emit Transfer(address(0), to, updatedIndex);\\n                if (safe && !_checkOnERC721Received(address(0), to, updatedIndex, _data)) {\\n                    revert TransferToNonERC721ReceiverImplementer();\\n                }\\n                updatedIndex++;\\n            }\\n\\n            _currentIndex = uint128(updatedIndex);\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) private {\\n        TokenOwnership memory prevOwnership = ownershipOf(tokenId);\\n\\n        bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr ||\\n            isApprovedForAll(prevOwnership.addr, _msgSender()) ||\\n            getApproved(tokenId) == _msgSender());\\n\\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\\n        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId, prevOwnership.addr);\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**128.\\n        unchecked {\\n            _addressData[from].balance -= 1;\\n            _addressData[to].balance += 1;\\n\\n            _ownerships[tokenId].addr = to;\\n            _ownerships[tokenId].startTimestamp = uint64(block.timestamp);\\n\\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\\n            uint256 nextTokenId = tokenId + 1;\\n            if (_ownerships[nextTokenId].addr == address(0)) {\\n                // This will suffice for checking _exists(nextTokenId),\\n                // as a burned slot cannot contain the zero address.\\n                if (nextTokenId < _currentIndex) {\\n                    _ownerships[nextTokenId].addr = prevOwnership.addr;\\n                    _ownerships[nextTokenId].startTimestamp = prevOwnership.startTimestamp;\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        TokenOwnership memory prevOwnership = ownershipOf(tokenId);\\n\\n        _beforeTokenTransfers(prevOwnership.addr, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId, prevOwnership.addr);\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**128.\\n        unchecked {\\n            _addressData[prevOwnership.addr].balance -= 1;\\n            _addressData[prevOwnership.addr].numberBurned += 1;\\n\\n            // Keep track of who burned the token, and the timestamp of burning.\\n            _ownerships[tokenId].addr = prevOwnership.addr;\\n            _ownerships[tokenId].startTimestamp = uint64(block.timestamp);\\n            _ownerships[tokenId].burned = true;\\n\\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\\n            uint256 nextTokenId = tokenId + 1;\\n            if (_ownerships[nextTokenId].addr == address(0)) {\\n                // This will suffice for checking _exists(nextTokenId),\\n                // as a burned slot cannot contain the zero address.\\n                if (nextTokenId < _currentIndex) {\\n                    _ownerships[nextTokenId].addr = prevOwnership.addr;\\n                    _ownerships[nextTokenId].startTimestamp = prevOwnership.startTimestamp;\\n                }\\n            }\\n        }\\n\\n        emit Transfer(prevOwnership.addr, address(0), tokenId);\\n        _afterTokenTransfers(prevOwnership.addr, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked { \\n            _burnCounter++;\\n        }\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(\\n        address to,\\n        uint256 tokenId,\\n        address owner\\n    ) private {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert TransferToNonERC721ReceiverImplementer();\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\\n     * minting.\\n     * And also called after one token has been burned.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n}\"\r\n    },\r\n    \"contracts/interfaces/IWord.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IWord {\\n    struct TokenInfo {\\n        string definerPart;\\n        string relatedWordPart;\\n        string descriptionPart;\\n\\n        uint16 wordPart;\\n        uint8 categoryPart; // 1: Genesis Card, 2: Special Card, 3. Censored Card\\n        uint8 partOfSpeechPart1;\\n        uint8 partOfSpeechPart2;\\n\\n        uint48 mintTime;\\n        bool defined;\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IMintverseWord.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IWord.sol\\\";\\n\\ninterface IMintverseWord is IWord {\\n    // Return true if the minter is eligible to claim the given amount word token with the signature.\\n    function verify(uint256 maxQuantity, bytes calldata SIGNATURE) external view returns(bool);\\n    // Changes the addon status of an address by owner.\\n    function mintGiveawayDictionary(address to, bool addon) external;\\n    // Mints tokens to an address with specific wordId by owner. \\n    function mintGiveawayWord(address to, uint16 wordId, uint48 mintTimestamp) external;\\n    // Whitelisted addresses mint specific amount of tokens with signature & maximum mintable amount to verify.\\n    function mintWhitelistWord(uint256 quantity, uint256 maxClaimNum, bool addon, bytes calldata SIGNATURE) external payable;\\n    // Public addresses mint specific amount of tokens.\\n    function mintPublicWord(bool addon) external payable;\\n    // Word token owners send five parameters to define the word.\\n    function defineWord(uint256 tokenId, string calldata definer, uint8 partOfSpeech1, uint8 partOfSpeech2, string calldata relatedWord, string calldata description) external;\\n\\n    // Add the wordId to the end of random word bank.\\n    function settleExpiredWord(uint256 startTokenId, uint256 endTokenId) external;\\n\\n    // View function to get the metadata of a specific token with tokenId.\\n    function getTokenProperties(uint256 tokenId) external view returns(string memory definer, uint256 wordId, uint256 categoryId, uint256 partOfSpeechId1, uint256 partOfSpeechId2, string memory relatedWord, string memory description);\\n    // View function to get the expired timestamp of a specific token with tokenId.\\n    function getTokenExpirationTime(uint256 tokenId) external view returns(uint256 expirationTime);\\n    // View function to get the status(dead or alive) of a specific token with tokenId.\\n    function getTokenStatus(uint256 tokenId) external view returns(bool writtenOrNot);\\n    // View function to get all the metadatas of the word tokens of the given address.\\n    function getTokenPropertiesByOwner(address owner) external view returns(TokenInfo[] memory tokenInfos);\\n    // View function to get all the expired timestamps of the word tokens of the given address.\\n    function getTokenExpirationTimeByOwner(address owner) external view returns(uint256[] memory expirationTimes);\\n    // View function to get all the status(dead or alive) of the word tokens of the given address.\\n    function getTokenStatusByOwner(address owner) external view returns(bool[] memory writtenOrNot);\\n    // View function to check if the given address has purchased the addon dictionary.\\n    function getAddonStatusByOwner(address owner) external view returns(bool addon);\\n    // View function to get all the token Id that a address owns.\\n    function tokensOfOwner(address owner) external view returns(uint256[] memory);\\n    // View function to get all the dictionary supply for dictionary contract.\\n    function getTotalDictionary() external view returns (uint256 amount);\\n\\n    // Set the variables to enable the whitelist mint phase by owner.\\n    function setWLMintPhase(bool hasWLMintStarted, uint256 wlMintTimestamp) external;\\n    // Set the variables to enable the public mint phase by owner.\\n    function setPublicMintPhase(bool hasPublicMintStarted, uint256 publicMintTimestamp) external;\\n\\n    // Set the price for minter to purchase addon dictionary.\\n    function setDictPrice(uint256 price) external;\\n    // Set the expiration time period of the token.\\n    function setExpirationTime(uint48 expirationPeriod) external;\\n    // Set the reveal timestamp to adjust tokens mint time.\\n    function setRevealTimestamp(uint48 newRevealTimestamp) external;\\n    // Set the categoryId of a specific token by tokenId.\\n    function setCategoryByTokenId(uint256 tokenId, uint8 categoryId) external;\\n\\n    // **SYSTEM EMERGENCY CALLS**\\n    // Set the maximum supply of the random tokens by owner.\\n    function setMaxRandomWordTokenAmt(uint256 amount) external;\\n    // Set the maximum supply of the giveaway tokens by owner.\\n    function setMaxGiveawayWordTokenAmt(uint256 amount) external;\\n    // Set the maximum supply of the dictionary by owner.\\n    function setMaxDictAmt(uint256 amount) external;\\n    // Set the index for head of random word.\\n    function setHeadRandomWordId(uint16 index) external;\\n    // Set the index for tail of random word.\\n    function setTailRandomWordId(uint16 index) external;\\n    // Set the index for tail of random word.\\n    function setSettleHeadRandomWordId(uint16 index) external;\\n    // Set the offset of the designated word id.\\n    function setWordIdOffset(uint16 offsetAmount) external;\\n\\n    // **TOKEN EMERGENCY CALLS**\\n    // Set the wordId of a specific token by tokenId.\\n    function setTokenWordIdByTokenId(uint256 tokenId, uint16 wordId) external;\\n    // Set the mint time of a specific token by tokenId.\\n    function setTokenMintTimeByTokenId(uint256 tokenId, uint48 mintTimestamp) external;\\n    // Set the defined status of a specific token by tokenId.\\n    function setTokenDefineStatusByTokenId(uint256 tokenId, bool definedOrNot) external;\\n\\n    // Set the URI to return the tokens metadata.\\n    function setBaseTokenURI(string calldata newBaseTokenURI) external;\\n    // Set the URI for the legal document.\\n    function setLegalDocumentURI(string calldata newLegalDocumentURI) external;\\n    // Set the URI for the system mechanism document.\\n    function setSystemMechanismDocumentURI(string calldata newSystemMechanismDocumentURI) external;\\n    // Set the URI for the animation code document.\\n    function setAnimationCodeDocumentURI(string calldata newAnimationCodeDocumentURI) external;\\n    // Set the URI for the visual rebuild method document.\\n    function setVisualRebuildDocumentURI(string calldata newVisualRebuildDocumentURI) external;\\n    // Set the URI for the erc721 technical document.\\n    function setERC721ATechinalDocumentURI(string calldata newERC721ATechinalDocumentURI) external;\\n    // Set the URI for the wordId mapping document.\\n    function setWordIdMappingDocumnetURI(string calldata newWordIdMappingDocumnetURI) external;\\n    // Set the URI for the partOfSpeechId mapping document.\\n    function setPartOfSpeechIdMappingDocumentURI(string calldata newPartOfSpeechIdMappingDocumentURI) external;\\n    // Set the URI for the categoryId mapping document.\\n    function setCategoryIdMappingDocumentURI(string calldata newCategoryIdMappingDocumentURI) external;\\n    // Set the URI for the metadata mapping document.\\n    function setMetadataMappingDocumentURI(string calldata newMetadataMappingDocumentURI) external;\\n    // Set the address to transfer the contract fund to.\\n    function setTreasury(address treasury) external;\\n    // Withdraw all the fund inside the contract to the treasury address.\\n    function withdrawAll() external payable;\\n    // This event is triggered whenever a call to #mintGiveawayWord, #mintWhitelistWord, and #mintPublicWord succeeds.\\n    event mintWordEvent(address owner, uint256 quantity, uint256 totalSupply);\\n    // This event is triggered whenever a call to #defineWord succeeds.\\n    event wordDefinedEvent(uint256 tokenId);\\n    // This event is triggered whenever a call to #settleExpiredWord succeeds.\\n    event moveWordToTheBack(uint256 oriWordId, uint256 newWordId);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n    address private immutable _CACHED_THIS;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _CACHED_THIS = address(this);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalToCurrentOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveToCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerIndexOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenIndexOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"mintWordEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oriWordId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newWordId\",\"type\":\"uint256\"}],\"name\":\"moveWordToTheBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"wordDefinedEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DESIGNATED_WORDID_OFFSET\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DICT_ADDON_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERC721ATechinalDocumentURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HEAD_RANDOM_WORDID\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_MINTVERSE_DICTIONARY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_MINTVERSE_GIVEAWAY_WORD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_MINTVERSE_RANDOM_WORD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SETTLE_HEAD_TOKENID\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TAIL_RANDOM_WORDID\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WORD_EXPIRATION_TIME\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"animationCodeDocumentURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"categoryIdMappingDocumentURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"definer\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"partOfSpeech1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"partOfSpeech2\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"relatedWord\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"defineWord\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getAddonStatusByOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"addon\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenExpirationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getTokenExpirationTimeByOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"expirationTimes\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenProperties\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"definer\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"wordId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"categoryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partOfSpeechId1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partOfSpeechId2\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"relatedWord\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getTokenPropertiesByOwner\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"definerPart\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"relatedWordPart\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"descriptionPart\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"wordPart\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"categoryPart\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"partOfSpeechPart1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"partOfSpeechPart2\",\"type\":\"uint8\"},{\"internalType\":\"uint48\",\"name\":\"mintTime\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"defined\",\"type\":\"bool\"}],\"internalType\":\"struct IWord.TokenInfo[]\",\"name\":\"tokenInfos\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"writtenOrNot\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getTokenStatusByOwner\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"writtenOrNot\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDictionary\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"legalDocumentURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadataMappingDocumentURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"addon\",\"type\":\"bool\"}],\"name\":\"mintGiveawayDictionary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"wordId\",\"type\":\"uint16\"},{\"internalType\":\"uint48\",\"name\":\"mintTimestamp\",\"type\":\"uint48\"}],\"name\":\"mintGiveawayWord\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPublicEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPublicTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"addon\",\"type\":\"bool\"}],\"name\":\"mintPublicWord\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintWhitelistEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintWhitelistTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxClaimNum\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"addon\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"SIGNATURE\",\"type\":\"bytes\"}],\"name\":\"mintWhitelistWord\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintedByAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partOfSpeechIdMappingDocumentURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"purchaseDictionaryCheckByAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealTimestamp\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newAnimationCodeDocumentURI\",\"type\":\"string\"}],\"name\":\"setAnimationCodeDocumentURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseTokenURI\",\"type\":\"string\"}],\"name\":\"setBaseTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"categoryId\",\"type\":\"uint8\"}],\"name\":\"setCategoryByTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newCategoryIdMappingDocumentURI\",\"type\":\"string\"}],\"name\":\"setCategoryIdMappingDocumentURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setDictPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newERC721ATechinalDocumentURI\",\"type\":\"string\"}],\"name\":\"setERC721ATechinalDocumentURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"newExpirationPeriod\",\"type\":\"uint48\"}],\"name\":\"setExpirationTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"setHeadRandomWordId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newLegalDocumentURI\",\"type\":\"string\"}],\"name\":\"setLegalDocumentURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxDictAmt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxGiveawayWordTokenAmt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxRandomWordTokenAmt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newMetadataMappingDocumentURI\",\"type\":\"string\"}],\"name\":\"setMetadataMappingDocumentURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newPartOfSpeechIdMappingDocumentURI\",\"type\":\"string\"}],\"name\":\"setPartOfSpeechIdMappingDocumentURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_hasPublicMintStarted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_publicMintTimestamp\",\"type\":\"uint256\"}],\"name\":\"setPublicMintPhase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"newRevealTimestamp\",\"type\":\"uint48\"}],\"name\":\"setRevealTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"setSettleHeadRandomWordId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newSystemMechanismDocumentURI\",\"type\":\"string\"}],\"name\":\"setSystemMechanismDocumentURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"setTailRandomWordId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"definedOrNot\",\"type\":\"bool\"}],\"name\":\"setTokenDefineStatusByTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"mintTimestamp\",\"type\":\"uint48\"}],\"name\":\"setTokenMintTimeByTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"wordId\",\"type\":\"uint16\"}],\"name\":\"setTokenWordIdByTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newVisualRebuildDocumentURI\",\"type\":\"string\"}],\"name\":\"setVisualRebuildDocumentURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_hasWLMintStarted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_wlMintTimestamp\",\"type\":\"uint256\"}],\"name\":\"setWLMintPhase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newWordIdMappingDocumnetURI\",\"type\":\"string\"}],\"name\":\"setWordIdMappingDocumnetURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"offsetAmount\",\"type\":\"uint16\"}],\"name\":\"setWordIdOffset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTokenId\",\"type\":\"uint256\"}],\"name\":\"settleExpiredWord\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"systemMechanismDocumentURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenItem\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"definerPart\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"relatedWordPart\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"descriptionPart\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"wordPart\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"categoryPart\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"partOfSpeechPart1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"partOfSpeechPart2\",\"type\":\"uint8\"},{\"internalType\":\"uint48\",\"name\":\"mintTime\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"defined\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"curTokenURI\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDictionary\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWordGiveaway\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWordWhitelist\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxQuantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"SIGNATURE\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"visualRebuildDocumentURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistMintAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wordIdMappingDocumnetURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MintverseWord", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}