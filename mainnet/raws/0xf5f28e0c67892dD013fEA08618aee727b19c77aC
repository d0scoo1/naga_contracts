{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"rift-protocol/src/vaults/uniswap/UniswapVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.11;\\n\\nimport \\\"../../../lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"../../../lib/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"../../../lib/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"../../../lib/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\n\\nimport \\\"../Vault.sol\\\";\\nimport \\\"./UniswapVaultStorage.sol\\\";\\n\\n/// @notice Contains the primary logic for Uniswap Vaults\\n/// @author Recursive Research Inc\\ncontract UniswapVault is Vault, UniswapVaultStorage {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    function initialize(\\n        address coreAddress,\\n        uint256 _epochDuration,\\n        address _token0,\\n        address _token1,\\n        uint256 _token0FloorNum,\\n        uint256 _token1FloorNum,\\n        address _uniswapFactory,\\n        address _uniswapRouter\\n    ) public virtual initializer {\\n        __UniswapVault_init(\\n            coreAddress,\\n            _epochDuration,\\n            _token0,\\n            _token1,\\n            _token0FloorNum,\\n            _token1FloorNum,\\n            _uniswapFactory,\\n            _uniswapRouter\\n        );\\n    }\\n\\n    function __UniswapVault_init(\\n        address coreAddress,\\n        uint256 _epochDuration,\\n        address _token0,\\n        address _token1,\\n        uint256 _token0FloorNum,\\n        uint256 _token1FloorNum,\\n        address _uniswapFactory,\\n        address _uniswapRouter\\n    ) internal onlyInitializing {\\n        __Vault_init(coreAddress, _epochDuration, _token0, _token1, _token0FloorNum, _token1FloorNum);\\n        __UniswapVault_init_unchained(_uniswapFactory, _uniswapRouter);\\n    }\\n\\n    function __UniswapVault_init_unchained(address _uniswapFactory, address _uniswapRouter) internal onlyInitializing {\\n        pair = IUniswapV2Factory(_uniswapFactory).getPair(address(token0), address(token1));\\n\\n        // require that the pair has been created\\n        require(pair != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        factory = _uniswapFactory;\\n        router = _uniswapRouter;\\n    }\\n\\n    // @dev queries the pool reserves and ensure the token ordering is correct\\n    function getPoolBalances() internal view virtual override returns (uint256, uint256) {\\n        (uint256 reservesA, uint256 reservesB, ) = IUniswapV2Pair(pair).getReserves();\\n        return IUniswapV2Pair(pair).token0() == address(token0) ? (reservesA, reservesB) : (reservesB, reservesA);\\n    }\\n\\n    // This is provided automatically by the Uniswap router\\n    function calcAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal view virtual override returns (uint256) {\\n        return IUniswapV2Router02(router).getAmountIn(amountOut, reserveIn, reserveOut);\\n    }\\n\\n    // Withdraws all liquidity\\n    // @dev We can ignore the need for frontrunning checks because the `_nextEpoch` function checks\\n    // that the pool reserves are as expected beforehand\\n    function _withdrawLiquidity() internal virtual override {\\n        uint256 lpTokenBalance = IERC20Upgradeable(pair).balanceOf(address(this));\\n        if (lpTokenBalance == 0) return;\\n\\n        // use the router to remove liquidity from the uni pool\\n        // don't need to decrease allowance afterwards because router guarantees the full amount is burned\\n        // safe to ignore return values because we check balances before and after this call\\n        IERC20Upgradeable(pair).safeIncreaseAllowance(router, lpTokenBalance);\\n        IUniswapV2Router02(router).removeLiquidity(\\n            address(token0),\\n            address(token1),\\n            lpTokenBalance,\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    // Deposits available liquidity\\n    // @dev We can ignore the need for frontrunning checks because the `_nextEpoch` function checks\\n    // that the pool reserves are as expected beforehand\\n    // `availableToken0` and `availableToken1` are also known to be greater than 0 since they are checked\\n    // by `depositLiquidity` in `Vault.sol`\\n    function _depositLiquidity(uint256 availableToken0, uint256 availableToken1)\\n        internal\\n        virtual\\n        override\\n        returns (uint256 token0Deposited, uint256 token1Deposited)\\n    {\\n        // use the router to deposit `token0` and `token1`\\n        token0.safeIncreaseAllowance(router, availableToken0);\\n        token1.safeIncreaseAllowance(router, availableToken1);\\n        // can safely ignore `liquidity` return value because when withdrawing we check our full balance\\n        (token0Deposited, token1Deposited, ) = IUniswapV2Router02(router).addLiquidity(\\n            address(token0),\\n            address(token1),\\n            availableToken0,\\n            availableToken1,\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        // if we didn't deposit the full `availableToken{x}`, reduce allowance for safety\\n        if (availableToken0 > token0Deposited) {\\n            token0.safeApprove(router, 0);\\n        }\\n        if (availableToken1 > token1Deposited) {\\n            token1.safeApprove(router, 0);\\n        }\\n    }\\n\\n    // For the default Uniswap vault this does nothing\\n    function _unstakeLiquidity() internal virtual override {}\\n\\n    // For the default Uniswap vault this does nothing\\n    function _stakeLiquidity() internal virtual override {}\\n\\n    // Swaps tokens\\n    // @dev We can ignore the need for frontrunning checks because the `_nextEpoch` function checks\\n    // that the pool reserves are as expected beforehand\\n    function swap(\\n        IERC20Upgradeable tokenIn,\\n        IERC20Upgradeable tokenOut,\\n        uint256 amountIn\\n    ) internal virtual override returns (uint256 amountOut, uint256 amountConsumed) {\\n        if (amountIn == 0) return (0, 0);\\n\\n        tokenIn.safeIncreaseAllowance(router, amountIn);\\n        amountOut = IUniswapV2Router02(router).swapExactTokensForTokens(\\n            amountIn,\\n            0,\\n            getPath(address(tokenIn), address(tokenOut)),\\n            address(this),\\n            block.timestamp\\n        )[1];\\n        amountConsumed = amountIn;\\n    }\\n\\n    /// @notice converts two addresses into an address[] type\\n    function getPath(address _from, address _to) internal pure returns (address[] memory path) {\\n        path = new address[](2);\\n        path[0] = _from;\\n        path[1] = _to;\\n    }\\n}\\n\"\r\n    },\r\n    \"rift-protocol/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"rift-protocol/lib/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"rift-protocol/lib/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"rift-protocol/lib/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"rift-protocol/src/vaults/Vault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.11;\\n\\n// Have to use SafeERC20Upgradeable instead of SafeERC20 because SafeERC20 inherits Address.sol,\\n// which uses delegeatecall functions, which are not allowed by OZ's upgrade process\\n// See more:\\n// https://forum.openzeppelin.com/t/error-contract-is-not-upgrade-safe-use-of-delegatecall-is-not-allowed/16859\\nimport \\\"../../lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"../../lib/openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"../external/IWrappy.sol\\\";\\nimport \\\"../refs/CoreReference.sol\\\";\\nimport \\\"./VaultStorage.sol\\\";\\nimport \\\"./IVault.sol\\\";\\n\\n/// @notice Contains the primary logic for vaults\\n/// @author Recursive Research Inc\\nabstract contract Vault is IVault, CoreReference, ReentrancyGuardUpgradeable, VaultStorage {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    bytes32 public constant TOKEN0 = keccak256(\\\"TOKEN0\\\");\\n    bytes32 public constant TOKEN1 = keccak256(\\\"TOKEN1\\\");\\n\\n    uint256 public constant RAY = 1e27;\\n    uint256 public constant POOL_ERR = 50; // 0.5% error margin allowed\\n    uint256 public constant DENOM = 10_000;\\n    uint256 public constant MIN_LP = 1000; // minimum amount of tokens to be deposited as LP\\n\\n    // ----------- Upgradeable Constructor Pattern -----------\\n\\n    /// Initializes the vault to point to the Core contract and configures it to have\\n    /// a given epoch duration, pair of tokens, and floor returns on each Token\\n    /// @param coreAddress address of the Core contract\\n    /// @param _epochDuration duration of the epoch in seconds\\n    /// @param _token0 address of TOKEN0\\n    /// @param _token1 address of TOKEN1\\n    /// @param _token0FloorNum the floor returns of the TOKEN0 side (out of `DENOM`). In practice,\\n    ///     10000 to guarantee lossless returns for the TOKEN0 side.\\n    /// @param _token1FloorNum the floor returns of the TOKEN1 side (out of `DENOM`). In practice,\\n    ///     500 to prevent accounting errors.\\n    function __Vault_init(\\n        address coreAddress,\\n        uint256 _epochDuration,\\n        address _token0,\\n        address _token1,\\n        uint256 _token0FloorNum,\\n        uint256 _token1FloorNum\\n    ) internal onlyInitializing {\\n        __CoreReference_init(coreAddress);\\n        __ReentrancyGuard_init();\\n        __Vault_init_unchained(_epochDuration, _token0, _token1, _token0FloorNum, _token1FloorNum);\\n    }\\n\\n    function __Vault_init_unchained(\\n        uint256 _epochDuration,\\n        address _token0,\\n        address _token1,\\n        uint256 _token0FloorNum,\\n        uint256 _token1FloorNum\\n    ) internal onlyInitializing {\\n        require(_token0FloorNum > 0, \\\"INVALID_TOKEN0_FLOOR\\\");\\n        require(_token1FloorNum > 0, \\\"INVALID_TOKEN1_FLOOR\\\");\\n\\n        isNativeVault = _token0 == core.wrappedNative();\\n\\n        token0 = IERC20Upgradeable(_token0);\\n        token1 = IERC20Upgradeable(_token1);\\n\\n        token0Data.epochToRate[0] = RAY;\\n        token1Data.epochToRate[0] = RAY;\\n        epoch = 1;\\n        epochDuration = _epochDuration;\\n        token0FloorNum = _token0FloorNum;\\n        token1FloorNum = _token1FloorNum;\\n    }\\n\\n    // ----------- Deposit Requests -----------\\n\\n    /// @notice schedules a deposit of TOKEN0 into the floor tranche\\n    /// @dev currently does not support fee on transfer / deflationary tokens.\\n    /// @param _amount the amount of the TOKEN0 to schedule-deposit if a non native vault,\\n    ///     and unused if it's a native vault. msg.value must be zero if not a native vault\\n    ///     typechain does not allow payable function overloading so we can either have 2 different\\n    ///     names or consolidate them into the same function as we do here\\n    function depositToken0(uint256 _amount) external payable override whenNotPaused nonReentrant {\\n        if (isNativeVault) {\\n            IWrappy(address(token0)).deposit{ value: msg.value }();\\n            _depositAccounting(token0Data, msg.value, TOKEN0);\\n        } else {\\n            require(msg.value == 0, \\\"NOT_NATIVE_VAULT\\\");\\n            token0.safeTransferFrom(msg.sender, address(this), _amount);\\n            _depositAccounting(token0Data, _amount, TOKEN0);\\n        }\\n    }\\n\\n    /// @notice schedules a deposit of the TOKEN1 into the ceiling tranche\\n    /// @dev currently does not support fee on transfer / deflationary tokens.\\n    /// @param _amount the amount of the TOKEN1 to schedule-deposit\\n    function depositToken1(uint256 _amount) external override whenNotPaused nonReentrant {\\n        token1.safeTransferFrom(msg.sender, address(this), _amount);\\n        _depositAccounting(token1Data, _amount, TOKEN1);\\n    }\\n\\n    /// @dev handles the accounting for scheduling deposits in a way that abstracts the logic\\n    /// @param assetData storage reference to the data for the desired asset\\n    /// @param _depositAmount the amount of the asset to deposit\\n    /// @param assetCode code for the type of asset (either `TOKEN0` or `TOKEN1`)\\n    function _depositAccounting(\\n        AssetData storage assetData,\\n        uint256 _depositAmount,\\n        bytes32 assetCode\\n    ) private {\\n        require(_depositAmount > 0, \\\"ZERO_AMOUNT\\\");\\n        uint256 currEpoch = epoch;\\n\\n        // Check their prior deposit requests and flush to balanceDay0 if needed\\n        assetData.balanceDay0[msg.sender] = __updateDepositRequests(assetData, currEpoch, _depositAmount);\\n\\n        // track total deposit requests\\n        assetData.depositRequestsTotal += _depositAmount;\\n\\n        emit DepositScheduled(assetCode, msg.sender, _depositAmount, currEpoch);\\n    }\\n\\n    /// @dev for updating the deposit requests with any new deposit amount\\n    /// or flushing the deposits to balanceDay0 if the epoch of the request has passed\\n    /// @param assetData storage reference to the data for the desired asset\\n    /// @param currEpoch current epoch (passed to save a storage read)\\n    /// @param _depositAmount amount of deposits\\n    /// @return newBalanceDay0 new balance day 0 of the user (returned to save a storage read)\\n    function __updateDepositRequests(\\n        AssetData storage assetData,\\n        uint256 currEpoch,\\n        uint256 _depositAmount\\n    ) private returns (uint256 newBalanceDay0) {\\n        Request storage req = assetData.depositRequests[msg.sender];\\n\\n        uint256 balance = assetData.balanceDay0[msg.sender];\\n        uint256 reqAmount = req.amount;\\n\\n        // If they have a prior request\\n        if (reqAmount > 0 && req.epoch < currEpoch) {\\n            // and if it was from a prior epoch\\n            // we now know the exchange rate at that epoch,\\n            // so we can add to their balance\\n            uint256 conversionRate = assetData.epochToRate[req.epoch];\\n            // will not overflow even if value = total mc of crypto\\n            balance += (reqAmount * RAY) / conversionRate;\\n\\n            reqAmount = 0;\\n        }\\n\\n        if (_depositAmount > 0) {\\n            // if they don't have a prior request, store this one (if this is a non-zero deposit)\\n            reqAmount += _depositAmount;\\n            req.epoch = currEpoch;\\n        }\\n        req.amount = reqAmount;\\n\\n        return balance;\\n    }\\n\\n    // ----------- Withdraw Requests -----------\\n\\n    /// @notice schedules a withdrawal of TOKEN0 from the floor tranche\\n    /// @param _amount amount of Day 0 TOKEN0 to withdraw\\n    function withdrawToken0(uint256 _amount) external override whenNotPaused nonReentrant {\\n        _withdrawAccounting(token0Data, _amount, TOKEN0);\\n    }\\n\\n    /// @notice schedules a withdrawal of the TOKEN1 from the ceiling tranche\\n    /// @param _amount amount of Day 0 TOKEN1 to withdraw\\n    function withdrawToken1(uint256 _amount) external override whenNotPaused nonReentrant {\\n        _withdrawAccounting(token1Data, _amount, TOKEN1);\\n    }\\n\\n    /// @dev handles the accounting for schedules withdrawals in a way that abstracts the logic\\n    /// @param assetData storage reference to the data for the desired asset\\n    /// @param _withdrawAmountDay0 the amount of the asset to withdraw\\n    /// @param assetCode code for the type of asset (either `TOKEN0` or `TOKEN1`)\\n    function _withdrawAccounting(\\n        AssetData storage assetData,\\n        uint256 _withdrawAmountDay0,\\n        bytes32 assetCode\\n    ) private {\\n        require(_withdrawAmountDay0 > 0, \\\"ZERO_AMOUNT\\\");\\n        uint256 currEpoch = epoch;\\n\\n        // Check if they have any deposit request that\\n        // might not have been flushed to the deposit mapping yet\\n        uint256 userBalanceDay0 = __updateDepositRequests(assetData, currEpoch, 0);\\n\\n        // See if there were any existing withdraw requests\\n        Request storage req = assetData.withdrawRequests[msg.sender];\\n        if (req.amount > 0 && req.epoch < currEpoch) {\\n            // If there was a request from a previous epoch, we now know the corresponding amount\\n            // that was withdrawn and we can add it to the accumulated amount of claimable assets\\n            // tokenAmount * epochToRate will not overflow even if value = total mc of crypto & rate = 3.8e10 * RAY\\n            assetData.claimable[msg.sender] += (req.amount * assetData.epochToRate[req.epoch]) / RAY;\\n            req.amount = 0;\\n        }\\n\\n        // Subtract the amount they way to withdraw from their deposit amount\\n        // Want to explicitly send out own reversion message\\n        require(userBalanceDay0 >= _withdrawAmountDay0, \\\"INSUFFICIENT_BALANCE\\\");\\n        unchecked {\\n            assetData.balanceDay0[msg.sender] = userBalanceDay0 - _withdrawAmountDay0;\\n        }\\n\\n        // Add it to their withdraw request and log the epoch\\n        req.amount = _withdrawAmountDay0 + req.amount;\\n        if (req.epoch < currEpoch) {\\n            req.epoch = currEpoch;\\n        }\\n\\n        // track total withdraw requests\\n        assetData.withdrawRequestsTotal += _withdrawAmountDay0;\\n\\n        emit WithdrawScheduled(assetCode, msg.sender, _withdrawAmountDay0, currEpoch);\\n    }\\n\\n    // ----------- Claim Functions -----------\\n\\n    /// @notice allows the user (`msg.sender`) to claim the TOKEN0 they have a right to once\\n    /// withdrawal requests are processed\\n    function claimToken0() external override whenNotPaused nonReentrant {\\n        uint256 claim = _claimAccounting(token0Data, TOKEN0);\\n\\n        if (isNativeVault) {\\n            IWrappy(address(token0)).withdraw(claim);\\n            (bool success, ) = msg.sender.call{ value: claim }(\\\"\\\");\\n            require(success, \\\"TRANSFER_FAILED\\\");\\n        } else {\\n            token0.safeTransfer(msg.sender, claim);\\n        }\\n    }\\n\\n    /// @notice allows the user (`msg.sender`) to claim the TOKEN1 they have a right to once\\n    /// withdrawal requests are processed\\n    function claimToken1() external override whenNotPaused nonReentrant {\\n        uint256 claim = _claimAccounting(token1Data, TOKEN1);\\n        token1.safeTransfer(msg.sender, claim);\\n    }\\n\\n    /// @notice calculates the current amount of an asset the user (`msg.sender`) has claim to\\n    /// after withdrawal requests are processed and abstracts away the accounting logic\\n    /// @param assetData storage reference to the data for the desired asset\\n    /// @return _claim amount of the asset the user has a claim to\\n    /// @param assetCode code for the type of asset (either `TOKEN0` or `TOKEN1`)\\n    function _claimAccounting(AssetData storage assetData, bytes32 assetCode) private returns (uint256 _claim) {\\n        Request storage withdrawReq = assetData.withdrawRequests[msg.sender];\\n        uint256 currEpoch = epoch;\\n        uint256 withdrawEpoch = withdrawReq.epoch;\\n\\n        uint256 claimable = assetData.claimable[msg.sender];\\n        if (withdrawEpoch < currEpoch) {\\n            // If epoch ended, calculate the amount they can withdraw\\n            uint256 withdrawAmountDay0 = withdrawReq.amount;\\n            if (withdrawAmountDay0 > 0) {\\n                delete assetData.withdrawRequests[msg.sender];\\n                // tokenAmount * epochToRate will not overflow even if value = total mc of crypto & rate = 3.8e10 * RAY\\n                claimable += (withdrawAmountDay0 * assetData.epochToRate[withdrawEpoch]) / RAY;\\n            }\\n        }\\n\\n        require(claimable > 0, \\\"NO_CLAIM\\\");\\n        assetData.claimable[msg.sender] = 0;\\n        assetData.claimableTotal -= claimable;\\n        emit AssetsClaimed(assetCode, msg.sender, claimable);\\n        return claimable;\\n    }\\n\\n    // ----------- Balance Functions -----------\\n\\n    /// @notice gets a user's current TOKEN0 balance\\n    /// @param user address of the user in which whose balance we are interested\\n    /// @return deposited amount of deposited TOKEN0 in the protocol\\n    /// @return pendingDeposit amount of TOKEN0 pending deposit\\n    /// @return claimable amount of TOKEN0 ready to be withdrawn\\n    function token0Balance(address user)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 deposited,\\n            uint256 pendingDeposit,\\n            uint256 claimable\\n        )\\n    {\\n        return _balance(token0Data, user);\\n    }\\n\\n    /// @notice gets a user's current TOKEN1 balance\\n    /// @param user address of the user in which whose balance we are interested\\n    /// @return deposited amount of deposited TOKEN1 in the protocol\\n    /// @return pendingDeposit amount of TOKEN1 pending deposit\\n    /// @return claimable amount of TOKEN1 ready to be withdrawn\\n    function token1Balance(address user)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 deposited,\\n            uint256 pendingDeposit,\\n            uint256 claimable\\n        )\\n    {\\n        return _balance(token1Data, user);\\n    }\\n\\n    /// @dev handles the balance calculations in a way that abstracts the logic\\n    /// @param assetData storage reference to the data for the desired asset\\n    /// @param user address of the user in which whose balance we are interested\\n    /// @return _deposited amount of their asset that is deposited in the protocol\\n    /// @return _pendingDeposit amount of their asset pending deposit\\n    /// @return _claimable amount of their asset ready to be withdrawn\\n    function _balance(AssetData storage assetData, address user)\\n        private\\n        view\\n        returns (\\n            uint256 _deposited,\\n            uint256 _pendingDeposit,\\n            uint256 _claimable\\n        )\\n    {\\n        uint256 currEpoch = epoch;\\n\\n        uint256 balanceDay0 = assetData.balanceDay0[user];\\n\\n        // then check if they have any open deposit requests\\n        Request memory depositReq = assetData.depositRequests[user];\\n        uint256 depositAmt = depositReq.amount;\\n        uint256 depositEpoch = depositReq.epoch;\\n\\n        if (depositAmt > 0) {\\n            // if they have one from a previous epoch, add the Day 0 amount that\\n            // deposit is worth\\n            if (depositEpoch < currEpoch) {\\n                balanceDay0 += (depositAmt * RAY) / assetData.epochToRate[depositEpoch];\\n            } else {\\n                // if they have one from this epoch, set the flat amount\\n                _pendingDeposit = depositAmt;\\n            }\\n        }\\n\\n        // Check their withdraw requests, because if they made one\\n        // their deposit balances would have been flushed to here\\n        Request memory withdrawReq = assetData.withdrawRequests[user];\\n        _claimable = assetData.claimable[user];\\n        if (withdrawReq.amount > 0) {\\n            // if they have one from a previous epoch, calculate that\\n            // requests day 0 Value\\n            if (withdrawReq.epoch < currEpoch) {\\n                _claimable += (withdrawReq.amount * assetData.epochToRate[withdrawReq.epoch]) / RAY;\\n            } else {\\n                // if they have one from this epoch, that means the tokens are still active\\n                balanceDay0 += withdrawReq.amount;\\n            }\\n        }\\n\\n        /* TODO: this would be better calculated if we simulated ending the epoch here\\n        because this doesn't consider the IL / profits from this current epoch\\n        but this is fine for now */\\n        // Note that currEpoch >= 1 since it is initialized to 1 in the constructor\\n        uint256 currentConversionRate = assetData.epochToRate[currEpoch - 1];\\n\\n        // tokenAmount * epochToRate will not overflow even if value = total mc of crypto & rate = 3.8e10 * RAY\\n        return ((balanceDay0 * currentConversionRate) / RAY, _pendingDeposit, _claimable);\\n    }\\n\\n    // ----------- Next Epoch Functions -----------\\n\\n    /// @notice Struct just for wrapper around local variables to avoid the stack limit in `nextEpoch()`\\n    struct NextEpochVariables {\\n        uint256 poolBalance;\\n        uint256 withdrawn;\\n        uint256 available;\\n        uint256 original;\\n        uint256 newRate;\\n        uint256 newClaimable;\\n    }\\n\\n    /// @notice Initiates the next epoch\\n    /// @param expectedPoolToken0 the approximate amount of TOKEN0 expected to be in the pool (preventing frontrunning)\\n    /// @param expectedPoolToken1 the approximate amount of TOKEN1 expected to be in the pool (preventing frontrunning)\\n    function nextEpoch(uint256 expectedPoolToken0, uint256 expectedPoolToken1)\\n        external\\n        override\\n        onlyStrategist\\n        whenNotPaused\\n    {\\n        require(block.timestamp - lastEpochStart >= epochDuration, \\\"EPOCH_DURATION_UNMET\\\");\\n\\n        AssetDataStatics memory _token0Data = _assetDataStatics(token0Data);\\n        AssetDataStatics memory _token1Data = _assetDataStatics(token1Data);\\n        // These are used to avoid hitting the local variable stack limit\\n        NextEpochVariables memory _token0;\\n        NextEpochVariables memory _token1;\\n\\n        uint256 currEpoch = epoch;\\n\\n        // Total tokens in the liquidity pool and our ownership of those tokens\\n        (_token0.poolBalance, _token1.poolBalance) = getPoolBalances();\\n        // will not overflow with reasonable expectedPoolToken amount (DENOM = 10,000)\\n        require(_token0.poolBalance >= (expectedPoolToken0 * (DENOM - POOL_ERR)) / DENOM, \\\"UNEXPECTED_POOL_BALANCES\\\");\\n        require(_token0.poolBalance <= (expectedPoolToken0 * (DENOM + POOL_ERR)) / DENOM, \\\"UNEXPECTED_POOL_BALANCES\\\");\\n        require(_token1.poolBalance >= (expectedPoolToken1 * (DENOM - POOL_ERR)) / DENOM, \\\"UNEXPECTED_POOL_BALANCES\\\");\\n        require(_token1.poolBalance <= (expectedPoolToken1 * (DENOM + POOL_ERR)) / DENOM, \\\"UNEXPECTED_POOL_BALANCES\\\");\\n        // !!NOTE: After this point we don't need to worry about front-running anymore because the pool's state has been\\n        // verified (as long as there is no calls to untrusted external parties)\\n\\n        // (1) Withdraw liquidity\\n        (_token0.withdrawn, _token1.withdrawn) = withdrawLiquidity();\\n        (_token0.poolBalance, _token1.poolBalance) = getPoolBalances();\\n        _token0.available = _token0.withdrawn + _token0Data.reserves;\\n        _token1.available = _token1.withdrawn + _token1Data.reserves;\\n\\n        // (2) Perform the swap\\n\\n        // Calculate the floor and ceiling returns for each side\\n        // will not overflow with reasonable amounts (token0/1FloorNum ~ 10,000)\\n        uint256 token0Floor = _token0Data.reserves + (_token0Data.active * token0FloorNum) / DENOM;\\n        uint256 token1Floor = _token1Data.reserves + (_token1Data.active * token1FloorNum) / DENOM;\\n        uint256 token1Ceiling = _token1Data.reserves + _token1Data.active;\\n        // Add interest to the token1 ceiling (but we don't for this version)\\n        // token1Ceiling += (_token1Data.active * timePassed * tokenInterest) / (RAY * 365 days);\\n\\n        if (token0Floor > _token0.available) {\\n            // The min amount needed to reach the TOKEN0 floor\\n            uint256 token1NeededToSwap;\\n            uint256 token0Deficit = token0Floor - _token0.available;\\n            if (token0Deficit > _token0.poolBalance) {\\n                token1NeededToSwap = _token1.available;\\n            } else {\\n                token1NeededToSwap = calcAmountIn(token0Deficit, _token1.poolBalance, _token0.poolBalance);\\n            }\\n\\n            // swap as much token1 as is necessary to get back to the token0 floor, without going\\n            // under the token1 floor\\n            uint256 swapAmount = (token1Ceiling + token1NeededToSwap < _token1.available)\\n                ? _token1.available - token1Ceiling\\n                : token1NeededToSwap + token1Floor > _token1.available\\n                ? _token1.available - token1Floor\\n                : token1NeededToSwap;\\n\\n            (uint256 amountOut, uint256 amountConsumed) = swap(token1, token0, swapAmount);\\n            _token0.available += amountOut;\\n            _token1.available -= amountConsumed;\\n        } else if (_token1.available >= token1Ceiling) {\\n            // If we have more token0 than the floor and more token1 than the ceiling so we swap the excess amount\\n            // all to TOKEN0\\n\\n            (uint256 amountOut, uint256 amountConsumed) = swap(token1, token0, _token1.available - token1Ceiling);\\n            _token0.available += amountOut;\\n            _token1.available -= amountConsumed;\\n        } else {\\n            // We have more token0 than the floor but are below the token1 ceiling\\n            // Min amount of TOKEN0 needed to swap to hit the token1 ceiling\\n            uint256 token0NeededToSwap;\\n            uint256 token1Deficit = token1Ceiling - _token1.available;\\n            if (token1Deficit > _token1.poolBalance) {\\n                token0NeededToSwap = _token0.poolBalance;\\n            } else {\\n                token0NeededToSwap = calcAmountIn(token1Deficit, _token0.poolBalance, _token1.poolBalance);\\n            }\\n\\n            if (token0Floor + token0NeededToSwap < _token0.available) {\\n                // If we can reach the token1 ceiling without going through the TOKEN0 floor\\n                (uint256 amountOut, uint256 amountConsumed) = swap(token0, token1, token0NeededToSwap);\\n                _token0.available -= amountConsumed;\\n                _token1.available += amountOut;\\n            } else {\\n                // We swap as much TOKEN0 as we can without going through the TOKEN0 floor\\n                (uint256 amountOut, uint256 amountConsumed) = swap(token0, token1, _token0.available - token0Floor);\\n                _token0.available -= amountConsumed;\\n                _token1.available += amountOut;\\n            }\\n        }\\n\\n        // (3) Add in new deposits and subtract withdrawals\\n        _token0.original = _token0Data.reserves + _token0Data.active;\\n        _token1.original = _token1Data.reserves + _token1Data.active;\\n\\n        // collect protocol fee if profitable\\n        if (_token0.available > _token0.original) {\\n            // will not overflow core.protocolFee() < 10,000\\n            _token0.available -= ((_token0.available - _token0.original) * core.protocolFee()) / core.MAX_FEE();\\n        }\\n        if (_token1.available > _token1.original) {\\n            // will not overflow core.protocolFee() < 10,000\\n            _token1.available -= ((_token1.available - _token1.original) * core.protocolFee()) / core.MAX_FEE();\\n        }\\n\\n        // calculate new rate (before withdraws and deposits) as available tokens divided by\\n        // tokens that were available at the beginning of the epoch\\n        // and tally claimable amount (withdraws that are now accounted for) for this token\\n        // tokenAmount * epochToRate will not overflow even if value = total mc of crypto & rate = 3.8e10 * RAY\\n        _token0.newRate = _token0.original > 0\\n            ? (token0Data.epochToRate[currEpoch - 1] * _token0.available) / _token0.original // no overflow\\n            : token0Data.epochToRate[currEpoch - 1];\\n        token0Data.epochToRate[currEpoch] = _token0.newRate;\\n        _token0.newClaimable = (_token0Data.withdrawRequestsTotal * _token0.newRate) / RAY; // no overflow\\n        token0Data.claimableTotal += _token0.newClaimable;\\n        _token1.newRate = _token1.original > 0\\n            ? (token1Data.epochToRate[currEpoch - 1] * _token1.available) / _token1.original // no overflow\\n            : token1Data.epochToRate[currEpoch - 1];\\n        token1Data.epochToRate[currEpoch] = _token1.newRate;\\n        _token1.newClaimable = (_token1Data.withdrawRequestsTotal * _token1.newRate) / RAY; // no overflow\\n        token1Data.claimableTotal += _token1.newClaimable;\\n\\n        // calculate available token after deposits and withdraws\\n        _token0.available = _token0.available + _token0Data.depositRequestsTotal - _token0.newClaimable;\\n        _token1.available = _token1.available + _token1Data.depositRequestsTotal - _token1.newClaimable;\\n\\n        token0Data.depositRequestsTotal = 0;\\n        token0Data.withdrawRequestsTotal = 0;\\n        token1Data.depositRequestsTotal = 0;\\n        token1Data.withdrawRequestsTotal = 0;\\n\\n        // (4) Deposit liquidity back in\\n        (token0Data.active, token1Data.active) = depositLiquidity(_token0.available, _token1.available);\\n        token0Data.reserves = _token0.available - token0Data.active;\\n        token1Data.reserves = _token1.available - token1Data.active;\\n\\n        epoch += 1;\\n        lastEpochStart = block.timestamp;\\n\\n        emit NextEpochStarted(epoch, msg.sender, block.timestamp);\\n    }\\n\\n    function _assetDataStatics(AssetData storage assetData) internal view returns (AssetDataStatics memory) {\\n        return\\n            AssetDataStatics({\\n                reserves: assetData.reserves,\\n                active: assetData.active,\\n                depositRequestsTotal: assetData.depositRequestsTotal,\\n                withdrawRequestsTotal: assetData.withdrawRequestsTotal\\n            });\\n    }\\n\\n    // ----------- Abstract Functions Implemented For Each DEX -----------\\n\\n    function getPoolBalances() internal view virtual returns (uint256 poolToken0, uint256 poolToken1);\\n\\n    /// @dev This is provided automatically by the Uniswap router\\n    function calcAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal view virtual returns (uint256 amountIn);\\n\\n    /// @dev Withdraws all liquidity\\n    function withdrawLiquidity() internal returns (uint256 token0Withdrawn, uint256 token1Withdrawn) {\\n        // the combination of `unstakeLiquidity` and `_withdrawLiquidity` should never result in a decreased\\n        // balance of either token. If they do, this transaction will revert.\\n        uint256 token0BalanceBefore = token0.balanceOf(address(this));\\n        uint256 token1BalanceBefore = token1.balanceOf(address(this));\\n        _unstakeLiquidity();\\n        _withdrawLiquidity();\\n        token0Withdrawn = token0.balanceOf(address(this)) - token0BalanceBefore;\\n        token1Withdrawn = token1.balanceOf(address(this)) - token1BalanceBefore;\\n    }\\n\\n    function _withdrawLiquidity() internal virtual;\\n\\n    /// @dev Deposits liquidity into the pool\\n    function depositLiquidity(uint256 availableToken0, uint256 availableToken1)\\n        internal\\n        returns (uint256 token0Deposited, uint256 token1Deposited)\\n    {\\n        // ensure sufficient liquidity is minted, if < MIN_LP don't activate those funds\\n        if ((availableToken0 < MIN_LP) || (availableToken1 < MIN_LP)) return (0, 0);\\n        (token0Deposited, token1Deposited) = _depositLiquidity(availableToken0, availableToken1);\\n        _stakeLiquidity();\\n    }\\n\\n    function _depositLiquidity(uint256 availableToken0, uint256 availableToken1)\\n        internal\\n        virtual\\n        returns (uint256 token0Deposited, uint256 token1Deposited);\\n\\n    /// @dev Swaps tokens and handles the case where amountIn == 0\\n    function swap(\\n        IERC20Upgradeable tokenIn,\\n        IERC20Upgradeable tokenOut,\\n        uint256 amountIn\\n    ) internal virtual returns (uint256 amountOut, uint256 amountConsumed);\\n\\n    // ----------- Rescue Funds -----------\\n\\n    /// @notice rescues funds from this contract in dire situations, only when contract is paused\\n    /// @param tokens array of tokens to rescue\\n    /// @param amounts list of amounts for each token to rescue. If 0, the full balance\\n    function rescueTokens(address[] calldata tokens, uint256[] calldata amounts)\\n        external\\n        override\\n        nonReentrant\\n        onlyGuardian\\n        whenPaused\\n    {\\n        require(tokens.length == amounts.length, \\\"INVALID_INPUTS\\\");\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (tokens[i] == address(0)) {\\n                amount = (amount == 0) ? address(this).balance : amount;\\n                (bool success, ) = msg.sender.call{ value: amount }(\\\"\\\");\\n                require(success, \\\"TRANSFER_FAILED\\\");\\n            } else {\\n                amount = (amount == 0) ? IERC20Upgradeable(tokens[i]).balanceOf(address(this)) : amount;\\n                IERC20Upgradeable(tokens[i]).safeTransfer(msg.sender, amount);\\n            }\\n        }\\n        emit FundsRescued(msg.sender);\\n    }\\n\\n    /// @notice A function that should be called by the guardian to unstake any liquidity before rescuing LP tokens\\n    function unstakeLiquidity() external override nonReentrant onlyGuardian whenPaused {\\n        _unstakeLiquidity();\\n    }\\n\\n    /// @notice stakes all LP tokens\\n    function _unstakeLiquidity() internal virtual;\\n\\n    /// @notice unstakes all LP tokens\\n    function _stakeLiquidity() internal virtual;\\n\\n    // ----------- Getter Functions -----------\\n\\n    function token0ValueLocked() external view override returns (uint256) {\\n        return token0.balanceOf(address(this)) + token0Data.active;\\n    }\\n\\n    function token1ValueLocked() external view override returns (uint256) {\\n        return token1.balanceOf(address(this)) + token1Data.active;\\n    }\\n\\n    function token0BalanceDay0(address user) external view override returns (uint256) {\\n        return __user_balanceDay0(token0Data, user);\\n    }\\n\\n    function epochToToken0Rate(uint256 _epoch) external view override returns (uint256) {\\n        return token0Data.epochToRate[_epoch];\\n    }\\n\\n    function token0WithdrawRequests(address user) external view override returns (uint256) {\\n        return __user_requestView(token0Data.withdrawRequests[user]);\\n    }\\n\\n    function token1BalanceDay0(address user) external view override returns (uint256) {\\n        return __user_balanceDay0(token1Data, user);\\n    }\\n\\n    function epochToToken1Rate(uint256 _epoch) external view override returns (uint256) {\\n        return token1Data.epochToRate[_epoch];\\n    }\\n\\n    function token1WithdrawRequests(address user) external view override returns (uint256) {\\n        return __user_requestView(token1Data.withdrawRequests[user]);\\n    }\\n\\n    /// @dev This function is used to convert the way balances are internally stored to\\n    /// what makes sense for the user\\n    function __user_balanceDay0(AssetData storage assetData, address user) internal view returns (uint256) {\\n        uint256 res = assetData.balanceDay0[user];\\n        Request memory depositReq = assetData.depositRequests[user];\\n        if (depositReq.epoch < epoch) {\\n            // will not overflow even if value = total mc of crypto\\n            res += (depositReq.amount * RAY) / assetData.epochToRate[depositReq.epoch];\\n        }\\n        Request memory withdrawReq = assetData.withdrawRequests[user];\\n        if (withdrawReq.epoch == epoch) {\\n            // This amount has not been withdrawn yet so this is still part of\\n            // their Day 0 Balance\\n            res += withdrawReq.amount;\\n        }\\n        return res;\\n    }\\n\\n    /// @dev This function is used to convert the way requests are internally stored to\\n    /// what makes sense for the user\\n    function __user_requestView(Request memory req) internal view returns (uint256) {\\n        if (req.epoch < epoch) {\\n            return 0;\\n        }\\n        return req.amount;\\n    }\\n\\n    /// @notice calculates current amount of fees accrued, as the current balance of each token\\n    /// less the amounts each tokens that are active user funds. token0Data.active is not\\n    /// included because they are currently in the DEX pool\\n    function feesAccrued() public view override returns (uint256 token0Fees, uint256 token1Fees) {\\n        token0Fees =\\n            token0.balanceOf(address(this)) -\\n            token0Data.claimableTotal -\\n            token0Data.reserves -\\n            token0Data.depositRequestsTotal;\\n        token1Fees =\\n            token1.balanceOf(address(this)) -\\n            token1Data.claimableTotal -\\n            token1Data.reserves -\\n            token1Data.depositRequestsTotal;\\n    }\\n\\n    /// ------------------- Setters -------------------\\n\\n    /// @notice sets a new value for the token0 floor\\n    /// @param _token0FloorNum the new floor token0 returns (out of `DENOM`)\\n    function setToken0Floor(uint256 _token0FloorNum) external override onlyStrategist {\\n        require(_token0FloorNum > 0, \\\"INVALID_TOKEN0_FLOOR\\\");\\n        token0FloorNum = _token0FloorNum;\\n        emit Token0FloorUpdated(_token0FloorNum);\\n    }\\n\\n    /// @notice sets a new value for the token1 floor\\n    /// @param _token1FloorNum the new floor token1 returns (out of `DENOM`)\\n    function setToken1Floor(uint256 _token1FloorNum) external override onlyStrategist {\\n        require(_token1FloorNum > 0, \\\"INVALID_TOKEN1_FLOOR\\\");\\n        token1FloorNum = _token1FloorNum;\\n        emit Token1FloorUpdated(_token1FloorNum);\\n    }\\n\\n    function setEpochDuration(uint256 _epochDuration) external override onlyStrategist whenPaused {\\n        epochDuration = _epochDuration;\\n        emit EpochDurationUpdated(_epochDuration);\\n    }\\n\\n    /// @notice sends accrued fees to the core.feeTo() address, the treasury\\n    function collectFees() external override {\\n        (uint256 token0Fees, uint256 token1Fees) = feesAccrued();\\n        if (token0Fees > 0) {\\n            token0.safeTransfer(core.feeTo(), token0Fees);\\n        }\\n        if (token1Fees > 0) {\\n            token1.safeTransfer(core.feeTo(), token1Fees);\\n        }\\n    }\\n\\n    // To receive any native token sent here (ex. from wrapped native withdraw)\\n    receive() external payable {\\n        // no logic upon reciept of native token required\\n    }\\n}\\n\"\r\n    },\r\n    \"rift-protocol/src/vaults/uniswap/UniswapVaultStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.11;\\n\\n/// @notice Storage for uniswap vaults\\n/// @author Recursive Research Inc\\nabstract contract UniswapVaultStorageUnpadded {\\n    /// @notice UniswapV2Factory address\\n    address public factory;\\n\\n    /// @notice UniswapV2Router02 address\\n    address public router;\\n\\n    // @notice UniswapV2Pair address for token0 and token1\\n    address public pair;\\n}\\n\\nabstract contract UniswapVaultStorage is UniswapVaultStorageUnpadded {\\n    // @dev Padding 100 words of storage for upgradeability. Follows OZ's guidance.\\n    uint256[100] private __gap;\\n}\\n\"\r\n    },\r\n    \"rift-protocol/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"rift-protocol/lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"rift-protocol/lib/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"rift-protocol/lib/openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"rift-protocol/src/external/IWrappy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\ninterface IWrappy {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"rift-protocol/src/refs/CoreReference.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.11;\\n\\nimport \\\"../../lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\\\";\\n\\nimport \\\"../core/ICore.sol\\\";\\n\\n/// @notice Stores a reference to the core contract\\n/// @author Recursive Research Inc\\nabstract contract CoreReference is Initializable {\\n    ICore public core;\\n    bool private _paused;\\n\\n    /// initialize logic contract\\n    /// This tag here tells OZ to not throw an error on this constructor\\n    /// Recommended here:\\n    /// https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializing_the_implementation_contract\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() initializer {}\\n\\n    /// @dev Emitted when the pause is triggered\\n    event Paused();\\n\\n    /// @dev Emitted when the pause is lifted\\n    event Unpaused();\\n\\n    function __CoreReference_init(address coreAddress) internal onlyInitializing {\\n        __CoreReference_init_unchained(coreAddress);\\n    }\\n\\n    function __CoreReference_init_unchained(address coreAddress) internal onlyInitializing {\\n        core = ICore(coreAddress);\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"PAUSED\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(paused(), \\\"NOT_PAUSED\\\");\\n        _;\\n    }\\n\\n    modifier onlyPauser() {\\n        require(core.hasRole(core.PAUSE_ROLE(), msg.sender), \\\"NOT_PAUSER\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovernor() {\\n        require(core.hasRole(core.GOVERN_ROLE(), msg.sender), \\\"NOT_GOVERNOR\\\");\\n        _;\\n    }\\n\\n    modifier onlyGuardian() {\\n        require(core.hasRole(core.GUARDIAN_ROLE(), msg.sender), \\\"NOT_GUARDIAN\\\");\\n        _;\\n    }\\n\\n    modifier onlyStrategist() {\\n        require(core.hasRole(core.STRATEGIST_ROLE(), msg.sender), \\\"NOT_STRATEGIST\\\");\\n        _;\\n    }\\n\\n    /// @notice view function to see whether or not the contract is paused\\n    /// @return true if the contract is paused either by the core or independently\\n    function paused() public view returns (bool) {\\n        return (core.paused() || _paused);\\n    }\\n\\n    function pause() external onlyPauser whenNotPaused {\\n        _paused = true;\\n        emit Paused();\\n    }\\n\\n    function unpause() external onlyPauser whenPaused {\\n        _paused = false;\\n        emit Unpaused();\\n    }\\n}\\n\"\r\n    },\r\n    \"rift-protocol/src/vaults/VaultStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.11;\\n\\n// Need to use IERC20Upgradeable because that is what SafeERC20Upgradeable requires\\n// but the interface is exactly the same as ERC20s so this still works with ERC20s\\nimport \\\"../../lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\n/// @notice Storage for Vault\\n/// @author Recursive Research Inc\\nabstract contract VaultStorageUnpadded {\\n    /// @notice struct for withdraw and deposit requests\\n    /// @param epoch the epoch when the request was submitted\\n    /// @param amount size of request, if deposit it's an absolute amount of the underlying.\\n    ///     If withdraw, specified in \\\"Day 0\\\" amount\\n    struct Request {\\n        uint256 epoch;\\n        uint256 amount;\\n    }\\n\\n    /// @notice struct to keep a copy of AssetData in memory during `nextEpoch` call\\n    struct AssetDataStatics {\\n        uint256 reserves;\\n        uint256 active;\\n        uint256 depositRequestsTotal;\\n        uint256 withdrawRequestsTotal;\\n    }\\n\\n    /// @notice global struct to keep track of all info for an asset\\n    /// @param reserves total amount not active\\n    /// @param active total amount paired up in the Dex pool\\n    /// @param depositRequestsTotal total amount of queued up deposit requests\\n    /// @param withdrawRequestsTotal total amount of queued up withdraw requests\\n    /// @param balanceDay0 each user's deposited balance denominated in \\\"day 0 tokens\\\"\\n    /// @param claimable each user's amount that has been withdrawn from the LP pool and they can claim\\n    /// @param epochToRate exchange rate of token to day0 tokens by epoch\\n    /// @param depositRequests each users deposit requests\\n    /// @param withdrawRequests each users withdraw requests\\n    struct AssetData {\\n        uint256 reserves;\\n        uint256 active;\\n        uint256 depositRequestsTotal;\\n        uint256 withdrawRequestsTotal;\\n        uint256 claimableTotal;\\n        mapping(address => uint256) balanceDay0;\\n        mapping(address => uint256) claimable;\\n        mapping(uint256 => uint256) epochToRate;\\n        mapping(address => Request) depositRequests;\\n        mapping(address => Request) withdrawRequests;\\n    }\\n\\n    /// @notice true if token0 is wrapped native\\n    bool public isNativeVault;\\n\\n    /// @notice token that receives a \\\"floor\\\" return\\n    IERC20Upgradeable public token0;\\n    /// @notice token that receives a \\\"ceiling\\\" return\\n    IERC20Upgradeable public token1;\\n\\n    /// @notice current epoch, set to 1 on initialization\\n    uint256 public epoch;\\n    /// @notice duration of each epoch\\n    uint256 public epochDuration;\\n    /// @notice start of last epoch, 0 on initialization\\n    uint256 public lastEpochStart;\\n\\n    /// @notice keeps track of relevant data for TOKEN0\\n    AssetData public token0Data;\\n    /// @notice keeps track of relevant data for TOKEN1\\n    AssetData public token1Data;\\n\\n    /// @notice minimum return for TOKEN0 (out of `vault.DENOM`) as long as TOKEN1 is above its minimum return\\n    uint256 public token0FloorNum;\\n    /// @notice minimum return for TOKEN1 (out of `vault.DENOM`)\\n    uint256 public token1FloorNum;\\n}\\n\\nabstract contract VaultStorage is VaultStorageUnpadded {\\n    // @dev Padding 100 words of storage for upgradeability. Follows OZ's guidance.\\n    uint256[100] private __gap;\\n}\\n\"\r\n    },\r\n    \"rift-protocol/src/vaults/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\ninterface IVault {\\n    /// @dev Emitted when a new epoch is started\\n    /// @param newEpoch number of the new epoch\\n    /// @param initiator address of the user who initiated the new epoch\\n    /// @param startTime timestamp of the start of this new epoch\\n    event NextEpochStarted(uint256 indexed newEpoch, address indexed initiator, uint256 startTime);\\n\\n    /// @dev Emitted upon a new deposit request\\n    /// @param assetCode code for the type of asset (either `TOKEN0` or `TOKEN1`)\\n    /// @param user address of the user who made the deposit request\\n    /// @param amount amount of the asset in deposit request\\n    /// @param epoch epoch of the deposit request\\n    event DepositScheduled(bytes32 indexed assetCode, address indexed user, uint256 amount, uint256 indexed epoch);\\n\\n    /// @dev Emitted upon a new withdraw request\\n    /// @param assetCode code for the type of asset (either `TOKEN0` or `TOKEN1`)\\n    /// @param user address of the user who made the withdraw request\\n    /// @param amountDay0 amount of the asset (day 0) in withdraw request\\n    /// @param epoch epoch of the withdraw request\\n    event WithdrawScheduled(bytes32 indexed assetCode, address indexed user, uint256 amountDay0, uint256 indexed epoch);\\n\\n    /// @dev Emitted upon a user claiming their tokens after a withdraw request is processed\\n    /// @param assetCode code for the type of asset (either `TOKEN0` or `TOKEN1`)\\n    /// @param user address of the user who is claiming their assets\\n    /// @param amount amount of the assets (day 0) claimed\\n    event AssetsClaimed(bytes32 indexed assetCode, address indexed user, uint256 amount);\\n\\n    /// @dev Emitted upon a guardian rescuing funds\\n    /// @param guardian address of the guardian who rescued the funds\\n    event FundsRescued(address indexed guardian);\\n\\n    /// @dev Emitted upon a strategist updating the token0 floor\\n    /// @param newFloor the new floor returns on TOKEN0 (out of `RAY`)\\n    event Token0FloorUpdated(uint256 newFloor);\\n\\n    /// @dev Emitted upon a strategist updating the token1 floor\\n    /// @param newFloor the new floor returns on TOKEN1 (out of `RAY`)\\n    event Token1FloorUpdated(uint256 newFloor);\\n\\n    event EpochDurationUpdated(uint256 newEpochDuration);\\n\\n    /// ------------------- Vault Interface -------------------\\n\\n    function depositToken0(uint256 _amount) external payable;\\n\\n    function depositToken1(uint256 _amount) external;\\n\\n    function withdrawToken0(uint256 _amount) external;\\n\\n    function withdrawToken1(uint256 _amount) external;\\n\\n    function claimToken0() external;\\n\\n    function claimToken1() external;\\n\\n    function token0Balance(address user)\\n        external\\n        view\\n        returns (\\n            uint256 deposited,\\n            uint256 pendingDeposit,\\n            uint256 claimable\\n        );\\n\\n    function token1Balance(address user)\\n        external\\n        view\\n        returns (\\n            uint256 deposited,\\n            uint256 pendingDeposit,\\n            uint256 claimable\\n        );\\n\\n    function nextEpoch(uint256 expectedPoolToken0, uint256 expectedPoolToken1) external;\\n\\n    function rescueTokens(address[] calldata tokens, uint256[] calldata amounts) external;\\n\\n    function collectFees() external;\\n\\n    function unstakeLiquidity() external;\\n\\n    /// ------------------- Getters -------------------\\n\\n    function token0ValueLocked() external view returns (uint256);\\n\\n    function token1ValueLocked() external view returns (uint256);\\n\\n    function token0BalanceDay0(address user) external view returns (uint256);\\n\\n    function epochToToken0Rate(uint256 _epoch) external view returns (uint256);\\n\\n    function token0WithdrawRequests(address user) external view returns (uint256);\\n\\n    function token1BalanceDay0(address user) external view returns (uint256);\\n\\n    function epochToToken1Rate(uint256 _epoch) external view returns (uint256);\\n\\n    function token1WithdrawRequests(address user) external view returns (uint256);\\n\\n    function feesAccrued() external view returns (uint256, uint256);\\n\\n    /// ------------------- Setters -------------------\\n\\n    function setToken0Floor(uint256 _token0FloorNum) external;\\n\\n    function setToken1Floor(uint256 _token1FloorNum) external;\\n\\n    function setEpochDuration(uint256 _epochDuration) external;\\n}\\n\"\r\n    },\r\n    \"rift-protocol/lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = _setInitializedVersion(1);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        bool isTopLevelCall = _setInitializedVersion(version);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(version);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        _setInitializedVersion(type(uint8).max);\\n    }\\n\\n    function _setInitializedVersion(uint8 version) private returns (bool) {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\\n        // of initializers, because in other contexts the contract may have been reentered.\\n        if (_initializing) {\\n            require(\\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\\n                \\\"Initializable: contract is already initialized\\\"\\n            );\\n            return false;\\n        } else {\\n            require(_initialized < version, \\\"Initializable: contract is already initialized\\\");\\n            _initialized = version;\\n            return true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"rift-protocol/src/core/ICore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"./ICorePermissions.sol\\\";\\n\\n/// @notice Interface for Core\\n/// @author Recursive Research Inc\\ninterface ICore is ICorePermissions {\\n    // ----------- Events ---------------------\\n\\n    /// @dev Emitted when the protocol fee (`protocolFee`) is changed\\n    ///   out of core.MAX_FEE()\\n    event ProtocolFeeUpdated(uint256 protocolFee);\\n\\n    /// @dev Emitted when the protocol fee destination (`feeTo`) is changed\\n    event FeeToUpdated(address indexed feeTo);\\n\\n    /// @dev Emitted when the pause is triggered\\n    event Paused();\\n\\n    /// @dev Emitted when the pause is lifted\\n    event Unpaused();\\n\\n    // @dev Emitted when a vault with address `vault`\\n    event VaultRegistered(address indexed vault);\\n\\n    // @dev Emitted when a vault with address `vault`\\n    event VaultRemoved(address indexed vault);\\n\\n    // ----------- Default Getters --------------\\n\\n    /// @dev constant set to 10_000\\n    function MAX_FEE() external view returns (uint256);\\n\\n    function feeTo() external view returns (address);\\n\\n    /// @dev protocol fee out of core.MAX_FEE()\\n    function protocolFee() external view returns (uint256);\\n\\n    function wrappedNative() external view returns (address);\\n\\n    // ----------- Main Core Utility --------------\\n\\n    function registerVaults(address[] memory vaults) external;\\n\\n    function removeVaults(address[] memory vaults) external;\\n\\n    /// @dev set core.protocolFee, out of core.MAX_FEE()\\n    function setProtocolFee(uint256 _protocolFee) external;\\n\\n    function setFeeTo(address _feeTo) external;\\n\\n    // ----------- Protocol Pausing -----------\\n\\n    function pause() external;\\n\\n    function unpause() external;\\n\\n    function paused() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"rift-protocol/src/core/ICorePermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"../../lib/openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol\\\";\\n\\n/// @title Interface for CorePermissions\\n/// @author Recursive Research Inc\\ninterface ICorePermissions is IAccessControlUpgradeable {\\n    // ----------- Events ---------------------\\n\\n    /// @dev Emitted when the whitelist is disabled by `admin`.\\n    event WhitelistDisabled();\\n\\n    /// @dev Emitted when the whitelist is disabled by `admin`.\\n    event WhitelistEnabled();\\n\\n    // ----------- Governor only state changing api -----------\\n\\n    function createRole(bytes32 role, bytes32 adminRole) external;\\n\\n    function whitelistAll(address[] memory addresses) external;\\n\\n    // ----------- GRANTING ROLES -----------\\n\\n    function disableWhitelist() external;\\n\\n    function enableWhitelist() external;\\n\\n    // ----------- Getters -----------\\n\\n    function GUARDIAN_ROLE() external view returns (bytes32);\\n\\n    function GOVERN_ROLE() external view returns (bytes32);\\n\\n    function PAUSE_ROLE() external view returns (bytes32);\\n\\n    function STRATEGIST_ROLE() external view returns (bytes32);\\n\\n    function WHITELISTED_ROLE() external view returns (bytes32);\\n\\n    function whitelistDisabled() external view returns (bool);\\n\\n    // ----------- Read Interface -----------\\n\\n    function isWhitelisted(address _address) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"rift-protocol/lib/openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"assetCode\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AssetsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"assetCode\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"DepositScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newEpochDuration\",\"type\":\"uint256\"}],\"name\":\"EpochDurationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"FundsRescued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newEpoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"NextEpochStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFloor\",\"type\":\"uint256\"}],\"name\":\"Token0FloorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFloor\",\"type\":\"uint256\"}],\"name\":\"Token1FloorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"assetCode\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDay0\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"WithdrawScheduled\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DENOM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_LP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL_ERR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN0\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN1\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimToken0\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimToken1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"core\",\"outputs\":[{\"internalType\":\"contract ICore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositToken0\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositToken1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"epochToToken0Rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"epochToToken1Rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"token0Fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1Fees\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_epochDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_token0FloorNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_token1FloorNum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_uniswapFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapRouter\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNativeVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastEpochStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expectedPoolToken0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedPoolToken1\",\"type\":\"uint256\"}],\"name\":\"nextEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epochDuration\",\"type\":\"uint256\"}],\"name\":\"setEpochDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_token0FloorNum\",\"type\":\"uint256\"}],\"name\":\"setToken0Floor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_token1FloorNum\",\"type\":\"uint256\"}],\"name\":\"setToken1Floor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"token0Balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"token0BalanceDay0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0Data\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"active\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositRequestsTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawRequestsTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimableTotal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0FloorNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0ValueLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"token0WithdrawRequests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"token1Balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"token1BalanceDay0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1Data\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"active\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositRequestsTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawRequestsTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimableTotal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1FloorNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1ValueLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"token1WithdrawRequests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken0\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UniswapVault", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}