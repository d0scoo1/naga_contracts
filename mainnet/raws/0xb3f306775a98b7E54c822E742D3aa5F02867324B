{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// Deployed at: 0x16c0e3D33B332E9BFab3A2de322cBA7Ca02c0638\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n//PROXY PROGRAM TO EXTEND MINTING CAPABILITIES OF THE NFT-PANDEMIC CONTRACT\r\n\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is 0x address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\nabstract contract Functional {\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n    \r\n    bool private _reentryKey = false;\r\n    modifier reentryLock {\r\n        require(!_reentryKey, \"attempt reenter locked function\");\r\n        _reentryKey = true;\r\n        _;\r\n        _reentryKey = false;\r\n    }\r\n}\r\n\r\ncontract PANDEMIC {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance){}\r\n    function ownerOf(uint256 tokenId) external view returns (address owner){}\r\n    function safeTransferFrom(address from,address to,uint256 tokenId) external{}\r\n    function transferFrom(address from, address to, uint256 tokenId) external{}\r\n    function approve(address to, uint256 tokenId) external{}\r\n    function getApproved(uint256 tokenId) external view returns (address operator){}\r\n    function setApprovalForAll(address operator, bool _approved) external{}\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool){}\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external{}\r\n\r\n\r\n    //required calls:\r\n\r\n    function totalSupply() external view returns (uint256) {}\r\n\r\n    //proxy access functions:\r\n    function proxyMint(address to, uint256 tokenId) external {\r\n    //transfer from 0x00 and totalSupply()+1\r\n    }\r\n    \r\n    function proxyBurn(uint256 tokenId) external {\r\n    //transfer to 0x00 and totalSupply()-1\r\n    }\r\n    \r\n    function proxyTransfer(address from, address to, uint256 tokenId) external {\r\n    //\t_transfer(from, to, tokenId);\r\n    }\r\n}\r\n\r\ncontract PandemicExtension is Ownable, Functional {\r\n\r\n    uint256 maxSupply = 6666;\r\n    uint256 collectionStart = 10000;\r\n    uint256 lottoCap = 100;\r\n    \r\n    bool lottoActive;\r\n    bool spawnActive;\r\n    bool mutateActive;\r\n    \r\n    mapping (address => bool) received;\r\n    mapping (uint256 => bool) claimed;\r\n\r\n    address[] lotteryHolders;\r\n    uint256[] lotteryTokens;\r\n\r\n    PANDEMIC proxy = PANDEMIC(0x4Ad8A7406Caac3457981A1B3C88B8aAB00D6e13d);\r\n\r\n\tfunction sneeze(address to, uint256 tokenId) external reentryLock {\r\n\t\tuint256 curSupply = proxy.totalSupply();\r\n\t\trequire(proxy.ownerOf(tokenId) == _msgSender(), \"Invalid tokenId\");\r\n\t\trequire(curSupply < maxSupply - 2, \"Supply Drained\");\r\n\t\trequire(received[to] == false, \"Already sneezed on\");\r\n\t\t\r\n\t\treceived[to] = true;\r\n\t\t\r\n\t\tproxy.proxyTransfer(_msgSender(), to, tokenId);\r\n\t\tproxy.proxyMint(to, curSupply);\r\n\t\tproxy.proxyMint(to, curSupply + 1);\r\n\t}\r\n\t\r\n\t///////////////////////////////////// LOTTO Section ////////////////////\r\n\t\r\n\tfunction enterLottery(uint256 tokenId) external reentryLock {\r\n\t\trequire(lottoActive, \"Entry Unavailable\");\r\n\t\trequire(proxy.ownerOf(tokenId) == _msgSender(), \"Invalid tokenId\");\r\n        require(lotteryHolders.length < lottoCap, \"Entries Filled\");\r\n\t\t\r\n\t\tlotteryHolders.push(_msgSender());\r\n\t\tlotteryTokens.push(tokenId);\r\n\t\t\r\n\t\tproxy.proxyBurn(tokenId);\r\n\t}\r\n\t\r\n\tfunction countLottoTickets() external view returns (uint256) {\r\n\t\treturn lotteryHolders.length;\r\n\t}\r\n\t\r\n\tfunction awardLottoWinner(uint256 ticketId) external onlyOwner {\r\n\t\taddress to = lotteryHolders[ticketId];\r\n\t\tuint256 tokenId = lotteryTokens[ticketId];\r\n\t\t\r\n\t\tproxy.proxyMint(to, tokenId);\r\n\t\t_clearLottery();\r\n\t}\r\n\t\r\n\tfunction scanTokenId(uint ticketId) external view returns (uint256) {\r\n\t\t//failsafe to ensure the winning token can be tracked.\r\n\t\treturn lotteryTokens[ticketId];\r\n\t}\r\n\r\n\tfunction scanTokenWinner(uint ticketId) external view returns (address) {\r\n\t\t//failsafe to ensure the winner can be tracked.\r\n\t\treturn lotteryHolders[ticketId];\r\n\t}\r\n\t\t\r\n\tfunction _clearLottery() internal {\r\n\t\tfor (uint256 i=0; i < lotteryHolders.length; i++){\r\n\t\t\tlotteryHolders.pop();\r\n\t\t\tlotteryTokens.pop();\r\n\t\t}\r\n\t}\r\n\r\n    function setLottoCapLimit(uint256 newLimit) external onlyOwner {\r\n        lottoCap = newLimit;\r\n    }\r\n\t\r\n\tfunction activateLotto() external onlyOwner {\r\n\t\tlottoActive = true;\r\n\t}\r\n\t\r\n\tfunction deactivateLotto() external onlyOwner {\r\n\t\tlottoActive = false;\r\n\t}\r\n\r\n\t/////////////////////////////////// NEW Collections ///////////////////\r\n\t\r\n\tfunction spawn(uint256 tokenId) external reentryLock {\r\n        uint256 newToken = tokenId + collectionStart;\r\n        require(tokenId < 10000, \"Only for OG Virus\");\r\n        require(spawnActive, \"Not Ready\");\r\n        require(proxy.ownerOf(tokenId) == _msgSender(), \"Invalid tokenId\");\r\n\t\trequire(claimed[newToken] == false, \"AlreadyIssued\");\r\n\r\n        claimed[newToken] == true;\r\n        proxy.proxyMint(_msgSender(), newToken);\r\n\t}\r\n\t\r\n\tfunction mutate(uint256 tokenId) external reentryLock {\r\n        uint256 newToken = tokenId + collectionStart;\r\n        require(tokenId < 10000, \"Only for OG Virus\");\r\n        require(mutateActive, \"Not Ready\");\r\n        require(proxy.ownerOf(tokenId) == _msgSender(), \"Invalid tokenId\");\r\n\t\trequire(claimed[newToken] == false, \"AlreadyIssued\");\r\n\r\n        claimed[newToken] == true;\r\n        proxy.proxyBurn( tokenId );\r\n        proxy.proxyMint(_msgSender(), newToken);\r\n\t}\r\n\t\r\n\tfunction setCollectionStart(uint256 newCollectionTId) external onlyOwner {\r\n        collectionStart = newCollectionTId;\r\n\t}\r\n\t\r\n\tfunction activateSpawn() external onlyOwner {\r\n\t\tspawnActive = true;\r\n\t}\r\n\t\r\n\tfunction activateMutate() external onlyOwner {\r\n        mutateActive = true;\r\n\t}\r\n\t\r\n\tfunction deactivateSpawn() external onlyOwner {\r\n        spawnActive = false;\r\n\t}\r\n\t\r\n\tfunction deactivateMutate() external onlyOwner {\r\n        mutateActive = true;\r\n\t}\r\n\t\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activateLotto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activateMutate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activateSpawn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"}],\"name\":\"awardLottoWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countLottoTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deactivateLotto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deactivateMutate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deactivateSpawn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"enterLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mutate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"}],\"name\":\"scanTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"}],\"name\":\"scanTokenWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCollectionTId\",\"type\":\"uint256\"}],\"name\":\"setCollectionStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"setLottoCapLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"sneeze\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"spawn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PandemicExtension", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c8a299d772e21df4f1494912fd739ce379c9489ea7b1d16b2ba40b881537233c"}]}