{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            codehash := extcodehash(account)\\n        }\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance \\u003e= amount,\\n            \\\"SCOLT : insufficient balance\\\"\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(\\n            success,\\n            \\\"SCOLT : unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return functionCall(target, data, \\\"SCOLT : low-level call failed\\\");\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                \\\"SCOLT : low-level call with value failed\\\"\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance \\u003e= value,\\n            \\\"SCOLT : insufficient balance for call\\\"\\n        );\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 weiValue,\\n        string memory errorMessage\\n    ) private returns (bytes memory) {\\n        require(isContract(target), \\\"SCOLT : call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\\n            data\\n        );\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"Conditions.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"./Variables.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary SCOLTLibrary {\\n\\n    // Contract imports\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    uint256 constant DAY_IN_SECONDS = 86400;\\n    uint256 constant YEAR_IN_SECONDS = 31536000;\\n    uint256 constant LEAP_YEAR_IN_SECONDS = 31622400;\\n\\n    uint256 constant HOUR_IN_SECONDS = 3600;\\n    uint256 constant MINUTE_IN_SECONDS = 60;\\n\\n    uint16 constant ORIGIN_YEAR = 1970;\\n\\n    function isLeapYear(uint16 year) public pure returns (bool) {\\n        if (year % 4 != 0) {\\n            return false;\\n        }\\n        if (year % 100 != 0) {\\n            return true;\\n        }\\n        if (year % 400 != 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    function leapYearsBefore(uint256 year) public pure returns (uint256) {\\n        uint256 localyear = year;\\n        localyear -= 1;\\n        return localyear / 4 - localyear / 100 + localyear / 400;\\n    }\\n\\n    function getDaysInMonth(uint8 month, uint16 year)\\n        public\\n        pure\\n        returns (uint8)\\n    {\\n        if (\\n            month == 1 ||\\n            month == 3 ||\\n            month == 5 ||\\n            month == 7 ||\\n            month == 8 ||\\n            month == 10 ||\\n            month == 12\\n        ) {\\n            return 31;\\n        } else if (month == 4 || month == 6 || month == 9 || month == 11) {\\n            return 30;\\n        } else if (isLeapYear(year)) {\\n            return 29;\\n        } else {\\n            return 28;\\n        }\\n    }\\n\\n    function parseTimestamp(uint256 timestamp)\\n        public\\n        pure\\n        returns (Variables._DateTime memory dt)\\n    {\\n        uint256 secondsAccountedFor = 0;\\n        uint256 buf;\\n        uint8 i;\\n\\n        // Year\\n        dt.year = getYear(timestamp);\\n        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\\n        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\\n\\n        // Month\\n        uint256 secondsInMonth;\\n        for (i = 1; i \\u003c= 12; i++) {\\n            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\\n            if (secondsInMonth + secondsAccountedFor \\u003e timestamp) {\\n                dt.month = i;\\n                break;\\n            }\\n            secondsAccountedFor += secondsInMonth;\\n        }\\n\\n        // Day\\n        for (i = 1; i \\u003c= getDaysInMonth(dt.month, dt.year); i++) {\\n            if (DAY_IN_SECONDS + secondsAccountedFor \\u003e timestamp) {\\n                dt.day = i;\\n                break;\\n            }\\n            secondsAccountedFor += DAY_IN_SECONDS;\\n        }\\n\\n        // Hour\\n        dt.hour = getHour(timestamp);\\n\\n        // Minute\\n        dt.minute = getMinute(timestamp);\\n\\n        // Second\\n        dt.second = getSecond(timestamp);\\n\\n        // Day of week.\\n        dt.weekday = getWeekday(timestamp);\\n    }\\n\\n    function getYear(uint256 timestamp) public pure returns (uint16) {\\n        uint256 secondsAccountedFor = 0;\\n        uint16 year;\\n        uint256 numLeapYears;\\n\\n        // Year\\n        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\\n        secondsAccountedFor +=\\n            YEAR_IN_SECONDS *\\n            (year - ORIGIN_YEAR - numLeapYears);\\n\\n        while (secondsAccountedFor \\u003e timestamp) {\\n            if (isLeapYear(uint16(year - 1))) {\\n                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\\n            } else {\\n                secondsAccountedFor -= YEAR_IN_SECONDS;\\n            }\\n            year -= 1;\\n        }\\n        return year;\\n    }\\n\\n    function getMonth(uint256 timestamp) public pure returns (uint8) {\\n        return parseTimestamp(timestamp).month;\\n    }\\n\\n    function getDay(uint256 timestamp) public pure returns (uint8) {\\n        return parseTimestamp(timestamp).day;\\n    }\\n\\n    function getHour(uint256 timestamp) public pure returns (uint8) {\\n        return uint8((timestamp / 60 / 60) % 24);\\n    }\\n\\n    function getMinute(uint256 timestamp) public pure returns (uint8) {\\n        return uint8((timestamp / 60) % 60);\\n    }\\n\\n    function getSecond(uint256 timestamp) public pure returns (uint8) {\\n        return uint8(timestamp % 60);\\n    }\\n\\n    function getWeekday(uint256 timestamp) public pure returns (uint8) {\\n        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\\n    }\\n\\n    function toTimestamp(\\n        uint16 year,\\n        uint8 month,\\n        uint8 day\\n    ) public pure returns (uint256 timestamp) {\\n        return toTimestamp(year, month, day, 0, 0, 0);\\n    }\\n\\n    function toTimestamp(\\n        uint16 year,\\n        uint8 month,\\n        uint8 day,\\n        uint8 hour\\n    ) public pure returns (uint256 timestamp) {\\n        return toTimestamp(year, month, day, hour, 0, 0);\\n    }\\n\\n    function toTimestamp(\\n        uint16 year,\\n        uint8 month,\\n        uint8 day,\\n        uint8 hour,\\n        uint8 minute\\n    ) public pure returns (uint256 timestamp) {\\n        return toTimestamp(year, month, day, hour, minute, 0);\\n    }\\n\\n    function toTimestamp(\\n        uint16 year,\\n        uint8 month,\\n        uint8 day,\\n        uint8 hour,\\n        uint8 minute,\\n        uint8 second\\n    ) public pure returns (uint256 timestamp) {\\n        uint16 i;\\n\\n        // Year\\n        for (i = ORIGIN_YEAR; i \\u003c year; i++) {\\n            if (isLeapYear(i)) {\\n                timestamp += LEAP_YEAR_IN_SECONDS;\\n            } else {\\n                timestamp += YEAR_IN_SECONDS;\\n            }\\n        }\\n\\n        // Month\\n        uint8[12] memory monthDayCounts;\\n        monthDayCounts[0] = 31;\\n        if (isLeapYear(year)) {\\n            monthDayCounts[1] = 29;\\n        } else {\\n            monthDayCounts[1] = 28;\\n        }\\n        monthDayCounts[2] = 31;\\n        monthDayCounts[3] = 30;\\n        monthDayCounts[4] = 31;\\n        monthDayCounts[5] = 30;\\n        monthDayCounts[6] = 31;\\n        monthDayCounts[7] = 31;\\n        monthDayCounts[8] = 30;\\n        monthDayCounts[9] = 31;\\n        monthDayCounts[10] = 30;\\n        monthDayCounts[11] = 31;\\n\\n        for (i = 1; i \\u003c month; i++) {\\n            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\\n        }\\n\\n        // Day\\n        timestamp += DAY_IN_SECONDS * (day - 1);\\n\\n        // Hour\\n        timestamp += HOUR_IN_SECONDS * (hour);\\n\\n        // Minute\\n        timestamp += MINUTE_IN_SECONDS * (minute);\\n\\n        // Second\\n        timestamp += second;\\n\\n        return timestamp;\\n    }\\n\\n    function toTimestampFromDateTime(Variables._DateTime memory date)\\n        public\\n        pure\\n        returns (uint256 timestamp)\\n    {\\n        uint16 year = date.year;\\n        uint8 month = date.month;\\n        uint8 day = date.day;\\n        uint8 hour = date.hour;\\n        uint8 minute = date.minute;\\n        uint8 second = date.second;\\n        uint16 i;\\n\\n        // Year\\n        for (i = ORIGIN_YEAR; i \\u003c year; i++) {\\n            if (isLeapYear(i)) {\\n                timestamp += LEAP_YEAR_IN_SECONDS;\\n            } else {\\n                timestamp += YEAR_IN_SECONDS;\\n            }\\n        }\\n\\n        // Month\\n        uint8[12] memory monthDayCounts;\\n        monthDayCounts[0] = 31;\\n        if (isLeapYear(year)) {\\n            monthDayCounts[1] = 29;\\n        } else {\\n            monthDayCounts[1] = 28;\\n        }\\n        monthDayCounts[2] = 31;\\n        monthDayCounts[3] = 30;\\n        monthDayCounts[4] = 31;\\n        monthDayCounts[5] = 30;\\n        monthDayCounts[6] = 31;\\n        monthDayCounts[7] = 31;\\n        monthDayCounts[8] = 30;\\n        monthDayCounts[9] = 31;\\n        monthDayCounts[10] = 30;\\n        monthDayCounts[11] = 31;\\n\\n        for (i = 1; i \\u003c month; i++) {\\n            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\\n        }\\n\\n        // Day\\n        timestamp += DAY_IN_SECONDS * (day - 1);\\n\\n        // Hour\\n        timestamp += HOUR_IN_SECONDS * (hour);\\n\\n        // Minute\\n        timestamp += MINUTE_IN_SECONDS * (minute);\\n\\n        // Second\\n        timestamp += second;\\n\\n        return timestamp;\\n    }\\n\\n    function _check_time_condition(\\n        uint256 current_timestamp,\\n        uint256 last_timestamp,\\n        uint256 diff\\n    ) public pure returns (bool) {\\n        if ((current_timestamp - last_timestamp) \\u003e= ((diff * 24) * 3600)) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _checkrules(\\n        Variables.wallet_details memory sender_wallet,\\n        Variables.wallet_details memory recipient_wallet,\\n        Variables.ctc_approval_details memory transferer_ctc_details,\\n        Variables.checkrules_additional_var memory variables\\n    ) public view {\\n        // Checking if sender requested for any C2C transfer or not\\n        if (transferer_ctc_details.has_value) {\\n            if (transferer_ctc_details.allowed_till \\u003e= block.timestamp) {\\n                if (!transferer_ctc_details.used) {\\n                    revert(\\n                        \\\"SCOLT : You can not make transfer while applied for C2C transfer.\\\"\\n                    );\\n                }\\n            }\\n        }\\n\\n        // Inter seller transfer not allowed\\n        if (variables._sellers_check_recipient) {\\n            if (variables._sellers_check_sender) {\\n                revert(\\\"SCOLT : Inter seller exchange is not allowed.\\\");\\n            }\\n        }\\n\\n        // Checking if sender or reciver is contract or not and also registered seller or not\\n        // Only Liquidity Wallet can create new pair in dex. ( Unregister Contract )\\n        if (\\n            variables.recipient.isContract()\\n        ) {\\n            if (variables._sellers_check_recipient) {\\n                if (\\n                    sender_wallet.wallet_type == Variables.type_of_wallet.UndefinedWallet ||\\n                    sender_wallet.wallet_type == Variables.type_of_wallet.DexPairWallet ||\\n                    sender_wallet.wallet_type == Variables.type_of_wallet.FutureTeamWallet\\n                ) {\\n                    revert(\\n                        \\\"SCOLT : You are not allowed to send tokens to DexPairWallet\\\"\\n                    );\\n                }\\n            } else {\\n                if (\\n                    sender_wallet.wallet_type != Variables.type_of_wallet.LiquidityWallet\\n                ) {\\n                    revert(\\n                        \\\"SCOLT : You are trying to reach unregistered DexPairWallet.\\\"\\n                    );\\n                }\\n            }\\n        }\\n\\n        if (\\n            variables.sender.isContract()\\n        ) {\\n            if (!variables._sellers_check_sender) {\\n                if (\\n                    recipient_wallet.wallet_type != Variables.type_of_wallet.LiquidityWallet\\n                ) {\\n                    revert(\\n                        \\\"SCOLT : Unregistered DexPairWallet are not allowed to send tokens.\\\"\\n                    );\\n                }\\n            }\\n        }\\n\\n        if (\\n            sender_wallet.wallet_type != Variables.type_of_wallet.GenesisWallet \\u0026\\u0026\\n            sender_wallet.wallet_type != Variables.type_of_wallet.DirectorWallet \\u0026\\u0026\\n            sender_wallet.wallet_type != Variables.type_of_wallet.UnsoldTokenWallet \\u0026\\u0026\\n            sender_wallet.wallet_type != Variables.type_of_wallet.GeneralWallet \\u0026\\u0026\\n            sender_wallet.wallet_type != Variables.type_of_wallet.DexPairWallet \\u0026\\u0026\\n            sender_wallet.wallet_type != Variables.type_of_wallet.FutureTeamWallet\\n        ) {\\n            if ( sender_wallet.wallet_type != Variables.type_of_wallet.LiquidityWallet ) {\\n                require(variables._sellers_check_recipient \\u0026\\u0026 variables.recipient.isContract(), \\\"SCOLT : This type of wallet is not allowed to do this transaction.\\\");\\n            } else {\\n                require(variables.recipient.isContract(), \\\"SCOLT : This type of wallet is not allowed to do this transaction.\\\");\\n            }\\n        }\\n\\n        // Rules for marketing and poolairdrop\\n        if (\\n            sender_wallet.wallet_type == Variables.type_of_wallet.MarketingWallet ||\\n            sender_wallet.wallet_type == Variables.type_of_wallet.PoolOrAirdropWallet\\n        ) {\\n            require(\\n                recipient_wallet.wallet_type == Variables.type_of_wallet.GeneralWallet || variables.recipient.isContract(),\\n                \\\"SCOLT : This type of wallet is not allowed to do this transaction.\\\"\\n            );\\n        }\\n\\n        // FutureTeamWallet Only can send to GeneralWallet and recieve from genesis\\n        if ( sender_wallet.wallet_type == Variables.type_of_wallet.FutureTeamWallet ) {\\n            require(\\n                recipient_wallet.wallet_type == Variables.type_of_wallet.GeneralWallet,\\n                \\\"SCOLT : You are not allowed to send any tokens other than General Type of Wallet.\\\"\\n            );\\n        }\\n        if ( recipient_wallet.wallet_type == Variables.type_of_wallet.FutureTeamWallet ) {\\n            require(\\n                sender_wallet.wallet_type == Variables.type_of_wallet.GenesisWallet,\\n                \\\"SCOLT : You are not allowed to send any tokens to Future Team Wallet.\\\"\\n            );\\n        }\\n\\n        // Checking investor block rule, time based\\n        if (sender_wallet.is_investor) {\\n            require(\\n                _check_time_condition(\\n                    block.timestamp,\\n                    toTimestampFromDateTime(sender_wallet.joining_date),\\n                    Variables._investor_swap_lock_days\\n                ),\\n                \\\"SCOLT : Investor account can perform any transfer after 180 days only\\\"\\n            );\\n        }\\n\\n        if (variables._sellers_check_recipient \\u0026\\u0026 sender_wallet.anti_dump) {\\n            // This is for anti dump for all wallet\\n\\n            // Director account restriction check.\\n            if (sender_wallet.wallet_type == Variables.type_of_wallet.DirectorWallet) {\\n                if (\\n                    _check_time_condition(\\n                        block.timestamp,\\n                        toTimestampFromDateTime(sender_wallet.last_sale_date),\\n                        1\\n                    )\\n                ) {\\n                    if (variables.amount \\u003e Variables._max_sell_per_director_per_day) {\\n                        revert(\\n                            \\\"SCOLT : Director can only send 10000 SCOLT every 24 hours\\\"\\n                        );\\n                    }\\n                } else {\\n                    if (\\n                        sender_wallet.lastday_total_sell + variables.amount \\u003e\\n                        Variables._max_sell_per_director_per_day\\n                    ) {\\n                        revert(\\n                            \\\"SCOLT : Director can only send 10000 SCOLT every 24 hours\\\"\\n                        );\\n                    }\\n                }\\n            }\\n\\n            // General account restriction check.\\n            if (sender_wallet.wallet_type == Variables.type_of_wallet.GeneralWallet) {\\n                if (\\n                    sender_wallet.concurrent_sale_day_count \\u003e=\\n                    Variables._max_concurrent_sale_day\\n                ) {\\n                    if (\\n                        !_check_time_condition(\\n                            block.timestamp,\\n                            toTimestampFromDateTime(\\n                                sender_wallet.last_sale_date\\n                            ),\\n                            1\\n                        )\\n                    ) {\\n                        if (\\n                            sender_wallet.balance \\u003e= Variables._whale_per \\u0026\\u0026\\n                            sender_wallet.antiwhale_apply == true\\n                        ) {\\n                            if (\\n                                sender_wallet.lastday_total_sell + variables.amount \\u003e\\n                                Variables._max_sell_amount_whale\\n                            ) {\\n                                revert(\\n                                    \\\"SCOLT : You can not sell more than 5000 SCOLT in past 24 hours.\\\"\\n                                );\\n                            }\\n                        } else {\\n                            if (\\n                                sender_wallet.lastday_total_sell + variables.amount \\u003e\\n                                Variables._max_sell_amount_normal\\n                            ) {\\n                                revert(\\n                                    \\\"SCOLT : You can not sell more than 2000 SCOLT in past 24 hours.\\\"\\n                                );\\n                            }\\n                        }\\n                    } else {\\n                        if (\\n                            !_check_time_condition(\\n                                block.timestamp,\\n                                toTimestampFromDateTime(\\n                                    sender_wallet.last_sale_date\\n                                ),\\n                                Variables._cooling_days + 1\\n                            )\\n                        ) {\\n                            revert(\\n                                \\\"SCOLT : Concurrent sell for more than 6 days not allowed. You can not sell for next 72 Hours\\\"\\n                            );\\n                        } else {\\n                            if (\\n                                sender_wallet.balance \\u003e= Variables._whale_per \\u0026\\u0026\\n                                sender_wallet.antiwhale_apply == true\\n                            ) {\\n                                if (variables.amount \\u003e Variables._max_sell_amount_whale) {\\n                                    revert(\\n                                        \\\"SCOLT : You can not sell more than 5000 SCOLT in past 24 hours.\\\"\\n                                    );\\n                                }\\n                            } else {\\n                                if (variables.amount \\u003e Variables._max_sell_amount_normal) {\\n                                    revert(\\n                                        \\\"SCOLT : You can not sell more than 2000 SCOLT in past 24 hours.\\\"\\n                                    );\\n                                }\\n                            }\\n                        }\\n                    }\\n                } else {\\n                    if (\\n                        !_check_time_condition(\\n                            block.timestamp,\\n                            toTimestampFromDateTime(\\n                                sender_wallet.last_sale_date\\n                            ),\\n                            1\\n                        )\\n                    ) {\\n                        if (\\n                            sender_wallet.balance \\u003e= Variables._whale_per \\u0026\\u0026\\n                            sender_wallet.antiwhale_apply == true\\n                        ) {\\n                            if (\\n                                sender_wallet.lastday_total_sell + variables.amount \\u003e\\n                                Variables._max_sell_amount_whale\\n                            ) {\\n                                revert(\\n                                    \\\"SCOLT : You can not sell more than 5000 SCOLT in past 24 hours.\\\"\\n                                );\\n                            }\\n                        } else {\\n                            if (\\n                                sender_wallet.lastday_total_sell + variables.amount \\u003e\\n                                Variables._max_sell_amount_normal\\n                            ) {\\n                                revert(\\n                                    \\\"SCOLT : You can not sell more than 2000 SCOLT in past 24 hours.\\\"\\n                                );\\n                            }\\n                        }\\n                    } else {\\n                        if (\\n                            sender_wallet.balance \\u003e= Variables._whale_per \\u0026\\u0026\\n                            sender_wallet.antiwhale_apply == true\\n                        ) {\\n                            if (variables.amount \\u003e Variables._max_sell_amount_whale) {\\n                                revert(\\n                                    \\\"SCOLT : You can not sell more than 5000 SCOLT in past 24 hours.\\\"\\n                                );\\n                            }\\n                        } else {\\n                            if (variables.amount \\u003e Variables._max_sell_amount_normal) {\\n                                revert(\\n                                    \\\"SCOLT : You can not sell more than 2000 SCOLT in past 24 hours.\\\"\\n                                );\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function _after_transfer_updates(\\n        uint256 amount,\\n        Variables.wallet_details memory sender_wallet,\\n        bool _sellers_check_recipient\\n    ) public view returns (\\n        Variables.wallet_details memory\\n    ){\\n        Variables._DateTime memory tdt = parseTimestamp(block.timestamp);\\n        Variables._DateTime memory lsd;\\n\\n        lsd = Variables._DateTime(tdt.year, tdt.month, tdt.day, 0, 0, 0, tdt.weekday);\\n\\n        // For Antidump rule\\n        if (_sellers_check_recipient) {\\n            // General wallet supporting entries\\n            if (sender_wallet.wallet_type == Variables.type_of_wallet.GeneralWallet) {\\n                if (\\n                    _check_time_condition(\\n                        block.timestamp,\\n                        toTimestampFromDateTime(sender_wallet.last_sale_date),\\n                        1\\n                    )\\n                ) {\\n                    sender_wallet.lastday_total_sell = 0; // reseting sale at 24 hours\\n                    if (\\n                        _check_time_condition(\\n                            block.timestamp,\\n                            toTimestampFromDateTime(\\n                                sender_wallet.last_sale_date\\n                            ),\\n                            2\\n                        )\\n                    ) {\\n                        sender_wallet.concurrent_sale_day_count = 1;\\n                    } else {\\n                        sender_wallet.concurrent_sale_day_count = sender_wallet\\n                            .concurrent_sale_day_count\\n                            .add(1);\\n                    }\\n                    sender_wallet.last_sale_date = lsd;\\n                    sender_wallet.lastday_total_sell = sender_wallet\\n                        .lastday_total_sell\\n                        .add(amount);\\n                } else {\\n                    sender_wallet.lastday_total_sell = sender_wallet\\n                        .lastday_total_sell\\n                        .add(amount);\\n                    if (sender_wallet.concurrent_sale_day_count == 0) {\\n                        sender_wallet.concurrent_sale_day_count = 1;\\n                        sender_wallet.last_sale_date = lsd;\\n                    }\\n                }\\n            }\\n            // Director wallet supporting entries\\n            if (sender_wallet.wallet_type == Variables.type_of_wallet.DirectorWallet) {\\n                if (\\n                    _check_time_condition(\\n                        block.timestamp,\\n                        toTimestampFromDateTime(sender_wallet.last_sale_date),\\n                        1\\n                    )\\n                ) {\\n                    sender_wallet.lastday_total_sell = 0; // reseting director sale at 24 hours\\n                    sender_wallet.last_sale_date = lsd;\\n                    sender_wallet.lastday_total_sell = sender_wallet\\n                        .lastday_total_sell\\n                        .add(amount);\\n                } else {\\n                    sender_wallet.lastday_total_sell = sender_wallet\\n                        .lastday_total_sell\\n                        .add(amount);\\n                    if (sender_wallet.concurrent_sale_day_count == 0) {\\n                        sender_wallet.concurrent_sale_day_count = 1;\\n                        sender_wallet.last_sale_date = lsd;\\n                    }\\n                }\\n            }\\n        }\\n        return sender_wallet;\\n    }\\n\\n    function contributionsCalc(\\n        Variables.wallet_details memory sender_wallet,\\n        Variables.wallet_details memory recipient_wallet,\\n        Variables.wallet_details memory marketing_wallet,\\n        Variables.wallet_details memory development_wallet,\\n        Variables.function_addresses memory addresses,\\n        Variables.function_amounts memory amounts\\n    ) public pure returns (\\n        Variables.distribution_variables memory,\\n        bool, // Sender Contribution Deduct ?\\n        Variables.wallet_details memory, // marketing wallet update\\n        Variables.wallet_details memory, // development wallet update\\n        uint256, // pending contribution update\\n        uint256, // total supply update\\n        uint256 // burning till now update\\n    ) {\\n        Variables.distribution_variables memory dv;\\n\\n        if (addresses.sender == addresses.owner || addresses.sender == addresses.this_address) {\\n            return (\\n                dv,\\n                true,\\n                marketing_wallet,\\n                development_wallet,\\n                amounts.pending_contribution_to_distribute,\\n                amounts.total_supply,\\n                amounts.burning_till_now\\n            );\\n        }\\n\\n        if (sender_wallet.contribution_apply == false) {\\n            return (\\n                dv,\\n                true,\\n                marketing_wallet,\\n                development_wallet,\\n                amounts.pending_contribution_to_distribute,\\n                amounts.total_supply,\\n                amounts.burning_till_now\\n            );\\n        }\\n\\n        // Calculate contributions based on whale or not whale\\n        if (\\n            sender_wallet.balance \\u003e=  Variables._whale_per \\u0026\\u0026\\n            sender_wallet.antiwhale_apply == true\\n        ) {\\n            dv.total_contributions = ((amounts.amount * Variables._whale_contribution_per) / 100);\\n            dv.marketing_contributions = ((dv.total_contributions * Variables._whale_marketing_share) / 100);\\n            dv.development_contributions = ((dv.total_contributions * Variables._whale_development_share) / 100);\\n            dv.holder_contributions = ((dv.total_contributions * Variables._whale_holder_share) / 100);\\n            dv.burn_amount = ((dv.total_contributions * Variables._whale_burning_share) / 100);\\n        } else {\\n            dv.total_contributions = ((amounts.amount * Variables._normal_contribution_per) / 100);\\n            dv.marketing_contributions = ((dv.total_contributions * Variables._normal_marketing_share) / 100);\\n            dv.development_contributions = ((dv.total_contributions * Variables._normal_development_share) / 100);\\n            dv.holder_contributions = ((dv.total_contributions * Variables._normal_holder_share) / 100);\\n            dv.burn_amount = ((dv.total_contributions * Variables._normal_burning_share) / 100);\\n        }\\n\\n        // add cut to defined acounts\\n        if (amounts.total_supply \\u003c (amounts.initial_total_supply / 2)) {\\n            dv.total_contributions = dv.total_contributions.sub(dv.burn_amount);\\n            dv.burn_amount = 0;\\n        }\\n\\n        bool sender_contribution_deduct = false;\\n\\n        // if contract type wallet then following condtion is default false\\n        if (\\n            (sender_wallet.balance \\u003e= amounts.amount + dv.total_contributions) \\u0026\\u0026\\n            (recipient_wallet.wallet_type != Variables.type_of_wallet.DexPairWallet)\\n        ) {\\n            if (dv.marketing_contributions \\u003e 0) {\\n                marketing_wallet.balance = marketing_wallet.balance.add(dv.marketing_contributions);\\n            }\\n\\n            if (dv.development_contributions \\u003e 0) {\\n                development_wallet.balance = development_wallet.balance.add(dv.development_contributions);\\n            }\\n\\n            if (dv.holder_contributions \\u003e 0) {\\n                amounts.pending_contribution_to_distribute = amounts.pending_contribution_to_distribute.add(\\n                    dv.holder_contributions\\n                );\\n            }\\n\\n            if (dv.burn_amount \\u003e 0) {\\n                amounts.total_supply = amounts.total_supply.sub(dv.burn_amount);\\n                amounts.burning_till_now = amounts.burning_till_now.add(dv.burn_amount);\\n            }\\n            sender_contribution_deduct = true;\\n        } else {\\n            if (dv.marketing_contributions \\u003e 0) {\\n                marketing_wallet.balance = marketing_wallet.balance.add(dv.marketing_contributions);\\n            }\\n\\n            if (dv.development_contributions \\u003e 0) {\\n                development_wallet.balance = development_wallet.balance.add(dv.development_contributions);\\n            }\\n\\n            if (dv.holder_contributions \\u003e 0) {\\n                amounts.pending_contribution_to_distribute = amounts.pending_contribution_to_distribute.add(\\n                    dv.holder_contributions\\n                );\\n            }\\n\\n            if (dv.burn_amount \\u003e 0) {\\n                amounts.total_supply = amounts.total_supply.sub(dv.burn_amount);\\n                amounts.burning_till_now = amounts.burning_till_now.add(dv.burn_amount);\\n            }\\n        }\\n\\n        return (\\n            dv,\\n            sender_contribution_deduct,\\n            marketing_wallet,\\n            development_wallet,\\n            amounts.pending_contribution_to_distribute,\\n            amounts.total_supply,\\n            amounts.burning_till_now\\n        );\\n    }\\n}\\n\"},\"IBEP20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\ninterface IBEP20 {\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function name() external view returns (string memory);\\n\\n    function getOwner() external view returns (address);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Burn(address indexed burner, uint256 value);\\n\\n    event Mint(address indexed minter, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    // Custom Event for making log entry for contract\\n    event ContributionAirDropUpdate(\\n        uint256 _total_beneficiary_count,\\n        uint256 _distributed_amount,\\n        uint256 _total_eligible_circulation,\\n        uint256 _timestamp\\n    );\\n    event ContributionAddedToContributionDistributionVariable(uint256 contribution);\\n\\n    event PublicAirDrop(\\n        uint256 _total_amount,\\n        uint256 _number_of_reciepent,\\n        uint256 _timestamp\\n    );\\n\\n    event ProfitAirDrop(\\n        uint256 _total_beneficiary_count,\\n        uint256 _distributed_amount,\\n        uint256 _total_eligible_circulation,\\n        uint256 _timestamp\\n    );\\n\\n    event ContributionDeductionAndBurningLog(\\n        uint256 _marketing_contribution,\\n        uint256 _development_contribution,\\n        uint256 _holder_contribution,\\n        uint256 _burn_amount\\n    );\\n\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nabstract contract Context {\\n\\n    function _msgSender() internal view returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; \\n        return msg.data;\\n    }\\n}\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"SCOLT : (Ownable) This function is only accesible by owner.\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal {\\n        require(\\n            newOwner != address(0),\\n            \\\"SCOLT : (Ownable) Can not transfer ownership to ZERO address.\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"SafeColiseum.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"./Address.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IBEP20.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Conditions.sol\\\";\\nimport \\\"./Variables.sol\\\";\\n\\n// Contract contains no comments or less comments due to chain contract file size issue.\\n\\ncontract SafeColiseum is Context, IBEP20, Ownable {\\n    // Contract imports\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    string private _name =  Variables._name;\\n    string private _symbol =  Variables._symbol;\\n    uint8 private _decimals = Variables._decimals;\\n    uint256 private _initial_total_supply =  Variables._initial_total_supply;\\n    uint256 private _total_supply = Variables._initial_total_supply;\\n\\n    address private _owner;\\n    uint256 private _total_holder = 0;\\n    uint256 private _total_seller = 0;\\n\\n    uint256 private _burning_till_now = 0; // initial burning token count is 0\\n    uint256 private _pending_contribution_to_distribute = 0; // contribution collection till now, after last distribution\\n\\n    mapping(address =\\u003e Variables.wallet_details) private _wallets;\\n    address[] private _holders;\\n    address[] private _sellers;\\n    mapping(address =\\u003e bool) private _sellers_check;\\n    mapping(address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n    mapping(address =\\u003e Variables.ctc_approval_details) private _ctc_approvals; // Contains Approval Details for CTC\\n    \\n    constructor() {\\n        // initial wallet adding process on contract launch\\n        _initialize_default_wallet_and_rules();\\n        _wallets[msg.sender].balance = _total_supply;\\n        _owner = msg.sender;\\n        emit Transfer(address(0), msg.sender, _total_supply);\\n\\n        // Intial Transfers\\n        _transfer(msg.sender, Variables._director_wallet_1, Variables._director_supply_each);\\n        _transfer(msg.sender, Variables._director_wallet_2, Variables._director_supply_each);\\n        _transfer(msg.sender, Variables._marketing_wallet, Variables._marketing_expansion_supply);\\n        _transfer(msg.sender, Variables._governance_wallet, Variables._governance_supply);\\n        _transfer(msg.sender, Variables._liquidity_wallet, Variables._liquidity_supply);\\n        _transfer(msg.sender, Variables._pool_airdrop_wallet, Variables._pool_airdrop_supply);\\n        _transfer(msg.sender, Variables._ifo_wallet, Variables._ifo_supply);\\n        _transfer(\\n            msg.sender,\\n            Variables._development_wallet,\\n            Variables._development_expansion_supply\\n        );\\n        _transfer(msg.sender, Variables._future_team_wallet, Variables._future_team_supply);\\n    }\\n\\n    function _create_wallet(address addr,Variables.type_of_wallet w_type, bool is_investor) private {\\n        bool contribution = false;\\n        bool whale = false;\\n        bool dump = false;\\n        bool investor = is_investor;\\n        if (\\n            w_type == Variables.type_of_wallet.DirectorWallet ||\\n            w_type == Variables.type_of_wallet.MarketingWallet ||\\n            w_type == Variables.type_of_wallet.GovernanceWallet ||\\n            w_type == Variables.type_of_wallet.DevelopmentWallet ||\\n            w_type == Variables.type_of_wallet.DexPairWallet ||\\n            w_type == Variables.type_of_wallet.GeneralWallet\\n        ) {\\n            contribution = true;\\n        }\\n        if (\\n            w_type == Variables.type_of_wallet.DirectorWallet ||\\n            w_type == Variables.type_of_wallet.MarketingWallet ||\\n            w_type == Variables.type_of_wallet.GovernanceWallet ||\\n            w_type == Variables.type_of_wallet.DevelopmentWallet ||\\n            w_type == Variables.type_of_wallet.GeneralWallet\\n        ) {\\n            whale = true;\\n        }\\n        if (\\n            w_type == Variables.type_of_wallet.DirectorWallet ||\\n            w_type == Variables.type_of_wallet.GeneralWallet\\n        ) {\\n            dump = true;\\n        }\\n        if (w_type == Variables.type_of_wallet.GenesisWallet) {\\n            _wallets[addr] = Variables.wallet_details(\\n                w_type,\\n                _total_supply,\\n                0,\\n                0,\\n                SCOLTLibrary.parseTimestamp(block.timestamp),\\n                SCOLTLibrary.parseTimestamp(block.timestamp),\\n                contribution,\\n                whale,\\n                dump,\\n                investor\\n            );\\n        } else {\\n            _wallets[addr] = Variables.wallet_details(\\n                w_type,\\n                0,\\n                0,\\n                0,\\n                SCOLTLibrary.parseTimestamp(block.timestamp),\\n                SCOLTLibrary.parseTimestamp(block.timestamp),\\n                contribution,\\n                whale,\\n                dump,\\n                investor\\n            );\\n        }\\n        if (\\n            w_type != Variables.type_of_wallet.GenesisWallet \\u0026\\u0026\\n            w_type != Variables.type_of_wallet.IfoWallet \\u0026\\u0026\\n            w_type != Variables.type_of_wallet.LiquidityWallet \\u0026\\u0026\\n            w_type != Variables.type_of_wallet.MarketingWallet \\u0026\\u0026\\n            w_type != Variables.type_of_wallet.PoolOrAirdropWallet \\u0026\\u0026\\n            w_type != Variables.type_of_wallet.DevelopmentWallet \\u0026\\u0026\\n            w_type != Variables.type_of_wallet.UnsoldTokenWallet \\u0026\\u0026\\n            w_type != Variables.type_of_wallet.DexPairWallet \\u0026\\u0026\\n            w_type != Variables.type_of_wallet.UndefinedWallet\\n        ) {\\n            _total_holder += 1;\\n            _holders.push(addr);\\n        }\\n    }\\n\\n    function _initialize_default_wallet_and_rules() private {\\n        _create_wallet(msg.sender, Variables.type_of_wallet.GenesisWallet, false); // Adding Ginesis wallets\\n        _create_wallet(Variables._director_wallet_1, Variables.type_of_wallet.DirectorWallet, false); // Adding Directors 1 wallets\\n        _create_wallet(Variables._director_wallet_2, Variables.type_of_wallet.DirectorWallet, false); // Adding Directors 2 wallets\\n        _create_wallet(Variables._marketing_wallet, Variables.type_of_wallet.MarketingWallet, false); // Adding Marketing Wallets\\n        _create_wallet(Variables._liquidity_wallet, Variables.type_of_wallet.LiquidityWallet, false); // Adding Liquidity Wallets\\n        _create_wallet(Variables._governance_wallet, Variables.type_of_wallet.GovernanceWallet, false); // Adding Governance Wallets\\n        _create_wallet(Variables._pool_airdrop_wallet, Variables.type_of_wallet.PoolOrAirdropWallet, false); // Adding PoolOrAirdropWallet Wallet\\n        _create_wallet(Variables._future_team_wallet, Variables.type_of_wallet.FutureTeamWallet, false); // Adding FutureTeamWallet Wallet\\n        _create_wallet(Variables._ifo_wallet, Variables.type_of_wallet.IfoWallet, false); // Adding IFO Wallet\\n        _create_wallet(Variables._development_wallet, Variables.type_of_wallet.DevelopmentWallet, false); // Adding Development Wallet\\n        _create_wallet(Variables._unsold_token_wallet, Variables.type_of_wallet.UnsoldTokenWallet, false); // Adding Unsold Token Wallet\\n    }\\n\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _total_supply;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _wallets[account].balance;\\n    }\\n\\n    function getOwner() external view override returns (address) {\\n        return owner();\\n    }\\n\\n    function burningTillNow() public view returns (uint256) {\\n        return _burning_till_now;\\n    }\\n\\n    function pendingFeeToDistribute() public view returns (uint256) {\\n        return  _pending_contribution_to_distribute;\\n    }\\n\\n    function holderDetails() public view returns (uint256, address[] memory) {\\n        return (_total_holder, _holders);\\n    }\\n\\n    function addSellerWallet(address account) public onlyOwner returns (bool) {\\n        require(account.isContract(), \\\"SCOLT : Only Contract(DEX) can be seller\\\");\\n        if (_wallets[account].wallet_type == Variables.type_of_wallet.UndefinedWallet) {\\n            if (account.isContract()) {\\n                _create_wallet(account, Variables.type_of_wallet.DexPairWallet, false);\\n            } else {\\n                _create_wallet(account, Variables.type_of_wallet.GeneralWallet, false);\\n            }\\n        } else {\\n            _wallets[account].contribution_apply = true;\\n            _wallets[account].antiwhale_apply = false;\\n            _wallets[account].anti_dump = false;\\n        }\\n        _sellers_check[account] = true;\\n        _total_seller += 1;\\n        return true;\\n    }\\n\\n    function removeSellerWallet(address account) public onlyOwner returns (bool) {\\n        require(account.isContract(), \\\"SCOLT : Need Contract Address\\\");\\n        _sellers_check[account] = false;\\n        _total_seller -= 1;\\n        return true;\\n    }\\n\\n    function checkAccountIsSeller(address account) public view returns (bool) {\\n        return _sellers_check[account];\\n    }\\n\\n    function getAccountDetails(address account)\\n        public\\n        view\\n        returns (Variables.wallet_details memory)\\n    {\\n        return _wallets[account];\\n    }\\n\\n    function publicAirdrop(address[] memory recipients, uint256[] memory amounts) public returns (bool) {\\n        Variables.wallet_details storage sender = _wallets[msg.sender];\\n        require(sender.wallet_type == Variables.type_of_wallet.PoolOrAirdropWallet,\\\"SCOLT : You are not allowed to do airdrop\\\");\\n        uint256 total = 0;\\n        for (uint256 i = 0; i \\u003c recipients.length; i++) {\\n            total = total.add(amounts[i]);\\n        }\\n        require(sender.balance \\u003e= total, \\\"SCOLT : Not enough balance for airdrop.\\\");\\n        for (uint256 i = 0; i \\u003c recipients.length; i++) {\\n            if (_wallets[recipients[i]].wallet_type == Variables.type_of_wallet.UndefinedWallet) {\\n                _create_wallet(recipients[i], Variables.type_of_wallet.GeneralWallet, false);\\n            } else {\\n                require(_wallets[recipients[i]].wallet_type == Variables.type_of_wallet.GeneralWallet, \\\"SCOLT : Not all recipients are GeneralWallet\\\");\\n            }\\n            sender.balance = sender.balance.sub(amounts[i].mul(10**_decimals));\\n            _wallets[recipients[i]].balance = _wallets[recipients[i]].balance.add(amounts[i].mul(10**_decimals));\\n        }\\n        emit PublicAirDrop(total, recipients.length, block.timestamp);\\n        return true;\\n    }\\n\\n    function profitAirdrop(uint256 amount) public onlyOwner returns (bool) {\\n        uint256 total_eligible_token = 0;\\n        uint256 distribution_till_now = 0;\\n        uint256 amount_to_transfer;\\n        uint256 eligibale_account_counter = 0;\\n        for (uint256 i = 0; i \\u003c _total_holder; i++) {\\n            if (\\n                _wallets[_holders[i]].balance \\u003e=\\n                Variables._profit_distribution_eligibility\\n            ) {\\n                eligibale_account_counter += 1;\\n                total_eligible_token = total_eligible_token.add(\\n                    _wallets[_holders[i]].balance\\n                );\\n            }\\n        }\\n        for (uint256 i = 0; i \\u003c _total_holder; i++) {\\n            if (\\n                _wallets[_holders[i]].balance \\u003e=\\n                Variables._profit_distribution_eligibility\\n            ) {\\n                amount_to_transfer = (\\n                    amount.mul(\\n                        (_wallets[_holders[i]].balance.mul(10**_decimals))\\n                            .div(total_eligible_token)\\n                    )\\n                ).div(10**_decimals);\\n                _wallets[_holders[i]].balance = _wallets[_holders[i]]\\n                    .balance\\n                    .add(amount_to_transfer);\\n                _wallets[_owner].balance = _wallets[_owner]\\n                    .balance\\n                    .sub(amount_to_transfer);\\n                distribution_till_now += amount_to_transfer;\\n            }\\n        }\\n        emit ProfitAirDrop(\\n            eligibale_account_counter,\\n            distribution_till_now,\\n            total_eligible_token,\\n            block.timestamp\\n        );\\n        return true;\\n    }\\n\\n    function transfer(address recipient, uint256 amount)\\n        public\\n        override\\n        returns (bool)\\n    {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    // Need to check condition for approval method.\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) private {\\n        require(owner != address(0), \\\"SCOLT : Approve from the zero address\\\");\\n        require(spender != address(0), \\\"SCOLT : Approve to the zero address\\\");\\n        require(_wallets[owner].balance \\u003e= amount, \\\"SCOLT : Can not allow more than balance.\\\");\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"SCOLT :transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"SCOLT :decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    // Function to add investment partner\\n    function addInvestmentPartner(address partner_address)\\n        public\\n        onlyOwner\\n        returns (bool)\\n    {\\n        if (\\n            _wallets[partner_address].wallet_type == Variables.type_of_wallet.UndefinedWallet\\n        ) {\\n            revert(\\n                \\\"SCOLT : New wallet address is not allowed to be investment partner.\\\"\\n            );\\n        }\\n        if (_wallets[partner_address].wallet_type != Variables.type_of_wallet.GeneralWallet) {\\n            revert(\\n                \\\"SCOLT : Other than GeneralWallet are not allowed to be investment partner.\\\"\\n            );\\n        }\\n        _wallets[partner_address].is_investor = true;\\n        _wallets[partner_address].joining_date = SCOLTLibrary.parseTimestamp(\\n            block.timestamp\\n        );\\n        return true;\\n    }\\n\\n    function _contribution_airdrop() internal {\\n        uint256 total_eligible_token = 0;\\n        uint256 distribution_till_now = 0;\\n        uint256 amount_to_transfer;\\n        uint256 eligibale_account_counter = 0;\\n        if (_pending_contribution_to_distribute \\u003e= Variables._contribution_distribute_after) {\\n            for (uint256 i = 0; i \\u003c _total_holder; i++) {\\n                if (\\n                    _wallets[_holders[i]].balance \\u003e=\\n                    Variables._contribution_distribution_eligibility\\n                ) {\\n                    eligibale_account_counter += 1;\\n                    total_eligible_token = total_eligible_token.add(\\n                        _wallets[_holders[i]].balance\\n                    );\\n                }\\n            }\\n            for (uint256 i = 0; i \\u003c _total_holder; i++) {\\n                if (\\n                    _wallets[_holders[i]].balance \\u003e=\\n                    Variables._contribution_distribution_eligibility\\n                ) {\\n                    amount_to_transfer = (\\n                        _pending_contribution_to_distribute.mul(\\n                            (_wallets[_holders[i]].balance.mul(10**_decimals))\\n                                .div(total_eligible_token)\\n                        )\\n                    ).div(10**_decimals);\\n                    _wallets[_holders[i]].balance = _wallets[_holders[i]]\\n                        .balance\\n                        .add(amount_to_transfer);\\n                    distribution_till_now += amount_to_transfer;\\n                }\\n            }\\n            emit ContributionAirDropUpdate(\\n                eligibale_account_counter,\\n                distribution_till_now,\\n                total_eligible_token,\\n                block.timestamp\\n            );\\n            _pending_contribution_to_distribute = _pending_contribution_to_distribute.sub(\\n                distribution_till_now\\n            );\\n        }\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        require(sender != address(0), \\\"SCOLT :transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"SCOLT :transfer to the zero address\\\");\\n        require(\\n            _wallets[sender].balance \\u003e= amount,\\n            \\\"SCOLT :transfer amount exceeds balance\\\"\\n        );\\n\\n        if (_wallets[sender].wallet_type == Variables.type_of_wallet.UndefinedWallet) {\\n            // Initializing customer wallet if not in contract\\n            if (sender.isContract()) {\\n                _create_wallet(sender, Variables.type_of_wallet.DexPairWallet, false);\\n            } else {\\n                _create_wallet(sender, Variables.type_of_wallet.GeneralWallet, false);\\n            }\\n        }\\n        if (_wallets[recipient].wallet_type == Variables.type_of_wallet.UndefinedWallet) {\\n            // Initializing customer wallet if not in contract\\n            if (recipient.isContract()) {\\n                _create_wallet(recipient, Variables.type_of_wallet.DexPairWallet, false);\\n            } else {\\n                _create_wallet(recipient, Variables.type_of_wallet.GeneralWallet, false);\\n            }\\n        }\\n\\n        Variables.distribution_variables memory dv;\\n        bool sender_contribution_deduct;\\n        address sendfrom;\\n\\n        // checking SCOLT rules before transfer\\n        SCOLTLibrary._checkrules(\\n            _wallets[sender],\\n            _wallets[recipient],\\n            _ctc_approvals[sender],\\n            Variables.checkrules_additional_var(\\n                sender,\\n                recipient,\\n                amount,\\n                _sellers_check[recipient],\\n                _sellers_check[sender]\\n            )\\n        );\\n        _wallets[sender].balance = _wallets[sender].balance.sub(amount);\\n        _wallets[recipient].balance = _wallets[recipient].balance.add(\\n            amount\\n        );\\n        emit Transfer(sender, recipient, amount);\\n        (\\n            dv,\\n            sender_contribution_deduct,\\n            _wallets[Variables._marketing_wallet],\\n            _wallets[Variables._development_wallet],\\n            _pending_contribution_to_distribute,\\n            _total_supply,\\n            _burning_till_now\\n        ) = SCOLTLibrary.contributionsCalc(\\n            _wallets[sender],\\n            _wallets[recipient],\\n            _wallets[Variables._marketing_wallet],\\n            _wallets[Variables._development_wallet],\\n            Variables.function_addresses(\\n                _owner,\\n                sender,\\n                address(this)\\n            ),\\n            Variables.function_amounts(\\n                amount,\\n                _pending_contribution_to_distribute,\\n                _initial_total_supply,\\n                _total_supply,\\n                _burning_till_now\\n            )\\n        );\\n\\n        if (sender_contribution_deduct == false || sender.isContract()) {\\n            sendfrom = recipient;\\n            _wallets[recipient].balance = _wallets[recipient].balance.sub(dv.total_contributions);\\n        } else {\\n            sendfrom = sender;\\n            _wallets[sender].balance = _wallets[sender].balance.sub(dv.total_contributions);\\n        }\\n\\n        // emit Transfer(sendfrom, Variables._marketing_wallet, dv.marketing_contributions);\\n        // emit Transfer(sendfrom, Variables._development_wallet, dv.development_contributions);\\n        // emit ContributionAddedToContributionDistributionVariable(dv.holder_contributions);\\n        // emit Burn(sendfrom, dv.burn_amount);\\n        // emit Transfer(sendfrom, address(0), dv.burn_amount);\\n\\n        emit ContributionDeductionAndBurningLog(\\n            dv.marketing_contributions,\\n            dv.development_contributions,\\n            dv.holder_contributions,\\n            dv.burn_amount\\n        );\\n\\n        _contribution_airdrop(); // check and make airdrops of contributions\\n\\n        _wallets[sender] = SCOLTLibrary._after_transfer_updates(\\n            amount,\\n            _wallets[sender],\\n            _sellers_check[recipient]\\n        );\\n    }\\n\\n    // This function manages to get aproval from user wallet to intiate CTC.\\n    // Only wallet holder can initiate any kind of CTC Transfers.\\n    function chainToChainApproval(\\n        string memory uctcid,\\n        bool burn_or_mint,\\n        uint256 amount\\n    ) public returns (bool) {\\n        Variables.wallet_details storage transferer_wallet = _wallets[_msgSender()];\\n\\n        // checking rule for CTC, only GeneralWallet type user can initiate CTC Transfer\\n        require(\\n            !_msgSender().isContract(),\\n            \\\"SCOLT : Contract type of wallet can not initiate C2C transfer.\\\"\\n        );\\n        if (!burn_or_mint) {\\n            require(\\n                transferer_wallet.wallet_type != Variables.type_of_wallet.UndefinedWallet,\\n                \\\"SCOLT : Only SCOLT holder can initiate C2C transfer.\\\"\\n            );\\n        }\\n        if (transferer_wallet.is_investor) {\\n            require(\\n                SCOLTLibrary._check_time_condition(\\n                    block.timestamp,\\n                    SCOLTLibrary.toTimestampFromDateTime(transferer_wallet.joining_date),\\n                    Variables._investor_swap_lock_days\\n                ),\\n                \\\"SCOLT : Investor account can perform any transfer after 180 days only.\\\"\\n            );\\n        }\\n        require(\\n            transferer_wallet.balance \\u003e= amount,\\n            \\\"SCOLT :Insufficient balance for CTC transfer.\\\"\\n        );\\n\\n        // Adding Details To CTC\\n        _ctc_approvals[_msgSender()] = Variables.ctc_approval_details(\\n            true,\\n            uctcid,\\n            block.timestamp + (300 * 1 seconds),\\n            false,\\n            burn_or_mint,\\n            amount * 10**_decimals\\n        );\\n\\n        return true;\\n    }\\n\\n    function chainToChainTransferBurn(address transferer, string memory uctcid)\\n        public\\n        onlyOwner\\n        returns (bool)\\n    {\\n        Variables.wallet_details storage transferer_wallet = _wallets[transferer];\\n        Variables.ctc_approval_details storage transferer_ctc_details = _ctc_approvals[\\n            transferer\\n        ];\\n\\n        // Checking CTC conditions\\n        require(\\n            keccak256(bytes(transferer_ctc_details.uctcid)) ==\\n                keccak256(bytes(uctcid)),\\n            \\\"SCOLT : Invalid Transfer token provided.\\\"\\n        );\\n        require(\\n            transferer_ctc_details.burn_or_mint == false,\\n            \\\"SCOLT : Invalid Transfer Details.\\\"\\n        );\\n        require(\\n            transferer_ctc_details.used == false,\\n            \\\"SCOLT : Invalid Transfer Details.\\\"\\n        );\\n        require(\\n            transferer_ctc_details.allowed_till \\u003e= block.timestamp,\\n            \\\"SCOLT : Transfer token expired.\\\"\\n        );\\n        require(\\n            transferer_wallet.balance \\u003e= transferer_ctc_details.amount,\\n            \\\"SCOLT :Insufficient balance for CTC transfer.\\\"\\n        );\\n\\n        _total_supply = _total_supply.sub(transferer_ctc_details.amount);\\n        // _burning_till_now = _burning_till_now.add(transferer_ctc_details.amount); not doing this as it is been transfered to other chain. not an official burn.\\n        emit Burn(transferer, transferer_ctc_details.amount);\\n        emit Transfer(transferer, address(0), transferer_ctc_details.amount);\\n        transferer_wallet.balance = transferer_wallet.balance.sub(\\n            transferer_ctc_details.amount\\n        );\\n\\n        transferer_ctc_details.used = true; // To stop token being used for multiple times.\\n        delete _ctc_approvals[transferer];\\n        return true;\\n    }\\n\\n    function chainToChainTransferMint(\\n        address transferer,\\n        Variables.type_of_wallet oc_wallet_type,\\n        uint256 lastday_total_sell,\\n        uint256 concurrent_sale_day_count,\\n        uint256 last_sale_date,\\n        uint256 joining_date,\\n        string memory uctcid\\n    ) public onlyOwner returns (bool) {\\n        Variables.wallet_details storage transferer_wallet = _wallets[transferer];\\n        Variables.ctc_approval_details storage transferer_ctc_details = _ctc_approvals[\\n            transferer\\n        ];\\n\\n        // Checking CTC conditions\\n        require(\\n            keccak256(bytes(transferer_ctc_details.uctcid)) ==\\n                keccak256(bytes(uctcid)),\\n            \\\"SCOLT : Invalid Transfer token provided.\\\"\\n        );\\n        require(\\n            transferer_ctc_details.burn_or_mint == true,\\n            \\\"SCOLT : Invalid Transfer Details.\\\"\\n        );\\n        require(\\n            transferer_ctc_details.used == false,\\n            \\\"SCOLT : Invalid Transfer Details.\\\"\\n        );\\n        require(\\n            transferer_ctc_details.allowed_till \\u003e= block.timestamp,\\n            \\\"SCOLT : Transfer token expired.\\\"\\n        );\\n        if (transferer_wallet.wallet_type != Variables.type_of_wallet.UndefinedWallet) {\\n            require(\\n                transferer_wallet.wallet_type == oc_wallet_type,\\n                \\\"SCOLT : Can not perform C2C transfer within differnt wallet type.\\\"\\n            );\\n        }\\n\\n        // Checking if wallet is already available or not\\n        if (transferer_wallet.wallet_type == Variables.type_of_wallet.UndefinedWallet) {\\n            // Initializing customer wallet if not in contract\\n            _create_wallet(transferer, oc_wallet_type, false);\\n            transferer_wallet = _wallets[transferer];\\n            transferer_wallet.lastday_total_sell = lastday_total_sell;\\n            transferer_wallet.concurrent_sale_day_count = concurrent_sale_day_count;\\n            transferer_wallet.last_sale_date = SCOLTLibrary.parseTimestamp(last_sale_date);\\n            transferer_wallet.joining_date = SCOLTLibrary.parseTimestamp(joining_date);\\n        } else {\\n            transferer_wallet.lastday_total_sell = transferer_wallet\\n                .lastday_total_sell\\n                .add(lastday_total_sell);\\n            if (\\n                transferer_wallet.concurrent_sale_day_count \\u003c\\n                concurrent_sale_day_count\\n            ) {\\n                transferer_wallet\\n                    .concurrent_sale_day_count = concurrent_sale_day_count;\\n            }\\n            if (\\n                SCOLTLibrary.toTimestampFromDateTime(transferer_wallet.last_sale_date) \\u003c\\n                last_sale_date\\n            ) {\\n                transferer_wallet.last_sale_date = SCOLTLibrary.parseTimestamp(\\n                    last_sale_date\\n                );\\n            }\\n        }\\n\\n        _total_supply = _total_supply.add(transferer_ctc_details.amount);\\n        emit Mint(transferer, transferer_ctc_details.amount);\\n        emit Transfer(address(0), transferer, transferer_ctc_details.amount); // Minting same amount of token as other C2C Chain.\\n        transferer_wallet.balance = transferer_wallet.balance.add(\\n            transferer_ctc_details.amount\\n        );\\n\\n        transferer_ctc_details.used = true; // To stop token being used for multiple times.\\n        delete _ctc_approvals[transferer];\\n        return true;\\n    }\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SCOLT : (SafeMatch) addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SCOLT : (SafeMatch) subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SCOLT : (SafeMatch) multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SCOLT : (SafeMatch) division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SCOLT : (SafeMatch) modulo by zero\\\");\\n    }\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"},\"Variables.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nlibrary Variables {\\n    // Baisc contract variable declaration\\n    string public constant _name = \\\"Safe Coliseum\\\";\\n    string public constant _symbol = \\\"SCOLT\\\";\\n    uint8 public constant _decimals = 8;\\n    uint256 public constant _initial_total_supply = 105000000 * 10**_decimals;\\n\\n    // Token distribution veriables\\n    uint256 public constant _pioneer_invester_supply = (12 * _initial_total_supply) / 100;\\n    uint256 public constant _ifo_supply = (21 * _initial_total_supply) / 100;\\n    uint256 public constant _pool_airdrop_supply = (3 * _initial_total_supply) / 100;\\n    uint256 public constant _director_supply_each = (5 * _initial_total_supply) / 100;\\n    uint256 public constant _marketing_expansion_supply = (19 * _initial_total_supply) / 100;\\n    uint256 public constant _development_expansion_supply = (6 * _initial_total_supply) / 100;\\n    uint256 public constant _liquidity_supply = (5 * _initial_total_supply) / 100;\\n    uint256 public constant _future_team_supply = (10 * _initial_total_supply) / 100;\\n    uint256 public constant _governance_supply = (4 * _initial_total_supply) / 100;\\n    uint256 public constant _investment_parter_supply = (10 * _initial_total_supply) / 100;\\n\\n    // Transaction contribution AirDrop variable\\n    uint256 public constant _contribution_distribute_after = 700 * 10**_decimals;\\n    uint256 public constant _contribution_distribution_eligibility = 700 * 10**_decimals;\\n    \\n    uint256 public constant _profit_distribution_eligibility = 1000 * 10**_decimals;\\n\\n    // Burning till total of 50% supply\\n    uint256 public constant _burning_till = _initial_total_supply / 2;\\n\\n    // Whale defination\\n    uint256 public constant _whale_per = (_initial_total_supply / 100); // 1% of total tokans consider tobe whale\\n\\n    // contribution structure defination, this will be in % ranging from 0 - 100\\n    uint256 public constant _normal_contribution_per = 2;\\n    uint256 public constant _whale_contribution_per = 5;\\n\\n    // below is percentage, consider _normal_contribution_per as 100%\\n    uint256 public constant _normal_marketing_share = 27;\\n    uint256 public constant _normal_development_share = 7;\\n    uint256 public constant _normal_holder_share = 43;\\n    uint256 public constant _normal_burning_share = 23;\\n\\n    // below is percentage, consider _whale_contribution_per as 100%\\n    uint256 public constant _whale_marketing_share = 32;\\n    uint256 public constant _whale_development_share = 10;\\n    uint256 public constant _whale_holder_share = 40;\\n    uint256 public constant _whale_burning_share = 18;\\n\\n    // antidump variables\\n    uint256 public constant _max_sell_amount_whale = 5000 * 10**_decimals; // max for whale\\n    uint256 public constant _max_sell_amount_normal = 2000 * 10**_decimals; // max for non-whale\\n    uint256 public constant _max_concurrent_sale_day = 6;\\n    uint256 public constant _cooling_days = 3;\\n    uint256 public constant _max_sell_per_director_per_day = 10000 * 10**_decimals;\\n    uint256 public constant _investor_swap_lock_days = 180; // after 180 days will behave as normal purchase user.\\n\\n    // Wallet specific declaration\\n    // UndefinedWallet : means 0 to check there is no wallet entry in Contract\\n    enum type_of_wallet {\\n        UndefinedWallet,\\n        GenesisWallet,\\n        DirectorWallet,\\n        MarketingWallet,\\n        DevelopmentWallet,\\n        LiquidityWallet,\\n        GovernanceWallet,\\n        GeneralWallet,\\n        FutureTeamWallet,\\n        PoolOrAirdropWallet,\\n        IfoWallet,\\n        UnsoldTokenWallet,\\n        DexPairWallet\\n    }\\n\\n    struct _DateTime {\\n        uint16 year;\\n        uint8 month;\\n        uint8 day;\\n        uint8 hour;\\n        uint8 minute;\\n        uint8 second;\\n        uint8 weekday;\\n    }\\n\\n    struct wallet_details {\\n        type_of_wallet wallet_type;\\n        uint256 balance;\\n        uint256 lastday_total_sell;\\n        uint256 concurrent_sale_day_count;\\n        _DateTime last_sale_date;\\n        _DateTime joining_date;\\n        bool contribution_apply;\\n        bool antiwhale_apply;\\n        bool anti_dump;\\n        bool is_investor;\\n    }\\n\\n    // Chain To Chain Transfer Process Variables\\n    struct ctc_approval_details {\\n        bool has_value;\\n        string uctcid;\\n        uint256 allowed_till;\\n        bool used;\\n        bool burn_or_mint; // false = burn, true = mint\\n        uint256 amount;\\n    }\\n\\n    struct distribution_variables {\\n        uint256 total_contributions;\\n        uint256 marketing_contributions;\\n        uint256 development_contributions;\\n        uint256 holder_contributions;\\n        uint256 burn_amount;\\n    }\\n\\n    struct function_addresses {\\n        address owner;\\n        address sender;\\n        address this_address;\\n    }\\n\\n    struct function_amounts {\\n        uint256 amount;\\n        uint256 pending_contribution_to_distribute;\\n        uint256 initial_total_supply;\\n        uint256 total_supply;\\n        uint256 burning_till_now;\\n    }\\n\\n    struct function_bools {\\n        bool _sellers_check_recipient;\\n        bool _sellers_check_sender;\\n    }\\n\\n    struct checkrules_additional_var {\\n        address sender;\\n        address recipient;\\n        uint256 amount;\\n        bool _sellers_check_recipient;\\n        bool _sellers_check_sender;\\n    }\\n\\n    uint256 public constant _ctc_aproval_validation_timespan = 300; // In Seconds\\n\\n    // SCOLT Specific Wallets\\n    address public constant _director_wallet_1 = 0x42B8Ba6D6bD7cD19e132aE5701F970Df0A6b96B1;\\n    address public constant _director_wallet_2 = 0x9CF71f45c110A4BD01a0Fc0ca2A2f4E9A5e48DF0;\\n    address public constant _marketing_wallet = 0x548F4817aDC48Df4Abe079c61E731c3ACC216331;\\n    address public constant _governance_wallet = 0x342B9C569cBaE2AF834dd13539633291A5a8d23B;\\n    address public constant _liquidity_wallet = 0x27AB3d2F9eB7274092Bf67c54cff1574eA3AFfF4;\\n    address public constant _pool_airdrop_wallet = 0x7aA854Bc1042df6b10F2a30981FC5DE0fDCF04D2;\\n    address public constant _future_team_wallet = 0x0Cd8Bd5a0B4DF8a861704c7da1f7D0eB63b2dDa6;\\n    address public constant _ifo_wallet = 0xffaFCD12D27DCF48a076C914b335B5c152d12609;\\n    address public constant _development_wallet = 0x8f0070EbC10E4586fC23fc37C6F1975F07f19867;\\n    address public constant _unsold_token_wallet = 0xC7008531330Ea8BBe55c6fc9b4bED018C1E0AF0e;\\n\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contribution\",\"type\":\"uint256\"}],\"name\":\"ContributionAddedToContributionDistributionVariable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_total_beneficiary_count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_distributed_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_total_eligible_circulation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"ContributionAirDropUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_marketing_contribution\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_development_contribution\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_holder_contribution\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_burn_amount\",\"type\":\"uint256\"}],\"name\":\"ContributionDeductionAndBurningLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_total_beneficiary_count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_distributed_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_total_eligible_circulation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"ProfitAirDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_total_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_number_of_reciepent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"PublicAirDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"partner_address\",\"type\":\"address\"}],\"name\":\"addInvestmentPartner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addSellerWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burningTillNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uctcid\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"burn_or_mint\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"chainToChainApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferer\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uctcid\",\"type\":\"string\"}],\"name\":\"chainToChainTransferBurn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferer\",\"type\":\"address\"},{\"internalType\":\"enum Variables.type_of_wallet\",\"name\":\"oc_wallet_type\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"lastday_total_sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"concurrent_sale_day_count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_sale_date\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"joining_date\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uctcid\",\"type\":\"string\"}],\"name\":\"chainToChainTransferMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"checkAccountIsSeller\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"enum Variables.type_of_wallet\",\"name\":\"wallet_type\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastday_total_sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"concurrent_sale_day_count\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"year\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"month\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"day\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hour\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"minute\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"second\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"weekday\",\"type\":\"uint8\"}],\"internalType\":\"struct Variables._DateTime\",\"name\":\"last_sale_date\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"year\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"month\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"day\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hour\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"minute\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"second\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"weekday\",\"type\":\"uint8\"}],\"internalType\":\"struct Variables._DateTime\",\"name\":\"joining_date\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"contribution_apply\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"antiwhale_apply\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"anti_dump\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"is_investor\",\"type\":\"bool\"}],\"internalType\":\"struct Variables.wallet_details\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holderDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingFeeToDistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"profitAirdrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"publicAirdrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeSellerWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SafeColiseum", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "SCOLTLibrary:3900a2a07007a004323c1ea0ebb97ebfb99beadc", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://39430063c763b8c8638120c01286443213becdd164e1262bc0bac6d404b6df8a"}]}