{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// OTU BurnToWL -- One-Time-Use Burn to Whitelist Contract for ZenApes\r\n\r\n// First, we define the contract inheritances that we want\r\nabstract contract Ownable {\r\n    address public owner; \r\n    constructor() { owner = msg.sender; }\r\n    modifier onlyOwner { require(owner == msg.sender, \"Not Owner!\"); _; }\r\n    function transferOwnership(address new_) external onlyOwner { owner = new_; }\r\n}\r\n\r\n// Then, we define the interfaces we will be using\r\ninterface IERC721 {\r\n    function ownerOf(uint256 tokenId_) external returns (address);\r\n    function transferFrom(address from_, address to_, uint256 tokenId_) external;\r\n}\r\n\r\n// Now, we write the smart contract.\r\ncontract ZenApeBTWL is Ownable {\r\n\r\n    // First, we define the interface.\r\n\r\n    // ZenApe ERC721\r\n    IERC721 public ZenApe = IERC721(0x838804a3dd7c717396a68F94E736eAf76b911632);\r\n\r\n    // Default Burn Address\r\n    // address public burnAddress = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    // ZenApe Burn Address (Override)\r\n    address public burnAddress = 0x0243Cc7705a10762d852419b88559A72D68fd1d1;\r\n\r\n    // There is 100 spots.\r\n    uint256 public totalSpots = 100;\r\n\r\n    // We define a simple mapping method to push in allowed addresses to BTWL\r\n    mapping(address => bool) public addressToAllowedBTWL;\r\n\r\n    // Then, we define a simple method to push the data into the mapping\r\n    function setAddressToBTWLs(address[] calldata addresses_, bool bool_) \r\n    external onlyOwner {\r\n        for (uint256 i = 0; i < addresses_.length; i++) {\r\n            addressToAllowedBTWL[addresses_[i]] = bool_;\r\n        }\r\n    }\r\n\r\n    // We define an array to store the addresses AND compare to totalSpots\r\n    address[] public whitelistedAddresses;\r\n\r\n    // We also give the array a method to return all the addresses at once\r\n    function getAllWhitelistedAddresses() external view returns (address[] memory) {\r\n        return whitelistedAddresses;\r\n    }\r\n\r\n    // Now, we define the BTWL mechanics.\r\n    function burnToWhitelist(uint256[] calldata tokenIds_) external {\r\n        // They can burn 2 and only 2 in a transaction\r\n        require(2 == tokenIds_.length,\r\n            \"Array length invalid!\");\r\n\r\n        // The whitelisted addresses must have available slots\r\n        // The length gets added + 1 everytime there is a .push()\r\n        require(totalSpots > whitelistedAddresses.length,   \r\n            \"No more spots left!\");\r\n\r\n        // The msg.sender must be in the allowed list of BTWL users\r\n        require(addressToAllowedBTWL[msg.sender],\r\n            \"You do not have access to BTWL!\");\r\n\r\n        // NOTE: This is not required. It's good for error messages. \r\n        // In this case, we remove the statement for gas savings.\r\n        // If the transferFrom is not possible, the function will revert anyway.\r\n        // ~0xInuarashi \r\n        //\r\n        // // The user must own the token\r\n        // require(msg.sender == ZenApe.ownerOf(tokenId_),\r\n        //     \"You are not the owner of this ZenApe!\");\r\n        \r\n        // Transfer the tokens in the array\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            ZenApe.transferFrom(msg.sender, burnAddress, tokenIds_[i]);\r\n        }\r\n\r\n        // We save gas by resetting the mapping storage to 0\r\n        delete addressToAllowedBTWL[msg.sender];\r\n\r\n        // Add them to the whitelisted addresses list \r\n        whitelistedAddresses.push(msg.sender);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"ZenApe\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToAllowedBTWL\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"burnToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllWhitelistedAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses_\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"bool_\",\"type\":\"bool\"}],\"name\":\"setAddressToBTWLs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSpots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"whitelistedAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ZenApeBTWL", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6a5247f7af6f5635c36fd35571c7ac75412dbc2df1c020c9bec9b464a3034ad2"}]}