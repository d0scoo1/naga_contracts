{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PixelURIParser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n// Creator: 0xBasedPixel; Based Pixel Labs/Yeety Labs; 1 yeet = 1 yeet\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./HexChars.sol\\\";\\n\\nlibrary PixelURIParser {\\n    string private constant startStr = \\\"<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='100%25' height='100%25' viewBox='0 0 16 16'>\\\";\\n    string private constant endStr = \\\"</svg>\\\";\\n    uint256 private constant rectStart = 27340891238026048097263813569089141950244693325490254729102276207101788291072;\\n    uint256 private constant heightNum = 14658463167467038245011812029062285656083636211927847345906851957315119087616;\\n    uint256 private constant inner1 = 57183955277861053027410940421065042940111934717952;\\n    uint256 private constant inner2 = 793586231870635386738538214064128;\\n\\n    function getPixelURI(uint256[12] memory slices, uint256 tokenId) public pure returns (string memory) {\\n        bytes32[] memory rectComponents = new bytes32[](512);\\n\\n        uint256 uniqueColors = 0;\\n        uint256[16] memory colorTracker = [uint256(0), uint256(0),uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0)];\\n        uint256 rTotal = 0;\\n        uint256 gTotal = 0;\\n        uint256 bTotal = 0;\\n        uint256 brightnessSum = 0;\\n\\n        for (uint256 i = 0; i < 4; i++) {\\n            for (uint256 j = 0; j < 64; j++) {\\n                uint256 hcR = slices[i*3];\\n                hcR = (hcR>>(j*4))%16;\\n                uint256 hcG = slices[i*3+1];\\n                hcG = (hcG>>(j*4))%16;\\n                uint256 hcB = slices[i*3+2];\\n                hcB = (hcB>>(j*4))%16;\\n\\n                uint256 strNum1 = rectStart+((48 + ((((i*64 + j)%16) - (((i*64 + j)%16)%10))/10))<<176)+((48 + (((i*64 + j)%16)%10))<<168)+inner1;\\n                strNum1 = strNum1+((48 + ((((i*64 + j)>>4) - (((i*64 + j)>>4)%10))/10))<<120)+((48 + (((i*64 + j)>>4)%10))<<112)+inner2;\\n                uint256 strNum2 = heightNum+((HexChars.getHex(hcR))<<80);\\n                strNum2 = strNum2+((HexChars.getHex(hcG))<<72);\\n                strNum2 = strNum2+((HexChars.getHex(hcB))<<64)+2823543661105512448; //+(39<<56)+(47<<48)+(62<<40)\\n                rectComponents[(i*64 + j)*2] = bytes32(strNum1);\\n                rectComponents[(i*64 + j)*2 + 1] = bytes32(strNum2);\\n\\n                if (((colorTracker[hcR])>>(hcG*16+hcB))%2 == 0) {\\n                    uniqueColors += 1;\\n                    colorTracker[hcR] += (uint256(1)<<(hcG*16+hcB));\\n                }\\n                rTotal += hcR;\\n                gTotal += hcG;\\n                bTotal += hcB;\\n                brightnessSum += (2126*hcR + 7152*hcG + 722*hcB);\\n            }\\n        }\\n\\n        if ((rTotal+gTotal+bTotal) == 0) {\\n            rTotal = 1;\\n            gTotal = 1;\\n            bTotal = 1;\\n        }\\n        uint256 rDom = (rTotal*10000)/(rTotal+gTotal+bTotal);\\n        uint256 gDom = (gTotal*10000)/(rTotal+gTotal+bTotal);\\n        uint256 bDom = (bTotal*10000)/(rTotal+gTotal+bTotal);\\n\\n        string memory brightnessStr;\\n        if ((brightnessSum/4096) == 10000) {\\n            brightnessStr = \\\"1\\\";\\n        }\\n        else if ((brightnessSum/4096) >= 1000) {\\n            brightnessStr = string(abi.encodePacked(\\\"0.\\\",Strings.toString(brightnessSum/4096)));\\n        }\\n        else if ((brightnessSum/4096) >= 100) {\\n            brightnessStr = string(abi.encodePacked(\\\"0.0\\\",Strings.toString(brightnessSum/4096)));\\n        }\\n        else if ((brightnessSum/4096) >= 10) {\\n            brightnessStr = string(abi.encodePacked(\\\"0.00\\\",Strings.toString(brightnessSum/4096)));\\n        }\\n        else if ((brightnessSum/4096) >= 1) {\\n            brightnessStr = string(abi.encodePacked(\\\"0.000\\\",Strings.toString(brightnessSum/4096)));\\n        }\\n        else {\\n            brightnessStr = \\\"0\\\";\\n        }\\n\\n        return string(\\n            abi.encodePacked(\\n                \\\"data:application/json;utf8,\\\",\\\"{\\\\\\\"name\\\\\\\":\\\\\\\"Token: \\\",\\n                Strings.toString(tokenId),\\\"\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Based Pixels #\\\",\\n                Strings.toString(tokenId),\\\"\\\\\\\",\\\\\\\"image\\\\\\\":\\\\\\\"data:image/svg+xml;utf8,\\\",\\n                startStr,rectComponents,endStr,\\\"\\\\\\\",\\\\\\\"attributes\\\\\\\":\\\",\\n                \\\"[{\\\\\\\"trait_type\\\\\\\":\\\\\\\"Unique Colors\\\\\\\",\\\\\\\"value\\\\\\\":\\\",\\n                Strings.toString(uniqueColors),\\\"},{\\\\\\\"trait_type\\\\\\\":\\\\\\\"Red Dominance\\\\\\\",\\\",\\n                \\\"\\\\\\\"value\\\\\\\":0.\\\",Strings.toString(rDom),\\\"},\\\",\\n                \\\"{\\\\\\\"trait_type\\\\\\\":\\\\\\\"Green Dominance\\\\\\\",\\\\\\\"value\\\\\\\":0.\\\",\\n                Strings.toString(gDom),\\\"},{\\\\\\\"trait_type\\\\\\\":\\\",\\n                \\\"\\\\\\\"Blue Dominance\\\\\\\",\\\\\\\"value\\\\\\\":0.\\\",Strings.toString(bDom),\\\"},\\\",\\n                \\\"{\\\\\\\"trait_type\\\\\\\":\\\\\\\"Average Brightness\\\\\\\",\\\\\\\"value\\\\\\\":\\\",brightnessStr,\\\"}]}\\\"));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/HexChars.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n// Creator: 0xBasedPixel; Based Pixel Labs/Yeety Labs; 1 yeet = 1 yeet\\npragma solidity ^0.8.0;\\n\\nlibrary HexChars {\\n    function getHex(uint _index) public pure returns (uint256) {\\n        uint256[16] memory hexChars = [\\n        uint256(48), uint256(49),\\n        uint256(50), uint256(51),\\n        uint256(52), uint256(53),\\n        uint256(54), uint256(55),\\n        uint256(56), uint256(57),\\n        uint256(65), uint256(66),\\n        uint256(67), uint256(68),\\n        uint256(69), uint256(70)\\n        ];\\n\\n        return hexChars[_index];\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/HexChars.sol\": {\r\n        \"HexChars\": \"0xccb7b5fc0dc232fe67c9c111bcb3b6adbe9fef49\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256[12]\",\"name\":\"slices\",\"type\":\"uint256[12]\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getPixelURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "PixelURIParser", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}