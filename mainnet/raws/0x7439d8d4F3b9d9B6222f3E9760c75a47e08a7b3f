{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/bridge/Outbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IOutbox.sol\\\";\\nimport \\\"../libraries/MerkleLib.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\n\\n/// @dev this error is thrown since certain functions are only expected to be used in simulations, not in actual txs\\nerror SimulationOnlyEntrypoint();\\n\\ncontract Outbox is DelegateCallAware, IOutbox {\\n    address public rollup; // the rollup contract\\n    IBridge public bridge; // the bridge contract\\n\\n    mapping(uint256 => bytes32) public spent; // packed spent bitmap\\n    mapping(bytes32 => bytes32) public roots; // maps root hashes => L2 block hash\\n\\n    struct L2ToL1Context {\\n        uint128 l2Block;\\n        uint128 l1Block;\\n        uint128 timestamp;\\n        bytes32 outputId;\\n        address sender;\\n    }\\n    // Note, these variables are set and then wiped during a single transaction.\\n    // Therefore their values don't need to be maintained, and their slots will\\n    // be empty outside of transactions\\n    L2ToL1Context internal context;\\n\\n    // default context values to be used in storage instead of zero, to save on storage refunds\\n    // it is assumed that arb-os never assigns these values to a valid leaf to be redeemed\\n    uint128 private constant L2BLOCK_DEFAULT_CONTEXT = type(uint128).max;\\n    uint128 private constant L1BLOCK_DEFAULT_CONTEXT = type(uint128).max;\\n    uint128 private constant TIMESTAMP_DEFAULT_CONTEXT = type(uint128).max;\\n    bytes32 private constant OUTPUTID_DEFAULT_CONTEXT = bytes32(type(uint256).max);\\n    address private constant SENDER_DEFAULT_CONTEXT = address(type(uint160).max);\\n\\n    uint128 public constant OUTBOX_VERSION = 2;\\n\\n    function initialize(IBridge _bridge) external onlyDelegated {\\n        if (address(bridge) != address(0)) revert AlreadyInit();\\n        // address zero is returned if no context is set, but the values used in storage\\n        // are non-zero to save users some gas (as storage refunds are usually maxed out)\\n        // EIP-1153 would help here\\n        context = L2ToL1Context({\\n            l2Block: L2BLOCK_DEFAULT_CONTEXT,\\n            l1Block: L1BLOCK_DEFAULT_CONTEXT,\\n            timestamp: TIMESTAMP_DEFAULT_CONTEXT,\\n            outputId: OUTPUTID_DEFAULT_CONTEXT,\\n            sender: SENDER_DEFAULT_CONTEXT\\n        });\\n        bridge = _bridge;\\n        rollup = address(_bridge.rollup());\\n    }\\n\\n    function updateSendRoot(bytes32 root, bytes32 l2BlockHash) external override {\\n        if (msg.sender != rollup) revert NotRollup(msg.sender, rollup);\\n        roots[root] = l2BlockHash;\\n        emit SendRootUpdated(root, l2BlockHash);\\n    }\\n\\n    /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\\n    /// When the return value is zero, that means this is a system message\\n    /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\\n    function l2ToL1Sender() external view override returns (address) {\\n        address sender = context.sender;\\n        // we don't return the default context value to avoid a breaking change in the API\\n        if (sender == SENDER_DEFAULT_CONTEXT) return address(0);\\n        return sender;\\n    }\\n\\n    /// @return l2Block return L2 block when the L2 tx was initiated or zero\\n    /// if no L2 to L1 transaction is active\\n    function l2ToL1Block() external view override returns (uint256) {\\n        uint128 l2Block = context.l2Block;\\n        // we don't return the default context value to avoid a breaking change in the API\\n        if (l2Block == L1BLOCK_DEFAULT_CONTEXT) return uint256(0);\\n        return uint256(l2Block);\\n    }\\n\\n    /// @return l1Block return L1 block when the L2 tx was initiated or zero\\n    /// if no L2 to L1 transaction is active\\n    function l2ToL1EthBlock() external view override returns (uint256) {\\n        uint128 l1Block = context.l1Block;\\n        // we don't return the default context value to avoid a breaking change in the API\\n        if (l1Block == L1BLOCK_DEFAULT_CONTEXT) return uint256(0);\\n        return uint256(l1Block);\\n    }\\n\\n    /// @return timestamp return L2 timestamp when the L2 tx was initiated or zero\\n    /// if no L2 to L1 transaction is active\\n    function l2ToL1Timestamp() external view override returns (uint256) {\\n        uint128 timestamp = context.timestamp;\\n        // we don't return the default context value to avoid a breaking change in the API\\n        if (timestamp == TIMESTAMP_DEFAULT_CONTEXT) return uint256(0);\\n        return uint256(timestamp);\\n    }\\n\\n    /// @notice batch number is deprecated and now always returns 0\\n    function l2ToL1BatchNum() external pure override returns (uint256) {\\n        return 0;\\n    }\\n\\n    /// @return outputId returns the unique output identifier of the L2 to L1 tx or\\n    /// zero if no L2 to L1 transaction is active\\n    function l2ToL1OutputId() external view override returns (bytes32) {\\n        bytes32 outputId = context.outputId;\\n        // we don't return the default context value to avoid a breaking change in the API\\n        if (outputId == OUTPUTID_DEFAULT_CONTEXT) return bytes32(0);\\n        return outputId;\\n    }\\n\\n    /**\\n     * @notice Executes a messages in an Outbox entry.\\n     * @dev Reverts if dispute period hasn't expired, since the outbox entry\\n     * is only created once the rollup confirms the respective assertion.\\n     * @param proof Merkle proof of message inclusion in send root\\n     * @param index Merkle path to message\\n     * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\\n     * @param to destination address for L1 contract call\\n     * @param l2Block l2 block number at which sendTxToL1 call was made\\n     * @param l1Block l1 block number at which sendTxToL1 call was made\\n     * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\\n     * @param value wei in L1 message\\n     * @param data abi-encoded L1 message data\\n     */\\n    function executeTransaction(\\n        bytes32[] calldata proof,\\n        uint256 index,\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) external {\\n        bytes32 userTx = calculateItemHash(\\n            l2Sender,\\n            to,\\n            l2Block,\\n            l1Block,\\n            l2Timestamp,\\n            value,\\n            data\\n        );\\n\\n        recordOutputAsSpent(proof, index, userTx);\\n\\n        executeTransactionImpl(index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data);\\n    }\\n\\n    /// @dev function used to simulate the result of a particular function call from the outbox\\n    /// it is useful for things such as gas estimates. This function includes all costs except for\\n    /// proof validation (which can be considered offchain as a somewhat of a fixed cost - it's\\n    /// not really a fixed cost, but can be treated as so with a fixed overhead for gas estimation).\\n    /// We can't include the cost of proof validation since this is intended to be used to simulate txs\\n    /// that are included in yet-to-be confirmed merkle roots. The simulation entrypoint could instead pretend\\n    /// to confirm a pending merkle root, but that would be less pratical for integrating with tooling.\\n    /// It is only possible to trigger it when the msg sender is address zero, which should be impossible\\n    /// unless under simulation in an eth_call or eth_estimateGas\\n    function executeTransactionSimulation(\\n        uint256 index,\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) external {\\n        if (msg.sender != address(0)) revert SimulationOnlyEntrypoint();\\n        executeTransactionImpl(index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data);\\n    }\\n\\n    function executeTransactionImpl(\\n        uint256 outputId,\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) internal {\\n        emit OutBoxTransactionExecuted(to, l2Sender, 0, outputId);\\n\\n        // we temporarily store the previous values so the outbox can naturally\\n        // unwind itself when there are nested calls to `executeTransaction`\\n        L2ToL1Context memory prevContext = context;\\n\\n        context = L2ToL1Context({\\n            sender: l2Sender,\\n            l2Block: uint128(l2Block),\\n            l1Block: uint128(l1Block),\\n            timestamp: uint128(l2Timestamp),\\n            outputId: bytes32(outputId)\\n        });\\n\\n        // set and reset vars around execution so they remain valid during call\\n        executeBridgeCall(to, value, data);\\n\\n        context = prevContext;\\n    }\\n\\n    function _calcSpentIndexOffset(uint256 index)\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            bytes32\\n        )\\n    {\\n        uint256 spentIndex = index / 255; // Note: Reserves the MSB.\\n        uint256 bitOffset = index % 255;\\n        bytes32 replay = spent[spentIndex];\\n        return (spentIndex, bitOffset, replay);\\n    }\\n\\n    function _isSpent(uint256 bitOffset, bytes32 replay) internal pure returns (bool) {\\n        return ((replay >> bitOffset) & bytes32(uint256(1))) != bytes32(0);\\n    }\\n\\n    function isSpent(uint256 index) external view returns (bool) {\\n        (, uint256 bitOffset, bytes32 replay) = _calcSpentIndexOffset(index);\\n        return _isSpent(bitOffset, replay);\\n    }\\n\\n    function recordOutputAsSpent(\\n        bytes32[] memory proof,\\n        uint256 index,\\n        bytes32 item\\n    ) internal {\\n        if (proof.length >= 256) revert ProofTooLong(proof.length);\\n        if (index >= 2**proof.length) revert PathNotMinimal(index, 2**proof.length);\\n\\n        // Hash the leaf an extra time to prove it's a leaf\\n        bytes32 calcRoot = calculateMerkleRoot(proof, index, item);\\n        if (roots[calcRoot] == bytes32(0)) revert UnknownRoot(calcRoot);\\n\\n        (uint256 spentIndex, uint256 bitOffset, bytes32 replay) = _calcSpentIndexOffset(index);\\n\\n        if (_isSpent(bitOffset, replay)) revert AlreadySpent(index);\\n        spent[spentIndex] = (replay | bytes32(1 << bitOffset));\\n    }\\n\\n    function executeBridgeCall(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        (bool success, bytes memory returndata) = bridge.executeCall(to, value, data);\\n        if (!success) {\\n            if (returndata.length > 0) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert BridgeCallFailed();\\n            }\\n        }\\n    }\\n\\n    function calculateItemHash(\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(abi.encodePacked(l2Sender, to, l2Block, l1Block, l2Timestamp, value, data));\\n    }\\n\\n    function calculateMerkleRoot(\\n        bytes32[] memory proof,\\n        uint256 path,\\n        bytes32 item\\n    ) public pure returns (bytes32) {\\n        return MerkleLib.calculateRoot(proof, path, keccak256(abi.encodePacked(item)));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/IBridge.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport {NotContract, NotRollupOrOwner} from \\\"../libraries/Error.sol\\\";\\nimport \\\"./IOwnable.sol\\\";\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-inbox function\\n/// @param sender The un-authorized sender\\nerror NotDelayedInbox(address sender);\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-sequencer-inbox function\\n/// @param sender The un-authorized sender\\nerror NotSequencerInbox(address sender);\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-outbox function\\n/// @param sender The un-authorized sender\\nerror NotOutbox(address sender);\\n\\n/// @dev the provided outbox address isn't valid\\n/// @param outbox address of outbox being set\\nerror InvalidOutboxSet(address outbox);\\n\\ninterface IBridge {\\n    event MessageDelivered(\\n        uint256 indexed messageIndex,\\n        bytes32 indexed beforeInboxAcc,\\n        address inbox,\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash,\\n        uint256 baseFeeL1,\\n        uint64 timestamp\\n    );\\n\\n    event BridgeCallTriggered(\\n        address indexed outbox,\\n        address indexed to,\\n        uint256 value,\\n        bytes data\\n    );\\n\\n    event InboxToggle(address indexed inbox, bool enabled);\\n\\n    event OutboxToggle(address indexed outbox, bool enabled);\\n\\n    event SequencerInboxUpdated(address newSequencerInbox);\\n\\n    function enqueueDelayedMessage(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable returns (uint256);\\n\\n    function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead)\\n        external\\n        returns (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 acc\\n        );\\n\\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\\n        external\\n        returns (uint256 msgNum);\\n\\n    function executeCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    // These are only callable by the admin\\n    function setDelayedInbox(address inbox, bool enabled) external;\\n\\n    function setOutbox(address inbox, bool enabled) external;\\n\\n    function setSequencerInbox(address _sequencerInbox) external;\\n\\n    // View functions\\n\\n    function sequencerInbox() external view returns (address);\\n\\n    function activeOutbox() external view returns (address);\\n\\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\\n\\n    function allowedOutboxes(address outbox) external view returns (bool);\\n\\n    function delayedInboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function sequencerInboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function delayedMessageCount() external view returns (uint256);\\n\\n    function sequencerMessageCount() external view returns (uint256);\\n\\n    function rollup() external view returns (IOwnable);\\n}\\n\"\r\n    },\r\n    \"src/bridge/IOutbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport {AlreadyInit, NotRollup} from \\\"../libraries/Error.sol\\\";\\n\\n/// @dev The provided proof was too long\\n/// @param proofLength The length of the too-long proof\\nerror ProofTooLong(uint256 proofLength);\\n\\n/// @dev The output index was greater than the maximum\\n/// @param index The output index\\n/// @param maxIndex The max the index could be\\nerror PathNotMinimal(uint256 index, uint256 maxIndex);\\n\\n/// @dev The calculated root does not exist\\n/// @param root The calculated root\\nerror UnknownRoot(bytes32 root);\\n\\n/// @dev The record has already been spent\\n/// @param index The index of the spent record\\nerror AlreadySpent(uint256 index);\\n\\n/// @dev A call to the bridge failed with no return data\\nerror BridgeCallFailed();\\n\\ninterface IOutbox {\\n    event SendRootUpdated(bytes32 indexed blockHash, bytes32 indexed outputRoot);\\n    event OutBoxTransactionExecuted(\\n        address indexed to,\\n        address indexed l2Sender,\\n        uint256 indexed zero,\\n        uint256 transactionIndex\\n    );\\n\\n    function l2ToL1Sender() external view returns (address);\\n\\n    function l2ToL1Block() external view returns (uint256);\\n\\n    function l2ToL1EthBlock() external view returns (uint256);\\n\\n    function l2ToL1Timestamp() external view returns (uint256);\\n\\n    // @deprecated batch number is now always 0\\n    function l2ToL1BatchNum() external view returns (uint256);\\n\\n    function l2ToL1OutputId() external view returns (bytes32);\\n\\n    function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/MerkleLib.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport {MerkleProofTooLong} from \\\"./Error.sol\\\";\\n\\nlibrary MerkleLib {\\n    function generateRoot(bytes32[] memory _hashes) internal pure returns (bytes32) {\\n        bytes32[] memory prevLayer = _hashes;\\n        while (prevLayer.length > 1) {\\n            bytes32[] memory nextLayer = new bytes32[]((prevLayer.length + 1) / 2);\\n            for (uint256 i = 0; i < nextLayer.length; i++) {\\n                if (2 * i + 1 < prevLayer.length) {\\n                    nextLayer[i] = keccak256(\\n                        abi.encodePacked(prevLayer[2 * i], prevLayer[2 * i + 1])\\n                    );\\n                } else {\\n                    nextLayer[i] = prevLayer[2 * i];\\n                }\\n            }\\n            prevLayer = nextLayer;\\n        }\\n        return prevLayer[0];\\n    }\\n\\n    function calculateRoot(\\n        bytes32[] memory nodes,\\n        uint256 route,\\n        bytes32 item\\n    ) internal pure returns (bytes32) {\\n        uint256 proofItems = nodes.length;\\n        if (proofItems > 256) revert MerkleProofTooLong(proofItems, 256);\\n        bytes32 h = item;\\n        for (uint256 i = 0; i < proofItems; i++) {\\n            bytes32 node = nodes[i];\\n            if (route % 2 == 0) {\\n                assembly {\\n                    mstore(0x00, h)\\n                    mstore(0x20, node)\\n                    h := keccak256(0x00, 0x40)\\n                }\\n            } else {\\n                assembly {\\n                    mstore(0x00, node)\\n                    mstore(0x20, h)\\n                    h := keccak256(0x00, 0x40)\\n                }\\n            }\\n            route /= 2;\\n        }\\n        return h;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/DelegateCallAware.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport {NotOwner} from \\\"./Error.sol\\\";\\n\\n/// @dev A stateless contract that allows you to infer if the current call has been delegated or not\\n/// Pattern used here is from UUPS implementation by the OpenZeppelin team\\nabstract contract DelegateCallAware {\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegate call. This allows a function to be\\n     * callable on the proxy contract but not on the logic contract.\\n     */\\n    modifier onlyDelegated() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"Function must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /// @dev Check that msg.sender is the current EIP 1967 proxy admin\\n    modifier onlyProxyOwner() {\\n        // Storage slot with the admin of the proxy contract\\n        // This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1\\n        bytes32 slot = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n        address admin;\\n        assembly {\\n            admin := sload(slot)\\n        }\\n        if (msg.sender != admin) revert NotOwner(msg.sender, admin);\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Error.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\n/// @dev Init was already called\\nerror AlreadyInit();\\n\\n/// Init was called with param set to zero that must be nonzero\\nerror HadZeroInit();\\n\\n/// @dev Thrown when non owner tries to access an only-owner function\\n/// @param sender The msg.sender who is not the owner\\n/// @param owner The owner address\\nerror NotOwner(address sender, address owner);\\n\\n/// @dev Thrown when an address that is not the rollup tries to call an only-rollup function\\n/// @param sender The sender who is not the rollup\\n/// @param rollup The rollup address authorized to call this function\\nerror NotRollup(address sender, address rollup);\\n\\n/// @dev Thrown when the contract was not called directly from the origin ie msg.sender != tx.origin\\nerror NotOrigin();\\n\\n/// @dev Provided data was too large\\n/// @param dataLength The length of the data that is too large\\n/// @param maxDataLength The max length the data can be\\nerror DataTooLarge(uint256 dataLength, uint256 maxDataLength);\\n\\n/// @dev The provided is not a contract and was expected to be\\n/// @param addr The adddress in question\\nerror NotContract(address addr);\\n\\n/// @dev The merkle proof provided was too long\\n/// @param actualLength The length of the merkle proof provided\\n/// @param maxProofLength The max length a merkle proof can have\\nerror MerkleProofTooLong(uint256 actualLength, uint256 maxProofLength);\\n\\n/// @dev Thrown when an un-authorized address tries to access an admin function\\n/// @param sender The un-authorized sender\\n/// @param rollup The rollup, which would be authorized\\n/// @param owner The rollup's owner, which would be authorized\\nerror NotRollupOrOwner(address sender, address rollup, address owner);\\n\"\r\n    },\r\n    \"src/bridge/IOwnable.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AlreadyInit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"AlreadySpent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BridgeCallFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxProofLength\",\"type\":\"uint256\"}],\"name\":\"MerkleProofTooLong\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"}],\"name\":\"NotRollup\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxIndex\",\"type\":\"uint256\"}],\"name\":\"PathNotMinimal\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proofLength\",\"type\":\"uint256\"}],\"name\":\"ProofTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SimulationOnlyEntrypoint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"UnknownRoot\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"zero\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transactionIndex\",\"type\":\"uint256\"}],\"name\":\"OutBoxTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"outputRoot\",\"type\":\"bytes32\"}],\"name\":\"SendRootUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"OUTBOX_VERSION\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contract IBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"calculateItemHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"path\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"item\",\"type\":\"bytes32\"}],\"name\":\"calculateMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeTransactionSimulation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBridge\",\"name\":\"_bridge\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isSpent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1BatchNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1Block\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1EthBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1OutputId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1Sender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1Timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"roots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"spent\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2BlockHash\",\"type\":\"bytes32\"}],\"name\":\"updateSendRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Outbox", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}