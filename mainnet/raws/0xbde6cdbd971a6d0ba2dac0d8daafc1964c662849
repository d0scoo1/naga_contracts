{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/nft/IPFSConvert.sol\": {\r\n      \"content\": \"// contracts/IPFSConvert.sol\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\n\\nlibrary IPFSConvert {\\n\\n    bytes constant private CODE_STRING = \\\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\\\";\\n    bytes constant private CIDV0HEAD = \\\"\\\\x00\\\\x04\\\\x28\\\\x0b\\\\x12\\\\x17\\\\x09\\\\x28\\\\x31\\\\x00\\\\x12\\\\x04\\\\x28\\\\x20\\\\x25\\\\x25\\\\x22\\\\x31\\\\x1b\\\\x1d\\\\x39\\\\x29\\\\x09\\\\x26\\\\x1b\\\\x29\\\\x0b\\\\x02\\\\x0a\\\\x18\\\\x25\\\\x22\\\\x24\\\\x1b\\\\x39\\\\x2c\\\\x1d\\\\x39\\\\x07\\\\x06\\\\x29\\\\x25\\\\x13\\\\x15\\\\x2c\\\\x17\\\";\\n\\n    /**\\n     * @dev This function converts an 256 bits hash value into IPFS CIDv0 hash string.\\n     * @param _cidv0 256 bits hash value (not including the 0x12 0x20 signature)\\n     * @return IPFS CIDv0 hash string (Qm...)\\n     */\\n    function cidv0FromBytes32(bytes32 _cidv0) public pure returns (string memory) {\\n        unchecked {\\n            // convert to base58\\n            bytes memory result = new bytes(46);        // 46 is the longest possible base58 result from CIDv0\\n            uint256 resultLen = 45;\\n            uint256 number = uint256(_cidv0);\\n            while(number > 0) {\\n                uint256 rem = number % 58;\\n                result[resultLen] = bytes1(uint8(rem));\\n                resultLen--;\\n                number = number / 58;\\n            }\\n\\n            // add 0x1220 in front of _cidv0\\n            uint256 i;\\n            for (i = 0; i < 46; i++) {\\n                uint8 r = uint8(result[45 - i]) + uint8(CIDV0HEAD[i]);\\n                if (r >= 58) {\\n                    result[45 - i] = bytes1(r - 58);\\n                    result[45 - i - 1] = bytes1(uint8(result[45 - i - 1]) + 1);\\n                }\\n                else {\\n                    result[45 - i] = bytes1(r);\\n                }\\n            }\\n\\n            // convert to characters\\n            for (i = 0; i < 46; i++) {\\n                result[i] = CODE_STRING[uint8(result[i])];\\n            }\\n\\n            return string(result);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cidv0\",\"type\":\"bytes32\"}],\"name\":\"cidv0FromBytes32\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "IPFSConvert", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}