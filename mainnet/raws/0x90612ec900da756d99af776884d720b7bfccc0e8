{"status": "1", "message": "OK", "result": [{"SourceCode": "// Sources flattened with hardhat v2.9.2 https://hardhat.org\n\n// File @openzeppelin/contracts/security/ReentrancyGuard.sol@v4.5.0\n\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\n// File @openzeppelin/contracts/utils/Counters.sol@v4.5.0\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n\n// File @openzeppelin/contracts/utils/Strings.sol@v4.5.0\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\n// File @openzeppelin/contracts/utils/cryptography/ECDSA.sol@v4.5.0\n\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n\n\n// File @chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol@v0.4.0\n\n\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n\n\n// File contracts/interfaces/IHabitatNFT.sol\n\n\npragma solidity ^0.8.0;\n\ninterface IHabitatNFT {\n  function mint(\n    address account,\n    uint256 id,\n    uint256 amount,\n    uint96 editionRoyalty,\n    bytes memory data\n  ) external;\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes memory data\n  ) external;\n  \n  function burn(\n    address from,\n    uint256 id,\n    uint256 amount\n    ) external;\n}\n\n\n// File contracts/PrimaryMarketplace.sol\n\n\npragma solidity ^0.8.0;\n\n\n\ncontract PrimaryMarketplace is ReentrancyGuard {\n  using ECDSA for bytes32;\n  using Counters for Counters.Counter;\n\n  event AddItem(uint256 indexed _itemID);\n  struct Edition {\n    uint256 itemId;\n    address nftContract;\n    uint256 tokenId;\n    uint256 totalAmount;\n    uint256 availableAmount;\n    uint256 price;\n    uint256 royalty;\n    address seller;\n    bool isHighestBidAuction;\n  }\n\n  mapping(uint256 => Edition) private idToEdition;\n  mapping(address => bool) private creatorsWhitelist;\n  mapping(address => uint256) public creatorBalances;\n\n  Counters.Counter private _itemIds;\n  AggregatorV3Interface private priceFeed;\n  address private owner;\n\n  constructor(address priceAggregatorAddress) {\n    owner = msg.sender;\n    priceFeed = AggregatorV3Interface(priceAggregatorAddress);\n  }\n\n  function buyEdition(uint256 itemId, uint256 amount)\n    external\n    payable\n    nonReentrant\n    onlyAvailableEdition(itemId)\n  {\n    require(!idToEdition[itemId].isHighestBidAuction, \"NOT_PERMITTED\");\n    uint256 pricePerItemInUSD = idToEdition[itemId].price;\n    uint256 pricePerItem = pricePerItemInUSD * priceInWEI();\n    uint256 price = pricePerItem * amount;\n    require(msg.value >= price, \"WRONG_PRICE\");\n    creatorBalances[idToEdition[itemId].seller] = msg.value;\n\n    _safeTransfer(itemId, amount, msg.sender);\n  }\n\n  function payForBid(\n    uint256 itemId,\n    uint256 price,\n    bytes memory signature\n  ) external payable nonReentrant {\n    require(idToEdition[itemId].isHighestBidAuction, \"AUCTION_NOT_EXIST\");\n    address verifiedSigner = recoverSignerAddress(msg.sender, price, signature);\n    require(verifiedSigner == owner, \"NOT_AUTHORIZED\");\n    require(msg.value >= price * priceInWEI(), \"WRONG_PRICE\");\n    creatorBalances[idToEdition[itemId].seller] = msg.value;\n    _safeTransfer(itemId, 1, msg.sender);\n  }\n\n  function transferEdition(\n    uint256 itemId,\n    uint256 amount,\n    address receiver\n  ) external nonReentrant onlyOwner {\n    _safeTransfer(itemId, amount, receiver);\n  }\n\n  function addEdition(\n    address nftContract,\n    uint256 tokenId,\n    uint256 amount,\n    uint256 price,\n    uint96 royalty,\n    address seller,\n    bool isHighestBidAuction\n  ) external nonReentrant onlyOwnerOrCreator {\n    _itemIds.increment();\n    uint256 itemId = _itemIds.current();\n\n    uint256 amountToMint = amount;\n\n    if (isHighestBidAuction) {\n      amountToMint = 1;\n    }\n\n    idToEdition[itemId] = Edition(\n      itemId,\n      nftContract,\n      tokenId,\n      amountToMint,\n      amountToMint,\n      price,\n      royalty,\n      seller,\n      isHighestBidAuction\n    );\n\n    emit AddItem(itemId);\n\n    IHabitatNFT(nftContract).mint(seller, tokenId, amountToMint, royalty, \"\");\n  }\n\n  function addCreator(address creator) external onlyOwner {\n    creatorsWhitelist[creator] = true;\n  }\n\n  function burnToken(uint256 itemId) external onlyOwnerOrCreator {\n    uint256 amount = idToEdition[itemId].availableAmount;\n    idToEdition[itemId].availableAmount = 0;\n    IHabitatNFT(idToEdition[itemId].nftContract).burn(\n      idToEdition[itemId].seller,\n      idToEdition[itemId].tokenId,\n      amount\n    );\n  }\n\n  function withdraw(address receiver) external onlyOwnerOrCreator nonReentrant {\n    uint256 amount;\n\n    if (owner == msg.sender) {\n      amount = address(this).balance;\n    } else {\n      amount = creatorBalances[msg.sender];\n      require(amount > 0, \"OUT_OF_MONEY\");\n      creatorBalances[msg.sender] -= amount;\n    }\n\n    payable(receiver).transfer(amount);\n  }\n\n  function closeMarket(address receiver) external onlyOwner {\n    selfdestruct(payable(receiver));\n  }\n\n  function itemPrice(uint256 itemId)\n    external\n    view\n    onlyAvailableEdition(itemId)\n    returns (uint256)\n  {\n    uint256 pricePerItemInUSD = idToEdition[itemId].price;\n    uint256 pricePerItem = pricePerItemInUSD * priceInWEI();\n    return pricePerItem;\n  }\n\n  function fetchEditions() external view returns (Edition[] memory) {\n    uint256 itemCount = _itemIds.current();\n    uint256 currentIndex = 0;\n    Edition[] memory items = new Edition[](itemCount);\n    for (uint256 i = 0; i < itemCount; ) {\n      Edition memory currentItem = idToEdition[i + 1];\n      items[currentIndex] = currentItem;\n      currentIndex += 1;\n\n      unchecked {\n        ++i;\n      }\n    }\n    return items;\n  }\n\n  function fetchCreatorEditions(address habitatNFTCreatorAddress)\n    external\n    view\n    returns (Edition[] memory)\n  {\n    uint256 itemCount = _itemIds.current();\n    uint256 resultCount = 0;\n    uint256 currentIndex = 0;\n    for (uint256 i = 0; i < itemCount; ) {\n      if (idToEdition[i + 1].nftContract == habitatNFTCreatorAddress) {\n        resultCount += 1;\n      }\n      unchecked {\n        ++i;\n      }\n    }\n    Edition[] memory result = new Edition[](resultCount);\n    for (uint256 i = 0; i < itemCount; ) {\n      Edition memory currentItem = idToEdition[i + 1];\n\n      if (currentItem.nftContract == habitatNFTCreatorAddress) {\n        result[currentIndex] = currentItem;\n        currentIndex += 1;\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n    return result;\n  }\n\n  function priceInWEI() public view returns (uint256) {\n    return uint256(1e18 / uint256(_priceOfETH() / 10**_decimals()));\n  }\n\n  function hashTransaction(address account, uint256 price)\n    internal\n    pure\n    returns (bytes32)\n  {\n    bytes32 dataHash = keccak256(abi.encodePacked(account, price));\n    return\n      keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash));\n  }\n\n  function recoverSignerAddress(\n    address account,\n    uint256 price,\n    bytes memory signature\n  ) internal pure returns (address) {\n    bytes32 hash = hashTransaction(account, price);\n    return hash.recover(signature);\n  }\n\n  function _safeTransfer(\n    uint256 itemId,\n    uint256 amount,\n    address receiver\n  ) internal {\n    uint256 availableAmount = idToEdition[itemId].availableAmount;\n    require(availableAmount >= amount, \"OUT_OF_STOCK\");\n\n    idToEdition[itemId].availableAmount -= amount;\n\n    IHabitatNFT(idToEdition[itemId].nftContract).safeTransferFrom(\n      idToEdition[itemId].seller,\n      receiver,\n      idToEdition[itemId].tokenId,\n      amount,\n      \"\"\n    );\n  }\n\n  function _priceOfETH() private view returns (uint256) {\n    (\n      uint80 roundID,\n      int256 price,\n      uint256 startedAt,\n      uint256 timeStamp,\n      uint80 answeredInRound\n    ) = priceFeed.latestRoundData();\n    (roundID, startedAt, timeStamp, answeredInRound);\n    return uint256(price);\n  }\n\n  function _decimals() private view returns (uint256) {\n    uint256 decimals = uint256(priceFeed.decimals());\n    return decimals;\n  }\n\n  modifier onlyOwnerOrCreator() {\n    require(\n      creatorsWhitelist[msg.sender] || msg.sender == owner,\n      \"NOT_AUTHORIZED\"\n    );\n    _;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"NOT_AUTHORIZED\");\n    _;\n  }\n\n  modifier onlyAvailableEdition(uint256 itemId) {\n    require(idToEdition[itemId].nftContract != address(0), \"NOT_EXIST\");\n    _;\n  }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"priceAggregatorAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_itemID\",\"type\":\"uint256\"}],\"name\":\"AddItem\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"addCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"royalty\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isHighestBidAuction\",\"type\":\"bool\"}],\"name\":\"addEdition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"burnToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyEdition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"closeMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"creatorBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"habitatNFTCreatorAddress\",\"type\":\"address\"}],\"name\":\"fetchCreatorEditions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royalty\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isHighestBidAuction\",\"type\":\"bool\"}],\"internalType\":\"struct PrimaryMarketplace.Edition[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchEditions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royalty\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isHighestBidAuction\",\"type\":\"bool\"}],\"internalType\":\"struct PrimaryMarketplace.Edition[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"itemPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"payForBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceInWEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"transferEdition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PrimaryMarketplace", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}