{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/RiskProviderRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"./interfaces/IRiskProviderRegistry.sol\\\";\\r\\nimport \\\"./shared/SpoolOwnable.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/IFeeHandler.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IRiskProviderRegistry} interface.\\r\\n *\\r\\n * @notice\\r\\n * This implementation acts as a simple registry contract permitting a\\r\\n * designated party (the owner) to toggle the validity of providers within\\r\\n * it.\\r\\n *\\r\\n * In turn, these providers are able to set a risk score for the strategies\\r\\n * they want that needs to be in the range [-10.0, 10.0].\\r\\n */\\r\\ncontract RiskProviderRegistry is IRiskProviderRegistry, SpoolOwnable {\\r\\n    /* ========== CONSTANTS ========== */\\r\\n\\r\\n    /// @notice Maximum strategy risk score\\r\\n    /// @dev Risk score has 1 decimal accuracy, so value 100 represents 10.0\\r\\n    uint8 public constant MAX_RISK_SCORE = 100;\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    /// @notice fee handler contracts, to manage the risk provider fees\\r\\n    IFeeHandler public immutable feeHandler;\\r\\n\\r\\n    /// @notice Association of a risk provider to a strategy and finally to a risk score [0, 100]\\r\\n    mapping(address => mapping(address => uint8)) private _risk;\\r\\n\\r\\n    /// @notice Status of a risk provider\\r\\n    mapping(address => bool) private _provider;\\r\\n\\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Initialize contract, set spool owner\\r\\n     *\\r\\n     * @param _feeHandler to manage the risk provider fees\\r\\n     * @param _spoolOwner the spool owner contract\\r\\n     */\\r\\n    constructor(\\r\\n        IFeeHandler _feeHandler,\\r\\n        ISpoolOwner _spoolOwner\\r\\n    )\\r\\n        SpoolOwnable(_spoolOwner)\\r\\n    {\\r\\n        require(address(_feeHandler) != address(0), \\\"RiskProviderRegistry::constructor: Fee Handler address cannot be 0\\\");\\r\\n        feeHandler = _feeHandler;\\r\\n    }\\r\\n\\r\\n    /* ========== VIEWS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Returns whether or not a particular address is a risk provider.\\r\\n     *\\r\\n     * @param provider provider address to check\\r\\n     *\\r\\n     * @return boolean indicating entry in _provider\\r\\n     */\\r\\n    function isProvider(address provider) public view override returns (bool) {\\r\\n        return _provider[provider];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the risk scores of strateg(s) as defined by\\r\\n     * the provided risk provider.\\r\\n     *\\r\\n     * @param riskProvider risk provider to get risk scores for \\r\\n     * @param strategies list of strategies that the risk provider has set risks for\\r\\n     *\\r\\n     * @return risk scores\\r\\n     */\\r\\n    function getRisks(address riskProvider, address[] memory strategies)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint8[] memory)\\r\\n    {\\r\\n        uint8[] memory riskScores = new uint8[](strategies.length);\\r\\n        for (uint256 i = 0; i < strategies.length; i++) {\\r\\n            riskScores[i] = _risk[riskProvider][strategies[i]];\\r\\n        }\\r\\n\\r\\n        return riskScores;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the risk score of a particular strategy as defined by\\r\\n     * the provided risk provider.\\r\\n     *\\r\\n     * @param riskProvider risk provider to get risk scores for \\r\\n     * @param strategy strategy that the risk provider has set risk for\\r\\n     *\\r\\n     * @return risk score\\r\\n     */\\r\\n    function getRisk(address riskProvider, address strategy)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint8)\\r\\n    {\\r\\n        return _risk[riskProvider][strategy];\\r\\n    }\\r\\n\\r\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Allows the risk score of multiple strategies to be set.\\r\\n     *\\r\\n     * @dev\\r\\n     * Requirements:\\r\\n     * - the caller must be a risk provider\\r\\n     * - input arrays must have the same length\\r\\n     *\\r\\n     * @param strategies list of strategies to set risk scores for\\r\\n     * @param riskScores list of risk scores to set on each strategy\\r\\n     */\\r\\n    function setRisks(address[] memory strategies, uint8[] memory riskScores) external {\\r\\n        require(\\r\\n            isProvider(msg.sender),\\r\\n            \\\"RiskProviderRegistry::setRisks: Insufficient Privileges\\\"\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            strategies.length == riskScores.length,\\r\\n            \\\"RiskProviderRegistry::setRisks: Strategies and risk scores lengths don't match\\\"\\r\\n        );    \\r\\n\\r\\n        for (uint i = 0; i < strategies.length; i++) {\\r\\n            _setRisk(strategies[i], riskScores[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows the risk score of a strategy to be set.\\r\\n     *\\r\\n     * @dev\\r\\n     * Requirements:\\r\\n     * - the caller must be a valid risk provider\\r\\n     *\\r\\n     * @param strategy strategy to set risk score for\\r\\n     * @param riskScore risk score to set on the strategy\\r\\n     */\\r\\n    function setRisk(address strategy, uint8 riskScore) external {\\r\\n        require(\\r\\n            isProvider(msg.sender),\\r\\n            \\\"RiskProviderRegistry::setRisk: Insufficient Privileges\\\"\\r\\n        );\\r\\n\\r\\n        _setRisk(strategy, riskScore);\\r\\n    }\\r\\n\\r\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Allows the inclusion of a new provider to the registry.\\r\\n     *\\r\\n     * @dev\\r\\n     * Emits a {ProviderAdded} event indicating the newly added provider.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - the caller must be the owner of the contract\\r\\n     * - the provider must not already exist in the registry\\r\\n     *\\r\\n     * @param provider provider to add\\r\\n     * @param fee fee to go to provider\\r\\n     */\\r\\n    function addProvider(address provider, uint16 fee) external onlyOwner {\\r\\n        require(\\r\\n            !_provider[provider],\\r\\n            \\\"RiskProviderRegistry::addProvider: Provider already exists\\\"\\r\\n        );\\r\\n\\r\\n        _provider[provider] = true;\\r\\n        feeHandler.setRiskProviderFee(provider, fee);\\r\\n\\r\\n        emit ProviderAdded(provider);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows the removal of an existing provider to the registry.\\r\\n     *\\r\\n     * @dev\\r\\n     * Emits a {ProviderRemoved} event indicating the address of the removed provider.\\r\\n     * provider fee is also set to 0.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be the owner of the contract\\r\\n     * - the provider must already exist in the registry\\r\\n     *\\r\\n     * @param provider provider to remove\\r\\n     */\\r\\n    function removeProvider(address provider) external onlyOwner {\\r\\n        require(\\r\\n            _provider[provider],\\r\\n            \\\"RiskProviderRegistry::removeProvider: Provider does not exist\\\"\\r\\n        );\\r\\n\\r\\n        _provider[provider] = false;\\r\\n        feeHandler.setRiskProviderFee(provider, 0);\\r\\n\\r\\n        emit ProviderRemoved(provider);\\r\\n    }\\r\\n\\r\\n    /* ========== PRIVATE FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Allows the risk score of a strategy to be set (internal)\\r\\n     *\\r\\n     * @dev\\r\\n     * Emits a {RiskAssessed} event indicating the assessor of the score and the\\r\\n     * newly set risk score of the strategy\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the risk score must be less than 100\\r\\n     *\\r\\n     * @param strategy strategy to set risk score for\\r\\n     * @param riskScore risk score to set on the strategy\\r\\n     */\\r\\n    function _setRisk(address strategy, uint8 riskScore) private {\\r\\n        require(riskScore <= MAX_RISK_SCORE, \\\"RiskProviderRegistry::_setRisk: Risk score too big\\\");\\r\\n\\r\\n        _risk[msg.sender][strategy] = riskScore;\\r\\n\\r\\n        emit RiskAssessed(msg.sender, strategy, riskScore);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeeHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\ninterface IFeeHandler {\\n    function payFees(\\n        IERC20 underlying,\\n        uint256 profit,\\n        address riskProvider,\\n        address vaultOwner,\\n        uint16 vaultFee\\n    ) external returns (uint256 feesPaid);\\n\\n    function setRiskProviderFee(address riskProvider, uint16 fee) external;\\n\\n    /* ========== EVENTS ========== */\\n\\n    event FeesPaid(address indexed vault, uint profit, uint ecosystemCollected, uint treasuryCollected, uint riskProviderColected, uint vaultFeeCollected);\\n    event RiskProviderFeeUpdated(address indexed riskProvider, uint indexed fee);\\n    event EcosystemFeeUpdated(uint indexed fee);\\n    event TreasuryFeeUpdated(uint indexed fee);\\n    event EcosystemCollectorUpdated(address indexed collector);\\n    event TreasuryCollectorUpdated(address indexed collector);\\n    event FeeCollected(address indexed collector, IERC20 indexed underlying, uint amount);\\n    event EcosystemFeeCollected(IERC20 indexed underlying, uint amount);\\n    event TreasuryFeeCollected(IERC20 indexed underlying, uint amount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRiskProviderRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\ninterface IRiskProviderRegistry {\\n    /* ========== FUNCTIONS ========== */\\n\\n    function isProvider(address provider) external view returns (bool);\\n\\n    function getRisk(address riskProvider, address strategy) external view returns (uint8);\\n\\n    function getRisks(address riskProvider, address[] memory strategies) external view returns (uint8[] memory);\\n\\n    /* ========== EVENTS ========== */\\n\\n    event RiskAssessed(address indexed provider, address indexed strategy, uint8 riskScore);\\n    event ProviderAdded(address provider);\\n    event ProviderRemoved(address provider);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISpoolOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\ninterface ISpoolOwner {\\r\\n    function isSpoolOwner(address user) external view returns(bool);\\r\\n}\"\r\n    },\r\n    \"contracts/shared/SpoolOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../interfaces/ISpoolOwner.sol\\\";\\r\\n\\r\\n/// @title Logic to help check whether the caller is the Spool owner\\r\\nabstract contract SpoolOwnable {\\r\\n    /// @notice Contract that checks if address is Spool owner\\r\\n    ISpoolOwner internal immutable spoolOwner;\\r\\n\\r\\n    /**\\r\\n     * @notice Sets correct initial values\\r\\n     * @param _spoolOwner Spool owner contract address\\r\\n     */\\r\\n    constructor(ISpoolOwner _spoolOwner) {\\r\\n        require(\\r\\n            address(_spoolOwner) != address(0),\\r\\n            \\\"SpoolOwnable::constructor: Spool owner contract address cannot be 0\\\"\\r\\n        );\\r\\n\\r\\n        spoolOwner = _spoolOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if caller is Spool owner\\r\\n     * @return True if caller is Spool owner, false otherwise\\r\\n     */\\r\\n    function isSpoolOwner() internal view returns(bool) {\\r\\n        return spoolOwner.isSpoolOwner(msg.sender);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @notice Checks and throws if caller is not Spool owner\\r\\n    function _onlyOwner() private view {\\r\\n        require(isSpoolOwner(), \\\"SpoolOwnable::onlyOwner: Caller is not the Spool owner\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Checks and throws if caller is not Spool owner\\r\\n    modifier onlyOwner() {\\r\\n        _onlyOwner();\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IFeeHandler\",\"name\":\"_feeHandler\",\"type\":\"address\"},{\"internalType\":\"contract ISpoolOwner\",\"name\":\"_spoolOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"ProviderAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"ProviderRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"riskScore\",\"type\":\"uint8\"}],\"name\":\"RiskAssessed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_RISK_SCORE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"fee\",\"type\":\"uint16\"}],\"name\":\"addProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeHandler\",\"outputs\":[{\"internalType\":\"contract IFeeHandler\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"riskProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"getRisk\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"riskProvider\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"}],\"name\":\"getRisks\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"isProvider\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"removeProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"riskScore\",\"type\":\"uint8\"}],\"name\":\"setRisk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"riskScores\",\"type\":\"uint8[]\"}],\"name\":\"setRisks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RiskProviderRegistry", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "000000000000000000000000b7be35c489accf37d9711cb0030af40fddfefc5c0000000000000000000000004f03f70a99e5c3b49d733ddd7458f80fa9b5a5b5", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}