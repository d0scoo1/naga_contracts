{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: @openzeppelin/contracts/utils/Counters.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: MultiSigWallet.sol\r\n\r\n\r\n\r\npragma solidity 0.8.0;\r\n\r\n\r\n\r\ncontract MultiSigWallet is ReentrancyGuard {\r\n    using Counters for Counters.Counter;\r\n    event Deposit(address indexed sender, uint256 amount, uint256 balance);\r\n    event SubmitTransaction(address indexed signer, uint256 indexed txIndex, address indexed to, uint256 value, bytes data);\r\n\r\n    address[] private signers;\r\n    mapping(address => bool) public isSigner;\r\n    uint256 public numConfirmationsRequired;\r\n\r\n    // mapping from tx index => signer => bool\r\n    mapping(uint256 => mapping(address => bool)) public isConfirmed;\r\n    Counters.Counter private txIds;\r\n\r\n    modifier onlySigner() {\r\n        require(isSigner[msg.sender], \"not signer\");\r\n        _;\r\n    }\r\n\r\n    constructor(address[] memory _signers, uint256 _numConfirmationsRequired) {\r\n        require(_signers.length > 0, \"signers required\");\r\n        require(\r\n            _numConfirmationsRequired > 0 && _numConfirmationsRequired <= _signers.length,\r\n            \"invalid number of required confirmations\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < _signers.length; i++) {\r\n            address signer = _signers[i];\r\n\r\n            require(signer != address(0), \"invalid signer\");\r\n            require(!isSigner[signer], \"signer not unique\");\r\n\r\n            isSigner[signer] = true;\r\n            signers.push(signer);\r\n        }\r\n\r\n        numConfirmationsRequired = _numConfirmationsRequired;\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Deposit(msg.sender, msg.value, address(this).balance);\r\n    }\r\n\r\n    function submitTransaction(\r\n        address _to,\r\n        uint256 _value,\r\n        bytes memory _data,\r\n        bytes32[] memory rs,\r\n        bytes32[] memory ss,\r\n        uint8[] memory vs\r\n    ) external payable onlySigner nonReentrant {\r\n        require(_to != address(0), \"ZERO Address\");\r\n        require(rs.length == ss.length && ss.length == vs.length, \"Signaure lengths should be same\");\r\n        uint256 sigLength = rs.length;\r\n        require(sigLength >= numConfirmationsRequired, \"Less than needed required confirmations\");\r\n        if (_value > 0) {\r\n            require(msg.value == _value, \"Should send value\");\r\n        }\r\n        uint256 ii;\r\n        uint256 txIdx = txIds.current();\r\n        for (ii = 0; ii < sigLength; ii++) {\r\n            address _signer = _getSigner(_to, _value, _data, rs[ii], ss[ii], vs[ii]);\r\n            require(isSigner[_signer] && !isConfirmed[txIdx][_signer], \"Not signer or duplicated signer for this transaction\");\r\n            isConfirmed[txIdx][_signer] = true;\r\n        }\r\n        (bool success, ) = _to.call{value: _value}(_data);\r\n        require(success, \"tx failed\");\r\n\r\n        emit SubmitTransaction(msg.sender, txIdx, _to, _value, _data);\r\n        txIds.increment();\r\n    }\r\n\r\n    function _getSigner(\r\n        address _to,\r\n        uint256 _value,\r\n        bytes memory _data,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v\r\n    ) private pure returns (address) {\r\n        bytes32 msgHash = keccak256(abi.encodePacked(_to, _value, _data));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", msgHash));\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        return recoveredAddress;\r\n    }\r\n\r\n    function getSigners() external view returns (address[] memory) {\r\n        return signers;\r\n    }\r\n\r\n    function getTransactionCount() external view returns (uint256) {\r\n        return txIds.current();\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_numConfirmationsRequired\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SubmitTransaction\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getSigners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTransactionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isSigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numConfirmationsRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"rs\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"ss\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8[]\",\"name\":\"vs\",\"type\":\"uint8[]\"}],\"name\":\"submitTransaction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MultiSigWallet", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000080000000000000000000000009066fddc2672ea3faa20b377126e3f3fe022177500000000000000000000000069927ab9c9937f36312958e192d27819522eeec90000000000000000000000009c702cc077fe63f0ba5b69dac3861ed5727778c9000000000000000000000000b89e07389a98f6fa9bee9c4de220e95eba30abe90000000000000000000000008c7d7ab71bb76f1fdfb9525dd25e4e060fa0995a000000000000000000000000495a1abab1a5e2c71bae9e686309704032d61939000000000000000000000000b6ad7b652abafac837346a7a25ae24159e8222ea0000000000000000000000005404e50f23bb42ffa126ae00f06752e01349d525", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9e565d86cfd7572835fd4b700a274080a004998545517d096927e2cea48f620d"}]}