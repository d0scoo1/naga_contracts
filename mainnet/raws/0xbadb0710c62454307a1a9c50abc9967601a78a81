{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: Special redeem, swap, LP, bond contract\r\n// msg.sender needs to approve smart contract to take redeeming/input token from their wallet e.g. ALCX\r\n// created by 0xfadedface\r\npragma solidity 0.8.7;\r\ninterface IERC20 {function transfer(address recipient, uint256 amount) external returns (bool);function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); function balanceOf(address account) external view returns (uint256);function approve(address spender, uint256 amount) external returns (bool);}\r\ninterface bondContract {function redeem(address _depositor) external returns (uint); function deposit(uint _amount, uint _maxPrice, address _depositor) external returns (uint);}\r\ninterface V2Router {function addLiquidity(address tokenA,address tokenB,uint amountADesired,uint amountBDesired,uint amountAMin,uint amountBMin,address to,uint deadline) external returns (uint amountA, uint amountB, uint liquidity);    function swapTokensForExactTokens(uint amountOut,uint amountInMax,address[] calldata path,address to,uint deadline) external returns (uint[] memory amounts);}\r\ncontract RedeemInvest {\r\n    address public oneInchRouter = 0x1111111254fb6c44bAC0beD2854e76F90643097d;\r\n    address public sushiRouter = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\r\n    bool locked = false;\r\n   \r\n    struct Params {\r\n        address[] redeems;\r\n        uint[4] slippages;\r\n        uint amountIn;\r\n        address tokenIn;\r\n        address tokenOut;\r\n        bytes swapPayload;\r\n        bool LP;\r\n        address poolAddress;\r\n        address bondContractAddress;\r\n    }\r\n    \r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    address public owner;\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner,\"ow\");\r\n        _;\r\n    }\r\n    modifier protect() {\r\n        if (locked) {\r\n            revert();\r\n        }\r\n    locked = true;\r\n    _;\r\n    locked = false;  \r\n    }\r\n    function setOwner(address newOwner) external onlyOwner{\r\n        owner = newOwner;\r\n    }\r\n\r\n    //if tokens ever get accidently sent to smart contract they can be recovered easily\r\n    function saveTokens(address _tokenContract, uint256 _amount) external onlyOwner{\r\n        IERC20 tokenContract = IERC20(_tokenContract);\r\n        tokenContract.transfer(owner, _amount);\r\n    }\r\n\r\n    function redeemSwapLPBond(Params calldata _params) external protect{\r\n        for(uint256 i = 0; i < _params.redeems.length; i++){bondContract(_params.redeems[i]).redeem(msg.sender);}\r\n        //transfer desired tokens into smart contract\r\n        IERC20(_params.tokenIn).transferFrom(msg.sender, address(this), _params.amountIn);\r\n        //approve and swap token to bond token\r\n        IERC20(_params.tokenIn).approve(oneInchRouter,2**256-1);\r\n        (bool _success, ) = oneInchRouter.call(_params.swapPayload);\r\n        require(_success);\r\n        //addLiquidity\r\n        uint bondSlippage=_params.slippages[3];\r\n        if(_params.LP){\r\n\r\n        IERC20(_params.tokenIn).approve(sushiRouter,2**256-1);\r\n        IERC20(_params.tokenOut).approve(sushiRouter,2**256-1);\r\n\r\n        uint amountADesired=_params.slippages[0];\r\n        uint amountBDesired=_params.slippages[1];\r\n        uint deadline = _params.slippages[2];\r\n            V2Router(sushiRouter).addLiquidity(\r\n                _params.tokenIn,//tokenA\r\n                _params.tokenOut,//tokenB\r\n                IERC20(_params.tokenIn).balanceOf(address(this)),//amountADesired\r\n                IERC20(_params.tokenOut).balanceOf(address(this)),//amountBDesired\r\n                amountADesired,//amountAMin\r\n                amountBDesired,//amountBMin\r\n                address(this),//to\r\n                deadline//deadline\r\n                );\r\n            //approve and deposit LP\r\n            IERC20(_params.poolAddress).approve(_params.bondContractAddress,2**256-1);\r\n            bondContract(_params.bondContractAddress).deposit(IERC20(_params.poolAddress).balanceOf(address(this)),bondSlippage, msg.sender);\r\n        }else{\r\n            //approve and deposit non-LP\r\n            IERC20(_params.tokenOut).approve(_params.bondContractAddress,2**256-1);\r\n            bondContract(_params.bondContractAddress).deposit(IERC20(_params.tokenOut).balanceOf(address(this)), bondSlippage, msg.sender);\r\n        }    \r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"oneInchRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"redeems\",\"type\":\"address[]\"},{\"internalType\":\"uint256[4]\",\"name\":\"slippages\",\"type\":\"uint256[4]\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapPayload\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"LP\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bondContractAddress\",\"type\":\"address\"}],\"internalType\":\"struct RedeemInvest.Params\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"redeemSwapLPBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"saveTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RedeemInvest", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6720adeb1ee83ebd3c5336874177d776b9baf64c8bc285b1a2598a609ebae1b2"}]}