{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.8.3;\r\n\r\ninterface IERC20 {\r\n    function symbol() external view returns (string memory);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    // Note this is non standard but nearly all ERC20 have exposed decimal functions\r\n    function decimals() external view returns (uint8);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\nlibrary Storage {\r\n    // This library follows a pattern which if solidity had higher level\r\n    // type or macro support would condense quite a bit.\r\n\r\n    // Each basic type which does not support storage locations is encoded as\r\n    // a struct of the same name capitalized and has functions 'load' and 'set'\r\n    // which load the data and set the data respectively.\r\n\r\n    // All types will have a function of the form 'typename'Ptr('name') -> storage ptr\r\n    // which will return a storage version of the type with slot which is the hash of\r\n    // the variable name and type string. This pointer allows easy state management between\r\n    // upgrades and overrides the default solidity storage slot system.\r\n\r\n    /// @dev The address type container\r\n    struct Address {\r\n        address data;\r\n    }\r\n\r\n    /// @notice A function which turns a variable name for a storage address into a storage\r\n    ///         pointer for its container.\r\n    /// @param name the variable name\r\n    /// @return data the storage pointer\r\n    function addressPtr(string memory name)\r\n        internal\r\n        pure\r\n        returns (Address storage data)\r\n    {\r\n        bytes32 typehash = keccak256(\"address\");\r\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\r\n        assembly {\r\n            data.slot := offset\r\n        }\r\n    }\r\n\r\n    /// @notice A function to load an address from the container struct\r\n    /// @param input the storage pointer for the container\r\n    /// @return the loaded address\r\n    function load(Address storage input) internal view returns (address) {\r\n        return input.data;\r\n    }\r\n\r\n    /// @notice A function to set the internal field of an address container\r\n    /// @param input the storage pointer to the container\r\n    /// @param to the address to set the container to\r\n    function set(Address storage input, address to) internal {\r\n        input.data = to;\r\n    }\r\n\r\n    /// @dev The uint256 type container\r\n    struct Uint256 {\r\n        uint256 data;\r\n    }\r\n\r\n    /// @notice A function which turns a variable name for a storage uint256 into a storage\r\n    ///         pointer for its container.\r\n    /// @param name the variable name\r\n    /// @return data the storage pointer\r\n    function uint256Ptr(string memory name)\r\n        internal\r\n        pure\r\n        returns (Uint256 storage data)\r\n    {\r\n        bytes32 typehash = keccak256(\"uint256\");\r\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\r\n        assembly {\r\n            data.slot := offset\r\n        }\r\n    }\r\n\r\n    /// @notice A function to load an uint256 from the container struct\r\n    /// @param input the storage pointer for the container\r\n    /// @return the loaded uint256\r\n    function load(Uint256 storage input) internal view returns (uint256) {\r\n        return input.data;\r\n    }\r\n\r\n    /// @notice A function to set the internal field of a unit256 container\r\n    /// @param input the storage pointer to the container\r\n    /// @param to the address to set the container to\r\n    function set(Uint256 storage input, uint256 to) internal {\r\n        input.data = to;\r\n    }\r\n\r\n    /// @notice Returns the storage pointer for a named mapping of address to uint256\r\n    /// @param name the variable name for the pointer\r\n    /// @return data the mapping pointer\r\n    function mappingAddressToUnit256Ptr(string memory name)\r\n        internal\r\n        pure\r\n        returns (mapping(address => uint256) storage data)\r\n    {\r\n        bytes32 typehash = keccak256(\"mapping(address => uint256)\");\r\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\r\n        assembly {\r\n            data.slot := offset\r\n        }\r\n    }\r\n\r\n    /// @notice Returns the storage pointer for a named mapping of address to uint256[]\r\n    /// @param name the variable name for the pointer\r\n    /// @return data the mapping pointer\r\n    function mappingAddressToUnit256ArrayPtr(string memory name)\r\n        internal\r\n        pure\r\n        returns (mapping(address => uint256[]) storage data)\r\n    {\r\n        bytes32 typehash = keccak256(\"mapping(address => uint256[])\");\r\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\r\n        assembly {\r\n            data.slot := offset\r\n        }\r\n    }\r\n\r\n    /// @notice Allows external users to calculate the slot given by this lib\r\n    /// @param typeString the string which encodes the type\r\n    /// @param name the variable name\r\n    /// @return the slot assigned by this lib\r\n    function getPtr(string memory typeString, string memory name)\r\n        external\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        bytes32 typehash = keccak256(abi.encodePacked(typeString));\r\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\r\n        return (uint256)(offset);\r\n    }\r\n\r\n    // A struct which represents 1 packed storage location with a compressed\r\n    // address and uint96 pair\r\n    struct AddressUint {\r\n        address who;\r\n        uint96 amount;\r\n    }\r\n\r\n    /// @notice Returns the storage pointer for a named mapping of address to uint256[]\r\n    /// @param name the variable name for the pointer\r\n    /// @return data the mapping pointer\r\n    function mappingAddressToPackedAddressUint(string memory name)\r\n        internal\r\n        pure\r\n        returns (mapping(address => AddressUint) storage data)\r\n    {\r\n        bytes32 typehash = keccak256(\"mapping(address => AddressUint)\");\r\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\r\n        assembly {\r\n            data.slot := offset\r\n        }\r\n    }\r\n}\r\n// This library is an assembly optimized storage library which is designed\r\n// to track timestamp history in a struct which uses hash derived pointers.\r\n// WARNING - Developers using it should not access the underlying storage\r\n// directly since we break some assumptions of high level solidity. Please\r\n// note this library also increases the risk profile of memory manipulation\r\n// please be cautious in your usage of uninitialized memory structs and other\r\n// anti patterns.\r\nlibrary History {\r\n    // The storage layout of the historical array looks like this\r\n    // [(128 bit min index)(128 bit length)] [0][0] ... [(64 bit block num)(192 bit data)] .... [(64 bit block num)(192 bit data)]\r\n    // We give the option to the invoker of the search function the ability to clear\r\n    // stale storage. To find data we binary search for the block number we need\r\n    // This library expects the blocknumber indexed data to be pushed in ascending block number\r\n    // order and if data is pushed with the same blocknumber it only retains the most recent.\r\n    // This ensures each blocknumber is unique and contains the most recent data at the end\r\n    // of whatever block it indexes [as long as that block is not the current one].\r\n\r\n    // A struct which wraps a memory pointer to a string and the pointer to storage\r\n    // derived from that name string by the storage library\r\n    // WARNING - For security purposes never directly construct this object always use load\r\n    struct HistoricalBalances {\r\n        string name;\r\n        // Note - We use bytes32 to reduce how easy this is to manipulate in high level sol\r\n        bytes32 cachedPointer;\r\n    }\r\n\r\n    /// @notice The method by which inheriting contracts init the HistoricalBalances struct\r\n    /// @param name The name of the variable. Note - these are globals, any invocations of this\r\n    ///             with the same name work on the same storage.\r\n    /// @return The memory pointer to the wrapper of the storage pointer\r\n    function load(string memory name)\r\n        internal\r\n        pure\r\n        returns (HistoricalBalances memory)\r\n    {\r\n        mapping(address => uint256[]) storage storageData =\r\n            Storage.mappingAddressToUnit256ArrayPtr(name);\r\n        bytes32 pointer;\r\n        assembly {\r\n            pointer := storageData.slot\r\n        }\r\n        return HistoricalBalances(name, pointer);\r\n    }\r\n\r\n    /// @notice An unsafe method of attaching the cached ptr in a historical balance memory objects\r\n    /// @param pointer cached pointer to storage\r\n    /// @return storageData A storage array mapping pointer\r\n    /// @dev PLEASE DO NOT USE THIS METHOD WITHOUT SERIOUS REVIEW. IF AN EXTERNAL ACTOR CAN CALL THIS WITH\r\n    //       ARBITRARY DATA THEY MAY BE ABLE TO OVERWRITE ANY STORAGE IN THE CONTRACT.\r\n    function _getMapping(bytes32 pointer)\r\n        private\r\n        pure\r\n        returns (mapping(address => uint256[]) storage storageData)\r\n    {\r\n        assembly {\r\n            storageData.slot := pointer\r\n        }\r\n    }\r\n\r\n    /// @notice This function adds a block stamp indexed piece of data to a historical data array\r\n    ///         To prevent duplicate entries if the top of the array has the same blocknumber\r\n    ///         the value is updated instead\r\n    /// @param wrapper The wrapper which hold the reference to the historical data storage pointer\r\n    /// @param who The address which indexes the array we need to push to\r\n    /// @param data The data to append, should be at most 192 bits and will revert if not\r\n    function push(\r\n        HistoricalBalances memory wrapper,\r\n        address who,\r\n        uint256 data\r\n    ) internal {\r\n        // Check preconditions\r\n        // OoB = Out of Bounds, short for contract bytecode size reduction\r\n        require(data <= type(uint192).max, \"OoB\");\r\n        // Get the storage this is referencing\r\n        mapping(address => uint256[]) storage storageMapping =\r\n            _getMapping(wrapper.cachedPointer);\r\n        // Get the array we need to push to\r\n        uint256[] storage storageData = storageMapping[who];\r\n        // We load the block number and then shift it to be in the top 64 bits\r\n        uint256 blockNumber = block.number << 192;\r\n        // We combine it with the data, because of our require this will have a clean\r\n        // top 64 bits\r\n        uint256 packedData = blockNumber | data;\r\n        // Load the array length\r\n        (uint256 minIndex, uint256 length) = _loadBounds(storageData);\r\n        // On the first push we don't try to load\r\n        uint256 loadedBlockNumber = 0;\r\n        if (length != 0) {\r\n            (loadedBlockNumber, ) = _loadAndUnpack(storageData, length - 1);\r\n        }\r\n        // The index we push to, note - we use this pattern to not branch the assembly\r\n        uint256 index = length;\r\n        // If the caller is changing data in the same block we change the entry for this block\r\n        // instead of adding a new one. This ensures each block numb is unique in the array.\r\n        if (loadedBlockNumber == block.number) {\r\n            index = length - 1;\r\n        }\r\n        // We use assembly to write our data to the index\r\n        assembly {\r\n            // Stores packed data in the equivalent of storageData[length]\r\n            sstore(\r\n                add(\r\n                    // The start of the data slots\r\n                    add(storageData.slot, 1),\r\n                    // index where we store\r\n                    index\r\n                ),\r\n                packedData\r\n            )\r\n        }\r\n        // Reset the boundaries if they changed\r\n        if (loadedBlockNumber != block.number) {\r\n            _setBounds(storageData, minIndex, length + 1);\r\n        }\r\n    }\r\n\r\n    /// @notice Loads the most recent timestamp of delegation power\r\n    /// @param wrapper The memory struct which we want to search for historical data\r\n    /// @param who The user who's balance we want to load\r\n    /// @return the top slot of the array\r\n    function loadTop(HistoricalBalances memory wrapper, address who)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Load the storage pointer\r\n        uint256[] storage userData = _getMapping(wrapper.cachedPointer)[who];\r\n        // Load the length\r\n        (, uint256 length) = _loadBounds(userData);\r\n        // If it's zero no data has ever been pushed so we return zero\r\n        if (length == 0) {\r\n            return 0;\r\n        }\r\n        // Load the current top\r\n        (, uint256 storedData) = _loadAndUnpack(userData, length - 1);\r\n        // and return it\r\n        return (storedData);\r\n    }\r\n\r\n    /// @notice Finds the data stored with the highest block number which is less than or equal to a provided\r\n    ///         blocknumber.\r\n    /// @param wrapper The memory struct which we want to search for historical data\r\n    /// @param who The address which indexes the array to be searched\r\n    /// @param blocknumber The blocknumber we want to load the historical data of\r\n    /// @return The loaded unpacked data at this point in time.\r\n    function find(\r\n        HistoricalBalances memory wrapper,\r\n        address who,\r\n        uint256 blocknumber\r\n    ) internal view returns (uint256) {\r\n        // Get the storage this is referencing\r\n        mapping(address => uint256[]) storage storageMapping =\r\n            _getMapping(wrapper.cachedPointer);\r\n        // Get the array we need to push to\r\n        uint256[] storage storageData = storageMapping[who];\r\n        // Pre load the bounds\r\n        (uint256 minIndex, uint256 length) = _loadBounds(storageData);\r\n        // Search for the blocknumber\r\n        (, uint256 loadedData) =\r\n            _find(storageData, blocknumber, 0, minIndex, length);\r\n        // In this function we don't have to change the stored length data\r\n        return (loadedData);\r\n    }\r\n\r\n    /// @notice Finds the data stored with the highest blocknumber which is less than or equal to a provided block number\r\n    ///         Opportunistically clears any data older than staleBlock which is possible to clear.\r\n    /// @param wrapper The memory struct which points to the storage we want to search\r\n    /// @param who The address which indexes the historical data we want to search\r\n    /// @param blocknumber The blocknumber we want to load the historical state of\r\n    /// @param staleBlock A block number which we can [but are not obligated to] delete history older than\r\n    /// @return The found data\r\n    function findAndClear(\r\n        HistoricalBalances memory wrapper,\r\n        address who,\r\n        uint256 blocknumber,\r\n        uint256 staleBlock\r\n    ) internal returns (uint256) {\r\n        // Get the storage this is referencing\r\n        mapping(address => uint256[]) storage storageMapping =\r\n            _getMapping(wrapper.cachedPointer);\r\n        // Get the array we need to push to\r\n        uint256[] storage storageData = storageMapping[who];\r\n        // Pre load the bounds\r\n        (uint256 minIndex, uint256 length) = _loadBounds(storageData);\r\n        // Search for the blocknumber\r\n        (uint256 staleIndex, uint256 loadedData) =\r\n            _find(storageData, blocknumber, staleBlock, minIndex, length);\r\n        // We clear any data in the stale region\r\n        // Note - Since find returns 0 if no stale data is found and we use > instead of >=\r\n        //        this won't trigger if no stale data is found. Plus it won't trigger on minIndex == staleIndex\r\n        //        == maxIndex and clear the whole array.\r\n        if (staleIndex > minIndex) {\r\n            // Delete the outdated stored info\r\n            _clear(minIndex, staleIndex, storageData);\r\n            // Reset the array info with stale index as the new minIndex\r\n            _setBounds(storageData, staleIndex, length);\r\n        }\r\n        return (loadedData);\r\n    }\r\n\r\n    /// @notice Searches for the data stored at the largest blocknumber index less than a provided parameter.\r\n    ///         Allows specification of a expiration stamp and returns the greatest examined index which is\r\n    ///         found to be older than that stamp.\r\n    /// @param data The stored data\r\n    /// @param blocknumber the blocknumber we want to load the historical data for.\r\n    /// @param staleBlock The oldest block that we care about the data stored for, all previous data can be deleted\r\n    /// @param startingMinIndex The smallest filled index in the array\r\n    /// @param length the length of the array\r\n    /// @return Returns the largest stale data index seen or 0 for no seen stale data and the stored data\r\n    function _find(\r\n        uint256[] storage data,\r\n        uint256 blocknumber,\r\n        uint256 staleBlock,\r\n        uint256 startingMinIndex,\r\n        uint256 length\r\n    ) private view returns (uint256, uint256) {\r\n        // We explicitly revert on the reading of memory which is uninitialized\r\n        require(length != 0, \"uninitialized\");\r\n        // Do some correctness checks\r\n        require(staleBlock <= blocknumber);\r\n        require(startingMinIndex < length);\r\n        // Load the bounds of our binary search\r\n        uint256 maxIndex = length - 1;\r\n        uint256 minIndex = startingMinIndex;\r\n        uint256 staleIndex = 0;\r\n\r\n        // We run a binary search on the block number fields in the array between\r\n        // the minIndex and maxIndex. If we find indexes with blocknumber < staleBlock\r\n        // we set staleIndex to them and return that data for an optional clearing step\r\n        // in the calling function.\r\n        while (minIndex != maxIndex) {\r\n            // We use the ceil instead of the floor because this guarantees that\r\n            // we pick the highest blocknumber less than or equal the requested one\r\n            uint256 mid = (minIndex + maxIndex + 1) / 2;\r\n            // Load and unpack the data in the midpoint index\r\n            (uint256 pastBlock, uint256 loadedData) = _loadAndUnpack(data, mid);\r\n\r\n            //  If we've found the exact block we are looking for\r\n            if (pastBlock == blocknumber) {\r\n                // Then we just return the data\r\n                return (staleIndex, loadedData);\r\n\r\n                // Otherwise if the loaded block is smaller than the block number\r\n            } else if (pastBlock < blocknumber) {\r\n                // Then we first check if this is possibly a stale block\r\n                if (pastBlock < staleBlock) {\r\n                    // If it is we mark it for clearing\r\n                    staleIndex = mid;\r\n                }\r\n                // We then repeat the search logic on the indices greater than the midpoint\r\n                minIndex = mid;\r\n\r\n                // In this case the pastBlock > blocknumber\r\n            } else {\r\n                // We then repeat the search on the indices below the midpoint\r\n                maxIndex = mid - 1;\r\n            }\r\n        }\r\n\r\n        // We load at the final index of the search\r\n        (uint256 _pastBlock, uint256 _loadedData) =\r\n            _loadAndUnpack(data, minIndex);\r\n        // This will only be hit if a user has misconfigured the stale index and then\r\n        // tried to load father into the past than has been preserved\r\n        require(_pastBlock <= blocknumber, \"Search Failure\");\r\n        return (staleIndex, _loadedData);\r\n    }\r\n\r\n    /// @notice Clears storage between two bounds in array\r\n    /// @param oldMin The first index to set to zero\r\n    /// @param newMin The new minimum filled index, ie clears to index < newMin\r\n    /// @param data The storage array pointer\r\n    function _clear(\r\n        uint256 oldMin,\r\n        uint256 newMin,\r\n        uint256[] storage data\r\n    ) private {\r\n        // Correctness checks on this call\r\n        require(oldMin <= newMin);\r\n        // This function is private and trusted and should be only called by functions which ensure\r\n        // that oldMin < newMin < length\r\n        assembly {\r\n            // The layout of arrays in solidity is [length][data]....[data] so this pointer is the\r\n            // slot to write to data\r\n            let dataLocation := add(data.slot, 1)\r\n            // Loop through each index which is below new min and clear the storage\r\n            // Note - Uses strict min so if given an input like oldMin = 5 newMin = 5 will be a no op\r\n            for {\r\n                let i := oldMin\r\n            } lt(i, newMin) {\r\n                i := add(i, 1)\r\n            } {\r\n                // store at the starting data pointer + i 256 bits of zero\r\n                sstore(add(dataLocation, i), 0)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Loads and unpacks the block number index and stored data from a data array\r\n    /// @param data the storage array\r\n    /// @param i the index to load and unpack\r\n    /// @return (block number, stored data)\r\n    function _loadAndUnpack(uint256[] storage data, uint256 i)\r\n        private\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        // This function is trusted and should only be called after checking data lengths\r\n        // we use assembly for the sload to avoid reloading length.\r\n        uint256 loaded;\r\n        assembly {\r\n            loaded := sload(add(add(data.slot, 1), i))\r\n        }\r\n        // Unpack the packed 64 bit block number and 192 bit data field\r\n        return (\r\n            loaded >> 192,\r\n            loaded &\r\n                0x0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff\r\n        );\r\n    }\r\n\r\n    /// @notice This function sets our non standard bounds data field where a normal array\r\n    ///         would have length\r\n    /// @param data the pointer to the storage array\r\n    /// @param minIndex The minimum non stale index\r\n    /// @param length The length of the storage array\r\n    function _setBounds(\r\n        uint256[] storage data,\r\n        uint256 minIndex,\r\n        uint256 length\r\n    ) private {\r\n        // Correctness check\r\n        require(minIndex < length);\r\n\r\n        assembly {\r\n            // Ensure data cleanliness\r\n            let clearedLength := and(\r\n                length,\r\n                0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff\r\n            )\r\n            // We move the min index into the top 128 bits by shifting it left by 128 bits\r\n            let minInd := shl(128, minIndex)\r\n            // We pack the data using binary or\r\n            let packed := or(minInd, clearedLength)\r\n            // We store in the packed data in the length field of this storage array\r\n            sstore(data.slot, packed)\r\n        }\r\n    }\r\n\r\n    /// @notice This function loads and unpacks our packed min index and length for our custom storage array\r\n    /// @param data The pointer to the storage location\r\n    /// @return minInd the first filled index in the array\r\n    /// @return length the length of the array\r\n    function _loadBounds(uint256[] storage data)\r\n        private\r\n        view\r\n        returns (uint256 minInd, uint256 length)\r\n    {\r\n        // Use assembly to manually load the length storage field\r\n        uint256 packedData;\r\n        assembly {\r\n            packedData := sload(data.slot)\r\n        }\r\n        // We use a shift right to clear out the low order bits of the data field\r\n        minInd = packedData >> 128;\r\n        // We use a binary and to extract only the bottom 128 bits\r\n        length =\r\n            packedData &\r\n            0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\r\n    }\r\n}\r\n// Copy of `Storage` with modified scope to match the VestingVault requirements\r\n// This library allows for secure storage pointers across proxy implementations\r\n// It will return storage pointers based on a hashed name and type string.\r\nlibrary VestingVaultStorage {\r\n    // This library follows a pattern which if solidity had higher level\r\n    // type or macro support would condense quite a bit.\r\n\r\n    // Each basic type which does not support storage locations is encoded as\r\n    // a struct of the same name capitalized and has functions 'load' and 'set'\r\n    // which load the data and set the data respectively.\r\n\r\n    // All types will have a function of the form 'typename'Ptr('name') -> storage ptr\r\n    // which will return a storage version of the type with slot which is the hash of\r\n    // the variable name and type string. This pointer allows easy state management between\r\n    // upgrades and overrides the default solidity storage slot system.\r\n\r\n    // A struct which represents 1 packed storage location (Grant)\r\n    struct Grant {\r\n        uint128 allocation;\r\n        uint128 withdrawn;\r\n        uint128 created;\r\n        uint128 expiration;\r\n        uint128 cliff;\r\n        uint128 latestVotingPower;\r\n        address delegatee;\r\n        uint256[2] range;\r\n    }\r\n\r\n    /// @notice Returns the storage pointer for a named mapping of address to uint256[]\r\n    /// @param name the variable name for the pointer\r\n    /// @return data the mapping pointer\r\n    function mappingAddressToGrantPtr(string memory name)\r\n        internal\r\n        pure\r\n        returns (mapping(address => Grant) storage data)\r\n    {\r\n        bytes32 typehash = keccak256(\"mapping(address => Grant)\");\r\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\r\n        assembly {\r\n            data.slot := offset\r\n        }\r\n    }\r\n}\r\ninterface IVotingVault {\r\n    /// @notice Attempts to load the voting power of a user\r\n    /// @param user The address we want to load the voting power of\r\n    /// @param blockNumber the block number we want the user's voting power at\r\n    /// @param extraData Abi encoded optional extra data used by some vaults, such as merkle proofs\r\n    /// @return the number of votes\r\n    function queryVotePower(\r\n        address user,\r\n        uint256 blockNumber,\r\n        bytes calldata extraData\r\n    ) external returns (uint256);\r\n}\r\nabstract contract AbstractVestingVault is IVotingVault {\r\n    // Bring our libraries into scope\r\n    using History for *;\r\n    using VestingVaultStorage for *;\r\n    using Storage for *;\r\n\r\n    // NOTE: There is no emergency withdrawal, any funds not sent via deposit() are\r\n    // unrecoverable by this version of the VestingVault\r\n\r\n    // This contract has a privileged grant manager who can add grants or remove grants\r\n    // It will not transfer in on each grant but rather check for solvency via state variables.\r\n\r\n    // Immutables are in bytecode so don't need special storage treatment\r\n    IERC20 public immutable token;\r\n\r\n    // A constant which is how far back stale blocks are\r\n    uint256 public immutable staleBlockLag;\r\n\r\n    event VoteChange(address indexed to, address indexed from, int256 amount);\r\n\r\n    /// @notice Constructs the contract.\r\n    /// @param _token The erc20 token to grant.\r\n    /// @param _stale Stale block used for voting power calculations.\r\n    constructor(IERC20 _token, uint256 _stale) {\r\n        token = _token;\r\n        staleBlockLag = _stale;\r\n    }\r\n\r\n    /// @notice initialization function to set initial variables.\r\n    /// @dev Can only be called once after deployment.\r\n    /// @param manager_ The vault manager can add and remove grants.\r\n    /// @param timelock_ The timelock address can change the unvested multiplier.\r\n    function initialize(address manager_, address timelock_) public {\r\n        require(Storage.uint256Ptr(\"initialized\").data == 0, \"initialized\");\r\n        Storage.set(Storage.uint256Ptr(\"initialized\"), 1);\r\n        Storage.set(Storage.addressPtr(\"manager\"), manager_);\r\n        Storage.set(Storage.addressPtr(\"timelock\"), timelock_);\r\n        Storage.set(Storage.uint256Ptr(\"unvestedMultiplier\"), 100);\r\n    }\r\n\r\n    // deposits mapping(address => Grant)\r\n    /// @notice A single function endpoint for loading grant storage\r\n    /// @dev Only one Grant is allowed per address. Grants SHOULD NOT\r\n    /// be modified.\r\n    /// @return returns a storage mapping which can be used to look up grant data\r\n    function _grants()\r\n        internal\r\n        pure\r\n        returns (mapping(address => VestingVaultStorage.Grant) storage)\r\n    {\r\n        // This call returns a storage mapping with a unique non overwrite-able storage location\r\n        // which can be persisted through upgrades, even if they change storage layout\r\n        return (VestingVaultStorage.mappingAddressToGrantPtr(\"grants\"));\r\n    }\r\n\r\n    /// @notice A single function endpoint for loading the starting\r\n    /// point of the range for each accepted grant\r\n    /// @dev This is modified any time a grant is accepted\r\n    /// @return returns the starting point uint\r\n    function _loadBound() internal pure returns (Storage.Uint256 memory) {\r\n        // This call returns a storage mapping with a unique non overwrite-able storage location\r\n        // which can be persisted through upgrades, even if they change storage layout\r\n        return Storage.uint256Ptr(\"bound\");\r\n    }\r\n\r\n    /// @notice A function to access the storage of the unassigned token value\r\n    /// @dev The unassigned tokens are not part of any grant and ca be used\r\n    /// for a future grant or withdrawn by the manager.\r\n    /// @return A struct containing the unassigned uint.\r\n    function _unassigned() internal pure returns (Storage.Uint256 storage) {\r\n        return Storage.uint256Ptr(\"unassigned\");\r\n    }\r\n\r\n    /// @notice A function to access the storage of the manager address.\r\n    /// @dev The manager can access all functions with the onlyManager modifier.\r\n    /// @return A struct containing the manager address.\r\n    function _manager() internal pure returns (Storage.Address memory) {\r\n        return Storage.addressPtr(\"manager\");\r\n    }\r\n\r\n    /// @notice A function to access the storage of the timelock address\r\n    /// @dev The timelock can access all functions with the onlyTimelock modifier.\r\n    /// @return A struct containing the timelock address.\r\n    function _timelock() internal pure returns (Storage.Address memory) {\r\n        return Storage.addressPtr(\"timelock\");\r\n    }\r\n\r\n    /// @notice A function to access the storage of the unvestedMultiplier value\r\n    /// @dev The unvested multiplier is a number that represents the voting power of each\r\n    /// unvested token as a percentage of a vested token. For example if\r\n    /// unvested tokens have 50% voting power compared to vested ones, this value would be 50.\r\n    /// This can be changed by governance in the future.\r\n    /// @return A struct containing the unvestedMultiplier uint.\r\n    function _unvestedMultiplier()\r\n        internal\r\n        pure\r\n        returns (Storage.Uint256 memory)\r\n    {\r\n        return Storage.uint256Ptr(\"unvestedMultiplier\");\r\n    }\r\n\r\n    modifier onlyManager() {\r\n        require(msg.sender == _manager().data, \"!manager\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyTimelock() {\r\n        require(msg.sender == _timelock().data, \"!timelock\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Getter for the grants mapping\r\n    /// @param _who The owner of the grant to query\r\n    /// @return Grant of the provided address\r\n    function getGrant(address _who)\r\n        external\r\n        view\r\n        returns (VestingVaultStorage.Grant memory)\r\n    {\r\n        return _grants()[_who];\r\n    }\r\n\r\n    /// @notice Accepts a grant\r\n    /// @dev Sends token from the contract to the sender and back to the contract\r\n    /// while assigning a numerical range to the unwithdrawn granted tokens.\r\n    function acceptGrant() public {\r\n        // load the grant\r\n        VestingVaultStorage.Grant storage grant = _grants()[msg.sender];\r\n        uint256 availableTokens = grant.allocation - grant.withdrawn;\r\n\r\n        // check that grant has unwithdrawn tokens\r\n        require(availableTokens > 0, \"no grant available\");\r\n\r\n        // transfer the token to the user\r\n        token.transfer(msg.sender, availableTokens);\r\n        // transfer from the user back to the contract\r\n        token.transferFrom(msg.sender, address(this), availableTokens);\r\n\r\n        uint256 bound = _loadBound().data;\r\n        grant.range = [bound, bound + availableTokens];\r\n        Storage.set(Storage.uint256Ptr(\"bound\"), bound + availableTokens);\r\n    }\r\n\r\n    /// @notice Adds a new grant.\r\n    /// @dev Manager can set who the voting power will be delegated to initially.\r\n    /// This potentially avoids the need for a delegation transaction by the grant recipient.\r\n    /// @param _who The Grant recipient.\r\n    /// @param _amount The total grant value.\r\n    /// @param _startTime Optionally set a non standard start time. If set to zero then the start time\r\n    ///                   will be made the block this is executed in.\r\n    /// @param _expiration timestamp when the grant ends (all tokens count as unlocked).\r\n    /// @param _cliff Timestamp when the cliff ends. No tokens are unlocked until this\r\n    /// timestamp is reached.\r\n    /// @param _delegatee Optional param. The address to delegate the voting power\r\n    /// associated with this grant to\r\n    function addGrantAndDelegate(\r\n        address _who,\r\n        uint128 _amount,\r\n        uint128 _startTime,\r\n        uint128 _expiration,\r\n        uint128 _cliff,\r\n        address _delegatee\r\n    ) public onlyManager {\r\n        // Consistency check\r\n        require(\r\n            _cliff <= _expiration && _startTime <= _expiration,\r\n            \"Invalid configuration\"\r\n        );\r\n        // If no custom start time is needed we use this block.\r\n        if (_startTime == 0) {\r\n            _startTime = uint128(block.number);\r\n        }\r\n\r\n        Storage.Uint256 storage unassigned = _unassigned();\r\n        Storage.Uint256 memory unvestedMultiplier = _unvestedMultiplier();\r\n\r\n        require(unassigned.data >= _amount, \"Insufficient balance\");\r\n        // load the grant.\r\n        VestingVaultStorage.Grant storage grant = _grants()[_who];\r\n\r\n        // If this address already has a grant, a different address must be provided\r\n        // topping up or editing active grants is not supported.\r\n        require(grant.allocation == 0, \"Has Grant\");\r\n\r\n        // load the delegate. Defaults to the grant owner\r\n        _delegatee = _delegatee == address(0) ? _who : _delegatee;\r\n\r\n        // calculate the voting power. Assumes all voting power is initially locked.\r\n        // Come back to this assumption.\r\n        uint128 newVotingPower =\r\n            (_amount * uint128(unvestedMultiplier.data)) / 100;\r\n\r\n        // set the new grant\r\n        _grants()[_who] = VestingVaultStorage.Grant(\r\n            _amount,\r\n            0,\r\n            _startTime,\r\n            _expiration,\r\n            _cliff,\r\n            newVotingPower,\r\n            _delegatee,\r\n            [uint256(0), uint256(0)]\r\n        );\r\n\r\n        // update the amount of unassigned tokens\r\n        unassigned.data -= _amount;\r\n\r\n        // update the delegatee's voting power\r\n        History.HistoricalBalances memory votingPower = _votingPower();\r\n        uint256 delegateeVotes = votingPower.loadTop(grant.delegatee);\r\n        votingPower.push(grant.delegatee, delegateeVotes + newVotingPower);\r\n\r\n        emit VoteChange(grant.delegatee, _who, int256(uint256(newVotingPower)));\r\n    }\r\n\r\n    /// @notice Removes a grant.\r\n    /// @dev The manager has the power to remove a grant at any time. Any withdrawable tokens will be\r\n    /// sent to the grant owner.\r\n    /// @param _who The Grant owner.\r\n    function removeGrant(address _who) public virtual onlyManager {\r\n        // load the grant\r\n        VestingVaultStorage.Grant storage grant = _grants()[_who];\r\n        // get the amount of withdrawable tokens\r\n        uint256 withdrawable = _getWithdrawableAmount(grant);\r\n        // it is simpler to just transfer withdrawable tokens instead of modifying the struct storage\r\n        // to allow withdrawal through claim()\r\n        token.transfer(_who, withdrawable);\r\n\r\n        Storage.Uint256 storage unassigned = _unassigned();\r\n        uint256 locked = grant.allocation - (grant.withdrawn + withdrawable);\r\n\r\n        // return the unused tokens so they can be used for a different grant\r\n        unassigned.data += locked;\r\n\r\n        // update the delegatee's voting power\r\n        History.HistoricalBalances memory votingPower = _votingPower();\r\n        uint256 delegateeVotes = votingPower.loadTop(grant.delegatee);\r\n        votingPower.push(\r\n            grant.delegatee,\r\n            delegateeVotes - grant.latestVotingPower\r\n        );\r\n\r\n        // Emit the vote change event\r\n        emit VoteChange(\r\n            grant.delegatee,\r\n            _who,\r\n            -1 * int256(uint256(grant.latestVotingPower))\r\n        );\r\n\r\n        // delete the grant\r\n        delete _grants()[_who];\r\n    }\r\n\r\n    /// @notice Claim all withdrawable value from a grant.\r\n    /// @dev claiming value resets the voting power, This could either increase or reduce the\r\n    /// total voting power associated with the caller's grant.\r\n    function claim() public virtual {\r\n        // load the grant\r\n        VestingVaultStorage.Grant storage grant = _grants()[msg.sender];\r\n        // get the withdrawable amount\r\n        uint256 withdrawable = _getWithdrawableAmount(grant);\r\n\r\n        // transfer the available amount\r\n        token.transfer(msg.sender, withdrawable);\r\n        grant.withdrawn += uint128(withdrawable);\r\n\r\n        // only move range bound if grant was accepted\r\n        if (grant.range[1] > 0) {\r\n            grant.range[1] -= withdrawable;\r\n        }\r\n\r\n        // update the user's voting power\r\n        _syncVotingPower(msg.sender, grant);\r\n    }\r\n\r\n    /// @notice Changes the caller's token grant voting power delegation.\r\n    /// @dev The total voting power is not guaranteed to go up because\r\n    /// the unvested token multiplier can be updated at any time.\r\n    /// @param _to the address to delegate to\r\n    function delegate(address _to) public {\r\n        VestingVaultStorage.Grant storage grant = _grants()[msg.sender];\r\n        // If the delegation has already happened we don't want the tx to send\r\n        require(_to != grant.delegatee, \"Already delegated\");\r\n        History.HistoricalBalances memory votingPower = _votingPower();\r\n\r\n        uint256 oldDelegateeVotes = votingPower.loadTop(grant.delegatee);\r\n        uint256 newVotingPower = _currentVotingPower(grant);\r\n\r\n        // Remove old delegatee's voting power and emit event\r\n        votingPower.push(\r\n            grant.delegatee,\r\n            oldDelegateeVotes - grant.latestVotingPower\r\n        );\r\n        emit VoteChange(\r\n            grant.delegatee,\r\n            msg.sender,\r\n            -1 * int256(uint256(grant.latestVotingPower))\r\n        );\r\n\r\n        // Note - It is important that this is loaded here and not before the previous state change because if\r\n        // _to == grant.delegatee and re-delegation was allowed we could be working with out of date state.\r\n        uint256 newDelegateeVotes = votingPower.loadTop(_to);\r\n\r\n        // add voting power to the target delegatee and emit event\r\n        emit VoteChange(_to, msg.sender, int256(newVotingPower));\r\n        votingPower.push(_to, newDelegateeVotes + newVotingPower);\r\n\r\n        // update grant info\r\n        grant.latestVotingPower = uint128(newVotingPower);\r\n        grant.delegatee = _to;\r\n    }\r\n\r\n    /// @notice Manager-only token deposit function.\r\n    /// @dev Deposited tokens are added to `_unassigned` and can be used to create grants.\r\n    /// WARNING: This is the only way to deposit tokens into the contract. Any tokens sent\r\n    /// via other means are not recoverable by this contract.\r\n    /// @param _amount The amount of tokens to deposit.\r\n    function deposit(uint256 _amount) public onlyManager {\r\n        Storage.Uint256 storage unassigned = _unassigned();\r\n        // update unassigned value\r\n        unassigned.data += _amount;\r\n        token.transferFrom(msg.sender, address(this), _amount);\r\n    }\r\n\r\n    /// @notice Manager-only token withdrawal function.\r\n    /// @dev The manager can withdraw tokens that are not being used by a grant.\r\n    /// This function cannot be used to recover tokens that were sent to this contract\r\n    /// by any means other than `deposit()`\r\n    /// @param _amount the amount to withdraw\r\n    /// @param _recipient the address to withdraw to\r\n    function withdraw(uint256 _amount, address _recipient)\r\n        public\r\n        virtual\r\n        onlyManager\r\n    {\r\n        Storage.Uint256 storage unassigned = _unassigned();\r\n        require(unassigned.data >= _amount, \"Insufficient balance\");\r\n        // update unassigned value\r\n        unassigned.data -= _amount;\r\n        token.transfer(_recipient, _amount);\r\n    }\r\n\r\n    /// @notice Update a delegatee's voting power.\r\n    /// @dev Voting power is only updated for this block onward.\r\n    /// see `History` for more on how voting power is tracked and queried.\r\n    /// Anybody can update a grant's voting power.\r\n    /// @param _who the address who's voting power this function updates\r\n    function updateVotingPower(address _who) public {\r\n        VestingVaultStorage.Grant storage grant = _grants()[_who];\r\n        _syncVotingPower(_who, grant);\r\n    }\r\n\r\n    /// @notice Helper to update a delegatee's voting power.\r\n    /// @param _who the address who's voting power we need to sync\r\n    /// @param _grant the storage pointer to the grant of that user\r\n    function _syncVotingPower(\r\n        address _who,\r\n        VestingVaultStorage.Grant storage _grant\r\n    ) internal {\r\n        History.HistoricalBalances memory votingPower = _votingPower();\r\n\r\n        uint256 delegateeVotes = votingPower.loadTop(_grant.delegatee);\r\n\r\n        uint256 newVotingPower = _currentVotingPower(_grant);\r\n        // get the change in voting power. Negative if the voting power is reduced\r\n        int256 change =\r\n            int256(newVotingPower) - int256(uint256(_grant.latestVotingPower));\r\n        // do nothing if there is no change\r\n        if (change == 0) return;\r\n        if (change > 0) {\r\n            votingPower.push(\r\n                _grant.delegatee,\r\n                delegateeVotes + uint256(change)\r\n            );\r\n        } else {\r\n            // if the change is negative, we multiply by -1 to avoid underflow when casting\r\n            votingPower.push(\r\n                _grant.delegatee,\r\n                delegateeVotes - uint256(change * -1)\r\n            );\r\n        }\r\n        emit VoteChange(_grant.delegatee, _who, change);\r\n        _grant.latestVotingPower = uint128(newVotingPower);\r\n    }\r\n\r\n    /// @notice Attempts to load the voting power of a user\r\n    /// @param user The address we want to load the voting power of\r\n    /// @param blockNumber the block number we want the user's voting power at\r\n    // @param calldata the extra calldata is unused in this contract\r\n    /// @return the number of votes\r\n    function queryVotePower(\r\n        address user,\r\n        uint256 blockNumber,\r\n        bytes calldata\r\n    ) external override returns (uint256) {\r\n        // Get our reference to historical data\r\n        History.HistoricalBalances memory votingPower = _votingPower();\r\n        // Find the historical data and clear everything more than 'staleBlockLag' into the past\r\n        return\r\n            votingPower.findAndClear(\r\n                user,\r\n                blockNumber,\r\n                block.number - staleBlockLag\r\n            );\r\n    }\r\n\r\n    /// @notice Loads the voting power of a user without changing state\r\n    /// @param user The address we want to load the voting power of\r\n    /// @param blockNumber the block number we want the user's voting power at\r\n    /// @return the number of votes\r\n    function queryVotePowerView(address user, uint256 blockNumber)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Get our reference to historical data\r\n        History.HistoricalBalances memory votingPower = _votingPower();\r\n        // Find the historical data\r\n        return votingPower.find(user, blockNumber);\r\n    }\r\n\r\n    /// @notice Calculates how much a grantee can withdraw\r\n    /// @param _grant the memory location of the loaded grant\r\n    /// @return the amount which can be withdrawn\r\n    function _getWithdrawableAmount(VestingVaultStorage.Grant memory _grant)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (block.number < _grant.cliff || block.number < _grant.created) {\r\n            return 0;\r\n        }\r\n        if (block.number >= _grant.expiration) {\r\n            return (_grant.allocation - _grant.withdrawn);\r\n        }\r\n        uint256 unlocked =\r\n            (_grant.allocation * (block.number - _grant.created)) /\r\n                (_grant.expiration - _grant.created);\r\n        return (unlocked - _grant.withdrawn);\r\n    }\r\n\r\n    /// @notice Returns the historical voting power tracker.\r\n    /// @return A struct which can push to and find items in block indexed storage.\r\n    function _votingPower()\r\n        internal\r\n        pure\r\n        returns (History.HistoricalBalances memory)\r\n    {\r\n        // This call returns a storage mapping with a unique non overwrite-able storage location\r\n        // which can be persisted through upgrades, even if they change storage layout.\r\n        return (History.load(\"votingPower\"));\r\n    }\r\n\r\n    /// @notice Helper that returns the current voting power of a grant\r\n    /// @dev This is not always the recorded voting power since it uses the latest\r\n    /// _unvestedMultiplier.\r\n    /// @param _grant The grant to check for voting power.\r\n    /// @return The current voting power of the grant.\r\n    function _currentVotingPower(VestingVaultStorage.Grant memory _grant)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 withdrawable = _getWithdrawableAmount(_grant);\r\n        uint256 locked = _grant.allocation - (withdrawable + _grant.withdrawn);\r\n        return (withdrawable + (locked * _unvestedMultiplier().data) / 100);\r\n    }\r\n\r\n    /// @notice timelock-only unvestedMultiplier update function.\r\n    /// @dev Allows the timelock to update the unvestedMultiplier.\r\n    /// @param _multiplier The new multiplier.\r\n    function changeUnvestedMultiplier(uint256 _multiplier) public onlyTimelock {\r\n        require(_multiplier <= 100, \"Above 100%\");\r\n        Storage.set(Storage.uint256Ptr(\"unvestedMultiplier\"), _multiplier);\r\n    }\r\n\r\n    /// @notice timelock-only timelock update function.\r\n    /// @dev Allows the timelock to update the timelock address.\r\n    /// @param timelock_ The new timelock.\r\n    function setTimelock(address timelock_) public onlyTimelock {\r\n        Storage.set(Storage.addressPtr(\"timelock\"), timelock_);\r\n    }\r\n\r\n    /// @notice timelock-only manager update function.\r\n    /// @dev Allows the timelock to update the manager address.\r\n    /// @param manager_ The new manager.\r\n    function setManager(address manager_) public onlyTimelock {\r\n        Storage.set(Storage.addressPtr(\"manager\"), manager_);\r\n    }\r\n\r\n    /// @notice A function to access the storage of the timelock address\r\n    /// @dev The timelock can access all functions with the onlyTimelock modifier.\r\n    /// @return The timelock address.\r\n    function timelock() public pure returns (address) {\r\n        return _timelock().data;\r\n    }\r\n\r\n    /// @notice A function to access the storage of the unvested token vote power multiplier.\r\n    /// @return The unvested token multiplier\r\n    function unvestedMultiplier() external pure returns (uint256) {\r\n        return _unvestedMultiplier().data;\r\n    }\r\n\r\n    /// @notice A function to access the storage of the manager address.\r\n    /// @dev The manager can access all functions with the olyManager modifier.\r\n    /// @return The manager address.\r\n    function manager() public pure returns (address) {\r\n        return _manager().data;\r\n    }\r\n}\r\n\r\n// Deployable version of the abstract contract\r\ncontract VestingVault is AbstractVestingVault {\r\n    /// @notice Constructs the contract.\r\n    /// @param _token The erc20 token to grant.\r\n    /// @param _stale Stale block used for voting power calculations.\r\n    constructor(IERC20 _token, uint256 _stale)\r\n        AbstractVestingVault(_token, _stale)\r\n    {}\r\n}\r\n// You can come in but you can never leave\r\ncontract FrozenVestingVault is AbstractVestingVault {\r\n    /// @notice Constructs the contract by passing through the the super\r\n    /// @param _token The erc20 token to grant.\r\n    /// @param _stale Stale block used for voting power calculations.\r\n    constructor(IERC20 _token, uint256 _stale)\r\n        AbstractVestingVault(_token, _stale)\r\n    {}\r\n\r\n    // These functions are the only way for tokens to leave the contract\r\n    // Therefore they now revert\r\n\r\n    /// @notice Does nothing, always reverts\r\n    function removeGrant(address) public pure override {\r\n        revert(\"Frozen\");\r\n    }\r\n\r\n    /// @notice Does nothing, always reverts\r\n    function claim() public pure override {\r\n        revert(\"Frozen\");\r\n    }\r\n\r\n    /// @notice Does nothing, always reverts\r\n    function withdraw(uint256, address) public pure override {\r\n        revert(\"Frozen\");\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stale\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"VoteChange\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptGrant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_startTime\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_expiration\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_cliff\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_delegatee\",\"type\":\"address\"}],\"name\":\"addGrantAndDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_multiplier\",\"type\":\"uint256\"}],\"name\":\"changeUnvestedMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"getGrant\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"allocation\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"withdrawn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"created\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"expiration\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"cliff\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"latestVotingPower\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"range\",\"type\":\"uint256[2]\"}],\"internalType\":\"struct VestingVaultStorage.Grant\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"timelock_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"queryVotePower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"queryVotePowerView\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"removeGrant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager_\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"timelock_\",\"type\":\"address\"}],\"name\":\"setTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staleBlockLag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unvestedMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"updateVotingPower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "VestingVault", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "0000000000000000000000005c6d51ecba4d8e4f20373e3ce96a62342b125d6d0000000000000000000000000000000000000000000000000000000000030d40", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b62bf3304e07600296b9067f7df3043877c7c96af8ceaedf488101276e5d1378"}]}