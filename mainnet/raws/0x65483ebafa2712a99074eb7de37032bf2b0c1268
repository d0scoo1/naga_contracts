{"status": "1", "message": "OK", "result": [{"SourceCode": "//SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.7;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\ninterface IERC721Metadata {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IERC721Enumerable {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns(bytes4);\r\n}\r\n\r\ninterface IERC721Mintable is IERC721, IERC721Enumerable, IERC721Metadata {\r\n    function autoMint(string memory tokenURI, address to) external returns (uint256);\r\n    function mintWithTokenURI(address to, uint256 tokenId, string memory tokenURI) external returns (bool);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n}\r\n\r\ncontract BananaTaskForceApeBlindBox {\r\n    using SafeMath for uint256;\r\n\r\n    address public owner;\r\n    address public nftContractAddress;\r\n    address payable public wallet;\r\n\r\n    bool public enabled;\r\n    uint256 public reserved;\r\n    uint256 public reserveLimit;\r\n    bool public onlyWhitelist;\r\n    uint256 public whitelistLimit;\r\n    uint256 public buyLimit;\r\n\r\n    IERC721Mintable private NFT_MINTABLE;\r\n\r\n    uint256 public totalCreated;\r\n    mapping(uint256 => uint256) private boxIndexes;\r\n    mapping(address => uint256[]) private ownerBoxes;\r\n    mapping(address => bool) public whitelist;\r\n\r\n    Blindbox[] private soldBoxes;\r\n\r\n    uint private nonce = 0;\r\n\r\n    uint256 cost;\r\n    uint256 total;\r\n    uint256 remaining;\r\n    mapping (uint256 => bool) issued;\r\n\r\n    struct Blindbox {\r\n        uint256 id;\r\n        address purchaser;\r\n        uint256 tokenID;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"can only be called by the contract owner\");\r\n        _;\r\n    }\r\n\r\n    modifier isEnabled() {\r\n        require(enabled, \"Contract is currently disabled\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        wallet = payable(0x1764041440eD4081Ae361EC9c2245Eb33F023F60);\r\n        onlyWhitelist = true;\r\n        whitelistLimit = 10;\r\n        buyLimit = 5;\r\n        reserveLimit = 500;\r\n\r\n        // Nft Contract\r\n        nftContractAddress = 0x510EBF6EaDd8acaE95c790212624ccA7CEcBBa73;\r\n        NFT_MINTABLE = IERC721Mintable(nftContractAddress);\r\n\r\n        cost = 99 * 10 ** 15;\r\n        total = 10000;\r\n        remaining = 10000;\r\n    }\r\n\r\n    function status() public view returns (bool canPurchase, uint256 boxCost, uint256 boxRemaining, uint256 hasPurchased, uint256 purchaseLimit) {\r\n        canPurchase = enabled && ((onlyWhitelist == false && ownerBoxes[msg.sender].length < buyLimit) || (whitelist[msg.sender] && ownerBoxes[msg.sender].length < whitelistLimit));\r\n        boxCost = cost;\r\n        boxRemaining = remaining;\r\n        hasPurchased = ownerBoxes[msg.sender].length;\r\n        purchaseLimit = whitelistLimit;\r\n    }\r\n\r\n    function purchaseBlindbox() public payable isEnabled {\r\n        require (remaining > 0, \"No more blindboxes available\");\r\n        require((onlyWhitelist == false && ownerBoxes[msg.sender].length < buyLimit) || (whitelist[msg.sender] && ownerBoxes[msg.sender].length < whitelistLimit), \"You are not on the whitelist\");\r\n        require (msg.value == cost, \"Incorrect BNB value.\");\r\n\r\n        wallet.transfer(cost);\r\n\r\n        mint(msg.sender);\r\n    }\r\n\r\n    function balanceOf(address who) public view returns (Blindbox[] memory) {\r\n        Blindbox[] memory boxes = new Blindbox[](ownerBoxes[who].length);\r\n\r\n        for (uint256 i = 0; i < ownerBoxes[who].length; i++) {\r\n            boxes[i] = soldBoxes[ownerBoxes[who][i]];\r\n        }\r\n\r\n        return boxes;\r\n    }\r\n\r\n\r\n    // Private methods\r\n\r\n   function mint(address who) private {\r\n        uint256 request = requestRandomWords();\r\n        soldBoxes.push(Blindbox(\r\n            request,\r\n            who,\r\n            0\r\n        ));\r\n\r\n        uint256 index = soldBoxes.length - 1;\r\n        boxIndexes[request] = index;\r\n        ownerBoxes[who].push(index);\r\n\r\n        uint256 roll = soldBoxes[boxIndexes[index]].id.mod(remaining).add(1);\r\n        uint256 current;\r\n        uint256 tokenId;\r\n        string memory uri;\r\n        for (uint256 i = 1; i <= total; i++) {\r\n            if (issued[i] == false) {\r\n                current += 1;\r\n            }\r\n            if (roll <= current) {\r\n                uri = string(abi.encodePacked(\"https://nftstorage.link/ipfs/bafybeic2hzyfaxo7gvezfnllsgxusjpb6rj6s77vru34yhbnghdjkxv3xe/\", uint2str(i), \".json\"));\r\n                issued[i] = true;\r\n                tokenId = i;\r\n                break;\r\n            }\r\n        }\r\n        remaining--;\r\n\r\n        require(NFT_MINTABLE.mintWithTokenURI(who, tokenId, uri), \"Minting error\");\r\n        soldBoxes[boxIndexes[index]].tokenID = tokenId;\r\n    }\r\n\r\n\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function requestRandomWords() private returns (uint256) {\r\n        nonce += 1;\r\n        return uint(keccak256(abi.encodePacked(nonce, msg.sender, blockhash(block.number - 1))));\r\n    }\r\n\r\n\r\n    // Admin Only\r\n\r\n    function setOwner(address who) external onlyOwner {\r\n        require(who != address(0), \"Cannot be zero address\");\r\n        owner = who;\r\n    }\r\n\r\n    function setWallet(address payable who) external onlyOwner {\r\n        require(who != address(0), \"Cannot be zero address\");\r\n        wallet = who;\r\n    }\r\n\r\n    function setPrice(uint256 price) external onlyOwner {\r\n        cost = price;\r\n    }\r\n\r\n    function setEnabled(bool canPurchase) external onlyOwner {\r\n        enabled = canPurchase;\r\n    }\r\n\r\n    function enableWhitelist(bool on) external onlyOwner {\r\n        onlyWhitelist = on;\r\n    }\r\n\r\n    function setWhitelist(address who, bool whitelisted) external onlyOwner {\r\n        whitelist[who] = whitelisted;\r\n    }\r\n\r\n    function setWhitelisted(address[] memory who, bool whitelisted) external onlyOwner {\r\n        for (uint256 i = 0; i < who.length; i++) {\r\n            whitelist[who[i]] = whitelisted;\r\n        }\r\n    }\r\n\r\n    function setBuyLimits(uint256 white, uint256 normal) external onlyOwner {\r\n        whitelistLimit = white;\r\n        buyLimit = normal;\r\n    }\r\n\r\n    function reserveNfts(address who, uint256 amount) external onlyOwner {\r\n        require(reserved + amount <= reserveLimit, \"NFTS have already been reserved\");\r\n\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            mint(who);\r\n        }\r\n\r\n        reserved += amount;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"internalType\":\"struct BananaTaskForceApeBlindBox.Blindbox[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"on\",\"type\":\"bool\"}],\"name\":\"enableWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onlyWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purchaseBlindbox\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reserveNfts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserved\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"white\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"normal\",\"type\":\"uint256\"}],\"name\":\"setBuyLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"canPurchase\",\"type\":\"bool\"}],\"name\":\"setEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"who\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"name\":\"setWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canPurchase\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"boxCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boxRemaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hasPurchased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseLimit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCreated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BananaTaskForceApeBlindBox", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://620d209e2e309c6b987c67fdff84c3751edb1bf53747dd0c0785aea58dd0597a"}]}