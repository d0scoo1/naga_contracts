{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/BankNode/StakingPool/BNPLStakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {AccessControlEnumerableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\\\";\\nimport {ReentrancyGuardUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport {IMintableBurnableTokenUpgradeable} from \\\"../../ERC20/interfaces/IMintableBurnableTokenUpgradeable.sol\\\";\\nimport {IBankNodeManager} from \\\"../../Management/interfaces/IBankNodeManager.sol\\\";\\n\\nimport {IBNPLBankNode} from \\\"../interfaces/IBNPLBankNode.sol\\\";\\nimport {IBNPLNodeStakingPool} from \\\"../interfaces/IBNPLNodeStakingPool.sol\\\";\\n\\nimport {UserTokenLockup} from \\\"./UserTokenLockup.sol\\\";\\nimport {BNPLKYCStore} from \\\"../../Management/BNPLKYCStore.sol\\\";\\n\\nimport {BankNodeUtils} from \\\"../lib/BankNodeUtils.sol\\\";\\nimport {TransferHelper} from \\\"../../Utils/TransferHelper.sol\\\";\\nimport {PRBMathUD60x18} from \\\"../../Utils/Math/PRBMathUD60x18.sol\\\";\\n\\n/// @title BNPL StakingPool contract\\n///\\n/// @notice\\n/// - Features:\\n///   **Stake BNPL**\\n///   **Unstake BNPL**\\n///   **Lock BNPL**\\n///   **Unlock BNPL**\\n///   **Decommission a bank node**\\n///   **Donate BNPL**\\n///   **Redeem AAVE**\\n///   **Claim AAVE rewards**\\n///   **Cool down AAVE**\\n///\\n/// @author BNPL\\ncontract BNPLStakingPool is\\n    Initializable,\\n    ReentrancyGuardUpgradeable,\\n    AccessControlEnumerableUpgradeable,\\n    UserTokenLockup,\\n    IBNPLNodeStakingPool\\n{\\n    using PRBMathUD60x18 for uint256;\\n    /// @dev Emitted when user `user` is stakes `bnplStakeAmount` of BNPL tokens while receiving `poolTokensMinted` of pool tokens\\n    event Stake(address indexed user, uint256 bnplStakeAmount, uint256 poolTokensMinted);\\n\\n    /// @dev Emitted when user `user` is unstakes `unstakeAmount` of liquidity while receiving `bnplTokensReturned` of BNPL tokens\\n    event Unstake(address indexed user, uint256 bnplUnstakeAmount, uint256 poolTokensBurned);\\n\\n    /// @dev Emitted when user `user` donates `donationAmount` of base liquidity tokens to the pool\\n    event Donation(address indexed user, uint256 donationAmount);\\n\\n    /// @dev Emitted when user `user` bonds `bondAmount` of base liquidity tokens to the pool\\n    event Bond(address indexed user, uint256 bondAmount);\\n\\n    /// @dev Emitted when user `user` unbonds `unbondAmount` of base liquidity tokens to the pool\\n    event Unbond(address indexed user, uint256 unbondAmount);\\n\\n    /// @dev Emitted when user `recipient` donates `donationAmount` of base liquidity tokens to the pool\\n    event Slash(address indexed recipient, uint256 slashAmount);\\n\\n    uint32 public constant BNPL_STAKER_NEEDS_KYC = 1 << 3;\\n\\n    bytes32 public constant SLASHER_ROLE = keccak256(\\\"SLASHER_ROLE\\\");\\n    bytes32 public constant NODE_REWARDS_MANAGER_ROLE = keccak256(\\\"NODE_REWARDS_MANAGER_ROLE\\\");\\n\\n    /// @dev BNPL token contract\\n    IERC20 public BASE_LIQUIDITY_TOKEN;\\n\\n    /// @dev Pool BNPL token contract\\n    IMintableBurnableTokenUpgradeable public POOL_LIQUIDITY_TOKEN;\\n\\n    /// @dev BNPL bank node contract\\n    IBNPLBankNode public bankNode;\\n\\n    /// @dev BNPL bank node manager contract\\n    IBankNodeManager public bankNodeManager;\\n\\n    /// @notice Total assets value\\n    uint256 public override baseTokenBalance;\\n\\n    /// @notice Cumulative value of bonded tokens\\n    uint256 public override tokensBondedAllTime;\\n\\n    /// @notice Pool BNPL token effective supply\\n    uint256 public override poolTokenEffectiveSupply;\\n\\n    /// @notice Pool BNPL token balance\\n    uint256 public override virtualPoolTokensCount;\\n\\n    /// @notice Cumulative value of donated tokens\\n    uint256 public totalDonatedAllTime;\\n\\n    /// @notice Cumulative value of shashed tokens\\n    uint256 public totalSlashedAllTime;\\n\\n    /// @notice The BNPL KYC store contract\\n    BNPLKYCStore public bnplKYCStore;\\n\\n    /// @notice The corresponding id in the BNPL KYC store\\n    uint32 public kycDomainId;\\n\\n    /// @dev StakingPool contract is created and initialized by the BankNodeManager contract\\n    ///\\n    /// - This contract is called through the proxy.\\n    ///\\n    /// @param bnplToken BNPL token address\\n    /// @param poolBNPLToken pool BNPL token address\\n    /// @param bankNodeContract BankNode contract address associated with stakingPool\\n    /// @param bankNodeManagerContract BankNodeManager contract address\\n    /// @param tokenBonder The address of the BankNode creator\\n    /// @param tokensToBond The amount of BNPL bound by the BankNode creator (initial liquidity amount)\\n    /// @param bnplKYCStore_ KYC store contract address\\n    /// @param kycDomainId_ KYC store domain id\\n    function initialize(\\n        address bnplToken,\\n        address poolBNPLToken,\\n        address bankNodeContract,\\n        address bankNodeManagerContract,\\n        address tokenBonder,\\n        uint256 tokensToBond,\\n        BNPLKYCStore bnplKYCStore_,\\n        uint32 kycDomainId_\\n    ) external override initializer nonReentrant {\\n        require(bnplToken != address(0), \\\"bnplToken cannot be 0\\\");\\n        require(poolBNPLToken != address(0), \\\"poolBNPLToken cannot be 0\\\");\\n        require(bankNodeContract != address(0), \\\"slasherAdmin cannot be 0\\\");\\n        require(tokenBonder != address(0), \\\"tokenBonder cannot be 0\\\");\\n        require(tokensToBond > 0, \\\"tokensToBond cannot be 0\\\");\\n\\n        __ReentrancyGuard_init_unchained();\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __AccessControl_init_unchained();\\n        __AccessControlEnumerable_init_unchained();\\n\\n        BASE_LIQUIDITY_TOKEN = IERC20(bnplToken);\\n        POOL_LIQUIDITY_TOKEN = IMintableBurnableTokenUpgradeable(poolBNPLToken);\\n\\n        bankNode = IBNPLBankNode(bankNodeContract);\\n        bankNodeManager = IBankNodeManager(bankNodeManagerContract);\\n\\n        _setupRole(SLASHER_ROLE, bankNodeContract);\\n        _setupRole(NODE_REWARDS_MANAGER_ROLE, tokenBonder);\\n\\n        require(BASE_LIQUIDITY_TOKEN.balanceOf(address(this)) >= tokensToBond, \\\"tokens to bond not sent\\\");\\n        baseTokenBalance = tokensToBond;\\n        tokensBondedAllTime = tokensToBond;\\n        poolTokenEffectiveSupply = tokensToBond;\\n        virtualPoolTokensCount = tokensToBond;\\n        bnplKYCStore = bnplKYCStore_;\\n        kycDomainId = kycDomainId_;\\n        POOL_LIQUIDITY_TOKEN.mint(address(this), tokensToBond);\\n        emit Bond(tokenBonder, tokensToBond);\\n    }\\n\\n    /// @notice Returns pool tokens circulating\\n    /// @return poolTokensCirculating\\n    function poolTokensCirculating() external view override returns (uint256) {\\n        return poolTokenEffectiveSupply - POOL_LIQUIDITY_TOKEN.balanceOf(address(this));\\n    }\\n\\n    /// @notice Returns unstake lockup period\\n    /// @return unstakeLockupPeriod\\n    function getUnstakeLockupPeriod() public pure override returns (uint256) {\\n        return 7 days;\\n    }\\n\\n    /// @notice Returns pool total assets value\\n    /// @return poolTotalAssetsValue\\n    function getPoolTotalAssetsValue() public view override returns (uint256) {\\n        return baseTokenBalance;\\n    }\\n\\n    /// @notice Returns whether the BankNode has been decommissioned\\n    ///\\n    /// - When the liquidity tokens amount of the BankNode is less than minimum BankNode bonded amount, it is decommissioned\\n    ///\\n    /// @return isNodeDecomissioning\\n    function isNodeDecomissioning() public view override returns (bool) {\\n        return\\n            getPoolWithdrawConversion(POOL_LIQUIDITY_TOKEN.balanceOf(address(this))) <\\n            ((bankNodeManager.minimumBankNodeBondedAmount() * 75) / 100);\\n    }\\n\\n    /// @notice Returns pool deposit conversion\\n    ///\\n    /// @param depositAmount The deposit tokens amount\\n    /// @return poolDepositConversion\\n    function getPoolDepositConversion(uint256 depositAmount) public view returns (uint256) {\\n        uint256 poolTotalAssetsValue = getPoolTotalAssetsValue();\\n        return (depositAmount * poolTokenEffectiveSupply) / (poolTotalAssetsValue > 0 ? poolTotalAssetsValue : 1);\\n    }\\n\\n    /// @notice Returns pool withdraw conversion\\n    ///\\n    /// @param withdrawAmount The withdraw tokens amount\\n    /// @return poolWithdrawConversion\\n    function getPoolWithdrawConversion(uint256 withdrawAmount) public view override returns (uint256) {\\n        return\\n            (withdrawAmount * getPoolTotalAssetsValue()) /\\n            (poolTokenEffectiveSupply > 0 ? poolTokenEffectiveSupply : 1);\\n    }\\n\\n    /// @dev issue `amount` amount of unlocked tokens to user `user`\\n    /// @return baseTokensOut\\n    function _issueUnlockedTokensToUser(address user, uint256 amount) internal override returns (uint256) {\\n        require(\\n            amount != 0 && amount <= poolTokenEffectiveSupply,\\n            \\\"poolTokenAmount cannot be 0 or more than circulating\\\"\\n        );\\n\\n        require(poolTokenEffectiveSupply != 0, \\\"poolTokenEffectiveSupply must not be 0\\\");\\n        require(getPoolTotalAssetsValue() != 0, \\\"total asset value must not be 0\\\");\\n\\n        uint256 baseTokensOut = getPoolWithdrawConversion(amount);\\n        poolTokenEffectiveSupply -= amount;\\n        require(baseTokenBalance >= baseTokensOut, \\\"base tokens balance must be >= out\\\");\\n        baseTokenBalance -= baseTokensOut;\\n        TransferHelper.safeTransfer(address(BASE_LIQUIDITY_TOKEN), user, baseTokensOut);\\n        emit Unstake(user, baseTokensOut, amount);\\n        return baseTokensOut;\\n    }\\n\\n    /// @dev Remove liquidity tokens from the liquidity pool and lock these tokens for `unstakeLockupPeriod` duration\\n    function _removeLiquidityAndLock(\\n        address user,\\n        uint256 poolTokensToConsume,\\n        uint256 unstakeLockupPeriod\\n    ) internal returns (uint256) {\\n        require(unstakeLockupPeriod != 0, \\\"lockup period cannot be 0\\\");\\n        require(user != address(this) && user != address(0), \\\"invalid user\\\");\\n\\n        require(\\n            poolTokensToConsume > 0 && poolTokensToConsume <= poolTokenEffectiveSupply,\\n            \\\"poolTokenAmount cannot be 0 or more than circulating\\\"\\n        );\\n\\n        require(poolTokenEffectiveSupply != 0, \\\"poolTokenEffectiveSupply must not be 0\\\");\\n        POOL_LIQUIDITY_TOKEN.burnFrom(user, poolTokensToConsume);\\n        _createTokenLockup(user, poolTokensToConsume, uint64(block.timestamp + unstakeLockupPeriod), true);\\n        return 0;\\n    }\\n\\n    /// @dev Mint `mintAmount` amount pool token to `user` address\\n    function _mintPoolTokensForUser(address user, uint256 mintAmount) private {\\n        require(user != address(0), \\\"user cannot be null\\\");\\n\\n        require(mintAmount != 0, \\\"mint amount cannot be 0\\\");\\n        uint256 newMintTokensCirculating = poolTokenEffectiveSupply + mintAmount;\\n        poolTokenEffectiveSupply = newMintTokensCirculating;\\n        POOL_LIQUIDITY_TOKEN.mint(user, mintAmount);\\n        require(poolTokenEffectiveSupply == newMintTokensCirculating);\\n    }\\n\\n    /// @dev Handle donate tokens\\n    function _processDonation(\\n        address sender,\\n        uint256 depositAmount,\\n        bool countedIntoTotal\\n    ) private {\\n        require(sender != address(this) && sender != address(0), \\\"invalid sender\\\");\\n        require(depositAmount != 0, \\\"depositAmount cannot be 0\\\");\\n\\n        require(poolTokenEffectiveSupply != 0, \\\"poolTokenEffectiveSupply must not be 0\\\");\\n        TransferHelper.safeTransferFrom(address(BASE_LIQUIDITY_TOKEN), sender, address(this), depositAmount);\\n        baseTokenBalance += depositAmount;\\n        if (countedIntoTotal) {\\n            totalDonatedAllTime += depositAmount;\\n        }\\n        emit Donation(sender, depositAmount);\\n    }\\n\\n    /// @dev Handle bond tokens\\n    function _processBondTokens(address sender, uint256 depositAmount) private {\\n        require(sender != address(this) && sender != address(0), \\\"invalid sender\\\");\\n        require(depositAmount != 0, \\\"depositAmount cannot be 0\\\");\\n\\n        require(poolTokenEffectiveSupply != 0, \\\"poolTokenEffectiveSupply must not be 0\\\");\\n        TransferHelper.safeTransferFrom(address(BASE_LIQUIDITY_TOKEN), sender, address(this), depositAmount);\\n        uint256 selfMint = getPoolDepositConversion(depositAmount);\\n        _mintPoolTokensForUser(address(this), selfMint);\\n        virtualPoolTokensCount += selfMint;\\n        baseTokenBalance += depositAmount;\\n        tokensBondedAllTime += depositAmount;\\n        emit Bond(sender, depositAmount);\\n    }\\n\\n    /// @dev Handle unbond tokens\\n    function _processUnbondTokens(address sender) private {\\n        require(sender != address(this) && sender != address(0), \\\"invalid sender\\\");\\n        require(bankNode.onGoingLoanCount() == 0, \\\"Cannot unbond, there are ongoing loans\\\");\\n\\n        uint256 pTokens = POOL_LIQUIDITY_TOKEN.balanceOf(address(this));\\n        uint256 totalBonded = getPoolWithdrawConversion(pTokens);\\n        require(totalBonded != 0, \\\"Insufficient bonded amount\\\");\\n\\n        TransferHelper.safeTransfer(address(BASE_LIQUIDITY_TOKEN), sender, totalBonded);\\n        POOL_LIQUIDITY_TOKEN.burn(pTokens);\\n\\n        poolTokenEffectiveSupply -= pTokens;\\n        virtualPoolTokensCount -= pTokens;\\n        baseTokenBalance -= totalBonded;\\n\\n        emit Unbond(sender, totalBonded);\\n    }\\n\\n    /// @dev This function is called when poolTokenEffectiveSupply is zero\\n    ///\\n    /// @param user The address of user\\n    /// @param depositAmount Deposit tokens amount\\n    /// @return poolTokensOut The output pool token amount\\n    function _setupLiquidityFirst(address user, uint256 depositAmount) private returns (uint256) {\\n        require(user != address(this) && user != address(0), \\\"invalid user\\\");\\n        require(depositAmount != 0, \\\"depositAmount cannot be 0\\\");\\n\\n        require(poolTokenEffectiveSupply == 0, \\\"poolTokenEffectiveSupply must be 0\\\");\\n        uint256 totalAssetValue = getPoolTotalAssetsValue();\\n\\n        TransferHelper.safeTransferFrom(address(BASE_LIQUIDITY_TOKEN), user, address(this), depositAmount);\\n\\n        require(poolTokenEffectiveSupply == 0, \\\"poolTokenEffectiveSupply must be 0\\\");\\n        require(getPoolTotalAssetsValue() == totalAssetValue, \\\"total asset value must not change\\\");\\n\\n        baseTokenBalance += depositAmount;\\n        uint256 newTotalAssetValue = getPoolTotalAssetsValue();\\n        require(newTotalAssetValue != 0 && newTotalAssetValue >= depositAmount);\\n        uint256 poolTokensOut = newTotalAssetValue;\\n        _mintPoolTokensForUser(user, poolTokensOut);\\n        emit Stake(user, depositAmount, poolTokensOut);\\n        return poolTokensOut;\\n    }\\n\\n    /// @dev This function is called when poolTokenEffectiveSupply great than zero\\n    ///\\n    /// @param user The address of user\\n    /// @param depositAmount Deposit tokens amount\\n    /// @return poolTokensOut The output pool token amount\\n    function _addLiquidityNormal(address user, uint256 depositAmount) private returns (uint256) {\\n        require(user != address(this) && user != address(0), \\\"invalid user\\\");\\n        require(depositAmount != 0, \\\"depositAmount cannot be 0\\\");\\n\\n        require(poolTokenEffectiveSupply != 0, \\\"poolTokenEffectiveSupply must not be 0\\\");\\n        require(getPoolTotalAssetsValue() != 0, \\\"total asset value must not be 0\\\");\\n\\n        TransferHelper.safeTransferFrom(address(BASE_LIQUIDITY_TOKEN), user, address(this), depositAmount);\\n        require(poolTokenEffectiveSupply != 0, \\\"poolTokenEffectiveSupply cannot be 0\\\");\\n\\n        uint256 totalAssetValue = getPoolTotalAssetsValue();\\n        require(totalAssetValue != 0, \\\"total asset value cannot be 0\\\");\\n        uint256 poolTokensOut = getPoolDepositConversion(depositAmount);\\n\\n        baseTokenBalance += depositAmount;\\n        _mintPoolTokensForUser(user, poolTokensOut);\\n        emit Stake(user, depositAmount, poolTokensOut);\\n        return poolTokensOut;\\n    }\\n\\n    /// @dev Add liquidity tokens to liquidity pools\\n    ///\\n    /// @param user The address of user\\n    /// @param depositAmount Deposit tokens amount\\n    /// @return poolTokensOut The output pool token amount\\n    function _addLiquidity(address user, uint256 depositAmount) private returns (uint256) {\\n        require(user != address(this) && user != address(0), \\\"invalid user\\\");\\n        require(!isNodeDecomissioning(), \\\"BankNode bonded amount is less than 75% of the minimum\\\");\\n\\n        require(depositAmount != 0, \\\"depositAmount cannot be 0\\\");\\n        if (poolTokenEffectiveSupply == 0) {\\n            return _setupLiquidityFirst(user, depositAmount);\\n        } else {\\n            return _addLiquidityNormal(user, depositAmount);\\n        }\\n    }\\n\\n    /// @dev Remove liquidity tokens from the liquidity pool\\n    function _removeLiquidityNoLockup(address user, uint256 poolTokensToConsume) private returns (uint256) {\\n        require(user != address(this) && user != address(0), \\\"invalid user\\\");\\n\\n        require(\\n            poolTokensToConsume != 0 && poolTokensToConsume <= poolTokenEffectiveSupply,\\n            \\\"poolTokenAmount cannot be 0 or more than circulating\\\"\\n        );\\n\\n        require(poolTokenEffectiveSupply != 0, \\\"poolTokenEffectiveSupply must not be 0\\\");\\n        require(getPoolTotalAssetsValue() != 0, \\\"total asset value must not be 0\\\");\\n\\n        uint256 baseTokensOut = getPoolWithdrawConversion(poolTokensToConsume);\\n        poolTokenEffectiveSupply -= poolTokensToConsume;\\n        require(baseTokenBalance >= baseTokensOut, \\\"base tokens balance must be >= out\\\");\\n        TransferHelper.safeTransferFrom(address(POOL_LIQUIDITY_TOKEN), user, address(this), poolTokensToConsume);\\n        require(baseTokenBalance >= baseTokensOut, \\\"base tokens balance must be >= out\\\");\\n        baseTokenBalance -= baseTokensOut;\\n        TransferHelper.safeTransfer(address(BASE_LIQUIDITY_TOKEN), user, baseTokensOut);\\n        emit Unstake(user, baseTokensOut, poolTokensToConsume);\\n        return baseTokensOut;\\n    }\\n\\n    /// @dev Remove liquidity tokens from liquidity pools\\n    function _removeLiquidity(address user, uint256 poolTokensToConsume) internal returns (uint256) {\\n        require(poolTokensToConsume != 0, \\\"poolTokensToConsume cannot be 0\\\");\\n        uint256 unstakeLockupPeriod = getUnstakeLockupPeriod();\\n        if (unstakeLockupPeriod == 0) {\\n            return _removeLiquidityNoLockup(user, poolTokensToConsume);\\n        } else {\\n            return _removeLiquidityAndLock(user, poolTokensToConsume, unstakeLockupPeriod);\\n        }\\n    }\\n\\n    /// @notice Allows a user to donate `donateAmount` of BNPL to the pool (user must first approve)\\n    /// @param donateAmount The donate amount of BNPL\\n    function donate(uint256 donateAmount) external override nonReentrant {\\n        require(donateAmount != 0, \\\"donateAmount cannot be 0\\\");\\n        _processDonation(msg.sender, donateAmount, true);\\n    }\\n\\n    /// @notice Allows a user to donate `donateAmount` of BNPL to the pool (not conted in total) (user must first approve)\\n    /// @param donateAmount The donate amount of BNPL\\n    function donateNotCountedInTotal(uint256 donateAmount) external override nonReentrant {\\n        require(donateAmount != 0, \\\"donateAmount cannot be 0\\\");\\n        _processDonation(msg.sender, donateAmount, false);\\n    }\\n\\n    /// @notice Allows a user to bond `bondAmount` of BNPL to the pool (user must first approve)\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"NODE_REWARDS_MANAGER_ROLE\\\"\\n    ///\\n    /// @param bondAmount The bond amount of BNPL\\n    function bondTokens(uint256 bondAmount) external override nonReentrant onlyRole(NODE_REWARDS_MANAGER_ROLE) {\\n        require(bondAmount != 0, \\\"bondAmount cannot be 0\\\");\\n        _processBondTokens(msg.sender, bondAmount);\\n    }\\n\\n    /// @notice Allows a user to unbond BNPL from the pool\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"NODE_REWARDS_MANAGER_ROLE\\\"\\n    ///\\n    function unbondTokens() external override nonReentrant onlyRole(NODE_REWARDS_MANAGER_ROLE) {\\n        _processUnbondTokens(msg.sender);\\n    }\\n\\n    /// @notice Allows a user to stake `stakeAmount` of BNPL to the pool (user must first approve)\\n    /// @param stakeAmount Stake token amount\\n    function stakeTokens(uint256 stakeAmount) external override nonReentrant {\\n        require(\\n            bnplKYCStore.checkUserBasicBitwiseMode(kycDomainId, msg.sender, BNPL_STAKER_NEEDS_KYC) == 1,\\n            \\\"borrower needs kyc\\\"\\n        );\\n        require(stakeAmount != 0, \\\"stakeAmount cannot be 0\\\");\\n        _addLiquidity(msg.sender, stakeAmount);\\n    }\\n\\n    /// @notice Allows a user to unstake `unstakeAmount` of BNPL from the pool (puts it into a lock up for a 7 day cool down period)\\n    /// @param unstakeAmount Unstake token amount\\n    function unstakeTokens(uint256 unstakeAmount) external override nonReentrant {\\n        require(unstakeAmount != 0, \\\"unstakeAmount cannot be 0\\\");\\n        _removeLiquidity(msg.sender, unstakeAmount);\\n    }\\n\\n    /// @dev Handle slash\\n    function _slash(uint256 slashAmount, address recipient) private {\\n        require(slashAmount < getPoolTotalAssetsValue(), \\\"cannot slash more than the pool balance\\\");\\n        baseTokenBalance -= slashAmount;\\n        totalSlashedAllTime += slashAmount;\\n        TransferHelper.safeTransfer(address(BASE_LIQUIDITY_TOKEN), recipient, slashAmount);\\n        emit Slash(recipient, slashAmount);\\n    }\\n\\n    /// @notice Allows an authenticated contract/user (in this case, only BNPLBankNode) to slash `slashAmount` of BNPL from the pool\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"SLASHER_ROLE\\\"\\n    ///\\n    /// @param slashAmount The slash amount\\n    function slash(uint256 slashAmount) external override onlyRole(SLASHER_ROLE) nonReentrant {\\n        _slash(slashAmount, msg.sender);\\n    }\\n\\n    /// @notice Claim node owner pool BNPL token rewards\\n    /// @return rewards Claimed reward pool token amount\\n    function getNodeOwnerPoolTokenRewards() public view override returns (uint256) {\\n        uint256 equivalentPoolTokens = getPoolDepositConversion(tokensBondedAllTime);\\n        uint256 ownerPoolTokens = POOL_LIQUIDITY_TOKEN.balanceOf(address(this));\\n        if (ownerPoolTokens > equivalentPoolTokens) {\\n            return ownerPoolTokens - equivalentPoolTokens;\\n        }\\n        return 0;\\n    }\\n\\n    /// @notice Claim node owner BNPL token rewards\\n    /// @return rewards Claimed reward BNPL token amount\\n    function getNodeOwnerBNPLRewards() external view override returns (uint256) {\\n        uint256 rewardsAmount = getNodeOwnerPoolTokenRewards();\\n        if (rewardsAmount != 0) {\\n            return getPoolWithdrawConversion(rewardsAmount);\\n        }\\n        return 0;\\n    }\\n\\n    /// @notice Claim node owner pool token rewards to address `to`\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"NODE_REWARDS_MANAGER_ROLE\\\"\\n    ///\\n    /// @param to Address to receive rewards\\n    function claimNodeOwnerPoolTokenRewards(address to)\\n        external\\n        override\\n        onlyRole(NODE_REWARDS_MANAGER_ROLE)\\n        nonReentrant\\n    {\\n        uint256 poolTokenRewards = getNodeOwnerPoolTokenRewards();\\n        require(poolTokenRewards > 0, \\\"cannot claim 0 rewards\\\");\\n        virtualPoolTokensCount -= poolTokenRewards;\\n        POOL_LIQUIDITY_TOKEN.transfer(to, poolTokenRewards);\\n    }\\n\\n    /// @notice Calculates the amount of BNPL to slash from the pool given a Bank Node loss of `nodeLoss`\\n    /// with a previous balance of `prevNodeBalance` and the current pool balance containing `poolBalance` BNPL.\\n    ///\\n    /// @param prevNodeBalance The bank node previous balance\\n    /// @param nodeLoss The bank node loss\\n    /// @param poolBalance The bank node current pool balance\\n    /// @return SlashAmount Calculated slash amount\\n    function calculateSlashAmount(\\n        uint256 prevNodeBalance,\\n        uint256 nodeLoss,\\n        uint256 poolBalance\\n    ) external pure returns (uint256) {\\n        uint256 slashRatio = (nodeLoss * PRBMathUD60x18.scale()).div(prevNodeBalance * PRBMathUD60x18.scale());\\n        return (poolBalance * slashRatio) / PRBMathUD60x18.scale();\\n    }\\n\\n    /// @notice Claim the next token lockup vault they have locked up in the contract.\\n    ///\\n    /// @param user The address of user\\n    /// @return claimTokenLockup claim token lockup amount\\n    function claimTokenLockup(address user) external nonReentrant returns (uint256) {\\n        return _claimNextTokenLockup(user);\\n    }\\n\\n    /// @notice Claim the next token lockup vaults they have locked up in the contract.\\n    ///\\n    /// @param user The address of user\\n    /// @param maxNumberOfClaims The max number of claims\\n    /// @return claimTokenNextNLockups claim token amount next N lockups\\n    function claimTokenNextNLockups(address user, uint32 maxNumberOfClaims) external nonReentrant returns (uint256) {\\n        return _claimUpToNextNTokenLockups(user, maxNumberOfClaims);\\n    }\\n\\n    /// @notice Allows rewards manager to unlock lending token interest.\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"NODE_REWARDS_MANAGER_ROLE\\\"\\n    ///\\n    /// - Distribute dividends can only be done after unlocking the lending token interest\\n    function unlockLendingTokenInterest() external onlyRole(NODE_REWARDS_MANAGER_ROLE) nonReentrant {\\n        bankNode.rewardToken().cooldown();\\n    }\\n\\n    /// @notice Distribute dividends with token interest\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"NODE_REWARDS_MANAGER_ROLE\\\"\\n    ///\\n    function distributeDividends() external onlyRole(NODE_REWARDS_MANAGER_ROLE) nonReentrant {\\n        bankNode.rewardToken().claimRewards(address(this), type(uint256).max);\\n\\n        uint256 rewardTokenAmount = IERC20(address(bankNode.rewardToken())).balanceOf(address(this));\\n        require(rewardTokenAmount > 0, \\\"rewardTokenAmount must be > 0\\\");\\n\\n        TransferHelper.safeApprove(address(bankNode.rewardToken()), address(bankNode.rewardToken()), rewardTokenAmount);\\n        bankNode.rewardToken().redeem(address(this), rewardTokenAmount);\\n\\n        IERC20 swapToken = IERC20(bankNode.rewardToken().REWARD_TOKEN());\\n\\n        uint256 donateAmount = bankNode.bnplSwapMarket().swapExactTokensForTokens(\\n            swapToken.balanceOf(address(this)),\\n            0,\\n            BankNodeUtils.getSwapExactTokensPath(address(swapToken), address(BASE_LIQUIDITY_TOKEN)),\\n            address(this),\\n            block.timestamp\\n        )[2];\\n        require(donateAmount > 0, \\\"swap amount must be > 0\\\");\\n\\n        TransferHelper.safeApprove(address(BASE_LIQUIDITY_TOKEN), address(this), donateAmount);\\n        _processDonation(msg.sender, donateAmount, false);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/AccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlEnumerableUpgradeable.sol\\\";\\nimport \\\"./AccessControlUpgradeable.sol\\\";\\nimport \\\"../utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\\n */\\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\\n    function __AccessControlEnumerable_init() internal onlyInitializing {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __AccessControl_init_unchained();\\n        __AccessControlEnumerable_init_unchained();\\n    }\\n\\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\\n    }\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n\\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\\n        return _roleMembers[role].at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\\n        return _roleMembers[role].length();\\n    }\\n\\n    /**\\n     * @dev Overload {_grantRole} to track enumerable memberships\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual override {\\n        super._grantRole(role, account);\\n        _roleMembers[role].add(account);\\n    }\\n\\n    /**\\n     * @dev Overload {_revokeRole} to track enumerable memberships\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual override {\\n        super._revokeRole(role, account);\\n        _roleMembers[role].remove(account);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/ERC20/interfaces/IMintableBurnableTokenUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\nimport {IGenericMintableTo} from \\\"./IGenericMintableTo.sol\\\";\\nimport {IGenericBurnableFrom} from \\\"./IGenericBurnableFrom.sol\\\";\\n\\n/**\\n * @dev Interface of the IMintableTokenUpgradeable standard\\n */\\ninterface IMintableTokenUpgradeable is IGenericMintableTo, IERC20Upgradeable {\\n\\n}\\n\\n/**\\n * @dev Interface of the IMintableBurnableTokenUpgradeable standard\\n */\\ninterface IMintableBurnableTokenUpgradeable is IMintableTokenUpgradeable, IGenericBurnableFrom {\\n\\n}\\n\"\r\n    },\r\n    \"src/Management/interfaces/IBankNodeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IBNPLProtocolConfig} from \\\"../../ProtocolDeploy/interfaces/IBNPLProtocolConfig.sol\\\";\\n\\nimport {BNPLKYCStore} from \\\"../BNPLKYCStore.sol\\\";\\nimport {BankNodeLendingRewards} from \\\"../../Rewards/PlatformRewards/BankNodeLendingRewards.sol\\\";\\n\\n/// @title BNPL BankNodeManager contract\\n///\\n/// @notice\\n/// - Features:\\n///     **Create a bank node**\\n///     **Add lendable token**\\n///     **Set minimum BankNode bonded amount**\\n///     **Set loan overdue grace period**\\n///\\n/// @author BNPL\\ninterface IBankNodeManager {\\n    struct LendableToken {\\n        address tokenContract;\\n        address swapMarket;\\n        uint24 swapMarketPoolFee;\\n        uint8 decimals;\\n        uint256 valueMultiplier;\\n        uint16 unusedFundsLendingMode;\\n        address unusedFundsLendingContract;\\n        address unusedFundsLendingToken;\\n        address unusedFundsIncentivesController;\\n        string symbol;\\n        string poolSymbol;\\n    }\\n\\n    struct BankNode {\\n        address bankNodeContract;\\n        address bankNodeToken;\\n        address bnplStakingPoolContract;\\n        address bnplStakingPoolToken;\\n        address lendableToken;\\n        address creator;\\n        uint32 id;\\n        uint64 createdAt;\\n        uint256 createBlock;\\n        string nodeName;\\n        string website;\\n        string configUrl;\\n    }\\n\\n    struct BankNodeDetail {\\n        uint256 totalAssetsValueBankNode;\\n        uint256 totalAssetsValueStakingPool;\\n        uint256 tokensCirculatingBankNode;\\n        uint256 tokensCirculatingStakingPool;\\n        uint256 totalLiquidAssetsValue;\\n        uint256 baseTokenBalanceBankNode;\\n        uint256 baseTokenBalanceStakingPool;\\n        uint256 accountsReceivableFromLoans;\\n        uint256 virtualPoolTokensCount;\\n        address baseLiquidityToken;\\n        address poolLiquidityToken;\\n        bool isNodeDecomissioning;\\n        uint256 nodeOperatorBalance;\\n        uint256 loanRequestIndex;\\n        uint256 loanIndex;\\n        uint256 valueOfUnusedFundsLendingDeposits;\\n        uint256 totalLossAllTime;\\n        uint256 onGoingLoanCount;\\n        uint256 totalTokensLocked;\\n        uint256 getUnstakeLockupPeriod;\\n        uint256 tokensBondedAllTime;\\n        uint256 poolTokenEffectiveSupply;\\n        uint256 nodeTotalStaked;\\n        uint256 nodeBondedBalance;\\n        uint256 nodeOwnerBNPLRewards;\\n        uint256 nodeOwnerPoolTokenRewards;\\n    }\\n\\n    struct BankNodeData {\\n        BankNode data;\\n        BankNodeDetail detail;\\n    }\\n\\n    struct CreateBankNodeContractsInput {\\n        uint32 bankNodeId;\\n        address operatorAdmin;\\n        address operator;\\n        address lendableTokenAddress;\\n    }\\n\\n    struct CreateBankNodeContractsOutput {\\n        address bankNodeContract;\\n        address bankNodeToken;\\n        address bnplStakingPoolContract;\\n        address bnplStakingPoolToken;\\n    }\\n\\n    /// @notice Get whether the banknode exists\\n    ///\\n    /// @param bankNodeId The bank node id\\n    /// @return BankNodeIdExists Returns `0` when it does not exist, otherwise returns `1`\\n    function bankNodeIdExists(uint32 bankNodeId) external view returns (uint256);\\n\\n    /// @notice Get the contract address of the specified bank node\\n    ///\\n    /// @param bankNodeId The bank node id\\n    /// @return BankNodeContract The contract address of the node\\n    function getBankNodeContract(uint32 bankNodeId) external view returns (address);\\n\\n    /// @notice Get the lending pool token contract (ERC20) address of the specified bank node\\n    ///\\n    /// @param bankNodeId Bank node id\\n    /// @return BankNodeToken The lending pool token contract (ERC20) address of the node\\n    function getBankNodeToken(uint32 bankNodeId) external view returns (address);\\n\\n    /// @notice Get the staking pool contract address of the specified bank node\\n    ///\\n    /// @param bankNodeId The bank node id\\n    /// @return BankNodeStakingPoolContract The staking pool contract address of the node\\n    function getBankNodeStakingPoolContract(uint32 bankNodeId) external view returns (address);\\n\\n    /// @notice Get the staking pool token contract (ERC20) address of the specified bank node\\n    ///\\n    /// @param bankNodeId The bank node id\\n    /// @return BankNodeStakingPoolToken The staking pool token contract (ERC20) address of the node\\n    function getBankNodeStakingPoolToken(uint32 bankNodeId) external view returns (address);\\n\\n    /// @notice Get the lendable token contract (ERC20) address of the specified bank node\\n    ///\\n    /// @param bankNodeId The bank node id\\n    /// @return BankNodeLendableToken The lendable token contract (ERC20) address of the node\\n    function getBankNodeLendableToken(uint32 bankNodeId) external view returns (address);\\n\\n    /// @notice Get all bank nodes loan statistic\\n    ///\\n    /// @return totalAmountOfAllActiveLoans uint256 Total amount of all activeLoans\\n    /// @return totalAmountOfAllLoans uint256 Total amount of all loans\\n    function getBankNodeLoansStatistic()\\n        external\\n        view\\n        returns (uint256 totalAmountOfAllActiveLoans, uint256 totalAmountOfAllLoans);\\n\\n    /// @notice Get BNPL KYC store contract\\n    ///\\n    /// @return BNPLKYCStore BNPL KYC store contract\\n    function bnplKYCStore() external view returns (BNPLKYCStore);\\n\\n    /// @dev This contract is called through the proxy.\\n    ///\\n    /// @param _protocolConfig BNPLProtocolConfig contract address\\n    /// @param _configurator BNPL contract platform configurator address\\n    /// @param _minimumBankNodeBondedAmount The minimum BankNode bonded amount required to create the bankNode\\n    /// @param _loanOverdueGracePeriod Loan overdue grace period (secs)\\n    /// @param _bankNodeLendingRewards BankNodeLendingRewards contract address\\n    /// @param _bnplKYCStore BNPLKYCStore contract address\\n    function initialize(\\n        IBNPLProtocolConfig _protocolConfig,\\n        address _configurator,\\n        uint256 _minimumBankNodeBondedAmount,\\n        uint256 _loanOverdueGracePeriod,\\n        BankNodeLendingRewards _bankNodeLendingRewards,\\n        BNPLKYCStore _bnplKYCStore\\n    ) external;\\n\\n    /// @notice Get whether lendable tokens are enabled\\n    ///\\n    /// @param lendableTokenAddress The lendable token contract (ERC20) address\\n    /// @return enabledLendableTokens Returns `0` when it does not exist, otherwise returns `1`\\n    function enabledLendableTokens(address lendableTokenAddress) external view returns (uint8);\\n\\n    /// @notice Get lendable token data\\n    ///\\n    /// @param lendableTokenAddress The lendable token contract (ERC20) address\\n    /// @return tokenContract The lendable token contract (ERC20) address\\n    /// @return swapMarket The configured swap market contract address (ex. SushiSwap Router)\\n    /// @return swapMarketPoolFee The configured swap market fee\\n    /// @return decimals The decimals for lendable tokens\\n    /// @return valueMultiplier `USD_VALUE = amount * valueMultiplier / 10 ** 18`\\n    /// @return unusedFundsLendingMode lending mode (1)\\n    /// @return unusedFundsLendingContract (ex. AAVE lending pool contract address)\\n    /// @return unusedFundsLendingToken (ex. AAVE tokens contract address)\\n    /// @return unusedFundsIncentivesController (ex. AAVE incentives controller contract address)\\n    /// @return symbol The lendable token symbol\\n    /// @return poolSymbol The pool lendable token symbol\\n    function lendableTokens(address lendableTokenAddress)\\n        external\\n        view\\n        returns (\\n            address tokenContract,\\n            address swapMarket,\\n            uint24 swapMarketPoolFee,\\n            uint8 decimals,\\n            uint256 valueMultiplier, //USD_VALUE = amount * valueMultiplier / 10**18\\n            uint16 unusedFundsLendingMode,\\n            address unusedFundsLendingContract,\\n            address unusedFundsLendingToken,\\n            address unusedFundsIncentivesController,\\n            string calldata symbol,\\n            string calldata poolSymbol\\n        );\\n\\n    /// @notice Get bank node data according to the specified id\\n    ///\\n    /// @param bankNodeId The bank node id\\n    /// @return bankNodeContract The bank node contract address\\n    /// @return bankNodeToken The bank node token contract (ERC20) address\\n    /// @return bnplStakingPoolContract The bank node staking pool contract address\\n    /// @return bnplStakingPoolToken The bank node staking pool token contract (ERC20) address\\n    /// @return lendableToken The bank node lendable token contract (ERC20) address\\n    /// @return creator The bank node creator address\\n    /// @return id The bank node id\\n    /// @return createdAt The creation time of the bank node\\n    /// @return createBlock The creation block of the bank node\\n    /// @return nodeName The name of the bank node\\n    /// @return website The website of the bank node\\n    /// @return configUrl The config url of the bank node\\n    function bankNodes(uint32 bankNodeId)\\n        external\\n        view\\n        returns (\\n            address bankNodeContract,\\n            address bankNodeToken,\\n            address bnplStakingPoolContract,\\n            address bnplStakingPoolToken,\\n            address lendableToken,\\n            address creator,\\n            uint32 id,\\n            uint64 createdAt,\\n            uint256 createBlock,\\n            string calldata nodeName,\\n            string calldata website,\\n            string calldata configUrl\\n        );\\n\\n    /// @notice Get bank node id with bank node address\\n    /// @return bankNodeId Bank node id\\n    function bankNodeAddressToId(address bankNodeAddressTo) external view returns (uint32);\\n\\n    /// @notice Get BNPL platform protocol config contract\\n    /// @return minimumBankNodeBondedAmount BNPL protocol config contract\\n    function minimumBankNodeBondedAmount() external view returns (uint256);\\n\\n    /// @notice Get the loan overdue grace period currently configured on the platform\\n    /// @return loanOverdueGracePeriod loan overdue grace period (secs)\\n    function loanOverdueGracePeriod() external view returns (uint256);\\n\\n    /// @notice Get the current total number of platform bank nodes\\n    /// @return bankNodeCount Number of platform bank nodes\\n    function bankNodeCount() external view returns (uint32);\\n\\n    /// @notice Get BNPL token contract\\n    /// @return bnplToken BNPL token contract\\n    function bnplToken() external view returns (IERC20);\\n\\n    /// @notice Get bank node lending rewards contract\\n    /// @return bankNodeLendingRewards Bank node lending rewards contract\\n    function bankNodeLendingRewards() external view returns (BankNodeLendingRewards);\\n\\n    /// @notice Get BNPL platform protocol config contract\\n    /// @return protocolConfig BNPL protocol config contract\\n    function protocolConfig() external view returns (IBNPLProtocolConfig);\\n\\n    /// @notice Get bank node details list (pagination supported)\\n    ///\\n    /// @param start Where to start getting bank node\\n    /// @param count How many bank nodes to get\\n    /// @param reverse Whether to return the list in reverse order\\n    /// @return BankNodeList bank node details array\\n    /// @return BankNodeCount bank node count\\n    function getBankNodeList(\\n        uint32 start,\\n        uint32 count,\\n        bool reverse\\n    ) external view returns (BankNodeData[] memory, uint32);\\n\\n    /// @notice Get bank node data with `bankNode` address\\n    ///\\n    /// @param bankNode bank node contract address\\n    /// @return bank node detail struct\\n    function getBankNodeDetail(address bankNode) external view returns (BankNodeDetail memory);\\n\\n    /// @dev Add support for a new ERC20 token to be used as lendable tokens for new bank nodes\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"CONFIGURE_NODE_MANAGER_ROLE\\\"\\n    ///\\n    /// @param _lendableToken LendableToken configuration structure.\\n    /// @param enabled `0` or `1`, Whether to enable (cannot be used to create bank node after disable)\\n    ///\\n    /// **`_lendableToken` parameters:**\\n    ///\\n    /// ```solidity\\n    /// address tokenContract The lendable token contract (ERC20) address\\n    /// address swapMarket The configured swap market contract address (ex. SushiSwap Router)\\n    /// uint24 swapMarketPoolFee The configured swap market fee\\n    /// uint8 decimals The decimals for lendable tokens\\n    /// uint256 valueMultiplier `USD_VALUE = amount * valueMultiplier / 10 ** 18`\\n    /// uint16 unusedFundsLendingMode lending mode (1)\\n    /// address unusedFundsLendingContract (ex. AAVE lending pool contract address)\\n    /// address unusedFundsLendingToken (ex. AAVE tokens contract address)\\n    /// address unusedFundsIncentivesController (ex. AAVE incentives controller contract address)\\n    /// string symbol The lendable token symbol\\n    /// string poolSymbol The pool lendable token symbol\\n    /// ```\\n    function addLendableToken(LendableToken calldata _lendableToken, uint8 enabled) external;\\n\\n    /// @dev Enable/Disable support for ERC20 tokens to be used as lendable tokens for new bank nodes (does not effect existing nodes)\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"CONFIGURE_NODE_MANAGER_ROLE\\\"\\n    ///\\n    /// @param tokenContract lendable token contract address\\n    /// @param enabled `0` or `1`, Whether to enable (cannot be used to create bank node after disable)\\n    function setLendableTokenStatus(address tokenContract, uint8 enabled) external;\\n\\n    /// @dev Set the minimum BNPL to bond per node\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"CONFIGURE_NODE_MANAGER_ROLE\\\"\\n    ///\\n    /// @param _minimumBankNodeBondedAmount minium bank node bonded amount\\n    function setMinimumBankNodeBondedAmount(uint256 _minimumBankNodeBondedAmount) external;\\n\\n    /// @dev Set the loan overdue grace period per node\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"CONFIGURE_NODE_MANAGER_ROLE\\\"\\n    ///\\n    /// @param _loanOverdueGracePeriod loan overdue grace period (secs)\\n    function setLoanOverdueGracePeriod(uint256 _loanOverdueGracePeriod) external;\\n\\n    /// @notice Creates a new bonded bank node\\n    ///\\n    /// @dev\\n    /// - Steps:\\n    ///    1) Create bank node proxy contract\\n    ///    2) Create staking pool proxy contract\\n    ///    3) Create staking pool ERC20 token\\n    ///    4) Create bank node ERC20 token\\n    ///    5) Initialize bank node proxy contract\\n    ///    6) Bond tokens\\n    ///    7) Initialize staking pool proxy contract\\n    ///    8) Settings\\n    ///\\n    /// @param operator The node operator who will be assigned the permissions of bank node admin for the newly created bank node\\n    /// @param tokensToBond The number of BNPL tokens to bond for the node\\n    /// @param lendableTokenAddress Which lendable token will be lent to borrowers for this bank node (ex. the address of USDT's erc20 smart contract)\\n    /// @param nodeName The official name of the bank node\\n    /// @param website The official website of the bank node\\n    /// @param configUrl The bank node config file url\\n    /// @param nodePublicKey KYC public key\\n    /// @param kycMode KYC mode\\n    /// @return BankNodeId bank node id\\n    function createBondedBankNode(\\n        address operator,\\n        uint256 tokensToBond,\\n        address lendableTokenAddress,\\n        string calldata nodeName,\\n        string calldata website,\\n        string calldata configUrl,\\n        address nodePublicKey,\\n        uint32 kycMode\\n    ) external returns (uint32);\\n}\\n\"\r\n    },\r\n    \"src/BankNode/interfaces/IBNPLBankNode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IStakedToken} from \\\"../../Aave/interfaces/IStakedToken.sol\\\";\\nimport {IAaveLendingPool} from \\\"../../Aave/interfaces/IAaveLendingPool.sol\\\";\\nimport {IAaveIncentivesController} from \\\"../../Aave/interfaces/IAaveIncentivesController.sol\\\";\\n\\nimport {IMintableBurnableTokenUpgradeable} from \\\"../../ERC20/interfaces/IMintableBurnableTokenUpgradeable.sol\\\";\\nimport {IBNPLSwapMarket} from \\\"../../SwapMarket/interfaces/IBNPLSwapMarket.sol\\\";\\nimport {IBankNodeManager} from \\\"../../Management/interfaces/IBankNodeManager.sol\\\";\\n\\nimport {BNPLKYCStore} from \\\"../../Management/BNPLKYCStore.sol\\\";\\nimport {IBNPLNodeStakingPool} from \\\"./IBNPLNodeStakingPool.sol\\\";\\n\\n/// @dev Interface of the IBNPLBankNode standard\\n/// @author BNPL\\ninterface IBankNodeInitializableV1 {\\n    struct BankNodeInitializeArgsV1 {\\n        uint32 bankNodeId; // The id of bank node\\n        uint24 bnplSwapMarketPoolFee; // The configured swap market fee\\n        address bankNodeManager; // The address of bank node manager\\n        address operatorAdmin; // The admin with `OPERATOR_ADMIN_ROLE` role\\n        address operator; // The admin with `OPERATOR_ROLE` role\\n        address bnplToken; // BNPL token address\\n        address bnplSwapMarket; // The swap market contract (ex. Sushiswap Router)\\n        uint16 unusedFundsLendingMode; // Lending mode (1)\\n        address unusedFundsLendingContract; // Lending contract (ex. AAVE lending pool)\\n        address unusedFundsLendingToken; // (ex. aTokens)\\n        address unusedFundsIncentivesController; // (ex. AAVE incentives controller)\\n        address nodeStakingPool; // The staking pool of bank node\\n        address baseLiquidityToken; // Liquidity token contract (ex. USDT)\\n        address poolLiquidityToken; // Pool liquidity token contract (ex. Pool USDT)\\n        address nodePublicKey; // Bank node KYC public key\\n        uint32 kycMode; // kycMode Bank node KYC mode\\n    }\\n\\n    /// @dev BankNode contract is created and initialized by the BankNodeManager contract\\n    ///\\n    /// - This contract is called through the proxy.\\n    ///\\n    /// @param bankNodeInitConfig BankNode configuration (passed in by BankNodeManager contract)\\n    ///\\n    /// `BankNodeInitializeArgsV1` paramerter structure:\\n    ///\\n    /// ```solidity\\n    /// uint32 bankNodeId // The id of bank node\\n    /// uint24 bnplSwapMarketPoolFee // The configured swap market fee\\n    /// address bankNodeManager // The address of bank node manager\\n    /// address operatorAdmin // The admin with `OPERATOR_ADMIN_ROLE` role\\n    /// address operator // The admin with `OPERATOR_ROLE` role\\n    /// uint256 bnplToken // BNPL token address\\n    /// address bnplSwapMarket // The swap market contract (ex. Sushiswap Router)\\n    /// uint16 unusedFundsLendingMode // Lending mode (1)\\n    /// address unusedFundsLendingContract // Lending contract (ex. AAVE lending pool)\\n    /// address unusedFundsLendingToken // (ex. AAVE aTokens)\\n    /// address unusedFundsIncentivesController // (ex. AAVE incentives controller)\\n    /// address nodeStakingPool // The staking pool of bank node\\n    /// address baseLiquidityToken // Liquidity token contract (ex. USDT)\\n    /// address poolLiquidityToken // Pool liquidity token contract (ex. Pool USDT)\\n    /// address nodePublicKey // Bank node KYC public key\\n    /// uint32 // kycMode Bank node KYC mode\\n    /// ```\\n    function initialize(BankNodeInitializeArgsV1 calldata bankNodeInitConfig) external;\\n}\\n\\n/**\\n * @dev Interface of the IBNPLBankNode standard\\n */\\ninterface IBNPLBankNode is IBankNodeInitializableV1 {\\n    struct Loan {\\n        address borrower;\\n        uint256 loanAmount;\\n        uint64 totalLoanDuration;\\n        uint32 numberOfPayments;\\n        uint64 loanStartedAt;\\n        uint32 numberOfPaymentsMade;\\n        uint256 amountPerPayment;\\n        uint256 interestRatePerPayment;\\n        uint256 totalAmountPaid;\\n        uint256 remainingBalance;\\n        uint8 status; // 0 = ongoing, 1 = completed, 2 = overdue, 3 = written off\\n        uint64 statusUpdatedAt;\\n        uint256 loanRequestId;\\n    }\\n\\n    /// @dev Get lending mode (1)\\n    /// @return lendingMode\\n    function unusedFundsLendingMode() external view returns (uint16);\\n\\n    /// @notice AAVE lending pool contract address\\n    /// @return AaveLendingPool\\n    function unusedFundsLendingContract() external view returns (IAaveLendingPool);\\n\\n    /// @notice AAVE tokens contract\\n    /// @return LendingToken\\n    function unusedFundsLendingToken() external view returns (IERC20);\\n\\n    /// @notice AAVE incentives controller contract\\n    /// @return AaveIncentivesController\\n    function unusedFundsIncentivesController() external view returns (IAaveIncentivesController);\\n\\n    /// @notice The configured lendable token swap market contract (ex. SushiSwap Router)\\n    /// @return BNPLSwapMarket\\n    function bnplSwapMarket() external view returns (IBNPLSwapMarket);\\n\\n    /// @notice The configured swap market fee\\n    /// @return bnplSwapMarketPoolFee\\n    function bnplSwapMarketPoolFee() external view returns (uint24);\\n\\n    /// @notice The id of bank node\\n    /// @return bankNodeId\\n    function bankNodeId() external view returns (uint32);\\n\\n    /// @notice Returns total assets value of bank node\\n    /// @return poolTotalAssetsValue\\n    function getPoolTotalAssetsValue() external view returns (uint256);\\n\\n    /// @notice Returns total liquidity assets value of bank node (Exclude `accountsReceivableFromLoans`)\\n    /// @return poolTotalLiquidAssetsValue\\n    function getPoolTotalLiquidAssetsValue() external view returns (uint256);\\n\\n    /// @notice The staking pool proxy contract\\n    /// @return BNPLNodeStakingPool\\n    function nodeStakingPool() external view returns (IBNPLNodeStakingPool);\\n\\n    /// @notice The bank node manager proxy contract\\n    /// @return BankNodeManager\\n    function bankNodeManager() external view returns (IBankNodeManager);\\n\\n    /// @notice Liquidity token (ex. USDT) balance of this\\n    /// @return baseTokenBalance\\n    function baseTokenBalance() external view returns (uint256);\\n\\n    /// @notice Returns `unusedFundsLendingToken` (ex. AAVE aTokens) balance of this\\n    /// @return unusedFundsLendingTokenBalance AAVE aTokens balance of this\\n    function getValueOfUnusedFundsLendingDeposits() external view returns (uint256);\\n\\n    /// @notice The balance of bank node admin\\n    /// @return nodeOperatorBalance\\n    function nodeOperatorBalance() external view returns (uint256);\\n\\n    /// @notice Accounts receivable from loans\\n    /// @return accountsReceivableFromLoans\\n    function accountsReceivableFromLoans() external view returns (uint256);\\n\\n    /// @notice Pool liquidity tokens (ex. Pool USDT) circulating\\n    /// @return poolTokensCirculating\\n    function poolTokensCirculating() external view returns (uint256);\\n\\n    /// @notice Current loan request index (pending)\\n    /// @return loanRequestIndex\\n    function loanRequestIndex() external view returns (uint256);\\n\\n    /// @notice Number of loans in progress\\n    /// @return onGoingLoanCount\\n    function onGoingLoanCount() external view returns (uint256);\\n\\n    /// @notice Current loan index (approved)\\n    /// @return loanIndex\\n    function loanIndex() external view returns (uint256);\\n\\n    /// @notice The total amount of all activated loans\\n    /// @return totalAmountOfActiveLoans\\n    function totalAmountOfActiveLoans() external view returns (uint256);\\n\\n    /// @notice The total amount of all loans\\n    /// @return totalAmountOfLoans\\n    function totalAmountOfLoans() external view returns (uint256);\\n\\n    /// @notice Liquidity token contract (ex. USDT)\\n    /// @return baseLiquidityToken\\n    function baseLiquidityToken() external view returns (IERC20);\\n\\n    /// @notice Pool liquidity token contract (ex. Pool USDT)\\n    /// @return poolLiquidityToken\\n    function poolLiquidityToken() external view returns (IMintableBurnableTokenUpgradeable);\\n\\n    /// @notice [Loan id] => [Interest paid for]\\n    ///\\n    /// @param loanId The id of loan\\n    /// @return interestPaidForLoan\\n    function interestPaidForLoan(uint256 loanId) external view returns (uint256);\\n\\n    /// @notice The total loss amount of bank node\\n    /// @return totalLossAllTime\\n    function totalLossAllTime() external view returns (uint256);\\n\\n    /// @notice Cumulative value of donate amounts\\n    /// @return totalDonatedAllTime\\n    function totalDonatedAllTime() external view returns (uint256);\\n\\n    /// @notice The total amount of net earnings\\n    /// @return netEarnings\\n    function netEarnings() external view returns (uint256);\\n\\n    /// @notice The total number of loans defaulted\\n    /// @return totalLoansDefaulted\\n    function totalLoansDefaulted() external view returns (uint256);\\n\\n    /// @notice Get bank node KYC public key\\n    /// @return nodeKycPublicKey\\n    function nodePublicKey() external view returns (address);\\n\\n    /// @notice Get bank node KYC mode\\n    /// @return kycMode\\n    function kycMode() external view returns (uint256);\\n\\n    /// @notice The corresponding id in the BNPL KYC store\\n    /// @return kycDomainId\\n    function kycDomainId() external view returns (uint32);\\n\\n    /// @notice The BNPL KYC store contract\\n    /// @return bnplKYCStore\\n    function bnplKYCStore() external view returns (BNPLKYCStore);\\n\\n    /// @notice [Loan request id] => [Loan request]\\n    /// @param _loanRequestId The id of loan request\\n    function loanRequests(uint256 _loanRequestId)\\n        external\\n        view\\n        returns (\\n            address borrower,\\n            uint256 loanAmount,\\n            uint64 totalLoanDuration,\\n            uint32 numberOfPayments,\\n            uint256 amountPerPayment,\\n            uint256 interestRatePerPayment,\\n            uint8 status, // 0 = under review, 1 = rejected, 2 = cancelled, 3 = *unused for now*, 4 = approved\\n            uint64 statusUpdatedAt,\\n            address statusModifiedBy,\\n            uint256 interestRate,\\n            uint256 loanId,\\n            uint8 messageType, // 0 = plain text, 1 = encrypted with the public key\\n            string memory message,\\n            string memory uuid\\n        );\\n\\n    /// @notice [Loan id] => [Loan]\\n    /// @param _loanId The id of loan\\n    function loans(uint256 _loanId)\\n        external\\n        view\\n        returns (\\n            address borrower,\\n            uint256 loanAmount,\\n            uint64 totalLoanDuration,\\n            uint32 numberOfPayments,\\n            uint64 loanStartedAt,\\n            uint32 numberOfPaymentsMade,\\n            uint256 amountPerPayment,\\n            uint256 interestRatePerPayment,\\n            uint256 totalAmountPaid,\\n            uint256 remainingBalance,\\n            uint8 status, // 0 = ongoing, 1 = completed, 2 = overdue, 3 = written off\\n            uint64 statusUpdatedAt,\\n            uint256 loanRequestId\\n        );\\n\\n    /// @notice Donate `depositAmount` liquidity tokens to bankNode\\n    /// @param depositAmount Amount of user deposit to liquidity pool\\n    function donate(uint256 depositAmount) external;\\n\\n    /// @notice Allow users to add liquidity tokens to liquidity pools.\\n    /// @dev The user will be issued an equal number of pool tokens\\n    ///\\n    /// @param depositAmount Amount of user deposit to liquidity pool\\n    function addLiquidity(uint256 depositAmount) external;\\n\\n    /// @notice Allow users to remove liquidity tokens from liquidity pools.\\n    /// @dev Users need to replace liquidity tokens with the same amount of pool tokens\\n    ///\\n    /// @param poolTokensToConsume Amount of user removes from the liquidity pool\\n    function removeLiquidity(uint256 poolTokensToConsume) external;\\n\\n    /// @notice Allows users to request a loan from the bank node\\n    ///\\n    /// @param loanAmount The loan amount\\n    /// @param totalLoanDuration The total loan duration (secs)\\n    /// @param numberOfPayments The number of payments\\n    /// @param interestRatePerPayment The interest rate per payment\\n    /// @param messageType 0 = plain text, 1 = encrypted with the public key\\n    /// @param message Writing detailed messages may increase loan approval rates\\n    /// @param uuid The `LoanRequested` event contains this uuid for easy identification\\n    function requestLoan(\\n        uint256 loanAmount,\\n        uint64 totalLoanDuration,\\n        uint32 numberOfPayments,\\n        uint256 interestRatePerPayment,\\n        uint8 messageType,\\n        string memory message,\\n        string memory uuid\\n    ) external;\\n\\n    /// @notice Deny a loan request with id `loanRequestId`\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"OPERATOR_ROLE\\\"\\n    ///\\n    /// @param loanRequestId The id of loan request\\n    function denyLoanRequest(uint256 loanRequestId) external;\\n\\n    /// @notice Approve a loan request with id `loanRequestId`\\n    /// - This also sends the lending token requested to the borrower\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"OPERATOR_ROLE\\\"\\n    ///\\n    /// @param loanRequestId The id of loan request\\n    function approveLoanRequest(uint256 loanRequestId) external;\\n\\n    /// @notice Make a loan payment for loan with id `loanId`\\n    /// - This method will call the swap contract, so `minTokenOut` is required\\n    ///\\n    /// @param loanId The id of loan\\n    /// @param minTokenOut The minimum output token of swap, if the swap result is less than this value, it will fail\\n    function makeLoanPayment(uint256 loanId, uint256 minTokenOut) external;\\n\\n    /// @notice Allows users report a loan with id `loanId` as being overdue\\n    /// - This method will call the swap contract, so `minTokenOut` is required\\n    ///\\n    /// @param loanId The id of loan\\n    /// @param minTokenOut The minimum output token of swap, if the swap result is less than this value, it will fail\\n    function reportOverdueLoan(uint256 loanId, uint256 minTokenOut) external;\\n\\n    /// @notice Withdraw `amount` of balance to an address\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"OPERATOR_ROLE\\\"\\n    ///\\n    /// @param amount Withdraw amount\\n    /// @param to Receiving address\\n    function withdrawNodeOperatorBalance(uint256 amount, address to) external;\\n\\n    /// @notice Change kyc settings of bank node\\n    /// - Including `setKYCDomainMode` and `setKYCDomainPublicKey`\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"OPERATOR_ROLE\\\"\\n    ///\\n    /// @param kycMode_ KYC mode\\n    /// @param nodePublicKey_ Bank node KYC public key\\n    function setKYCSettings(uint256 kycMode_, address nodePublicKey_) external;\\n\\n    /// @notice Set KYC mode for specified kycdomain\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"OPERATOR_ROLE\\\"\\n    ///\\n    /// @param domain KYC domain\\n    /// @param mode KYC mode\\n    function setKYCDomainMode(uint32 domain, uint256 mode) external;\\n\\n    /// @notice Returns incentives controller reward token (ex. stkAAVE)\\n    /// @return stakedAAVE\\n    function rewardToken() external view returns (IStakedToken);\\n\\n    /// @notice Get reward token (stkAAVE) unclaimed rewards balance of bank node\\n    /// @return rewardsBalance\\n    function getRewardsBalance() external view returns (uint256);\\n\\n    /// @notice Get reward token (stkAAVE) cool down start time of staking pool\\n    /// @return cooldownStartTimestamp\\n    function getCooldownStartTimestamp() external view returns (uint256);\\n\\n    /// @notice Get reward token (stkAAVE) rewards balance of staking pool\\n    /// @return stakedTokenRewardsBalance\\n    function getStakedTokenRewardsBalance() external view returns (uint256);\\n\\n    /// @notice Get reward token (stkAAVE) balance of staking pool\\n    /// @return stakedTokenBalance\\n    function getStakedTokenBalance() external view returns (uint256);\\n\\n    /// @notice Claim lending token interest\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"OPERATOR_ROLE\\\"\\n    ///\\n    /// @return lendingTokenInterest\\n    function claimLendingTokenInterest() external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/BankNode/interfaces/IBNPLNodeStakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {BNPLKYCStore} from \\\"../../Management/BNPLKYCStore.sol\\\";\\nimport {IUserTokenLockup} from \\\"./IUserTokenLockup.sol\\\";\\n\\n/// @dev Interface of the IBankNodeStakingPoolInitializableV1 standard\\n/// @author BNPL\\ninterface IBankNodeStakingPoolInitializableV1 {\\n    /// @dev StakingPool contract is created and initialized by the BankNodeManager contract\\n    ///\\n    /// - This contract is called through the proxy.\\n    ///\\n    /// @param bnplToken BNPL token address\\n    /// @param poolBNPLToken pool BNPL token address\\n    /// @param bankNodeContract BankNode contract address associated with stakingPool\\n    /// @param bankNodeManagerContract BankNodeManager contract address\\n    /// @param tokenBonder The address of the BankNode creator\\n    /// @param tokensToBond The amount of BNPL bound by the BankNode creator (initial liquidity amount)\\n    /// @param bnplKYCStore_ KYC store contract address\\n    /// @param kycDomainId_ KYC store domain id\\n    function initialize(\\n        address bnplToken,\\n        address poolBNPLToken,\\n        address bankNodeContract,\\n        address bankNodeManagerContract,\\n        address tokenBonder,\\n        uint256 tokensToBond,\\n        BNPLKYCStore bnplKYCStore_,\\n        uint32 kycDomainId_\\n    ) external;\\n}\\n\\n/**\\n * @dev Interface of the IBankNode standard\\n */\\ninterface IBNPLNodeStakingPool is IBankNodeStakingPoolInitializableV1, IUserTokenLockup {\\n    /// @notice Allows a user to donate `donateAmount` of BNPL to the pool (user must first approve)\\n    /// @param donateAmount The donate amount of BNPL\\n    function donate(uint256 donateAmount) external;\\n\\n    /// @notice Allows a user to donate `donateAmount` of BNPL to the pool (not conted in total) (user must first approve)\\n    /// @param donateAmount The donate amount of BNPL\\n    function donateNotCountedInTotal(uint256 donateAmount) external;\\n\\n    /// @notice Allows a user to bond `bondAmount` of BNPL to the pool (user must first approve)\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"NODE_REWARDS_MANAGER_ROLE\\\"\\n    ///\\n    /// @param bondAmount The bond amount of BNPL\\n    function bondTokens(uint256 bondAmount) external;\\n\\n    /// @notice Allows a user to unbond BNPL from the pool\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"NODE_REWARDS_MANAGER_ROLE\\\"\\n    ///\\n    function unbondTokens() external;\\n\\n    /// @notice Allows a user to stake `stakeAmount` of BNPL to the pool (user must first approve)\\n    /// @param stakeAmount Stake token amount\\n    function stakeTokens(uint256 stakeAmount) external;\\n\\n    /// @notice Allows a user to unstake `unstakeAmount` of BNPL from the pool (puts it into a lock up for a 7 day cool down period)\\n    /// @param unstakeAmount Unstake token amount\\n    function unstakeTokens(uint256 unstakeAmount) external;\\n\\n    /// @notice Allows an authenticated contract/user (in this case, only BNPLBankNode) to slash `slashAmount` of BNPL from the pool\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"SLASHER_ROLE\\\"\\n    ///\\n    /// @param slashAmount The slash amount\\n    function slash(uint256 slashAmount) external;\\n\\n    /// @notice Returns pool total assets value\\n    /// @return poolTotalAssetsValue\\n    function getPoolTotalAssetsValue() external view returns (uint256);\\n\\n    /// @notice Returns pool withdraw conversion\\n    ///\\n    /// @param withdrawAmount The withdraw tokens amount\\n    /// @return poolWithdrawConversion\\n    function getPoolWithdrawConversion(uint256 withdrawAmount) external view returns (uint256);\\n\\n    /// @notice Pool BNPL token balance\\n    /// @return virtualPoolTokensCount\\n    function virtualPoolTokensCount() external view returns (uint256);\\n\\n    /// @notice Total assets value\\n    /// @return baseTokenBalance\\n    function baseTokenBalance() external view returns (uint256);\\n\\n    /// @notice Returns unstake lockup period\\n    /// @return unstakeLockupPeriod\\n    function getUnstakeLockupPeriod() external pure returns (uint256);\\n\\n    /// @notice Cumulative value of bonded tokens\\n    /// @return tokensBondedAllTime\\n    function tokensBondedAllTime() external view returns (uint256);\\n\\n    /// @notice Pool BNPL token effective supply\\n    /// @return poolTokenEffectiveSupply\\n    function poolTokenEffectiveSupply() external view returns (uint256);\\n\\n    /// @notice Claim node owner BNPL token rewards\\n    /// @return rewards Claimed reward BNPL token amount\\n    function getNodeOwnerBNPLRewards() external view returns (uint256);\\n\\n    /// @notice Claim node owner pool BNPL token rewards\\n    /// @return rewards Claimed reward pool token amount\\n    function getNodeOwnerPoolTokenRewards() external view returns (uint256);\\n\\n    /// @notice Returns pool tokens circulating\\n    /// @return poolTokensCirculating\\n    function poolTokensCirculating() external view returns (uint256);\\n\\n    /// @notice Returns whether the BankNode has been decommissioned\\n    ///\\n    /// - When the liquidity tokens amount of the BankNode is less than minimum BankNode bonded amount, it is decommissioned\\n    ///\\n    /// @return isNodeDecomissioning\\n    function isNodeDecomissioning() external view returns (bool);\\n\\n    /// @notice Claim node owner pool token rewards to address `to`\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"NODE_REWARDS_MANAGER_ROLE\\\"\\n    ///\\n    /// @param to Address to receive rewards\\n    function claimNodeOwnerPoolTokenRewards(address to) external;\\n}\\n\"\r\n    },\r\n    \"src/BankNode/StakingPool/UserTokenLockup.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {IUserTokenLockup} from \\\"../interfaces/IUserTokenLockup.sol\\\";\\n\\ncontract UserTokenLockup is Initializable, IUserTokenLockup {\\n    /// @dev Emitted when user `user` creates a lockup with an index of `vaultIndex` containing `amount` of tokens which can be claimed on `unlockDate`\\n    event LockupCreated(address indexed user, uint32 vaultIndex, uint256 amount, uint64 unlockDate);\\n\\n    /// @dev Emitted when user `user` claims a lockup with an index of `vaultIndex` containing `amount` of tokens\\n    event LockupClaimed(address indexed user, uint256 amount, uint32 vaultIndex);\\n\\n    /// @notice Tokens locked amount\\n    uint256 public override totalTokensLocked;\\n\\n    /// @dev [user address] => [lockup status: Encoded(tokensLocked, currentVaultIndex, numberOfActiveVaults)]\\n    mapping(address => uint256) public encodedLockupStatuses;\\n\\n    /// @dev [user token lockup key: Encoded(user address, vaultIndex)] => [token lockup value: Encoded(tokenAmount, unlockDate)]\\n    mapping(uint256 => uint256) public encodedTokenLockups;\\n\\n    function _UserTokenLockup_init_unchained() internal initializer {}\\n\\n    /// @dev Get current block timestamp\\n    /// @return blockTimestamp\\n    function _getTime() internal view virtual returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /// @dev Should override this function\\n    function _issueUnlockedTokensToUser(\\n        address, /*user*/\\n        uint256 /*amount*/\\n    ) internal virtual returns (uint256) {\\n        require(false, \\\"you must override this function\\\");\\n        return 0;\\n    }\\n\\n    /// @notice Encode user lockup status\\n    ///\\n    /// @param tokensLocked Tokens locked amount\\n    /// @param currentVaultIndex The current vault index\\n    /// @param numberOfActiveVaults The number of activeVaults\\n    /// @return userLockupStatus Encoded user lockup status\\n    function createUserLockupStatus(\\n        uint256 tokensLocked,\\n        uint32 currentVaultIndex,\\n        uint32 numberOfActiveVaults\\n    ) internal pure returns (uint256) {\\n        return (tokensLocked << 64) | (uint256(currentVaultIndex) << 32) | uint256(numberOfActiveVaults);\\n    }\\n\\n    /// @notice Decode an encoded user lockup status\\n    ///\\n    /// @param lockupStatus Encoded user lockup status\\n    /// @return tokensLocked\\n    /// @return currentVaultIndex\\n    /// @return numberOfActiveVaults\\n    function decodeUserLockupStatus(uint256 lockupStatus)\\n        internal\\n        pure\\n        returns (\\n            uint256 tokensLocked,\\n            uint32 currentVaultIndex,\\n            uint32 numberOfActiveVaults\\n        )\\n    {\\n        tokensLocked = lockupStatus >> 64;\\n        currentVaultIndex = uint32((lockupStatus >> 32) & 0xffffffff);\\n        numberOfActiveVaults = uint32(lockupStatus & 0xffffffff);\\n    }\\n\\n    function createTokenLockupKey(address user, uint32 vaultIndex) internal pure returns (uint256) {\\n        return (uint256(uint160(user)) << 32) | uint256(vaultIndex);\\n    }\\n\\n    function decodeTokenLockupKey(uint256 tokenLockupKey) internal pure returns (address user, uint32 vaultIndex) {\\n        vaultIndex = uint32(tokenLockupKey & 0xffffffff);\\n        user = address(uint160(tokenLockupKey >> 32));\\n    }\\n\\n    function createTokenLockupValue(uint256 tokenAmount, uint64 unlockDate) internal pure returns (uint256) {\\n        return (uint256(unlockDate) << 192) | tokenAmount;\\n    }\\n\\n    function decodeTokenLockupValue(uint256 tokenLockupValue)\\n        internal\\n        pure\\n        returns (uint256 tokenAmount, uint64 unlockDate)\\n    {\\n        tokenAmount = tokenLockupValue & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        unlockDate = uint32(tokenLockupValue >> 192);\\n    }\\n\\n    /// @notice Get user lockup status with address `user`\\n    ///\\n    /// @param user The address of user\\n    /// @return tokensLocked\\n    /// @return currentVaultIndex\\n    /// @return numberOfActiveVaults\\n    function userLockupStatus(address user)\\n        public\\n        view\\n        returns (\\n            uint256 tokensLocked,\\n            uint32 currentVaultIndex,\\n            uint32 numberOfActiveVaults\\n        )\\n    {\\n        return decodeUserLockupStatus(encodedLockupStatuses[user]);\\n    }\\n\\n    /// @notice Get user lockup data\\n    ///\\n    /// @param user The address of user\\n    /// @param vaultIndex vault index\\n    /// @return tokenAmount\\n    /// @return unlockDate\\n    function getTokenLockup(address user, uint32 vaultIndex)\\n        public\\n        view\\n        returns (uint256 tokenAmount, uint64 unlockDate)\\n    {\\n        return decodeTokenLockupValue(encodedTokenLockups[createTokenLockupKey(user, vaultIndex)]);\\n    }\\n\\n    /// @notice Get next token lockup for user\\n    ///\\n    /// @param user The address of user\\n    /// @return tokenAmount\\n    /// @return unlockDate\\n    /// @return vaultIndex\\n    function getNextTokenLockupForUser(address user)\\n        external\\n        view\\n        returns (\\n            uint256 tokenAmount,\\n            uint64 unlockDate,\\n            uint32 vaultIndex\\n        )\\n    {\\n        (, uint32 currentVaultIndex, ) = userLockupStatus(user);\\n        vaultIndex = currentVaultIndex;\\n        (tokenAmount, unlockDate) = getTokenLockup(user, currentVaultIndex);\\n    }\\n\\n    function _createTokenLockup(\\n        address user,\\n        uint256 amount,\\n        uint64 unlockDate,\\n        bool allowAddToFutureVault\\n    ) internal returns (uint256) {\\n        require(amount > 0, \\\"amount must be > 0\\\");\\n        require(user != address(0), \\\"cannot create a lockup for a null user\\\");\\n        require(unlockDate > block.timestamp, \\\"cannot create a lockup that expires now or in the past!\\\");\\n\\n        (uint256 tokensLocked, uint32 currentVaultIndex, uint32 numberOfActiveVaults) = userLockupStatus(user);\\n        require(\\n            amount < (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - tokensLocked),\\n            \\\"cannot store this many tokens in the locked contract at once!\\\"\\n        );\\n        tokensLocked += amount;\\n        uint64 futureDate;\\n\\n        if (\\n            numberOfActiveVaults != 0 &&\\n            currentVaultIndex != 0 &&\\n            (futureDate = uint64(encodedTokenLockups[createTokenLockupKey(user, currentVaultIndex)] >> 192)) >=\\n            unlockDate\\n        ) {\\n            require(\\n                allowAddToFutureVault || futureDate == unlockDate,\\n                \\\"allowAddToFutureVault must be enabled to add to future vaults\\\"\\n            );\\n            // if the current vault's date is later than our unlockDate, add the value to it\\n            amount +=\\n                encodedTokenLockups[createTokenLockupKey(user, currentVaultIndex)] &\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n            unlockDate = futureDate;\\n        } else {\\n            currentVaultIndex += 1;\\n            numberOfActiveVaults += 1;\\n        }\\n\\n        totalTokensLocked += amount;\\n\\n        encodedLockupStatuses[user] = createUserLockupStatus(tokensLocked, currentVaultIndex, numberOfActiveVaults);\\n\\n        encodedTokenLockups[createTokenLockupKey(user, currentVaultIndex)] = createTokenLockupValue(amount, unlockDate);\\n\\n        return currentVaultIndex;\\n    }\\n\\n    /// @dev Claim next token lockup\\n    function _claimNextTokenLockup(address user) internal returns (uint256) {\\n        require(user != address(0), \\\"cannot claim for null user\\\");\\n        (uint256 tokensLocked, uint32 currentVaultIndex, uint32 numberOfActiveVaults) = userLockupStatus(user);\\n        currentVaultIndex = currentVaultIndex + 1 - numberOfActiveVaults;\\n\\n        require(tokensLocked > 0 && numberOfActiveVaults > 0 && currentVaultIndex > 0, \\\"user has no tokens locked up!\\\");\\n        (uint256 tokenAmount, uint64 unlockDate) = getTokenLockup(user, currentVaultIndex);\\n        require(tokenAmount > 0 && unlockDate <= _getTime(), \\\"cannot claim tokens that have not matured yet!\\\");\\n        numberOfActiveVaults -= 1;\\n        encodedLockupStatuses[user] = createUserLockupStatus(\\n            tokensLocked - tokenAmount,\\n            numberOfActiveVaults == 0 ? currentVaultIndex : (currentVaultIndex + 1),\\n            numberOfActiveVaults\\n        );\\n        require(totalTokensLocked >= tokenAmount, \\\"not enough tokens locked in the contract!\\\");\\n        totalTokensLocked -= tokenAmount;\\n        _issueUnlockedTokensToUser(user, tokenAmount);\\n        return tokenAmount;\\n    }\\n\\n    /// @dev Claim up to next `N` token lockups\\n    function _claimUpToNextNTokenLockups(address user, uint32 maxNumberOfClaims) internal returns (uint256) {\\n        require(user != address(0), \\\"cannot claim for null user\\\");\\n        require(maxNumberOfClaims > 0, \\\"cannot claim 0 lockups\\\");\\n        (uint256 tokensLocked, uint32 currentVaultIndex, uint32 numberOfActiveVaults) = userLockupStatus(user);\\n        currentVaultIndex = currentVaultIndex + 1 - numberOfActiveVaults;\\n\\n        require(tokensLocked > 0 && numberOfActiveVaults > 0 && currentVaultIndex > 0, \\\"user has no tokens locked up!\\\");\\n        uint256 curTimeShifted = _getTime() << 192;\\n        uint32 maxVaultIndex = (maxNumberOfClaims > numberOfActiveVaults ? numberOfActiveVaults : maxNumberOfClaims) +\\n            currentVaultIndex;\\n        uint256 userShifted = uint256(uint160(user)) << 32;\\n        uint256 totalAmountToClaim = 0;\\n        uint256 nextCandiate;\\n\\n        while (\\n            currentVaultIndex < maxVaultIndex &&\\n            (nextCandiate = encodedTokenLockups[userShifted | uint256(currentVaultIndex)]) < curTimeShifted\\n        ) {\\n            totalAmountToClaim += nextCandiate & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n            currentVaultIndex++;\\n            numberOfActiveVaults--;\\n        }\\n        require(totalAmountToClaim > 0 && currentVaultIndex > 1, \\\"cannot claim nothing!\\\");\\n        require(totalAmountToClaim <= tokensLocked, \\\"cannot claim more than total locked!\\\");\\n        if (numberOfActiveVaults == 0) {\\n            currentVaultIndex--;\\n        }\\n\\n        encodedLockupStatuses[user] = createUserLockupStatus(\\n            tokensLocked - totalAmountToClaim,\\n            currentVaultIndex,\\n            numberOfActiveVaults\\n        );\\n        require(totalTokensLocked >= totalAmountToClaim, \\\"not enough tokens locked in the contract!\\\");\\n        totalTokensLocked -= totalAmountToClaim;\\n        _issueUnlockedTokensToUser(user, totalAmountToClaim);\\n        return totalAmountToClaim;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Management/BNPLKYCStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {ReentrancyGuardUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport {ECDSAUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\\\";\\n\\n/// @title BNPL KYC store contract.\\n///\\n/// @notice\\n/// - Features:\\n///   **Create and store KYC status**\\n///   **Create a KYC bank node**\\n///   **Change the KYC mode**\\n///   **Check the KYC status**\\n///   **Approve or reject the applicant**\\n///\\n/// @author BNPL\\ncontract BNPLKYCStore is Initializable, ReentrancyGuardUpgradeable {\\n    using ECDSAUpgradeable for bytes32;\\n\\n    /// @dev [Domain id] => [KYC public key]\\n    mapping(uint32 => address) public publicKeys;\\n\\n    /// @dev [encode(Domain, User)] => [Permissions]\\n    mapping(uint256 => uint32) public domainPermissions;\\n\\n    /// @dev [encode(Domain, User)] => [KYC status]\\n    mapping(uint256 => uint32) public userKycStatuses;\\n\\n    /// @dev [Proof hash] => [Use status]\\n    mapping(bytes32 => uint8) public proofUsed;\\n\\n    /// @dev [Domain id] => [KYC mode]\\n    mapping(uint32 => uint256) public domainKycMode;\\n\\n    uint32 public constant PROOF_MAGIC = 0xfc203827;\\n    uint32 public constant DOMAIN_ADMIN_PERM = 0xffff;\\n\\n    /// @notice The current number of domains in the KYC store\\n    uint32 public domainCount;\\n\\n    /// @dev Encode KYC domain and user address into a uint256\\n    ///\\n    /// @param domain The domain id\\n    /// @param user The address of user\\n    /// @return KYCUserDomainKey Encoded user domain key\\n    function encodeKYCUserDomainKey(uint32 domain, address user) internal pure returns (uint256) {\\n        return (uint256(uint160(user)) << 32) | uint256(domain);\\n    }\\n\\n    /// @dev Can only be operated by domain admin\\n    modifier onlyDomainAdmin(uint32 domain) {\\n        require(\\n            domainPermissions[encodeKYCUserDomainKey(domain, msg.sender)] == DOMAIN_ADMIN_PERM,\\n            \\\"User must be an admin for this domain to perform this action\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @notice Get domain permissions with domain id and user address\\n    ///\\n    /// @param domain The domain id\\n    /// @param user The address of user\\n    /// @return DomainPermissions User's domain permissions\\n    function getDomainPermissions(uint32 domain, address user) external view returns (uint32) {\\n        return domainPermissions[encodeKYCUserDomainKey(domain, user)];\\n    }\\n\\n    /// @dev Set domain permissions with domain id and user address\\n    function _setDomainPermissions(\\n        uint32 domain,\\n        address user,\\n        uint32 permissions\\n    ) internal {\\n        domainPermissions[encodeKYCUserDomainKey(domain, user)] = permissions;\\n    }\\n\\n    /// @notice Get user's kyc status under domain\\n    ///\\n    /// @param domain The domain id\\n    /// @param user The address of user\\n    /// @return KYCStatusUser User's KYC status\\n    function getKYCStatusUser(uint32 domain, address user) public view returns (uint32) {\\n        return userKycStatuses[encodeKYCUserDomainKey(domain, user)];\\n    }\\n\\n    /// @dev Verify that the operation and signature are valid\\n    function _verifyProof(\\n        uint32 domain,\\n        address user,\\n        uint32 status,\\n        uint256 nonce,\\n        bytes calldata signature\\n    ) internal {\\n        require(domain != 0 && domain <= domainCount, \\\"invalid domain\\\");\\n        require(publicKeys[domain] != address(0), \\\"this domain is disabled\\\");\\n        bytes32 proofHash = getKYCSignatureHash(domain, user, status, nonce);\\n        require(proofHash.toEthSignedMessageHash().recover(signature) == publicKeys[domain], \\\"invalid signature\\\");\\n        require(proofUsed[proofHash] == 0, \\\"proof already used\\\");\\n        proofUsed[proofHash] = 1;\\n    }\\n\\n    /// @dev Set KYC status for user\\n    function _setKYCStatusUser(\\n        uint32 domain,\\n        address user,\\n        uint32 status\\n    ) internal {\\n        userKycStatuses[encodeKYCUserDomainKey(domain, user)] = status;\\n    }\\n\\n    /// @dev Bitwise OR the user's KYC status\\n    function _orKYCStatusUser(\\n        uint32 domain,\\n        address user,\\n        uint32 status\\n    ) internal {\\n        userKycStatuses[encodeKYCUserDomainKey(domain, user)] |= status;\\n    }\\n\\n    /// @notice Create a new KYC store domain\\n    ///\\n    /// @param admin The address of domain admin\\n    /// @param publicKey The KYC domain publicKey\\n    /// @param kycMode The KYC mode\\n    /// @return DomainId The new KYC domain id\\n    function createNewKYCDomain(\\n        address admin,\\n        address publicKey,\\n        uint256 kycMode\\n    ) external returns (uint32) {\\n        require(admin != address(0), \\\"cannot create a kyc domain with an empty user\\\");\\n        uint32 id = domainCount + 1;\\n        domainCount = id;\\n        _setDomainPermissions(id, admin, DOMAIN_ADMIN_PERM);\\n        publicKeys[id] = publicKey;\\n        domainKycMode[id] = kycMode;\\n        return id;\\n    }\\n\\n    /// @notice Set KYC domain public key for domain\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Domain admin\\n    ///\\n    /// @param domain The KYC domain id\\n    /// @param newPublicKey New KYC domain publickey\\n    function setKYCDomainPublicKey(uint32 domain, address newPublicKey) external onlyDomainAdmin(domain) {\\n        publicKeys[domain] = newPublicKey;\\n    }\\n\\n    /// @notice Set KYC mode for domain\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Domain admin\\n    ///\\n    /// @param domain The KYC domain id\\n    /// @param mode The KYC mode\\n    function setKYCDomainMode(uint32 domain, uint256 mode) external onlyDomainAdmin(domain) {\\n        domainKycMode[domain] = mode;\\n    }\\n\\n    /// @notice Check the KYC mode of the user under the specified domain\\n    ///\\n    /// @param domain The KYC domain id\\n    /// @param user The address of user\\n    /// @param mode The KYC mode\\n    /// @return result Return `1` if valid\\n    function checkUserBasicBitwiseMode(\\n        uint32 domain,\\n        address user,\\n        uint256 mode\\n    ) external view returns (uint256) {\\n        require(domain != 0 && domain <= domainCount, \\\"invalid domain\\\");\\n        require(\\n            user != address(0) && ((domainKycMode[domain] & mode) == 0 || (mode & getKYCStatusUser(domain, user) != 0)),\\n            \\\"invalid user permissions\\\"\\n        );\\n        return 1;\\n    }\\n\\n    /// @notice Allow domain admin to set KYC status for user\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Domain admin\\n    ///\\n    /// @param domain The KYC domain id\\n    /// @param user The address of user\\n    /// @param status The status number\\n    function setKYCStatusUser(\\n        uint32 domain,\\n        address user,\\n        uint32 status\\n    ) external onlyDomainAdmin(domain) {\\n        _setKYCStatusUser(domain, user, status);\\n    }\\n\\n    /// @notice Returns KYC signature (encoded data)\\n    ///\\n    /// @param domain The KYC domain id\\n    /// @param user The address of user\\n    /// @param status The status number\\n    /// @param nonce The nonce\\n    /// @return KYCSignaturePayload The KYC signature (encoded data)\\n    function getKYCSignaturePayload(\\n        uint32 domain,\\n        address user,\\n        uint32 status,\\n        uint256 nonce\\n    ) public pure returns (bytes memory) {\\n        return (\\n            abi.encode(\\n                ((uint256(PROOF_MAGIC) << 224) |\\n                    (uint256(uint160(user)) << 64) |\\n                    (uint256(domain) << 32) |\\n                    uint256(status)),\\n                nonce\\n            )\\n        );\\n    }\\n\\n    /// @notice Returns KYC signature (keccak256 hash)\\n    ///\\n    /// @param domain The KYC domain id\\n    /// @param user The address of user\\n    /// @param status The status number\\n    /// @param nonce The nonce\\n    /// @return KYCSignatureHash The KYC signature (keccak256 hash)\\n    function getKYCSignatureHash(\\n        uint32 domain,\\n        address user,\\n        uint32 status,\\n        uint256 nonce\\n    ) public pure returns (bytes32) {\\n        return keccak256(getKYCSignaturePayload(domain, user, status, nonce));\\n    }\\n\\n    /// @notice Bitwise OR the user's KYC status\\n    ///\\n    /// - SIGNATURE REQUIRED:\\n    ///     Domain admin\\n    ///\\n    /// @param domain The KYC domain id\\n    /// @param user The address of user\\n    /// @param status The status number to bitwise OR\\n    /// @param nonce The nonce\\n    /// @param signature The domain admin signature (proof)\\n    function orKYCStatusWithProof(\\n        uint32 domain,\\n        address user,\\n        uint32 status,\\n        uint256 nonce,\\n        bytes calldata signature\\n    ) external {\\n        _verifyProof(domain, user, status, nonce, signature);\\n        _orKYCStatusUser(domain, user, status);\\n    }\\n\\n    /// @notice Clear KYC status for user\\n    ///\\n    /// - SIGNATURE REQUIRED:\\n    ///     Domain admin\\n    ///\\n    /// @param domain The KYC domain id\\n    /// @param user The address of user\\n    /// @param nonce The nonce\\n    /// @param signature The domain admin signature (proof)\\n    function clearKYCStatusWithProof(\\n        uint32 domain,\\n        address user,\\n        uint256 nonce,\\n        bytes calldata signature\\n    ) external {\\n        _verifyProof(domain, user, 1, nonce, signature);\\n        _setKYCStatusUser(domain, user, 1);\\n    }\\n\\n    /// @dev This contract is called through the proxy.\\n    function initialize() external initializer nonReentrant {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/BankNode/lib/BankNodeUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {PRBMathUD60x18} from \\\"../../Utils/Math/PRBMathUD60x18.sol\\\";\\n\\n/// @dev BNPL bank node mathematical calculation tools\\n/// @author BNPL\\nlibrary BankNodeUtils {\\n    using PRBMathUD60x18 for uint256;\\n\\n    /// @notice The wETH contract address (ERC20 tradable version of ETH)\\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @notice Calculate slash amount\\n    ///\\n    /// @param prevNodeBalance Previous bank node balance\\n    /// @param nodeLoss The loss amount of bank node\\n    /// @param poolBalance The staking pool balance of bank node\\n    /// @return slashAmount\\n    function calculateSlashAmount(\\n        uint256 prevNodeBalance,\\n        uint256 nodeLoss,\\n        uint256 poolBalance\\n    ) internal pure returns (uint256) {\\n        uint256 slashRatio = (nodeLoss * PRBMathUD60x18.scale()).div(prevNodeBalance * PRBMathUD60x18.scale());\\n        return (poolBalance * slashRatio) / PRBMathUD60x18.scale();\\n    }\\n\\n    /// @notice Calculate monthly interest payment\\n    ///\\n    /// @param loanAmount Amount of loan\\n    /// @param interestAmount Interest rate per payment\\n    /// @param numberOfPayments The number of payments\\n    /// @param currentMonth Number of payments made\\n    /// @return monthlyInterestPayment\\n    function getMonthlyInterestPayment(\\n        uint256 loanAmount,\\n        uint256 interestAmount,\\n        uint256 numberOfPayments,\\n        uint256 currentMonth\\n    ) internal pure returns (uint256) {\\n        return\\n            (loanAmount *\\n                getPrincipleForMonth(interestAmount, numberOfPayments, currentMonth - 1).mul(interestAmount)) /\\n            PRBMathUD60x18.scale();\\n    }\\n\\n    /// @notice Calculate principle for month\\n    ///\\n    /// @param interestAmount Interest rate per payment\\n    /// @param numberOfPayments The number of payments\\n    /// @param currentMonth Number of payments made\\n    /// @return principleForMonth\\n    function getPrincipleForMonth(\\n        uint256 interestAmount,\\n        uint256 numberOfPayments,\\n        uint256 currentMonth\\n    ) internal pure returns (uint256) {\\n        uint256 ip1m = (PRBMathUD60x18.scale() + interestAmount).pow(currentMonth);\\n        uint256 right = getPaymentMultiplier(interestAmount, numberOfPayments).mul(\\n            (ip1m - PRBMathUD60x18.scale()).div(interestAmount)\\n        );\\n        return ip1m - right;\\n    }\\n\\n    /// @notice Calculate monthly payment\\n    ///\\n    /// @param loanAmount Amount of loan\\n    /// @param interestAmount Interest rate per payment\\n    /// @param numberOfPayments The number of payments\\n    /// @return monthlyPayment\\n    function getMonthlyPayment(\\n        uint256 loanAmount,\\n        uint256 interestAmount,\\n        uint256 numberOfPayments\\n    ) internal pure returns (uint256) {\\n        return (loanAmount * getPaymentMultiplier(interestAmount, numberOfPayments)) / PRBMathUD60x18.scale();\\n    }\\n\\n    /// @notice Calculate payment multiplier\\n    ///\\n    /// @param interestAmount Interest rate per payment\\n    /// @param numberOfPayments The number of payments\\n    /// @return paymentMultiplier\\n    function getPaymentMultiplier(uint256 interestAmount, uint256 numberOfPayments) internal pure returns (uint256) {\\n        uint256 ip1n = (PRBMathUD60x18.scale() + interestAmount).pow(numberOfPayments);\\n        uint256 result = interestAmount.mul(ip1n).div((ip1n - PRBMathUD60x18.scale()));\\n        return result;\\n    }\\n\\n    /// @dev Sushiswap exact tokens path (join wETH in the middle)\\n    ///\\n    /// @param tokenIn input token address\\n    /// @param tokenOut output token address\\n    /// @return swapExactTokensPath\\n    function getSwapExactTokensPath(address tokenIn, address tokenOut) internal pure returns (address[] memory) {\\n        address[] memory path = new address[](3);\\n        path[0] = address(tokenIn);\\n        path[1] = WETH;\\n        path[2] = address(tokenOut);\\n        return path;\\n    }\\n\\n    /// @dev Returns the smallest of two numbers.\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Utils/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\\"approve(address,uint256)\\\")));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeApprove: approve failed\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeTransfer: transfer failed\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\\"transferFrom(address,address,uint256)\\\")));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::transferFrom: transferFrom failed\\\"\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\\"TransferHelper::safeTransferETH: ETH transfer failed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Utils/Math/PRBMathUD60x18.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\npragma solidity >=0.8.0;\\n\\nimport \\\"./PRBMathCommon.sol\\\";\\n\\n/// @title PRBMathUD60x18\\n/// @author Paul Razvan Berg\\n/// @notice Smart contract library for advanced fixed-point math. It works with uint256 numbers considered to have 18\\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\\n/// maximum values permitted by the Solidity type uint256.\\nlibrary PRBMathUD60x18 {\\n    /// @dev Half the SCALE number.\\n    uint256 internal constant HALF_SCALE = 5e17;\\n\\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\\n    uint256 internal constant LOG2_E = 1442695040888963407;\\n\\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_UD60x18 = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_WHOLE_UD60x18 = 115792089237316195423570985008687907853269984665640564039457000000000000000000;\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @notice Calculates arithmetic average of x and y, rounding down.\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The arithmetic average as an usigned 60.18-decimal fixed-point number.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // The operations can never overflow.\\n        unchecked {\\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\\n        }\\n    }\\n\\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\\n    ///\\n    /// @dev Optimised for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function ceil(uint256 x) internal pure returns (uint256 result) {\\n        require(x <= MAX_WHOLE_UD60x18);\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"SCALE - remainder\\\" but faster.\\n            let delta := sub(SCALE, remainder)\\n\\n            // Equivalent to \\\"x + delta * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := add(x, mul(delta, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\\n    ///\\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\\n    ///\\n    /// Requirements:\\n    /// - y cannot be zero.\\n    ///\\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMathCommon.mulDiv(x, SCALE, y);\\n    }\\n\\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\\n    function e() internal pure returns (uint256 result) {\\n        result = 2718281828459045235;\\n    }\\n\\n    /// @notice Calculates the natural exponent of x.\\n    ///\\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    /// - x must be less than 88722839111672999628.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp(uint256 x) internal pure returns (uint256 result) {\\n        // Without this check, the value passed to \\\"exp2\\\" would be greater than 128e18.\\n        require(x < 88722839111672999628);\\n\\n        // Do the fixed-point multiplication inline to save gas.\\n        unchecked {\\n            uint256 doubleScaleProduct = x * LOG2_E;\\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\\n        }\\n    }\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    ///\\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\n    ///\\n    /// Requirements:\\n    /// - x must be 128e18 or less.\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        // 2**128 doesn't fit within the 128.128-bit format used internally in this function.\\n        require(x < 128e18);\\n\\n        unchecked {\\n            // Convert x to the 128.128-bit fixed-point format.\\n            uint256 x128x128 = (x << 128) / SCALE;\\n\\n            // Pass x to the PRBMathCommon.exp2 function, which uses the 128.128-bit fixed-point number representation.\\n            result = PRBMathCommon.exp2(x128x128);\\n        }\\n    }\\n\\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\\n    /// @dev Optimised for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function floor(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"x - remainder * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := sub(x, mul(remainder, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Yields the excess beyond the floor of x.\\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\\n    function frac(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mod(x, SCALE)\\n        }\\n    }\\n\\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\\n    ///\\n    /// @dev Requirements:\\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\\n    ///\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        unchecked {\\n            // Checking for overflow this way is faster than letting Solidity do it.\\n            uint256 xy = x * y;\\n            require(xy / x == y);\\n\\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\\n            // during multiplication. See the comments within the \\\"sqrt\\\" function.\\n            result = PRBMathCommon.sqrt(xy);\\n        }\\n    }\\n\\n    /// @notice Calculates 1 / x, rounding towards zero.\\n    ///\\n    /// @dev Requirements:\\n    /// - x cannot be zero.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\\n    function inv(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 1e36 is SCALE * SCALE.\\n            result = 1e36 / x;\\n        }\\n    }\\n\\n    /// @notice Calculates the natural logarithm of x.\\n    ///\\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    /// - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function ln(uint256 x) internal pure returns (uint256 result) {\\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\\n        // can return is 196205294292027477728.\\n        unchecked { result = (log2(x) * SCALE) / LOG2_E; }\\n    }\\n\\n    /// @notice Calculates the common logarithm of x.\\n    ///\\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log10(uint256 x) internal pure returns (uint256 result) {\\n        require(x >= SCALE);\\n\\n        // Note that the \\\"mul\\\" in this block is the assembly mul operation, not the \\\"mul\\\" function defined in this contract.\\n        // prettier-ignore\\n        assembly {\\n            switch x\\n            case 1 { result := mul(SCALE, sub(0, 18)) }\\n            case 10 { result := mul(SCALE, sub(1, 18)) }\\n            case 100 { result := mul(SCALE, sub(2, 18)) }\\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\\n            case 1000000000000000000 { result := 0 }\\n            case 10000000000000000000 { result := SCALE }\\n            case 100000000000000000000 { result := mul(SCALE, 2) }\\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\\n            default {\\n                result := MAX_UD60x18\\n            }\\n        }\\n\\n        if (result == MAX_UD60x18) {\\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\\n            unchecked { result = (log2(x) * SCALE) / 332192809488736234; }\\n        }\\n    }\\n\\n    /// @notice Calculates the binary logarithm of x.\\n    ///\\n    /// @dev Based on the iterative approximation algorithm.\\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n    ///\\n    /// Caveats:\\n    /// - The results are nor perfectly accurate to the last digit, due to the lossy precision of the iterative approximation.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log2(uint256 x) internal pure returns (uint256 result) {\\n        require(x >= SCALE);\\n        unchecked {\\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n            uint256 n = PRBMathCommon.mostSignificantBit(x / SCALE);\\n\\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\\n            // because n is maximum 255 and SCALE is 1e18.\\n            result = n * SCALE;\\n\\n            // This is y = x * 2^(-n).\\n            uint256 y = x >> n;\\n\\n            // If y = 1, the fractional part is zero.\\n            if (y == SCALE) {\\n                return result;\\n            }\\n\\n            // Calculate the fractional part via the iterative approximation.\\n            // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\\n                y = (y * y) / SCALE;\\n\\n                // Is y^2 > 2 and so in the range [2,4)?\\n                if (y >= 2 * SCALE) {\\n                    // Add the 2^(-m) factor to the logarithm.\\n                    result += delta;\\n\\n                    // Corresponds to z/2 on Wikipedia.\\n                    y >>= 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\\n    /// fixed-point number.\\n    /// @dev See the documentation for the \\\"PRBMathCommon.mulDivFixedPoint\\\" function.\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMathCommon.mulDivFixedPoint(x, y);\\n    }\\n\\n    /// @notice Retrieves PI as an unsigned 60.18-decimal fixed-point number.\\n    function pi() internal pure returns (uint256 result) {\\n        result = 3141592653589793238;\\n    }\\n\\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\\n    /// famous algorithm \\\"exponentiation by squaring\\\".\\n    ///\\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The exponent as an uint256.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // Calculate the first iteration of the loop in advance.\\n        result = y & 1 > 0 ? x : SCALE;\\n\\n        // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\n        for (y >>= 1; y > 0; y >>= 1) {\\n            x = mul(x, x);\\n\\n            // Equivalent to \\\"y % 2 == 1\\\" but faster.\\n            if (y & 1 > 0) {\\n                result = mul(result, x);\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\\n    function scale() internal pure returns (uint256 result) {\\n        result = SCALE;\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than MAX_UD60x18 / SCALE.\\n    ///\\n    /// Caveats:\\n    /// - The maximum fixed-point number permitted is 115792089237316195423570985008687907853269.984665640564039458.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        require(x < 115792089237316195423570985008687907853269984665640564039458);\\n        unchecked {\\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\\n            result = PRBMathCommon.sqrt(x * SCALE);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlUpgradeable.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlUpgradeable.sol\\\";\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\\n    function __AccessControl_init() internal onlyInitializing {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __AccessControl_init_unchained();\\n    }\\n\\n    function __AccessControl_init_unchained() internal onlyInitializing {\\n    }\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        StringsUpgradeable.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        StringsUpgradeable.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n        __ERC165_init_unchained();\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"src/ERC20/interfaces/IGenericMintableTo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IGenericMintableTo {\\n    function mint(address to, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/ERC20/interfaces/IGenericBurnableFrom.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IGenericBurnableFrom {\\n    function burn(uint256 amount) external;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/ProtocolDeploy/interfaces/IBNPLProtocolConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {UpgradeableBeacon} from \\\"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IBankNodeManager} from \\\"../../Management/interfaces/IBankNodeManager.sol\\\";\\nimport {BNPLKYCStore} from \\\"../../Management/BNPLKYCStore.sol\\\";\\n\\n/// @title BNPL Protocol configuration contract\\n///\\n/// @notice\\n/// - Include:\\n///     **Network Info**\\n///     **BNPL token contracts**\\n///     **BNPL UpBeacon contracts**\\n///     **BNPL BankNodeManager contract**\\n///\\n/// @author BNPL\\ninterface IBNPLProtocolConfig {\\n    /// @notice Returns blockchain network id\\n    /// @return networkId blockchain network id\\n    function networkId() external view returns (uint64);\\n\\n    /// @notice Returns blockchain network name\\n    /// @return networkName blockchain network name\\n    function networkName() external view returns (string memory);\\n\\n    /// @notice Returns BNPL token address\\n    /// @return bnplToken BNPL token contract\\n    function bnplToken() external view returns (IERC20);\\n\\n    /// @notice Returns bank node manager upBeacon contract\\n    /// @return upBeaconBankNodeManager bank node manager upBeacon contract\\n    function upBeaconBankNodeManager() external view returns (UpgradeableBeacon);\\n\\n    /// @notice Returns bank node upBeacon contract\\n    /// @return upBeaconBankNode bank node upBeacon contract\\n    function upBeaconBankNode() external view returns (UpgradeableBeacon);\\n\\n    /// @notice Returns bank node lending pool token upBeacon contract\\n    /// @return upBeaconBankNodeLendingPoolToken bank node lending pool token upBeacon contract\\n    function upBeaconBankNodeLendingPoolToken() external view returns (UpgradeableBeacon);\\n\\n    /// @notice Returns bank node staking pool upBeacon contract\\n    /// @return upBeaconBankNodeStakingPool bank node staking pool upBeacon contract\\n    function upBeaconBankNodeStakingPool() external view returns (UpgradeableBeacon);\\n\\n    /// @notice Returns bank node staking pool token upBeacon contract\\n    /// @return upBeaconBankNodeStakingPoolToken bank node staking pool token upBeacon contract\\n    function upBeaconBankNodeStakingPoolToken() external view returns (UpgradeableBeacon);\\n\\n    /// @notice Returns bank node lending rewards upBeacon contract\\n    /// @return upBeaconBankNodeLendingRewards bank node lending rewards upBeacon contract\\n    function upBeaconBankNodeLendingRewards() external view returns (UpgradeableBeacon);\\n\\n    /// @notice Returns BNPL KYC store upBeacon contract\\n    /// @return upBeaconBNPLKYCStore BNPL KYC store upBeacon contract\\n    function upBeaconBNPLKYCStore() external view returns (UpgradeableBeacon);\\n\\n    /// @notice Returns BankNodeManager contract\\n    /// @return bankNodeManager BankNodeManager contract\\n    function bankNodeManager() external view returns (IBankNodeManager);\\n}\\n\"\r\n    },\r\n    \"src/Rewards/PlatformRewards/BankNodeLendingRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/* Borrowed heavily from Synthetix\\n\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 Synthetix\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n*/\\npragma solidity ^0.8.0;\\n\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IBankNodeManager} from \\\"../../Management/interfaces/IBankNodeManager.sol\\\";\\n\\nimport {BankNodeRewardSystem} from \\\"./BankNodeRewardSystem.sol\\\";\\n\\n/// @title BNPL bank node lending rewards contract\\n///\\n/// @notice\\n/// - Features:\\n///     - Users:\\n///       **Stake**\\n///       **Withdraw**\\n///       **GetReward**\\n///     - Manager:\\n///       **SetRewardsDuration**\\n///     - Distributor:\\n///       **distribute BNPL tokens to BankNodes**\\n///\\n/// @author BNPL\\ncontract BankNodeLendingRewards is Initializable, BankNodeRewardSystem {\\n    using SafeERC20 for IERC20;\\n\\n    /// @dev This contract is called through the proxy.\\n    ///\\n    /// @param _defaultRewardsDuration The default reward duration (secs)\\n    /// @param _rewardsToken The address of the BNPL token\\n    /// @param _bankNodeManager The address of the BankNodeManagerProxy\\n    /// @param distributorAdmin The address of the distributor admin\\n    /// @param managerAdmin The address of the manager admin\\n    function initialize(\\n        uint256 _defaultRewardsDuration,\\n        address _rewardsToken,\\n        address _bankNodeManager,\\n        address distributorAdmin,\\n        address managerAdmin\\n    ) external initializer {\\n        __ReentrancyGuard_init_unchained();\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n        __ERC165_init_unchained();\\n        __AccessControl_init_unchained();\\n        rewardsToken = IERC20(_rewardsToken);\\n        bankNodeManager = IBankNodeManager(_bankNodeManager);\\n        defaultRewardsDuration = _defaultRewardsDuration;\\n\\n        _setupRole(REWARDS_DISTRIBUTOR_ROLE, _bankNodeManager);\\n        _setupRole(REWARDS_DISTRIBUTOR_ROLE, distributorAdmin);\\n        _setupRole(REWARDS_DISTRIBUTOR_ADMIN_ROLE, distributorAdmin);\\n        _setRoleAdmin(REWARDS_DISTRIBUTOR_ROLE, REWARDS_DISTRIBUTOR_ADMIN_ROLE);\\n\\n        _setupRole(REWARDS_MANAGER, _bankNodeManager);\\n        _setupRole(REWARDS_MANAGER, managerAdmin);\\n        _setupRole(REWARDS_MANAGER_ROLE_ADMIN, managerAdmin);\\n        _setRoleAdmin(REWARDS_MANAGER, REWARDS_MANAGER_ROLE_ADMIN);\\n    }\\n\\n    /// @dev Get the amount of tokens staked by the node\\n    function _bnplTokensStakedToBankNode(uint32 bankNodeId) internal view returns (uint256) {\\n        return\\n            rewardsToken.balanceOf(\\n                _ensureContractAddressNot0(bankNodeManager.getBankNodeStakingPoolContract(bankNodeId))\\n            );\\n    }\\n\\n    /// @notice Get the amount of rewards that can be allocated by all bank nodes\\n    ///\\n    /// @param amount The distribute BNPL tokens amount\\n    /// @return bnplTokensPerNode BNPL tokens amount per node\\n    function getBNPLTokenDistribution(uint256 amount) external view returns (uint256[] memory) {\\n        uint32 nodeCount = bankNodeManager.bankNodeCount();\\n        uint256[] memory bnplTokensPerNode = new uint256[](nodeCount);\\n        uint32 i = 0;\\n        uint256 amt = 0;\\n        uint256 total = 0;\\n        while (i < nodeCount) {\\n            amt = rewardsToken.balanceOf(\\n                _ensureContractAddressNot0(bankNodeManager.getBankNodeStakingPoolContract(i + 1))\\n            );\\n            bnplTokensPerNode[i] = amt;\\n            total += amt;\\n            i += 1;\\n        }\\n        i = 0;\\n        while (i < nodeCount) {\\n            bnplTokensPerNode[i] = (bnplTokensPerNode[i] * amount) / total;\\n            i += 1;\\n        }\\n        return bnplTokensPerNode;\\n    }\\n\\n    /// @notice Distribute rewards to all bank nodes (Method 1)\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"REWARDS_DISTRIBUTOR_ROLE\\\"\\n    ///\\n    /// @param amount The distribute BNPL tokens amount\\n    /// @return total Total Rewards\\n    function distributeBNPLTokensToBankNodes(uint256 amount)\\n        external\\n        onlyRole(REWARDS_DISTRIBUTOR_ROLE)\\n        returns (uint256)\\n    {\\n        require(amount > 0, \\\"cannot send 0\\\");\\n        rewardsToken.safeTransferFrom(msg.sender, address(this), amount);\\n        uint32 nodeCount = bankNodeManager.bankNodeCount();\\n        uint256[] memory bnplTokensPerNode = new uint256[](nodeCount);\\n        uint32 i = 0;\\n        uint256 amt = 0;\\n        uint256 total = 0;\\n        while (i < nodeCount) {\\n            if (getPoolLiquidityTokensStakedInRewards(i + 1) != 0) {\\n                amt = rewardsToken.balanceOf(\\n                    _ensureContractAddressNot0(bankNodeManager.getBankNodeStakingPoolContract(i + 1))\\n                );\\n                bnplTokensPerNode[i] = amt;\\n                total += amt;\\n            }\\n            i += 1;\\n        }\\n        i = 0;\\n        while (i < nodeCount) {\\n            amt = (bnplTokensPerNode[i] * amount) / total;\\n            if (amt != 0) {\\n                _notifyRewardAmount(i + 1, amt);\\n            }\\n            i += 1;\\n        }\\n        return total;\\n    }\\n\\n    /// @notice Distribute rewards to all bank nodes (Method 2)\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"REWARDS_DISTRIBUTOR_ROLE\\\"\\n    ///\\n    /// @param amount The distribute BNPL tokens amount\\n    /// @return total Total Rewards\\n    function distributeBNPLTokensToBankNodes2(uint256 amount)\\n        external\\n        onlyRole(REWARDS_DISTRIBUTOR_ROLE)\\n        returns (uint256)\\n    {\\n        uint32 nodeCount = bankNodeManager.bankNodeCount();\\n        uint32 i = 0;\\n        uint256 amt = 0;\\n        uint256 total = 0;\\n        while (i < nodeCount) {\\n            total += rewardsToken.balanceOf(\\n                _ensureContractAddressNot0(bankNodeManager.getBankNodeStakingPoolContract(i + 1))\\n            );\\n            i += 1;\\n        }\\n        i = 0;\\n        while (i < nodeCount) {\\n            amt =\\n                (rewardsToken.balanceOf(\\n                    _ensureContractAddressNot0(bankNodeManager.getBankNodeStakingPoolContract(i + 1))\\n                ) * amount) /\\n                total;\\n            if (amt != 0) {\\n                _notifyRewardAmount(i + 1, amt);\\n            }\\n            i += 1;\\n        }\\n        return total;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"../../access/Ownable.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\\n * implementation contract, which is where they will delegate all function calls.\\n *\\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\\n */\\ncontract UpgradeableBeacon is IBeacon, Ownable {\\n    address private _implementation;\\n\\n    /**\\n     * @dev Emitted when the implementation returned by the beacon is changed.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\\n     * beacon.\\n     */\\n    constructor(address implementation_) {\\n        _setImplementation(implementation_);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function implementation() public view virtual override returns (address) {\\n        return _implementation;\\n    }\\n\\n    /**\\n     * @dev Upgrades the beacon to a new implementation.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * Requirements:\\n     *\\n     * - msg.sender must be the owner of the contract.\\n     * - `newImplementation` must be a contract.\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Sets the implementation contract address for this beacon\\n     *\\n     * Requirements:\\n     *\\n     * - `newImplementation` must be a contract.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"UpgradeableBeacon: implementation is not a contract\\\");\\n        _implementation = newImplementation;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../StringsUpgradeable.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSAUpgradeable {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", StringsUpgradeable.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Rewards/PlatformRewards/BankNodeRewardSystem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/* Borrowed heavily from Synthetix\\n\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 Synthetix\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n*/\\npragma solidity ^0.8.0;\\n\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {PausableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport {ReentrancyGuardUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport {AccessControlUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IBankNodeManager} from \\\"../../Management/interfaces/IBankNodeManager.sol\\\";\\n\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/// @title BNPL bank node lending reward system contract\\n///\\n/// @dev This contract is inherited by the `BankNodeLendingRewards` contract\\n/// @notice\\n/// - Users:\\n///   **Stake**\\n///   **Withdraw**\\n///   **GetReward**\\n/// - Manager:\\n///   **SetRewardsDuration**\\n/// - Distributor:\\n///   **distribute BNPL tokens to BankNodes**\\n///\\n/// @author BNPL\\ncontract BankNodeRewardSystem is\\n    Initializable,\\n    ReentrancyGuardUpgradeable,\\n    PausableUpgradeable,\\n    AccessControlUpgradeable\\n{\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    bytes32 public constant REWARDS_DISTRIBUTOR_ROLE = keccak256(\\\"REWARDS_DISTRIBUTOR_ROLE\\\");\\n    bytes32 public constant REWARDS_DISTRIBUTOR_ADMIN_ROLE = keccak256(\\\"REWARDS_DISTRIBUTOR_ADMIN_ROLE\\\");\\n\\n    bytes32 public constant REWARDS_MANAGER = keccak256(\\\"REWARDS_MANAGER_ROLE\\\");\\n    bytes32 public constant REWARDS_MANAGER_ROLE_ADMIN = keccak256(\\\"REWARDS_MANAGER_ROLE_ADMIN\\\");\\n\\n    /// @notice [Bank node id] => [Previous rewards period]\\n    mapping(uint32 => uint256) public periodFinish;\\n\\n    /// @notice [Bank node id] => [Reward rate]\\n    mapping(uint32 => uint256) public rewardRate;\\n\\n    /// @notice [Bank node id] => [Rewards duration]\\n    mapping(uint32 => uint256) public rewardsDuration;\\n\\n    /// @notice [Bank node id] => [Rewards last update time]\\n    mapping(uint32 => uint256) public lastUpdateTime;\\n\\n    /// @notice [Bank node id] => [Reward per token stored]\\n    mapping(uint32 => uint256) public rewardPerTokenStored;\\n\\n    /// @notice [Encoded user bank node key (user, bankNodeId)] => [Reward per token paid]\\n    mapping(uint256 => uint256) public userRewardPerTokenPaid;\\n\\n    /// @notice [Encoded user bank node key (user, bankNodeId)] => [Rewards amount]\\n    mapping(uint256 => uint256) public rewards;\\n\\n    /// @notice [Bank node id] => [Stake amount]\\n    mapping(uint32 => uint256) public _totalSupply;\\n\\n    /// @notice [Encoded user bank node key (user, bankNodeId)] => [Staked balance]\\n    mapping(uint256 => uint256) private _balances;\\n\\n    /// @notice BNPL bank node manager contract\\n    IBankNodeManager public bankNodeManager;\\n\\n    /// @notice Rewards token contract\\n    IERC20 public rewardsToken;\\n\\n    /// @notice Default rewards duration (secs)\\n    uint256 public defaultRewardsDuration;\\n\\n    /// @dev Encode user address and bank node id into a uint256.\\n    ///\\n    /// @param user The address of user\\n    /// @param bankNodeId The id of the bank node\\n    /// @return encodedUserBankNodeKey The encoded user bank node key.\\n    function encodeUserBankNodeKey(address user, uint32 bankNodeId) public pure returns (uint256) {\\n        return (uint256(uint160(user)) << 32) | uint256(bankNodeId);\\n    }\\n\\n    /// @dev Decode user bank node key to user address and bank node id.\\n    ///\\n    /// @param stakingVaultKey The user bank node key\\n    /// @return user The address of user\\n    /// @return bankNodeId The id of the bank node\\n    function decodeUserBankNodeKey(uint256 stakingVaultKey) external pure returns (address user, uint32 bankNodeId) {\\n        bankNodeId = uint32(stakingVaultKey & 0xffffffff);\\n        user = address(uint160(stakingVaultKey >> 32));\\n    }\\n\\n    /// @dev Encode amount and depositTime into a uint256.\\n    ///\\n    /// @param amount An uint256 amount\\n    /// @param depositTime An uint40 deposit time\\n    /// @return encodedVaultValue The encoded vault value\\n    function encodeVaultValue(uint256 amount, uint40 depositTime) external pure returns (uint256) {\\n        require(\\n            amount <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff,\\n            \\\"cannot encode amount larger than 2^216-1\\\"\\n        );\\n        return (amount << 40) | uint256(depositTime);\\n    }\\n\\n    /// @notice Decode vault value to amount and depositTime\\n    ///\\n    /// @param vaultValue The encoded vault value\\n    /// @return amount An `uint256` amount\\n    /// @return depositTime An `uint40` deposit time\\n    function decodeVaultValue(uint256 vaultValue) external pure returns (uint256 amount, uint40 depositTime) {\\n        depositTime = uint40(vaultValue & 0xffffffffff);\\n        amount = vaultValue >> 40;\\n    }\\n\\n    /// @dev Ensure the given address not zero and return it as IERC20\\n    /// @return ERC20Token\\n    function _ensureAddressIERC20Not0(address tokenAddress) internal pure returns (IERC20) {\\n        require(tokenAddress != address(0), \\\"invalid token address!\\\");\\n        return IERC20(tokenAddress);\\n    }\\n\\n    /// @dev Ensure the given address not zero\\n    /// @return Address\\n    function _ensureContractAddressNot0(address contractAddress) internal pure returns (address) {\\n        require(contractAddress != address(0), \\\"invalid token address!\\\");\\n        return contractAddress;\\n    }\\n\\n    /// @dev Get the lending pool token contract (ERC20) address of the specified bank node\\n    ///\\n    /// @param bankNodeId The id of the bank node\\n    /// @return BankNodeTokenContract The lending pool token contract (ERC20)\\n    function getStakingTokenForBankNode(uint32 bankNodeId) internal view returns (IERC20) {\\n        return _ensureAddressIERC20Not0(bankNodeManager.getBankNodeToken(bankNodeId));\\n    }\\n\\n    /// @notice Get the lending pool token amount in rewards of the specified bank node\\n    ///\\n    /// @param bankNodeId The id of the bank node\\n    /// @return BankNodeTokenBalanceInRewards The lending pool token balance in rewards\\n    function getPoolLiquidityTokensStakedInRewards(uint32 bankNodeId) public view returns (uint256) {\\n        return getStakingTokenForBankNode(bankNodeId).balanceOf(address(this));\\n    }\\n\\n    /// @dev Returns the input `amount`\\n    function getInternalValueForStakedTokenAmount(uint256 amount) internal pure returns (uint256) {\\n        return amount;\\n    }\\n\\n    /// @dev Returns the input `amount`\\n    function getStakedTokenAmountForInternalValue(uint256 amount) internal pure returns (uint256) {\\n        return amount;\\n    }\\n\\n    /// @notice Get the stake amount of the specified bank node\\n    ///\\n    /// @param bankNodeId The id of the bank node\\n    /// @return TotalSupply The stake amount\\n    function totalSupply(uint32 bankNodeId) external view returns (uint256) {\\n        return getStakedTokenAmountForInternalValue(_totalSupply[bankNodeId]);\\n    }\\n\\n    /// @notice Get the user's staked balance under the specified bank node\\n    ///\\n    /// @param account User address\\n    /// @param bankNodeId The id of the bank node\\n    /// @return StakedBalance User's staked balance\\n    function balanceOf(address account, uint32 bankNodeId) external view returns (uint256) {\\n        return getStakedTokenAmountForInternalValue(_balances[encodeUserBankNodeKey(account, bankNodeId)]);\\n    }\\n\\n    /// @notice Get the last time reward applicable of the specified bank node\\n    ///\\n    /// @param bankNodeId The id of the bank node\\n    /// @return lastTimeRewardApplicable The last time reward applicable\\n    function lastTimeRewardApplicable(uint32 bankNodeId) public view returns (uint256) {\\n        return block.timestamp < periodFinish[bankNodeId] ? block.timestamp : periodFinish[bankNodeId];\\n    }\\n\\n    /// @notice Get reward amount with bank node id\\n    ///\\n    /// @param bankNodeId The id of the bank node\\n    /// @return rewardPerToken Reward per token amount\\n    function rewardPerToken(uint32 bankNodeId) public view returns (uint256) {\\n        if (_totalSupply[bankNodeId] == 0) {\\n            return rewardPerTokenStored[bankNodeId];\\n        }\\n        return\\n            rewardPerTokenStored[bankNodeId].add(\\n                lastTimeRewardApplicable(bankNodeId)\\n                    .sub(lastUpdateTime[bankNodeId])\\n                    .mul(rewardRate[bankNodeId])\\n                    .mul(1e18)\\n                    .div(_totalSupply[bankNodeId])\\n            );\\n    }\\n\\n    /// @notice Get the benefits earned by users in the bank node\\n    ///\\n    /// @param account The user address\\n    /// @param bankNodeId The id of the bank node\\n    /// @return Earnd Benefits earned by users in the bank node\\n    function earned(address account, uint32 bankNodeId) public view returns (uint256) {\\n        uint256 key = encodeUserBankNodeKey(account, bankNodeId);\\n        return\\n            ((_balances[key] * (rewardPerToken(bankNodeId) - (userRewardPerTokenPaid[key]))) / 1e18) + (rewards[key]);\\n    }\\n\\n    /// @notice Get bank node reward for duration\\n    ///\\n    /// @param bankNodeId The id of the bank node\\n    /// @return RewardForDuration Bank node reward for duration\\n    function getRewardForDuration(uint32 bankNodeId) external view returns (uint256) {\\n        return rewardRate[bankNodeId] * rewardsDuration[bankNodeId];\\n    }\\n\\n    /// @notice Stake `tokenAmount` tokens to specified bank node\\n    ///\\n    /// @param bankNodeId The id of the bank node to stake\\n    /// @param tokenAmount The amount to be staked\\n    function stake(uint32 bankNodeId, uint256 tokenAmount)\\n        external\\n        nonReentrant\\n        whenNotPaused\\n        updateReward(msg.sender, bankNodeId)\\n    {\\n        require(tokenAmount > 0, \\\"Cannot stake 0\\\");\\n        uint256 amount = getInternalValueForStakedTokenAmount(tokenAmount);\\n        require(amount > 0, \\\"Cannot stake 0\\\");\\n        require(getStakedTokenAmountForInternalValue(amount) == tokenAmount, \\\"token amount too high!\\\");\\n        _totalSupply[bankNodeId] += amount;\\n        _balances[encodeUserBankNodeKey(msg.sender, bankNodeId)] += amount;\\n        getStakingTokenForBankNode(bankNodeId).safeTransferFrom(msg.sender, address(this), tokenAmount);\\n        emit Staked(msg.sender, bankNodeId, tokenAmount);\\n    }\\n\\n    /// @notice Withdraw `tokenAmount` tokens from specified bank node\\n    ///\\n    /// @param bankNodeId The id of the bank node to withdraw\\n    /// @param tokenAmount The amount to be withdrawn\\n    function withdraw(uint32 bankNodeId, uint256 tokenAmount) public nonReentrant updateReward(msg.sender, bankNodeId) {\\n        require(tokenAmount > 0, \\\"Cannot withdraw 0\\\");\\n        uint256 amount = getInternalValueForStakedTokenAmount(tokenAmount);\\n        require(amount > 0, \\\"Cannot withdraw 0\\\");\\n        require(getStakedTokenAmountForInternalValue(amount) == tokenAmount, \\\"token amount too high!\\\");\\n\\n        _totalSupply[bankNodeId] -= amount;\\n        _balances[encodeUserBankNodeKey(msg.sender, bankNodeId)] -= amount;\\n        getStakingTokenForBankNode(bankNodeId).safeTransfer(msg.sender, tokenAmount);\\n        emit Withdrawn(msg.sender, bankNodeId, tokenAmount);\\n    }\\n\\n    /// @notice Get reward from specified bank node.\\n    /// @param bankNodeId The id of the bank node\\n    function getReward(uint32 bankNodeId) public nonReentrant updateReward(msg.sender, bankNodeId) {\\n        uint256 reward = rewards[encodeUserBankNodeKey(msg.sender, bankNodeId)];\\n\\n        if (reward > 0) {\\n            rewards[encodeUserBankNodeKey(msg.sender, bankNodeId)] = 0;\\n            rewardsToken.safeTransfer(msg.sender, reward);\\n            emit RewardPaid(msg.sender, bankNodeId, reward);\\n        }\\n    }\\n\\n    /// @notice Withdraw tokens and get reward from specified bank node.\\n    /// @param bankNodeId The id of the bank node\\n    function exit(uint32 bankNodeId) external {\\n        withdraw(\\n            bankNodeId,\\n            getStakedTokenAmountForInternalValue(_balances[encodeUserBankNodeKey(msg.sender, bankNodeId)])\\n        );\\n        getReward(bankNodeId);\\n    }\\n\\n    /// @dev Update the reward and emit the `RewardAdded` event\\n    function _notifyRewardAmount(uint32 bankNodeId, uint256 reward) internal updateReward(address(0), bankNodeId) {\\n        if (rewardsDuration[bankNodeId] == 0) {\\n            rewardsDuration[bankNodeId] = defaultRewardsDuration;\\n        }\\n        if (block.timestamp >= periodFinish[bankNodeId]) {\\n            rewardRate[bankNodeId] = reward / (rewardsDuration[bankNodeId]);\\n        } else {\\n            uint256 remaining = periodFinish[bankNodeId] - (block.timestamp);\\n            uint256 leftover = remaining * (rewardRate[bankNodeId]);\\n            rewardRate[bankNodeId] = (reward + leftover) / (rewardsDuration[bankNodeId]);\\n        }\\n\\n        // Ensure the provided reward amount is not more than the balance in the contract.\\n        // This keeps the reward rate in the right range, preventing overflows due to\\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\\n        uint256 balance = rewardsToken.balanceOf(address(this));\\n        require(rewardRate[bankNodeId] <= (balance / rewardsDuration[bankNodeId]), \\\"Provided reward too high\\\");\\n\\n        lastUpdateTime[bankNodeId] = block.timestamp;\\n        periodFinish[bankNodeId] = block.timestamp + (rewardsDuration[bankNodeId]);\\n        emit RewardAdded(bankNodeId, reward);\\n    }\\n\\n    /// @notice Update the reward and emit the `RewardAdded` event\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"REWARDS_DISTRIBUTOR_ROLE\\\"\\n    ///\\n    /// @param bankNodeId The id of the bank node\\n    /// @param reward The reward amount\\n    function notifyRewardAmount(uint32 bankNodeId, uint256 reward) external onlyRole(REWARDS_DISTRIBUTOR_ROLE) {\\n        _notifyRewardAmount(bankNodeId, reward);\\n    }\\n\\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\\n    /* function recoverERC20(address tokenAddress, uint256 tokenAmount) external {\\n        require(tokenAddress != address(stakingToken[]), \\\"Cannot withdraw the staking token\\\");\\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\\n        emit Recovered(tokenAddress, tokenAmount);\\n    }*/\\n\\n    /// @notice Set reward duration for a bank node\\n    ///\\n    /// - PRIVILEGES REQUIRED:\\n    ///     Admins with the role \\\"REWARDS_MANAGER\\\"\\n    ///\\n    /// @param bankNodeId The id of the bank node\\n    /// @param _rewardsDuration New reward duration (secs)\\n    function setRewardsDuration(uint32 bankNodeId, uint256 _rewardsDuration) external onlyRole(REWARDS_MANAGER) {\\n        require(\\n            block.timestamp > periodFinish[bankNodeId],\\n            \\\"Previous rewards period must be complete before changing the duration for the new period\\\"\\n        );\\n        rewardsDuration[bankNodeId] = _rewardsDuration;\\n        emit RewardsDurationUpdated(bankNodeId, rewardsDuration[bankNodeId]);\\n    }\\n\\n    /// @dev Update user bank node reward\\n    modifier updateReward(address account, uint32 bankNodeId) {\\n        if (rewardsDuration[bankNodeId] == 0) {\\n            rewardsDuration[bankNodeId] = defaultRewardsDuration;\\n        }\\n        rewardPerTokenStored[bankNodeId] = rewardPerToken(bankNodeId);\\n        lastUpdateTime[bankNodeId] = lastTimeRewardApplicable(bankNodeId);\\n        if (account != address(0)) {\\n            uint256 key = encodeUserBankNodeKey(msg.sender, bankNodeId);\\n            rewards[key] = earned(msg.sender, bankNodeId);\\n            userRewardPerTokenPaid[key] = rewardPerTokenStored[bankNodeId];\\n        }\\n        _;\\n    }\\n\\n    /// @dev Emitted when `_notifyRewardAmount` is called.\\n    ///\\n    /// @param bankNodeId The id of the bank node\\n    /// @param reward The reward amount\\n    event RewardAdded(uint32 indexed bankNodeId, uint256 reward);\\n\\n    /// @dev Emitted when user `user` stake `tokenAmount` to specified `bankNodeId` bank node.\\n    ///\\n    /// @param user The user address\\n    /// @param bankNodeId The id of the bank node\\n    /// @param amount The staked amount\\n    event Staked(address indexed user, uint32 indexed bankNodeId, uint256 amount);\\n\\n    /// @dev Emitted when user `user` withdraw `amount` of BNPL tokens from `bankNodeId` bank node.\\n    ///\\n    /// @param user The user address\\n    /// @param bankNodeId The id of the bank node\\n    /// @param amount The withdrawn amount\\n    event Withdrawn(address indexed user, uint32 indexed bankNodeId, uint256 amount);\\n\\n    /// @dev Emitted when user `user` calls `getReward`.\\n    ///\\n    /// @param user The user address\\n    /// @param bankNodeId The id of the bank node\\n    /// @param reward The reward amount\\n    event RewardPaid(address indexed user, uint32 indexed bankNodeId, uint256 reward);\\n\\n    /// @dev Emitted when `setRewardsDuration` is called.\\n    ///\\n    /// @param bankNodeId The id of the bank node\\n    /// @param newDuration The new reward duration\\n    event RewardsDurationUpdated(uint32 indexed bankNodeId, uint256 newDuration);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Aave/interfaces/IStakedToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IStakedToken {\\n    function stake(address to, uint256 amount) external;\\n\\n    function redeem(address to, uint256 amount) external;\\n\\n    function cooldown() external;\\n\\n    function claimRewards(address to, uint256 amount) external;\\n\\n    function REWARD_TOKEN() external view returns (address);\\n\\n    function stakersCooldowns(address staker) external view returns (uint256);\\n\\n    function getTotalRewardsBalance(address staker) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/Aave/interfaces/IAaveLendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IAaveLendingPool {\\n    function deposit(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/Aave/interfaces/IAaveIncentivesController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport {IAaveDistributionManager} from \\\"./IAaveDistributionManager.sol\\\";\\n\\ninterface IAaveIncentivesController is IAaveDistributionManager {\\n    event RewardsAccrued(address indexed user, uint256 amount);\\n\\n    event RewardsClaimed(address indexed user, address indexed to, address indexed claimer, uint256 amount);\\n\\n    event ClaimerSet(address indexed user, address indexed claimer);\\n\\n    /**\\n     * @dev Whitelists an address to claim the rewards on behalf of another address\\n     * @param user The address of the user\\n     * @param claimer The address of the claimer\\n     */\\n    function setClaimer(address user, address claimer) external;\\n\\n    /**\\n     * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\\n     * @param user The address of the user\\n     * @return The claimer address\\n     */\\n    function getClaimer(address user) external view returns (address);\\n\\n    /**\\n     * @dev Configure assets for a certain rewards emission\\n     * @param assets The assets to incentivize\\n     * @param emissionsPerSecond The emission for each asset\\n     */\\n    function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond) external;\\n\\n    /**\\n     * @dev Called by the corresponding asset on any update that affects the rewards distribution\\n     * @param asset The address of the user\\n     * @param userBalance The balance of the user of the asset in the lending pool\\n     * @param totalSupply The total supply of the asset in the lending pool\\n     **/\\n    function handleAction(\\n        address asset,\\n        uint256 userBalance,\\n        uint256 totalSupply\\n    ) external;\\n\\n    /**\\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\\n     * @param user The address of the user\\n     * @return The rewards\\n     **/\\n    function getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);\\n\\n    /**\\n     * @dev Claims reward for an user to the desired address, on all the assets of the lending pool, accumulating the pending rewards\\n     * @param amount Amount of rewards to claim\\n     * @param to Address that will be receiving the rewards\\n     * @return Rewards claimed\\n     **/\\n    function claimRewards(\\n        address[] calldata assets,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\\n     * be whitelisted via \\\"allowClaimOnBehalf\\\" function by the RewardsAdmin role manager\\n     * @param amount Amount of rewards to claim\\n     * @param user Address to check and claim rewards\\n     * @param to Address that will be receiving the rewards\\n     * @return Rewards claimed\\n     **/\\n    function claimRewardsOnBehalf(\\n        address[] calldata assets,\\n        uint256 amount,\\n        address user,\\n        address to\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Claims reward for msg.sender, on all the assets of the lending pool, accumulating the pending rewards\\n     * @param amount Amount of rewards to claim\\n     * @return Rewards claimed\\n     **/\\n    function claimRewardsToSelf(address[] calldata assets, uint256 amount) external returns (uint256);\\n\\n    /**\\n     * @dev returns the unclaimed rewards of the user\\n     * @param user the address of the user\\n     * @return the unclaimed user rewards\\n     */\\n    function getUserUnclaimedRewards(address user) external view returns (uint256);\\n\\n    /**\\n     * @dev for backward compatibility with previous implementation of the Incentives controller\\n     */\\n    function REWARD_TOKEN() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/SwapMarket/interfaces/IBNPLSwapMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the IBNPLSwapMarket standard\\n */\\ninterface IBNPLSwapMarket {\\n    /// @title Router token swapping functionality\\n    /// @notice Functions for swapping tokens via Uniswap V3\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @return amounts The amount of the received token\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"src/Aave/interfaces/IAaveDistributionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport {DistributionTypes} from \\\"../lib/DistributionTypes.sol\\\";\\n\\ninterface IAaveDistributionManager {\\n    event AssetConfigUpdated(address indexed asset, uint256 emission);\\n    event AssetIndexUpdated(address indexed asset, uint256 index);\\n    event UserIndexUpdated(address indexed user, address indexed asset, uint256 index);\\n    event DistributionEndUpdated(uint256 newDistributionEnd);\\n\\n    /**\\n     * @dev Sets the end date for the distribution\\n     * @param distributionEnd The end date timestamp\\n     **/\\n    function setDistributionEnd(uint256 distributionEnd) external;\\n\\n    /**\\n     * @dev Gets the end date for the distribution\\n     * @return The end of the distribution\\n     **/\\n    function getDistributionEnd() external view returns (uint256);\\n\\n    /**\\n     * @dev for backwards compatibility with the previous DistributionManager used\\n     * @return The end of the distribution\\n     **/\\n    function DISTRIBUTION_END() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the data of an user on a distribution\\n     * @param user Address of the user\\n     * @param asset The address of the reference asset of the distribution\\n     * @return The new index\\n     **/\\n    function getUserAssetData(address user, address asset) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the configuration of the distribution for a certain asset\\n     * @param asset The address of the reference asset of the distribution\\n     * @return The asset index, the emission per second and the last updated timestamp\\n     **/\\n    function getAssetData(address asset)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n}\\n\"\r\n    },\r\n    \"src/Aave/lib/DistributionTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nlibrary DistributionTypes {\\n    struct AssetConfigInput {\\n        uint104 emissionPerSecond;\\n        uint256 totalStaked;\\n        address underlyingAsset;\\n    }\\n\\n    struct UserStakeInput {\\n        address underlyingAsset;\\n        uint256 stakedByUser;\\n        uint256 totalStaked;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/BankNode/interfaces/IUserTokenLockup.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @dev Interface of the IUserTokenLockup standard\\ninterface IUserTokenLockup {\\n    /// @notice Tokens locked amount\\n    /// @return totalTokensLocked\\n    function totalTokensLocked() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/Utils/Math/PRBMathCommon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\npragma solidity >=0.8.0;\\n\\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\\n// representation. When it does not, it is annonated in the function's NatSpec documentation.\\nlibrary PRBMathCommon {\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @dev Largest power of two divisor of SCALE.\\n    uint256 internal constant SCALE_LPOTD = 262144;\\n\\n    /// @dev SCALE inverted mod 2^256.\\n    uint256 internal constant SCALE_INVERSE = 78156646155174841979727994598816262306175212592076161876661508869554232690281;\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    /// @dev Uses 128.128-bit fixed-point numbers - it is the most efficient way.\\n    /// @param x The exponent as an unsigned 128.128-bit fixed-point number.\\n    /// @return result The result as an unsigned 60x18 decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // Start from 0.5 in the 128.128-bit fixed-point format. We need to use uint256 because the intermediary\\n            // may get very close to 2^256, which doesn't fit in int256.\\n            result = 0x80000000000000000000000000000000;\\n\\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\\n            // because the initial result is 2^127 and all magic factors are less than 2^129.\\n            if (x & 0x80000000000000000000000000000000 > 0) result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\\n            if (x & 0x40000000000000000000000000000000 > 0) result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDED) >> 128;\\n            if (x & 0x20000000000000000000000000000000 > 0) result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A7920) >> 128;\\n            if (x & 0x10000000000000000000000000000000 > 0) result = (result * 0x10B5586CF9890F6298B92B71842A98364) >> 128;\\n            if (x & 0x8000000000000000000000000000000 > 0) result = (result * 0x1059B0D31585743AE7C548EB68CA417FE) >> 128;\\n            if (x & 0x4000000000000000000000000000000 > 0) result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE9) >> 128;\\n            if (x & 0x2000000000000000000000000000000 > 0) result = (result * 0x10163DA9FB33356D84A66AE336DCDFA40) >> 128;\\n            if (x & 0x1000000000000000000000000000000 > 0) result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9544) >> 128;\\n            if (x & 0x800000000000000000000000000000 > 0) result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679C) >> 128;\\n            if (x & 0x400000000000000000000000000000 > 0) result = (result * 0x1002C605E2E8CEC506D21BFC89A23A011) >> 128;\\n            if (x & 0x200000000000000000000000000000 > 0) result = (result * 0x100162F3904051FA128BCA9C55C31E5E0) >> 128;\\n            if (x & 0x100000000000000000000000000000 > 0) result = (result * 0x1000B175EFFDC76BA38E31671CA939726) >> 128;\\n            if (x & 0x80000000000000000000000000000 > 0) result = (result * 0x100058BA01FB9F96D6CACD4B180917C3E) >> 128;\\n            if (x & 0x40000000000000000000000000000 > 0) result = (result * 0x10002C5CC37DA9491D0985C348C68E7B4) >> 128;\\n            if (x & 0x20000000000000000000000000000 > 0) result = (result * 0x1000162E525EE054754457D5995292027) >> 128;\\n            if (x & 0x10000000000000000000000000000 > 0) result = (result * 0x10000B17255775C040618BF4A4ADE83FD) >> 128;\\n            if (x & 0x8000000000000000000000000000 > 0) result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAC) >> 128;\\n            if (x & 0x4000000000000000000000000000 > 0) result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7CA) >> 128;\\n            if (x & 0x2000000000000000000000000000 > 0) result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\\n            if (x & 0x1000000000000000000000000000 > 0) result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\\n            if (x & 0x800000000000000000000000000 > 0) result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1629) >> 128;\\n            if (x & 0x400000000000000000000000000 > 0) result = (result * 0x1000002C5C863B73F016468F6BAC5CA2C) >> 128;\\n            if (x & 0x200000000000000000000000000 > 0) result = (result * 0x100000162E430E5A18F6119E3C02282A6) >> 128;\\n            if (x & 0x100000000000000000000000000 > 0) result = (result * 0x1000000B1721835514B86E6D96EFD1BFF) >> 128;\\n            if (x & 0x80000000000000000000000000 > 0) result = (result * 0x100000058B90C0B48C6BE5DF846C5B2F0) >> 128;\\n            if (x & 0x40000000000000000000000000 > 0) result = (result * 0x10000002C5C8601CC6B9E94213C72737B) >> 128;\\n            if (x & 0x20000000000000000000000000 > 0) result = (result * 0x1000000162E42FFF037DF38AA2B219F07) >> 128;\\n            if (x & 0x10000000000000000000000000 > 0) result = (result * 0x10000000B17217FBA9C739AA5819F44FA) >> 128;\\n            if (x & 0x8000000000000000000000000 > 0) result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC824) >> 128;\\n            if (x & 0x4000000000000000000000000 > 0) result = (result * 0x100000002C5C85FE31F35A6A30DA1BE51) >> 128;\\n            if (x & 0x2000000000000000000000000 > 0) result = (result * 0x10000000162E42FF0999CE3541B9FFFD0) >> 128;\\n            if (x & 0x1000000000000000000000000 > 0) result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\\n            if (x & 0x800000000000000000000000 > 0) result = (result * 0x10000000058B90BFBF8479BD5A81B51AE) >> 128;\\n            if (x & 0x400000000000000000000000 > 0) result = (result * 0x1000000002C5C85FDF84BD62AE30A74CD) >> 128;\\n            if (x & 0x200000000000000000000000 > 0) result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\\n            if (x & 0x100000000000000000000000 > 0) result = (result * 0x1000000000B17217F7D5A7716BBA4A9AF) >> 128;\\n            if (x & 0x80000000000000000000000 > 0) result = (result * 0x100000000058B90BFBE9DDBAC5E109CCF) >> 128;\\n            if (x & 0x40000000000000000000000 > 0) result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0E) >> 128;\\n            if (x & 0x20000000000000000000000 > 0) result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\\n            if (x & 0x10000000000000000000000 > 0) result = (result * 0x10000000000B17217F7D20CF927C8E94D) >> 128;\\n            if (x & 0x8000000000000000000000 > 0) result = (result * 0x1000000000058B90BFBE8F71CB4E4B33E) >> 128;\\n            if (x & 0x4000000000000000000000 > 0) result = (result * 0x100000000002C5C85FDF477B662B26946) >> 128;\\n            if (x & 0x2000000000000000000000 > 0) result = (result * 0x10000000000162E42FEFA3AE53369388D) >> 128;\\n            if (x & 0x1000000000000000000000 > 0) result = (result * 0x100000000000B17217F7D1D351A389D41) >> 128;\\n            if (x & 0x800000000000000000000 > 0) result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDF) >> 128;\\n            if (x & 0x400000000000000000000 > 0) result = (result * 0x1000000000002C5C85FDF4741BEA6E77F) >> 128;\\n            if (x & 0x200000000000000000000 > 0) result = (result * 0x100000000000162E42FEFA39FE95583C3) >> 128;\\n            if (x & 0x100000000000000000000 > 0) result = (result * 0x1000000000000B17217F7D1CFB72B45E3) >> 128;\\n            if (x & 0x80000000000000000000 > 0) result = (result * 0x100000000000058B90BFBE8E7CC35C3F2) >> 128;\\n            if (x & 0x40000000000000000000 > 0) result = (result * 0x10000000000002C5C85FDF473E242EA39) >> 128;\\n            if (x & 0x20000000000000000000 > 0) result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;\\n            if (x & 0x10000000000000000000 > 0) result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\\n            if (x & 0x8000000000000000000 > 0) result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\\n            if (x & 0x4000000000000000000 > 0) result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;\\n            if (x & 0x2000000000000000000 > 0) result = (result * 0x10000000000000162E42FEFA39EF44D92) >> 128;\\n            if (x & 0x1000000000000000000 > 0) result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;\\n            if (x & 0x800000000000000000 > 0) result = (result * 0x10000000000000058B90BFBE8E7BCE545) >> 128;\\n            if (x & 0x400000000000000000 > 0) result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\\n            if (x & 0x200000000000000000 > 0) result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;\\n            if (x & 0x100000000000000000 > 0) result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\\n            if (x & 0x80000000000000000 > 0) result = (result * 0x100000000000000058B90BFBE8E7BCD6E) >> 128;\\n            if (x & 0x40000000000000000 > 0) result = (result * 0x10000000000000002C5C85FDF473DE6B3) >> 128;\\n            if (x & 0x20000000000000000 > 0) result = (result * 0x1000000000000000162E42FEFA39EF359) >> 128;\\n            if (x & 0x10000000000000000 > 0) result = (result * 0x10000000000000000B17217F7D1CF79AC) >> 128;\\n\\n            // Multiply the result by the integer part 2^n + 1. We have to shift by one bit extra because we have already divided\\n            // by two when we set the result equal to 0.5 above.\\n            result = result << ((x >> 128) + 1);\\n\\n            // Convert the result to the signed 60.18-decimal fixed-point format.\\n            result = PRBMathCommon.mulDiv(result, 1e18, 2**128);\\n        }\\n    }\\n\\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n    /// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n    /// @param x The uint256 number for which to find the index of the most significant bit.\\n    /// @return msb The index of the most significant bit as an uint256.\\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n        if (x >= 2**128) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 2**64) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 2**32) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 2**16) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 2**8) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 2**4) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 2**2) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 2**1) {\\n            // No need to shift x any more.\\n            msb += 1;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The multiplicand as an uint256.\\n    /// @param y The multiplier as an uint256.\\n    /// @param denominator The divisor as an uint256.\\n    /// @return result The result as an uint256.\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2**256 and mod 2**256 - 1, then use\\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0.\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256. Also prevents denominator == 0.\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0].\\n        uint256 remainder;\\n        assembly {\\n            // Compute remainder using mulmod.\\n            remainder := mulmod(x, y, denominator)\\n\\n            // Subtract 256 bit number from 512 bit number\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n        // See https://cs.stackexchange.com/q/138556/92363.\\n        unchecked {\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 lpotdod = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by lpotdod.\\n                denominator := div(denominator, lpotdod)\\n\\n                // Divide [prod1 prod0] by lpotdod.\\n                prod0 := div(prod0, lpotdod)\\n\\n                // Flip lpotdod such that it is 2**256 / lpotdod. If lpotdod is zero, then it becomes one.\\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * lpotdod;\\n\\n            // Invert denominator mod 2**256. Now that denominator is an odd number, it has an inverse modulo 2**256 such\\n            // that denominator * inv = 1 mod 2**256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Now use Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2**8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2**16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2**32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2**64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2**128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2**256. Since the precoditions guarantee that the outcome is\\n            // less than 2**256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\u00f71e18) with full precision.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\\n    /// being rounded to 1e-18.  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717.\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - The body is purposely left uncommented; see the NatSpec comments in \\\"PRBMathCommon.mulDiv\\\" to understand how this works.\\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two queations:\\n    ///     1) x * y = type(uint256).max * SCALE\\n    ///     2) (x * y) % SCALE >= SCALE / 2\\n    ///\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        uint256 prod0;\\n        uint256 prod1;\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        uint256 remainder;\\n        uint256 roundUpUnit;\\n        assembly {\\n            remainder := mulmod(x, y, SCALE)\\n            roundUpUnit := gt(remainder, 499999999999999999)\\n        }\\n\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = (prod0 / SCALE) + roundUpUnit;\\n                return result;\\n            }\\n        }\\n\\n        require(SCALE > prod1);\\n\\n        assembly {\\n            result := add(\\n                mul(\\n                    or(\\n                        div(sub(prod0, remainder), SCALE_LPOTD),\\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\\n                    ),\\n                    SCALE_INVERSE\\n                ),\\n                roundUpUnit\\n            )\\n        }\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The uint256 number for which to calculate the square root.\\n    /// @return result The result as an uint256.\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Calculate the square root of the perfect square of a power of two that is the closest to x.\\n        uint256 xAux = uint256(x);\\n        result = 1;\\n        if (xAux >= 0x100000000000000000000000000000000) {\\n            xAux >>= 128;\\n            result <<= 64;\\n        }\\n        if (xAux >= 0x10000000000000000) {\\n            xAux >>= 64;\\n            result <<= 32;\\n        }\\n        if (xAux >= 0x100000000) {\\n            xAux >>= 32;\\n            result <<= 16;\\n        }\\n        if (xAux >= 0x10000) {\\n            xAux >>= 16;\\n            result <<= 8;\\n        }\\n        if (xAux >= 0x100) {\\n            xAux >>= 8;\\n            result <<= 4;\\n        }\\n        if (xAux >= 0x10) {\\n            xAux >>= 4;\\n            result <<= 2;\\n        }\\n        if (xAux >= 0x8) {\\n            result <<= 1;\\n        }\\n\\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\\n        unchecked {\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1; // Seven iterations should be enough\\n            uint256 roundedDownResult = x / result;\\n            return result >= roundedDownResult ? roundedDownResult : result;\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondAmount\",\"type\":\"uint256\"}],\"name\":\"Bond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"donationAmount\",\"type\":\"uint256\"}],\"name\":\"Donation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"vaultIndex\",\"type\":\"uint32\"}],\"name\":\"LockupClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"vaultIndex\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"unlockDate\",\"type\":\"uint64\"}],\"name\":\"LockupCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slashAmount\",\"type\":\"uint256\"}],\"name\":\"Slash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnplStakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolTokensMinted\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unbondAmount\",\"type\":\"uint256\"}],\"name\":\"Unbond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnplUnstakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolTokensBurned\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_LIQUIDITY_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BNPL_STAKER_NEEDS_KYC\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NODE_REWARDS_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL_LIQUIDITY_TOKEN\",\"outputs\":[{\"internalType\":\"contract IMintableBurnableTokenUpgradeable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SLASHER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bankNode\",\"outputs\":[{\"internalType\":\"contract IBNPLBankNode\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bankNodeManager\",\"outputs\":[{\"internalType\":\"contract IBankNodeManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnplKYCStore\",\"outputs\":[{\"internalType\":\"contract BNPLKYCStore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bondAmount\",\"type\":\"uint256\"}],\"name\":\"bondTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prevNodeBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nodeLoss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolBalance\",\"type\":\"uint256\"}],\"name\":\"calculateSlashAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimNodeOwnerPoolTokenRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimTokenLockup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"maxNumberOfClaims\",\"type\":\"uint32\"}],\"name\":\"claimTokenNextNLockups\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"donateAmount\",\"type\":\"uint256\"}],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"donateAmount\",\"type\":\"uint256\"}],\"name\":\"donateNotCountedInTotal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"encodedLockupStatuses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"encodedTokenLockups\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getNextTokenLockupForUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"unlockDate\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"vaultIndex\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeOwnerBNPLRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeOwnerPoolTokenRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"getPoolDepositConversion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolTotalAssetsValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"getPoolWithdrawConversion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"vaultIndex\",\"type\":\"uint32\"}],\"name\":\"getTokenLockup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"unlockDate\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnstakeLockupPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bnplToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolBNPLToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bankNodeContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bankNodeManagerContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenBonder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokensToBond\",\"type\":\"uint256\"},{\"internalType\":\"contract BNPLKYCStore\",\"name\":\"bnplKYCStore_\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"kycDomainId_\",\"type\":\"uint32\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNodeDecomissioning\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kycDomainId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolTokenEffectiveSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolTokensCirculating\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slashAmount\",\"type\":\"uint256\"}],\"name\":\"slash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"name\":\"stakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensBondedAllTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDonatedAllTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSlashedAllTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unbondTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockLendingTokenInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unstakeAmount\",\"type\":\"uint256\"}],\"name\":\"unstakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userLockupStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"currentVaultIndex\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numberOfActiveVaults\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"virtualPoolTokensCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BNPLStakingPool", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}