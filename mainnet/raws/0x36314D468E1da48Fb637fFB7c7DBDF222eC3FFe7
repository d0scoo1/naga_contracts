{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.10;\n\n\n\n\n\ncontract MainnetYearnAddresses {\n    address internal constant YEARN_REGISTRY_ADDR = 0x50c1a2eA0a861A967D9d0FFE2AE4012c2E053804;\n}\n\n\n\n\n\nabstract contract IYearnRegistry {\n    function latestVault(address) external virtual view returns (address);\n    function numVaults(address) external virtual view returns (uint256);\n    function vaults(address,uint256) external virtual view returns (address);\n}\n\n\n\n\n\n\ncontract YearnHelper is MainnetYearnAddresses {\n\n    IYearnRegistry public constant yearnRegistry =\n        IYearnRegistry(YEARN_REGISTRY_ADDR);\n}\n\n\n\n\n\ninterface IYVault {\n    function withdraw(uint256 _shares) external ;\n    function deposit(uint256 _amount) external ;\n    function token() external view returns (address);\n\n    function totalSupply() external view returns (uint256);\n    function totalAssets() external view returns (uint256);\n    function withdrawalQueue(uint256 i) external view returns (address);\n\n    function strategies(address) external view returns (uint256, uint256, uint256,uint256, uint256, uint256, uint256, uint256, uint256);\n}\n\n\n\n\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint256 digits);\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x + y;\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x - y;\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y;\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n\ncontract YearnView is YearnHelper, DSMath  {\n    function getUnderlyingBalanceInVault(address _user, address _vault) public view returns (uint256) {\n        uint256 exchangeRate = rdiv(IYVault(_vault).totalAssets(), IYVault(_vault).totalSupply());\n\n        uint256 yTokenBalance = IERC20(_vault).balanceOf(_user);\n\n        return rmul(yTokenBalance, exchangeRate);\n    }\n\n    function getPoolLiquidity(address _vault) public view returns (uint256) {\n        address underlyingToken = IYVault(_vault).token();\n\n        uint256 balanceInVault = IERC20(underlyingToken).balanceOf(_vault);\n\n        uint256 strategyDebtSum = 0;\n\n        for(uint256 i = 0; i < 20; ++i) {\n            address strategyAddr = IYVault(_vault).withdrawalQueue(i);\n            (,,,,,,uint totalDebt,,) = IYVault(_vault).strategies(strategyAddr);\n\n            strategyDebtSum += totalDebt;\n        }\n\n        return balanceInVault + strategyDebtSum;\n    }\n\n    function getVaultsForUnderlying(address _regAddr, address _tokenAddr) public view returns (address[] memory vaultAddresses) {\n        uint256 numVaults = IYearnRegistry(_regAddr).numVaults(_tokenAddr);\n\n        vaultAddresses = new address[](numVaults);\n\n        for(uint256 i = 0; i < numVaults; ++i) {\n            vaultAddresses[i] = IYearnRegistry(_regAddr).vaults(_tokenAddr, i);\n        }\n    }\n\n    function getBalanceAndCheckLiquidity(address _user, address _tokenAddr, address _regAddr) public view returns (uint256) {\n        address[] memory vaultAddresses = getVaultsForUnderlying(_regAddr, _tokenAddr);\n\n        uint256 biggestUsableVaultBalance = 0;\n        address targetVault;\n\n        for(uint256 i = 0; i < vaultAddresses.length; ++i) {\n            uint256 userBalance = getUnderlyingBalanceInVault(_user, vaultAddresses[i]);\n            uint256 availLiquidity = getPoolLiquidity(targetVault);\n\n            uint256 usableBalance = userBalance > availLiquidity ? availLiquidity : userBalance;\n\n            if (usableBalance > biggestUsableVaultBalance) {\n                biggestUsableVaultBalance = userBalance;\n                targetVault = vaultAddresses[i];\n            }\n        }\n\n        return biggestUsableVaultBalance;\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_regAddr\",\"type\":\"address\"}],\"name\":\"getBalanceAndCheckLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"getPoolLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"getUnderlyingBalanceInVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_regAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"getVaultsForUnderlying\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"vaultAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yearnRegistry\",\"outputs\":[{\"internalType\":\"contract IYearnRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "YearnView", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}