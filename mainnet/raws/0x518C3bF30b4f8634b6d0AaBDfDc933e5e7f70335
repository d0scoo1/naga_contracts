{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IPoolStorage {\r\n  /// @notice The contract that deployed the pool, which must adhere to the IFactory interface\r\n  /// @return The contract address\r\n  function factory() external view returns (address);\r\n\r\n  /// @notice The first of the two tokens of the pool, sorted by address\r\n  /// @return The token contract address\r\n  function token0() external view returns (IERC20);\r\n\r\n  /// @notice The second of the two tokens of the pool, sorted by address\r\n  /// @return The token contract address\r\n  function token1() external view returns (IERC20);\r\n\r\n  /// @notice The fee to be charged for a swap in basis points\r\n  /// @return The swap fee in basis points\r\n  function swapFeeUnits() external view returns (uint24);\r\n\r\n  /// @notice The pool tick distance\r\n  /// @dev Ticks can only be initialized and used at multiples of this value\r\n  /// It remains an int24 to avoid casting even though it is >= 1.\r\n  /// e.g: a tickDistance of 5 means ticks can be initialized every 5th tick, i.e., ..., -10, -5, 0, 5, 10, ...\r\n  /// @return The tick distance\r\n  function tickDistance() external view returns (int24);\r\n\r\n  /// @notice Maximum gross liquidity that an initialized tick can have\r\n  /// @dev This is to prevent overflow the pool's active base liquidity (uint128)\r\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\r\n  /// @return The max amount of liquidity per tick\r\n  function maxTickLiquidity() external view returns (uint128);\r\n\r\n  /// @notice Look up information about a specific tick in the pool\r\n  /// @param tick The tick to look up\r\n  /// @return liquidityGross total liquidity amount from positions that uses this tick as a lower or upper tick\r\n  /// liquidityNet how much liquidity changes when the pool tick crosses above the tick\r\n  /// feeGrowthOutside the fee growth on the other side of the tick relative to the current tick\r\n  /// secondsPerLiquidityOutside the seconds spent on the other side of the tick relative to the current tick\r\n  function ticks(int24 tick)\r\n    external\r\n    view\r\n    returns (\r\n      uint128 liquidityGross,\r\n      int128 liquidityNet,\r\n      uint256 feeGrowthOutside,\r\n      uint128 secondsPerLiquidityOutside\r\n    );\r\n\r\n  /// @notice Returns the previous and next initialized ticks of a specific tick\r\n  /// @dev If specified tick is uninitialized, the returned values are zero.\r\n  /// @param tick The tick to look up\r\n  function initializedTicks(int24 tick) external view returns (int24 previous, int24 next);\r\n\r\n  /// @notice Returns the information about a position by the position's key\r\n  /// @return liquidity the liquidity quantity of the position\r\n  /// @return feeGrowthInsideLast fee growth inside the tick range as of the last mint / burn action performed\r\n  function getPositions(\r\n    address owner,\r\n    int24 tickLower,\r\n    int24 tickUpper\r\n  ) external view returns (uint128 liquidity, uint256 feeGrowthInsideLast);\r\n\r\n  /// @notice Fetches the pool's prices, ticks and lock status\r\n  /// @return sqrtP sqrt of current price: sqrt(token1/token0)\r\n  /// @return currentTick pool's current tick\r\n  /// @return nearestCurrentTick pool's nearest initialized tick that is <= currentTick\r\n  /// @return locked true if pool is locked, false otherwise\r\n  function getPoolState()\r\n    external\r\n    view\r\n    returns (\r\n      uint160 sqrtP,\r\n      int24 currentTick,\r\n      int24 nearestCurrentTick,\r\n      bool locked\r\n    );\r\n\r\n  /// @notice Fetches the pool's liquidity values\r\n  /// @return baseL pool's base liquidity without reinvest liqudity\r\n  /// @return reinvestL the liquidity is reinvested into the pool\r\n  /// @return reinvestLLast last cached value of reinvestL, used for calculating reinvestment token qty\r\n  function getLiquidityState()\r\n    external\r\n    view\r\n    returns (\r\n      uint128 baseL,\r\n      uint128 reinvestL,\r\n      uint128 reinvestLLast\r\n    );\r\n\r\n  /// @return feeGrowthGlobal All-time fee growth per unit of liquidity of the pool\r\n  function getFeeGrowthGlobal() external view returns (uint256);\r\n\r\n  /// @return secondsPerLiquidityGlobal All-time seconds per unit of liquidity of the pool\r\n  /// @return lastUpdateTime The timestamp in which secondsPerLiquidityGlobal was last updated\r\n  function getSecondsPerLiquidityData()\r\n    external\r\n    view\r\n    returns (uint128 secondsPerLiquidityGlobal, uint32 lastUpdateTime);\r\n\r\n  /// @notice Calculates and returns the active time per unit of liquidity until current block.timestamp\r\n  /// @param tickLower The lower tick (of a position)\r\n  /// @param tickUpper The upper tick (of a position)\r\n  /// @return secondsPerLiquidityInside active time (multiplied by 2^96)\r\n  /// between the 2 ticks, per unit of liquidity.\r\n  function getSecondsPerLiquidityInside(int24 tickLower, int24 tickUpper)\r\n    external\r\n    view\r\n    returns (uint128 secondsPerLiquidityInside);\r\n}\r\n\r\ninterface IPool is IPoolStorage {}\r\n\r\n\r\ncontract UniV3Helper {\r\n    \r\n    function getTicks(IPool pool, uint maxTickNum) external view returns (bytes[] memory ticks) {\r\n        (,,int24 tick,) = pool.getPoolState();\r\n        \r\n        int24[] memory initTicks = new int24[](maxTickNum);\r\n        \r\n        uint counter = 1;\r\n        initTicks[0] = tick;\r\n\r\n        (int24 previous, int24 next) = pool.initializedTicks(tick);\r\n        if (previous != tick && previous != 0) {\r\n            initTicks[counter] = previous;\r\n            counter++;\r\n        }\r\n        if (next != tick && next != 0) {\r\n            initTicks[counter] = next;\r\n            counter++;\r\n        }\r\n\r\n        while ((next != 0 || previous != 0)) {\r\n            if (previous != 0) {\r\n                (int24 p, ) = pool.initializedTicks(previous);\r\n                if (previous != p && p != 0) {\r\n                    initTicks[counter] = p;\r\n                    previous = p;\r\n                    counter++;\r\n                } else {\r\n                    previous = 0;\r\n                }\r\n            }\r\n\r\n            if (counter == maxTickNum) {\r\n                break;\r\n            }\r\n            \r\n            if (next != 0) {\r\n                (, int24 n) = pool.initializedTicks(next);\r\n                if (next != n && n != 0) {\r\n                    initTicks[counter] = n;\r\n                    next = n;\r\n                    counter++;\r\n                } else {\r\n                    next = 0;\r\n                }\r\n            }\r\n\r\n            if (counter == maxTickNum) {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        ticks = new bytes[](counter);\r\n        for (uint i = 0; i < counter; i++) {\r\n            (           \r\n                uint128 liquidityGross,\r\n                int128 liquidityNet,\r\n                ,\r\n            ) = pool.ticks(initTicks[i]);\r\n                 \r\n             ticks[i] = abi.encodePacked(\r\n                 liquidityGross,\r\n                 liquidityNet,\r\n                 initTicks[i]\r\n             );\r\n        }\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxTickNum\",\"type\":\"uint256\"}],\"name\":\"getTicks\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"ticks\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UniV3Helper", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dd9f9bd9dcec6056b27e8d70f46f5d927c1c5da83bd4910288580c6669fcefc0"}]}