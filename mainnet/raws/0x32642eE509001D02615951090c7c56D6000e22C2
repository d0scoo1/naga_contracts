{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/rollup/RollupEventInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IRollupEventInbox.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/IDelayedMessageProvider.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\nimport {INITIALIZATION_MSG_TYPE} from \\\"../libraries/MessageTypes.sol\\\";\\n\\n/**\\n * @title The inbox for rollup protocol events\\n */\\ncontract RollupEventInbox is IRollupEventInbox, IDelayedMessageProvider, DelegateCallAware {\\n    uint8 internal constant CREATE_NODE_EVENT = 0;\\n    uint8 internal constant CONFIRM_NODE_EVENT = 1;\\n    uint8 internal constant REJECT_NODE_EVENT = 2;\\n    uint8 internal constant STAKE_CREATED_EVENT = 3;\\n\\n    IBridge public override bridge;\\n    address public override rollup;\\n\\n    modifier onlyRollup() {\\n        require(msg.sender == rollup, \\\"ONLY_ROLLUP\\\");\\n        _;\\n    }\\n\\n    function initialize(IBridge _bridge) external override onlyDelegated {\\n        require(address(bridge) == address(0), \\\"ALREADY_INIT\\\");\\n        bridge = _bridge;\\n        rollup = address(_bridge.rollup());\\n    }\\n\\n    function rollupInitialized(uint256 chainId) external override onlyRollup {\\n        bytes memory initMsg = abi.encodePacked(chainId);\\n        uint256 num = bridge.enqueueDelayedMessage(\\n            INITIALIZATION_MSG_TYPE,\\n            address(0),\\n            keccak256(initMsg)\\n        );\\n        emit InboxMessageDelivered(num, initMsg);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/IRollupEventInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../bridge/IBridge.sol\\\";\\n\\ninterface IRollupEventInbox {\\n    function bridge() external view returns (IBridge);\\n\\n    function initialize(IBridge _bridge) external;\\n\\n    function rollup() external view returns (address);\\n\\n    function rollupInitialized(uint256 chainId) external;\\n}\\n\"\r\n    },\r\n    \"src/bridge/IBridge.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport {NotContract, NotRollupOrOwner} from \\\"../libraries/Error.sol\\\";\\nimport \\\"./IOwnable.sol\\\";\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-inbox function\\n/// @param sender The un-authorized sender\\nerror NotDelayedInbox(address sender);\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-sequencer-inbox function\\n/// @param sender The un-authorized sender\\nerror NotSequencerInbox(address sender);\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-outbox function\\n/// @param sender The un-authorized sender\\nerror NotOutbox(address sender);\\n\\n/// @dev the provided outbox address isn't valid\\n/// @param outbox address of outbox being set\\nerror InvalidOutboxSet(address outbox);\\n\\ninterface IBridge {\\n    event MessageDelivered(\\n        uint256 indexed messageIndex,\\n        bytes32 indexed beforeInboxAcc,\\n        address inbox,\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash,\\n        uint256 baseFeeL1,\\n        uint64 timestamp\\n    );\\n\\n    event BridgeCallTriggered(\\n        address indexed outbox,\\n        address indexed to,\\n        uint256 value,\\n        bytes data\\n    );\\n\\n    event InboxToggle(address indexed inbox, bool enabled);\\n\\n    event OutboxToggle(address indexed outbox, bool enabled);\\n\\n    event SequencerInboxUpdated(address newSequencerInbox);\\n\\n    function enqueueDelayedMessage(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable returns (uint256);\\n\\n    function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead)\\n        external\\n        returns (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 acc\\n        );\\n\\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\\n        external\\n        returns (uint256 msgNum);\\n\\n    function executeCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    // These are only callable by the admin\\n    function setDelayedInbox(address inbox, bool enabled) external;\\n\\n    function setOutbox(address inbox, bool enabled) external;\\n\\n    function setSequencerInbox(address _sequencerInbox) external;\\n\\n    // View functions\\n\\n    function sequencerInbox() external view returns (address);\\n\\n    function activeOutbox() external view returns (address);\\n\\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\\n\\n    function allowedOutboxes(address outbox) external view returns (bool);\\n\\n    function delayedInboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function sequencerInboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function delayedMessageCount() external view returns (uint256);\\n\\n    function sequencerMessageCount() external view returns (uint256);\\n\\n    function rollup() external view returns (IOwnable);\\n}\\n\"\r\n    },\r\n    \"src/bridge/IDelayedMessageProvider.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\ninterface IDelayedMessageProvider {\\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\n\\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\\n    /// same as InboxMessageDelivered but the batch data is available in tx.input\\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\n}\\n\"\r\n    },\r\n    \"src/libraries/DelegateCallAware.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport {NotOwner} from \\\"./Error.sol\\\";\\n\\n/// @dev A stateless contract that allows you to infer if the current call has been delegated or not\\n/// Pattern used here is from UUPS implementation by the OpenZeppelin team\\nabstract contract DelegateCallAware {\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegate call. This allows a function to be\\n     * callable on the proxy contract but not on the logic contract.\\n     */\\n    modifier onlyDelegated() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"Function must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /// @dev Check that msg.sender is the current EIP 1967 proxy admin\\n    modifier onlyProxyOwner() {\\n        // Storage slot with the admin of the proxy contract\\n        // This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1\\n        bytes32 slot = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n        address admin;\\n        assembly {\\n            admin := sload(slot)\\n        }\\n        if (msg.sender != admin) revert NotOwner(msg.sender, admin);\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/MessageTypes.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nuint8 constant L2_MSG = 3;\\nuint8 constant L1MessageType_L2FundedByL1 = 7;\\nuint8 constant L1MessageType_submitRetryableTx = 9;\\nuint8 constant L1MessageType_ethDeposit = 12;\\nuint8 constant L1MessageType_batchPostingReport = 13;\\nuint8 constant L2MessageType_unsignedEOATx = 0;\\nuint8 constant L2MessageType_unsignedContractTx = 1;\\n\\nuint8 constant ROLLUP_PROTOCOL_EVENT_TYPE = 8;\\nuint8 constant INITIALIZATION_MSG_TYPE = 11;\\n\"\r\n    },\r\n    \"src/libraries/Error.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\n/// @dev Init was already called\\nerror AlreadyInit();\\n\\n/// Init was called with param set to zero that must be nonzero\\nerror HadZeroInit();\\n\\n/// @dev Thrown when non owner tries to access an only-owner function\\n/// @param sender The msg.sender who is not the owner\\n/// @param owner The owner address\\nerror NotOwner(address sender, address owner);\\n\\n/// @dev Thrown when an address that is not the rollup tries to call an only-rollup function\\n/// @param sender The sender who is not the rollup\\n/// @param rollup The rollup address authorized to call this function\\nerror NotRollup(address sender, address rollup);\\n\\n/// @dev Thrown when the contract was not called directly from the origin ie msg.sender != tx.origin\\nerror NotOrigin();\\n\\n/// @dev Provided data was too large\\n/// @param dataLength The length of the data that is too large\\n/// @param maxDataLength The max length the data can be\\nerror DataTooLarge(uint256 dataLength, uint256 maxDataLength);\\n\\n/// @dev The provided is not a contract and was expected to be\\n/// @param addr The adddress in question\\nerror NotContract(address addr);\\n\\n/// @dev The merkle proof provided was too long\\n/// @param actualLength The length of the merkle proof provided\\n/// @param maxProofLength The max length a merkle proof can have\\nerror MerkleProofTooLong(uint256 actualLength, uint256 maxProofLength);\\n\\n/// @dev Thrown when an un-authorized address tries to access an admin function\\n/// @param sender The un-authorized sender\\n/// @param rollup The rollup, which would be authorized\\n/// @param owner The rollup's owner, which would be authorized\\nerror NotRollupOrOwner(address sender, address rollup, address owner);\\n\"\r\n    },\r\n    \"src/bridge/IOwnable.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"InboxMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"InboxMessageDeliveredFromOrigin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contract IBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBridge\",\"name\":\"_bridge\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"rollupInitialized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RollupEventInbox", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}