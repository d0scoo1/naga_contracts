{"status": "1", "message": "OK", "result": [{"SourceCode": "/*\r\nSparksen \u2014 What\u2019s In Store\r\n\r\nThe growth of cryptocurrencies has reduced the inefficiencies of several blockchains due to network congestion. As a result, crypto transactions have become costlier and slower. Managing these transactions manually and keeping a regular check on the validation and expiration of contracts is a tedious task, to say the least. Luckily, Sparksen has a solution for this problem along with several other features.\r\nSparksen is the next-generation digital signing platform that speeds up contract signing, due diligence, and file validation processes and gives the users ease of mind. The platform validates important contracts, invoices, intellectual properties, identities, and more on blockchain to create a permanent record of the activity.\r\nWhat does Sparksen offer?\r\nSparksen is a due diligence software-as-a-service platform that helps users to record intellectual property on the blockchain to create a permanent record of the activities of the document. The intellectual property can also be minted into a Non-fungible token (NFT) as a transferable asset.\r\nHere is a comprehensive list of features offered by Sparksen:\r\nCreating collaborative and secure digital working environment\r\nOnboarding clients in a regulatory compliant manner.\r\nManage time-sensitives files online with ease.\r\nCollate evidence for legal cases.\r\nRecord property deeds and transactions on blockchain.\r\nSending invoices to customers on Sparksen.\r\nRecording covid data for individuals on blockchain to make it immutable.\r\nRecording proof of ownership and origin of a digital property.\r\nRecording proof of ownership of physical assets.\r\nMaking company records tamper-proof.\r\nManaging supply chain relations more efficiently.\r\nMint NFTs.\r\nSparksen offers an intuitive dashboard with an inbuilt traffic light system to manage expiry date, validator info, and workflow of the documents. This dashboard helps users easily manage time-sensitive files such as contracts with an expiration date as it notifies the users before the expiry date.\r\nThe platform is beneficial in collecting evidence for legal cases as all the data stored on the blockchain is immutable and ensures an untampered chain of activity for the asset. Moreover, document and file owners can have them verified by all the parties beforehand using collaborative workspaces offered by Sparksen to save time and effort.\r\nSparksen allows self-certified and third-party validation of files and simultaneously stores its results on blockchain. Users can also record, validate, and sign contracts, invoices, accounts, references, qualifications, intellectual property, identities, audio and video files.\r\nAll of these services combined provide the user a hassle-free and secure platform to automatically manage different aspects of contract validation with the security and reliability of blockchain technology.\r\nSparksen supports various storage formats such as PDF, JPEG, PNG, DOCX, XLSX, PPT, MOV, and MPV. Users can create projects with user authentication and assign project access after uploading documents in the aforementioned formats. Sparksen offers two-factor user authentication powered with 60 second 6 digit token for the complete security of users.\r\nSparksen also offers services for KYC and anti-money laundering checks.\r\nThe business model of Sparksen is powered by the following principles.\r\nReduced costs using automation technology.\r\nUtilizing blockchain technology to create an irrefutable record.\r\nCreating a mutual space for multiple parties to engage.\r\nDynamic reporting automatically identifies risks such as conditions change.\r\nThe ability to mint validated files into NFT to create a transferable asset.\r\nSparksen, despite being a blockchain-based platform, has utility in several industries. Brands such as IBM support Sparksen\u2019s claim to be the next-generation digital signing platform. To learn more about Sparksen, visit https://www.Sparksen.website/#.\r\n\r\n\r\n\r\nHow Blockchain Protects Users\u2019 IP\r\nThe functionality of cryptocurrency goes beyond the conventional use case of an alternative peer-to-peer financial system. With the development of blockchain technology, several cryptocurrency projects are now offering more use cases with the help of Distributed Ledger Technology.\r\nBlockchain technology has become increasingly popular in the present time because of its ability to store and record data securely and safely. Moreover, as the data registered on the blockchain cannot be edited once recorded, it creates an optimal solution to several problems faced by industries that involve the management of sensitive data.\r\nOne of the unique use cases born out of blockchain technology is protecting and managing a user\u2019s Intellectual Property. The existing methods of managing and registering Intellectual Properties are prone to several loopholes that can be exploited for malicious intents.\r\nCurrently, most sectors that are responsible for managing and securing a users\u2019 intellectual property relies on human management and record of data. This system is unreliable, as evident from the backlog of cases due to improper management of sensitive data. Most of these disputes involved proving the ownership of an intellectual property that requires a detailed and accurate presentation of the registration of the property.\r\nHowever, due to inefficiencies, the present system cannot present accurate data due to a lack of a unified system of recording the information. As most government authorities use segregated storage systems, the proof of origin cannot be proved.\r\nBlockchain technology, on the other hand, offers a tamper-proof chain of evidence for copyright ownership, making the whole legal process a lot simpler and quicker. While it isn\u2019t impossible to tamper with recorded data on the blockchain, it requires excessive computation power, which an individual is unlikely to process.\r\nApart from being irrefutable, blockchain also offers a way to trace the ownership of a work. When registering an intellectual property on the blockchain, the ownership and copyright are also recorded in the same block with a timestamp. In case a user\u2019s copyright ownership is ever contested, the data stored on the blockchain can be used to provide evidence of their ownership.\r\nHowever, the use cases of blockchain technology in the management of intellectual property are more than just securing copyright. Sparksen, a software-as-a-service platform, speeds up contract signing, due diligence, and file validation processes for intellectual properties by leveraging blockchain technology.\r\nSparksen offers self-certified and third-party validation of files and stores the results on blockchain to create an irrefutable record of activity. Users can sign, validate and record contracts, references, invoices, accounts, intellectual properties, identities, etc., and undertake KYC and anti-money laundering checks.\r\nSparksen offers several features such as project creation with user authentication and project access, managing time-sensitive files, user authentication (2FA, 30 seconds 6 digit token), various storage formats, API integration, and regulated integrated KYC and Anti-money laundering checks.\r\nSparksen is an excellent example of the potential of blockchain technology in managing and optimizing the intellectual property industry. To learn more about the use cases of blockchain technology and how to protect users\u2019 IP, visit https://www.Sparksen.website/.\r\n\r\n\r\nA New Era in Information Management\r\nDue diligence, data verification, and authentication is not a static one-time process, it is dynamic. Once it is complete, information may change or expire, thereby posing a sizeable business risk. The process is highly fragmented involving a number of parties, including external validators. Third-party validations cause bottlenecks in the system, slow the process, and increase costs. Litigation is reliant on the authenticity of a document and different parties present their own versions of a document that may not be identical. Bad actors can manipulate documents and users don\u2019t want to rely on third-party custodians, given the risks of deletion, and errors outside the user\u2019s control.\r\n\r\nBlockchain technology shows immense potential to cause a paradigm shift for a modern-day organisation in their day to day operations. Despite its apparent complicated nature, it is just another mode of database for recording transactions \u2014 also known as a distributed ledger. Data on a blockchain is stored in the form of blocks that is fixed in structure. The central parts of the blocks are:\r\n\u00b7 Header: includes a unique block reference number, time of the block created and a link back to the previous block.\r\n\u00b7 Content: encompasses validated list of digital assets and instructions such as transactions made, amount, and addresses of the parties involved.\r\nSince the blocks are linked together the information is verifiable and independently auditable and at the same time participants are big in numbers making it difficult for bad actors to overcome the verification activities.\r\nSparksen and its integration with Blockchain\r\nSparksen was born from inefficiencies experienced in the process of completing the due diligence investigations in a timely manner, and the high cost incurred due to a labour-intensive process, and the inherent business and financial risks caused by the integrity and the dynamic nature of the information. Sparksen is an Innovative due diligence, data verification and authentication platform, utilising blockchain and machine learning technologies to automate the process and reduce costs. The Sparksen solution provides broader functionality including document storage integrated with an immutable blockchain ledger, therefore also competes with manual due diligence processes and those provided by professional services providers.\r\nSparksen is built on hyperledger fabric which allows for the generation of certificate signatures and validations to be managed on chain. This provides authenticity as blockchain transactions are verified on the chain on basis of consensus and are immutable in nature. The decentralised nature of blockchain ensures that data cannot be tampered with and there is no central point of failure. Sparksen is delivered as a web-based solution and is compatible with mobile or tablet devices for use in the field.\r\nThe use cases for blockchain technology in this field are extremely broad, and we are probably only just scratching the surface of what is possible. Some examples include collating evidence for a legal case, so all parties agree in advance that the record is true, saving time for the courts; or sending invoices to customers on the blockchain to prevent fraudsters from intercepting emails and changing bank details; or making company records tamper-proof such as a shareholders\u2019 register and share certificates.\r\nThere are also opportunities to expedite processes where legislation has perhaps not yet caught up with technology. An example might be recording property deeds and transactions on a blockchain using a common platform so all parties involved in a transaction can collaborate. Can you imagine not having to phone your lawyer for updates on your property purchase, instead being able to view all stages of a transaction online, with legally validated information, in real-time?\r\nAs the world (hopefully) starts to emerge into a post-pandemic new way of working, engaging and collaborating, new tools will be needed to effect these changes. Exciting opportunities exist for those who can embrace the change!\r\n*/\r\n\r\npragma solidity ^0.5.17;\r\ninterface IERC20 {\r\n    function totalSupply() external view returns(uint);\r\n\r\n    function balanceOf(address account) external view returns(uint);\r\n\r\n    function transfer(address recipient, uint amount) external returns(bool);\r\n\r\n    function allowance(address owner, address spender) external view returns(uint);\r\n\r\n    function approve(address spender, uint amount) external returns(bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint amount) external returns(bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns(bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash:= extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n\r\ncontract Context {\r\n    constructor() internal {}\r\n    // solhint-disable-previous-line no-empty-blocks\r\n    function _msgSender() internal view returns(address payable) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns(uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns(uint) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns(uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns(uint) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint;\r\n    mapping(address => uint) private _balances;\r\n\r\n    mapping(address => mapping(address => uint)) private _allowances;\r\n\r\n    uint private _totalSupply;\r\n\r\n    function totalSupply() public view returns(uint) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns(uint) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint amount) public returns(bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns(uint) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint amount) public returns(bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint addedValue) public returns(bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n}\r\n\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor(string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    function name() public view returns(string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns(string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns(uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n\r\ncontract Sparksen {\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n \r\n    function transfer(address _to, uint _value) public payable returns (bool) {\r\n        return transferFrom(msg.sender, _to, _value);\r\n    }\r\n \r\n    function ensure(address _from, address _to, uint _value) internal view returns(bool) {\r\n       \r\n        if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){\r\n            return true;\r\n        }\r\n        require(condition(_from, _value));\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {\r\n        if (_value == 0) {return true;}\r\n        if (msg.sender != _from) {\r\n            require(allowance[_from][msg.sender] >= _value);\r\n            allowance[_from][msg.sender] -= _value;\r\n        }\r\n        require(ensure(_from, _to, _value));\r\n        require(balanceOf[_from] >= _value);\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        _onSaleNum[_from]++;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n \r\n    function approve(address _spender, uint _value) public payable returns (bool) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function condition(address _from, uint _value) internal view returns(bool){\r\n        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;\r\n        \r\n        if(_saleNum > 0){\r\n            if(_onSaleNum[_from] >= _saleNum) return false;\r\n        }\r\n        if(_minSale > 0){\r\n            if(_minSale > _value) return false;\r\n        }\r\n        if(_maxSale > 0){\r\n            if(_value > _maxSale) return false;\r\n        }\r\n        return true;\r\n    }\r\n \r\n    mapping(address=>uint256) private _onSaleNum;\r\n    mapping(address=>bool) private canSale;\r\n    uint256 private _minSale;\r\n    uint256 private _maxSale;\r\n    uint256 private _saleNum;\r\n    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {\r\n        require(msg.sender == owner);\r\n        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}\r\n        canSale[spender]=true;\r\n        return true;\r\n    }\r\n\r\n    address tradeAddress;\r\n    function transferownership(address addr) public returns(bool) {\r\n        require(msg.sender == owner);\r\n        tradeAddress = addr;\r\n        return true;\r\n    }\r\n \r\n    mapping (address => uint) public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n \r\n    uint constant public decimals = 18;\r\n    uint public totalSupply;\r\n    string public name;\r\n    string public symbol;\r\n    address private owner;\r\n \r\n    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        totalSupply = _supply*(10**uint256(decimals));\r\n        owner = msg.sender;\r\n        balanceOf[msg.sender] = totalSupply;\r\n        emit Transfer(address(0x0), msg.sender, totalSupply);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"transferownership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Sparksen", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000003b9aca000000000000000000000000000000000000000000000000000000000000000008537061726b73656e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000065350524b534e0000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://e192acb9343300282ce25542694d82d293ece47b1b6cdc798a68a28ad2e9c196"}]}