{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/Vault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"./vault/VaultRestricted.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice Implementation of the {IVault} interface.\\r\\n *\\r\\n * @dev\\r\\n * All vault instances are meant to be deployed via the Controller\\r\\n * as a proxy and will not be recognizable by the Spool if they are\\r\\n * not done so.\\r\\n *\\r\\n * The vault contract is capable of supporting a single currency underlying\\r\\n * asset and deposit to multiple strategies at once, including dual-collateral\\r\\n * ones.\\r\\n *\\r\\n * The vault also supports the additional distribution of extra reward tokens as\\r\\n * an incentivization mechanism proportionate to each user's deposit amount within\\r\\n * the vhe vault.\\r\\n *\\r\\n * Vault implementation consists of following contracts:\\r\\n * 1. VaultImmutable: reads vault specific immutable variable from vault proxy contract\\r\\n * 2. VaultBase: holds vault state variables and provides some of the common vault functions\\r\\n * 3. RewardDrip: distributes vault incentivized rewards to users participating in the vault\\r\\n * 4. VaultIndexActions: implements functions to synchronize the vault with central Spool contract\\r\\n * 5. VaultRestricted: exposes functions restricted for other Spool specific contracts\\r\\n * 6. Vault: exposes unrestricted functons to interact with the core vault functionality (deposit/withdraw/claim)\\r\\n */\\r\\ncontract Vault is VaultRestricted {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using Bitwise for uint256;\\r\\n\\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the initial immutable values of the contract.\\r\\n     *\\r\\n     * @dev\\r\\n     * All values have been sanitized by the controller contract, meaning\\r\\n     * that no additional checks need to be applied here.\\r\\n     *\\r\\n     * @param _spool the spool implemenation\\r\\n     * @param _controller the controller implemenation\\r\\n     * @param _fastWithdraw fast withdraw implementation\\r\\n     * @param _feeHandler fee handler implementation\\r\\n     * @param _spoolOwner spool owner contract\\r\\n     */\\r\\n    constructor(\\r\\n        ISpool _spool,\\r\\n        IController _controller,\\r\\n        IFastWithdraw _fastWithdraw,\\r\\n        IFeeHandler _feeHandler,\\r\\n        ISpoolOwner _spoolOwner\\r\\n    )\\r\\n        VaultBase(\\r\\n            _spool,\\r\\n            _controller,\\r\\n            _fastWithdraw,\\r\\n            _feeHandler\\r\\n        )\\r\\n        SpoolOwnable(_spoolOwner)\\r\\n    {}\\r\\n\\r\\n    /* ========== DEPOSIT ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Allows a user to perform a particular deposit to the vault.\\r\\n     *\\r\\n     * @dev\\r\\n     * Emits a {Deposit} event indicating the amount newly deposited for index.\\r\\n     *\\r\\n     * Perform redeem if possible:\\r\\n     * - Vault: Index has been completed (sync deposits/withdrawals)\\r\\n     * - User: Claim deposit shares or withdrawn amount\\r\\n     * \\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the provided strategies must be valid\\r\\n     * - the caller must have pre-approved the contract for the token amount deposited\\r\\n     * - the caller cannot deposit zero value\\r\\n     * - the system should not be paused\\r\\n     *\\r\\n     * @param vaultStrategies strategies of this vault (verified internally)\\r\\n     * @param amount amount to deposit\\r\\n     * @param transferFromVault if the transfer should occur from the funds transfer(controller) address\\r\\n     */\\r\\n    function deposit(address[] memory vaultStrategies, uint128 amount, bool transferFromVault)\\r\\n        external\\r\\n        verifyStrategies(vaultStrategies)\\r\\n        hasStrategies(vaultStrategies)\\r\\n        redeemVaultStrategiesModifier(vaultStrategies)\\r\\n        redeemUserModifier\\r\\n        updateRewards\\r\\n    {\\r\\n        require(amount > 0, \\\"NDP\\\");\\r\\n\\r\\n        // get next possible index to deposit\\r\\n        uint24 activeGlobalIndex = _getActiveGlobalIndex();\\r\\n\\r\\n        // Mark user deposited amount for active index\\r\\n        vaultIndexAction[activeGlobalIndex].depositAmount += amount;\\r\\n        userIndexAction[msg.sender][activeGlobalIndex].depositAmount += amount;\\r\\n\\r\\n        // Mark vault strategies to deposit at index\\r\\n        _distributeInStrats(vaultStrategies, amount, activeGlobalIndex);\\r\\n\\r\\n        // mark that vault and user have interacted at this global index\\r\\n        _updateInteractedIndex(activeGlobalIndex);\\r\\n        _updateUserInteractedIndex(activeGlobalIndex);\\r\\n\\r\\n        // transfer user deposit to Spool\\r\\n        _transferDepositToSpool(amount, transferFromVault);\\r\\n\\r\\n        // store user deposit amount\\r\\n        _addInstantDeposit(amount);\\r\\n\\r\\n        emit Deposit(msg.sender, activeGlobalIndex, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Distributes a deposit to the various strategies based on the allocations of the vault.\\r\\n     */\\r\\n    function _distributeInStrats(\\r\\n        address[] memory vaultStrategies,\\r\\n        uint128 amount,\\r\\n        uint256 activeGlobalIndex\\r\\n    ) private {\\r\\n        uint128 amountLeft = amount;\\r\\n        uint256 lastElement = vaultStrategies.length - 1;\\r\\n        uint256 _proportions = proportions;\\r\\n\\r\\n        for (uint256 i; i < lastElement; i++) {\\r\\n            uint128 proportionateAmount = _getStrategyDepositAmount(_proportions, i, amount);\\r\\n            if (proportionateAmount > 0) {\\r\\n                spool.deposit(vaultStrategies[i], proportionateAmount, activeGlobalIndex);\\r\\n                amountLeft -= proportionateAmount;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (amountLeft > 0) {\\r\\n            spool.deposit(vaultStrategies[lastElement], amountLeft, activeGlobalIndex);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* ========== WITHDRAW ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Allows a user to withdraw their deposited funds from the vault at next possible index.\\r\\n     * The withdrawal is queued for when do hard work for index is completed.\\r\\n     * \\r\\n     * @dev\\r\\n     * Perform redeem if possible:\\r\\n     * - Vault: Index has been completed (sync deposits/withdrawals)\\r\\n     * - User: Claim deposit shares or withdrawn amount\\r\\n     *\\r\\n     * Emits a {Withdrawal} event indicating the shares burned, index of the withdraw and the amount of funds withdrawn.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - vault must not be reallocating\\r\\n     * - the provided strategies must be valid\\r\\n     * - the caller must have a non-zero amount of shares to withdraw\\r\\n     * - the caller must have enough shares to withdraw the specified share amount\\r\\n     * - the system should not be paused\\r\\n     *\\r\\n     * @param vaultStrategies strategies of this vault (verified internally)\\r\\n     * @param sharesToWithdraw shares amount to withdraw\\r\\n     * @param withdrawAll if all shares should be removed\\r\\n     */\\r\\n    function withdraw(\\r\\n        address[] memory vaultStrategies,\\r\\n        uint128 sharesToWithdraw,\\r\\n        bool withdrawAll\\r\\n    )\\r\\n        external\\r\\n        verifyStrategies(vaultStrategies)\\r\\n        redeemVaultStrategiesModifier(vaultStrategies)\\r\\n        noReallocation\\r\\n        redeemUserModifier\\r\\n        updateRewards\\r\\n    {\\r\\n        sharesToWithdraw = _withdrawShares(sharesToWithdraw, withdrawAll);\\r\\n        \\r\\n        // get next possible index to withdraw\\r\\n        uint24 activeGlobalIndex = _getActiveGlobalIndex();\\r\\n\\r\\n        // mark user withdrawn shares amount for active index\\r\\n        userIndexAction[msg.sender][activeGlobalIndex].withdrawShares += sharesToWithdraw;\\r\\n        vaultIndexAction[activeGlobalIndex].withdrawShares += sharesToWithdraw;\\r\\n\\r\\n        // mark strategies in the spool contract to be withdrawn at next possible index\\r\\n        _withdrawFromStrats(vaultStrategies, sharesToWithdraw, activeGlobalIndex);\\r\\n\\r\\n        // mark that vault and user interacted at this global index\\r\\n        _updateInteractedIndex(activeGlobalIndex);\\r\\n        _updateUserInteractedIndex(activeGlobalIndex);\\r\\n\\r\\n        emit Withdraw(msg.sender, activeGlobalIndex, sharesToWithdraw);\\r\\n    }\\r\\n\\r\\n    /* ========== FAST WITHDRAW ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Allows a user to withdraw their deposited funds right away.\\r\\n     *\\r\\n     * @dev\\r\\n     * @dev\\r\\n     * User can execute the withdrawal of his shares from the vault at any time without\\r\\n     * waiting for the DHW to process it. This is done independently of other events (e.g. DHW)\\r\\n     * and the gas cost is paid entirely by the user.\\r\\n     * Shares belonging to the user and are sent back to the FastWithdraw contract\\r\\n     * where an actual withdrawal can be peformed, where user recieves the underlying tokens\\r\\n     * right away.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - vault must not be reallocating\\r\\n     * - the spool system must not be mid reallocation\\r\\n     *   (started DHW and not finished, at index the reallocation was initiated)\\r\\n     * - the provided strategies must be valid\\r\\n     * - the sistem must not be in the middle of the reallocation\\r\\n     * - the system should not be paused\\r\\n     *\\r\\n     * @param vaultStrategies strategies of this vault\\r\\n     * @param sharesToWithdraw shares amount to withdraw\\r\\n     * @param withdrawAll if all shares should be removed\\r\\n     * @param fastWithdrawParams extra parameters to perform fast withdraw\\r\\n     */\\r\\n    function withdrawFast(\\r\\n        address[] memory vaultStrategies,\\r\\n        uint128 sharesToWithdraw,\\r\\n        bool withdrawAll,\\r\\n        FastWithdrawParams memory fastWithdrawParams\\r\\n    )\\r\\n        external\\r\\n        noMidReallocation\\r\\n        verifyStrategies(vaultStrategies)\\r\\n        redeemVaultStrategiesModifier(vaultStrategies)\\r\\n        noReallocation\\r\\n        redeemUserModifier\\r\\n        updateRewards\\r\\n    {\\r\\n        sharesToWithdraw = _withdrawShares(sharesToWithdraw, withdrawAll);\\r\\n\\r\\n        uint256 vaultShareProportion = _getVaultShareProportion(sharesToWithdraw);\\r\\n        totalShares -= sharesToWithdraw;\\r\\n\\r\\n        uint128[] memory strategyRemovedShares = spool.removeShares(vaultStrategies, vaultShareProportion);\\r\\n\\r\\n        uint256 proportionateDeposit = _getUserProportionateDeposit(sharesToWithdraw);\\r\\n\\r\\n        // transfer removed shares to fast withdraw contract\\r\\n        fastWithdraw.transferShares(\\r\\n            vaultStrategies,\\r\\n            strategyRemovedShares,\\r\\n            proportionateDeposit,\\r\\n            msg.sender,\\r\\n            fastWithdrawParams\\r\\n        );\\r\\n\\r\\n        emit WithdrawFast(msg.sender, sharesToWithdraw);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Updates storage values according to shares withdrawn.\\r\\n     *      If `withdrawAll` is true, all shares are removed from the users\\r\\n     * @param sharesToWithdraw Amount of shares to withdraw\\r\\n     * @param withdrawAll Withdraw all user shares\\r\\n     */\\r\\n    function _withdrawShares(uint128 sharesToWithdraw, bool withdrawAll) private returns(uint128) {\\r\\n        User storage user = users[msg.sender];\\r\\n        uint128 userShares = user.shares;\\r\\n\\r\\n        uint128 userActiveInstantDeposit = user.instantDeposit;\\r\\n\\r\\n        // Substract the not processed instant deposit\\r\\n        // This way we don't consider the deposit that was not yet processed by the DHW\\r\\n        // when calculating amount of it withdrawn\\r\\n        LastIndexInteracted memory userIndexInteracted = userLastInteractions[msg.sender];\\r\\n        if (userIndexInteracted.index1 > 0) {\\r\\n            userActiveInstantDeposit -= userIndexAction[msg.sender][userIndexInteracted.index1].depositAmount;\\r\\n            // also check if user second index has pending actions\\r\\n            if (userIndexInteracted.index2 > 0) {\\r\\n                userActiveInstantDeposit -= userIndexAction[msg.sender][userIndexInteracted.index2].depositAmount;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        // check if withdraw all flag was set or user requested\\r\\n        // withdraw of all shares in `sharesToWithdraw`\\r\\n        if (withdrawAll || userShares == sharesToWithdraw) {\\r\\n            sharesToWithdraw = userShares;\\r\\n            // set user shares to 0\\r\\n            user.shares = 0;\\r\\n\\r\\n            // substract all the users instant deposit processed till now\\r\\n            // substract the same amount from vault total instand deposit value\\r\\n            totalInstantDeposit -= userActiveInstantDeposit;\\r\\n            user.instantDeposit -= userActiveInstantDeposit;\\r\\n        } else {\\r\\n            require(\\r\\n                userShares >= sharesToWithdraw &&\\r\\n                sharesToWithdraw > 0, \\r\\n                \\\"WSH\\\"\\r\\n            );\\r\\n\\r\\n            // if we didnt withdraw all calculate the proportion of\\r\\n            // the instant deposit to substract it from the user and vault amounts\\r\\n            uint128 instantDepositWithdrawn = _getProportion128(userActiveInstantDeposit, sharesToWithdraw, userShares);\\r\\n\\r\\n            totalInstantDeposit -= instantDepositWithdrawn;\\r\\n            user.instantDeposit -= instantDepositWithdrawn;\\r\\n\\r\\n            // susrtact withdrawn shares from the user\\r\\n            // NOTE: vault shares will be substracted when the at the redeem\\r\\n            // for the current active index is processed. This way we substract it\\r\\n            // only once for all the users.\\r\\n            user.shares = userShares - sharesToWithdraw;\\r\\n        }\\r\\n        \\r\\n        return sharesToWithdraw;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates user proportionate deposit when withdrawing and updated user deposit storage\\r\\n     * @dev Checks user index action to see if user already has some withdrawn shares\\r\\n     *      pending to be processed.\\r\\n     *      Called when performing the fast withdraw\\r\\n     *\\r\\n     * @param sharesToWithdraw shares amount to withdraw\\r\\n     *\\r\\n     * @return User deposit amount proportionate to the amount of shares being withdrawn\\r\\n     */\\r\\n    function _getUserProportionateDeposit(uint128 sharesToWithdraw) private returns(uint256) {\\r\\n        User storage user = users[msg.sender];\\r\\n        LastIndexInteracted memory userIndexInteracted = userLastInteractions[msg.sender];\\r\\n\\r\\n        uint128 proportionateDeposit;\\r\\n        uint128 sharesAtWithdrawal = user.shares + sharesToWithdraw;\\r\\n\\r\\n        if (userIndexInteracted.index1 > 0) {\\r\\n            sharesAtWithdrawal += userIndexAction[msg.sender][userIndexInteracted.index1].withdrawShares;\\r\\n\\r\\n            if (userIndexInteracted.index2 > 0) {\\r\\n                sharesAtWithdrawal += userIndexAction[msg.sender][userIndexInteracted.index2].withdrawShares;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (sharesAtWithdrawal > sharesToWithdraw) {\\r\\n            uint128 userTotalDeposit = user.activeDeposit;\\r\\n            proportionateDeposit = _getProportion128(userTotalDeposit, sharesToWithdraw, sharesAtWithdrawal);\\r\\n            user.activeDeposit = userTotalDeposit - proportionateDeposit;\\r\\n        } else {\\r\\n            proportionateDeposit = user.activeDeposit;\\r\\n            user.activeDeposit = 0;\\r\\n        }\\r\\n\\r\\n        return proportionateDeposit;\\r\\n    }\\r\\n\\r\\n    function _withdrawFromStrats(address[] memory vaultStrategies, uint128 totalSharesToWithdraw, uint256 activeGlobalIndex) private {\\r\\n        uint256 vaultShareProportion = _getVaultShareProportion(totalSharesToWithdraw);\\r\\n        for (uint256 i; i < vaultStrategies.length; i++) {\\r\\n            spool.withdraw(vaultStrategies[i], vaultShareProportion, activeGlobalIndex);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* ========== CLAIM ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Allows a user to claim their debt from the vault after withdrawn shares were processed.\\r\\n     *\\r\\n     * @dev\\r\\n     * Fee is taken from the profit\\r\\n     * Perform redeem on user demand\\r\\n     *\\r\\n     * Emits a {DebtClaim} event indicating the debt the user claimed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - if `doRedeemVault` is true, the provided strategies must be valid\\r\\n     * - the caller must have a non-zero debt owed\\r\\n     * - the system should not be paused (if doRedeemVault)\\r\\n     *\\r\\n     * @param doRedeemVault flag, to execute redeem for the vault (synchronize deposit/withdrawals with the system)\\r\\n     * @param vaultStrategies vault stratigies\\r\\n     * @param doRedeemUser flag, to execute redeem for the caller\\r\\n     *\\r\\n     * @return claimAmount amount of underlying asset, claimed by the caller\\r\\n     */\\r\\n    function claim(\\r\\n        bool doRedeemVault,\\r\\n        address[] memory vaultStrategies,\\r\\n        bool doRedeemUser\\r\\n    ) external returns (uint128 claimAmount) {\\r\\n        User storage user = users[msg.sender];\\r\\n\\r\\n        if (doRedeemVault) {\\r\\n            _verifyStrategies(vaultStrategies);\\r\\n            _redeemVaultStrategies(vaultStrategies);\\r\\n        }\\r\\n\\r\\n        if (doRedeemUser) {\\r\\n            _redeemUser();\\r\\n        }\\r\\n\\r\\n        claimAmount = user.owed;\\r\\n        require(claimAmount > 0, \\\"CA0\\\");\\r\\n\\r\\n        user.owed = 0;\\r\\n\\r\\n        // Calculate profit and take fees\\r\\n        uint128 userWithdrawnDeposits = user.withdrawnDeposits;\\r\\n        if (claimAmount > userWithdrawnDeposits) {\\r\\n            user.withdrawnDeposits = 0;\\r\\n            uint128 profit = claimAmount - userWithdrawnDeposits;\\r\\n\\r\\n            uint128 feesPaid = _payFeesAndTransfer(profit);\\r\\n\\r\\n            // Substract fees paid from claim amount\\r\\n            claimAmount -= feesPaid;\\r\\n        } else {\\r\\n            user.withdrawnDeposits = userWithdrawnDeposits - claimAmount;\\r\\n        }\\r\\n\\r\\n        _underlying().safeTransfer(msg.sender, claimAmount);\\r\\n\\r\\n        emit Claimed(msg.sender, claimAmount);\\r\\n    }\\r\\n\\r\\n    /* ========== REDEEM ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Redeem vault and user deposit and withdrawals\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the provided strategies must be valid\\r\\n     *\\r\\n     * @param vaultStrategies vault stratigies\\r\\n     */\\r\\n    function redeemVaultAndUser(address[] memory vaultStrategies)\\r\\n        external\\r\\n        verifyStrategies(vaultStrategies)\\r\\n        redeemVaultStrategiesModifier(vaultStrategies)\\r\\n        redeemUserModifier\\r\\n    {}\\r\\n\\r\\n    /**\\r\\n     * @notice Redeem vault and user and return the user state\\r\\n     * @dev This function should be called as static and act as view\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the provided strategies must be valid\\r\\n     *\\r\\n     * @param vaultStrategies vault stratigies\\r\\n     *\\r\\n     * @return user state after reedeem\\r\\n     */\\r\\n    function getUpdatedUser(address[] memory vaultStrategies)\\r\\n        external\\r\\n        verifyStrategies(vaultStrategies)\\r\\n        redeemVaultStrategiesModifier(vaultStrategies)\\r\\n        redeemUserModifier\\r\\n        returns(uint256, uint256, uint256, uint256, uint256)\\r\\n    {\\r\\n        User memory user = users[msg.sender];\\r\\n\\r\\n        uint256 totalUnderlying = 0;\\r\\n        for (uint256 i; i < vaultStrategies.length; i++) {\\r\\n            totalUnderlying += spool.getUnderlying(vaultStrategies[i]);\\r\\n        }\\r\\n\\r\\n        uint256 userTotalUnderlying;\\r\\n        if (totalShares > 0 && user.shares > 0) {\\r\\n            userTotalUnderlying = (totalUnderlying * user.shares) / totalShares;\\r\\n        }\\r\\n\\r\\n        return (\\r\\n            user.shares,\\r\\n            user.activeDeposit, // amount of user deposited underlying token\\r\\n            user.owed, // underlying token claimable amount\\r\\n            user.withdrawnDeposits, // underlying token withdrawn amount\\r\\n            userTotalUnderlying\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Redeem vault strategy deposits and withdrawals after do hard work.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the provided strategies must be valid\\r\\n     *\\r\\n     * @param vaultStrategies vault strategies\\r\\n     */\\r\\n    function redeemVaultStrategies(address[] memory vaultStrategies)\\r\\n        external\\r\\n        verifyStrategies(vaultStrategies)\\r\\n        redeemVaultStrategiesModifier(vaultStrategies)\\r\\n    {}\\r\\n\\r\\n    /**\\r\\n     * @notice Redeem vault strategy deposits and withdrawals after do hard work.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the provided strategies must be valid\\r\\n     *\\r\\n     * @param vaultStrategies vault strategies\\r\\n     * @return totalUnderlying total vault underlying\\r\\n     * @return totalShares underlying and shares after redeem\\r\\n     */\\r\\n    function getUpdatedVault(address[] memory vaultStrategies)\\r\\n        external\\r\\n        verifyStrategies(vaultStrategies)\\r\\n        redeemVaultStrategiesModifier(vaultStrategies)\\r\\n        returns(uint256, uint256)\\r\\n    {\\r\\n        uint256 totalUnderlying = 0;\\r\\n        for (uint256 i; i < vaultStrategies.length; i++) {\\r\\n            totalUnderlying += spool.getUnderlying(vaultStrategies[i]);\\r\\n        }\\r\\n        return (totalUnderlying, totalShares);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Redeem user deposits and withdrawals\\r\\n     *\\r\\n     * @dev Can only redeem user up to last index vault has redeemed\\r\\n     */\\r\\n    function redeemUser()\\r\\n        external\\r\\n    {\\r\\n        _redeemUser();\\r\\n    }\\r\\n\\r\\n    /* ========== STRATEGY REMOVED ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Notify a vault a strategy was removed from the Spool system\\r\\n     * @dev\\r\\n     * This can be called by anyone after a strategy has been removed from the system.\\r\\n     * After the removal of the strategy that the vault contains, all actions\\r\\n     * calling central Spool contract will revert. This function must be called,\\r\\n     * to remove the strategy from the vault and update the strategy hash according\\r\\n     * to the new strategy array.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The Spool system must finish reallocation if it's in progress\\r\\n     * - the provided strategies must be valid\\r\\n     * - The strategy must belong to this vault\\r\\n     * - The strategy must be removed from the system\\r\\n     *\\r\\n     * @param vaultStrategies Array of current vault strategies (including the removed one)\\r\\n     * @param i Index of the removed strategy in the `vaultStrategies`\\r\\n     */\\r\\n    function notifyStrategyRemoved(\\r\\n        address[] memory vaultStrategies,\\r\\n        uint256 i\\r\\n    )\\r\\n        external\\r\\n        reallocationFinished\\r\\n        verifyStrategies(vaultStrategies)\\r\\n        hasStrategies(vaultStrategies)\\r\\n        redeemVaultStrategiesModifier(vaultStrategies)\\r\\n    {\\r\\n        require(\\r\\n            i < vaultStrategies.length &&\\r\\n            !controller.validStrategy(vaultStrategies[i]),\\r\\n            \\\"BSTR\\\"\\r\\n        );\\r\\n\\r\\n        uint256 lastElement = vaultStrategies.length - 1;\\r\\n\\r\\n        address[] memory newStrategies = new address[](lastElement);\\r\\n\\r\\n        if (lastElement > 0) {\\r\\n            for (uint256 j; j < lastElement; j++) {\\r\\n                newStrategies[j] = vaultStrategies[j];\\r\\n            }\\r\\n\\r\\n            if (i < lastElement) {\\r\\n                newStrategies[i] = vaultStrategies[lastElement];\\r\\n            }\\r\\n\\r\\n            uint256 _proportions = proportions;\\r\\n            uint256 proportionsLeft = FULL_PERCENT - _proportions.get14BitUintByIndex(i);\\r\\n            if (lastElement > 1 && proportionsLeft > 0) {\\r\\n                if (i == lastElement) {\\r\\n                    _proportions = _proportions.reset14BitUintByIndex(i);\\r\\n                } else {\\r\\n                    uint256 lastProportion = _proportions.get14BitUintByIndex(lastElement);\\r\\n                    _proportions = _proportions.reset14BitUintByIndex(i);\\r\\n                    _proportions = _proportions.set14BitUintByIndex(i, lastProportion);\\r\\n                }\\r\\n\\r\\n                uint256 newProportions = _proportions;\\r\\n\\r\\n                uint256 lastNewElement = lastElement - 1;\\r\\n                uint256 newProportionsLeft = FULL_PERCENT;\\r\\n                for (uint256 j; j < lastNewElement; j++) {\\r\\n                    uint256 propJ = _proportions.get14BitUintByIndex(j);\\r\\n                    propJ = (propJ * FULL_PERCENT) / proportionsLeft;\\r\\n                    newProportions = newProportions.set14BitUintByIndex(j, propJ);\\r\\n                    newProportionsLeft -= propJ;\\r\\n                }\\r\\n\\r\\n                newProportions = newProportions.set14BitUintByIndex(lastNewElement, newProportionsLeft);\\r\\n\\r\\n                proportions = newProportions;\\r\\n            } else {\\r\\n                proportions = FULL_PERCENT;\\r\\n            }\\r\\n        } else {\\r\\n            proportions = 0;\\r\\n        }\\r\\n\\r\\n        _updateStrategiesHash(newStrategies);\\r\\n        emit StrategyRemoved(i, vaultStrategies[i]);\\r\\n    }\\r\\n\\r\\n    /* ========== PRIVATE FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Throws if given array of strategies is empty\\r\\n     */\\r\\n    function _hasStrategies(address[] memory vaultStrategies) private pure {\\r\\n        require(vaultStrategies.length > 0, \\\"NST\\\");\\r\\n    }\\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Throws if given array of strategies is empty\\r\\n     */\\r\\n    modifier hasStrategies(address[] memory vaultStrategies) {\\r\\n        _hasStrategies(vaultStrategies);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Revert if reallocation is not finished for this vault\\r\\n     */\\r\\n    modifier reallocationFinished() {\\r\\n        require(\\r\\n            !_isVaultReallocating() ||\\r\\n            reallocationIndex <= spool.getCompletedGlobalIndex(),\\r\\n            \\\"RNF\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/utils/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\ninterface IController {\\n    /* ========== FUNCTIONS ========== */\\n\\n    function strategies(uint256 i) external view returns (address);\\n\\n    function validStrategy(address strategy) external view returns (bool);\\n\\n    function validVault(address vault) external view returns (bool);\\n\\n    function getStrategiesCount() external view returns(uint8);\\n\\n    function supportedUnderlying(IERC20 underlying)\\n        external\\n        view\\n        returns (bool);\\n\\n    function getAllStrategies() external view returns (address[] memory);\\n\\n    function verifyStrategies(address[] calldata _strategies) external view;\\n\\n    function transferToSpool(\\n        address transferFrom,\\n        uint256 amount\\n    ) external;\\n\\n    function checkPaused() external view;\\n\\n    /* ========== EVENTS ========== */\\n\\n    event EmergencyWithdrawStrategy(address indexed strategy);\\n    event EmergencyRecipientUpdated(address indexed recipient);\\n    event EmergencyWithdrawerUpdated(address indexed withdrawer, bool set);\\n    event PauserUpdated(address indexed user, bool set);\\n    event UnpauserUpdated(address indexed user, bool set);\\n    event VaultCreated(address indexed vault, address underlying, address[] strategies, uint256[] proportions,\\n        uint16 vaultFee, address riskProvider, int8 riskTolerance);\\n    event StrategyAdded(address strategy);\\n    event StrategyRemoved(address strategy);\\n    event VaultInvalid(address vault);\\n    event DisableStrategy(address strategy);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFastWithdraw.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./ISwapData.sol\\\";\\n\\nstruct FastWithdrawParams {\\n    bool doExecuteWithdraw;\\n    uint256[][] slippages;\\n    SwapData[][] swapData;\\n}\\n\\ninterface IFastWithdraw {\\n    function transferShares(\\n        address[] calldata vaultStrategies,\\n        uint128[] calldata sharesWithdrawn,\\n        uint256 proportionateDeposit,\\n        address user,\\n        FastWithdrawParams calldata fastWithdrawParams\\n    ) external;\\n\\n        /* ========== EVENTS ========== */\\n\\n    event StrategyWithdrawn(address indexed user, address indexed vault, address indexed strategy);\\n    event UserSharesSaved(address indexed user, address indexed vault);\\n    event FastWithdrawExecuted(address indexed user, address indexed vault, uint256 totalWithdrawn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeeHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\ninterface IFeeHandler {\\n    function payFees(\\n        IERC20 underlying,\\n        uint256 profit,\\n        address riskProvider,\\n        address vaultOwner,\\n        uint16 vaultFee\\n    ) external returns (uint256 feesPaid);\\n\\n    function setRiskProviderFee(address riskProvider, uint16 fee) external;\\n\\n    /* ========== EVENTS ========== */\\n\\n    event FeesPaid(address indexed vault, uint profit, uint ecosystemCollected, uint treasuryCollected, uint riskProviderColected, uint vaultFeeCollected);\\n    event RiskProviderFeeUpdated(address indexed riskProvider, uint indexed fee);\\n    event EcosystemFeeUpdated(uint indexed fee);\\n    event TreasuryFeeUpdated(uint indexed fee);\\n    event EcosystemCollectorUpdated(address indexed collector);\\n    event TreasuryCollectorUpdated(address indexed collector);\\n    event FeeCollected(address indexed collector, IERC20 indexed underlying, uint amount);\\n    event EcosystemFeeCollected(IERC20 indexed underlying, uint amount);\\n    event TreasuryFeeCollected(IERC20 indexed underlying, uint amount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISpool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./spool/ISpoolExternal.sol\\\";\\nimport \\\"./spool/ISpoolReallocation.sol\\\";\\nimport \\\"./spool/ISpoolDoHardWork.sol\\\";\\nimport \\\"./spool/ISpoolStrategy.sol\\\";\\nimport \\\"./spool/ISpoolBase.sol\\\";\\n\\n/// @notice Utility Interface for central Spool implementation\\ninterface ISpool is ISpoolExternal, ISpoolReallocation, ISpoolDoHardWork, ISpoolStrategy, ISpoolBase {}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISpoolOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\ninterface ISpoolOwner {\\r\\n    function isSpoolOwner(address user) external view returns(bool);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISwapData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\n/**\\r\\n * @notice Strict holding information how to swap the asset\\r\\n * @member slippage minumum output amount\\r\\n * @member path swap path, first byte represents an action (e.g. Uniswap V2 custom swap), rest is swap specific path\\r\\n */\\r\\nstruct SwapData {\\r\\n    uint256 slippage; // min amount out\\r\\n    bytes path; // 1st byte is action, then path \\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/spool/ISpoolBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\ninterface ISpoolBase {\\n    /* ========== FUNCTIONS ========== */\\n\\n    function getCompletedGlobalIndex() external view returns(uint24);\\n\\n    function getActiveGlobalIndex() external view returns(uint24);\\n\\n    function isMidReallocation() external view returns (bool);\\n\\n    /* ========== EVENTS ========== */\\n\\n    event ReallocationTableUpdated(\\n        uint24 indexed index,\\n        bytes32 reallocationTableHash\\n    );\\n\\n    event ReallocationTableUpdatedWithTable(\\n        uint24 indexed index,\\n        bytes32 reallocationTableHash,\\n        uint256[][] reallocationTable\\n    );\\n    \\n    event DoHardWorkCompleted(uint24 indexed index);\\n\\n    event SetAllocationProvider(address actor, bool isAllocationProvider);\\n    event SetIsDoHardWorker(address actor, bool isDoHardWorker);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/spool/ISpoolDoHardWork.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\ninterface ISpoolDoHardWork {\\r\\n    /* ========== EVENTS ========== */\\r\\n\\r\\n    event DoHardWorkStrategyCompleted(address indexed strat, uint256 indexed index);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/spool/ISpoolExternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"../ISwapData.sol\\\";\\n\\ninterface ISpoolExternal {\\n    /* ========== FUNCTIONS ========== */\\n\\n    function deposit(address strategy, uint128 amount, uint256 index) external;\\n\\n    function withdraw(address strategy, uint256 vaultProportion, uint256 index) external;\\n\\n    function fastWithdrawStrat(address strat, address underlying, uint256 shares, uint256[] calldata slippages, SwapData[] calldata swapData) external returns(uint128);\\n\\n    function redeem(address strat, uint256 index) external returns (uint128, uint128);\\n\\n    function redeemUnderlying(uint128 amount) external;\\n\\n    function redeemReallocation(address[] calldata vaultStrategies, uint256 depositProportions, uint256 index) external;\\n\\n    function removeShares(address[] calldata vaultStrategies, uint256 vaultProportion) external returns(uint128[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/spool/ISpoolReallocation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\ninterface ISpoolReallocation {\\n    event StartReallocation(uint24 indexed index);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/spool/ISpoolStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\ninterface ISpoolStrategy {\\n    /* ========== FUNCTIONS ========== */\\n\\n    function getUnderlying(address strat) external returns (uint128);\\n    \\n    function getVaultTotalUnderlyingAtIndex(address strat, uint256 index) external view returns(uint128);\\n\\n    function addStrategy(address strat) external;\\n\\n    function disableStrategy(address strategy, bool skipDisable) external;\\n\\n    function runDisableStrategy(address strategy) external;\\n\\n    function emergencyWithdraw(\\n        address strat,\\n        address withdrawRecipient,\\n        uint256[] calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/vault/IRewardDrip.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"../../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\ninterface IRewardDrip {\\n    /* ========== STRUCTS ========== */\\n\\n    // The reward configuration struct, containing all the necessary data of a typical Synthetix StakingReward contract\\n    struct RewardConfiguration {\\n        uint32 rewardsDuration;\\n        uint32 periodFinish;\\n        uint192 rewardRate; // rewards per second multiplied by accuracy\\n        uint32 lastUpdateTime;\\n        uint224 rewardPerTokenStored;\\n        mapping(address => uint256) userRewardPerTokenPaid;\\n        mapping(address => uint256) rewards;\\n    }\\n\\n    /* ========== FUNCTIONS ========== */\\n\\n    function getActiveRewards(address account) external;\\n    function tokenBlacklist(IERC20 token) view external returns(bool);\\n\\n    /* ========== EVENTS ========== */\\n    \\n    event RewardPaid(IERC20 token, address indexed user, uint256 reward);\\n    event RewardAdded(IERC20 indexed token, uint256 amount, uint256 duration);\\n    event RewardExtended(IERC20 indexed token, uint256 amount, uint256 leftover, uint256 duration, uint32 periodFinish);\\n    event RewardRemoved(IERC20 indexed token);\\n    event PeriodFinishUpdated(IERC20 indexed token, uint32 periodFinish);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/vault/IVaultBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./IVaultDetails.sol\\\";\\n\\ninterface IVaultBase {\\n    /* ========== FUNCTIONS ========== */\\n\\n    function initialize(VaultInitializable calldata vaultInitializable) external;\\n\\n    /* ========== STRUCTS ========== */\\n\\n    struct User {\\n        uint128 instantDeposit; // used for calculating rewards\\n        uint128 activeDeposit; // users deposit after deposit process and claim\\n        uint128 owed; // users owed underlying amount after withdraw has been processed and claimed\\n        uint128 withdrawnDeposits; // users withdrawn deposit, used to calculate performance fees\\n        uint128 shares; // users shares after deposit process and claim\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event Claimed(address indexed member, uint256 claimAmount);\\n    event Deposit(address indexed member, uint256 indexed index, uint256 amount);\\n    event Withdraw(address indexed member, uint256 indexed index, uint256 shares);\\n    event WithdrawFast(address indexed member, uint256 shares);\\n    event StrategyRemoved(uint256 i, address strategy);\\n    event TransferVaultOwner(address owner);\\n    event LowerVaultFee(uint16 fee);\\n    event UpdateName(string name);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/vault/IVaultDetails.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nstruct VaultDetails {\\n    address underlying;\\n    address[] strategies;\\n    uint256[] proportions;\\n    address creator;\\n    uint16 vaultFee;\\n    address riskProvider;\\n    int8 riskTolerance;\\n    string name;\\n}\\n\\nstruct VaultInitializable {\\n    string name;\\n    address owner;\\n    uint16 fee;\\n    address[] strategies;\\n    uint256[] proportions;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/vault/IVaultImmutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"../../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\nstruct VaultImmutables {\\n    IERC20 underlying;\\n    address riskProvider;\\n    int8 riskTolerance;\\n}\\n\\ninterface IVaultImmutable {\\n    /* ========== FUNCTIONS ========== */\\n\\n    function underlying() external view returns (IERC20);\\n\\n    function riskProvider() external view returns (address);\\n\\n    function riskTolerance() external view returns (int8);\\n}\"\r\n    },\r\n    \"contracts/interfaces/vault/IVaultIndexActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\ninterface IVaultIndexActions {\\n\\n    /* ========== STRUCTS ========== */\\n\\n    struct IndexAction {\\n        uint128 depositAmount;\\n        uint128 withdrawShares;\\n    }\\n\\n    struct LastIndexInteracted {\\n        uint128 index1;\\n        uint128 index2;\\n    }\\n\\n    struct Redeem {\\n        uint128 depositShares;\\n        uint128 withdrawnAmount;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event VaultRedeem(uint indexed globalIndex);\\n    event UserRedeem(address indexed member, uint indexed globalIndex);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/vault/IVaultRestricted.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\ninterface IVaultRestricted {\\n    /* ========== FUNCTIONS ========== */\\n    \\n    function reallocate(\\n        address[] calldata vaultStrategies,\\n        uint256 newVaultProportions,\\n        uint256 finishedIndex,\\n        uint24 activeIndex\\n    ) external returns (uint256[] memory, uint256);\\n\\n    function payFees(uint256 profit) external returns (uint256 feesPaid);\\n\\n    /* ========== EVENTS ========== */\\n\\n    event Reallocate(uint24 indexed index, uint256 newProportions);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Bitwise.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.11;\\n\\nlibrary Bitwise {\\n    function get8BitUintByIndex(uint256 bitwiseData, uint256 i) internal pure returns(uint256) {\\n        return (bitwiseData >> (8 * i)) & type(uint8).max;\\n    }\\n\\n    // 14 bits is used for strategy proportions in a vault as FULL_PERCENT is 10_000\\n    function get14BitUintByIndex(uint256 bitwiseData, uint256 i) internal pure returns(uint256) {\\n        return (bitwiseData >> (14 * i)) & (16_383); // 16.383 is 2^14 - 1\\n    }\\n\\n    function set14BitUintByIndex(uint256 bitwiseData, uint256 i, uint256 num14bit) internal pure returns(uint256) {\\n        return bitwiseData + (num14bit << (14 * i));\\n    }\\n\\n    function reset14BitUintByIndex(uint256 bitwiseData, uint256 i) internal pure returns(uint256) {\\n        return bitwiseData & (~(16_383 << (14 * i)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Hash.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\n/**\\r\\n * @notice Library to provide utils for hashing and hash compatison of Spool related data\\r\\n */\\r\\nlibrary Hash {\\r\\n    function hashReallocationTable(uint256[][] memory reallocationTable) internal pure returns(bytes32) {\\r\\n        return keccak256(abi.encode(reallocationTable));\\r\\n    }\\r\\n\\r\\n    function hashStrategies(address[] memory strategies) internal pure returns(bytes32) {\\r\\n        return keccak256(abi.encodePacked(strategies));\\r\\n    }\\r\\n\\r\\n    function sameStrategies(address[] memory strategies1, address[] memory strategies2) internal pure returns(bool) {\\r\\n        return hashStrategies(strategies1) == hashStrategies(strategies2);\\r\\n    }\\r\\n\\r\\n    function sameStrategies(address[] memory strategies, bytes32 strategiesHash) internal pure returns(bool) {\\r\\n        return hashStrategies(strategies) == strategiesHash;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../external/@openzeppelin/utils/SafeCast.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @notice A collection of custom math ustils used throughout the system\\r\\n */\\r\\nlibrary Math {\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a > b ? b : a;\\r\\n    }\\r\\n\\r\\n    function getProportion128(uint256 mul1, uint256 mul2, uint256 div) internal pure returns (uint128) {\\r\\n        return SafeCast.toUint128(((mul1 * mul2) / div));\\r\\n    }\\r\\n\\r\\n    function getProportion128Unchecked(uint256 mul1, uint256 mul2, uint256 div) internal pure returns (uint128) {\\r\\n        unchecked {\\r\\n            return uint128((mul1 * mul2) / div);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/shared/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\n/// @title Common Spool contracts constants\\r\\nabstract contract BaseConstants {\\r\\n    /// @dev 2 digits precision\\r\\n    uint256 internal constant FULL_PERCENT = 100_00;\\r\\n\\r\\n    /// @dev Accuracy when doing shares arithmetics\\r\\n    uint256 internal constant ACCURACY = 10**30;\\r\\n}\\r\\n\\r\\n/// @title Contains USDC token related values\\r\\nabstract contract USDC {\\r\\n    /// @notice USDC token contract address\\r\\n    IERC20 internal constant USDC_ADDRESS = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\\r\\n}\"\r\n    },\r\n    \"contracts/shared/SpoolOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../interfaces/ISpoolOwner.sol\\\";\\r\\n\\r\\n/// @title Logic to help check whether the caller is the Spool owner\\r\\nabstract contract SpoolOwnable {\\r\\n    /// @notice Contract that checks if address is Spool owner\\r\\n    ISpoolOwner internal immutable spoolOwner;\\r\\n\\r\\n    /**\\r\\n     * @notice Sets correct initial values\\r\\n     * @param _spoolOwner Spool owner contract address\\r\\n     */\\r\\n    constructor(ISpoolOwner _spoolOwner) {\\r\\n        require(\\r\\n            address(_spoolOwner) != address(0),\\r\\n            \\\"SpoolOwnable::constructor: Spool owner contract address cannot be 0\\\"\\r\\n        );\\r\\n\\r\\n        spoolOwner = _spoolOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if caller is Spool owner\\r\\n     * @return True if caller is Spool owner, false otherwise\\r\\n     */\\r\\n    function isSpoolOwner() internal view returns(bool) {\\r\\n        return spoolOwner.isSpoolOwner(msg.sender);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @notice Checks and throws if caller is not Spool owner\\r\\n    function _onlyOwner() private view {\\r\\n        require(isSpoolOwner(), \\\"SpoolOwnable::onlyOwner: Caller is not the Spool owner\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Checks and throws if caller is not Spool owner\\r\\n    modifier onlyOwner() {\\r\\n        _onlyOwner();\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/shared/SpoolPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"../interfaces/IController.sol\\\";\\n\\n/// @title Facilitates checking if the system is paused or not\\nabstract contract SpoolPausable {\\n    /* ========== STATE VARIABLES ========== */\\n\\n    /// @notice The controller contract that is consulted for a strategy's and vault's validity\\n    IController public immutable controller;\\n\\n    /**\\n     * @notice Sets initial values\\n     * @param _controller Controller contract address\\n     */\\n    constructor(IController _controller) {\\n        require(\\n            address(_controller) != address(0),\\n            \\\"SpoolPausable::constructor: Controller contract address cannot be 0\\\"\\n        );\\n\\n        controller = _controller;\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    /// @notice Throws if system is paused\\n    modifier systemNotPaused() {\\n        controller.checkPaused();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault/RewardDrip.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../interfaces/vault/IRewardDrip.sol\\\";\\r\\nimport \\\"./VaultBase.sol\\\";\\r\\n\\r\\nimport \\\"../external/@openzeppelin/utils/SafeCast.sol\\\";\\r\\nimport \\\"../external/@openzeppelin/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"../libraries/Math.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice Implementation of the {IRewardDrip} interface.\\r\\n *\\r\\n * @dev\\r\\n * An adaptation of the Synthetix StakingRewards contract to support multiple tokens:\\r\\n *\\r\\n * https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol\\r\\n *\\r\\n * Instead of storing the values of the StakingRewards contract at the contract level,\\r\\n * they are stored in a struct that is mapped to depending on the reward token instead.\\r\\n */\\r\\nabstract contract RewardDrip is IRewardDrip, ReentrancyGuard, VaultBase {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    /* ========== CONSTANTS ========== */\\r\\n\\r\\n    /// @notice Multiplier used when dealing reward calculations\\r\\n    uint256 constant private REWARD_ACCURACY = 1e18;\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    /// @notice All reward tokens supported by the contract\\r\\n    mapping(uint256 => IERC20) public rewardTokens;\\r\\n\\r\\n    /// @notice Vault reward token incentive configuration\\r\\n    mapping(IERC20 => RewardConfiguration) public rewardConfiguration;\\r\\n\\r\\n    /// @notice Blacklisted force-removed tokens\\r\\n    mapping(IERC20 => bool) public override tokenBlacklist;\\r\\n\\r\\n    /* ========== VIEWS ========== */\\r\\n\\r\\n    function lastTimeRewardApplicable(IERC20 token)\\r\\n        public\\r\\n        view\\r\\n        returns (uint32)\\r\\n    {\\r\\n        return uint32(Math.min(block.timestamp, rewardConfiguration[token].periodFinish));\\r\\n    }\\r\\n\\r\\n    function rewardPerToken(IERC20 token) public view returns (uint224) {\\r\\n        RewardConfiguration storage config = rewardConfiguration[token];\\r\\n\\r\\n        if (totalInstantDeposit == 0)\\r\\n            return config.rewardPerTokenStored;\\r\\n            \\r\\n        uint256 timeDelta = lastTimeRewardApplicable(token) - config.lastUpdateTime;\\r\\n\\r\\n        if (timeDelta == 0)\\r\\n            return config.rewardPerTokenStored;\\r\\n\\r\\n        return\\r\\n            SafeCast.toUint224(\\r\\n                config.rewardPerTokenStored + \\r\\n                    ((timeDelta\\r\\n                        * config.rewardRate)\\r\\n                        / totalInstantDeposit)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function earned(IERC20 token, address account)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        RewardConfiguration storage config = rewardConfiguration[token];\\r\\n\\r\\n        uint256 userShares = users[account].instantDeposit;\\r\\n\\r\\n        if (userShares == 0)\\r\\n            return config.rewards[account];\\r\\n        \\r\\n        uint256 userRewardPerTokenPaid = config.userRewardPerTokenPaid[account];\\r\\n\\r\\n        return\\r\\n            ((userShares * \\r\\n                (rewardPerToken(token) - userRewardPerTokenPaid))\\r\\n                / REWARD_ACCURACY)\\r\\n                + config.rewards[account];\\r\\n    }\\r\\n\\r\\n    function getRewardForDuration(IERC20 token)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        RewardConfiguration storage config = rewardConfiguration[token];\\r\\n        return uint256(config.rewardRate) * config.rewardsDuration;\\r\\n    }\\r\\n\\r\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\r\\n\\r\\n    function getRewards(IERC20[] memory tokens) external nonReentrant {\\r\\n        for (uint256 i; i < tokens.length; i++) {\\r\\n            _getReward(tokens[i], msg.sender);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getActiveRewards(address account) external override onlyController nonReentrant {\\r\\n        uint256 _rewardTokensCount = rewardTokensCount;\\r\\n        for (uint256 i; i < _rewardTokensCount; i++) {\\r\\n            _getReward(rewardTokens[i], account);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getReward(IERC20 token, address account)\\r\\n        internal\\r\\n        updateReward(token, account)\\r\\n    {\\r\\n        RewardConfiguration storage config = rewardConfiguration[token];\\r\\n\\r\\n        require(\\r\\n            config.rewardsDuration != 0,\\r\\n            \\\"BTK\\\"\\r\\n        );\\r\\n\\r\\n        uint256 reward = config.rewards[account];\\r\\n        if (reward > 0) {\\r\\n            config.rewards[account] = 0;\\r\\n            token.safeTransfer(account, reward);\\r\\n            emit RewardPaid(token, account, reward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Allows a new token to be added to the reward system\\r\\n     *\\r\\n     * @dev\\r\\n     * Emits an {TokenAdded} event indicating the newly added reward token\\r\\n     * and configuration\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be the reward distributor\\r\\n     * - the reward duration must be non-zero\\r\\n     * - the token must not have already been added\\r\\n     *\\r\\n     */\\r\\n    function addToken(\\r\\n        IERC20 token,\\r\\n        uint32 rewardsDuration,\\r\\n        uint256 reward\\r\\n    ) external onlyVaultOwnerOrSpoolOwner exceptUnderlying(token) {\\r\\n        RewardConfiguration storage config = rewardConfiguration[token];\\r\\n\\r\\n        require(!tokenBlacklist[token], \\\"TOBL\\\");\\r\\n        require(\\r\\n            rewardsDuration != 0 &&\\r\\n            config.lastUpdateTime == 0,\\r\\n            \\\"BCFG\\\"\\r\\n        );\\r\\n        require(\\r\\n            rewardTokensCount <= 5,\\r\\n            \\\"TMAX\\\"\\r\\n        );\\r\\n\\r\\n        rewardTokens[rewardTokensCount] = token;\\r\\n        rewardTokensCount++;\\r\\n\\r\\n        config.rewardsDuration = rewardsDuration;\\r\\n\\r\\n        if (reward > 0) {\\r\\n            _notifyRewardAmount(token, reward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function notifyRewardAmount(IERC20 token, uint256 reward, uint32 rewardsDuration)\\r\\n    external\\r\\n    onlyVaultOwnerOrSpoolOwner\\r\\n    {\\r\\n        rewardConfiguration[token].rewardsDuration = rewardsDuration;\\r\\n        _notifyRewardAmount(token, reward);\\r\\n    }\\r\\n\\r\\n    function _notifyRewardAmount(IERC20 token, uint256 reward)\\r\\n        private\\r\\n        updateReward(token, address(0))\\r\\n    {\\r\\n        RewardConfiguration storage config = rewardConfiguration[token];\\r\\n\\r\\n        require(\\r\\n            config.rewardPerTokenStored + (reward * REWARD_ACCURACY) <= type(uint192).max,\\r\\n            \\\"RTB\\\"\\r\\n        );\\r\\n\\r\\n        token.safeTransferFrom(msg.sender, address(this), reward);\\r\\n        uint32 newPeriodFinish = uint32(block.timestamp) + config.rewardsDuration;\\r\\n\\r\\n        if (block.timestamp >= config.periodFinish) {\\r\\n            config.rewardRate = SafeCast.toUint192((reward * REWARD_ACCURACY) / config.rewardsDuration);\\r\\n            emit RewardAdded(token, reward, config.rewardsDuration);\\r\\n        } else {\\r\\n            // If extending or adding additional rewards,\\r\\n            // cannot set new finish time to be less than previously configured\\r\\n            require(config.periodFinish <= newPeriodFinish, \\\"PFS\\\");\\r\\n            uint256 remaining = config.periodFinish - block.timestamp;\\r\\n            uint256 leftover = remaining * config.rewardRate;\\r\\n            uint192 newRewardRate = SafeCast.toUint192((reward * REWARD_ACCURACY + leftover) / config.rewardsDuration);\\r\\n        \\r\\n            require(\\r\\n                newRewardRate >= config.rewardRate,\\r\\n                \\\"LRR\\\"\\r\\n            );\\r\\n\\r\\n            config.rewardRate = newRewardRate;\\r\\n            emit RewardExtended(token, reward, leftover, config.rewardsDuration, newPeriodFinish);\\r\\n        }\\r\\n\\r\\n        config.lastUpdateTime = uint32(block.timestamp);\\r\\n        config.periodFinish = newPeriodFinish;\\r\\n    }\\r\\n\\r\\n    // End rewards emission earlier\\r\\n    function updatePeriodFinish(IERC20 token, uint32 timestamp)\\r\\n        external\\r\\n        onlyOwner\\r\\n        updateReward(token, address(0))\\r\\n    {\\r\\n        if (rewardConfiguration[token].lastUpdateTime > timestamp) {\\r\\n            rewardConfiguration[token].periodFinish = rewardConfiguration[token].lastUpdateTime;\\r\\n        } else {\\r\\n            rewardConfiguration[token].periodFinish = timestamp;\\r\\n        }\\r\\n\\r\\n        emit PeriodFinishUpdated(token, rewardConfiguration[token].periodFinish);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Claim reward tokens\\r\\n     * @dev\\r\\n     * This is meant to be an emergency function to claim reward tokens.\\r\\n     * Users that have not claimed yet will not be able to claim as\\r\\n     * the rewards will be removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be Spool DAO\\r\\n     * - cannot claim vault underlying token\\r\\n     * - cannot only execute if the reward finished\\r\\n     *\\r\\n     * @param token Token address to remove\\r\\n     * @param amount Amount of tokens to claim\\r\\n     */\\r\\n    function claimFinishedRewards(IERC20 token, uint256 amount) external onlyOwner exceptUnderlying(token) onlyFinished(token) {\\r\\n        token.safeTransfer(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Force remove reward from vault rewards configuration.\\r\\n     * @dev This is meant to be an emergency function if a reward token breaks.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be Spool DAO\\r\\n     *\\r\\n     * @param token Token address to remove\\r\\n     */\\r\\n    function forceRemoveReward(IERC20 token) external onlyOwner {\\r\\n        tokenBlacklist[token] = true;\\r\\n        _removeReward(token);\\r\\n\\r\\n        delete rewardConfiguration[token];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Remove reward from vault rewards configuration.\\r\\n     * @dev\\r\\n     * Used to sanitize vault and save on gas, after the reward has ended.\\r\\n     * Users will be able to claim rewards \\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be the spool owner or Spool DAO\\r\\n     * - cannot claim vault underlying token\\r\\n     * - cannot only execute if the reward finished\\r\\n     *\\r\\n     * @param token Token address to remove\\r\\n     */\\r\\n    function removeReward(IERC20 token) \\r\\n        external\\r\\n        onlyVaultOwnerOrSpoolOwner\\r\\n        onlyFinished(token)\\r\\n        updateReward(token, address(0))\\r\\n    {\\r\\n        _removeReward(token);\\r\\n    }\\r\\n\\r\\n    /* ========== PRIVATE FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Syncs rewards across all tokens of the system\\r\\n     *\\r\\n     * This function is meant to be invoked every time the instant deposit\\r\\n     * of a user changes.\\r\\n     */\\r\\n    function _updateRewards(address account) private {\\r\\n        uint256 _rewardTokensCount = rewardTokensCount;\\r\\n        \\r\\n        for (uint256 i; i < _rewardTokensCount; i++)\\r\\n            _updateReward(rewardTokens[i], account);\\r\\n    }\\r\\n\\r\\n    function _updateReward(IERC20 token, address account) private {\\r\\n        RewardConfiguration storage config = rewardConfiguration[token];\\r\\n        config.rewardPerTokenStored = rewardPerToken(token);\\r\\n        config.lastUpdateTime = lastTimeRewardApplicable(token);\\r\\n        if (account != address(0)) {\\r\\n            config.rewards[account] = earned(token, account);\\r\\n            config.userRewardPerTokenPaid[account] = config\\r\\n                .rewardPerTokenStored;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _removeReward(IERC20 token) private {\\r\\n        uint256 _rewardTokensCount = rewardTokensCount;\\r\\n        for (uint256 i; i < _rewardTokensCount; i++) {\\r\\n            if (rewardTokens[i] == token) {\\r\\n                rewardTokens[i] = rewardTokens[_rewardTokensCount - 1];\\r\\n\\r\\n                delete rewardTokens[_rewardTokensCount - 1];\\r\\n                rewardTokensCount--;\\r\\n                emit RewardRemoved(token);\\r\\n\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _exceptUnderlying(IERC20 token) private view {\\r\\n        require(\\r\\n            token != _underlying(),\\r\\n            \\\"NUT\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _onlyFinished(IERC20 token) private view {\\r\\n        require(\\r\\n            block.timestamp > rewardConfiguration[token].periodFinish,\\r\\n            \\\"RNF\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice Ensures that the caller is the controller\\r\\n     */\\r\\n    function _onlyController() private view {\\r\\n        require(\\r\\n            msg.sender == address(controller),\\r\\n            \\\"OCTRL\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n\\r\\n    modifier updateReward(IERC20 token, address account) {\\r\\n        _updateReward(token, account);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier updateRewards() {\\r\\n        _updateRewards(msg.sender);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier exceptUnderlying(IERC20 token) {\\r\\n        _exceptUnderlying(token);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyFinished(IERC20 token) {\\r\\n        _onlyFinished(token);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Throws if called by anyone else other than the controller\\r\\n     */\\r\\n    modifier onlyController() {\\r\\n        _onlyController();\\r\\n        _;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/vault/VaultBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\n// libraries\\r\\nimport \\\"../external/@openzeppelin/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport \\\"../external/@openzeppelin/utils/SafeCast.sol\\\";\\r\\nimport \\\"../libraries/Bitwise.sol\\\";\\r\\nimport \\\"../libraries/Hash.sol\\\";\\r\\n\\r\\n// extends\\r\\nimport \\\"../interfaces/vault/IVaultBase.sol\\\";\\r\\nimport \\\"./VaultImmutable.sol\\\";\\r\\nimport \\\"../shared/SpoolOwnable.sol\\\";\\r\\nimport \\\"../shared/Constants.sol\\\";\\r\\n\\r\\n// other imports\\r\\nimport \\\"../interfaces/vault/IVaultDetails.sol\\\";\\r\\nimport \\\"../interfaces/ISpool.sol\\\";\\r\\nimport \\\"../interfaces/IController.sol\\\";\\r\\nimport \\\"../interfaces/IFastWithdraw.sol\\\";\\r\\nimport \\\"../interfaces/IFeeHandler.sol\\\";\\r\\nimport \\\"../shared/SpoolPausable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice Implementation of the {IVaultBase} interface.\\r\\n *\\r\\n * @dev\\r\\n * Vault base holds vault state variables and provides some of the common vault functions.\\r\\n */\\r\\nabstract contract VaultBase is IVaultBase, VaultImmutable, SpoolOwnable, SpoolPausable, BaseConstants {\\r\\n    using Bitwise for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    /// @notice The central Spool contract\\r\\n    ISpool internal immutable spool;\\r\\n\\r\\n    /// @notice The fast withdraw contract\\r\\n    IFastWithdraw internal immutable fastWithdraw;\\r\\n\\r\\n    /// @notice The fee handler contract\\r\\n    IFeeHandler internal immutable feeHandler;\\r\\n\\r\\n    /// @notice Boolean signaling if the contract was initialized yet\\r\\n    bool private _initialized;\\r\\n\\r\\n    /// @notice The owner of the vault, also the vault fee recipient\\r\\n    address public vaultOwner;\\r\\n\\r\\n    /// @notice Vault owner fee\\r\\n    uint16 public vaultFee;\\r\\n\\r\\n    /// @notice The name of the vault\\r\\n    string public name;\\r\\n\\r\\n    /// @notice The total shares of a vault\\r\\n    uint128 public totalShares;\\r\\n\\r\\n    /// @notice Total instant deposit, used to calculate vault reward incentives\\r\\n    uint128 public totalInstantDeposit;\\r\\n\\r\\n    /// @notice The proportions of each strategy when depositing\\r\\n    /// @dev Proportions are 14bits each, and the add up to FULL_PERCENT (10.000)\\r\\n    uint256 public proportions;\\r\\n\\r\\n    /// @notice Proportions to deposit after reallocation withdraw amount is claimed\\r\\n    uint256 internal depositProportions;\\r\\n    \\r\\n    /// @notice Hash of the strategies list\\r\\n    bytes32 public strategiesHash;\\r\\n\\r\\n    /// @notice Number of vault incentivized tokens\\r\\n    uint8 public rewardTokensCount;\\r\\n    \\r\\n    /// @notice Data if vault and at what index vault is reallocating\\r\\n    uint24 public reallocationIndex;\\r\\n\\r\\n    /// @notice User vault state values\\r\\n    mapping(address => User) public users;\\r\\n\\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the initial immutable values of the contract common for all vaults.\\r\\n     *\\r\\n     * @dev\\r\\n     * All values have been sanitized by the controller contract, meaning\\r\\n     * that no additional checks need to be applied here.\\r\\n     *\\r\\n     * @param _spool the spool implemenation\\r\\n     * @param _controller the controller implementation\\r\\n     * @param _fastWithdraw fast withdraw implementation\\r\\n     * @param _feeHandler fee handler implementation\\r\\n     */\\r\\n    constructor(\\r\\n        ISpool _spool,\\r\\n        IController _controller,\\r\\n        IFastWithdraw _fastWithdraw,\\r\\n        IFeeHandler _feeHandler\\r\\n    )\\r\\n    SpoolPausable(_controller)\\r\\n    {\\r\\n        require(address(_spool) != address(0), \\\"VaultBase::constructor: Spool address cannot be 0\\\");\\r\\n        require(address(_fastWithdraw) != address(0), \\\"VaultBase::constructor: FastWithdraw address cannot be 0\\\");\\r\\n        require(address(_feeHandler) != address(0), \\\"VaultBase::constructor: Fee Handler address cannot be 0\\\");\\r\\n\\r\\n        spool = _spool;\\r\\n        fastWithdraw = _fastWithdraw;\\r\\n        feeHandler = _feeHandler;\\r\\n    }\\r\\n\\r\\n    /* ========== INITIALIZE ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes state of the vault at proxy creation.\\r\\n     * @dev Called only once by vault factory after deploying a vault proxy.\\r\\n     *      All values have been sanitized by the controller contract, meaning\\r\\n     *      that no additional checks need to be applied here.\\r\\n     *\\r\\n     * @param vaultInitializable initial vault specific variables\\r\\n     */\\r\\n    function initialize(\\r\\n        VaultInitializable memory vaultInitializable\\r\\n    ) external override initializer {\\r\\n        vaultOwner = vaultInitializable.owner;\\r\\n        vaultFee = vaultInitializable.fee;\\r\\n        name = vaultInitializable.name;\\r\\n\\r\\n        proportions = _mapProportionsArrayToBits(vaultInitializable.proportions);\\r\\n        _updateStrategiesHash(vaultInitializable.strategies);\\r\\n    }\\r\\n\\r\\n    /* ========== VIEW FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate and return proportion of passed parameters of 128 bit size\\r\\n     * @dev Calculates the value using in 256 bit space, later casts back to 128 bit\\r\\n     * Requirements:\\r\\n     * \\r\\n     * - the result can't be bigger than maximum 128 bits value\\r\\n     *\\r\\n     * @param mul1 first multiplication value\\r\\n     * @param mul2 second multiplication value\\r\\n     * @param div result division value\\r\\n     *\\r\\n     * @return 128 bit proportion result\\r\\n     */\\r\\n    function _getProportion128(uint128 mul1, uint128 mul2, uint128 div) internal pure returns (uint128) {\\r\\n        return SafeCast.toUint128((uint256(mul1) * mul2) / div);\\r\\n    }\\r\\n\\r\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer vault owner to another address.\\r\\n     *\\r\\n     * @param _vaultOwner new vault owner address\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller can only be the vault owner or Spool DAO\\r\\n     */\\r\\n    function transferVaultOwner(address _vaultOwner) external onlyVaultOwnerOrSpoolOwner {\\r\\n        vaultOwner = _vaultOwner;\\r\\n        emit TransferVaultOwner(_vaultOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set lower vault fee.\\r\\n     *\\r\\n     * @param _vaultFee new vault fee\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller can only be the vault owner\\r\\n     * - new vault fee must be lower than before\\r\\n     */\\r\\n    function lowerVaultFee(uint16 _vaultFee) external {\\r\\n        require(\\r\\n            msg.sender == vaultOwner &&\\r\\n            _vaultFee < vaultFee,\\r\\n            \\\"FEE\\\"\\r\\n        );\\r\\n\\r\\n        vaultFee = _vaultFee;\\r\\n        emit LowerVaultFee(_vaultFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Update the name of the vault.\\r\\n     *\\r\\n     * @param _name new vault name\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller can only be the Spool DAO\\r\\n     */\\r\\n    function updateName(string memory _name) external onlyOwner {\\r\\n        name = _name;\\r\\n        emit UpdateName(_name);\\r\\n    }\\r\\n\\r\\n    // =========== DEPOSIT HELPERS ============ //\\r\\n\\r\\n    /**\\r\\n     * @notice Update instant deposit user and vault amounts\\r\\n     *\\r\\n     * @param amount deposited amount\\r\\n     */\\r\\n    function _addInstantDeposit(uint128 amount) internal {\\r\\n        users[msg.sender].instantDeposit += amount;\\r\\n        totalInstantDeposit += amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get strategy deposit amount for the strategy\\r\\n     * @param _proportions Vault strategy proportions (14bit each)\\r\\n     * @param i index to get the proportion\\r\\n     * @param amount Total deposit amount\\r\\n     * @return strategyDepositAmount \\r\\n     */\\r\\n    function _getStrategyDepositAmount(\\r\\n        uint256 _proportions,\\r\\n        uint256 i,\\r\\n        uint256 amount\\r\\n    ) internal pure returns (uint128) {\\r\\n        return SafeCast.toUint128((_proportions.get14BitUintByIndex(i) * amount) / FULL_PERCENT);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfers deposited underlying asset amount from user to spool contract.\\r\\n     * @dev Transfer happens from the vault or controller, defined by the user\\r\\n     *\\r\\n     * @param amount deposited amount\\r\\n     * @param fromVault flag indicating wether the transfer is intiafed from the vault or controller\\r\\n     */\\r\\n    function _transferDepositToSpool(uint128 amount, bool fromVault) internal {\\r\\n        if (fromVault) {\\r\\n            _underlying().safeTransferFrom(msg.sender, address(spool), amount);\\r\\n        } else {\\r\\n            controller.transferToSpool(msg.sender, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* ========== WITHDRAW HELPERS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates proportions of shares relative to the total shares\\r\\n     * @dev Value has accuracy of `ACCURACY` which is 10^30\\r\\n     *\\r\\n     * @param sharesToWithdraw amount of shares\\r\\n     *\\r\\n     * @return total vault shares proportion\\r\\n     */\\r\\n    function _getVaultShareProportion(uint128 sharesToWithdraw) internal view returns(uint256) {\\r\\n        return (ACCURACY * sharesToWithdraw) / totalShares;\\r\\n    }\\r\\n\\r\\n    // =========== PERFORMANCE FEES ============ //\\r\\n\\r\\n    /**\\r\\n     * @notice Pay fees to fee handler contract and transfer fee amount.\\r\\n     * \\r\\n     * @param profit Total profit made by the users\\r\\n     * @return feeSize Fee amount calculated from profit\\r\\n     */\\r\\n    function _payFeesAndTransfer(uint256 profit) internal returns (uint128 feeSize) {\\r\\n        feeSize = SafeCast.toUint128(_payFees(profit));\\r\\n\\r\\n        _underlying().safeTransfer(address(feeHandler), feeSize);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice  Call fee handler contract to pay fees, without transfering assets\\r\\n     * @dev Fee handler updates the fee storage slots and returns \\r\\n     *\\r\\n     * @param profit Total profit made by the users\\r\\n     * @return Fee amount calculated from profit\\r\\n     */\\r\\n    function _payFees(uint256 profit) internal returns (uint256) {\\r\\n        return feeHandler.payFees(\\r\\n            _underlying(),\\r\\n            profit,\\r\\n            _riskProvider(),\\r\\n            vaultOwner,\\r\\n            vaultFee\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // =========== STRATEGIIES ============ //\\r\\n\\r\\n    /**\\r\\n     * @notice Map vault strategy proportions array in one uint256 word.\\r\\n     *\\r\\n     * @dev Proportions sum up to `FULL_PERCENT` (10_000).\\r\\n     *      There is maximum of 18 elements, and each takes maximum of 14bits.\\r\\n     *\\r\\n     * @param _proportions Vault strategy proportions array\\r\\n     * @return Mapped propportion 256 bit word format\\r\\n     */\\r\\n    function _mapProportionsArrayToBits(uint256[] memory _proportions) internal pure returns (uint256) {\\r\\n        uint256 proportions14bit;\\r\\n        for (uint256 i = 0; i < _proportions.length; i++) {\\r\\n            proportions14bit = proportions14bit.set14BitUintByIndex(i, _proportions[i]);\\r\\n        }\\r\\n\\r\\n        return proportions14bit;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Store vault strategy addresses array hash in `strategiesHash` storage\\r\\n     * @param vaultStrategies Array of strategy addresses\\r\\n     */\\r\\n    function _updateStrategiesHash(address[] memory vaultStrategies) internal {\\r\\n        strategiesHash = Hash.hashStrategies(vaultStrategies);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev verify vault strategy addresses array against storage `strategiesHash`\\r\\n     * @param vaultStrategies Array of strategies to verify\\r\\n     */\\r\\n    function _verifyStrategies(address[] memory vaultStrategies) internal view {\\r\\n        require(Hash.sameStrategies(vaultStrategies, strategiesHash), \\\"VSH\\\");\\r\\n    }\\r\\n\\r\\n    /* ========== PRIVATE FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Verify the caller is The vault owner or Spool DAO\\r\\n     *\\r\\n     * @dev\\r\\n     * Only callable from onlyVaultOwnerOrSpoolOwner modifier.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - msg.sender is the vault owner or Spool DAO\\r\\n     */\\r\\n    function _onlyVaultOwnerOrSpoolOwner() private view {\\r\\n        require(\\r\\n            msg.sender == vaultOwner || isSpoolOwner(),\\r\\n            \\\"OOD\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Verify the caller is the spool contact\\r\\n     *\\r\\n     * @dev\\r\\n     * Only callable from onlySpool modifier.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - msg.sender is central spool contract\\r\\n     */\\r\\n    function _onlySpool() private view {\\r\\n        require(address(spool) == msg.sender, \\\"OSP\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Verify caller is the spool contact\\r\\n     *\\r\\n     * @dev\\r\\n     * Only callable from onlyFastWithdraw modifier.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - caller is fast withdraw contract\\r\\n     */\\r\\n    function _onlyFastWithdraw() private view {\\r\\n        require(address(fastWithdraw) == msg.sender, \\\"OFW\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Dissallow action if Spool reallocation already started\\r\\n     */\\r\\n    function _noMidReallocation() private view {\\r\\n        require(!spool.isMidReallocation(), \\\"NMR\\\");\\r\\n    }\\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Ensures caller is vault owner or spool owner.\\r\\n     */\\r\\n    modifier onlyVaultOwnerOrSpoolOwner() {\\r\\n        _onlyVaultOwnerOrSpoolOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Ensures caller is central spool contract\\r\\n     */\\r\\n    modifier onlySpool() {\\r\\n        _onlySpool();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Ensures caller is fast withdraw contract\\r\\n     */\\r\\n    modifier onlyFastWithdraw() {\\r\\n        _onlyFastWithdraw();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Verifies given array of strategy addresses\\r\\n     */\\r\\n    modifier verifyStrategies(address[] memory vaultStrategies) {\\r\\n        _verifyStrategies(vaultStrategies);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Ensures the system is not mid reallocation\\r\\n     */\\r\\n    modifier noMidReallocation() {\\r\\n        _noMidReallocation();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Ensures the vault has not been initialized before\\r\\n     */\\r\\n    modifier initializer() {\\r\\n        require(!_initialized, \\\"AINT\\\");\\r\\n        _;\\r\\n        _initialized = true;\\r\\n    }\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/vault/VaultImmutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../interfaces/vault/IVaultImmutable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice This contracts calls vault proxy that stores following\\r\\n *      properties as immutables. \\r\\n */\\r\\nabstract contract VaultImmutable {\\r\\n    /* ========== FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the underlying vault token from proxy address\\r\\n     * @return Underlying token contract\\r\\n     */\\r\\n    function _underlying() internal view returns (IERC20) {\\r\\n        return IVaultImmutable(address(this)).underlying();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns vaults risk provider from proxy address\\r\\n     * @return Risk provider contract\\r\\n     */\\r\\n    function _riskProvider() internal view returns (address) {\\r\\n        return IVaultImmutable(address(this)).riskProvider();\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/vault/VaultIndexActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../interfaces/vault/IVaultIndexActions.sol\\\";\\r\\nimport \\\"./RewardDrip.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice VaultIndexActions extends VaultBase and holds the logic to process index related data and actions.\\r\\n *\\r\\n * @dev\\r\\n * Index functions are executed when state changes are performed, to synchronize to vault with central Spool contract.\\r\\n * \\r\\n * Index actions include:\\r\\n * - Redeem vault: claiming vault shares and withdrawn amount when DHW is complete\\r\\n * - Redeem user: claiming user deposit shares and/or withdrawn amount after vault claim has been processed\\r\\n */\\r\\nabstract contract VaultIndexActions is IVaultIndexActions, RewardDrip {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using Bitwise for uint256;\\r\\n\\r\\n    /* ========== CONSTANTS ========== */\\r\\n\\r\\n    /// @notice minimum shares size to avoid loss of share due to computation precision\\r\\n    uint128 private constant MIN_SHARES = 10**8;\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    /// @notice Holds up to 2 global indexes vault last interacted at and havent been redeemed yet\\r\\n    /// @dev Second index can only be the next index of the first one\\r\\n    /// Second index is used if the do-hard-work is executed in 2 transactions and actions are executed in between\\r\\n    LastIndexInteracted public lastIndexInteracted;\\r\\n\\r\\n    /// @notice Maps all vault actions to the corresponding global index\\r\\n    mapping(uint256 => IndexAction) public vaultIndexAction;\\r\\n    \\r\\n    /// @notice Maps user actions to the corresponding global index\\r\\n    mapping(address => mapping(uint256 => IndexAction)) public userIndexAction;\\r\\n\\r\\n    /// @notice Holds up to 2 global indexes users last interacted with, and havent been redeemed yet\\r\\n    mapping(address => LastIndexInteracted) public userLastInteractions;\\r\\n\\r\\n    /// @notice Global index to deposit and withdraw vault redeem\\r\\n    mapping(uint256 => Redeem) public redeems;\\r\\n\\r\\n    // =========== VIEW FUNCTIONS ============ //\\r\\n\\r\\n    /**\\r\\n     * @notice Checks and sets the \\\"is reallocating\\\" flag for given index\\r\\n     * @param index Index to check\\r\\n     * @return isReallocating True if vault is reallocating at this `index`\\r\\n     */\\r\\n    function _isVaultReallocatingAtIndex(uint256 index) internal view returns (bool isReallocating) {\\r\\n        if (index == reallocationIndex) {\\r\\n            isReallocating = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Check if the vault is set to reallocate\\r\\n     * @dev True if in the current index or the next one\\r\\n     * @return isReallocating True if vault is set to reallocate\\r\\n     */\\r\\n    function _isVaultReallocating() internal view returns (bool isReallocating) {\\r\\n        if (reallocationIndex > 0) {\\r\\n            isReallocating = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // =========== VAULT REDEEM ============ //\\r\\n\\r\\n    /**\\r\\n     * @notice Redeem vault strategies after do hard work (DHW) has been completed\\r\\n     * \\r\\n     * @dev\\r\\n     * This is only possible if all vault strategy DHWs have been executed, otherwise it's reverted.\\r\\n     * If the system is paused, function will revert - impacts vault functions deposit, withdraw, fastWithdraw,\\r\\n     * claim, reallocate.\\r\\n     * @param vaultStrategies strategies of this vault (verified internally)\\r\\n     */\\r\\n    function _redeemVaultStrategies(address[] memory vaultStrategies) internal systemNotPaused {\\r\\n        LastIndexInteracted memory _lastIndexInteracted = lastIndexInteracted;\\r\\n        if (_lastIndexInteracted.index1 > 0) {\\r\\n            uint256 globalIndex1 = _lastIndexInteracted.index1;\\r\\n            uint256 completedGlobalIndex = spool.getCompletedGlobalIndex();\\r\\n            if (globalIndex1 <= completedGlobalIndex) {\\r\\n                // redeem interacted index 1\\r\\n                _redeemStrategiesIndex(globalIndex1, vaultStrategies);\\r\\n                _lastIndexInteracted.index1 = 0;\\r\\n\\r\\n                if (_lastIndexInteracted.index2 > 0) {\\r\\n                    uint256 globalIndex2 = _lastIndexInteracted.index2;\\r\\n                    if (globalIndex2 <= completedGlobalIndex) {\\r\\n                        // redeem interacted index 2\\r\\n                        _redeemStrategiesIndex(globalIndex2, vaultStrategies);\\r\\n                    } else {\\r\\n                        _lastIndexInteracted.index1 = _lastIndexInteracted.index2;\\r\\n                    }\\r\\n                    \\r\\n                    _lastIndexInteracted.index2 = 0;\\r\\n                }\\r\\n\\r\\n                lastIndexInteracted = _lastIndexInteracted;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Redeem strategies for at index\\r\\n     * @dev Causes additional gas for first interaction after DHW index has been completed\\r\\n     * @param globalIndex Global index\\r\\n     * @param vaultStrategies Array of vault strategy addresses\\r\\n     */\\r\\n    function _redeemStrategiesIndex(uint256 globalIndex, address[] memory vaultStrategies) private {\\r\\n        uint128 _totalShares = totalShares;\\r\\n        uint128 totalReceived = 0;\\r\\n        uint128 totalWithdrawn = 0;\\r\\n        uint128 totalUnderlyingAtIndex = 0;\\r\\n        \\r\\n        // if vault was reallocating at index claim reallocation deposit\\r\\n        bool isReallocating = _isVaultReallocatingAtIndex(globalIndex);\\r\\n        if (isReallocating) {\\r\\n            spool.redeemReallocation(vaultStrategies, depositProportions, globalIndex);\\r\\n            // Reset reallocation index to 0\\r\\n            reallocationIndex = 0;\\r\\n        }\\r\\n\\r\\n        // go over strategies and redeem deposited shares and withdrawn amount\\r\\n        for (uint256 i = 0; i < vaultStrategies.length; i++) {\\r\\n            address strat = vaultStrategies[i];\\r\\n            (uint128 receivedTokens, uint128 withdrawnTokens) = spool.redeem(strat, globalIndex);\\r\\n            totalReceived += receivedTokens;\\r\\n            totalWithdrawn += withdrawnTokens;\\r\\n            \\r\\n            totalUnderlyingAtIndex += spool.getVaultTotalUnderlyingAtIndex(strat, globalIndex);\\r\\n        }\\r\\n\\r\\n        // redeem underlying withdrawn token for all strategies at once\\r\\n        if (totalWithdrawn > 0) {\\r\\n            spool.redeemUnderlying(totalWithdrawn);\\r\\n        }\\r\\n\\r\\n        // substract withdrawn shares\\r\\n        _totalShares -= vaultIndexAction[globalIndex].withdrawShares;\\r\\n\\r\\n        // calculate new deposit shares\\r\\n        uint128 newShares = 0;\\r\\n        if (_totalShares == 0 || totalUnderlyingAtIndex == 0) {\\r\\n            // Enforce minimum shares size to avoid loss of share due to computation precision\\r\\n            newShares = (0 < totalReceived && totalReceived < MIN_SHARES) ? MIN_SHARES : totalReceived;\\r\\n        } else {\\r\\n            newShares = _getProportion128(totalReceived, _totalShares, totalUnderlyingAtIndex);\\r\\n        }\\r\\n\\r\\n        // add new deposit shares\\r\\n        totalShares = _totalShares + newShares;\\r\\n\\r\\n        redeems[globalIndex] = Redeem(newShares, totalWithdrawn);\\r\\n\\r\\n        emit VaultRedeem(globalIndex);\\r\\n    }\\r\\n\\r\\n    // =========== USER REDEEM ============ //\\r\\n\\r\\n    /**\\r\\n     * @notice Redeem user deposit shares and withdrawn amount\\r\\n     *\\r\\n     * @dev\\r\\n     * Check if vault has already claimed shares for itself\\r\\n     */\\r\\n    function _redeemUser() internal {\\r\\n        LastIndexInteracted memory _lastIndexInteracted = lastIndexInteracted;\\r\\n        LastIndexInteracted memory userIndexInteracted = userLastInteractions[msg.sender];\\r\\n\\r\\n        // check if strategy for index has already been redeemed\\r\\n        if (userIndexInteracted.index1 > 0 && \\r\\n            (_lastIndexInteracted.index1 == 0 || userIndexInteracted.index1 < _lastIndexInteracted.index1)) {\\r\\n            // redeem interacted index 1\\r\\n            _redeemUserAction(userIndexInteracted.index1, true);\\r\\n            userIndexInteracted.index1 = 0;\\r\\n\\r\\n            if (userIndexInteracted.index2 > 0) {\\r\\n                if (_lastIndexInteracted.index2 == 0 || userIndexInteracted.index2 < _lastIndexInteracted.index1) {\\r\\n                    // redeem interacted index 2\\r\\n                    _redeemUserAction(userIndexInteracted.index2, false);\\r\\n                } else {\\r\\n                    userIndexInteracted.index1 = userIndexInteracted.index2;\\r\\n                }\\r\\n                \\r\\n                userIndexInteracted.index2 = 0;\\r\\n            }\\r\\n\\r\\n            userLastInteractions[msg.sender] = userIndexInteracted;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Redeem user action for the `index`\\r\\n     * @param index index aw which user performed the action\\r\\n     * @param isFirstIndex Is this the first user index\\r\\n     */\\r\\n    function _redeemUserAction(uint256 index, bool isFirstIndex) private {\\r\\n        User storage user = users[msg.sender];\\r\\n        IndexAction storage userIndex = userIndexAction[msg.sender][index];\\r\\n\\r\\n        // redeem user withdrawn amount at index\\r\\n        uint128 userWithdrawalShares = userIndex.withdrawShares;\\r\\n        if (userWithdrawalShares > 0) {\\r\\n            // calculate user withdrawn amount\\r\\n\\r\\n            uint128 userWithdrawnAmount = _getProportion128(redeems[index].withdrawnAmount, userWithdrawalShares, vaultIndexAction[index].withdrawShares);\\r\\n\\r\\n            user.owed += userWithdrawnAmount;\\r\\n\\r\\n            // calculate proportionate deposit to pay for performance fees on claim\\r\\n            uint128 proportionateDeposit;\\r\\n            uint128 sharesAtWithdrawal = user.shares + userWithdrawalShares;\\r\\n            if (isFirstIndex) {\\r\\n                // if user has 2 withdraws pending sum shares from the pending one as well\\r\\n                sharesAtWithdrawal += userIndexAction[msg.sender][index + 1].withdrawShares;\\r\\n            }\\r\\n\\r\\n            // check if withdrawal of all user shares was performes (all shares at the index of the action)\\r\\n            if (sharesAtWithdrawal > userWithdrawalShares) {\\r\\n                uint128 userTotalDeposit = user.activeDeposit;\\r\\n                \\r\\n                proportionateDeposit = _getProportion128(userTotalDeposit, userWithdrawalShares, sharesAtWithdrawal);\\r\\n                user.activeDeposit = userTotalDeposit - proportionateDeposit;\\r\\n            } else {\\r\\n                proportionateDeposit = user.activeDeposit;\\r\\n                user.activeDeposit = 0;\\r\\n            }\\r\\n\\r\\n            user.withdrawnDeposits += proportionateDeposit;\\r\\n\\r\\n            // set user withdraw shares for index to 0\\r\\n            userIndex.withdrawShares = 0;\\r\\n        }\\r\\n\\r\\n        // redeem user deposit shares at index\\r\\n        uint128 userDepositAmount = userIndex.depositAmount;\\r\\n        if (userDepositAmount > 0) {\\r\\n            // calculate new user deposit shares\\r\\n            uint128 newUserShares = _getProportion128(userDepositAmount, redeems[index].depositShares, vaultIndexAction[index].depositAmount);\\r\\n\\r\\n            user.shares += newUserShares;\\r\\n            user.activeDeposit += userDepositAmount;\\r\\n\\r\\n            // set user deposit amount for index to 0\\r\\n            userIndex.depositAmount = 0;\\r\\n        }\\r\\n        \\r\\n        emit UserRedeem(msg.sender, index);\\r\\n    }\\r\\n\\r\\n    // =========== INDEX FUNCTIONS ============ //\\r\\n\\r\\n    /**\\r\\n     * @dev Saves vault last interacted global index\\r\\n     * @param globalIndex Global index\\r\\n     */\\r\\n    function _updateInteractedIndex(uint24 globalIndex) internal {\\r\\n        _updateLastIndexInteracted(lastIndexInteracted, globalIndex);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Saves last user interacted global index\\r\\n     * @param globalIndex Global index\\r\\n     */\\r\\n    function _updateUserInteractedIndex(uint24 globalIndex) internal {\\r\\n        _updateLastIndexInteracted(userLastInteractions[msg.sender], globalIndex);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Update last index with which the system interacted\\r\\n     * @param lit Last interacted idex of a user or a vault\\r\\n     * @param globalIndex Global index\\r\\n     */\\r\\n    function _updateLastIndexInteracted(LastIndexInteracted storage lit, uint24 globalIndex) private {\\r\\n        if (lit.index1 > 0) {\\r\\n            if (lit.index1 < globalIndex) {\\r\\n                lit.index2 = globalIndex;\\r\\n            }\\r\\n        } else {\\r\\n            lit.index1 = globalIndex;\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets current active global index from spool\\r\\n     */\\r\\n    function _getActiveGlobalIndex() internal view returns(uint24) {\\r\\n        return spool.getActiveGlobalIndex();\\r\\n    }\\r\\n\\r\\n    /* ========== PRIVATE FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @dev Ensures the vault is not currently reallocating\\r\\n     */\\r\\n    function _noReallocation() private view {\\r\\n        require(!_isVaultReallocating(), \\\"NRED\\\");\\r\\n    }\\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n\\r\\n    /**\\r\\n    * @dev Redeem given array of vault strategies\\r\\n     */\\r\\n    modifier redeemVaultStrategiesModifier(address[] memory vaultStrategies) {\\r\\n        _redeemVaultStrategies(vaultStrategies);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Redeem user\\r\\n     */\\r\\n    modifier redeemUserModifier() {\\r\\n        _redeemUser();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Ensures the vault is not currently reallocating\\r\\n     */\\r\\n    modifier noReallocation() {\\r\\n        _noReallocation();\\r\\n        _;\\r\\n    }  \\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/vault/VaultRestricted.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../interfaces/vault/IVaultRestricted.sol\\\";\\r\\nimport \\\"./VaultIndexActions.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice Implementation of the {IVaultRestricted} interface.\\r\\n *\\r\\n * @dev\\r\\n * VaultRestricted extends VaultIndexActions and exposes functions restricted for Spool specific contracts.\\r\\n * \\r\\n * Index functions are executed when state changes are performed, to synchronize to vault with central Spool contract\\r\\n * \\r\\n * Functions:\\r\\n * - payFees, called by fast withdraw, when user decides to fast withdraw its shares\\r\\n * - reallocate, called by spool, sets new strategy allocation values and calculates what\\r\\n *   strategies to withdraw from and deposit to, to achieve the desired allocation\\r\\n */\\r\\nabstract contract VaultRestricted is IVaultRestricted, VaultIndexActions {\\r\\n    using Bitwise for uint256;\\r\\n\\r\\n    // =========== FAST WITHDRAW FEES ============ //\\r\\n\\r\\n    /**\\r\\n     * @notice  Notifies fee handler of user realized profits to calculate and store the fee.\\r\\n     * @dev\\r\\n     * Called by fast withdraw contract.\\r\\n     * Fee handler updates the fee storage slots and returns calculated fee value\\r\\n     * Fast withdraw transfers the calculated fee to the fee handler after.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Caller must be the fast withdraw contract\\r\\n     *\\r\\n     * @param profit Total profit made by the user\\r\\n     * @return Fee amount calculated from the profit\\r\\n     */\\r\\n    function payFees(uint256 profit) external override onlyFastWithdraw returns (uint256) {\\r\\n        return _payFees(profit);\\r\\n    }\\r\\n\\r\\n    /* ========== SPOOL REALLOCATE ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Update vault strategy proportions and reallocate funds according to the new proportions.\\r\\n     *\\r\\n     * @dev \\r\\n     * Requirements:\\r\\n     * \\r\\n     * - the caller must be the Spool contract\\r\\n     * - reallocation must not be in progress\\r\\n     * - new vault proportions must add up to `FULL_PERCENT`\\r\\n     *\\r\\n     * @param vaultStrategies Vault strategy addresses\\r\\n     * @param newVaultProportions New vault proportions\\r\\n     * @param finishedIndex Completed global index\\r\\n     * @param activeIndex current active global index, that we're setting reallocate for\\r\\n     *\\r\\n     * @return withdrawProportionsArray array of shares to be withdrawn from each vault strategy, and be later deposited back to other vault strategies\\r\\n     * @return newDepositProportions proportions to be deposited to strategies from all withdrawn funds (written in a uint word, 14bits each) values add up to `FULL_PERCENT`\\r\\n     *\\r\\n     */\\r\\n    function reallocate(\\r\\n        address[] memory vaultStrategies,\\r\\n        uint256 newVaultProportions,\\r\\n        uint256 finishedIndex,\\r\\n        uint24 activeIndex\\r\\n    ) \\r\\n        external \\r\\n        override\\r\\n        onlySpool\\r\\n        verifyStrategies(vaultStrategies)\\r\\n        redeemVaultStrategiesModifier(vaultStrategies)\\r\\n        noReallocation\\r\\n        returns(uint256[] memory withdrawProportionsArray, uint256 newDepositProportions)\\r\\n    {\\r\\n        (withdrawProportionsArray, newDepositProportions) = _adjustAllocation(vaultStrategies, newVaultProportions, finishedIndex);\\r\\n\\r\\n        proportions = newVaultProportions;\\r\\n\\r\\n        reallocationIndex = activeIndex;\\r\\n        _updateInteractedIndex(activeIndex);\\r\\n        emit Reallocate(reallocationIndex, newVaultProportions);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set new vault strategy allocation and calculate how the funds should be spread\\r\\n     * \\r\\n     * @dev\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - new proportions must add up to 100% (`FULL_PERCENT`)\\r\\n     * - vault must withdraw from at least one strategy\\r\\n     * - vault must deposit to at least one strategy\\r\\n     * - vault total underlying must be more than zero\\r\\n     *\\r\\n     * @param vaultStrategies Vault strategy addresses\\r\\n     * @param newVaultProportions New vault proportions\\r\\n     * @param finishedIndex Completed global index\\r\\n     *\\r\\n     * @return withdrawProportionsArray array of shares to be withdrawn from each vault strategy, and be later deposited back to other vault strategies\\r\\n     * @return newDepositProportions proportions to be deposited to strategies from all withdrawn funds (written in a uint word, 14bits each) values add up to `FULL_PERCENT`\\r\\n     */\\r\\n    function _adjustAllocation(\\r\\n        address[] memory vaultStrategies,\\r\\n        uint256 newVaultProportions,\\r\\n        uint256 finishedIndex\\r\\n    )\\r\\n        private returns(uint256[] memory, uint256)\\r\\n    {\\r\\n        uint256[] memory depositProportionsArray = new uint256[](vaultStrategies.length);\\r\\n        uint256[] memory withdrawProportionsArray = new uint256[](vaultStrategies.length);\\r\\n\\r\\n        (uint256[] memory stratUnderlyings, uint256 vaultTotalUnderlying) = _getStratsAndVaultUnderlying(vaultStrategies, finishedIndex);\\r\\n\\r\\n        require(vaultTotalUnderlying > 0, \\\"NUL\\\");\\r\\n\\r\\n        uint256 totalProportion;\\r\\n        uint256 totalDepositProportion;\\r\\n        uint256 lastDepositIndex;\\r\\n\\r\\n        {\\r\\n            // flags to check if reallocation will withdraw and reposit\\r\\n            bool didWithdraw = false;\\r\\n            bool willDeposit = false;\\r\\n            for (uint256 i; i < vaultStrategies.length; i++) {\\r\\n                uint256 newStratProportion = Bitwise.get14BitUintByIndex(newVaultProportions, i);\\r\\n                totalProportion += newStratProportion;\\r\\n\\r\\n                uint256 stratProportion;\\r\\n                if (stratUnderlyings[i] > 0) {\\r\\n                    stratProportion = (stratUnderlyings[i] * FULL_PERCENT) / vaultTotalUnderlying;\\r\\n                }\\r\\n\\r\\n                // if current proportion is more than new - withdraw\\r\\n                if (stratProportion > newStratProportion) {\\r\\n                    uint256 withdrawalProportion = stratProportion - newStratProportion;\\r\\n                    if (withdrawalProportion < 10) // NOTE: skip if diff is less than 0.1%\\r\\n                        continue;\\r\\n\\r\\n                    uint256 withdrawalShareProportion = (withdrawalProportion * ACCURACY) / stratProportion;\\r\\n                    withdrawProportionsArray[i] = withdrawalShareProportion;\\r\\n\\r\\n                    didWithdraw = true;\\r\\n                } else if (stratProportion < newStratProportion) {\\r\\n                    // if less - prepare for deposit\\r\\n                    uint256 depositProportion = newStratProportion - stratProportion;\\r\\n                    if (depositProportion < 10) // NOTE: skip if diff is less than 0.1%\\r\\n                        continue;\\r\\n\\r\\n                    depositProportionsArray[i] = depositProportion;\\r\\n                    totalDepositProportion += depositProportion;\\r\\n                    lastDepositIndex = i;\\r\\n\\r\\n                    willDeposit = true;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // check if sum of new propotions equals to full percent\\r\\n            require(\\r\\n                totalProportion == FULL_PERCENT,\\r\\n                \\\"BPP\\\"\\r\\n            );\\r\\n\\r\\n            // Check if withdraw happened and if deposit will, otherwise revert\\r\\n            require(didWithdraw && willDeposit, \\\"NRD\\\");\\r\\n        }\\r\\n\\r\\n        // normalize deposit proportions to FULL_PERCENT\\r\\n        uint256 newDepositProportions;\\r\\n        uint256 totalDepositProp;\\r\\n        for (uint256 i; i <= lastDepositIndex; i++) {\\r\\n            if (depositProportionsArray[i] > 0) {\\r\\n                uint256 proportion = (depositProportionsArray[i] * FULL_PERCENT) / totalDepositProportion;\\r\\n\\r\\n                newDepositProportions = newDepositProportions.set14BitUintByIndex(i, proportion);\\r\\n                \\r\\n                totalDepositProp += proportion;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        newDepositProportions = newDepositProportions.set14BitUintByIndex(lastDepositIndex, FULL_PERCENT - totalDepositProp);\\r\\n\\r\\n        // store reallocation deposit proportions\\r\\n        depositProportions = newDepositProportions;\\r\\n\\r\\n        return (withdrawProportionsArray, newDepositProportions);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get strategies and vault underlying\\r\\n     * @param vaultStrategies Array of vault strategy addresses\\r\\n     * @param index Get the underlying amounts at index\\r\\n     */\\r\\n    function _getStratsAndVaultUnderlying(address[] memory vaultStrategies, uint256 index)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256[] memory, uint256)\\r\\n    {\\r\\n        uint256[] memory stratUnderlyings = new uint256[](vaultStrategies.length);\\r\\n\\r\\n        uint256 vaultTotalUnderlying;\\r\\n        for (uint256 i; i < vaultStrategies.length; i++) {\\r\\n            uint256 stratUnderlying = spool.getVaultTotalUnderlyingAtIndex(vaultStrategies[i], index);\\r\\n\\r\\n            stratUnderlyings[i] = stratUnderlying;\\r\\n            vaultTotalUnderlying += stratUnderlying;\\r\\n        }\\r\\n\\r\\n        return (stratUnderlyings, vaultTotalUnderlying);\\r\\n    }\\r\\n}\\r\\n\\r\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ISpool\",\"name\":\"_spool\",\"type\":\"address\"},{\"internalType\":\"contract IController\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"contract IFastWithdraw\",\"name\":\"_fastWithdraw\",\"type\":\"address\"},{\"internalType\":\"contract IFeeHandler\",\"name\":\"_feeHandler\",\"type\":\"address\"},{\"internalType\":\"contract ISpoolOwner\",\"name\":\"_spoolOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"fee\",\"type\":\"uint16\"}],\"name\":\"LowerVaultFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"periodFinish\",\"type\":\"uint32\"}],\"name\":\"PeriodFinishUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"index\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newProportions\",\"type\":\"uint256\"}],\"name\":\"Reallocate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leftover\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"periodFinish\",\"type\":\"uint32\"}],\"name\":\"RewardExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"RewardRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"StrategyRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"TransferVaultOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"UpdateName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"globalIndex\",\"type\":\"uint256\"}],\"name\":\"UserRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"globalIndex\",\"type\":\"uint256\"}],\"name\":\"VaultRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"WithdrawFast\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"rewardsDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"doRedeemVault\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"vaultStrategies\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"doRedeemUser\",\"type\":\"bool\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"claimAmount\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimFinishedRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaultStrategies\",\"type\":\"address[]\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"transferFromVault\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"forceRemoveReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getActiveRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getRewardForDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaultStrategies\",\"type\":\"address[]\"}],\"name\":\"getUpdatedUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaultStrategies\",\"type\":\"address[]\"}],\"name\":\"getUpdatedVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"fee\",\"type\":\"uint16\"},{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"proportions\",\"type\":\"uint256[]\"}],\"internalType\":\"struct VaultInitializable\",\"name\":\"vaultInitializable\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastIndexInteracted\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"index1\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"index2\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_vaultFee\",\"type\":\"uint16\"}],\"name\":\"lowerVaultFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"rewardsDuration\",\"type\":\"uint32\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaultStrategies\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"notifyStrategyRemoved\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"payFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proportions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaultStrategies\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"newVaultProportions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishedIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"activeIndex\",\"type\":\"uint24\"}],\"name\":\"reallocate\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"withdrawProportionsArray\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"newDepositProportions\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reallocationIndex\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaultStrategies\",\"type\":\"address[]\"}],\"name\":\"redeemVaultAndUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaultStrategies\",\"type\":\"address[]\"}],\"name\":\"redeemVaultStrategies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"redeems\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"depositShares\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"withdrawnAmount\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardConfiguration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"rewardsDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"periodFinish\",\"type\":\"uint32\"},{\"internalType\":\"uint192\",\"name\":\"rewardRate\",\"type\":\"uint192\"},{\"internalType\":\"uint32\",\"name\":\"lastUpdateTime\",\"type\":\"uint32\"},{\"internalType\":\"uint224\",\"name\":\"rewardPerTokenStored\",\"type\":\"uint224\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint224\",\"name\":\"\",\"type\":\"uint224\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardTokens\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTokensCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategiesHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBlacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInstantDeposit\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultOwner\",\"type\":\"address\"}],\"name\":\"transferVaultOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"updateName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"name\":\"updatePeriodFinish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userIndexAction\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"depositAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"withdrawShares\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLastInteractions\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"index1\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"index2\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"instantDeposit\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"activeDeposit\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"owed\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"withdrawnDeposits\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"shares\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultFee\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vaultIndexAction\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"depositAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"withdrawShares\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaultStrategies\",\"type\":\"address[]\"},{\"internalType\":\"uint128\",\"name\":\"sharesToWithdraw\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"withdrawAll\",\"type\":\"bool\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaultStrategies\",\"type\":\"address[]\"},{\"internalType\":\"uint128\",\"name\":\"sharesToWithdraw\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"withdrawAll\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"doExecuteWithdraw\",\"type\":\"bool\"},{\"internalType\":\"uint256[][]\",\"name\":\"slippages\",\"type\":\"uint256[][]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapData[][]\",\"name\":\"swapData\",\"type\":\"tuple[][]\"}],\"internalType\":\"struct FastWithdrawParams\",\"name\":\"fastWithdrawParams\",\"type\":\"tuple\"}],\"name\":\"withdrawFast\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Vault", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000534ef1c63cc191076ea8252f25bbd29d9db6e635000000000000000000000000e5b126ae9540809488990a9813e1a2732f678047000000000000000000000000a602141d5f84490071dd977e1c12c82628e1af6c00000000000000000000000091e08c609ca54517846118a3929044ef9a2e676d0000000000000000000000004f03f70a99e5c3b49d733ddd7458f80fa9b5a5b5", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}