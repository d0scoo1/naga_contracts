{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.12;\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'TELE' token governance smart contract\r\n//\r\n// Symbol      : TELE\r\n// Name        : Telefy\r\n// Max Total Circulating supply: 1000000000\r\n// Decimals    : 18\r\n//\r\n//\r\n//\r\n// (c) by Telefy Technologies Private Limited.\r\n// ----------------------------------------------------------------------------\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\ncontract SafeMath {\r\n\tfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\tc = a + b;\r\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\r\n\t}\r\n\r\n\tfunction safeSub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\trequire(b <= a, \"SafeMath: subtraction overflow\");\r\n\t\tc = a - b;\r\n\t}\r\n\r\n\tfunction safeMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\tif (a == 0) {\r\n\t\t\tc = 0;\r\n\t\t} else {\r\n\t\t\tc = a * b;\r\n\t\t}\r\n\t\trequire((a == 0 || c / a == b), \"SafeMath: multiplication overflow\");\r\n\t}\r\n\r\n\tfunction safeDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\trequire(b > 0, \"SafeMath: division by zero\");\r\n\t\tc = a / b;\r\n\t}\r\n\r\n\tfunction safeMod(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\trequire(b != 0, \"SafeMath: modulo by zero\");\r\n\t\tc = a % b;\r\n\t}\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Information of context: Sender and Data\r\n// ----------------------------------------------------------------------------\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns (bytes memory) {\r\n\t\tthis; // Warning: silence state mutability without generating bytecode\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\nabstract contract ERC20Interface {\r\n\tfunction totalSupply() public view virtual returns (uint256);\r\n\r\n\tfunction balanceOf(address tokenOwner) public view virtual returns (uint256 balance);\r\n\r\n\tfunction allowance(address tokenOwner, address spender)\r\n\t\tpublic\r\n\t\tview\r\n\t\tvirtual\r\n\t\treturns (uint256 remaining);\r\n\r\n\tfunction transfer(address to, uint256 tokens) external virtual returns (bool success);\r\n\r\n\tfunction approve(address spender, uint256 tokens) public virtual returns (bool success);\r\n\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokens\r\n\t) external virtual returns (bool success);\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 tokens);\r\n\tevent Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract function to receive approval and execute function in one call\r\n//\r\n// Borrowed from MiniMeToken\r\n// ----------------------------------------------------------------------------\r\nabstract contract ApproveAndCallFallBack {\r\n\tfunction receiveApproval(\r\n\t\taddress from,\r\n\t\tuint256 tokens,\r\n\t\taddress token,\r\n\t\tbytes memory data\r\n\t) public virtual;\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n\taddress public owner;\r\n\taddress public newOwner;\r\n\r\n\tevent OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n\tconstructor() {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferOwnership(address _newOwner) external onlyOwner {\r\n\t\tnewOwner = _newOwner;\r\n\t}\r\n\r\n\tfunction acceptOwnership() external {\r\n\t\trequire(msg.sender == newOwner);\r\n\t\temit OwnershipTransferred(owner, newOwner);\r\n\t\towner = newOwner;\r\n\t\tnewOwner = address(0);\r\n\t}\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// @dev Collection of functions related to the address type\r\n// @openzeppelin/contracts/utils/Address.sol\r\n// ----------------------------------------------------------------------------\r\nlibrary Address {\r\n\t// ----------------------------------------------------------------------------\r\n\t// @dev Returns true if `account` is a contract.\r\n\t//\r\n\t// [IMPORTANT]\r\n\t// It is unsafe to assume that an address for which this function returns\r\n\t// false is an externally-owned account (EOA) and not a contract.\r\n\t//\r\n\t// Among others, `isContract` will return false for the following\r\n\t// types of addresses:\r\n\t//\r\n\t//  - an externally-owned account\r\n\t//  - a contract in construction\r\n\t//  - an address where a contract will be created\r\n\t//  - an address where a contract lived, but was destroyed\r\n\t// ----------------------------------------------------------------------------\r\n\tfunction isContract(address account) internal view returns (bool) {\r\n\t\t// According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n\t\t// and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n\t\t// for accounts without code, i.e. `keccak256('')`\r\n\t\tbytes32 codehash;\r\n\t\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n\t\t// solhint-disable-next-line no-inline-assembly\r\n\t\tassembly {\r\n\t\t\tcodehash := extcodehash(account)\r\n\t\t}\r\n\t\treturn (codehash != accountHash && codehash != 0x0);\r\n\t}\r\n\r\n\t// ----------------------------------------------------------------------------\r\n\t// @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n\t// `recipient`, forwarding all available gas and reverting on errors.\r\n\t//\r\n\t// https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n\t// of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n\t// imposed by `transfer`, making them unable to receive funds via\r\n\t// `transfer`. {sendValue} removes this limitation.\r\n\t//\r\n\t// https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n\t//\r\n\t// IMPORTANT: because control is transferred to `recipient`, TELEe must be\r\n\t// taken to not create reentrancy vulnerabilities. Consider using\r\n\t// {ReentrancyGuard} or the\r\n\t// https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n\t// ----------------------------------------------------------------------------\r\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n\t\t// solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n\t\t(bool success, ) = recipient.call{ value: amount }(\"\");\r\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n\t}\r\n\r\n\t// ----------------------------------------------------------------------------\r\n\t// @dev Performs a Solidity function call using a low level `call`. A\r\n\t// plain`call` is an unsafe replacement for a function call: use this\r\n\t// function instead.\r\n\t//\r\n\t// If `target` reverts with a revert reason, it is bubbled up by this\r\n\t// function (like regular Solidity function calls).\r\n\t//\r\n\t// Returns the raw returned data. To convert to the expected return value,\r\n\t// use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n\t// _Available since v3.1._\r\n\t// ----------------------------------------------------------------------------\r\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\r\n\t}\r\n\r\n\t// ----------------------------------------------------------------------------\r\n\t// @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n\t// `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t// _Available since v3.1._\r\n\t// ----------------------------------------------------------------------------\r\n\tfunction functionCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\treturn _functionCallWithValue(target, data, 0, errorMessage);\r\n\t}\r\n\r\n\t// ----------------------------------------------------------------------------\r\n\t// @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t// but also transferring `value` wei to `target`.\r\n\t// _Available since v3.1._\r\n\t// ----------------------------------------------------------------------------\r\n\tfunction functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 value\r\n\t) internal returns (bytes memory) {\r\n\t\treturn\r\n\t\t\tfunctionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n\t}\r\n\r\n\t// ----------------------------------------------------------------------------\r\n\t// @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n\t// with `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t// _Available since v3.1._\r\n\t// ----------------------------------------------------------------------------\r\n\tfunction functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 value,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n\t\treturn _functionCallWithValue(target, data, value, errorMessage);\r\n\t}\r\n\r\n\tfunction _functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 weiValue,\r\n\t\tstring memory errorMessage\r\n\t) private returns (bytes memory) {\r\n\t\trequire(isContract(target), \"Address: call to non-contract\");\r\n\r\n\t\t// solhint-disable-next-line avoid-low-level-calls\r\n\t\t(bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n\t\tif (success) {\r\n\t\t\treturn returndata;\r\n\t\t} else {\r\n\t\t\t// Look for revert reason and bubble it up if present\r\n\t\t\tif (returndata.length > 0) {\r\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n\t\t\t\t// solhint-disable-next-line no-inline-assembly\r\n\t\t\t\tassembly {\r\n\t\t\t\t\tlet returndata_size := mload(returndata)\r\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\trevert(errorMessage);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// TELE Token, with the addition of symbol, name and decimals and assisted\r\n// token transfers\r\n// TELE is Governance token for TELEFY\r\n// ----------------------------------------------------------------------------\r\ncontract TELEToken is ERC20Interface, Owned, SafeMath, Context {\r\n\tusing Address for address;\r\n\r\n\tstring public symbol;\r\n\tstring public name;\r\n\tuint8 public decimals;\r\n\tuint256 private _totalSupply;\r\n\taddress private _minter;\r\n\r\n\tmapping(address => uint256) balances;\r\n\tmapping(address => mapping(address => uint256)) allowed;\r\n\r\n\t/// @notice The timestamp after which minting may occur\r\n\tuint256 public mintingAllowedAfter;\r\n\r\n\t/// @notice Minimum time between mints\r\n\tuint32 public constant minimumTimeBetweenMints = 1 days * 7;\r\n\r\n\t/// @notice Cap on the percentage of totalSupply that can be minted at each mint\r\n\t/// We are going to divide this by 1000. so below is 0.2 percent of totalSupply\r\n\tuint8 public constant mintCap = 2;\r\n\r\n\t/// @notice A record of each accounts delegate\r\n\tmapping(address => address) internal _delegates;\r\n\r\n\t/// @notice A checkpoint for marking number of votes from a given block\r\n\tstruct Checkpoint {\r\n\t\tuint32 fromBlock;\r\n\t\tuint256 votes;\r\n\t}\r\n\r\n\t/// @notice A record of votes checkpoints for each account, by index\r\n\tmapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\r\n\r\n\t/// @notice The number of checkpoints for each account\r\n\tmapping(address => uint32) public numCheckpoints;\r\n\r\n\t/// @notice The EIP-712 typehash for the contract's domain\r\n\tbytes32 public constant DOMAIN_TYPEHASH =\r\n\t\tkeccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n\t/// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n\tbytes32 public constant DELEGATION_TYPEHASH =\r\n\t\tkeccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n\t/// @notice The EIP-712 typehash for the permit struct used by the contract\r\n\tbytes32 public constant PERMIT_TYPEHASH =\r\n\t\tkeccak256(\r\n\t\t\t\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\r\n\t\t);\r\n\r\n\t/// @notice A record of states for signing / validating signatures\r\n\tmapping(address => uint256) public nonces;\r\n\r\n\t// @notice An event thats emitted when multiple transactions made\r\n\tevent TransferMultiple(address indexed from, address[] indexed to, uint256[] tokens);\r\n\r\n\t/// @notice An event thats emitted when an account changes its delegate\r\n\tevent DelegateChanged(\r\n\t\taddress indexed delegator,\r\n\t\taddress indexed fromDelegate,\r\n\t\taddress indexed toDelegate\r\n\t);\r\n\r\n\t/// @notice An event thats emitted when a delegate account's vote balance changes\r\n\tevent DelegateVotesChanged(\r\n\t\taddress indexed delegate,\r\n\t\tuint256 previousBalance,\r\n\t\tuint256 newBalance\r\n\t);\r\n\r\n\t// @notice An event thats emitted when the minter address is changed\r\n\tevent MinterChanged(address minter, address newMinter);\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// Constructor\r\n\t///**\r\n     //* @notice Construct a new TELE token\r\n     //* @param account The initial account to grant all the tokens\r\n     //* @param minter_ The account with minting ability\r\n     //* @param mintingAllowedAfter_ The timestamp after which minting may occur\r\n     //*\r\n\t// ------------------------------------------------------------------------\r\n\tconstructor() {\r\n\t\tsymbol = \"TELE\";\r\n\t\tname = \"Telefy\";\r\n\t\tdecimals = 18;\r\n\t\t_totalSupply = 600_000_000e18;\r\n\t\tbalances[owner] = _totalSupply;\r\n\t\temit Transfer(address(0), owner, _totalSupply);\r\n\t\t_minter = 0xa270dA3c3175ED9992c9Ad3B6Bb679Bf81c35BA8;\r\n\t\tmintingAllowedAfter = safeAdd(block.timestamp, minimumTimeBetweenMints);\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// Total supply\r\n\t// ------------------------------------------------------------------------\r\n\tfunction totalSupply() public view override returns (uint256) {\r\n\t\treturn safeSub(_totalSupply, balances[address(0)]);\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// Get the token balance for account tokenOwner\r\n\t// ------------------------------------------------------------------------\r\n\tfunction balanceOf(address tokenOwner) public view override returns (uint256 balance) {\r\n\t\treturn balances[tokenOwner];\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// Transfer the balance from token owner's account to to account\r\n\t// - Owner's account must have sufficient balance to transfer\r\n\t// - 0 value transfers are allowed\r\n\t// ------------------------------------------------------------------------\r\n\tfunction transfer(address to, uint256 tokens) external override returns (bool success) {\r\n\t\trequire(to != address(0), \"TELE: transfer to the zero address\");\r\n\t\t_transferTokens(to, tokens);\r\n\t\temit Transfer(_msgSender(), to, tokens);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// Transfer the balance from token owner's account to to multiple accounts\r\n\t// - Owner's account must have sufficient balance to transfer\r\n\t// - 0 value transfers are allowed\r\n\t// ------------------------------------------------------------------------\r\n\tfunction transferMultiple(address[] memory to, uint256[] memory tokens)\r\n\t\texternal\r\n\t\treturns (bool success)\r\n\t{\r\n\t\trequire(\r\n\t\t\tto.length == tokens.length,\r\n\t\t\t\"TELE: number of receiver addresses and number of amounts should be equal\"\r\n\t\t);\r\n\t\tfor (uint256 i = 0; i < to.length; i++) {\r\n\t\t\tif (to[i] != address(0)) {\r\n\t\t\t\t_transferTokens(to[i], tokens[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\temit TransferMultiple(_msgSender(), to, tokens);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// Token owner can approve for spender to transferFrom(...) tokens\r\n\t// from the token owner's account\r\n\t//\r\n\t// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n\t// recommends that there are no checks for the approval double-spend attack\r\n\t// as this should be implemented in user interfaces\r\n\t// ------------------------------------------------------------------------\r\n\tfunction approve(address spender, uint256 tokens) public override returns (bool success) {\r\n\t\trequire(spender != address(0), \"TELE: transfer to the zero address\");\r\n\t\tallowed[_msgSender()][spender] = tokens;\r\n\t\temit Approval(_msgSender(), spender, tokens);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// @notice Triggers an approval from owner to spends\r\n\t// @param owner The address to approve from\r\n\t// @param spender The address to be approved\r\n\t// @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\r\n\t// @param deadline The time at which to expire the signature\r\n\t// @param v The recovery byte of the signature\r\n\t// @param r Half of the ECDSA signature pair\r\n\t// @param s Half of the ECDSA signature pair\r\n\t// ------------------------------------------------------------------------\r\n\tfunction permit(\r\n\t\taddress owner,\r\n\t\taddress spender,\r\n\t\tuint256 rawAmount,\r\n\t\tuint256 deadline,\r\n\t\tuint8 v,\r\n\t\tbytes32 r,\r\n\t\tbytes32 s\r\n\t) external {\r\n\t\tbytes32 domainSeparator = keccak256(\r\n\t\t\tabi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this))\r\n\t\t);\r\n\t\tbytes32 structHash = keccak256(\r\n\t\t\tabi.encode(PERMIT_TYPEHASH, owner, spender, rawAmount, nonces[owner]++, deadline)\r\n\t\t);\r\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n\t\taddress signatory = ecrecover(digest, v, r, s);\r\n\t\trequire(signatory != address(0), \"TELE::permit: invalid signature\");\r\n\t\trequire(signatory == owner, \"TELE::permit: unauthorized\");\r\n\t\trequire(block.timestamp <= deadline, \"TELE::permit: signature expired\");\r\n\r\n\t\tallowed[owner][spender] = rawAmount;\r\n\r\n\t\temit Approval(owner, spender, rawAmount);\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// Transfer tokens from the from account to the to account\r\n\t//\r\n\t// The calling account must already have sufficient tokens approve(...)-d\r\n\t// for spending from the from account and\r\n\t// - From account must have sufficient balance to transfer\r\n\t// - Spender must have sufficient allowance to transfer\r\n\t// - 0 value transfers are allowed\r\n\t// ------------------------------------------------------------------------\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokens\r\n\t) external override returns (bool success) {\r\n\t\tbalances[from] = safeSub(balances[from], tokens);\r\n\t\tallowed[from][_msgSender()] = safeSub(allowed[from][_msgSender()], tokens);\r\n\t\temit Approval(from, to, tokens);\r\n\t\tbalances[to] = safeAdd(balances[to], tokens);\r\n\t\temit Transfer(from, to, tokens);\r\n\t\t_moveDelegates(_delegates[from], _delegates[to], tokens);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// Returns the amount of tokens approved by the owner that can be\r\n\t// transferred to the spender's account\r\n\t// ------------------------------------------------------------------------\r\n\tfunction allowance(address tokenOwner, address spender)\r\n\t\tpublic\r\n\t\tview\r\n\t\toverride\r\n\t\treturns (uint256 remaining)\r\n\t{\r\n\t\treturn allowed[tokenOwner][spender];\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// @dev Atomically increases the allowance granted to `spender` by the caller.\r\n\t// This is an alternative to {approve} that can be used as a mitigation for\r\n\t// problems described in {IERC20-approve}.\r\n\t// Emits an {Approval} event indicating the updated allowance.\r\n\t// ------------------------------------------------------------------------\r\n\tfunction increaseAllowance(address spender, uint256 addedValue)\r\n\t\texternal\r\n\t\tvirtual\r\n\t\treturns (bool)\r\n\t{\r\n\t\tapprove(spender, safeAdd(allowed[_msgSender()][spender], addedValue));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n\t// This is an alternative to {approve} that can be used as a mitigation for\r\n\t// problems described in {IERC20-approve}.\r\n\t// Emits an {Approval} event indicating the updated allowance.\r\n\t// ------------------------------------------------------------------------\r\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue)\r\n\t\texternal\r\n\t\tvirtual\r\n\t\treturns (bool)\r\n\t{\r\n\t\tapprove(spender, safeSub(allowed[_msgSender()][spender], subtractedValue));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// Token owner can approve for spender to transferFrom(...) tokens\r\n\t// from the token owner's account. The spender contract function\r\n\t// receiveApproval(...) is then executed\r\n\t// ------------------------------------------------------------------------\r\n\tfunction approveAndCall(\r\n\t\taddress spender,\r\n\t\tuint256 tokens,\r\n\t\tbytes memory data\r\n\t) external returns (bool success) {\r\n\t\tallowed[_msgSender()][spender] = tokens;\r\n\t\temit Approval(_msgSender(), spender, tokens);\r\n\t\tApproveAndCallFallBack(spender).receiveApproval(_msgSender(), tokens, address(this), data);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// Owner can transfer out any accidentally sent ERC20 tokens\r\n\t// ------------------------------------------------------------------------\r\n\tfunction transferAnyERC20Token(address tokenAddress, uint256 tokens)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t\treturns (bool success)\r\n\t{\r\n\t\treturn ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// @dev Destroys `amount` tokens from `account`'s allowance, reducing the\r\n\t// total supply which requires approval from user before this action can be performed.\r\n\t// Emits a {Transfer} event with `to` set to the zero address.\r\n\t// ------------------------------------------------------------------------\r\n\tfunction burn(address account, uint256 amount) external {\r\n\t\trequire(_msgSender() == _minter, \"TELE::burn: only the minter can mint\");\r\n\t\trequire(account != address(0), \"TELE: burn from the zero address\");\r\n\r\n\t\t_beforeTokenTransfer(account, address(0), amount);\r\n\r\n\t\tbalances[account] = safeSub(balances[account], amount);\r\n\r\n\t\t// Sets `amount` as the allowance of `spender`\r\n\t\tallowed[account][_msgSender()] = safeSub(allowed[account][_msgSender()], amount);\r\n\t\temit Approval(account, _msgSender(), amount);\r\n\r\n\t\t_totalSupply = safeSub(_totalSupply, amount);\r\n\t\temit Transfer(account, address(0), amount);\r\n\t\t_moveDelegates(address(0), _delegates[account], amount);\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n\t// the total supply.\r\n\t// Emits a {Transfer} event with `from` set to the zero address.\r\n\t// ------------------------------------------------------------------------\r\n\tfunction mint(address account, uint256 amount) external {\r\n\t\trequire(_msgSender() == _minter, \"TELE::mint: only the minter can mint\");\r\n\t\trequire(block.timestamp >= mintingAllowedAfter, \"TELE::mint: minting not allowed yet\");\r\n\t\trequire(account != address(0), \"TELE: mint to the zero address\");\r\n\r\n\t\t// record the mint\r\n\t\tmintingAllowedAfter = safeAdd(block.timestamp, minimumTimeBetweenMints);\r\n\r\n\t\t_beforeTokenTransfer(address(0), account, amount);\r\n\r\n\t\t// mint amount should not exceed mint cap\r\n\t\trequire(amount <= safeDiv(safeMul(_totalSupply, mintCap), 1000));\r\n\t\t_totalSupply = safeAdd(_totalSupply, amount);\r\n\t\tbalances[account] = safeAdd(balances[account], amount);\r\n\t\temit Transfer(address(0), account, amount);\r\n\t\t_moveDelegates(address(0), _delegates[account], amount);\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// @notice Change the minter address\r\n\t// @param minter_ The address of the new minter\r\n\t// ------------------------------------------------------------------------\r\n\tfunction setMinter(address minter_) external {\r\n\t\trequire(\r\n\t\t\t_msgSender() == _minter,\r\n\t\t\t\"TELE::setMinter: only the minter can change the minter address\"\r\n\t\t);\r\n\t\temit MinterChanged(_minter, minter_);\r\n\t\t_minter = minter_;\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// @notice Delegate votes from `msg.sender` to `delegatee`\r\n\t// @param delegator The address to get delegatee for\r\n\t// ------------------------------------------------------------------------\r\n\tfunction delegates(address delegator) external view returns (address) {\r\n\t\treturn _delegates[delegator];\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// @notice Delegate votes from `msg.sender` to `delegatee`\r\n\t// @param delegatee The address to delegate votes to\r\n\t// ------------------------------------------------------------------------\r\n\tfunction delegate(address delegatee) external {\r\n\t\treturn _delegate(_msgSender(), delegatee);\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// @notice Delegates votes from signatory to `delegatee`\r\n\t// @param delegatee The address to delegate votes to\r\n\t// @param nonce The contract state required to match the signature\r\n\t// @param expiry The time at which to expire the signature\r\n\t// @param v The recovery byte of the signature\r\n\t// @param r Half of the ECDSA signature pair\r\n\t// @param s Half of the ECDSA signature pair\r\n\t// ------------------------------------------------------------------------\r\n\tfunction delegateBySig(\r\n\t\taddress delegatee,\r\n\t\tuint256 nonce,\r\n\t\tuint256 expiry,\r\n\t\tuint8 v,\r\n\t\tbytes32 r,\r\n\t\tbytes32 s\r\n\t) external {\r\n\t\tbytes32 domainSeparator = keccak256(\r\n\t\t\tabi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this))\r\n\t\t);\r\n\r\n\t\tbytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\r\n\r\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n\r\n\t\taddress signatory = ecrecover(digest, v, r, s);\r\n\t\trequire(signatory != address(0), \"TELE::delegateBySig: invalid signature\");\r\n\t\trequire(nonce == nonces[signatory]++, \"TELE::delegateBySig: invalid nonce\");\r\n\t\trequire(block.timestamp <= expiry, \"TELE::delegateBySig: signature expired\");\r\n\t\treturn _delegate(signatory, delegatee);\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// @notice Gets the current votes balance for `account`\r\n\t// @param account The address to get votes balance\r\n\t// @return The number of current votes for `account`\r\n\t// ------------------------------------------------------------------------\r\n\tfunction getCurrentVotes(address account) external view returns (uint256) {\r\n\t\tuint32 nCheckpoints = numCheckpoints[account];\r\n\t\treturn nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n\t}\r\n\r\n\t// ------------------------------------------------------------------------\r\n\t// @notice Determine the prior number of votes for an account as of a block number\r\n\t// @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\r\n\t// @param account The address of the account to check\r\n\t// @param blockNumber The block number to get the vote balance at\r\n\t// @return The number of votes the account had as of the given block\r\n\t// ------------------------------------------------------------------------\r\n\tfunction getPriorVotes(address account, uint256 blockNumber) external view returns (uint256) {\r\n\t\trequire(blockNumber < block.number, \"TELE::getPriorVotes: not yet determined\");\r\n\r\n\t\tuint32 nCheckpoints = numCheckpoints[account];\r\n\t\tif (nCheckpoints == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// First check most recent balance\r\n\t\tif (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n\t\t\treturn checkpoints[account][nCheckpoints - 1].votes;\r\n\t\t}\r\n\r\n\t\t// Next check implicit zero balance\r\n\t\tif (checkpoints[account][0].fromBlock > blockNumber) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint32 lower = 0;\r\n\t\tuint32 upper = nCheckpoints - 1;\r\n\t\twhile (upper > lower) {\r\n\t\t\tuint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n\t\t\tCheckpoint memory cp = checkpoints[account][center];\r\n\t\t\tif (cp.fromBlock == blockNumber) {\r\n\t\t\t\treturn cp.votes;\r\n\t\t\t} else if (cp.fromBlock < blockNumber) {\r\n\t\t\t\tlower = center;\r\n\t\t\t} else {\r\n\t\t\t\tupper = center - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn checkpoints[account][lower].votes;\r\n\t}\r\n\r\n\tfunction _transferTokens(address to, uint256 tokens) internal {\r\n\t\tbalances[_msgSender()] = safeSub(balances[_msgSender()], tokens);\r\n\t\tbalances[to] = safeAdd(balances[to], tokens);\r\n\t\t_moveDelegates(_delegates[_msgSender()], _delegates[to], tokens);\r\n\t}\r\n\r\n\tfunction _delegate(address delegator, address delegatee) internal {\r\n\t\taddress currentDelegate = _delegates[delegator];\r\n\t\tuint256 delegatorBalance = balanceOf(delegator); // balance of underlying TELEs (not scaled);\r\n\t\t_delegates[delegator] = delegatee;\r\n\r\n\t\temit DelegateChanged(delegator, currentDelegate, delegatee);\r\n\r\n\t\t_moveDelegates(currentDelegate, delegatee, delegatorBalance);\r\n\t}\r\n\r\n\tfunction _moveDelegates(\r\n\t\taddress srcRep,\r\n\t\taddress dstRep,\r\n\t\tuint256 amount\r\n\t) internal {\r\n\t\tif (srcRep != dstRep && amount > 0) {\r\n\t\t\tif (srcRep != address(0)) {\r\n\t\t\t\t// decrease old representative\r\n\t\t\t\tuint32 srcRepNum = numCheckpoints[srcRep];\r\n\t\t\t\tuint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n\t\t\t\tuint256 srcRepNew = safeSub(srcRepOld, amount);\r\n\t\t\t\t_writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n\t\t\t}\r\n\r\n\t\t\tif (dstRep != address(0)) {\r\n\t\t\t\t// increase new representative\r\n\t\t\t\tuint32 dstRepNum = numCheckpoints[dstRep];\r\n\t\t\t\tuint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n\t\t\t\tuint256 dstRepNew = safeAdd(dstRepOld, amount);\r\n\t\t\t\t_writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _writeCheckpoint(\r\n\t\taddress delegatee,\r\n\t\tuint32 nCheckpoints,\r\n\t\tuint256 oldVotes,\r\n\t\tuint256 newVotes\r\n\t) internal {\r\n\t\tuint32 blockNumber = safe32(\r\n\t\t\tblock.number,\r\n\t\t\t\"TELE::_writeCheckpoint: block number exceeds 32 bits\"\r\n\t\t);\r\n\r\n\t\tif (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\r\n\t\t\tcheckpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n\t\t} else {\r\n\t\t\tcheckpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\r\n\t\t\tnumCheckpoints[delegatee] = nCheckpoints + 1;\r\n\t\t}\r\n\r\n\t\temit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n\t}\r\n\r\n\tfunction safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\r\n\t\trequire(n < 2**32, errorMessage);\r\n\t\treturn uint32(n);\r\n\t}\r\n\r\n\tfunction getChainId() internal view returns (uint256) {\r\n\t\tuint256 chainId;\r\n\t\tassembly {\r\n\t\t\tchainId := chainid()\r\n\t\t}\r\n\t\treturn chainId;\r\n\t}\r\n\r\n\tfunction _beforeTokenTransfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 amount\r\n\t) internal virtual {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromDelegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toDelegate\",\"type\":\"address\"}],\"name\":\"DelegateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"DelegateVotesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMinter\",\"type\":\"address\"}],\"name\":\"MinterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"TransferMultiple\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DELEGATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"checkpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"fromBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"delegateBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"}],\"name\":\"delegates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getCurrentVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getPriorVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTimeBetweenMints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintCap\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintingAllowedAfter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"numCheckpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter_\",\"type\":\"address\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"transferMultiple\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TELEToken", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d0e5c1c4f29130c4545892d49f0999fd6c7d78abdfd0da46f7e1dd0b952f2e82"}]}