{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/tokens/empire.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n}\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n    address private _previousOwner;\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address payable newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\ninterface IUniswapV2Factory {\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n}\\n\\ncontract Empire is Context, IERC20, Ownable {\\n    using SafeMath for uint256;\\n    string private constant _name = \\\"Empire\\\";\\n    string private constant _symbol = \\\"EMP\\\";\\n    uint8 private constant _decimals = 9;\\n    mapping(address => uint256) private _rOwned;\\n    mapping(address => uint256) private _tOwned;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n    mapping(address => bool) private _isExcludedFromFee;\\n    uint256 private constant MAX = ~uint256(0);\\n    uint256 private constant _tTotal = 10000000000 * 10**9;\\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\\n    uint256 private _tFeeTotal;\\n\\n    uint256 private _devTax;\\n    uint256 private _buyDevTax = 4;\\n    uint256 private _sellDevTax = 4;\\n\\n    uint256 private _marketingTax;\\n    uint256 private _buyMarketingTax = 4;\\n    uint256 private _sellMarketingTax = 4;\\n\\n    uint256 private _salesTax;\\n    uint256 private _buySalesTax = 2;\\n    uint256 private _sellSalesTax = 2;\\n\\n    uint256 private _totalBuyTax = _buyDevTax + _buyMarketingTax + _buySalesTax;\\n    uint256 private _totalSellTax = _sellDevTax + _sellMarketingTax + _sellSalesTax;\\n\\n    uint256 private _summedTax = _marketingTax+_salesTax;\\n    uint256 private _numOfTokensToExchangeForTeam = 50000 * 10**9;\\n    uint256 private _routermax = 50000000 * 10**9;\\n\\n    // Bot detection\\n    mapping(address => bool) private bots;\\n    mapping(address => uint256) private cooldown;\\n    address payable private _Marketingfund;\\n    address payable private _Deployer;\\n    address payable private _devWalletAddress;\\n    address payable private _holdings;\\n    IUniswapV2Router02 private uniswapV2Router;\\n    address private uniswapV2Pair;\\n    bool private tradingOpen;\\n    bool private inSwap = false;\\n    bool private swapEnabled = false;\\n    bool private cooldownEnabled = false;\\n    bool private enableLevelSell = false;\\n    uint256 private _maxTxAmount = _tTotal;\\n    uint256 public launchBlock;\\n\\n    event MaxTxAmountUpdated(uint256 _maxTxAmount);\\n    modifier lockTheSwap {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n\\n    constructor(address payable marketingTaxAddress, address payable devfeeAddr, address payable depAddr, address payable holdings) {\\n        _Marketingfund = marketingTaxAddress;\\n        _Deployer = depAddr;\\n        _devWalletAddress = devfeeAddr;\\n        _holdings = holdings;\\n        _rOwned[_msgSender()] = _rTotal;\\n        _isExcludedFromFee[owner()] = true;\\n        _isExcludedFromFee[address(this)] = true;\\n        _isExcludedFromFee[_Marketingfund] = true;\\n        _isExcludedFromFee[_devWalletAddress] = true;\\n        _isExcludedFromFee[_Deployer] = true;\\n\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n        uniswapV2Router = _uniswapV2Router;\\n        _approve(address(this), address(uniswapV2Router), _tTotal);\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\n            .createPair(address(this), _uniswapV2Router.WETH());\\n\\n        emit Transfer(address(0), _msgSender(), _tTotal);\\n    }\\n\\n    function name() public pure returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public pure returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public pure returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public pure override returns (uint256) {\\n        return _tTotal;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return tokenFromReflection(_rOwned[account]);\\n    }\\n\\n    function transfer(address recipient, uint256 amount)\\n        public\\n        override\\n        returns (bool)\\n    {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount)\\n        public\\n        override\\n        returns (bool)\\n    {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()].sub(\\n                amount,\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    function setCooldownEnabled(bool onoff) external onlyOwner() {\\n        cooldownEnabled = onoff;\\n    }\\n\\n    function setLevelSellEnabled(bool enable) external onlyOwner {\\n        enableLevelSell = enable;\\n    }\\n\\n    function tokenFromReflection(uint256 rAmount)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        require(\\n            rAmount <= _rTotal,\\n            \\\"Amount must be less than total reflections\\\"\\n        );\\n        uint256 currentRate = _getRate();\\n        return rAmount.div(currentRate);\\n    }\\n\\n    function removeAllFee() private {\\n        if (_devTax == 0 && _summedTax == 0) return;\\n        _devTax = 0;\\n        _summedTax = 0;\\n    }\\n\\n    function restoreAllFee() private {\\n        _devTax = _buyDevTax;\\n        _marketingTax = _buyMarketingTax;\\n        _salesTax = _buySalesTax;\\n        _summedTax = _marketingTax+_salesTax;\\n    }\\n\\n     function takeBuyFee() private {\\n        _salesTax = _buySalesTax;\\n        _marketingTax = _buyMarketingTax;\\n        _devTax = _buyDevTax;\\n        _summedTax = _marketingTax+_salesTax;\\n    }\\n\\n    function takeSellFee() private {\\n        _devTax = _sellDevTax;\\n        _salesTax = _sellSalesTax;\\n        _marketingTax = _sellMarketingTax;\\n        _summedTax = _sellSalesTax+_sellMarketingTax;\\n    }\\n\\n    function levelSell(uint256 amount, address sender) private returns (uint256) {\\n        uint256 sellTax = amount.mul(_totalSellTax).div(100);\\n        _rOwned[sender] = _rOwned[sender].sub(sellTax);\\n        _rOwned[address(this)] = _rOwned[address(this)].add(sellTax);\\n\\n        uint256 tAmount = amount.sub(sellTax);\\n        uint256 prevEthBalance = address(this).balance;\\n        swapTokensForEth(sellTax);\\n        uint256 newEthBalance = address(this).balance;\\n\\n        uint256 balanceDelta = newEthBalance - prevEthBalance;\\n\\n        if (balanceDelta > 0) {\\n            sendETHForSellTax(balanceDelta);\\n        }\\n        \\n        return tAmount;\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) private {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n        \\n        if (from != owner() && to != owner()) {\\n            if (cooldownEnabled) {\\n                if (\\n                    from != address(this) &&\\n                    to != address(this) &&\\n                    from != address(uniswapV2Router) &&\\n                    to != address(uniswapV2Router)\\n                ) {\\n                    require(\\n                        _msgSender() == address(uniswapV2Router) ||\\n                            _msgSender() == uniswapV2Pair,\\n                        \\\"ERR: Uniswap only\\\"\\n                    );\\n                }\\n            }\\n            if(from != address(this)){\\n                require(amount <= _maxTxAmount);\\n            }\\n            require(!bots[from] && !bots[to] && !bots[msg.sender]);\\n\\n            if (\\n                from == uniswapV2Pair &&\\n                to != address(uniswapV2Router) &&\\n                !_isExcludedFromFee[to] &&\\n                cooldownEnabled\\n            ) {\\n                require(cooldown[to] < block.timestamp);\\n                cooldown[to] = block.timestamp + (15 seconds);\\n            }\\n              \\n            uint256 contractTokenBalance = balanceOf(address(this));\\n            \\n            if(contractTokenBalance >= _routermax)\\n            {\\n                contractTokenBalance = _routermax;\\n            }\\n\\n            bool overMinTokenBalance = contractTokenBalance >= _numOfTokensToExchangeForTeam;\\n            if (!inSwap && swapEnabled && overMinTokenBalance && from != uniswapV2Pair && from != address(uniswapV2Router)\\n            ) {\\n                // We need to swap the current tokens to ETH and send to the team wallet\\n                swapTokensForEth(contractTokenBalance);\\n                \\n                uint256 contractETHBalance = address(this).balance;\\n                if(contractETHBalance > 0) {\\n                    sendETHToFee(address(this).balance);\\n                }\\n            }\\n        }\\n\\n        bool takeFee = true;\\n\\n        if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\\n            takeFee = false;\\n        }\\n\\n        if (from != owner() && to != owner() && to != uniswapV2Pair) {\\n            require(swapEnabled, \\\"Swap disabled\\\");\\n            _tokenTransfer(from, to, amount, takeFee);\\n        } else {\\n            _tokenTransfer(from, to, amount, takeFee);\\n        }\\n\\n     \\n    }\\n\\n    function isExcluded(address account) public view returns (bool) {\\n        return _isExcludedFromFee[account];\\n    }\\n\\n    function isBlackListed(address account) public view returns (bool) {\\n        return bots[account];\\n    }\\n\\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap{\\n            // generate the uniswap pair path of token -> weth\\n            address[] memory path = new address[](2);\\n            path[0] = address(this);\\n            path[1] = uniswapV2Router.WETH();\\n\\n            _approve(address(this), address(uniswapV2Router), type(uint256).max);\\n\\n            // make the swap\\n            uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                tokenAmount,\\n                0, // accept any amount of ETH\\n                path,\\n                address(this),\\n                block.timestamp\\n            );\\n    }\\n\\n    function sendETHToFee(uint256 amount) private {\\n        _Marketingfund.transfer(amount.div(_totalBuyTax).mul(_buyMarketingTax));\\n        _devWalletAddress.transfer(amount.div(_totalBuyTax).mul(_buyDevTax));\\n        _Deployer.transfer(amount.div(_totalBuyTax).mul(_buySalesTax));\\n    }\\n\\n    function sendETHForSellTax(uint256 amount) private {\\n        _holdings.transfer(amount);\\n    }\\n\\n    function openTrading() external onlyOwner() {\\n        require(!tradingOpen, \\\"trading is already open\\\");\\n        swapEnabled = true;\\n        cooldownEnabled = false;\\n        _maxTxAmount = 20000000 * 10**9;\\n        launchBlock = block.number;\\n        tradingOpen = true;\\n        IERC20(uniswapV2Pair).approve(\\n            address(uniswapV2Router),\\n            type(uint256).max\\n        );\\n    }\\n    \\n    function setSwapEnabled(bool enabled) external onlyOwner() {\\n        swapEnabled = enabled;\\n    }\\n        \\n\\n    function manualswap() external onlyOwner() {\\n        uint256 contractBalance = balanceOf(address(this));\\n        swapTokensForEth(contractBalance);\\n    }\\n\\n    function manualsend() external onlyOwner() {\\n        uint256 contractETHBalance = address(this).balance;\\n        sendETHToFee(contractETHBalance);\\n    }\\n\\n    function setBots(address[] memory bots_) public onlyOwner() {\\n        for (uint256 i = 0; i < bots_.length; i++) {\\n            bots[bots_[i]] = true;\\n        }\\n    }\\n\\n    function setBot(address _bot) external onlyOwner() {\\n        bots[_bot] = true;\\n    }\\n\\n    function delBot(address notbot) public onlyOwner() {\\n        bots[notbot] = false;\\n    }\\n\\n    function _tokenTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bool takeFee\\n    ) private {\\n        uint256 amountToTx = amount;\\n            if (!takeFee) {\\n                removeAllFee();\\n            }\\n            else if(sender == uniswapV2Pair) {\\n                takeBuyFee();\\n            }\\n            else if(recipient == uniswapV2Pair) {\\n                takeSellFee();\\n                if (enableLevelSell) {\\n                uint256 remainder = levelSell(amount, sender);\\n                amountToTx = remainder;\\n                }\\n            }\\n            else {\\n                takeSellFee();\\n            }\\n            \\n        _transferStandard(sender, recipient, amountToTx);\\n        if (!takeFee) restoreAllFee();\\n    }\\n\\n    function _transferStandard(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tTeam\\n        ) = _getValues(tAmount);\\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\\n        _takeTeam(tTeam);\\n        _reflectFee(rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n    function _takeTeam(uint256 tTeam) private {\\n        uint256 currentRate = _getRate();\\n        uint256 rTeam = tTeam.mul(currentRate);\\n        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\\n    }\\n\\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\\n        _rTotal = _rTotal.sub(rFee);\\n        _tFeeTotal = _tFeeTotal.add(tFee);\\n    }\\n\\n    receive() external payable {}\\n\\n    function _getValues(uint256 tAmount)\\n        private\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) =\\n            _getTValues(tAmount, _devTax, _summedTax);\\n        uint256 currentRate = _getRate();\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) =\\n            _getRValues(tAmount, tFee, tTeam, currentRate);\\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\\n    }\\n\\n    function _getTValues(\\n        uint256 tAmount,\\n        uint256 taxFee,\\n        uint256 TeamFee\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 _taxFee = taxFee > 0 ? taxFee : 1;\\n        uint256 _TeamFee = TeamFee > 0 ? TeamFee : 1;\\n\\n        uint256 tFee = tAmount.mul(_taxFee).div(100);\\n        uint256 tTeam = tAmount.mul(_TeamFee).div(100);\\n        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\\n        return (tTransferAmount, tFee, tTeam);\\n    }\\n\\n    function _getRValues(\\n        uint256 tAmount,\\n        uint256 tFee,\\n        uint256 tTeam,\\n        uint256 currentRate\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 rAmount = tAmount.mul(currentRate);\\n        uint256 rFee = tFee.mul(currentRate);\\n        uint256 rTeam = tTeam.mul(currentRate);\\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\\n        return (rAmount, rTransferAmount, rFee);\\n    }\\n\\n    function _getRate() private view returns (uint256) {\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\n        return rSupply.div(tSupply);\\n    }\\n\\n    function _getCurrentSupply() private view returns (uint256, uint256) {\\n        uint256 rSupply = _rTotal;\\n        uint256 tSupply = _tTotal;\\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\\n        return (rSupply, tSupply);\\n    }\\n\\n    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {\\n        require(maxTxPercent > 0, \\\"Amount must be greater than 0\\\");\\n        _maxTxAmount = _tTotal.mul(maxTxPercent).div(10**2);\\n        emit MaxTxAmountUpdated(_maxTxAmount);\\n    }\\n    function setRouterPercent(uint256 maxRouterPercent) external onlyOwner() {\\n        require(maxRouterPercent > 0, \\\"Amount must be greater than 0\\\");\\n        _routermax = _tTotal.mul(maxRouterPercent).div(10**4);\\n    }\\n    \\n    function _setTeamFee(uint256 teamFee) external onlyOwner() {\\n        require(teamFee >= 1 && teamFee <= 25, 'teamFee should be in 1 - 25');\\n        _summedTax = teamFee;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"marketingTaxAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"devfeeAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"depAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"holdings\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_maxTxAmount\",\"type\":\"uint256\"}],\"name\":\"MaxTxAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"teamFee\",\"type\":\"uint256\"}],\"name\":\"_setTeamFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"notbot\",\"type\":\"address\"}],\"name\":\"delBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBlackListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualsend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualswap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bot\",\"type\":\"address\"}],\"name\":\"setBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"bots_\",\"type\":\"address[]\"}],\"name\":\"setBots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"onoff\",\"type\":\"bool\"}],\"name\":\"setCooldownEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setLevelSellEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxPercent\",\"type\":\"uint256\"}],\"name\":\"setMaxTxPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxRouterPercent\",\"type\":\"uint256\"}],\"name\":\"setRouterPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Empire", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000e3966cd2bcac0a0d51a12b286bf6037566ecc967000000000000000000000000761190739afb1f8dd84716f79f0e2935137576c4000000000000000000000000d84569809efdc3e6313e2a61b273c64637203c99000000000000000000000000e3966cd2bcac0a0d51a12b286bf6037566ecc967", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}