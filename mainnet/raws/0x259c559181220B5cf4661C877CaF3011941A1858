{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AmbassadorNFT.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport './token/ERC721Enumerable.sol';\\nimport './token/Base64.sol';\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\n\\ncontract AmbassadorNFT is ERC721Enumerable {\\n  using Base64 for *;\\n  using Strings for uint256;\\n\\n  struct Base {\\n    string image; // base image\\n    address collection; // Drops dToken\\n  }\\n\\n  /// @dev emit when new collection registered\\n  event CollectionRegistered(address collection, string name);\\n\\n  /// @dev emit when base gets added or updated\\n  event BaseUpdated(uint256 index, Base base);\\n\\n  /// @dev emit when base/votingWeight for ambassador being set\\n  event AmbassadorUpdated(uint256 tokenId, uint256 base, uint256 weight);\\n\\n  uint128 public constant DEFAULT_WEIGHT = 3_000 * 1e18; // 3k\\n\\n  string public constant DESCRIPTION =\\n    'The Ambassador NFT is a non-transferable token exclusively available to Drops DAO ambassadors. Each NFT provides veDOP voting power which is used in DAO governance process.';\\n\\n  bool public initialized;\\n\\n  /// @dev collection name mapped by collection address\\n  mapping(address => string) public collectionNames;\\n\\n  /// @dev array of Bases\\n  Base[] public bases;\\n\\n  /// @dev tokenId => base info\\n  /// top 128 bit = base_index\\n  /// bottom 128 bit = weight\\n  mapping(uint256 => uint256) public info;\\n\\n  /// @dev baseURI\\n  string private baseURI;\\n\\n  function initialize(string memory _baseURI) external {\\n    require(msg.sender == admin);\\n    require(!initialized);\\n    initialized = true;\\n\\n    name = 'Drops DAO Ambassadors';\\n    symbol = 'DROPSAMB';\\n\\n    baseURI = _baseURI;\\n  }\\n\\n  /// @dev register collection name\\n  /// @param collection collection address\\n  /// @param name collection name\\n  function registerCollection(address collection, string calldata name) external onlyOwner {\\n    collectionNames[collection] = name;\\n\\n    emit CollectionRegistered(collection, name);\\n  }\\n\\n  /// @dev add new base\\n  /// @param image base image\\n  /// @param collection base collection\\n  function addBase(string calldata image, address collection) external onlyOwner {\\n    require(bytes(collectionNames[collection]).length > 0, 'addBase: Invalid collection');\\n    Base memory base = Base(image, collection);\\n    emit BaseUpdated(bases.length, base);\\n    bases.push(base);\\n  }\\n\\n  /// @dev update base\\n  /// @param index base index\\n  /// @param image base image\\n  /// @param collection base collection\\n  function updateBase(\\n    uint256 index,\\n    string calldata image,\\n    address collection\\n  ) external onlyOwner {\\n    require(index < bases.length, 'updateBase: Invalid index');\\n\\n    Base storage base = bases[index];\\n    base.image = image;\\n    base.collection = collection;\\n\\n    emit BaseUpdated(index, base);\\n  }\\n\\n  /// @dev return total number of bases\\n  /// @return uint256\\n  function totalBases() external view returns (uint256) {\\n    return bases.length;\\n  }\\n\\n  /// @dev mint new NFT\\n  /// @param tokenId ambassador id\\n  /// @param to ambassador wallet\\n  /// @param base ambassador index\\n  function mintInternal(\\n    uint256 tokenId,\\n    address to,\\n    uint256 base\\n  ) internal {\\n    require(to != address(0), 'mint: Invalid to');\\n    require(base < bases.length, 'mint: Invalid base');\\n\\n    // Mint new token\\n    info[tokenId] = (base << 128) | DEFAULT_WEIGHT;\\n    _mint(to, tokenId);\\n\\n    emit AmbassadorUpdated(tokenId, base, DEFAULT_WEIGHT);\\n  }\\n\\n  /// @dev mint new NFT\\n  /// @param tokenId ambassador id\\n  /// @param to ambassador wallet\\n  /// @param base ambassador index\\n  function mint(\\n    uint256 tokenId,\\n    address to,\\n    uint256 base\\n  ) public onlyOwner {\\n    mintInternal(tokenId, to, base);\\n  }\\n\\n  /// @dev mint new NFTs\\n  /// @param tokenIds ambassador ids\\n  /// @param wallets ambassador wallets\\n  /// @param baseIndexes ambassador bases\\n  function mints(\\n    uint256[] calldata tokenIds,\\n    address[] calldata wallets,\\n    uint256[] calldata baseIndexes\\n  ) external onlyOwner {\\n    for (uint256 i = 0; i < tokenIds.length; i++) {\\n      mintInternal(tokenIds[i], wallets[i], baseIndexes[i]);\\n    }\\n  }\\n\\n  /// @dev update weight\\n  /// @param tokenId ambassador id\\n  /// @param weight ambassador weight\\n  function updateAmbWeight(uint256 tokenId, uint256 weight) external onlyOwner {\\n    require(ownerOf[tokenId] != address(0), 'updateWeight: Non-existent token');\\n\\n    uint256 base = info[tokenId] >> 128;\\n    info[tokenId] = (base << 128) | weight;\\n\\n    emit AmbassadorUpdated(tokenId, base, weight);\\n  }\\n\\n  /// @dev update base\\n  /// @param tokenId ambassador id\\n  /// @param base ambassador base\\n  function updateAmbBase(uint256 tokenId, uint256 base) external onlyOwner {\\n    require(ownerOf[tokenId] != address(0), 'updateBase: Non-existent token');\\n\\n    uint128 weight = uint128(info[tokenId]);\\n    info[tokenId] = (base << 128) | weight;\\n\\n    emit AmbassadorUpdated(tokenId, base, weight);\\n  }\\n\\n  /// @dev get ambassador\\n  /// @param tokenId ambassador id\\n  /// @return weight ambassador weight\\n  /// @return image ambassador image\\n  /// @return collection ambassador collection\\n  function getAmbassador(uint256 tokenId)\\n    public\\n    view\\n    returns (\\n      uint256 weight,\\n      string memory image,\\n      address collection\\n    )\\n  {\\n    require(ownerOf[tokenId] != address(0), 'getAmbassador: Non-existent token');\\n\\n    uint256 base = info[tokenId];\\n    weight = uint128(base);\\n    base = base >> 128;\\n    image = bases[base].image;\\n    collection = bases[base].collection;\\n  }\\n\\n  /// @dev burns FNT\\n  /// Only the owner can do this action\\n  /// @param tokenId tokenID of NFT to be burnt\\n  function burn(uint256 tokenId) external onlyOwner {\\n    _burn(tokenId);\\n  }\\n\\n  /// @dev return tokenURI per tokenId\\n  /// @return tokenURI string\\n  function tokenURI(uint256 tokenId) public view returns (string memory) {\\n    require(ownerOf[tokenId] != address(0), 'tokenURI: Non-existent token');\\n\\n    (uint256 weight, string memory image, address collection) = getAmbassador(tokenId);\\n\\n    string memory attributes = string(\\n      abi.encodePacked(\\n        '[{\\\"trait_type\\\":\\\"Collection\\\",\\\"value\\\":\\\"',\\n        collectionNames[collection],\\n        '\\\"},{\\\"display_type\\\":\\\"number\\\",\\\"trait_type\\\":\\\"veDOP\\\",\\\"value\\\":',\\n        (weight / 1e18).toString(),\\n        '}]'\\n      )\\n    );\\n\\n    return\\n      string(\\n        abi.encodePacked(\\n          'data:application/json;base64,',\\n          Base64.encode(\\n            abi.encodePacked(\\n              '{\\\"name\\\":\\\"',\\n              string(abi.encodePacked('Ambassador', ' #', tokenId.toString())),\\n              '\\\",\\\"description\\\":\\\"',\\n              DESCRIPTION,\\n              '\\\",\\\"image\\\":\\\"',\\n              string(abi.encodePacked(baseURI, image)),\\n              '\\\",\\\"attributes\\\":',\\n              attributes,\\n              '}'\\n            )\\n          )\\n        )\\n      );\\n  }\\n\\n  /// @dev check if caller is owner\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) internal virtual override onlyOwner {\\n    // one wallet cannot hold more than 1 NFT\\n    require(balanceOf[to] == 0, 'transfer: Already an ambassador');\\n    ERC721Enumerable._beforeTokenTransfer(from, to, tokenId);\\n  }\\n\\n  /// @dev See {IERC721-transferFrom}.\\n  /// clear approve or owner logic since admin will transfer NFTs without permissions from owner\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) public virtual override {\\n    // admin will transfer NFTs without approve\\n    _transfer(from, to, tokenId);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/token/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Base64 {\\n  string private constant base64stdchars =\\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n\\n  function encode(bytes memory data) internal pure returns (string memory) {\\n    if (data.length == 0) return '';\\n\\n    // load the table into memory\\n    string memory table = base64stdchars;\\n\\n    // multiply by 4/3 rounded up\\n    uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n    // add some extra buffer at the end required for the writing\\n    string memory result = new string(encodedLen + 32);\\n\\n    assembly {\\n      // set the actual output length\\n      mstore(result, encodedLen)\\n\\n      // prepare the lookup table\\n      let tablePtr := add(table, 1)\\n\\n      // input ptr\\n      let dataPtr := data\\n      let endPtr := add(dataPtr, mload(data))\\n\\n      // result ptr, jump over length\\n      let resultPtr := add(result, 32)\\n\\n      // run over the input, 3 bytes at a time\\n      for {\\n\\n      } lt(dataPtr, endPtr) {\\n\\n      } {\\n        dataPtr := add(dataPtr, 3)\\n\\n        // read 3 bytes\\n        let input := mload(dataPtr)\\n\\n        // write 4 characters\\n        mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\\n        resultPtr := add(resultPtr, 1)\\n        mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\\n        resultPtr := add(resultPtr, 1)\\n        mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F)))))\\n        resultPtr := add(resultPtr, 1)\\n        mstore(resultPtr, shl(248, mload(add(tablePtr, and(input, 0x3F)))))\\n        resultPtr := add(resultPtr, 1)\\n      }\\n\\n      // padding with '='\\n      switch mod(mload(data), 3)\\n      case 1 {\\n        mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n      }\\n      case 2 {\\n        mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/token/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n  /**\\n   * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n   * by `operator` from `from`, this function is called.\\n   *\\n   * It must return its Solidity selector to confirm the token transfer.\\n   * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n   *\\n   * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n   */\\n  function onERC721Received(\\n    address operator,\\n    address from,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external returns (bytes4);\\n}\\n\\n/// @notice Modern and gas efficient ERC-721 + ERC-20/EIP-2612-like implementation,\\n/// including the MetaData, and partially, Enumerable extensions.\\ncontract ERC721 {\\n  /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n  event Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\\n\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n  address implementation_;\\n  address admin;\\n\\n  string public name;\\n  string public symbol;\\n\\n  /*///////////////////////////////////////////////////////////////\\n                             ERC-721 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n  mapping(address => uint256) public balanceOf;\\n\\n  mapping(uint256 => address) public ownerOf;\\n\\n  mapping(uint256 => address) public getApproved;\\n\\n  mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n  /*///////////////////////////////////////////////////////////////\\n                             VIEW FUNCTION\\n    //////////////////////////////////////////////////////////////*/\\n\\n  modifier onlyOwner() {\\n    require(msg.sender == admin);\\n    _;\\n  }\\n\\n  function owner() external view returns (address) {\\n    return admin;\\n  }\\n\\n  /*///////////////////////////////////////////////////////////////\\n                              ERC-20-LIKE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n  function transfer(address to, uint256 tokenId) external {\\n    require(msg.sender == ownerOf[tokenId], \\\"NOT_OWNER\\\");\\n\\n    _transfer(msg.sender, to, tokenId);\\n  }\\n\\n  /*///////////////////////////////////////////////////////////////\\n                              ERC-721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n  function supportsInterface(bytes4 interfaceId) external pure returns (bool supported) {\\n    // supported = interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f || interfaceId == 0x2a55205a;\\n    supported = true;\\n  }\\n\\n  function approve(address spender, uint256 tokenId) external {\\n    address owner_ = ownerOf[tokenId];\\n\\n    require(msg.sender == owner_ || isApprovedForAll[owner_][msg.sender], \\\"NOT_APPROVED\\\");\\n\\n    getApproved[tokenId] = spender;\\n\\n    emit Approval(owner_, spender, tokenId);\\n  }\\n\\n  function setApprovalForAll(address operator, bool approved) external {\\n    isApprovedForAll[msg.sender][operator] = approved;\\n\\n    emit ApprovalForAll(msg.sender, operator, approved);\\n  }\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) public virtual {\\n    require(\\n      msg.sender == from || msg.sender == getApproved[tokenId] || isApprovedForAll[from][msg.sender],\\n      \\\"NOT_APPROVED\\\"\\n    );\\n\\n    _transfer(from, to, tokenId);\\n  }\\n\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external {\\n    safeTransferFrom(from, to, tokenId, \\\"\\\");\\n  }\\n\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes memory data\\n  ) public {\\n    transferFrom(from, to, tokenId);\\n\\n    if (to.code.length != 0) {\\n      try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {\\n        require(retval == IERC721Receiver.onERC721Received.selector);\\n      } catch (bytes memory reason) {\\n        if (reason.length == 0) {\\n          revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n        } else {\\n          assembly {\\n            revert(add(32, reason), mload(reason))\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /*///////////////////////////////////////////////////////////////\\n                          INTERNAL UTILS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  function _transfer(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) internal {\\n    require(ownerOf[tokenId] == from);\\n    _beforeTokenTransfer(from, to, tokenId);\\n\\n    balanceOf[from]--;\\n    balanceOf[to]++;\\n\\n    delete getApproved[tokenId];\\n\\n    ownerOf[tokenId] = to;\\n    emit Transfer(from, to, tokenId);\\n\\n    _afterTokenTransfer(from, to, tokenId);\\n  }\\n\\n  function _mint(address to, uint256 tokenId) internal {\\n    require(ownerOf[tokenId] == address(0), \\\"ALREADY_MINTED\\\");\\n    _beforeTokenTransfer(address(0), to, tokenId);\\n\\n    // This is safe because the sum of all user\\n    // balances can't exceed type(uint256).max!\\n    unchecked {\\n      balanceOf[to]++;\\n    }\\n\\n    ownerOf[tokenId] = to;\\n\\n    emit Transfer(address(0), to, tokenId);\\n\\n    _afterTokenTransfer(address(0), to, tokenId);\\n  }\\n\\n  function _burn(uint256 tokenId) internal {\\n    address owner_ = ownerOf[tokenId];\\n\\n    require(owner_ != address(0), \\\"NOT_MINTED\\\");\\n    _beforeTokenTransfer(owner_, address(0), tokenId);\\n\\n    balanceOf[owner_]--;\\n\\n    delete ownerOf[tokenId];\\n\\n    emit Transfer(owner_, address(0), tokenId);\\n\\n    _afterTokenTransfer(owner_, address(0), tokenId);\\n  }\\n\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) internal virtual {}\\n\\n  function _afterTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/token/ERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC721.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n */\\nabstract contract ERC721Enumerable is ERC721 {\\n  // Mapping from owner to list of owned token IDs\\n  mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\\n\\n  // Mapping from token ID to index of the owner tokens list\\n  mapping(uint256 => uint256) private _ownedTokensIndex;\\n\\n  /**\\n   * @dev See {IERC721Enumerable-totalSupply}.\\n   */\\n  uint256 public totalSupply;\\n\\n  /**\\n   * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n   */\\n  function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\\n    require(index < balanceOf[owner], \\\"ERC721Enumerable: owner index out of bounds\\\");\\n    return _ownedTokens[owner][index];\\n  }\\n\\n  /**\\n   * @dev Hook that is called before any token transfer. This includes minting\\n   * and burning.\\n   *\\n   * Calling conditions:\\n   *\\n   * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n   * transferred to `to`.\\n   * - When `from` is zero, `tokenId` will be minted for `to`.\\n   * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   *\\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n   */\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) internal virtual override {\\n    super._beforeTokenTransfer(from, to, tokenId);\\n\\n    if (from == address(0)) {\\n      totalSupply++;\\n    } else if (from != to) {\\n      _removeTokenFromOwnerEnumeration(from, tokenId);\\n    }\\n    if (to == address(0)) {\\n      totalSupply--;\\n    } else if (to != from) {\\n      _addTokenToOwnerEnumeration(to, tokenId);\\n    }\\n  }\\n\\n  /**\\n   * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n   * @param to address representing the new owner of the given token ID\\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n   */\\n  function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n    uint256 length = balanceOf[to];\\n    _ownedTokens[to][length] = tokenId;\\n    _ownedTokensIndex[tokenId] = length;\\n  }\\n\\n  /**\\n   * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n   * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n   * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n   * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n   * @param from address representing the previous owner of the given token ID\\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n   */\\n  function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n    // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n    // then delete the last slot (swap and pop).\\n\\n    uint256 lastTokenIndex = balanceOf[from] - 1;\\n    uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n    // When the token to delete is the last token, the swap operation is unnecessary\\n    if (tokenIndex != lastTokenIndex) {\\n      uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n      _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n      _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n    }\\n\\n    // This also deletes the contents at the last position of the array\\n    delete _ownedTokensIndex[tokenId];\\n    delete _ownedTokens[from][lastTokenIndex];\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"base\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"AmbassadorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"image\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct AmbassadorNFT.Base\",\"name\":\"base\",\"type\":\"tuple\"}],\"name\":\"BaseUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"CollectionRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_WEIGHT\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DESCRIPTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"image\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"addBase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bases\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"image\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"collectionNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getAmbassador\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"image\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"info\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"base\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"baseIndexes\",\"type\":\"uint256[]\"}],\"name\":\"mints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"registerCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"supported\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"base\",\"type\":\"uint256\"}],\"name\":\"updateAmbBase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"updateAmbWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"image\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"updateBase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AmbassadorNFT", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}