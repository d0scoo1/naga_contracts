{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/multisender/MultiSender.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\nimport \\\"./Storage.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\nstruct ProductItem {\\r\\n    bytes32 i18nId;\\r\\n    bytes32 appId;\\r\\n    uint256 price;\\r\\n    uint128 payType;\\r\\n    uint128 off;\\r\\n    uint256 duration;\\r\\n    uint256 createdAt;\\r\\n    address createdBy;\\r\\n    address updatedBy;\\r\\n}\\r\\n\\r\\nstruct VIPStats {\\r\\n    uint256 startedAt;\\r\\n    uint256 expiredAt;\\r\\n}\\r\\n\\r\\ninterface IFinance {\\r\\n    function queryProduct(bytes32 id) external returns (ProductItem memory);\\r\\n\\r\\n    function checkout(\\r\\n        bytes32 orderid,\\r\\n        address payer,\\r\\n        bytes32 skuId,\\r\\n        address inviter\\r\\n    ) external payable;\\r\\n}\\r\\n\\r\\ninterface IVIP {\\r\\n    function queryVIP(bytes32 appId, address target)\\r\\n        external\\r\\n        view\\r\\n        returns (VIPStats memory vipStats);\\r\\n}\\r\\n\\r\\ncontract MultiSender is Ownable {\\r\\n    event MultisendTokenOK(address indexed _from, address indexed token);\\r\\n    event WithdrawSuccessed(address indexed _from);\\r\\n    event WithdrawERC20Successed(address indexed _from, address indexed token);\\r\\n\\r\\n    address public checkoutContract;\\r\\n    address public vipContract;\\r\\n\\r\\n    function setCheckoutContract(address _checkout) public onlyOwner {\\r\\n        checkoutContract = _checkout;\\r\\n    }\\r\\n\\r\\n    function setVipContract(address _vip) public onlyOwner {\\r\\n        vipContract = _vip;\\r\\n    }\\r\\n\\r\\n    constructor(address _checkout, address _vip) {\\r\\n        checkoutContract = _checkout;\\r\\n        vipContract = _vip;\\r\\n    }\\r\\n\\r\\n    function multisendToken(\\r\\n        address token,\\r\\n        address[] memory _contributors,\\r\\n        uint256[] memory _balances,\\r\\n        address inviter,\\r\\n        bytes32 orderid,\\r\\n        bytes32 appId\\r\\n    ) public payable {\\r\\n        //solhint-disable reason-string\\r\\n        require(\\r\\n            _contributors.length <= 100,\\r\\n            \\\"MultiSenderV1: _contributors length must be less than or equal to 100\\\"\\r\\n        );\\r\\n        //solhint-disable reason-string\\r\\n        require(\\r\\n            _contributors.length == _balances.length,\\r\\n            \\\"MultiSenderV1: _contributors length and _balances length must be the same\\\"\\r\\n        );\\r\\n\\r\\n        uint256 total = 0;\\r\\n        for (uint256 i = 0; i < _balances.length; i++) {\\r\\n            total = total + _balances[i];\\r\\n        }\\r\\n        uint256 minMainCoin = total;\\r\\n\\r\\n        if (address(0) != token) {\\r\\n            minMainCoin = 0;\\r\\n        }\\r\\n        IVIP vip = IVIP(vipContract);\\r\\n\\r\\n        VIPStats memory vipInfo = vip.queryVIP(appId, msg.sender);\\r\\n        // solhint-disable not-rely-on-time\\r\\n        if (vipInfo.expiredAt < block.timestamp) {\\r\\n            // Non-VIP need to pay\\r\\n            IFinance finance = IFinance(checkoutContract);\\r\\n            bytes32 skuId = querySkuId(_contributors.length);\\r\\n\\r\\n            require(\\r\\n                msg.value > minMainCoin,\\r\\n                \\\"MultiSenderV1: msg.value should greater than the amount of tokens\\\"\\r\\n            );\\r\\n\\r\\n            // Main Coin multisend: Pay the software fee, msg.value minus the number of tokens to be sent\\r\\n            // ERC20 token multisend: Pay the software fee\\r\\n            // uint256 v = uint256(msg.value) - minMainCoin;\\r\\n            uint256 v = msg.value - minMainCoin;\\r\\n\\r\\n            finance.checkout{value: v * 1 wei}(\\r\\n                orderid,\\r\\n                msg.sender,\\r\\n                skuId,\\r\\n                inviter\\r\\n            );\\r\\n        } else {\\r\\n            //   VIP send for free\\r\\n            if (address(0) == token) {\\r\\n                require(\\r\\n                    msg.value == total,\\r\\n                    \\\"MultiSenderV1: msg.value should be equal to the amount of tokens you want to send without paying software fees\\\"\\r\\n                );\\r\\n            } else {\\r\\n                require(msg.value == 0, \\\"MultiSenderV1: msg.value should be 0\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (address(0) == token) {\\r\\n            //solhint-disable reason-string\\r\\n            require(\\r\\n                msg.value >= total,\\r\\n                \\\"MultiSenderV1: insufficient MainCoin balance\\\"\\r\\n            );\\r\\n            // Main Coin multisend\\r\\n            executeNativeTokenTransfer(_contributors, _balances);\\r\\n        } else {\\r\\n            IERC20 eRC20Token = IERC20(token);\\r\\n            require(\\r\\n                eRC20Token.balanceOf(msg.sender) >= total,\\r\\n                \\\"MultiSenderV1: insufficient ERC20Coin balance\\\"\\r\\n            );\\r\\n            //solhint-disable reason-string\\r\\n            require(\\r\\n                eRC20Token.allowance(msg.sender, address(this)) >= total,\\r\\n                \\\"MultiSenderV1: insufficient allowance\\\"\\r\\n            );\\r\\n            // ERC20 token multisend\\r\\n            executeERC20Transfer(eRC20Token, _contributors, _balances);\\r\\n        }\\r\\n\\r\\n        //  event MultisendTokenOK\\r\\n        emit MultisendTokenOK(msg.sender, token);\\r\\n    }\\r\\n\\r\\n    function executeNativeTokenTransfer(\\r\\n        address[] memory receivers,\\r\\n        uint256[] memory _balances\\r\\n    ) internal {\\r\\n        for (uint256 i = 0; i < receivers.length; i++) {\\r\\n            address payable recipient = payable(address(receivers[i]));\\r\\n            // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n            (bool success, ) = recipient.call{value: _balances[i]}(\\r\\n                \\\"0x506f7765726564206279206269756269752e746f6f6c73000000000000000000\\\"\\r\\n            );\\r\\n            require(\\r\\n                success,\\r\\n                \\\"Address: unable to send value, recipient may have reverted\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function executeERC20Transfer(\\r\\n        IERC20 eRC20Token,\\r\\n        address[] memory receivers,\\r\\n        uint256[] memory _balances\\r\\n    ) internal {\\r\\n        for (uint256 i = 0; i < receivers.length; i++) {\\r\\n            eRC20Token.transferFrom(msg.sender, receivers[i], _balances[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function querySkuId(uint256 len) public pure returns (bytes32 skuId) {\\r\\n        if (len <= 20) {\\r\\n            return\\r\\n                0x6d756c746973656e6465722d6e6f746f76657232302d7070702d306400000000;\\r\\n        } else {\\r\\n            return\\r\\n                0x6d756c746973656e6465722d6f76657232302d7070702d306400000000000000;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdraw() public onlyOwner {\\r\\n        require(address(this).balance > 0, \\\"Finance: insufficient balance\\\");\\r\\n        address payable recipient = payable(address(owner()));\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{value: address(this).balance}(\\\"\\\");\\r\\n        require(\\r\\n            success,\\r\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\r\\n        );\\r\\n\\r\\n        emit WithdrawSuccessed(address(owner()));\\r\\n    }\\r\\n\\r\\n    function withdrawERC20(address token) public onlyOwner {\\r\\n        IERC20 erc20Token = IERC20(token);\\r\\n        require(\\r\\n            erc20Token.balanceOf(address(this)) > 0,\\r\\n            \\\"Address: insufficient balance\\\"\\r\\n        );\\r\\n        erc20Token.transfer(\\r\\n            address(owner()),\\r\\n            erc20Token.balanceOf(address(this))\\r\\n        );\\r\\n        emit WithdrawERC20Successed(address(owner()), token);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/multisender/Storage.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ncontract Storage {\\r\\n    struct VIPStats {\\r\\n        uint256 startedAt;\\r\\n        uint256 expiredAt;\\r\\n    }\\r\\n    mapping(address => VIPStats) internal vipMap;\\r\\n    address public checkoutContract;\\r\\n    address[] internal vips;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/multisender/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_checkout\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vip\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"MultisendTokenOK\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"WithdrawERC20Successed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"WithdrawSuccessed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"checkoutContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_contributors\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_balances\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"inviter\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"orderid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appId\",\"type\":\"bytes32\"}],\"name\":\"multisendToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"len\",\"type\":\"uint256\"}],\"name\":\"querySkuId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"skuId\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_checkout\",\"type\":\"address\"}],\"name\":\"setCheckoutContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vip\",\"type\":\"address\"}],\"name\":\"setVipContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vipContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MultiSender", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000009787a66464c3743cfbded8b2cb10598f6dec47c1000000000000000000000000c65a81984cfe0aecaa199add9653e3fd286c95d2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}