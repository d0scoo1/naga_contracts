{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/external/@openzeppelin/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/utils/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/interfaces/yearn/IYearnTokenVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.11;\\n\\ninterface IYearnTokenVault {\\n    function balanceOf(address user) external view returns (uint256);\\n\\n    function pricePerShare() external view returns (uint256);\\n\\n    function deposit(uint256 lp, address user) external;\\n\\n    function withdraw(\\n        uint256 amount,\\n        address user,\\n        uint256 slippage\\n    ) external;\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBaseStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport \\\"./ISwapData.sol\\\";\\n\\ninterface IBaseStrategy {\\n    function underlying() external view returns (IERC20);\\n\\n    function getStrategyBalance() external view returns (uint128);\\n\\n    function getStrategyUnderlyingWithRewards() external view returns(uint128);\\n\\n    function process(uint256[] calldata, bool, SwapData[] calldata) external;\\n\\n    function processReallocation(uint256[] calldata, ProcessReallocationData calldata) external returns(uint128);\\n\\n    function processDeposit(uint256[] calldata) external;\\n\\n    function fastWithdraw(uint128, uint256[] calldata, SwapData[] calldata) external returns(uint128);\\n\\n    function claimRewards(SwapData[] calldata) external;\\n\\n    function emergencyWithdraw(address recipient, uint256[] calldata data) external;\\n\\n    function initialize() external;\\n\\n    function disable() external;\\n}\\n\\nstruct ProcessReallocationData {\\n    uint128 sharesToWithdraw;\\n    uint128 optimizedShares;\\n    uint128 optimizedWithdrawnAmount;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwapData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\n/**\\r\\n * @notice Strict holding information how to swap the asset\\r\\n * @member slippage minumum output amount\\r\\n * @member path swap path, first byte represents an action (e.g. Uniswap V2 custom swap), rest is swap specific path\\r\\n */\\r\\nstruct SwapData {\\r\\n    uint256 slippage; // min amount out\\r\\n    bytes path; // 1st byte is action, then path \\r\\n}\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../external/@openzeppelin/utils/SafeCast.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @notice A collection of custom math ustils used throughout the system\\r\\n */\\r\\nlibrary Math {\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a > b ? b : a;\\r\\n    }\\r\\n\\r\\n    function getProportion128(uint256 mul1, uint256 mul2, uint256 div) internal pure returns (uint128) {\\r\\n        return SafeCast.toUint128(((mul1 * mul2) / div));\\r\\n    }\\r\\n\\r\\n    function getProportion128Unchecked(uint256 mul1, uint256 mul2, uint256 div) internal pure returns (uint128) {\\r\\n        unchecked {\\r\\n            return uint128((mul1 * mul2) / div);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Max/128Bit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.11;\\n\\n/** @notice Handle setting zero value in a storage word as uint128 max value.\\n  *\\n  *  @dev\\n  *  The purpose of this is to avoid resetting a storage word to the zero value; \\n  *  the gas cost of re-initializing the value is the same as setting the word originally.\\n  *  so instead, if word is to be set to zero, we set it to uint128 max.\\n  *\\n  *   - anytime a word is loaded from storage: call \\\"get\\\"\\n  *   - anytime a word is written to storage: call \\\"set\\\"\\n  *   - common operations on uints are also bundled here.\\n  *\\n  * NOTE: This library should ONLY be used when reading or writing *directly* from storage.\\n */\\nlibrary Max128Bit {\\n    uint128 internal constant ZERO = type(uint128).max;\\n\\n    function get(uint128 a) internal pure returns(uint128) {\\n        return (a == ZERO) ? 0 : a;\\n    }\\n\\n    function set(uint128 a) internal pure returns(uint128){\\n        return (a == 0) ? ZERO : a;\\n    }\\n\\n    function add(uint128 a, uint128 b) internal pure returns(uint128 c){\\n        a = get(a);\\n        c = set(a + b);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/shared/BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\nimport \\\"../interfaces/ISwapData.sol\\\";\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\n/// @notice Strategy struct for all strategies\\r\\nstruct Strategy {\\r\\n    uint128 totalShares;\\r\\n\\r\\n    /// @notice Denotes strategy completed index\\r\\n    uint24 index;\\r\\n\\r\\n    /// @notice Denotes whether strategy is removed\\r\\n    /// @dev after removing this value can never change, hence strategy cannot be added back again\\r\\n    bool isRemoved;\\r\\n\\r\\n    /// @notice Pending geposit amount and pending shares withdrawn by all users for next index \\r\\n    Pending pendingUser;\\r\\n\\r\\n    /// @notice Used if strategies \\\"dohardwork\\\" hasn't been executed yet in the current index\\r\\n    Pending pendingUserNext;\\r\\n\\r\\n    /// @dev Usually a temp variable when compounding\\r\\n    mapping(address => uint256) pendingRewards;\\r\\n\\r\\n    /// @dev Usually a temp variable when compounding\\r\\n    uint128 pendingDepositReward;\\r\\n\\r\\n    /// @notice Amount of lp tokens the strategy holds, NOTE: not all strategies use it\\r\\n    uint256 lpTokens;\\r\\n\\r\\n    // ----- REALLOCATION VARIABLES -----\\r\\n\\r\\n    bool isInDepositPhase;\\r\\n\\r\\n    /// @notice Used to store amount of optimized shares, so they can be substracted at the end\\r\\n    /// @dev Only for temporary use, should be reset to 0 in same transaction\\r\\n    uint128 optimizedSharesWithdrawn;\\r\\n\\r\\n    /// @dev Underlying amount pending to be deposited from other strategies at reallocation \\r\\n    /// @dev resets after the strategy reallocation DHW is finished\\r\\n    uint128 pendingReallocateDeposit;\\r\\n\\r\\n    /// @notice Stores amount of optimized underlying amount when reallocating\\r\\n    /// @dev resets after the strategy reallocation DHW is finished\\r\\n    /// @dev This is \\\"virtual\\\" amount that was matched between this strategy and others when reallocating\\r\\n    uint128 pendingReallocateOptimizedDeposit;\\r\\n\\r\\n    // ------------------------------------\\r\\n\\r\\n    /// @notice Total underlying amoung at index\\r\\n    mapping(uint256 => TotalUnderlying) totalUnderlying;\\r\\n\\r\\n    /// @notice Batches stored after each DHW with index as a key\\r\\n    /// @dev Holds information for vauls to redeem newly gained shares and withdrawn amounts belonging to users\\r\\n    mapping(uint256 => Batch) batches;\\r\\n\\r\\n    /// @notice Batches stored after each DHW reallocating (if strategy was set to reallocate)\\r\\n    /// @dev Holds information for vauls to redeem newly gained shares and withdrawn shares to complete reallocation\\r\\n    mapping(uint256 => BatchReallocation) reallocationBatches;\\r\\n\\r\\n    /// @notice Vaults holding this strategy shares\\r\\n    mapping(address => Vault) vaults;\\r\\n\\r\\n    /// @notice Future proof storage\\r\\n    mapping(bytes32 => AdditionalStorage) additionalStorage;\\r\\n\\r\\n    /// @dev Make sure to reset it to 0 after emergency withdrawal\\r\\n    uint256 emergencyPending;\\r\\n}\\r\\n\\r\\n/// @notice Unprocessed deposit underlying amount and strategy share amount from users\\r\\nstruct Pending {\\r\\n    uint128 deposit;\\r\\n    uint128 sharesToWithdraw;\\r\\n}\\r\\n\\r\\n/// @notice Struct storing total underlying balance of a strategy for an index, along with total shares at same index\\r\\nstruct TotalUnderlying {\\r\\n    uint128 amount;\\r\\n    uint128 totalShares;\\r\\n}\\r\\n\\r\\n/// @notice Stored after executing DHW for each index.\\r\\n/// @dev This is used for vaults to redeem their deposit.\\r\\nstruct Batch {\\r\\n    /// @notice total underlying deposited in index\\r\\n    uint128 deposited;\\r\\n    uint128 depositedReceived;\\r\\n    uint128 depositedSharesReceived;\\r\\n    uint128 withdrawnShares;\\r\\n    uint128 withdrawnReceived;\\r\\n}\\r\\n\\r\\n/// @notice Stored after executing reallocation DHW each index.\\r\\nstruct BatchReallocation {\\r\\n    /// @notice Deposited amount received from reallocation\\r\\n    uint128 depositedReallocation;\\r\\n\\r\\n    /// @notice Received shares from reallocation\\r\\n    uint128 depositedReallocationSharesReceived;\\r\\n\\r\\n    /// @notice Used to know how much tokens was received for reallocating\\r\\n    uint128 withdrawnReallocationReceived;\\r\\n\\r\\n    /// @notice Amount of shares to withdraw for reallocation\\r\\n    uint128 withdrawnReallocationShares;\\r\\n}\\r\\n\\r\\n/// @notice VaultBatches could be refactored so we only have 2 structs current and next (see how Pending is working)\\r\\nstruct Vault {\\r\\n    uint128 shares;\\r\\n\\r\\n    /// @notice Withdrawn amount as part of the reallocation\\r\\n    uint128 withdrawnReallocationShares;\\r\\n\\r\\n    /// @notice Index to action\\r\\n    mapping(uint256 => VaultBatch) vaultBatches;\\r\\n}\\r\\n\\r\\n/// @notice Stores deposited and withdrawn shares by the vault\\r\\nstruct VaultBatch {\\r\\n    /// @notice Vault index to deposited amount mapping\\r\\n    uint128 deposited;\\r\\n\\r\\n    /// @notice Vault index to withdrawn user shares mapping\\r\\n    uint128 withdrawnShares;\\r\\n}\\r\\n\\r\\n/// @notice Used for reallocation calldata\\r\\nstruct VaultData {\\r\\n    address vault;\\r\\n    uint8 strategiesCount;\\r\\n    uint256 strategiesBitwise;\\r\\n    uint256 newProportions;\\r\\n}\\r\\n\\r\\n/// @notice Calldata when executing reallocatin DHW\\r\\n/// @notice Used in the withdraw part of the reallocation DHW\\r\\nstruct ReallocationWithdrawData {\\r\\n    uint256[][] reallocationTable;\\r\\n    StratUnderlyingSlippage[] priceSlippages;\\r\\n    RewardSlippages[] rewardSlippages;\\r\\n    uint256[] stratIndexes;\\r\\n    uint256[][] slippages;\\r\\n}\\r\\n\\r\\n/// @notice Calldata when executing reallocatin DHW\\r\\n/// @notice Used in the deposit part of the reallocation DHW\\r\\nstruct ReallocationData {\\r\\n    uint256[] stratIndexes;\\r\\n    uint256[][] slippages;\\r\\n}\\r\\n\\r\\n/// @notice In case some adapters need extra storage\\r\\nstruct AdditionalStorage {\\r\\n    uint256 value;\\r\\n    address addressValue;\\r\\n    uint96 value96;\\r\\n}\\r\\n\\r\\n/// @notice Strategy total underlying slippage, to verify validity of the strategy state\\r\\nstruct StratUnderlyingSlippage {\\r\\n    uint128 min;\\r\\n    uint128 max;\\r\\n}\\r\\n\\r\\n/// @notice Containig information if and how to swap strategy rewards at the DHW\\r\\n/// @dev Passed in by the do-hard-worker\\r\\nstruct RewardSlippages {\\r\\n    bool doClaim;\\r\\n    SwapData[] swapData;\\r\\n}\\r\\n\\r\\n/// @notice Helper struct to compare strategy share between eachother\\r\\n/// @dev Used for reallocation optimization of shares (strategy matching deposits and withdrawals between eachother when reallocating)\\r\\nstruct PriceData {\\r\\n    uint128 totalValue;\\r\\n    uint128 totalShares;\\r\\n}\\r\\n\\r\\n/// @notice Strategy reallocation values after reallocation optimization of shares was calculated \\r\\nstruct ReallocationShares {\\r\\n    uint128[] optimizedWithdraws;\\r\\n    uint128[] optimizedShares;\\r\\n    uint128[] totalSharesWithdrawn;\\r\\n}\\r\\n\\r\\n/// @notice Shared storage for multiple strategies\\r\\n/// @dev This is used when strategies are part of the same proticil (e.g. Curve 3pool)\\r\\nstruct StrategiesShared {\\r\\n    uint184 value;\\r\\n    uint32 lastClaimBlock;\\r\\n    uint32 lastUpdateBlock;\\r\\n    uint8 stratsCount;\\r\\n    mapping(uint256 => address) stratAddresses;\\r\\n    mapping(bytes32 => uint256) bytesValues;\\r\\n}\\r\\n\\r\\n/// @notice Base storage shared betweek Spool contract and Strategies\\r\\n/// @dev this way we can use same values when performing delegate call\\r\\n/// to strategy implementations from the Spool contract\\r\\nabstract contract BaseStorage {\\r\\n    // ----- DHW VARIABLES -----\\r\\n\\r\\n    /// @notice Force while DHW (all strategies) to be executed in only one transaction\\r\\n    /// @dev This is enforced to increase the gas efficiency of the system\\r\\n    /// Can be removed by the DAO if gas gost of the strategies goes over the block limit\\r\\n    bool internal forceOneTxDoHardWork;\\r\\n\\r\\n    /// @notice Global index of the system\\r\\n    /// @dev Insures the correct strategy DHW execution.\\r\\n    /// Every strategy in the system must be equal or one less than global index value\\r\\n    /// Global index increments by 1 on every do-hard-work\\r\\n    uint24 public globalIndex;\\r\\n\\r\\n    /// @notice number of strategies unprocessed (by the do-hard-work) in the current index to be completed\\r\\n    uint8 internal doHardWorksLeft;\\r\\n\\r\\n    // ----- REALLOCATION VARIABLES -----\\r\\n\\r\\n    /// @notice Used for offchain execution to get the new reallocation table.\\r\\n    bool internal logReallocationTable;\\r\\n\\r\\n    /// @notice number of withdrawal strategies unprocessed (by the do-hard-work) in the current index\\r\\n    /// @dev only used when reallocating\\r\\n    /// after it reaches 0, deposit phase of the reallocation can begin\\r\\n    uint8 public withdrawalDoHardWorksLeft;\\r\\n\\r\\n    /// @notice Index at which next reallocation is set\\r\\n    uint24 public reallocationIndex;\\r\\n\\r\\n    /// @notice 2D table hash containing information of how strategies should be reallocated between eachother\\r\\n    /// @dev Created when allocation provider sets reallocation for the vaults\\r\\n    /// This table is stored as a hash in the system and verified on reallocation DHW\\r\\n    /// Resets to 0 after reallocation DHW is completed\\r\\n    bytes32 internal reallocationTableHash;\\r\\n\\r\\n    /// @notice Hash of all the strategies array in the system at the time when reallocation was set for index\\r\\n    /// @dev this array is used for the whole reallocation period even if a strategy gets exploited when reallocating.\\r\\n    /// This way we can remove the strategy from the system and not breaking the flow of the reallocaton\\r\\n    /// Resets when DHW is completed\\r\\n    bytes32 internal reallocationStrategiesHash;\\r\\n\\r\\n    // -----------------------------------\\r\\n\\r\\n    /// @notice Denoting if an address is the do-hard-worker\\r\\n    mapping(address => bool) public isDoHardWorker;\\r\\n\\r\\n    /// @notice Denoting if an address is the allocation provider\\r\\n    mapping(address => bool) public isAllocationProvider;\\r\\n\\r\\n    /// @notice Strategies shared storage\\r\\n    /// @dev used as a helper storage to save common inoramation\\r\\n    mapping(bytes32 => StrategiesShared) internal strategiesShared;\\r\\n\\r\\n    /// @notice Mapping of strategy implementation address to strategy system values\\r\\n    mapping(address => Strategy) public strategies;\\r\\n\\r\\n    /// @notice Flag showing if disable was skipped when a strategy has been removed\\r\\n    /// @dev If true disable can still be run \\r\\n    mapping(address => bool) internal _skippedDisable;\\r\\n\\r\\n    /// @notice Flag showing if after removing a strategy emergency withdraw can still be executed\\r\\n    /// @dev If true emergency withdraw can still be executed\\r\\n    mapping(address => bool) internal _awaitingEmergencyWithdraw;\\r\\n}\"\r\n    },\r\n    \"contracts/shared/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\n/// @title Common Spool contracts constants\\r\\nabstract contract BaseConstants {\\r\\n    /// @dev 2 digits precision\\r\\n    uint256 internal constant FULL_PERCENT = 100_00;\\r\\n\\r\\n    /// @dev Accuracy when doing shares arithmetics\\r\\n    uint256 internal constant ACCURACY = 10**30;\\r\\n}\\r\\n\\r\\n/// @title Contains USDC token related values\\r\\nabstract contract USDC {\\r\\n    /// @notice USDC token contract address\\r\\n    IERC20 internal constant USDC_ADDRESS = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\\r\\n}\"\r\n    },\r\n    \"contracts/strategies/BaseStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../interfaces/IBaseStrategy.sol\\\";\\r\\nimport \\\"../shared/BaseStorage.sol\\\";\\r\\nimport \\\"../shared/Constants.sol\\\";\\r\\n\\r\\nimport \\\"../external/@openzeppelin/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport \\\"../libraries/Math.sol\\\";\\r\\nimport \\\"../libraries/Max/128Bit.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice Implementation of the {IBaseStrategy} interface.\\r\\n *\\r\\n * @dev\\r\\n * This implementation of the {IBaseStrategy} is meant to operate\\r\\n * on single-collateral strategies and uses a delta system to calculate\\r\\n * whether a withdrawal or deposit needs to be performed for a particular\\r\\n * strategy.\\r\\n */\\r\\nabstract contract BaseStrategy is IBaseStrategy, BaseStorage, BaseConstants {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using Max128Bit for uint128;\\r\\n\\r\\n    /* ========== CONSTANTS ========== */\\r\\n\\r\\n    /// @notice minimum shares size to avoid loss of share due to computation precision\\r\\n    uint128 private constant MIN_SHARES = 10**8;\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    /// @notice The total slippage slots the strategy supports, used for validation of provided slippage\\r\\n    uint256 internal immutable rewardSlippageSlots;\\r\\n\\r\\n    /// @notice Slots for processing\\r\\n    uint256 internal immutable processSlippageSlots;\\r\\n\\r\\n    /// @notice Slots for reallocation\\r\\n    uint256 internal immutable reallocationSlippageSlots;\\r\\n\\r\\n    /// @notice Slots for deposit\\r\\n    uint256 internal immutable depositSlippageSlots;\\r\\n\\r\\n    /** \\r\\n     * @notice do force claim of rewards.\\r\\n     *\\r\\n     * @dev\\r\\n     * Some strategies auto claim on deposit/withdraw,\\r\\n     * so execute the claim actions to store the reward amounts.\\r\\n     */\\r\\n    bool internal immutable forceClaim;\\r\\n\\r\\n    /// @notice flag to force balance validation before running process strategy\\r\\n    /// @dev this is done so noone can manipulate the strategies before we interact with them and cause harm to the system\\r\\n    bool internal immutable doValidateBalance;\\r\\n\\r\\n    /// @notice The self address, set at initialization to allow proper share accounting\\r\\n    address internal immutable self;\\r\\n\\r\\n    /// @notice The underlying asset of the strategy\\r\\n    IERC20 public immutable override underlying;\\r\\n\\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes the base strategy values.\\r\\n     *\\r\\n     * @dev\\r\\n     * It performs certain pre-conditional validations to ensure the contract\\r\\n     * has been initialized properly, such as that the address argument of the\\r\\n     * underlying asset is valid.\\r\\n     *\\r\\n     * Slippage slots for certain strategies may be zero if there is no compounding\\r\\n     * work to be done.\\r\\n     * \\r\\n     * @param _underlying token used for deposits\\r\\n     * @param _rewardSlippageSlots slots for rewards\\r\\n     * @param _processSlippageSlots slots for processing\\r\\n     * @param _reallocationSlippageSlots slots for reallocation\\r\\n     * @param _depositSlippageSlots slots for deposits\\r\\n     * @param _forceClaim force claim of rewards\\r\\n     * @param _doValidateBalance force balance validation\\r\\n     */\\r\\n    constructor(\\r\\n        IERC20  _underlying,\\r\\n        uint256 _rewardSlippageSlots,\\r\\n        uint256 _processSlippageSlots,\\r\\n        uint256 _reallocationSlippageSlots,\\r\\n        uint256 _depositSlippageSlots,\\r\\n        bool _forceClaim,\\r\\n        bool _doValidateBalance\\r\\n    ) {\\r\\n        require(\\r\\n            _underlying != IERC20(address(0)),\\r\\n            \\\"BaseStrategy::constructor: Underlying address cannot be 0\\\"\\r\\n        );\\r\\n\\r\\n        self = address(this);\\r\\n        underlying = _underlying;\\r\\n        rewardSlippageSlots = _rewardSlippageSlots;\\r\\n        processSlippageSlots = _processSlippageSlots;\\r\\n        reallocationSlippageSlots = _reallocationSlippageSlots;\\r\\n        depositSlippageSlots = _depositSlippageSlots;\\r\\n        forceClaim = _forceClaim;\\r\\n        doValidateBalance = _doValidateBalance;\\r\\n    }\\r\\n\\r\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Process the latest pending action of the strategy\\r\\n     *\\r\\n     * @dev\\r\\n     * it yields amount of funds processed as well as the reward buffer of the strategy.\\r\\n     * The function will auto-compound rewards if requested and supported.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the slippages provided must be valid in length\\r\\n     * - if the redeposit flag is set to true, the strategy must support\\r\\n     *   compounding of rewards\\r\\n     *\\r\\n     * @param slippages slippages to process\\r\\n     * @param redeposit if redepositing is to occur\\r\\n     * @param swapData swap data for processing\\r\\n     */\\r\\n    function process(uint256[] calldata slippages, bool redeposit, SwapData[] calldata swapData) external override\\r\\n    {\\r\\n        slippages = _validateStrategyBalance(slippages);\\r\\n\\r\\n        if (forceClaim || redeposit) {\\r\\n            _validateRewardsSlippage(swapData);\\r\\n            _processRewards(swapData);\\r\\n        }\\r\\n\\r\\n        if (processSlippageSlots != 0)\\r\\n            _validateProcessSlippage(slippages);\\r\\n        \\r\\n        _process(slippages, 0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Process first part of the reallocation DHW\\r\\n     * @dev Withdraws for reallocation, depositn and withdraww for a user\\r\\n     *\\r\\n     * @param slippages Parameters to apply when performing a deposit or a withdraw\\r\\n     * @param processReallocationData Data containing amuont of optimized and not optimized shares to withdraw\\r\\n     * @return withdrawnReallocationReceived actual amount recieveed from peforming withdraw\\r\\n     */\\r\\n    function processReallocation(uint256[] calldata slippages, ProcessReallocationData calldata processReallocationData) external override returns(uint128)\\r\\n    {   \\r\\n        slippages = _validateStrategyBalance(slippages);\\r\\n\\r\\n        if (reallocationSlippageSlots != 0)\\r\\n            _validateReallocationSlippage(slippages);\\r\\n\\r\\n        _process(slippages, processReallocationData.sharesToWithdraw);\\r\\n\\r\\n        uint128 withdrawnReallocationReceived = _updateReallocationWithdraw(processReallocationData);\\r\\n\\r\\n        return withdrawnReallocationReceived;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Update reallocation batch storage for index after withdrawing reallocated shares\\r\\n     * @param processReallocationData Data containing amount of optimized and not optimized shares to withdraw\\r\\n     * @return Withdrawn reallocation received\\r\\n     */\\r\\n    function _updateReallocationWithdraw(ProcessReallocationData calldata processReallocationData) internal virtual returns(uint128) {\\r\\n        Strategy storage strategy = strategies[self];\\r\\n        uint24 stratIndex = _getProcessingIndex();\\r\\n        BatchReallocation storage batch = strategy.reallocationBatches[stratIndex];\\r\\n\\r\\n        // save actual withdrawn amount, without optimized one \\r\\n        uint128 withdrawnReallocationReceived = batch.withdrawnReallocationReceived;\\r\\n\\r\\n        strategy.optimizedSharesWithdrawn += processReallocationData.optimizedShares;\\r\\n        batch.withdrawnReallocationReceived += processReallocationData.optimizedWithdrawnAmount;\\r\\n        batch.withdrawnReallocationShares = processReallocationData.optimizedShares + processReallocationData.sharesToWithdraw;\\r\\n\\r\\n        return withdrawnReallocationReceived;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Process deposit\\r\\n     * @param slippages Array of slippage parameters to apply when depositing\\r\\n     */\\r\\n    function processDeposit(uint256[] calldata slippages)\\r\\n        external\\r\\n        override\\r\\n    {\\r\\n        slippages = _validateStrategyBalance(slippages);\\r\\n\\r\\n        if (depositSlippageSlots != 0)\\r\\n            _validateDepositSlippage(slippages);\\r\\n\\r\\n        _processDeposit(slippages);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns total starategy balance includign pending rewards\\r\\n     * @return strategyBalance total starategy balance includign pending rewards\\r\\n     */\\r\\n    function getStrategyUnderlyingWithRewards() public view override returns(uint128)\\r\\n    {\\r\\n        return _getStrategyUnderlyingWithRewards();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Fast withdraw\\r\\n     * @param shares Shares to fast withdraw\\r\\n     * @param slippages Array of slippage parameters to apply when withdrawing\\r\\n     * @param swapData Swap slippage and path array\\r\\n     * @return Withdrawn amount withdawn\\r\\n     */\\r\\n    function fastWithdraw(uint128 shares, uint256[] calldata slippages, SwapData[] calldata swapData) external override returns(uint128)\\r\\n    {\\r\\n        slippages = _validateStrategyBalance(slippages);\\r\\n\\r\\n        _validateRewardsSlippage(swapData);\\r\\n\\r\\n        if (processSlippageSlots != 0)\\r\\n            _validateProcessSlippage(slippages);\\r\\n\\r\\n        uint128 withdrawnAmount = _processFastWithdraw(shares, slippages, swapData);\\r\\n        strategies[self].totalShares -= shares;\\r\\n        return withdrawnAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Claims and possibly compounds strategy rewards.\\r\\n     *\\r\\n     * @param swapData swap data for processing\\r\\n     */\\r\\n    function claimRewards(SwapData[] calldata swapData) external override\\r\\n    {\\r\\n        _validateRewardsSlippage(swapData);\\r\\n        _processRewards(swapData);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Withdraws all actively deployed funds in the strategy, liquifying them in the process.\\r\\n     *\\r\\n     * @param recipient recipient of the withdrawn funds\\r\\n     * @param data data necessary execute the emergency withdraw\\r\\n     */\\r\\n    function emergencyWithdraw(address recipient, uint256[] calldata data) external virtual override {\\r\\n        uint256 balanceBefore = underlying.balanceOf(address(this));\\r\\n        _emergencyWithdraw(recipient, data);\\r\\n        uint256 balanceAfter = underlying.balanceOf(address(this));\\r\\n\\r\\n        uint256 withdrawnAmount = 0;\\r\\n        if (balanceAfter > balanceBefore) {\\r\\n            withdrawnAmount = balanceAfter - balanceBefore;\\r\\n        }\\r\\n        \\r\\n        Strategy storage strategy = strategies[self];\\r\\n        if (strategy.emergencyPending > 0) {\\r\\n            withdrawnAmount += strategy.emergencyPending;\\r\\n            strategy.emergencyPending = 0;\\r\\n        }\\r\\n\\r\\n        // also withdraw all unprocessed deposit for a strategy\\r\\n        if (strategy.pendingUser.deposit.get() > 0) {\\r\\n            withdrawnAmount += strategy.pendingUser.deposit.get();\\r\\n            strategy.pendingUser.deposit = 0;\\r\\n        }\\r\\n\\r\\n        if (strategy.pendingUserNext.deposit.get() > 0) {\\r\\n            withdrawnAmount += strategy.pendingUserNext.deposit.get();\\r\\n            strategy.pendingUserNext.deposit = 0;\\r\\n        }\\r\\n\\r\\n        // if strategy was already processed in the current index that hasn't finished yet,\\r\\n        // transfer the withdrawn amount\\r\\n        // reset total underlying to 0\\r\\n        if (strategy.index == globalIndex && doHardWorksLeft > 0) {\\r\\n            uint256 withdrawnReceived = strategy.batches[strategy.index].withdrawnReceived;\\r\\n            withdrawnAmount += withdrawnReceived;\\r\\n            strategy.batches[strategy.index].withdrawnReceived = 0;\\r\\n\\r\\n            strategy.totalUnderlying[strategy.index].amount = 0;\\r\\n        }\\r\\n\\r\\n        if (withdrawnAmount > 0) {\\r\\n            // check if the balance is high enough to withdraw the total withdrawnAmount\\r\\n            if (balanceAfter < withdrawnAmount) {\\r\\n                // if not withdraw the current balance\\r\\n                withdrawnAmount = balanceAfter;\\r\\n            }\\r\\n\\r\\n            underlying.safeTransfer(recipient, withdrawnAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initialize a strategy.\\r\\n     * @dev Execute strategy specific one-time actions if needed.\\r\\n     */\\r\\n    function initialize() external virtual override {}\\r\\n\\r\\n    /**\\r\\n     * @notice Disables a strategy.\\r\\n     * @dev Cleans strategy specific values if needed.\\r\\n     */\\r\\n    function disable() external virtual override {}\\r\\n\\r\\n    /* ========== INTERNAL FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @dev Validate strategy balance\\r\\n     * @param slippages Check if the strategy balance is within defined min and max values\\r\\n     * @return slippages Same array without first 2 slippages\\r\\n     */\\r\\n    function _validateStrategyBalance(uint256[] calldata slippages) internal virtual returns(uint256[] calldata) {\\r\\n        if (doValidateBalance) {\\r\\n            require(slippages.length >= 2, \\\"BaseStrategy:: _validateStrategyBalance: Invalid number of slippages\\\");\\r\\n            uint128 strategyBalance =  getStrategyBalance();\\r\\n\\r\\n            require(\\r\\n                slippages[0] <= strategyBalance &&\\r\\n                slippages[1] >= strategyBalance,\\r\\n                \\\"BaseStrategy::_validateStrategyBalance: Bad strategy balance\\\"\\r\\n            );\\r\\n\\r\\n            return slippages[2:];\\r\\n        }\\r\\n\\r\\n        return slippages;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validate reards slippage\\r\\n     * @param swapData Swap slippage and path array\\r\\n     */\\r\\n    function _validateRewardsSlippage(SwapData[] calldata swapData) internal view virtual {\\r\\n        if (swapData.length > 0) {\\r\\n            require(\\r\\n                swapData.length == _getRewardSlippageSlots(),\\r\\n                \\\"BaseStrategy::_validateSlippage: Invalid Number of reward slippages Defined\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Retrieve reward slippage slots\\r\\n     * @return Reward slippage slots\\r\\n     */\\r\\n    function _getRewardSlippageSlots() internal view virtual returns(uint256) {\\r\\n        return rewardSlippageSlots;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validate process slippage\\r\\n     * @param slippages parameters to verify validity of the strategy state\\r\\n     */\\r\\n    function _validateProcessSlippage(uint256[] calldata slippages) internal view virtual {\\r\\n        _validateSlippage(slippages.length, processSlippageSlots);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validate reallocation slippage\\r\\n     * @param slippages parameters to verify validity of the strategy state\\r\\n     */\\r\\n    function _validateReallocationSlippage(uint256[] calldata slippages) internal view virtual {\\r\\n        _validateSlippage(slippages.length, reallocationSlippageSlots);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validate deposit slippage\\r\\n     * @param slippages parameters to verify validity of the strategy state\\r\\n     */\\r\\n    function _validateDepositSlippage(uint256[] calldata slippages) internal view virtual {\\r\\n        _validateSlippage(slippages.length, depositSlippageSlots);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validates the provided slippage in length.\\r\\n     * @param currentLength actual slippage array length\\r\\n     * @param shouldBeLength expected slippages array length\\r\\n     */\\r\\n    function _validateSlippage(uint256 currentLength, uint256 shouldBeLength)\\r\\n        internal\\r\\n        view\\r\\n        virtual\\r\\n    {\\r\\n        require(\\r\\n            currentLength == shouldBeLength,\\r\\n            \\\"BaseStrategy::_validateSlippage: Invalid Number of Slippages Defined\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Retrieve processing index\\r\\n     * @return Processing index\\r\\n     */\\r\\n    function _getProcessingIndex() internal view returns(uint24) {\\r\\n        return strategies[self].index + 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculates shares before they are added to the total shares\\r\\n     * @param strategyTotalShares Total shares for strategy\\r\\n     * @param stratTotalUnderlying Total underlying for strategy\\r\\n     * @return newShares New shares calculated\\r\\n     */\\r\\n    function _getNewSharesAfterWithdraw(uint128 strategyTotalShares, uint128 stratTotalUnderlying, uint128 depositAmount) internal pure returns(uint128 newShares){\\r\\n        uint128 oldUnderlying;\\r\\n        if (stratTotalUnderlying > depositAmount) {\\r\\n            oldUnderlying = stratTotalUnderlying - depositAmount;\\r\\n        }\\r\\n        \\r\\n        if (strategyTotalShares == 0 || oldUnderlying == 0) {\\r\\n            // Enforce minimum shares size to avoid loss of share due to computation precision\\r\\n            newShares = (0 < depositAmount && depositAmount < MIN_SHARES) ? MIN_SHARES : depositAmount;\\r\\n        } else {\\r\\n            newShares = Math.getProportion128(depositAmount, strategyTotalShares, oldUnderlying);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculates shares when they are already part of the total shares\\r\\n     *\\r\\n     * @param strategyTotalShares Total shares\\r\\n     * @param stratTotalUnderlying Total underlying\\r\\n     * @return newShares New shares calculated\\r\\n     */\\r\\n    function _getNewShares(uint128 strategyTotalShares, uint128 stratTotalUnderlying, uint128 depositAmount) internal pure returns(uint128 newShares){\\r\\n        if (strategyTotalShares == 0 || stratTotalUnderlying == 0) {\\r\\n            // Enforce minimum shares size to avoid loss of share due to computation precision\\r\\n            newShares = (0 < depositAmount && depositAmount < MIN_SHARES) ? MIN_SHARES : depositAmount;\\r\\n        } else {\\r\\n            newShares = Math.getProportion128(depositAmount, strategyTotalShares, stratTotalUnderlying);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Reset allowance to zero if previously set to a higher value.\\r\\n     * @param token Asset\\r\\n     * @param spender Spender address\\r\\n     */\\r\\n    function _resetAllowance(IERC20 token, address spender) internal {\\r\\n        if (token.allowance(address(this), spender) > 0) {\\r\\n            token.safeApprove(spender, 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* ========== VIRTUAL FUNCTIONS ========== */\\r\\n\\r\\n    function getStrategyBalance()\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (uint128);\\r\\n\\r\\n    function _processRewards(SwapData[] calldata) internal virtual;\\r\\n    function _emergencyWithdraw(address recipient, uint256[] calldata data) internal virtual;\\r\\n    function _process(uint256[] memory, uint128 reallocateSharesToWithdraw) internal virtual;\\r\\n    function _processDeposit(uint256[] memory) internal virtual;\\r\\n    function _getStrategyUnderlyingWithRewards() internal view virtual returns(uint128);\\r\\n    function _processFastWithdraw(uint128, uint256[] memory, SwapData[] calldata) internal virtual returns(uint128);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/strategies/NoRewardStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"./ProcessStrategy.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice No reward strategy logic\\r\\n */\\r\\nabstract contract NoRewardStrategy is ProcessStrategy {\\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Set initial values\\r\\n     * @param _underlying Underlying asset\\r\\n     * @param _processSlippageSlots Slots for processing\\r\\n     * @param _reallocationSlippageSlots Slots for reallocation\\r\\n     * @param _depositSlippageSlots Slots for deposits\\r\\n     * @param _doValidateBalance Force balance validation\\r\\n     */\\r\\n    constructor(\\r\\n        IERC20 _underlying,\\r\\n        uint256 _processSlippageSlots,\\r\\n        uint256 _reallocationSlippageSlots,\\r\\n        uint256 _depositSlippageSlots,\\r\\n        bool _doValidateBalance\\r\\n    )\\r\\n        BaseStrategy(\\r\\n            _underlying,\\r\\n            0,\\r\\n            _processSlippageSlots,\\r\\n            _reallocationSlippageSlots,\\r\\n            _depositSlippageSlots,\\r\\n            false,\\r\\n            _doValidateBalance\\r\\n        )\\r\\n    {}\\r\\n\\r\\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Returns total strategy balance including pending rewards\\r\\n     * @return strategyBalance total strategy balance including pending rewards\\r\\n     */\\r\\n    function _getStrategyUnderlyingWithRewards() internal view override virtual returns(uint128) {\\r\\n        return getStrategyBalance();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Process rewards - not supported\\r\\n     */\\r\\n    function _processRewards(SwapData[] calldata) internal pure override {\\r\\n        revert(\\\"NoRewardStrategy::_processRewards: Strategy does not have rewards\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Process fast withdraw\\r\\n     * @param shares Amount of shares\\r\\n     * @param slippages Slippages array\\r\\n     * @return withdrawnAmount Underlying withdrawn amount\\r\\n     */\\r\\n    function _processFastWithdraw(uint128 shares, uint256[] memory slippages, SwapData[] calldata) internal virtual override returns(uint128) {\\r\\n        return _withdraw(shares, slippages);\\r\\n    }\\r\\n\\r\\n    function _validateRewardsSlippage(SwapData[] calldata) internal view override {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/strategies/ProcessStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"./BaseStrategy.sol\\\";\\r\\n\\r\\nimport \\\"../libraries/Max/128Bit.sol\\\";\\r\\nimport \\\"../libraries/Math.sol\\\";\\r\\n\\r\\nstruct ProcessInfo {\\r\\n    uint128 totalWithdrawReceived;\\r\\n    uint128 userDepositReceived;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @notice Process strategy logic\\r\\n */\\r\\nabstract contract ProcessStrategy is BaseStrategy {\\r\\n    using Max128Bit for uint128;\\r\\n\\r\\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Process the strategy pending deposits, withdrawals, and collected strategy rewards\\r\\n     * @dev\\r\\n     * Deposit amount amd withdrawal shares are matched between eachother, effecively only one of\\r\\n     * those 2 is called. Shares are converted to the dollar value, based on the current strategy\\r\\n     * total balance. This ensures the minimum amount of assets are moved around to lower the price\\r\\n     * drift and total fees paid to the protocols the strategy is interacting with (if there are any)\\r\\n     *\\r\\n     * @param slippages Strategy slippage values verifying the validity of the strategy state\\r\\n     * @param reallocateSharesToWithdraw Reallocation shares to withdraw (non-zero only if reallocation DHW is in progress, otherwise 0)\\r\\n     */\\r\\n    function _process(uint256[] memory slippages, uint128 reallocateSharesToWithdraw) internal override virtual {\\r\\n        // PREPARE\\r\\n        Strategy storage strategy = strategies[self];\\r\\n        uint24 processingIndex = _getProcessingIndex();\\r\\n        Batch storage batch = strategy.batches[processingIndex];\\r\\n        uint128 strategyTotalShares = strategy.totalShares;\\r\\n        uint128 pendingSharesToWithdraw = strategy.pendingUser.sharesToWithdraw.get();\\r\\n        uint128 userDeposit = strategy.pendingUser.deposit.get();\\r\\n\\r\\n        // CALCULATE THE ACTION\\r\\n\\r\\n        // if withdrawing for reallocating, add shares to total withdraw shares\\r\\n        if (reallocateSharesToWithdraw > 0) {\\r\\n            pendingSharesToWithdraw += reallocateSharesToWithdraw;\\r\\n        }\\r\\n\\r\\n        // total deposit received from users + compound reward (if there are any)\\r\\n        uint128 totalPendingDeposit = userDeposit;\\r\\n        \\r\\n        // add compound reward (pendingDepositReward) to deposit\\r\\n        uint128 withdrawalReward = 0;\\r\\n        if (strategy.pendingDepositReward > 0) {\\r\\n            uint128 pendingDepositReward = strategy.pendingDepositReward;\\r\\n\\r\\n            totalPendingDeposit += pendingDepositReward;\\r\\n\\r\\n            // calculate compound reward (withdrawalReward) for users withdrawing in this batch\\r\\n            if (pendingSharesToWithdraw > 0 && strategyTotalShares > 0) {\\r\\n                withdrawalReward = Math.getProportion128(pendingSharesToWithdraw, pendingDepositReward, strategyTotalShares);\\r\\n\\r\\n                // substract withdrawal reward from total deposit\\r\\n                totalPendingDeposit -= withdrawalReward;\\r\\n            }\\r\\n\\r\\n            // Reset pendingDepositReward\\r\\n            strategy.pendingDepositReward = 0;\\r\\n        }\\r\\n\\r\\n        // if there is no pending deposit or withdrawals, return\\r\\n        if (totalPendingDeposit == 0 && pendingSharesToWithdraw == 0) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint128 pendingWithdrawalAmount = 0;\\r\\n        if (pendingSharesToWithdraw > 0) {\\r\\n            pendingWithdrawalAmount = \\r\\n                Math.getProportion128(getStrategyBalance(), pendingSharesToWithdraw, strategyTotalShares);\\r\\n        }\\r\\n\\r\\n        // ACTION: DEPOSIT OR WITHDRAW\\r\\n        ProcessInfo memory processInfo;\\r\\n        if (totalPendingDeposit > pendingWithdrawalAmount) { // DEPOSIT\\r\\n            // uint128 amount = totalPendingDeposit - pendingWithdrawalAmount;\\r\\n            uint128 depositReceived = _deposit(totalPendingDeposit - pendingWithdrawalAmount, slippages);\\r\\n\\r\\n            processInfo.totalWithdrawReceived = pendingWithdrawalAmount + withdrawalReward;\\r\\n\\r\\n            // pendingWithdrawalAmount is optimized deposit: totalPendingDeposit - amount;\\r\\n            uint128 totalDepositReceived = depositReceived + pendingWithdrawalAmount;\\r\\n            \\r\\n            // calculate user deposit received, excluding compound rewards\\r\\n            processInfo.userDepositReceived =  Math.getProportion128(totalDepositReceived, userDeposit, totalPendingDeposit);\\r\\n        } else if (totalPendingDeposit < pendingWithdrawalAmount) { // WITHDRAW\\r\\n            // uint128 amount = pendingWithdrawalAmount - totalPendingDeposit;\\r\\n\\r\\n            uint128 withdrawReceived = _withdraw(\\r\\n                // calculate back the shares from actual withdraw amount\\r\\n                // NOTE: we can do unchecked calculation and casting as\\r\\n                //       the multiplier is always smaller than the divisor\\r\\n                Math.getProportion128Unchecked(\\r\\n                    (pendingWithdrawalAmount - totalPendingDeposit),\\r\\n                    pendingSharesToWithdraw,\\r\\n                    pendingWithdrawalAmount\\r\\n                ),\\r\\n                slippages\\r\\n            );\\r\\n\\r\\n            // optimized withdraw is total pending deposit: pendingWithdrawalAmount - amount = totalPendingDeposit;\\r\\n            processInfo.totalWithdrawReceived = withdrawReceived + totalPendingDeposit + withdrawalReward;\\r\\n            processInfo.userDepositReceived = userDeposit;\\r\\n        } else {\\r\\n            processInfo.totalWithdrawReceived = pendingWithdrawalAmount + withdrawalReward;\\r\\n            processInfo.userDepositReceived = userDeposit;\\r\\n        }\\r\\n        \\r\\n        // UPDATE STORAGE AFTER\\r\\n        {\\r\\n            uint128 stratTotalUnderlying = getStrategyBalance();\\r\\n\\r\\n            // Update withdraw batch\\r\\n            if (pendingSharesToWithdraw > 0) {\\r\\n                batch.withdrawnReceived = processInfo.totalWithdrawReceived;\\r\\n                batch.withdrawnShares = pendingSharesToWithdraw;\\r\\n                \\r\\n                strategyTotalShares -= pendingSharesToWithdraw;\\r\\n\\r\\n                // update reallocation batch\\r\\n                if (reallocateSharesToWithdraw > 0) {\\r\\n                    BatchReallocation storage reallocationBatch = strategy.reallocationBatches[processingIndex];\\r\\n\\r\\n                    uint128 withdrawnReallocationReceived =\\r\\n                        Math.getProportion128(processInfo.totalWithdrawReceived, reallocateSharesToWithdraw, pendingSharesToWithdraw);\\r\\n                    reallocationBatch.withdrawnReallocationReceived = withdrawnReallocationReceived;\\r\\n\\r\\n                    // substract reallocation values from user values\\r\\n                    batch.withdrawnReceived -= withdrawnReallocationReceived;\\r\\n                    batch.withdrawnShares -= reallocateSharesToWithdraw;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // Update deposit batch\\r\\n            if (userDeposit > 0) {\\r\\n                uint128 newShares = _getNewSharesAfterWithdraw(strategyTotalShares, stratTotalUnderlying, processInfo.userDepositReceived);\\r\\n\\r\\n                batch.deposited = userDeposit;\\r\\n                batch.depositedReceived = processInfo.userDepositReceived;\\r\\n                batch.depositedSharesReceived = newShares;\\r\\n                strategyTotalShares += newShares;\\r\\n            }\\r\\n\\r\\n            // Update shares\\r\\n            if (strategyTotalShares != strategy.totalShares) {\\r\\n                strategy.totalShares = strategyTotalShares;\\r\\n            }\\r\\n\\r\\n            // Set underlying at index\\r\\n            strategy.totalUnderlying[processingIndex].amount = stratTotalUnderlying;\\r\\n            strategy.totalUnderlying[processingIndex].totalShares = strategyTotalShares;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Process deposit\\r\\n     * @param slippages Slippages array\\r\\n     */\\r\\n    function _processDeposit(uint256[] memory slippages) internal override virtual {\\r\\n        Strategy storage strategy = strategies[self];\\r\\n        \\r\\n        uint128 depositOptimizedAmount = strategy.pendingReallocateOptimizedDeposit;\\r\\n        uint128 optimizedSharesWithdrawn = strategy.optimizedSharesWithdrawn;\\r\\n        uint128 depositAmount = strategy.pendingReallocateDeposit;\\r\\n\\r\\n        // if a strategy is not part of reallocation return\\r\\n        if (\\r\\n            depositOptimizedAmount == 0 &&\\r\\n            optimizedSharesWithdrawn == 0 &&\\r\\n            depositAmount == 0\\r\\n        ) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint24 processingIndex = _getProcessingIndex();\\r\\n        BatchReallocation storage reallocationBatch = strategy.reallocationBatches[processingIndex];\\r\\n        \\r\\n        uint128 strategyTotalShares = strategy.totalShares;\\r\\n        \\r\\n        // get shares from optimized deposit\\r\\n        if (depositOptimizedAmount > 0) {\\r\\n            uint128 stratTotalUnderlying = getStrategyBalance();\\r\\n            uint128 newShares = _getNewShares(strategyTotalShares, stratTotalUnderlying, depositOptimizedAmount);\\r\\n\\r\\n            // add new shares\\r\\n            strategyTotalShares += newShares;\\r\\n\\r\\n            // update reallocation batch\\r\\n            reallocationBatch.depositedReallocation = depositOptimizedAmount;\\r\\n            reallocationBatch.depositedReallocationSharesReceived = newShares;\\r\\n\\r\\n            strategy.totalUnderlying[processingIndex].amount = stratTotalUnderlying;\\r\\n\\r\\n            // reset\\r\\n            strategy.pendingReallocateOptimizedDeposit = 0;\\r\\n        }\\r\\n\\r\\n        // remove optimized withdraw shares\\r\\n        if (optimizedSharesWithdrawn > 0) {\\r\\n            strategyTotalShares -= optimizedSharesWithdrawn;\\r\\n\\r\\n            // reset\\r\\n            strategy.optimizedSharesWithdrawn = 0;\\r\\n        }\\r\\n\\r\\n        // get shares from actual deposit\\r\\n        if (depositAmount > 0) {\\r\\n            // deposit\\r\\n            uint128 depositReceived = _deposit(depositAmount, slippages);\\r\\n\\r\\n            // NOTE: might return it from _deposit (only certain strategies need it)\\r\\n            uint128 stratTotalUnderlying = getStrategyBalance();\\r\\n\\r\\n            uint128 newShares = _getNewSharesAfterWithdraw(strategyTotalShares, stratTotalUnderlying, depositReceived);\\r\\n\\r\\n            // add new shares\\r\\n            strategyTotalShares += newShares;\\r\\n\\r\\n            // update reallocation batch\\r\\n            reallocationBatch.depositedReallocation += depositReceived;\\r\\n            reallocationBatch.depositedReallocationSharesReceived += newShares;\\r\\n\\r\\n            strategy.totalUnderlying[processingIndex].amount = stratTotalUnderlying;\\r\\n\\r\\n            // reset\\r\\n            strategy.pendingReallocateDeposit = 0;\\r\\n        }\\r\\n\\r\\n        // update share storage\\r\\n        strategy.totalUnderlying[processingIndex].totalShares = strategyTotalShares;\\r\\n        strategy.totalShares = strategyTotalShares;\\r\\n    }\\r\\n\\r\\n    /* ========== INTERNAL FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice get the value of the strategy shares in the underlying tokens\\r\\n     * @param shares Number of shares\\r\\n     * @return amount Underling amount representing the `share` value of the strategy\\r\\n     */\\r\\n    function _getSharesToAmount(uint256 shares) internal virtual returns(uint128 amount) {\\r\\n        amount = Math.getProportion128( getStrategyBalance(), shares, strategies[self].totalShares );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice get slippage amount, and action type (withdraw/deposit).\\r\\n     * @dev\\r\\n     * Most significant bit represents an action, 0 for a withdrawal and 1 for deposit.\\r\\n     *\\r\\n     * This ensures the slippage will be used for the action intended by the do-hard-worker,\\r\\n     * otherwise the transavtion will revert.\\r\\n     *\\r\\n     * @param slippageAction number containing the slippage action and the actual slippage amount\\r\\n     * @return isDeposit Flag showing if the slippage is for the deposit action\\r\\n     * @return slippage the slippage value cleaned of the most significant bit\\r\\n     */\\r\\n    function _getSlippageAction(uint256 slippageAction) internal pure returns (bool isDeposit, uint256 slippage) {\\r\\n        // remove most significant bit\\r\\n        slippage = (slippageAction << 1) >> 1;\\r\\n\\r\\n        // if values are not the same (the removed bit was 1) set action to deposit\\r\\n        if (slippageAction != slippage) {\\r\\n            isDeposit = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* ========== VIRTUAL FUNCTIONS ========== */\\r\\n\\r\\n    function _deposit(uint128 amount, uint256[] memory slippages) internal virtual returns(uint128 depositReceived);\\r\\n    function _withdraw(uint128 shares, uint256[] memory slippages) internal virtual returns(uint128 withdrawReceived);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/strategies/yearn/YearnStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../../external/@openzeppelin/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport \\\"../NoRewardStrategy.sol\\\";\\r\\nimport \\\"../../external/interfaces/yearn/IYearnTokenVault.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice Yearn Strategy implementation\\r\\n */\\r\\ncontract YearnStrategy is NoRewardStrategy {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    /// @notice Vault contract\\r\\n    IYearnTokenVault public immutable vault;\\r\\n\\r\\n    /// @notice One yearn vault share amount\\r\\n    uint256 public immutable oneShare;\\r\\n\\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Set initial values\\r\\n     * @param _vault Vault contract\\r\\n     * @param _underlying Underlying asset\\r\\n     */\\r\\n    constructor(\\r\\n        IYearnTokenVault _vault,\\r\\n        IERC20 _underlying\\r\\n    )\\r\\n        NoRewardStrategy(_underlying, 1, 1, 1, false)\\r\\n    {\\r\\n        require(address(_vault) != address(0), \\\"YearnStrategy::constructor: Vault address cannot be 0\\\");\\r\\n        vault = _vault;\\r\\n        oneShare = 10**uint256(_vault.decimals());\\r\\n    }\\r\\n\\r\\n    /* ========== VIEWS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Get strategy balance\\r\\n     * @return Strategy balance\\r\\n     */\\r\\n    function getStrategyBalance() public view override returns(uint128) {\\r\\n        uint256 yearnTokenAmount = vault.balanceOf(address(this));\\r\\n        return SafeCast.toUint128(_getYearnTokenValue(yearnTokenAmount));\\r\\n    }\\r\\n\\r\\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Deposit\\r\\n     * @param amount Amount to deposit\\r\\n     * @param slippages Slippages array\\r\\n     * @return Minted idle amount\\r\\n     */\\r\\n    function _deposit(uint128 amount, uint256[] memory slippages) internal override returns(uint128) {\\r\\n        (bool isDeposit, uint256 slippage) = _getSlippageAction(slippages[0]);\\r\\n        require(isDeposit, \\\"YearnStrategy::_deposit: Withdraw slippage provided\\\");\\r\\n\\r\\n        // deposit underlying\\r\\n        underlying.safeApprove(address(vault), amount);\\r\\n\\r\\n        uint256 yearnTokenBefore = vault.balanceOf(address(this));\\r\\n        vault.deposit(amount, address(this));\\r\\n        uint256 yearnTokenNew = vault.balanceOf(address(this)) - yearnTokenBefore;\\r\\n        _resetAllowance(underlying, address(vault));\\r\\n\\r\\n        require(\\r\\n            yearnTokenNew >= slippage,\\r\\n            \\\"YearnStrategy::_deposit: Insufficient Yearn Amount Minted\\\"\\r\\n        );\\r\\n\\r\\n        return SafeCast.toUint128(_getYearnTokenValue(yearnTokenNew));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Withdraw\\r\\n     * @param shares Shares to withdraw\\r\\n     * @param slippages Slippages array\\r\\n     * @return Underlying withdrawn\\r\\n     */\\r\\n    function _withdraw(uint128 shares, uint256[] memory slippages) internal override returns(uint128) {\\r\\n        (bool isDeposit, uint256 slippage) = _getSlippageAction(slippages[0]);\\r\\n        require(!isDeposit, \\\"YearnStrategy::_withdraw: Deposit slippage provided\\\");\\r\\n\\r\\n        uint256 yearnTokenBalance = vault.balanceOf(address(this));\\r\\n        uint256 yearnTokenWithdraw = (yearnTokenBalance * shares) / strategies[self].totalShares;\\r\\n\\r\\n        // withdraw idle tokens from vault\\r\\n        uint256 undelyingBefore = underlying.balanceOf(address(this));\\r\\n        vault.withdraw(yearnTokenWithdraw, address(this), slippage);\\r\\n        uint256 undelyingWithdrawn = underlying.balanceOf(address(this)) - undelyingBefore;\\r\\n\\r\\n        return SafeCast.toUint128(undelyingWithdrawn);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Emergency withdraw\\r\\n     * @param recipient Address to withdraw to\\r\\n     * @param data Data to perform emergency withdrawal\\r\\n     */\\r\\n    function _emergencyWithdraw(address recipient, uint256[] calldata data) internal override {\\r\\n        // if no data provided set max loss to 100%\\r\\n        uint256 maxLoss = data.length > 0 ? data[0] : 100_00;\\r\\n\\r\\n        vault.withdraw(\\r\\n            type(uint256).max,\\r\\n            recipient,\\r\\n            maxLoss\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /* ========== PRIVATE FUNCTIONS ========== */\\r\\n\\r\\n    function _getYearnTokenValue(uint256 yearnTokenAmount) private view returns(uint256) {\\r\\n        if (yearnTokenAmount == 0)\\r\\n            return 0;\\r\\n        return (yearnTokenAmount * vault.pricePerShare()) / oneShare;\\r\\n    }\\r\\n}\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IYearnTokenVault\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_underlying\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapData[]\",\"name\":\"swapData\",\"type\":\"tuple[]\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"data\",\"type\":\"uint256[]\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"shares\",\"type\":\"uint128\"},{\"internalType\":\"uint256[]\",\"name\":\"slippages\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapData[]\",\"name\":\"swapData\",\"type\":\"tuple[]\"}],\"name\":\"fastWithdraw\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStrategyBalance\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStrategyUnderlyingWithRewards\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalIndex\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAllocationProvider\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isDoHardWorker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"slippages\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"redeposit\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapData[]\",\"name\":\"swapData\",\"type\":\"tuple[]\"}],\"name\":\"process\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"slippages\",\"type\":\"uint256[]\"}],\"name\":\"processDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"slippages\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"sharesToWithdraw\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"optimizedShares\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"optimizedWithdrawnAmount\",\"type\":\"uint128\"}],\"internalType\":\"struct ProcessReallocationData\",\"name\":\"processReallocationData\",\"type\":\"tuple\"}],\"name\":\"processReallocation\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reallocationIndex\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"strategies\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"totalShares\",\"type\":\"uint128\"},{\"internalType\":\"uint24\",\"name\":\"index\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isRemoved\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"deposit\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"sharesToWithdraw\",\"type\":\"uint128\"}],\"internalType\":\"struct Pending\",\"name\":\"pendingUser\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"deposit\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"sharesToWithdraw\",\"type\":\"uint128\"}],\"internalType\":\"struct Pending\",\"name\":\"pendingUserNext\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"pendingDepositReward\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isInDepositPhase\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"optimizedSharesWithdrawn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"pendingReallocateDeposit\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"pendingReallocateOptimizedDeposit\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"emergencyPending\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IYearnTokenVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalDoHardWorksLeft\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "YearnStrategy", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "0000000000000000000000007da96a3891add058ada2e826306d812c638d87a7000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}