{"status": "1", "message": "OK", "result": [{"SourceCode": "//SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.8.11;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    //function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC721 {\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function balanceOf(address _owner) external returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function withdraw(uint256 _amount) external;\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n    function WETH() external pure returns (address);\r\n    function factory() external pure returns (address);\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ncontract ChainParameters {\r\n\tuint256 public chainId;\r\n\tbool public isTestnet;\r\n\taddress public swapRouter = address(0);\r\n\taddress public wETHAddr;\r\n\taddress private routerUNIAll = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; //1,3,4,5,42\r\n\taddress private routerPCSMainnet = 0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F; //56\r\n\taddress private routerPCSTestnet = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3; //97\r\n\r\n\tfunction getChainID() public view returns (uint256) {\r\n        uint256 id;\r\n        assembly {id := chainid()}\r\n        return id;\r\n    }\r\n\t\r\n\t\r\n\tconstructor() {\r\n\t\tchainId = getChainID();\r\n\t\tif(chainId == 1) {isTestnet = false; swapRouter = routerUNIAll;}\r\n\t\tif(chainId == 3) {isTestnet = true; swapRouter = routerUNIAll;}\r\n\t\tif(chainId == 4) {isTestnet = true; swapRouter = routerUNIAll;}\r\n\t\tif(chainId == 5) {isTestnet = true; swapRouter = routerUNIAll;}\r\n\t\tif(chainId == 42) {isTestnet = true; swapRouter = routerUNIAll;}\r\n\t\tif(chainId == 56) {isTestnet = false; swapRouter = routerPCSMainnet;}\r\n\t\tif(chainId == 97) {isTestnet = true; swapRouter = routerPCSTestnet;}\r\n\t\trequire(swapRouter!=address(0),\"Chain id not supported by this implementation\");\r\n\t\twETHAddr = IUniswapV2Router(swapRouter).WETH();\r\n\t}\r\n\t\r\n}\r\n\r\n\r\ncontract Timer is ChainParameters {\r\n\tuint256 public epochPeriod;\r\n\tuint256 public delayPeriod;\r\n\tuint256 public nextWithdrawalDue;\r\n\tuint256 public lastWithdrawalDone;\r\n\tuint256 public counter;\r\n\r\n    constructor()  {\r\n        epochPeriod = (isTestnet?3600:86400*30); //1h/1m\r\n        delayPeriod = (isTestnet?900:86400); //15m/1d\r\n        nextWithdrawalDue = block.timestamp/epochPeriod*epochPeriod; //align to the beginning of current epoch\r\n\t\tlastWithdrawalDone = 0; \r\n\t\tcounter = 0;\r\n    }\r\n\t\r\n\tfunction updateTimer() internal {\r\n\t\tcounter++;\r\n\t\trequire(nextWithdrawalDue < block.timestamp, \"Next withdrawal not due yet\");\r\n\t\tnextWithdrawalDue += epochPeriod;\r\n\t\trequire(lastWithdrawalDone+delayPeriod < block.timestamp, \"Late withdrawal attempted too early after last one\");\r\n\t\tlastWithdrawalDone = block.timestamp;\r\n\t}\r\n}\r\n\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor ()  {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n\t\t//don't allow burning except 0xdead\r\n        require(newOwner != address(0), \"Ownable: newOwner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ncontract InfiniteVest is Ownable, Timer {\r\n\tuint256 private tokenBalance;\r\n\tuint256 private ethBalance;\r\n\tuint8 private percentToSell = 1;\r\n\tuint8 private fractionToFinalize = 10;\r\n\tuint256 private tokensToSell;\r\n\tuint256 private ethToSend;\r\n    uint256 public historicMaxBalance;\r\n    event Log (string action); \r\n\r\n\tfunction _vestEth() private {\r\n        ethBalance = address(this).balance;\r\n        if (ethBalance > historicMaxBalance) \r\n            historicMaxBalance = ethBalance;\r\n        ethToSend = ethBalance*percentToSell/100;\r\n        payable(owner()).transfer(ethBalance < historicMaxBalance/fractionToFinalize ? ethBalance : ethToSend);\r\n\t}\r\n\r\n\tfunction vestEth() public onlyOwner {\r\n\t\tupdateTimer();\r\n        _vestEth();\r\n\t}\r\n\r\n\tfunction vestToken(address tokenAddress) public onlyOwner {\r\n\t\tupdateTimer();\r\n\t\ttrySellToken(tokenAddress,percentToSell,0);\r\n        _vestEth();\r\n\t}\r\n\r\n    function vestNFT(address _token, uint256 _id) external onlyOwner {\r\n\t\tupdateTimer();\r\n        require(IERC721(_token).ownerOf(_id) == address(this),\"ERC721: Not an owner of specified id or not ERC721 token\");\r\n        IERC721(_token).transferFrom(address(this),owner(),_id);\r\n        _vestEth();\r\n    }\r\n\r\n\tfunction trySellToken(address _token, uint8 _percent, uint256 _amount) public onlyOwner {\r\n        tokenBalance = IERC20(_token).balanceOf(address(this));\r\n        tokensToSell = (_amount > 0 ? _amount : tokenBalance*_percent/100);\r\n        if (_token == wETHAddr) {\r\n            IWETH(wETHAddr).withdraw(tokensToSell);\r\n        } else {\r\n            bool swapSuccess = swapTokensForEth(tokensToSell,_token);\r\n\t\t    if (!swapSuccess) {IERC20(_token).transfer(owner(),tokensToSell);}\r\n        }\r\n    }\r\n\r\n    function swapTokensForEth(uint256 tokenAmount, address tokenAddress) private  returns (bool){\r\n        // generate the uniswap pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = tokenAddress;\r\n        path[1] = wETHAddr;\r\n        IERC20(tokenAddress).approve(swapRouter, tokenAmount);\r\n        // make the swap but never fail\r\n        try IUniswapV2Router(swapRouter).swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        )  { return true; }\r\n        catch Error(string memory reason) {emit Log(reason); }\r\n        catch {emit Log(\"Swap: Call unsuccessful\"); }\r\n        return false;\r\n    }\r\n\treceive() external payable { }\r\n\tfallback() external payable { }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"action\",\"type\":\"string\"}],\"name\":\"Log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"counter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"historicMaxBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTestnet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastWithdrawalDone\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextWithdrawalDue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_percent\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"trySellToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"vestNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"vestToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wETHAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "InfiniteVest", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5b09c3f183cb1f984c17a65f03f2a72ffb1d38b715d19c2fcfaa9b77be4ae79e"}]}