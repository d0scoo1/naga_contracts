{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity 0.8.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n// File: Address.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: BitMath.sol\r\n\r\n/// @title BitMath\r\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\r\nlibrary BitMath {\r\n    /// @notice Returns the index of the most significant bit of the number,\r\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\r\n    /// @dev The function satisfies the property:\r\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\r\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\r\n    /// @return r the index of the most significant bit\r\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\r\n        require(x > 0);\r\n\r\n        unchecked {\r\n            if (x >= 0x100000000000000000000000000000000) {\r\n                x >>= 128;\r\n                r += 128;\r\n            }\r\n            if (x >= 0x10000000000000000) {\r\n                x >>= 64;\r\n                r += 64;\r\n            }\r\n            if (x >= 0x100000000) {\r\n                x >>= 32;\r\n                r += 32;\r\n            }\r\n            if (x >= 0x10000) {\r\n                x >>= 16;\r\n                r += 16;\r\n            }\r\n            if (x >= 0x100) {\r\n                x >>= 8;\r\n                r += 8;\r\n            }\r\n            if (x >= 0x10) {\r\n                x >>= 4;\r\n                r += 4;\r\n            }\r\n            if (x >= 0x4) {\r\n                x >>= 2;\r\n                r += 2;\r\n            }\r\n            if (x >= 0x2) r += 1;\r\n        }\r\n    }\r\n\r\n    /// @notice Returns the index of the least significant bit of the number,\r\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\r\n    /// @dev The function satisfies the property:\r\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\r\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\r\n    /// @return r the index of the least significant bit\r\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\r\n        require(x > 0);\r\n\r\n        unchecked {\r\n            r = 255;\r\n            if (x & type(uint128).max > 0) {\r\n                r -= 128;\r\n            } else {\r\n                x >>= 128;\r\n            }\r\n            if (x & type(uint64).max > 0) {\r\n                r -= 64;\r\n            } else {\r\n                x >>= 64;\r\n            }\r\n            if (x & type(uint32).max > 0) {\r\n                r -= 32;\r\n            } else {\r\n                x >>= 32;\r\n            }\r\n            if (x & type(uint16).max > 0) {\r\n                r -= 16;\r\n            } else {\r\n                x >>= 16;\r\n            }\r\n            if (x & type(uint8).max > 0) {\r\n                r -= 8;\r\n            } else {\r\n                x >>= 8;\r\n            }\r\n            if (x & 0xf > 0) {\r\n                r -= 4;\r\n            } else {\r\n                x >>= 4;\r\n            }\r\n            if (x & 0x3 > 0) {\r\n                r -= 2;\r\n            } else {\r\n                x >>= 2;\r\n            }\r\n            if (x & 0x1 > 0) r -= 1;\r\n        }\r\n    }\r\n}\r\n\r\n// File: Context.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: FixedPoint128.sol\r\n\r\n/// @title FixedPoint128\r\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\r\nlibrary FixedPoint128 {\r\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\r\n}\r\n\r\n// File: FixedPoint96.sol\r\n\r\n/// @title FixedPoint96\r\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\r\n/// @dev Used in SqrtPriceMath.sol\r\nlibrary FixedPoint96 {\r\n    uint8 internal constant RESOLUTION = 96;\r\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\r\n}\r\n\r\n// File: FullMath.sol\r\n\r\n/// @title Contains 512-bit math functions\r\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\r\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\r\nlibrary FullMath {\r\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\r\n    function mulDiv(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = a * b\r\n            // Compute the product mod 2**256 and mod 2**256 - 1\r\n            // then use the Chinese Remainder Theorem to reconstruct\r\n            // the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2**256 + prod0\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(a, b, not(0))\r\n                prod0 := mul(a, b)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division\r\n            if (prod1 == 0) {\r\n                require(denominator > 0);\r\n                assembly {\r\n                    result := div(prod0, denominator)\r\n                }\r\n                return result;\r\n            }\r\n\r\n            // Make sure the result is less than 2**256.\r\n            // Also prevents denominator == 0\r\n            require(denominator > prod1);\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0]\r\n            // Compute remainder using mulmod\r\n            uint256 remainder;\r\n            assembly {\r\n                remainder := mulmod(a, b, denominator)\r\n            }\r\n            // Subtract 256 bit number from 512 bit number\r\n            assembly {\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator\r\n            // Compute largest power of two divisor of denominator.\r\n            // Always >= 1.\r\n            uint256 twos = (0 - denominator) & denominator;\r\n            // Divide denominator by power of two\r\n            assembly {\r\n                denominator := div(denominator, twos)\r\n            }\r\n\r\n            // Divide [prod1 prod0] by the factors of two\r\n            assembly {\r\n                prod0 := div(prod0, twos)\r\n            }\r\n            // Shift in bits from prod1 into prod0. For this we need\r\n            // to flip `twos` such that it is 2**256 / twos.\r\n            // If twos is zero, then it becomes one\r\n            assembly {\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2**256\r\n            // Now that denominator is an odd number, it has an inverse\r\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n            // Compute the inverse by starting with a seed that is correct\r\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n            uint256 inv = (3 * denominator) ^ 2;\r\n            // Now use Newton-Raphson iteration to improve the precision.\r\n            // Thanks to Hensel's lifting lemma, this also works in modular\r\n            // arithmetic, doubling the correct bits in each step.\r\n            inv *= 2 - denominator * inv; // inverse mod 2**8\r\n            inv *= 2 - denominator * inv; // inverse mod 2**16\r\n            inv *= 2 - denominator * inv; // inverse mod 2**32\r\n            inv *= 2 - denominator * inv; // inverse mod 2**64\r\n            inv *= 2 - denominator * inv; // inverse mod 2**128\r\n            inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n            // Because the division is now exact we can divide by multiplying\r\n            // with the modular inverse of denominator. This will give us the\r\n            // correct result modulo 2**256. Since the precoditions guarantee\r\n            // that the outcome is less than 2**256, this is the final result.\r\n            // We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inv;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    function mulDivRoundingUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            result = mulDiv(a, b, denominator);\r\n            if (mulmod(a, b, denominator) > 0) {\r\n                require(result < type(uint256).max);\r\n                result++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: ICRVPool.sol\r\n\r\ninterface ICRVPool {\r\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\r\n\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\r\n\r\n    function coins(uint256 arg0) external view returns (address);\r\n}\r\n\r\n// File: IERC20.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: IUniswapV3PoolActions.sol\r\n\r\n/// @title Permissionless pool actions\r\n/// @notice Contains pool methods that can be called by anyone\r\ninterface IUniswapV3PoolActions {\r\n    /// @notice Sets the initial price for the pool\r\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\r\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\r\n    function initialize(uint160 sqrtPriceX96) external;\r\n\r\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\r\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\r\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\r\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\r\n    /// @param recipient The address for which the liquidity will be created\r\n    /// @param tickLower The lower tick of the position in which to add liquidity\r\n    /// @param tickUpper The upper tick of the position in which to add liquidity\r\n    /// @param amount The amount of liquidity to mint\r\n    /// @param data Any data that should be passed through to the callback\r\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\r\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\r\n    function mint(\r\n        address recipient,\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 amount,\r\n        bytes calldata data\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    /// @notice Collects tokens owed to a position\r\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\r\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\r\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\r\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\r\n    /// @param recipient The address which should receive the fees collected\r\n    /// @param tickLower The lower tick of the position for which to collect fees\r\n    /// @param tickUpper The upper tick of the position for which to collect fees\r\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\r\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\r\n    /// @return amount0 The amount of fees collected in token0\r\n    /// @return amount1 The amount of fees collected in token1\r\n    function collect(\r\n        address recipient,\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 amount0Requested,\r\n        uint128 amount1Requested\r\n    ) external returns (uint128 amount0, uint128 amount1);\r\n\r\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\r\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\r\n    /// @dev Fees must be collected separately via a call to #collect\r\n    /// @param tickLower The lower tick of the position for which to burn liquidity\r\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\r\n    /// @param amount How much liquidity to burn\r\n    /// @return amount0 The amount of token0 sent to the recipient\r\n    /// @return amount1 The amount of token1 sent to the recipient\r\n    function burn(\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 amount\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    /// @notice Swap token0 for token1, or token1 for token0\r\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\r\n    /// @param recipient The address to receive the output of the swap\r\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\r\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\r\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\r\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\r\n    /// @param data Any data to be passed through to the callback\r\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\r\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\r\n    function swap(\r\n        address recipient,\r\n        bool zeroForOne,\r\n        int256 amountSpecified,\r\n        uint160 sqrtPriceLimitX96,\r\n        bytes calldata data\r\n    ) external returns (int256 amount0, int256 amount1);\r\n\r\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\r\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\r\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\r\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\r\n    /// @param recipient The address which will receive the token0 and token1 amounts\r\n    /// @param amount0 The amount of token0 to send\r\n    /// @param amount1 The amount of token1 to send\r\n    /// @param data Any data to be passed through to the callback\r\n    function flash(\r\n        address recipient,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\r\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\r\n    /// the input observationCardinalityNext.\r\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\r\n    function increaseObservationCardinalityNext(\r\n        uint16 observationCardinalityNext\r\n    ) external;\r\n}\r\n\r\n// File: IUniswapV3PoolDerivedState.sol\r\n\r\n/// @title Pool state that is not stored\r\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\r\n/// blockchain. The functions here may have variable gas costs.\r\ninterface IUniswapV3PoolDerivedState {\r\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\r\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\r\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\r\n    /// you must call it with secondsAgos = [3600, 0].\r\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\r\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\r\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\r\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\r\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\r\n    /// timestamp\r\n    function observe(uint32[] calldata secondsAgos)\r\n        external\r\n        view\r\n        returns (\r\n            int56[] memory tickCumulatives,\r\n            uint160[] memory secondsPerLiquidityCumulativeX128s\r\n        );\r\n\r\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\r\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\r\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\r\n    /// snapshot is taken and the second snapshot is taken.\r\n    /// @param tickLower The lower tick of the range\r\n    /// @param tickUpper The upper tick of the range\r\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\r\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\r\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\r\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\r\n        external\r\n        view\r\n        returns (\r\n            int56 tickCumulativeInside,\r\n            uint160 secondsPerLiquidityInsideX128,\r\n            uint32 secondsInside\r\n        );\r\n}\r\n\r\n// File: IUniswapV3PoolErrors.sol\r\n\r\n/// @title Errors emitted by a pool\r\n/// @notice Contains all events emitted by the pool\r\ninterface IUniswapV3PoolErrors {\r\n    error LOK();\r\n    error TLU();\r\n    error TLM();\r\n    error TUM();\r\n    error AI();\r\n    error M0();\r\n    error M1();\r\n    error AS();\r\n    error IIA();\r\n    error L();\r\n    error F0();\r\n    error F1();\r\n}\r\n\r\n// File: IUniswapV3PoolEvents.sol\r\n\r\n/// @title Events emitted by a pool\r\n/// @notice Contains all events emitted by the pool\r\ninterface IUniswapV3PoolEvents {\r\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\r\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\r\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\r\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\r\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\r\n\r\n    /// @notice Emitted when liquidity is minted for a given position\r\n    /// @param sender The address that minted the liquidity\r\n    /// @param owner The owner of the position and recipient of any minted liquidity\r\n    /// @param tickLower The lower tick of the position\r\n    /// @param tickUpper The upper tick of the position\r\n    /// @param amount The amount of liquidity minted to the position range\r\n    /// @param amount0 How much token0 was required for the minted liquidity\r\n    /// @param amount1 How much token1 was required for the minted liquidity\r\n    event Mint(\r\n        address sender,\r\n        address indexed owner,\r\n        int24 indexed tickLower,\r\n        int24 indexed tickUpper,\r\n        uint128 amount,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    );\r\n\r\n    /// @notice Emitted when fees are collected by the owner of a position\r\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\r\n    /// @param owner The owner of the position for which fees are collected\r\n    /// @param tickLower The lower tick of the position\r\n    /// @param tickUpper The upper tick of the position\r\n    /// @param amount0 The amount of token0 fees collected\r\n    /// @param amount1 The amount of token1 fees collected\r\n    event Collect(\r\n        address indexed owner,\r\n        address recipient,\r\n        int24 indexed tickLower,\r\n        int24 indexed tickUpper,\r\n        uint128 amount0,\r\n        uint128 amount1\r\n    );\r\n\r\n    /// @notice Emitted when a position's liquidity is removed\r\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\r\n    /// @param owner The owner of the position for which liquidity is removed\r\n    /// @param tickLower The lower tick of the position\r\n    /// @param tickUpper The upper tick of the position\r\n    /// @param amount The amount of liquidity to remove\r\n    /// @param amount0 The amount of token0 withdrawn\r\n    /// @param amount1 The amount of token1 withdrawn\r\n    event Burn(\r\n        address indexed owner,\r\n        int24 indexed tickLower,\r\n        int24 indexed tickUpper,\r\n        uint128 amount,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    );\r\n\r\n    /// @notice Emitted by the pool for any swaps between token0 and token1\r\n    /// @param sender The address that initiated the swap call, and that received the callback\r\n    /// @param recipient The address that received the output of the swap\r\n    /// @param amount0 The delta of the token0 balance of the pool\r\n    /// @param amount1 The delta of the token1 balance of the pool\r\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\r\n    /// @param liquidity The liquidity of the pool after the swap\r\n    /// @param tick The log base 1.0001 of price of the pool after the swap\r\n    event Swap(\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        int256 amount0,\r\n        int256 amount1,\r\n        uint160 sqrtPriceX96,\r\n        uint128 liquidity,\r\n        int24 tick\r\n    );\r\n\r\n    /// @notice Emitted by the pool for any flashes of token0/token1\r\n    /// @param sender The address that initiated the swap call, and that received the callback\r\n    /// @param recipient The address that received the tokens from flash\r\n    /// @param amount0 The amount of token0 that was flashed\r\n    /// @param amount1 The amount of token1 that was flashed\r\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\r\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\r\n    event Flash(\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        uint256 paid0,\r\n        uint256 paid1\r\n    );\r\n\r\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\r\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\r\n    /// just before a mint/swap/burn.\r\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\r\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\r\n    event IncreaseObservationCardinalityNext(\r\n        uint16 observationCardinalityNextOld,\r\n        uint16 observationCardinalityNextNew\r\n    );\r\n\r\n    /// @notice Emitted when the protocol fee is changed by the pool\r\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\r\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\r\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\r\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\r\n    event SetFeeProtocol(\r\n        uint8 feeProtocol0Old,\r\n        uint8 feeProtocol1Old,\r\n        uint8 feeProtocol0New,\r\n        uint8 feeProtocol1New\r\n    );\r\n\r\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\r\n    /// @param sender The address that collects the protocol fees\r\n    /// @param recipient The address that receives the collected protocol fees\r\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\r\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\r\n    event CollectProtocol(\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        uint128 amount0,\r\n        uint128 amount1\r\n    );\r\n}\r\n\r\n// File: IUniswapV3PoolImmutables.sol\r\n\r\n/// @title Pool state that never changes\r\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\r\ninterface IUniswapV3PoolImmutables {\r\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\r\n    /// @return The contract address\r\n    function factory() external view returns (address);\r\n\r\n    /// @notice The first of the two tokens of the pool, sorted by address\r\n    /// @return The token contract address\r\n    function token0() external view returns (address);\r\n\r\n    /// @notice The second of the two tokens of the pool, sorted by address\r\n    /// @return The token contract address\r\n    function token1() external view returns (address);\r\n\r\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\r\n    /// @return The fee\r\n    function fee() external view returns (uint24);\r\n\r\n    /// @notice The pool tick spacing\r\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\r\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\r\n    /// This value is an int24 to avoid casting even though it is always positive.\r\n    /// @return The tick spacing\r\n    function tickSpacing() external view returns (int24);\r\n\r\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\r\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\r\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\r\n    /// @return The max amount of liquidity per tick\r\n    function maxLiquidityPerTick() external view returns (uint128);\r\n}\r\n\r\n// File: IUniswapV3PoolOwnerActions.sol\r\n\r\n/// @title Permissioned pool actions\r\n/// @notice Contains pool methods that may only be called by the factory owner\r\ninterface IUniswapV3PoolOwnerActions {\r\n    /// @notice Set the denominator of the protocol's % share of the fees\r\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\r\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\r\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\r\n\r\n    /// @notice Collect the protocol fee accrued to the pool\r\n    /// @param recipient The address to which collected protocol fees should be sent\r\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\r\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\r\n    /// @return amount0 The protocol fee collected in token0\r\n    /// @return amount1 The protocol fee collected in token1\r\n    function collectProtocol(\r\n        address recipient,\r\n        uint128 amount0Requested,\r\n        uint128 amount1Requested\r\n    ) external returns (uint128 amount0, uint128 amount1);\r\n}\r\n\r\n// File: IUniswapV3PoolState.sol\r\n\r\n/// @title Pool state that can change\r\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\r\n/// per transaction\r\ninterface IUniswapV3PoolState {\r\n    struct Slot0 {\r\n        // the current price\r\n        uint160 sqrtPriceX96;\r\n        // the current tick\r\n        int24 tick;\r\n        // the most-recently updated index of the observations array\r\n        uint16 observationIndex;\r\n        // the current maximum number of observations that are being stored\r\n        uint16 observationCardinality;\r\n        // the next maximum number of observations to store, triggered in observations.write\r\n        uint16 observationCardinalityNext;\r\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\r\n        // represented as an integer denominator (1/x)%\r\n        uint8 feeProtocol;\r\n        // whether the pool is locked\r\n        bool unlocked;\r\n    }\r\n\r\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\r\n    /// when accessed externally.\r\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\r\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\r\n    /// unlocked Whether the pool is currently locked to reentrancy\r\n    function slot0() external view returns (Slot0 memory);\r\n\r\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\r\n    /// @dev This value can overflow the uint256\r\n    function feeGrowthGlobal0X128() external view returns (uint256);\r\n\r\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\r\n    /// @dev This value can overflow the uint256\r\n    function feeGrowthGlobal1X128() external view returns (uint256);\r\n\r\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\r\n    /// @dev Protocol fees will never exceed uint128 max in either token\r\n    function protocolFees()\r\n        external\r\n        view\r\n        returns (uint128 token0, uint128 token1);\r\n\r\n    /// @notice The currently in range liquidity available to the pool\r\n    /// @dev This value has no relationship to the total liquidity across all ticks\r\n    /// @return The liquidity at the current price of the pool\r\n    function liquidity() external view returns (uint128);\r\n\r\n    struct TickInfo {\r\n        // the total position liquidity that references this tick\r\n        uint128 liquidityGross;\r\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\r\n        int128 liquidityNet;\r\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\r\n        // only has relative meaning, not absolute \u2014 the value depends on when the tick is initialized\r\n        uint256 feeGrowthOutside0X128;\r\n        uint256 feeGrowthOutside1X128;\r\n        // the cumulative tick value on the other side of the tick\r\n        int56 tickCumulativeOutside;\r\n        // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\r\n        // only has relative meaning, not absolute \u2014 the value depends on when the tick is initialized\r\n        uint160 secondsPerLiquidityOutsideX128;\r\n        // the seconds spent on the other side of the tick (relative to the current tick)\r\n        // only has relative meaning, not absolute \u2014 the value depends on when the tick is initialized\r\n        uint32 secondsOutside;\r\n        // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\r\n        // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\r\n        bool initialized;\r\n    }\r\n\r\n    /// @notice Look up information about a specific tick in the pool\r\n    function ticks(int24 tick) external view returns (TickInfo memory);\r\n\r\n    struct PositionInfo {\r\n        // the amount of liquidity owned by this position\r\n        uint128 liquidity;\r\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\r\n        uint256 feeGrowthInside0LastX128;\r\n        uint256 feeGrowthInside1LastX128;\r\n        // the fees owed to the position owner in token0/token1\r\n        uint128 tokensOwed0;\r\n        uint128 tokensOwed1;\r\n    }\r\n\r\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\r\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\r\n\r\n    /// @notice Returns the information about a position by the position's key\r\n    function positions(bytes32 key) external view returns (PositionInfo memory);\r\n\r\n    /// @notice Returns data about a specific observation index\r\n    /// @param index The element of the observations array to fetch\r\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\r\n    /// ago, rather than at a specific index in the array.\r\n    /// @return blockTimestamp The timestamp of the observation,\r\n    /// @return tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\r\n    /// @return secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\r\n    /// @return initialized whether the observation has been initialized and the values are safe to use\r\n    function observations(uint256 index)\r\n        external\r\n        view\r\n        returns (\r\n            uint32 blockTimestamp,\r\n            int56 tickCumulative,\r\n            uint160 secondsPerLiquidityCumulativeX128,\r\n            bool initialized\r\n        );\r\n}\r\n\r\n// File: Math.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a / b + (a % b == 0 ? 0 : 1);\r\n    }\r\n}\r\n\r\n// File: SafeCast.sol\r\n\r\n/// @title Safe casting methods\r\n/// @notice Contains methods for safely casting between types\r\nlibrary SafeCast {\r\n    /// @notice Cast a uint256 to a uint160, revert on overflow\r\n    /// @param y The uint256 to be downcasted\r\n    /// @return z The downcasted integer, now type uint160\r\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\r\n        require((z = uint160(y)) == y);\r\n    }\r\n\r\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\r\n    /// @param y The int256 to be downcasted\r\n    /// @return z The downcasted integer, now type int128\r\n    function toInt128(int256 y) internal pure returns (int128 z) {\r\n        require((z = int128(y)) == y);\r\n    }\r\n\r\n    /// @notice Cast a uint256 to a int256, revert on overflow\r\n    /// @param y The uint256 to be casted\r\n    /// @return z The casted integer, now type int256\r\n    function toInt256(uint256 y) internal pure returns (int256 z) {\r\n        require(y < 2**255);\r\n        z = int256(y);\r\n    }\r\n}\r\n\r\n// File: TickMath.sol\r\n\r\n/// @title Math library for computing sqrt prices from ticks and vice versa\r\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\r\n/// prices between 2**-128 and 2**128\r\nlibrary TickMath {\r\n    error T();\r\n    error R();\r\n\r\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\r\n    int24 internal constant MIN_TICK = -887272;\r\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\r\n    int24 internal constant MAX_TICK = -MIN_TICK;\r\n\r\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\r\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\r\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\r\n    uint160 internal constant MAX_SQRT_RATIO =\r\n        1461446703485210103287273052203988822378723970342;\r\n\r\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\r\n    /// @dev Throws if |tick| > max tick\r\n    /// @param tick The input tick for the above formula\r\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\r\n    /// at the given tick\r\n    function getSqrtRatioAtTick(int24 tick)\r\n        internal\r\n        pure\r\n        returns (uint160 sqrtPriceX96)\r\n    {\r\n        unchecked {\r\n            uint256 absTick = tick < 0\r\n                ? uint256(-int256(tick))\r\n                : uint256(int256(tick));\r\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\r\n\r\n            uint256 ratio = absTick & 0x1 != 0\r\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\r\n                : 0x100000000000000000000000000000000;\r\n            if (absTick & 0x2 != 0)\r\n                ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\r\n            if (absTick & 0x4 != 0)\r\n                ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\r\n            if (absTick & 0x8 != 0)\r\n                ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\r\n            if (absTick & 0x10 != 0)\r\n                ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\r\n            if (absTick & 0x20 != 0)\r\n                ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\r\n            if (absTick & 0x40 != 0)\r\n                ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\r\n            if (absTick & 0x80 != 0)\r\n                ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\r\n            if (absTick & 0x100 != 0)\r\n                ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\r\n            if (absTick & 0x200 != 0)\r\n                ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\r\n            if (absTick & 0x400 != 0)\r\n                ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\r\n            if (absTick & 0x800 != 0)\r\n                ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\r\n            if (absTick & 0x1000 != 0)\r\n                ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\r\n            if (absTick & 0x2000 != 0)\r\n                ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\r\n            if (absTick & 0x4000 != 0)\r\n                ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\r\n            if (absTick & 0x8000 != 0)\r\n                ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\r\n            if (absTick & 0x10000 != 0)\r\n                ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\r\n            if (absTick & 0x20000 != 0)\r\n                ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\r\n            if (absTick & 0x40000 != 0)\r\n                ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\r\n            if (absTick & 0x80000 != 0)\r\n                ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\r\n\r\n            if (tick > 0) ratio = type(uint256).max / ratio;\r\n\r\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\r\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\r\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\r\n            sqrtPriceX96 = uint160(\r\n                (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\r\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\r\n    /// ever return.\r\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\r\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\r\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96)\r\n        internal\r\n        pure\r\n        returns (int24 tick)\r\n    {\r\n        unchecked {\r\n            // second inequality must be < because the price can never reach the price at the max tick\r\n            if (\r\n                !(sqrtPriceX96 >= MIN_SQRT_RATIO &&\r\n                    sqrtPriceX96 < MAX_SQRT_RATIO)\r\n            ) revert R();\r\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\r\n\r\n            uint256 r = ratio;\r\n            uint256 msb = 0;\r\n\r\n            assembly {\r\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\r\n                msb := or(msb, f)\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\r\n                msb := or(msb, f)\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                let f := shl(5, gt(r, 0xFFFFFFFF))\r\n                msb := or(msb, f)\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                let f := shl(4, gt(r, 0xFFFF))\r\n                msb := or(msb, f)\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                let f := shl(3, gt(r, 0xFF))\r\n                msb := or(msb, f)\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                let f := shl(2, gt(r, 0xF))\r\n                msb := or(msb, f)\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                let f := shl(1, gt(r, 0x3))\r\n                msb := or(msb, f)\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                let f := gt(r, 0x1)\r\n                msb := or(msb, f)\r\n            }\r\n\r\n            if (msb >= 128) r = ratio >> (msb - 127);\r\n            else r = ratio << (127 - msb);\r\n\r\n            int256 log_2 = (int256(msb) - 128) << 64;\r\n\r\n            assembly {\r\n                r := shr(127, mul(r, r))\r\n                let f := shr(128, r)\r\n                log_2 := or(log_2, shl(63, f))\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                r := shr(127, mul(r, r))\r\n                let f := shr(128, r)\r\n                log_2 := or(log_2, shl(62, f))\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                r := shr(127, mul(r, r))\r\n                let f := shr(128, r)\r\n                log_2 := or(log_2, shl(61, f))\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                r := shr(127, mul(r, r))\r\n                let f := shr(128, r)\r\n                log_2 := or(log_2, shl(60, f))\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                r := shr(127, mul(r, r))\r\n                let f := shr(128, r)\r\n                log_2 := or(log_2, shl(59, f))\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                r := shr(127, mul(r, r))\r\n                let f := shr(128, r)\r\n                log_2 := or(log_2, shl(58, f))\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                r := shr(127, mul(r, r))\r\n                let f := shr(128, r)\r\n                log_2 := or(log_2, shl(57, f))\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                r := shr(127, mul(r, r))\r\n                let f := shr(128, r)\r\n                log_2 := or(log_2, shl(56, f))\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                r := shr(127, mul(r, r))\r\n                let f := shr(128, r)\r\n                log_2 := or(log_2, shl(55, f))\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                r := shr(127, mul(r, r))\r\n                let f := shr(128, r)\r\n                log_2 := or(log_2, shl(54, f))\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                r := shr(127, mul(r, r))\r\n                let f := shr(128, r)\r\n                log_2 := or(log_2, shl(53, f))\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                r := shr(127, mul(r, r))\r\n                let f := shr(128, r)\r\n                log_2 := or(log_2, shl(52, f))\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                r := shr(127, mul(r, r))\r\n                let f := shr(128, r)\r\n                log_2 := or(log_2, shl(51, f))\r\n                r := shr(f, r)\r\n            }\r\n            assembly {\r\n                r := shr(127, mul(r, r))\r\n                let f := shr(128, r)\r\n                log_2 := or(log_2, shl(50, f))\r\n            }\r\n\r\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\r\n\r\n            int24 tickLow = int24(\r\n                (log_sqrt10001 - 3402992956809132418596140100660247210) >> 128\r\n            );\r\n            int24 tickHi = int24(\r\n                (log_sqrt10001 + 291339464771989622907027621153398088495) >> 128\r\n            );\r\n\r\n            tick = tickLow == tickHi\r\n                ? tickLow\r\n                : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96\r\n                ? tickHi\r\n                : tickLow;\r\n        }\r\n    }\r\n}\r\n\r\n// File: UnsafeMath.sol\r\n\r\n/// @title Math functions that do not check inputs or outputs\r\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\r\nlibrary UnsafeMath {\r\n    /// @notice Returns ceil(x / y)\r\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\r\n    /// @param x The dividend\r\n    /// @param y The divisor\r\n    /// @return z The quotient, ceil(x / y)\r\n    function divRoundingUp(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256 z)\r\n    {\r\n        assembly {\r\n            z := add(div(x, y), gt(mod(x, y), 0))\r\n        }\r\n    }\r\n}\r\n\r\n// File: IERC20Extended.sol\r\n\r\ninterface IERC20Extended is IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n}\r\n\r\n// File: IERC20Metadata.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: IUniswapV3Pool.sol\r\n\r\n/// @title The interface for a Uniswap V3 Pool\r\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\r\n/// to the ERC20 specification\r\n/// @dev The pool interface is broken up into many smaller pieces\r\ninterface IUniswapV3Pool is\r\n    IUniswapV3PoolImmutables,\r\n    IUniswapV3PoolState,\r\n    IUniswapV3PoolDerivedState,\r\n    IUniswapV3PoolActions,\r\n    IUniswapV3PoolOwnerActions,\r\n    IUniswapV3PoolErrors,\r\n    IUniswapV3PoolEvents\r\n{\r\n\r\n}\r\n\r\n// File: LiquidityAmounts.sol\r\n\r\n/// @title Liquidity amount functions\r\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\r\nlibrary LiquidityAmounts {\r\n    /// @notice Downcasts uint256 to uint128\r\n    /// @param x The uint258 to be downcasted\r\n    /// @return y The passed value, downcasted to uint128\r\n    function toUint128(uint256 x) private pure returns (uint128 y) {\r\n        require((y = uint128(x)) == x);\r\n    }\r\n\r\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\r\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param amount0 The amount0 being sent in\r\n    /// @return liquidity The amount of returned liquidity\r\n    function getLiquidityForAmount0(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96)\r\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n        uint256 intermediate = FullMath.mulDiv(\r\n            sqrtRatioAX96,\r\n            sqrtRatioBX96,\r\n            FixedPoint96.Q96\r\n        );\r\n        return\r\n            toUint128(\r\n                FullMath.mulDiv(\r\n                    amount0,\r\n                    intermediate,\r\n                    sqrtRatioBX96 - sqrtRatioAX96\r\n                )\r\n            );\r\n    }\r\n\r\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\r\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param amount1 The amount1 being sent in\r\n    /// @return liquidity The amount of returned liquidity\r\n    function getLiquidityForAmount1(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount1\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96)\r\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n        return\r\n            toUint128(\r\n                FullMath.mulDiv(\r\n                    amount1,\r\n                    FixedPoint96.Q96,\r\n                    sqrtRatioBX96 - sqrtRatioAX96\r\n                )\r\n            );\r\n    }\r\n\r\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\r\n    /// pool prices and the prices at the tick boundaries\r\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param amount0 The amount of token0 being sent in\r\n    /// @param amount1 The amount of token1 being sent in\r\n    /// @return liquidity The maximum amount of liquidity received\r\n    function getLiquidityForAmounts(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96)\r\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\r\n            liquidity = getLiquidityForAmount0(\r\n                sqrtRatioAX96,\r\n                sqrtRatioBX96,\r\n                amount0\r\n            );\r\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\r\n            uint128 liquidity0 = getLiquidityForAmount0(\r\n                sqrtRatioX96,\r\n                sqrtRatioBX96,\r\n                amount0\r\n            );\r\n            uint128 liquidity1 = getLiquidityForAmount1(\r\n                sqrtRatioAX96,\r\n                sqrtRatioX96,\r\n                amount1\r\n            );\r\n\r\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\r\n        } else {\r\n            liquidity = getLiquidityForAmount1(\r\n                sqrtRatioAX96,\r\n                sqrtRatioBX96,\r\n                amount1\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param liquidity The liquidity being valued\r\n    /// @return amount0 The amount of token0\r\n    function getAmount0ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount0) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96)\r\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        return\r\n            FullMath.mulDiv(\r\n                uint256(liquidity) << FixedPoint96.RESOLUTION,\r\n                sqrtRatioBX96 - sqrtRatioAX96,\r\n                sqrtRatioBX96\r\n            ) / sqrtRatioAX96;\r\n    }\r\n\r\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param liquidity The liquidity being valued\r\n    /// @return amount1 The amount of token1\r\n    function getAmount1ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount1) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96)\r\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        return\r\n            FullMath.mulDiv(\r\n                liquidity,\r\n                sqrtRatioBX96 - sqrtRatioAX96,\r\n                FixedPoint96.Q96\r\n            );\r\n    }\r\n\r\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\r\n    /// pool prices and the prices at the tick boundaries\r\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param liquidity The liquidity being valued\r\n    /// @return amount0 The amount of token0\r\n    /// @return amount1 The amount of token1\r\n    function getAmountsForLiquidity(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96)\r\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\r\n            amount0 = getAmount0ForLiquidity(\r\n                sqrtRatioAX96,\r\n                sqrtRatioBX96,\r\n                liquidity\r\n            );\r\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\r\n            amount0 = getAmount0ForLiquidity(\r\n                sqrtRatioX96,\r\n                sqrtRatioBX96,\r\n                liquidity\r\n            );\r\n            amount1 = getAmount1ForLiquidity(\r\n                sqrtRatioAX96,\r\n                sqrtRatioX96,\r\n                liquidity\r\n            );\r\n        } else {\r\n            amount1 = getAmount1ForLiquidity(\r\n                sqrtRatioAX96,\r\n                sqrtRatioBX96,\r\n                liquidity\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File: SafeERC20.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: SqrtPriceMath.sol\r\n\r\n/// @title Functions based on Q64.96 sqrt price and liquidity\r\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\r\nlibrary SqrtPriceMath {\r\n    using SafeCast for uint256;\r\n\r\n    /// @notice Gets the next sqrt price given a delta of token0\r\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\r\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\r\n    /// price less in order to not send too much output.\r\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\r\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\r\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\r\n    /// @param liquidity The amount of usable liquidity\r\n    /// @param amount How much of token0 to add or remove from virtual reserves\r\n    /// @param add Whether to add or remove the amount of token0\r\n    /// @return The price after adding or removing amount, depending on add\r\n    function getNextSqrtPriceFromAmount0RoundingUp(\r\n        uint160 sqrtPX96,\r\n        uint128 liquidity,\r\n        uint256 amount,\r\n        bool add\r\n    ) internal pure returns (uint160) {\r\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\r\n        if (amount == 0) return sqrtPX96;\r\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\r\n\r\n        if (add) {\r\n            unchecked {\r\n                uint256 product;\r\n                if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\r\n                    uint256 denominator = numerator1 + product;\r\n                    if (denominator >= numerator1)\r\n                        // always fits in 160 bits\r\n                        return\r\n                            uint160(\r\n                                FullMath.mulDivRoundingUp(\r\n                                    numerator1,\r\n                                    sqrtPX96,\r\n                                    denominator\r\n                                )\r\n                            );\r\n                }\r\n            }\r\n            // denominator is checked for overflow\r\n            return\r\n                uint160(\r\n                    UnsafeMath.divRoundingUp(\r\n                        numerator1,\r\n                        (numerator1 / sqrtPX96) + amount\r\n                    )\r\n                );\r\n        } else {\r\n            unchecked {\r\n                uint256 product;\r\n                // if the product overflows, we know the denominator underflows\r\n                // in addition, we must check that the denominator does not underflow\r\n                require(\r\n                    (product = amount * sqrtPX96) / amount == sqrtPX96 &&\r\n                        numerator1 > product\r\n                );\r\n                uint256 denominator = numerator1 - product;\r\n                return\r\n                    FullMath\r\n                        .mulDivRoundingUp(numerator1, sqrtPX96, denominator)\r\n                        .toUint160();\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Gets the next sqrt price given a delta of token1\r\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\r\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\r\n    /// price less in order to not send too much output.\r\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\r\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\r\n    /// @param liquidity The amount of usable liquidity\r\n    /// @param amount How much of token1 to add, or remove, from virtual reserves\r\n    /// @param add Whether to add, or remove, the amount of token1\r\n    /// @return The price after adding or removing `amount`\r\n    function getNextSqrtPriceFromAmount1RoundingDown(\r\n        uint160 sqrtPX96,\r\n        uint128 liquidity,\r\n        uint256 amount,\r\n        bool add\r\n    ) internal pure returns (uint160) {\r\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\r\n        // in both cases, avoid a mulDiv for most inputs\r\n        if (add) {\r\n            uint256 quotient = (\r\n                amount <= type(uint160).max\r\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\r\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\r\n            );\r\n\r\n            return (uint256(sqrtPX96) + quotient).toUint160();\r\n        } else {\r\n            uint256 quotient = (\r\n                amount <= type(uint160).max\r\n                    ? UnsafeMath.divRoundingUp(\r\n                        amount << FixedPoint96.RESOLUTION,\r\n                        liquidity\r\n                    )\r\n                    : FullMath.mulDivRoundingUp(\r\n                        amount,\r\n                        FixedPoint96.Q96,\r\n                        liquidity\r\n                    )\r\n            );\r\n\r\n            require(sqrtPX96 > quotient);\r\n            // always fits 160 bits\r\n            unchecked {\r\n                return uint160(sqrtPX96 - quotient);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Gets the next sqrt price given an input amount of token0 or token1\r\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\r\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\r\n    /// @param liquidity The amount of usable liquidity\r\n    /// @param amountIn How much of token0, or token1, is being swapped in\r\n    /// @param zeroForOne Whether the amount in is token0 or token1\r\n    /// @return sqrtQX96 The price after adding the input amount to token0 or token1\r\n    function getNextSqrtPriceFromInput(\r\n        uint160 sqrtPX96,\r\n        uint128 liquidity,\r\n        uint256 amountIn,\r\n        bool zeroForOne\r\n    ) internal pure returns (uint160 sqrtQX96) {\r\n        require(sqrtPX96 > 0);\r\n        require(liquidity > 0);\r\n\r\n        // round to make sure that we don't pass the target price\r\n        return\r\n            zeroForOne\r\n                ? getNextSqrtPriceFromAmount0RoundingUp(\r\n                    sqrtPX96,\r\n                    liquidity,\r\n                    amountIn,\r\n                    true\r\n                )\r\n                : getNextSqrtPriceFromAmount1RoundingDown(\r\n                    sqrtPX96,\r\n                    liquidity,\r\n                    amountIn,\r\n                    true\r\n                );\r\n    }\r\n\r\n    /// @notice Gets the next sqrt price given an output amount of token0 or token1\r\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\r\n    /// @param sqrtPX96 The starting price before accounting for the output amount\r\n    /// @param liquidity The amount of usable liquidity\r\n    /// @param amountOut How much of token0, or token1, is being swapped out\r\n    /// @param zeroForOne Whether the amount out is token0 or token1\r\n    /// @return sqrtQX96 The price after removing the output amount of token0 or token1\r\n    function getNextSqrtPriceFromOutput(\r\n        uint160 sqrtPX96,\r\n        uint128 liquidity,\r\n        uint256 amountOut,\r\n        bool zeroForOne\r\n    ) internal pure returns (uint160 sqrtQX96) {\r\n        require(sqrtPX96 > 0);\r\n        require(liquidity > 0);\r\n\r\n        // round to make sure that we pass the target price\r\n        return\r\n            zeroForOne\r\n                ? getNextSqrtPriceFromAmount1RoundingDown(\r\n                    sqrtPX96,\r\n                    liquidity,\r\n                    amountOut,\r\n                    false\r\n                )\r\n                : getNextSqrtPriceFromAmount0RoundingUp(\r\n                    sqrtPX96,\r\n                    liquidity,\r\n                    amountOut,\r\n                    false\r\n                );\r\n    }\r\n\r\n    /// @notice Gets the amount0 delta between two prices\r\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\r\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\r\n    /// @param sqrtRatioAX96 A sqrt price\r\n    /// @param sqrtRatioBX96 Another sqrt price\r\n    /// @param liquidity The amount of usable liquidity\r\n    /// @param roundUp Whether to round the amount up or down\r\n    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices\r\n    function getAmount0Delta(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity,\r\n        bool roundUp\r\n    ) internal pure returns (uint256 amount0) {\r\n        unchecked {\r\n            if (sqrtRatioAX96 > sqrtRatioBX96)\r\n                (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n            uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\r\n            uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\r\n\r\n            require(sqrtRatioAX96 > 0);\r\n\r\n            return\r\n                roundUp\r\n                    ? UnsafeMath.divRoundingUp(\r\n                        FullMath.mulDivRoundingUp(\r\n                            numerator1,\r\n                            numerator2,\r\n                            sqrtRatioBX96\r\n                        ),\r\n                        sqrtRatioAX96\r\n                    )\r\n                    : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) /\r\n                        sqrtRatioAX96;\r\n        }\r\n    }\r\n\r\n    /// @notice Gets the amount1 delta between two prices\r\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\r\n    /// @param sqrtRatioAX96 A sqrt price\r\n    /// @param sqrtRatioBX96 Another sqrt price\r\n    /// @param liquidity The amount of usable liquidity\r\n    /// @param roundUp Whether to round the amount up, or down\r\n    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\r\n    function getAmount1Delta(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity,\r\n        bool roundUp\r\n    ) internal pure returns (uint256 amount1) {\r\n        unchecked {\r\n            if (sqrtRatioAX96 > sqrtRatioBX96)\r\n                (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n            return\r\n                roundUp\r\n                    ? FullMath.mulDivRoundingUp(\r\n                        liquidity,\r\n                        sqrtRatioBX96 - sqrtRatioAX96,\r\n                        FixedPoint96.Q96\r\n                    )\r\n                    : FullMath.mulDiv(\r\n                        liquidity,\r\n                        sqrtRatioBX96 - sqrtRatioAX96,\r\n                        FixedPoint96.Q96\r\n                    );\r\n        }\r\n    }\r\n\r\n    /// @notice Helper that gets signed token0 delta\r\n    /// @param sqrtRatioAX96 A sqrt price\r\n    /// @param sqrtRatioBX96 Another sqrt price\r\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\r\n    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices\r\n    function getAmount0Delta(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        int128 liquidity\r\n    ) internal pure returns (int256 amount0) {\r\n        unchecked {\r\n            return\r\n                liquidity < 0\r\n                    ? -getAmount0Delta(\r\n                        sqrtRatioAX96,\r\n                        sqrtRatioBX96,\r\n                        uint128(-liquidity),\r\n                        false\r\n                    ).toInt256()\r\n                    : getAmount0Delta(\r\n                        sqrtRatioAX96,\r\n                        sqrtRatioBX96,\r\n                        uint128(liquidity),\r\n                        true\r\n                    ).toInt256();\r\n        }\r\n    }\r\n\r\n    /// @notice Helper that gets signed token1 delta\r\n    /// @param sqrtRatioAX96 A sqrt price\r\n    /// @param sqrtRatioBX96 Another sqrt price\r\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\r\n    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices\r\n    function getAmount1Delta(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        int128 liquidity\r\n    ) internal pure returns (int256 amount1) {\r\n        unchecked {\r\n            return\r\n                liquidity < 0\r\n                    ? -getAmount1Delta(\r\n                        sqrtRatioAX96,\r\n                        sqrtRatioBX96,\r\n                        uint128(-liquidity),\r\n                        false\r\n                    ).toInt256()\r\n                    : getAmount1Delta(\r\n                        sqrtRatioAX96,\r\n                        sqrtRatioBX96,\r\n                        uint128(liquidity),\r\n                        true\r\n                    ).toInt256();\r\n        }\r\n    }\r\n}\r\n\r\n// File: TickBitmapExtended.sol\r\n\r\n/// @title Tick bitmap extended functions\r\n/// @dev Uses the bitmap from UniswapV3Pool\r\nlibrary TickBitmapExtended {\r\n    /// @notice Computes the position in the mapping where the initialized bit for a tick lives\r\n    /// @param tick The tick for which to compute the position\r\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\r\n    /// @return bitPos The bit position in the word where the flag is stored\r\n    function position(int24 tick)\r\n        private\r\n        pure\r\n        returns (int16 wordPos, uint8 bitPos)\r\n    {\r\n        wordPos = int16(tick >> 8);\r\n        bitPos = uint8(uint24(tick % 256));\r\n    }\r\n\r\n    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\r\n    /// to the left (less than or equal to) or right (greater than) of the given tick\r\n    /// @param self The mapping in which to compute the next initialized tick\r\n    /// @param tick The starting tick\r\n    /// @param tickSpacing The spacing between usable ticks\r\n    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\r\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\r\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\r\n    function nextInitializedTickWithinOneWord(\r\n        function(int16) external view returns (uint256) self,\r\n        int24 tick,\r\n        int24 tickSpacing,\r\n        bool lte\r\n    ) internal view returns (int24 next, bool initialized) {\r\n        int24 compressed = tick / tickSpacing;\r\n        if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\r\n\r\n        if (lte) {\r\n            (int16 wordPos, uint8 bitPos) = position(compressed);\r\n            // all the 1s at or to the right of the current bitPos\r\n            uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\r\n            uint256 masked = self(wordPos) & mask;\r\n\r\n            // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\r\n            initialized = masked != 0;\r\n            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\r\n            next = initialized\r\n                ? (compressed -\r\n                    int24(\r\n                        uint24(bitPos - BitMath.mostSignificantBit(masked))\r\n                    )) * tickSpacing\r\n                : (compressed - int24(uint24(bitPos))) * tickSpacing;\r\n        } else {\r\n            // start from the word of the next tick, since the current tick state doesn't matter\r\n            (int16 wordPos, uint8 bitPos) = position(compressed + 1);\r\n            // all the 1s at or to the left of the bitPos\r\n            uint256 mask = ~((1 << bitPos) - 1);\r\n            uint256 masked = self(wordPos) & mask;\r\n\r\n            // if there are no initialized ticks to the left of the current tick, return leftmost in the word\r\n            initialized = masked != 0;\r\n            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\r\n            next = initialized\r\n                ? (compressed +\r\n                    1 +\r\n                    int24(\r\n                        uint24(BitMath.leastSignificantBit(masked) - bitPos)\r\n                    )) * tickSpacing\r\n                : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) *\r\n                    tickSpacing;\r\n        }\r\n    }\r\n}\r\n\r\n// File: ERC20.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(sender, _msgSender(), currentAllowance - amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n\r\n        _afterTokenTransfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: SwapMath.sol\r\n\r\n/// @title Computes the result of a swap within ticks\r\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\r\nlibrary SwapMath {\r\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\r\n    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\r\n    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\r\n    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\r\n    /// @param liquidity The usable liquidity\r\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\r\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\r\n    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\r\n    /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap\r\n    /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap\r\n    /// @return feeAmount The amount of input that will be taken as a fee\r\n    function computeSwapStep(\r\n        uint160 sqrtRatioCurrentX96,\r\n        uint160 sqrtRatioTargetX96,\r\n        uint128 liquidity,\r\n        int256 amountRemaining,\r\n        uint24 feePips\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            uint160 sqrtRatioNextX96,\r\n            uint256 amountIn,\r\n            uint256 amountOut,\r\n            uint256 feeAmount\r\n        )\r\n    {\r\n        unchecked {\r\n            bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\r\n            bool exactIn = amountRemaining >= 0;\r\n\r\n            if (exactIn) {\r\n                uint256 amountRemainingLessFee = FullMath.mulDiv(\r\n                    uint256(amountRemaining),\r\n                    1e6 - feePips,\r\n                    1e6\r\n                );\r\n                amountIn = zeroForOne\r\n                    ? SqrtPriceMath.getAmount0Delta(\r\n                        sqrtRatioTargetX96,\r\n                        sqrtRatioCurrentX96,\r\n                        liquidity,\r\n                        true\r\n                    )\r\n                    : SqrtPriceMath.getAmount1Delta(\r\n                        sqrtRatioCurrentX96,\r\n                        sqrtRatioTargetX96,\r\n                        liquidity,\r\n                        true\r\n                    );\r\n                if (amountRemainingLessFee >= amountIn)\r\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\r\n                else\r\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\r\n                        sqrtRatioCurrentX96,\r\n                        liquidity,\r\n                        amountRemainingLessFee,\r\n                        zeroForOne\r\n                    );\r\n            } else {\r\n                amountOut = zeroForOne\r\n                    ? SqrtPriceMath.getAmount1Delta(\r\n                        sqrtRatioTargetX96,\r\n                        sqrtRatioCurrentX96,\r\n                        liquidity,\r\n                        false\r\n                    )\r\n                    : SqrtPriceMath.getAmount0Delta(\r\n                        sqrtRatioCurrentX96,\r\n                        sqrtRatioTargetX96,\r\n                        liquidity,\r\n                        false\r\n                    );\r\n                if (uint256(-amountRemaining) >= amountOut)\r\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\r\n                else\r\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\r\n                        sqrtRatioCurrentX96,\r\n                        liquidity,\r\n                        uint256(-amountRemaining),\r\n                        zeroForOne\r\n                    );\r\n            }\r\n\r\n            bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\r\n\r\n            // get the input/output amounts\r\n            if (zeroForOne) {\r\n                amountIn = max && exactIn\r\n                    ? amountIn\r\n                    : SqrtPriceMath.getAmount0Delta(\r\n                        sqrtRatioNextX96,\r\n                        sqrtRatioCurrentX96,\r\n                        liquidity,\r\n                        true\r\n                    );\r\n                amountOut = max && !exactIn\r\n                    ? amountOut\r\n                    : SqrtPriceMath.getAmount1Delta(\r\n                        sqrtRatioNextX96,\r\n                        sqrtRatioCurrentX96,\r\n                        liquidity,\r\n                        false\r\n                    );\r\n            } else {\r\n                amountIn = max && exactIn\r\n                    ? amountIn\r\n                    : SqrtPriceMath.getAmount1Delta(\r\n                        sqrtRatioCurrentX96,\r\n                        sqrtRatioNextX96,\r\n                        liquidity,\r\n                        true\r\n                    );\r\n                amountOut = max && !exactIn\r\n                    ? amountOut\r\n                    : SqrtPriceMath.getAmount0Delta(\r\n                        sqrtRatioCurrentX96,\r\n                        sqrtRatioNextX96,\r\n                        liquidity,\r\n                        false\r\n                    );\r\n            }\r\n\r\n            // cap the output amount to not exceed the remaining output amount\r\n            if (!exactIn && amountOut > uint256(-amountRemaining)) {\r\n                amountOut = uint256(-amountRemaining);\r\n            }\r\n\r\n            if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\r\n                // we didn't reach the target, so take the remainder of the maximum input as fee\r\n                feeAmount = uint256(amountRemaining) - amountIn;\r\n            } else {\r\n                feeAmount = FullMath.mulDivRoundingUp(\r\n                    amountIn,\r\n                    feePips,\r\n                    1e6 - feePips\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: ySwapper.sol\r\n\r\ninterface ITradeFactory {\r\n    function enable(address, address) external;\r\n}\r\n\r\nabstract contract ySwapper {\r\n    using SafeERC20 for IERC20;\r\n    // TODO: not working for clonables !\r\n    address public tradeFactory =\r\n        address(0xD3f89C21719Ec5961a3E6B0f9bBf9F9b4180E9e9);\r\n\r\n    bool public tradesEnabled;\r\n\r\n    // Implement in contract using ySwaps.\r\n    // should return the list of tokens to be swapped and a list of tokens to be swapped to\r\n    function getYSwapTokens()\r\n        internal\r\n        view\r\n        virtual\r\n        returns (address[] memory, address[] memory);\r\n\r\n    // WARNING this is a manual permissioned function\r\n    // should call internalFunction and use onlyROLEs\r\n    // if you don't want this function, just override with empty function\r\n    function removeTradeFactoryPermissions() external virtual;\r\n\r\n    // WARNING this is a manual permissioned function\r\n    // should call internalFunction and use onlyROLEs\r\n    // if you don't want this function, just override with empty function\r\n    function updateTradeFactoryPermissions(address _tradeFactory)\r\n        external\r\n        virtual;\r\n\r\n    function _setUpTradeFactory() internal {\r\n        //approve and set up trade factory\r\n        tradesEnabled = true;\r\n        (\r\n            address[] memory tokensToEnable,\r\n            address[] memory toTokens\r\n        ) = getYSwapTokens();\r\n\r\n        for (uint256 i; i < tokensToEnable.length; i++) {\r\n            _enableTradeFactoryForToken(tokensToEnable[i], toTokens[i]);\r\n        }\r\n    }\r\n\r\n    function _enableTradeFactoryForToken(address fromToken, address toToken)\r\n        internal\r\n    {\r\n        ITradeFactory tf = ITradeFactory(tradeFactory);\r\n        IERC20(fromToken).safeApprove(address(tf), type(uint256).max);\r\n        tf.enable(fromToken, toToken);\r\n    }\r\n\r\n    function _updateTradeFactory(address _newTradeFactory) internal {\r\n        if (tradeFactory != address(0)) {\r\n            _removeTradeFactory();\r\n        }\r\n\r\n        tradeFactory = _newTradeFactory;\r\n        _setUpTradeFactory();\r\n    }\r\n\r\n    function _removeTradeFactory() internal {\r\n        address _tradeFactory = tradeFactory;\r\n\r\n        (address[] memory tokens, ) = getYSwapTokens();\r\n\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            IERC20(tokens[i]).safeApprove(_tradeFactory, 0);\r\n        }\r\n\r\n        tradeFactory = address(0);\r\n        tradesEnabled = false;\r\n    }\r\n}\r\n\r\n// File: BaseStrategy.sol\r\n\r\nstruct StrategyParams {\r\n    uint256 performanceFee;\r\n    uint256 activation;\r\n    uint256 debtRatio;\r\n    uint256 minDebtPerHarvest;\r\n    uint256 maxDebtPerHarvest;\r\n    uint256 lastReport;\r\n    uint256 totalDebt;\r\n    uint256 totalGain;\r\n    uint256 totalLoss;\r\n}\r\n\r\ninterface VaultAPI is IERC20 {\r\n    function name() external view returns (string calldata);\r\n\r\n    function symbol() external view returns (string calldata);\r\n\r\n    function decimals() external view returns (uint256);\r\n\r\n    function apiVersion() external pure returns (string memory);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount,\r\n        uint256 expiry,\r\n        bytes calldata signature\r\n    ) external returns (bool);\r\n\r\n    // NOTE: Vyper produces multiple signatures for a given function with \"default\" args\r\n    function deposit() external returns (uint256);\r\n\r\n    function deposit(uint256 amount) external returns (uint256);\r\n\r\n    function deposit(uint256 amount, address recipient) external returns (uint256);\r\n\r\n    // NOTE: Vyper produces multiple signatures for a given function with \"default\" args\r\n    function withdraw() external returns (uint256);\r\n\r\n    function withdraw(uint256 maxShares) external returns (uint256);\r\n\r\n    function withdraw(uint256 maxShares, address recipient) external returns (uint256);\r\n\r\n    function token() external view returns (address);\r\n\r\n    function strategies(address _strategy) external view returns (StrategyParams memory);\r\n\r\n    function pricePerShare() external view returns (uint256);\r\n\r\n    function totalAssets() external view returns (uint256);\r\n\r\n    function depositLimit() external view returns (uint256);\r\n\r\n    function maxAvailableShares() external view returns (uint256);\r\n\r\n    /**\r\n     * View how much the Vault would increase this Strategy's borrow limit,\r\n     * based on its present performance (since its last report). Can be used to\r\n     * determine expectedReturn in your Strategy.\r\n     */\r\n    function creditAvailable() external view returns (uint256);\r\n\r\n    /**\r\n     * View how much the Vault would like to pull back from the Strategy,\r\n     * based on its present performance (since its last report). Can be used to\r\n     * determine expectedReturn in your Strategy.\r\n     */\r\n    function debtOutstanding() external view returns (uint256);\r\n\r\n    /**\r\n     * View how much the Vault expect this Strategy to return at the current\r\n     * block, based on its present performance (since its last report). Can be\r\n     * used to determine expectedReturn in your Strategy.\r\n     */\r\n    function expectedReturn() external view returns (uint256);\r\n\r\n    /**\r\n     * This is the main contact point where the Strategy interacts with the\r\n     * Vault. It is critical that this call is handled as intended by the\r\n     * Strategy. Therefore, this function will be called by BaseStrategy to\r\n     * make sure the integration is correct.\r\n     */\r\n    function report(\r\n        uint256 _gain,\r\n        uint256 _loss,\r\n        uint256 _debtPayment\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * This function should only be used in the scenario where the Strategy is\r\n     * being retired but no migration of the positions are possible, or in the\r\n     * extreme scenario that the Strategy needs to be put into \"Emergency Exit\"\r\n     * mode in order for it to exit as quickly as possible. The latter scenario\r\n     * could be for any reason that is considered \"critical\" that the Strategy\r\n     * exits its position as fast as possible, such as a sudden change in\r\n     * market conditions leading to losses, or an imminent failure in an\r\n     * external dependency.\r\n     */\r\n    function revokeStrategy() external;\r\n\r\n    /**\r\n     * View the governance address of the Vault to assert privileged functions\r\n     * can only be called by governance. The Strategy serves the Vault, so it\r\n     * is subject to governance defined by the Vault.\r\n     */\r\n    function governance() external view returns (address);\r\n\r\n    /**\r\n     * View the management address of the Vault to assert privileged functions\r\n     * can only be called by management. The Strategy serves the Vault, so it\r\n     * is subject to management defined by the Vault.\r\n     */\r\n    function management() external view returns (address);\r\n\r\n    /**\r\n     * View the guardian address of the Vault to assert privileged functions\r\n     * can only be called by guardian. The Strategy serves the Vault, so it\r\n     * is subject to guardian defined by the Vault.\r\n     */\r\n    function guardian() external view returns (address);\r\n}\r\n\r\n/**\r\n * This interface is here for the keeper bot to use.\r\n */\r\ninterface StrategyAPI {\r\n    function name() external view returns (string memory);\r\n\r\n    function vault() external view returns (address);\r\n\r\n    function want() external view returns (address);\r\n\r\n    function apiVersion() external pure returns (string memory);\r\n\r\n    function keeper() external view returns (address);\r\n\r\n    function isActive() external view returns (bool);\r\n\r\n    function delegatedAssets() external view returns (uint256);\r\n\r\n    function estimatedTotalAssets() external view returns (uint256);\r\n\r\n    function tendTrigger(uint256 callCost) external view returns (bool);\r\n\r\n    function tend() external;\r\n\r\n    function harvestTrigger(uint256 callCost) external view returns (bool);\r\n\r\n    function harvest() external;\r\n\r\n    event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);\r\n}\r\n\r\ninterface HealthCheck {\r\n    function check(\r\n        uint256 profit,\r\n        uint256 loss,\r\n        uint256 debtPayment,\r\n        uint256 debtOutstanding,\r\n        uint256 totalDebt\r\n    ) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @title Yearn Base Strategy\r\n * @author yearn.finance\r\n * @notice\r\n *  BaseStrategy implements all of the required functionality to interoperate\r\n *  closely with the Vault contract. This contract should be inherited and the\r\n *  abstract methods implemented to adapt the Strategy to the particular needs\r\n *  it has to create a return.\r\n *\r\n *  Of special interest is the relationship between `harvest()` and\r\n *  `vault.report()'. `harvest()` may be called simply because enough time has\r\n *  elapsed since the last report, and not because any funds need to be moved\r\n *  or positions adjusted. This is critical so that the Vault may maintain an\r\n *  accurate picture of the Strategy's performance. See  `vault.report()`,\r\n *  `harvest()`, and `harvestTrigger()` for further details.\r\n */\r\n\r\nabstract contract BaseStrategy {\r\n    using SafeERC20 for IERC20;\r\n    string public metadataURI;\r\n\r\n    // health checks\r\n    bool public doHealthCheck;\r\n    address public healthCheck;\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to track which version of `StrategyAPI` this Strategy\r\n     *  implements.\r\n     * @dev The Strategy's version must match the Vault's `API_VERSION`.\r\n     * @return A string which holds the current API version of this contract.\r\n     */\r\n    function apiVersion() public pure returns (string memory) {\r\n        return \"0.4.3\";\r\n    }\r\n\r\n    /**\r\n     * @notice This Strategy's name.\r\n     * @dev\r\n     *  You can use this field to manage the \"version\" of this Strategy, e.g.\r\n     *  `StrategySomethingOrOtherV1`. However, \"API Version\" is managed by\r\n     *  `apiVersion()` function above.\r\n     * @return This Strategy's name.\r\n     */\r\n    function name() external view virtual returns (string memory);\r\n\r\n    /**\r\n     * @notice\r\n     *  The amount (priced in want) of the total assets managed by this strategy should not count\r\n     *  towards Yearn's TVL calculations.\r\n     * @dev\r\n     *  You can override this field to set it to a non-zero value if some of the assets of this\r\n     *  Strategy is somehow delegated inside another part of of Yearn's ecosystem e.g. another Vault.\r\n     *  Note that this value must be strictly less than or equal to the amount provided by\r\n     *  `estimatedTotalAssets()` below, as the TVL calc will be total assets minus delegated assets.\r\n     *  Also note that this value is used to determine the total assets under management by this\r\n     *  strategy, for the purposes of computing the management fee in `Vault`\r\n     * @return\r\n     *  The amount of assets this strategy manages that should not be included in Yearn's Total Value\r\n     *  Locked (TVL) calculation across it's ecosystem.\r\n     */\r\n    function delegatedAssets() external view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    VaultAPI public vault;\r\n    address public strategist;\r\n    address public rewards;\r\n    address public keeper;\r\n\r\n    IERC20 public want;\r\n\r\n    // So indexers can keep track of this\r\n    event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);\r\n\r\n    event UpdatedStrategist(address newStrategist);\r\n\r\n    event UpdatedKeeper(address newKeeper);\r\n\r\n    event UpdatedRewards(address rewards);\r\n\r\n    event UpdatedMinReportDelay(uint256 delay);\r\n\r\n    event UpdatedMaxReportDelay(uint256 delay);\r\n\r\n    event UpdatedProfitFactor(uint256 profitFactor);\r\n\r\n    event UpdatedDebtThreshold(uint256 debtThreshold);\r\n\r\n    event EmergencyExitEnabled();\r\n\r\n    event UpdatedMetadataURI(string metadataURI);\r\n\r\n    event SetHealthCheck(address);\r\n    event SetDoHealthCheck(bool);\r\n\r\n    // The minimum number of seconds between harvest calls. See\r\n    // `setMinReportDelay()` for more details.\r\n    uint256 public minReportDelay;\r\n\r\n    // The maximum number of seconds between harvest calls. See\r\n    // `setMaxReportDelay()` for more details.\r\n    uint256 public maxReportDelay;\r\n\r\n    // The minimum multiple that `callCost` must be above the credit/profit to\r\n    // be \"justifiable\". See `setProfitFactor()` for more details.\r\n    uint256 public profitFactor;\r\n\r\n    // Use this to adjust the threshold at which running a debt causes a\r\n    // harvest trigger. See `setDebtThreshold()` for more details.\r\n    uint256 public debtThreshold;\r\n\r\n    // See note on `setEmergencyExit()`.\r\n    bool public emergencyExit;\r\n\r\n    // modifiers\r\n    modifier onlyAuthorized() {\r\n        require(msg.sender == strategist || msg.sender == governance(), \"!authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyEmergencyAuthorized() {\r\n        require(\r\n            msg.sender == strategist || msg.sender == governance() || msg.sender == vault.guardian() || msg.sender == vault.management(),\r\n            \"!authorized\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyStrategist() {\r\n        require(msg.sender == strategist, \"!strategist\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        require(msg.sender == governance(), \"!authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyKeepers() {\r\n        require(\r\n            msg.sender == keeper ||\r\n                msg.sender == strategist ||\r\n                msg.sender == governance() ||\r\n                msg.sender == vault.guardian() ||\r\n                msg.sender == vault.management(),\r\n            \"!authorized\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyVaultManagers() {\r\n        require(msg.sender == vault.management() || msg.sender == governance(), \"!authorized\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _vault) {\r\n        _initialize(_vault, msg.sender, msg.sender, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Initializes the Strategy, this is called only once, when the\r\n     *  contract is deployed.\r\n     * @dev `_vault` should implement `VaultAPI`.\r\n     * @param _vault The address of the Vault responsible for this Strategy.\r\n     * @param _strategist The address to assign as `strategist`.\r\n     * The strategist is able to change the reward address\r\n     * @param _rewards  The address to use for pulling rewards.\r\n     * @param _keeper The adddress of the _keeper. _keeper\r\n     * can harvest and tend a strategy.\r\n     */\r\n    function _initialize(\r\n        address _vault,\r\n        address _strategist,\r\n        address _rewards,\r\n        address _keeper\r\n    ) internal {\r\n        require(address(want) == address(0), \"Strategy already initialized\");\r\n\r\n        vault = VaultAPI(_vault);\r\n        want = IERC20(vault.token());\r\n        want.safeApprove(_vault, type(uint256).max); // Give Vault unlimited access (might save gas)\r\n        strategist = _strategist;\r\n        rewards = _rewards;\r\n        keeper = _keeper;\r\n\r\n        // initialize variables\r\n        minReportDelay = 0;\r\n        maxReportDelay = 86400;\r\n        profitFactor = 100;\r\n        debtThreshold = 0;\r\n\r\n        vault.approve(rewards, type(uint256).max); // Allow rewards to be pulled\r\n    }\r\n\r\n    function setHealthCheck(address _healthCheck) external onlyVaultManagers {\r\n        emit SetHealthCheck(_healthCheck);\r\n        healthCheck = _healthCheck;\r\n    }\r\n\r\n    function setDoHealthCheck(bool _doHealthCheck) external onlyVaultManagers {\r\n        emit SetDoHealthCheck(_doHealthCheck);\r\n        doHealthCheck = _doHealthCheck;\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `strategist`.\r\n     *\r\n     *  This may only be called by governance or the existing strategist.\r\n     * @param _strategist The new address to assign as `strategist`.\r\n     */\r\n    function setStrategist(address _strategist) external onlyAuthorized {\r\n        require(_strategist != address(0));\r\n        strategist = _strategist;\r\n        emit UpdatedStrategist(_strategist);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `keeper`.\r\n     *\r\n     *  `keeper` is the only address that may call `tend()` or `harvest()`,\r\n     *  other than `governance()` or `strategist`. However, unlike\r\n     *  `governance()` or `strategist`, `keeper` may *only* call `tend()`\r\n     *  and `harvest()`, and no other authorized functions, following the\r\n     *  principle of least privilege.\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _keeper The new address to assign as `keeper`.\r\n     */\r\n    function setKeeper(address _keeper) external onlyAuthorized {\r\n        require(_keeper != address(0));\r\n        keeper = _keeper;\r\n        emit UpdatedKeeper(_keeper);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `rewards`. EOA or smart contract which has the permission\r\n     *  to pull rewards from the vault.\r\n     *\r\n     *  This may only be called by the strategist.\r\n     * @param _rewards The address to use for pulling rewards.\r\n     */\r\n    function setRewards(address _rewards) external onlyStrategist {\r\n        require(_rewards != address(0));\r\n        vault.approve(rewards, 0);\r\n        rewards = _rewards;\r\n        vault.approve(rewards, type(uint256).max);\r\n        emit UpdatedRewards(_rewards);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `minReportDelay`. `minReportDelay` is the minimum number\r\n     *  of blocks that should pass for `harvest()` to be called.\r\n     *\r\n     *  For external keepers (such as the Keep3r network), this is the minimum\r\n     *  time between jobs to wait. (see `harvestTrigger()`\r\n     *  for more details.)\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _delay The minimum number of seconds to wait between harvests.\r\n     */\r\n    function setMinReportDelay(uint256 _delay) external onlyAuthorized {\r\n        minReportDelay = _delay;\r\n        emit UpdatedMinReportDelay(_delay);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `maxReportDelay`. `maxReportDelay` is the maximum number\r\n     *  of blocks that should pass for `harvest()` to be called.\r\n     *\r\n     *  For external keepers (such as the Keep3r network), this is the maximum\r\n     *  time between jobs to wait. (see `harvestTrigger()`\r\n     *  for more details.)\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _delay The maximum number of seconds to wait between harvests.\r\n     */\r\n    function setMaxReportDelay(uint256 _delay) external onlyAuthorized {\r\n        maxReportDelay = _delay;\r\n        emit UpdatedMaxReportDelay(_delay);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `profitFactor`. `profitFactor` is used to determine\r\n     *  if it's worthwhile to harvest, given gas costs. (See `harvestTrigger()`\r\n     *  for more details.)\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _profitFactor A ratio to multiply anticipated\r\n     * `harvest()` gas cost against.\r\n     */\r\n    function setProfitFactor(uint256 _profitFactor) external onlyAuthorized {\r\n        profitFactor = _profitFactor;\r\n        emit UpdatedProfitFactor(_profitFactor);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Sets how far the Strategy can go into loss without a harvest and report\r\n     *  being required.\r\n     *\r\n     *  By default this is 0, meaning any losses would cause a harvest which\r\n     *  will subsequently report the loss to the Vault for tracking. (See\r\n     *  `harvestTrigger()` for more details.)\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _debtThreshold How big of a loss this Strategy may carry without\r\n     * being required to report to the Vault.\r\n     */\r\n    function setDebtThreshold(uint256 _debtThreshold) external onlyAuthorized {\r\n        debtThreshold = _debtThreshold;\r\n        emit UpdatedDebtThreshold(_debtThreshold);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Used to change `metadataURI`. `metadataURI` is used to store the URI\r\n     * of the file describing the strategy.\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @param _metadataURI The URI that describe the strategy.\r\n     */\r\n    function setMetadataURI(string calldata _metadataURI) external onlyAuthorized {\r\n        metadataURI = _metadataURI;\r\n        emit UpdatedMetadataURI(_metadataURI);\r\n    }\r\n\r\n    /**\r\n     * Resolve governance address from Vault contract, used to make assertions\r\n     * on protected functions in the Strategy.\r\n     */\r\n    function governance() internal view returns (address) {\r\n        return vault.governance();\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Provide an accurate conversion from `_amtInWei` (denominated in wei)\r\n     *  to `want` (using the native decimal characteristics of `want`).\r\n     * @dev\r\n     *  Care must be taken when working with decimals to assure that the conversion\r\n     *  is compatible. As an example:\r\n     *\r\n     *      given 1e17 wei (0.1 ETH) as input, and want is USDC (6 decimals),\r\n     *      with USDC/ETH = 1800, this should give back 1800000000 (180 USDC)\r\n     *\r\n     * @param _amtInWei The amount (in wei/1e-18 ETH) to convert to `want`\r\n     * @return The amount in `want` of `_amtInEth` converted to `want`\r\n     **/\r\n    function ethToWant(uint256 _amtInWei) public view virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice\r\n     *  Provide an accurate estimate for the total amount of assets\r\n     *  (principle + return) that this Strategy is currently managing,\r\n     *  denominated in terms of `want` tokens.\r\n     *\r\n     *  This total should be \"realizable\" e.g. the total value that could\r\n     *  *actually* be obtained from this Strategy if it were to divest its\r\n     *  entire position based on current on-chain conditions.\r\n     * @dev\r\n     *  Care must be taken in using this function, since it relies on external\r\n     *  systems, which could be manipulated by the attacker to give an inflated\r\n     *  (or reduced) value produced by this function, based on current on-chain\r\n     *  conditions (e.g. this function is possible to influence through\r\n     *  flashloan attacks, oracle manipulations, or other DeFi attack\r\n     *  mechanisms).\r\n     *\r\n     *  It is up to governance to use this function to correctly order this\r\n     *  Strategy relative to its peers in the withdrawal queue to minimize\r\n     *  losses for the Vault based on sudden withdrawals. This value should be\r\n     *  higher than the total debt of the Strategy and higher than its expected\r\n     *  value to be \"safe\".\r\n     * @return The estimated total assets in this Strategy.\r\n     */\r\n    function estimatedTotalAssets() public view virtual returns (uint256);\r\n\r\n    /*\r\n     * @notice\r\n     *  Provide an indication of whether this strategy is currently \"active\"\r\n     *  in that it is managing an active position, or will manage a position in\r\n     *  the future. This should correlate to `harvest()` activity, so that Harvest\r\n     *  events can be tracked externally by indexing agents.\r\n     * @return True if the strategy is actively managing a position.\r\n     */\r\n    function isActive() public view returns (bool) {\r\n        return vault.strategies(address(this)).debtRatio > 0 || estimatedTotalAssets() > 0;\r\n    }\r\n\r\n    /**\r\n     * Perform any Strategy unwinding or other calls necessary to capture the\r\n     * \"free return\" this Strategy has generated since the last time its core\r\n     * position(s) were adjusted. Examples include unwrapping extra rewards.\r\n     * This call is only used during \"normal operation\" of a Strategy, and\r\n     * should be optimized to minimize losses as much as possible.\r\n     *\r\n     * This method returns any realized profits and/or realized losses\r\n     * incurred, and should return the total amounts of profits/losses/debt\r\n     * payments (in `want` tokens) for the Vault's accounting (e.g.\r\n     * `want.balanceOf(this) >= _debtPayment + _profit`).\r\n     *\r\n     * `_debtOutstanding` will be 0 if the Strategy is not past the configured\r\n     * debt limit, otherwise its value will be how far past the debt limit\r\n     * the Strategy is. The Strategy's debt limit is configured in the Vault.\r\n     *\r\n     * NOTE: `_debtPayment` should be less than or equal to `_debtOutstanding`.\r\n     *       It is okay for it to be less than `_debtOutstanding`, as that\r\n     *       should only used as a guide for how much is left to pay back.\r\n     *       Payments should be made to minimize loss from slippage, debt,\r\n     *       withdrawal fees, etc.\r\n     *\r\n     * See `vault.debtOutstanding()`.\r\n     */\r\n    function prepareReturn(uint256 _debtOutstanding)\r\n        internal\r\n        virtual\r\n        returns (\r\n            uint256 _profit,\r\n            uint256 _loss,\r\n            uint256 _debtPayment\r\n        );\r\n\r\n    /**\r\n     * Perform any adjustments to the core position(s) of this Strategy given\r\n     * what change the Vault made in the \"investable capital\" available to the\r\n     * Strategy. Note that all \"free capital\" in the Strategy after the report\r\n     * was made is available for reinvestment. Also note that this number\r\n     * could be 0, and you should handle that scenario accordingly.\r\n     *\r\n     * See comments regarding `_debtOutstanding` on `prepareReturn()`.\r\n     */\r\n    function adjustPosition(uint256 _debtOutstanding) internal virtual;\r\n\r\n    /**\r\n     * Liquidate up to `_amountNeeded` of `want` of this strategy's positions,\r\n     * irregardless of slippage. Any excess will be re-invested with `adjustPosition()`.\r\n     * This function should return the amount of `want` tokens made available by the\r\n     * liquidation. If there is a difference between them, `_loss` indicates whether the\r\n     * difference is due to a realized loss, or if there is some other sitution at play\r\n     * (e.g. locked funds) where the amount made available is less than what is needed.\r\n     *\r\n     * NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained\r\n     */\r\n    function liquidatePosition(uint256 _amountNeeded) internal virtual returns (uint256 _liquidatedAmount, uint256 _loss);\r\n\r\n    /**\r\n     * Liquidate everything and returns the amount that got freed.\r\n     * This function is used during emergency exit instead of `prepareReturn()` to\r\n     * liquidate all of the Strategy's positions back to the Vault.\r\n     */\r\n\r\n    function liquidateAllPositions() internal virtual returns (uint256 _amountFreed);\r\n\r\n    /**\r\n     * @notice\r\n     *  Provide a signal to the keeper that `tend()` should be called. The\r\n     *  keeper will provide the estimated gas cost that they would pay to call\r\n     *  `tend()`, and this function should use that estimate to make a\r\n     *  determination if calling it is \"worth it\" for the keeper. This is not\r\n     *  the only consideration into issuing this trigger, for example if the\r\n     *  position would be negatively affected if `tend()` is not called\r\n     *  shortly, then this can return `true` even if the keeper might be\r\n     *  \"at a loss\" (keepers are always reimbursed by Yearn).\r\n     * @dev\r\n     *  `callCostInWei` must be priced in terms of `wei` (1e-18 ETH).\r\n     *\r\n     *  This call and `harvestTrigger()` should never return `true` at the same\r\n     *  time.\r\n     * @param callCostInWei The keeper's estimated gas cost to call `tend()` (in wei).\r\n     * @return `true` if `tend()` should be called, `false` otherwise.\r\n     */\r\n    function tendTrigger(uint256 callCostInWei) public view virtual returns (bool) {\r\n        // We usually don't need tend, but if there are positions that need\r\n        // active maintainence, overriding this function is how you would\r\n        // signal for that.\r\n        // If your implementation uses the cost of the call in want, you can\r\n        // use uint256 callCost = ethToWant(callCostInWei);\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Adjust the Strategy's position. The purpose of tending isn't to\r\n     *  realize gains, but to maximize yield by reinvesting any returns.\r\n     *\r\n     *  See comments on `adjustPosition()`.\r\n     *\r\n     *  This may only be called by governance, the strategist, or the keeper.\r\n     */\r\n    function tend() external onlyKeepers {\r\n        // Don't take profits with this call, but adjust for better gains\r\n        adjustPosition(vault.debtOutstanding());\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Provide a signal to the keeper that `harvest()` should be called. The\r\n     *  keeper will provide the estimated gas cost that they would pay to call\r\n     *  `harvest()`, and this function should use that estimate to make a\r\n     *  determination if calling it is \"worth it\" for the keeper. This is not\r\n     *  the only consideration into issuing this trigger, for example if the\r\n     *  position would be negatively affected if `harvest()` is not called\r\n     *  shortly, then this can return `true` even if the keeper might be \"at a\r\n     *  loss\" (keepers are always reimbursed by Yearn).\r\n     * @dev\r\n     *  `callCostInWei` must be priced in terms of `wei` (1e-18 ETH).\r\n     *\r\n     *  This call and `tendTrigger` should never return `true` at the\r\n     *  same time.\r\n     *\r\n     *  See `min/maxReportDelay`, `profitFactor`, `debtThreshold` to adjust the\r\n     *  strategist-controlled parameters that will influence whether this call\r\n     *  returns `true` or not. These parameters will be used in conjunction\r\n     *  with the parameters reported to the Vault (see `params`) to determine\r\n     *  if calling `harvest()` is merited.\r\n     *\r\n     *  It is expected that an external system will check `harvestTrigger()`.\r\n     *  This could be a script run off a desktop or cloud bot (e.g.\r\n     *  https://github.com/iearn-finance/yearn-vaults/blob/main/scripts/keep.py),\r\n     *  or via an integration with the Keep3r network (e.g.\r\n     *  https://github.com/Macarse/GenericKeep3rV2/blob/master/contracts/keep3r/GenericKeep3rV2.sol).\r\n     * @param callCostInWei The keeper's estimated gas cost to call `harvest()` (in wei).\r\n     * @return `true` if `harvest()` should be called, `false` otherwise.\r\n     */\r\n    function harvestTrigger(uint256 callCostInWei) public view virtual returns (bool) {\r\n        uint256 callCost = ethToWant(callCostInWei);\r\n        StrategyParams memory params = vault.strategies(address(this));\r\n\r\n        // Should not trigger if Strategy is not activated\r\n        if (params.activation == 0) return false;\r\n\r\n        // Should not trigger if we haven't waited long enough since previous harvest\r\n        if (block.timestamp - params.lastReport < minReportDelay) return false;\r\n\r\n        // Should trigger if hasn't been called in a while\r\n        if (block.timestamp - params.lastReport >= maxReportDelay) return true;\r\n\r\n        // If some amount is owed, pay it back\r\n        // NOTE: Since debt is based on deposits, it makes sense to guard against large\r\n        //       changes to the value from triggering a harvest directly through user\r\n        //       behavior. This should ensure reasonable resistance to manipulation\r\n        //       from user-initiated withdrawals as the outstanding debt fluctuates.\r\n        uint256 outstanding = vault.debtOutstanding();\r\n        if (outstanding > debtThreshold) return true;\r\n\r\n        // Check for profits and losses\r\n        uint256 total = estimatedTotalAssets();\r\n        // Trigger if we have a loss to report\r\n        if (total + debtThreshold < params.totalDebt) return true;\r\n\r\n        uint256 profit = 0;\r\n        if (total > params.totalDebt) profit = total - params.totalDebt; // We've earned a profit!\r\n\r\n        // Otherwise, only trigger if it \"makes sense\" economically (gas cost\r\n        // is <N% of value moved)\r\n        uint256 credit = vault.creditAvailable();\r\n        return (profitFactor * callCost < credit + profit);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Harvests the Strategy, recognizing any profits or losses and adjusting\r\n     *  the Strategy's position.\r\n     *\r\n     *  In the rare case the Strategy is in emergency shutdown, this will exit\r\n     *  the Strategy's position.\r\n     *\r\n     *  This may only be called by governance, the strategist, or the keeper.\r\n     * @dev\r\n     *  When `harvest()` is called, the Strategy reports to the Vault (via\r\n     *  `vault.report()`), so in some cases `harvest()` must be called in order\r\n     *  to take in profits, to borrow newly available funds from the Vault, or\r\n     *  otherwise adjust its position. In other cases `harvest()` must be\r\n     *  called to report to the Vault on the Strategy's position, especially if\r\n     *  any losses have occurred.\r\n     */\r\n    function harvest() external onlyKeepers {\r\n        uint256 profit = 0;\r\n        uint256 loss = 0;\r\n        uint256 debtOutstanding = vault.debtOutstanding();\r\n        uint256 debtPayment = 0;\r\n        if (emergencyExit) {\r\n            // Free up as much capital as possible\r\n            uint256 amountFreed = liquidateAllPositions();\r\n            if (amountFreed < debtOutstanding) {\r\n                loss = debtOutstanding - amountFreed;\r\n            } else if (amountFreed > debtOutstanding) {\r\n                profit = amountFreed - debtOutstanding;\r\n            }\r\n            debtPayment = debtOutstanding - loss;\r\n        } else {\r\n            // Free up returns for Vault to pull\r\n            (profit, loss, debtPayment) = prepareReturn(debtOutstanding);\r\n        }\r\n\r\n        // Allow Vault to take up to the \"harvested\" balance of this contract,\r\n        // which is the amount it has earned since the last time it reported to\r\n        // the Vault.\r\n        uint256 totalDebt = vault.strategies(address(this)).totalDebt;\r\n        debtOutstanding = vault.report(profit, loss, debtPayment);\r\n\r\n        // Check if free returns are left, and re-invest them\r\n        adjustPosition(debtOutstanding);\r\n\r\n        // call healthCheck contract\r\n        if (doHealthCheck && healthCheck != address(0)) {\r\n            require(HealthCheck(healthCheck).check(profit, loss, debtPayment, debtOutstanding, totalDebt), \"!healthcheck\");\r\n        } else {\r\n            doHealthCheck = true;\r\n        }\r\n\r\n        emit Harvested(profit, loss, debtPayment, debtOutstanding);\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Withdraws `_amountNeeded` to `vault`.\r\n     *\r\n     *  This may only be called by the Vault.\r\n     * @param _amountNeeded How much `want` to withdraw.\r\n     * @return _loss Any realized losses\r\n     */\r\n    function withdraw(uint256 _amountNeeded) external returns (uint256 _loss) {\r\n        require(msg.sender == address(vault), \"!vault\");\r\n        // Liquidate as much as possible to `want`, up to `_amountNeeded`\r\n        uint256 amountFreed;\r\n        (amountFreed, _loss) = liquidatePosition(_amountNeeded);\r\n        // Send it directly back (NOTE: Using `msg.sender` saves some gas here)\r\n        want.safeTransfer(msg.sender, amountFreed);\r\n        // NOTE: Reinvest anything leftover on next `tend`/`harvest`\r\n    }\r\n\r\n    /**\r\n     * Do anything necessary to prepare this Strategy for migration, such as\r\n     * transferring any reserve or LP tokens, CDPs, or other tokens or stores of\r\n     * value.\r\n     */\r\n    function prepareMigration(address _newStrategy) internal virtual;\r\n\r\n    /**\r\n     * @notice\r\n     *  Transfers all `want` from this Strategy to `_newStrategy`.\r\n     *\r\n     *  This may only be called by the Vault.\r\n     * @dev\r\n     * The new Strategy's Vault must be the same as this Strategy's Vault.\r\n     *  The migration process should be carefully performed to make sure all\r\n     * the assets are migrated to the new address, which should have never\r\n     * interacted with the vault before.\r\n     * @param _newStrategy The Strategy to migrate to.\r\n     */\r\n    function migrate(address _newStrategy) external {\r\n        require(msg.sender == address(vault));\r\n        require(BaseStrategy(_newStrategy).vault() == vault);\r\n        prepareMigration(_newStrategy);\r\n        want.safeTransfer(_newStrategy, want.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * @notice\r\n     *  Activates emergency exit. Once activated, the Strategy will exit its\r\n     *  position upon the next harvest, depositing all funds into the Vault as\r\n     *  quickly as is reasonable given on-chain conditions.\r\n     *\r\n     *  This may only be called by governance or the strategist.\r\n     * @dev\r\n     *  See `vault.setEmergencyShutdown()` and `harvest()` for further details.\r\n     */\r\n    function setEmergencyExit() external onlyEmergencyAuthorized {\r\n        emergencyExit = true;\r\n        vault.revokeStrategy();\r\n\r\n        emit EmergencyExitEnabled();\r\n    }\r\n\r\n    /**\r\n     * Override this to add all tokens/tokenized positions this contract\r\n     * manages on a *persistent* basis (e.g. not just for swapping back to\r\n     * want ephemerally).\r\n     *\r\n     * NOTE: Do *not* include `want`, already included in `sweep` below.\r\n     *\r\n     * Example:\r\n     * ```\r\n     *    function protectedTokens() internal override view returns (address[] memory) {\r\n     *      address[] memory protected = new address[](3);\r\n     *      protected[0] = tokenA;\r\n     *      protected[1] = tokenB;\r\n     *      protected[2] = tokenC;\r\n     *      return protected;\r\n     *    }\r\n     * ```\r\n     */\r\n    function protectedTokens() internal view virtual returns (address[] memory);\r\n\r\n    /**\r\n     * @notice\r\n     *  Removes tokens from this Strategy that are not the type of tokens\r\n     *  managed by this Strategy. This may be used in case of accidentally\r\n     *  sending the wrong kind of token to this Strategy.\r\n     *\r\n     *  Tokens will be sent to `governance()`.\r\n     *\r\n     *  This will fail if an attempt is made to sweep `want`, or any tokens\r\n     *  that are protected by this Strategy.\r\n     *\r\n     *  This may only be called by governance.\r\n     * @dev\r\n     *  Implement `protectedTokens()` to specify any additional tokens that\r\n     *  should be protected from sweeping in addition to `want`.\r\n     * @param _token The token to transfer out of this vault.\r\n     */\r\n    function sweep(address _token) external onlyGovernance {\r\n        require(_token != address(want), \"!want\");\r\n        require(_token != address(vault), \"!shares\");\r\n\r\n        address[] memory _protectedTokens = protectedTokens();\r\n        for (uint256 i; i < _protectedTokens.length; i++) require(_token != _protectedTokens[i], \"!protected\");\r\n\r\n        IERC20(_token).safeTransfer(governance(), IERC20(_token).balanceOf(address(this)));\r\n    }\r\n}\r\n\r\nabstract contract BaseStrategyInitializable is BaseStrategy {\r\n    bool public isOriginal = true;\r\n    event Cloned(address indexed clone);\r\n\r\n    constructor(address _vault) BaseStrategy(_vault) {}\r\n\r\n    function initialize(\r\n        address _vault,\r\n        address _strategist,\r\n        address _rewards,\r\n        address _keeper\r\n    ) external virtual {\r\n        _initialize(_vault, _strategist, _rewards, _keeper);\r\n    }\r\n\r\n    function clone(address _vault) external returns (address) {\r\n        require(isOriginal, \"!clone\");\r\n        return this.clone(_vault, msg.sender, msg.sender, msg.sender);\r\n    }\r\n\r\n    function clone(\r\n        address _vault,\r\n        address _strategist,\r\n        address _rewards,\r\n        address _keeper\r\n    ) external returns (address newStrategy) {\r\n        // Copied from https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\r\n        bytes20 addressBytes = bytes20(address(this));\r\n\r\n        assembly {\r\n            // EIP-1167 bytecode\r\n            let clone_code := mload(0x40)\r\n            mstore(clone_code, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone_code, 0x14), addressBytes)\r\n            mstore(add(clone_code, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            newStrategy := create(0, clone_code, 0x37)\r\n        }\r\n\r\n        BaseStrategyInitializable(newStrategy).initialize(_vault, _strategist, _rewards, _keeper);\r\n\r\n        emit Cloned(newStrategy);\r\n    }\r\n}\r\n\r\n// File: UniswapHelperViews.sol\r\n\r\n/// @title Uniswap V3 necessary views for the strategy\r\nlibrary UniswapHelperViews {\r\n    using SafeCast for uint256;\r\n    using TickBitmapExtended for function(int16)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    error ZeroAmount();\r\n    error InvalidSqrtPriceLimit(uint160 sqrtPriceLimitX96);\r\n\r\n    struct Cache {\r\n        // price at the beginning of the swap\r\n        uint160 sqrtPriceX96Start;\r\n        // tick at the beginning of the swap\r\n        int24 tickStart;\r\n        // the protocol fee for the input token\r\n        uint8 feeProtocol;\r\n        // liquidity at the beginning of the swap\r\n        uint128 liquidityStart;\r\n        // the tick spacing of the pool\r\n        int24 tickSpacing;\r\n        // the lp fee share of the pool\r\n        uint24 fee;\r\n    }\r\n\r\n    struct State {\r\n        // the amount remaining to be swapped in/out of the input/output asset\r\n        int256 amountSpecifiedRemaining;\r\n        // the amount already swapped out/in of the output/input asset\r\n        int256 amountCalculated;\r\n        // current sqrt(price)\r\n        uint160 sqrtPriceX96;\r\n        // the tick associated with the current price\r\n        int24 tick;\r\n        // the global fee growth of the input token\r\n        uint256 feeGrowthGlobalIncreaseX128;\r\n        // amount of input token paid as protocol fee\r\n        uint128 protocolFee;\r\n        // the current liquidity in range\r\n        uint128 liquidity;\r\n    }\r\n\r\n    struct Step {\r\n        // the price at the beginning of the step\r\n        uint160 sqrtPriceStartX96;\r\n        // the next tick to swap to from the current tick in the swap direction\r\n        int24 tickNext;\r\n        // whether tickNext is initialized or not\r\n        bool initialized;\r\n        // sqrt(price) for the next tick (1/0)\r\n        uint160 sqrtPriceNextX96;\r\n        // how much is being swapped in in this step\r\n        uint256 amountIn;\r\n        // how much is being swapped out\r\n        uint256 amountOut;\r\n        // how much fee is being paid in\r\n        uint256 feeAmount;\r\n    }\r\n\r\n    /// @notice Simulates a swap over an Uniswap V3 Pool, allowing to handle tick crosses.\r\n    /// @param v3Pool uniswap v3 pool address\r\n    /// @param zeroForOne direction of swap, true means swap zero for one\r\n    /// @param amountSpecified amount to swap in/out\r\n    /// @param sqrtPriceLimitX96 the maximum price to swap to, if this price is reached, then the swap is stopped partially\r\n    /// @param cache the swap cache, can be passed empty or with some values filled in to prevent STATICCALLS to v3Pool\r\n    /// @return amount0 token0 amount\r\n    /// @return amount1 token1 amount\r\n    /// @return state swap state at the end of the swap\r\n    function simulateSwap(\r\n        IUniswapV3Pool v3Pool,\r\n        bool zeroForOne,\r\n        int256 amountSpecified,\r\n        uint160 sqrtPriceLimitX96,\r\n        UniswapHelperViews.Cache memory cache\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            int256 amount0,\r\n            int256 amount1,\r\n            UniswapHelperViews.State memory state\r\n        )\r\n    {\r\n        if (amountSpecified == 0) revert ZeroAmount();\r\n\r\n        // if cache.sqrtPriceX96Start is not set, then make a STATICCALL to v3Pool\r\n        if (cache.sqrtPriceX96Start == 0) {\r\n            IUniswapV3Pool.Slot0 memory slot0 = v3Pool.slot0();\r\n            cache.sqrtPriceX96Start = slot0.sqrtPriceX96;\r\n            cache.tickStart = slot0.tick;\r\n            cache.feeProtocol = slot0.feeProtocol;\r\n        }\r\n\r\n        // if cache.liquidityStart is not set, then make a STATICCALL to v3Pool\r\n        if (cache.liquidityStart == 0)\r\n            cache.liquidityStart = v3Pool.liquidity();\r\n\r\n        // if cache.tickSpacing is not set, then make a STATICCALL to v3Pool\r\n        if (cache.tickSpacing == 0) {\r\n            cache.fee = v3Pool.fee();\r\n            cache.tickSpacing = v3Pool.tickSpacing();\r\n        }\r\n\r\n        // ensure that the sqrtPriceLimitX96 makes sense\r\n        if (\r\n            zeroForOne\r\n                ? sqrtPriceLimitX96 > cache.sqrtPriceX96Start ||\r\n                    sqrtPriceLimitX96 < TickMath.MIN_SQRT_RATIO\r\n                : sqrtPriceLimitX96 < cache.sqrtPriceX96Start ||\r\n                    sqrtPriceLimitX96 > TickMath.MAX_SQRT_RATIO\r\n        ) revert InvalidSqrtPriceLimit(sqrtPriceLimitX96);\r\n\r\n        bool exactInput = amountSpecified > 0;\r\n\r\n        state = UniswapHelperViews.State({\r\n            amountSpecifiedRemaining: amountSpecified,\r\n            amountCalculated: 0,\r\n            sqrtPriceX96: cache.sqrtPriceX96Start,\r\n            tick: cache.tickStart,\r\n            feeGrowthGlobalIncreaseX128: 0,\r\n            protocolFee: 0,\r\n            liquidity: cache.liquidityStart\r\n        });\r\n\r\n        // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\r\n        while (\r\n            state.amountSpecifiedRemaining != 0 &&\r\n            state.sqrtPriceX96 != sqrtPriceLimitX96\r\n        ) {\r\n            UniswapHelperViews.Step memory step;\r\n\r\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\r\n\r\n            (step.tickNext, step.initialized) = v3Pool\r\n                .tickBitmap\r\n                .nextInitializedTickWithinOneWord(\r\n                    state.tick,\r\n                    cache.tickSpacing,\r\n                    zeroForOne\r\n                );\r\n\r\n            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\r\n            if (step.tickNext < TickMath.MIN_TICK) {\r\n                step.tickNext = TickMath.MIN_TICK;\r\n            } else if (step.tickNext > TickMath.MAX_TICK) {\r\n                step.tickNext = TickMath.MAX_TICK;\r\n            }\r\n\r\n            // get the price for the next tick\r\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\r\n\r\n            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\r\n            (\r\n                state.sqrtPriceX96,\r\n                step.amountIn,\r\n                step.amountOut,\r\n                step.feeAmount\r\n            ) = SwapMath.computeSwapStep(\r\n                state.sqrtPriceX96,\r\n                (\r\n                    zeroForOne\r\n                        ? step.sqrtPriceNextX96 < sqrtPriceLimitX96\r\n                        : step.sqrtPriceNextX96 > sqrtPriceLimitX96\r\n                )\r\n                    ? sqrtPriceLimitX96\r\n                    : step.sqrtPriceNextX96,\r\n                state.liquidity,\r\n                state.amountSpecifiedRemaining,\r\n                cache.fee\r\n            );\r\n\r\n            if (exactInput) {\r\n                state.amountSpecifiedRemaining -= (step.amountIn +\r\n                    step.feeAmount).toInt256();\r\n                state.amountCalculated =\r\n                    state.amountCalculated -\r\n                    step.amountOut.toInt256();\r\n            } else {\r\n                state.amountSpecifiedRemaining += step.amountOut.toInt256();\r\n                state.amountCalculated =\r\n                    state.amountCalculated +\r\n                    (step.amountIn + step.feeAmount).toInt256();\r\n            }\r\n\r\n            // update global fee tracker\r\n            if (state.liquidity > 0) {\r\n                state.feeGrowthGlobalIncreaseX128 += FullMath.mulDiv(\r\n                    step.feeAmount,\r\n                    FixedPoint128.Q128,\r\n                    state.liquidity\r\n                );\r\n            }\r\n\r\n            // jump to the method that handles the swap step\r\n            //onSwapStep(zeroForOne, cache, state, step);\r\n\r\n            // shift tick if we reached the next price\r\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\r\n                // if the tick is initialized, adjust the liquidity\r\n                if (step.initialized) {\r\n                    IUniswapV3Pool.TickInfo memory tickInfo = v3Pool.ticks(\r\n                        step.tickNext\r\n                    );\r\n                    int128 liquidityNet = tickInfo.liquidityNet;\r\n                    // if we're moving leftward, we interpret liquidityNet as the opposite sign\r\n                    // safe because liquidityNet cannot be type(int128).min\r\n                    if (zeroForOne) liquidityNet = -liquidityNet;\r\n                    state.liquidity = liquidityNet < 0\r\n                        ? state.liquidity - uint128(-liquidityNet)\r\n                        : state.liquidity + uint128(liquidityNet);\r\n                }\r\n\r\n                state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;\r\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\r\n                // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\r\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\r\n            }\r\n        }\r\n\r\n        (amount0, amount1) = zeroForOne == exactInput\r\n            ? (\r\n                amountSpecified - state.amountSpecifiedRemaining,\r\n                state.amountCalculated\r\n            )\r\n            : (\r\n                state.amountCalculated,\r\n                amountSpecified - state.amountSpecifiedRemaining\r\n            );\r\n    }\r\n\r\n    /// @notice Overloads simulate swap to prevent passing a cache input\r\n    /// @param v3Pool uniswap v3 pool address\r\n    /// @param zeroForOne direction of swap, true means swap zero for one\r\n    /// @param amountSpecified amount to swap in/out\r\n    /// @param sqrtPriceLimitX96 the maximum price to swap to, if this price is reached, then the swap is stopped partially\r\n    /// @return amount0 token0 amount\r\n    /// @return amount1 token1 amount\r\n    /// @return state swap state at the end of the swap\r\n    /// @return cache swap cache populated with values, can be used for subsequent simulations\r\n    function simulateSwap(\r\n        IUniswapV3Pool v3Pool,\r\n        bool zeroForOne,\r\n        int256 amountSpecified,\r\n        uint160 sqrtPriceLimitX96\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            int256 amount0,\r\n            int256 amount1,\r\n            UniswapHelperViews.State memory state,\r\n            UniswapHelperViews.Cache memory cache\r\n        )\r\n    {\r\n        (amount0, amount1, state) = simulateSwap(\r\n            v3Pool,\r\n            zeroForOne,\r\n            amountSpecified,\r\n            sqrtPriceLimitX96,\r\n            cache\r\n        );\r\n    }\r\n\r\n    struct feesEarnedParams {\r\n        uint128 liquidity;\r\n        int24 tickCurrent;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint256 feeGrowthGlobal0X128;\r\n        uint256 feeGrowthGlobal1X128;\r\n        uint256 feeGrowthInside0LastX128;\r\n        uint256 feeGrowthInside1LastX128;\r\n    }\r\n\r\n    /// @notice Retrieves owed fee data for a specific position\r\n    /// @param _feesEarnedParams Custom struct containing:\r\n    /// - liquidity Position's liquidity\r\n    /// - tickCurrent The current tick\r\n    /// - tickLower The lower tick boundary of the position\r\n    /// - tickUpper The upper tick boundary of the position\r\n    /// - feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\r\n    /// - feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\r\n    /// - feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\r\n    /// - feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\r\n    /// @param lower Lower tick information from pool\r\n    /// @param upper Upper tick information from pool\r\n    function getFeesEarned(\r\n        feesEarnedParams memory _feesEarnedParams,\r\n        IUniswapV3Pool.TickInfo memory lower,\r\n        IUniswapV3Pool.TickInfo memory upper\r\n    ) internal pure returns (uint128 tokensOwed0, uint128 tokensOwed1) {\r\n        uint256 feeGrowthBelow0X128;\r\n        uint256 feeGrowthBelow1X128;\r\n        if (_feesEarnedParams.tickCurrent >= _feesEarnedParams.tickLower) {\r\n            feeGrowthBelow0X128 = lower.feeGrowthOutside0X128;\r\n            feeGrowthBelow1X128 = lower.feeGrowthOutside1X128;\r\n        } else {\r\n            feeGrowthBelow0X128 =\r\n                _feesEarnedParams.feeGrowthGlobal0X128 -\r\n                lower.feeGrowthOutside0X128;\r\n            feeGrowthBelow1X128 =\r\n                _feesEarnedParams.feeGrowthGlobal1X128 -\r\n                lower.feeGrowthOutside1X128;\r\n        }\r\n\r\n        // calculate fee growth above\r\n        uint256 feeGrowthAbove0X128;\r\n        uint256 feeGrowthAbove1X128;\r\n        if (_feesEarnedParams.tickCurrent < _feesEarnedParams.tickUpper) {\r\n            feeGrowthAbove0X128 = upper.feeGrowthOutside0X128;\r\n            feeGrowthAbove1X128 = upper.feeGrowthOutside1X128;\r\n        } else {\r\n            feeGrowthAbove0X128 =\r\n                _feesEarnedParams.feeGrowthGlobal0X128 -\r\n                upper.feeGrowthOutside0X128;\r\n            feeGrowthAbove1X128 =\r\n                _feesEarnedParams.feeGrowthGlobal1X128 -\r\n                upper.feeGrowthOutside1X128;\r\n        }\r\n\r\n        uint256 feeGrowthInside0X128 = _feesEarnedParams.feeGrowthGlobal0X128 -\r\n            feeGrowthBelow0X128 -\r\n            feeGrowthAbove0X128;\r\n        uint256 feeGrowthInside1X128 = _feesEarnedParams.feeGrowthGlobal1X128 -\r\n            feeGrowthBelow1X128 -\r\n            feeGrowthAbove1X128;\r\n\r\n        // calculate accumulated fees\r\n        tokensOwed0 = uint128(\r\n            FullMath.mulDiv(\r\n                feeGrowthInside0X128 -\r\n                    _feesEarnedParams.feeGrowthInside0LastX128,\r\n                _feesEarnedParams.liquidity,\r\n                FixedPoint128.Q128\r\n            )\r\n        );\r\n        tokensOwed1 = uint128(\r\n            FullMath.mulDiv(\r\n                feeGrowthInside1X128 -\r\n                    _feesEarnedParams.feeGrowthInside1LastX128,\r\n                _feesEarnedParams.liquidity,\r\n                FixedPoint128.Q128\r\n            )\r\n        );\r\n    }\r\n\r\n}\r\n\r\n// File: Joint.sol\r\n\r\ninterface ProviderStrategy {\r\n    function vault() external view returns (VaultAPI);\r\n\r\n    function strategist() external view returns (address);\r\n\r\n    function keeper() external view returns (address);\r\n\r\n    function want() external view returns (address);\r\n\r\n    function totalDebt() external view returns (uint256);\r\n}\r\n\r\nabstract contract Joint {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    // Constant to use in ratio calculations\r\n    uint256 internal constant RATIO_PRECISION = 1e18;\r\n    // Provider strategy of tokenA\r\n    ProviderStrategy public providerA;\r\n    // Provider strategy of tokenB\r\n    ProviderStrategy public providerB;\r\n\r\n    // Address of tokenA\r\n    address public tokenA;\r\n    // Address of tokenB\r\n    address public tokenB;\r\n\r\n    // Reference token to use in swaps: WETH, WFTM...\r\n    address public referenceToken;\r\n    // Array containing reward tokens\r\n    address[] public rewardTokens;\r\n\r\n    // Address of the pool to LP\r\n    address public pool;\r\n\r\n    // Amounts that actually go into the LP position\r\n    uint256 public investedA;\r\n    uint256 public investedB;\r\n\r\n    // Boolean values protecting against re-investing into the pool\r\n    bool public dontInvestWant;\r\n    bool public autoProtectionDisabled;\r\n\r\n    // Thresholds to operate the strat\r\n    uint256 public minAmountToSell;\r\n    uint256 public maxPercentageLoss;\r\n    uint256 public minRewardToHarvest;\r\n\r\n    // Modifiers needed for access control normally inherited from BaseStrategy \r\n    modifier onlyGovernance() {\r\n        checkGovernance();\r\n        _;\r\n    }\r\n\r\n    modifier onlyVaultManagers() {\r\n        checkVaultManagers();\r\n        _;\r\n    }\r\n\r\n    modifier onlyProviders() {\r\n        checkProvider();\r\n        _;\r\n    }\r\n\r\n    modifier onlyKeepers() {\r\n        checkKeepers();\r\n        _;\r\n    }\r\n\r\n    function checkKeepers() internal {\r\n        require(isKeeper() || isGovernance() || isVaultManager());\r\n    }\r\n\r\n    function checkGovernance() internal {\r\n        require(isGovernance());\r\n    }\r\n\r\n    function checkVaultManagers() internal {\r\n        require(isGovernance() || isVaultManager());\r\n    }\r\n\r\n    function checkProvider() internal {\r\n        require(isProvider());\r\n    }\r\n\r\n    function isGovernance() internal view returns (bool) {\r\n        return\r\n            msg.sender == providerA.vault().governance() ||\r\n            msg.sender == providerB.vault().governance();\r\n    }\r\n\r\n    function isVaultManager() internal view returns (bool) {\r\n        return\r\n            msg.sender == providerA.vault().management() ||\r\n            msg.sender == providerB.vault().management();\r\n    }\r\n\r\n    function isKeeper() internal view returns (bool) {\r\n        return\r\n            (msg.sender == providerA.keeper()) ||\r\n            (msg.sender == providerB.keeper());\r\n    }\r\n\r\n    function isProvider() internal view returns (bool) {\r\n        return\r\n            msg.sender == address(providerA) ||\r\n            msg.sender == address(providerB);\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Constructor, only called during original deploy\r\n     * @param _providerA, provider strategy of tokenA\r\n     * @param _providerB, provider strategy of tokenB\r\n     * @param _referenceToken, token to use as reference, for pricing oracles and paying hedging costs (if any)\r\n     * @param _pool, Pool to LP\r\n     */\r\n    constructor(\r\n        address _providerA,\r\n        address _providerB,\r\n        address _referenceToken,\r\n        address _pool\r\n    ) {\r\n        _initialize(_providerA, _providerB, _referenceToken, _pool);\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Constructor equivalent for clones, initializing the joint and the specifics of UniV3Joint\r\n     * @param _providerA, provider strategy of tokenA\r\n     * @param _providerB, provider strategy of tokenB\r\n     * @param _referenceToken, token to use as reference, for pricing oracles and paying hedging costs (if any)\r\n     * @param _pool, Pool to LP\r\n     */\r\n    function _initialize(\r\n        address _providerA,\r\n        address _providerB,\r\n        address _referenceToken,\r\n        address _pool\r\n    ) internal virtual {\r\n        require(address(providerA) == address(0), \"Joint already initialized\");\r\n        providerA = ProviderStrategy(_providerA);\r\n        providerB = ProviderStrategy(_providerB);\r\n        referenceToken = _referenceToken;\r\n        pool = _pool;\r\n\r\n        // NOTE: we let some loss to avoid getting locked in the position if something goes slightly wrong\r\n        maxPercentageLoss = RATIO_PRECISION / 1_000; // 0.10%\r\n\r\n        tokenA = address(providerA.want());\r\n        tokenB = address(providerB.want());\r\n        require(tokenA != tokenB, \"!same-want\");\r\n    }\r\n\r\n    function name() external view virtual returns (string memory);\r\n\r\n    function shouldEndEpoch() external view virtual returns (bool);\r\n\r\n    function _autoProtect() internal view virtual returns (bool);\r\n\r\n    /*\r\n     * @notice\r\n     *  Check wether a token address is part of rewards or not\r\n     * @param token, token address to check\r\n     * @return wether the provided token address is a reward for the strar or not\r\n     */\r\n    function _isReward(address token) internal view returns (bool) {\r\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\r\n            if (rewardTokens[i] == token) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function used in harvestTrigger in providers to decide wether an epoch can be started or not:\r\n     * - if there is balance of tokens but no position open, return true\r\n     * @return wether to start a new epoch or not\r\n     */\r\n    function shouldStartEpoch() external view returns (bool) {\r\n        // return true if we have balance of A or balance of B while the position is closed\r\n        return\r\n            (balanceOfA() > 0 || balanceOfB() > 0) &&\r\n            investedA == 0 &&\r\n            investedB == 0;\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available for vault managers to set the boolean value deciding wether\r\n     * to re-invest into the LP or not\r\n     * @param _dontInvestWant, new booelan value to use\r\n     */\r\n    function setDontInvestWant(bool _dontInvestWant)\r\n        external\r\n        onlyVaultManagers\r\n    {\r\n        dontInvestWant = _dontInvestWant;\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available for vault managers to set the minimum reward to harvest\r\n     * @param _minRewardToHarvest, new value to use\r\n     */\r\n    function setMinRewardToHarvest(uint256 _minRewardToHarvest)\r\n        external\r\n        onlyVaultManagers\r\n    {\r\n        minRewardToHarvest = _minRewardToHarvest;\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available for vault managers to set the minimum amount to sell\r\n     * @param _minAmountToSell, new value to use\r\n     */\r\n    function setMinAmountToSell(uint256 _minAmountToSell)\r\n        external\r\n        onlyVaultManagers\r\n    {\r\n        minAmountToSell = _minAmountToSell;\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available for vault managers to set the auto protection\r\n     * @param _autoProtectionDisabled, new value to use\r\n     */\r\n    function setAutoProtectionDisabled(bool _autoProtectionDisabled)\r\n        external\r\n        onlyVaultManagers\r\n    {\r\n        autoProtectionDisabled = _autoProtectionDisabled;\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available for vault managers to set the maximum allowed loss\r\n     * @param _maxPercentageLoss, new value to use\r\n     */\r\n    function setMaxPercentageLoss(uint256 _maxPercentageLoss)\r\n        external\r\n        onlyVaultManagers\r\n    {\r\n        require(_maxPercentageLoss <= RATIO_PRECISION);\r\n        maxPercentageLoss = _maxPercentageLoss;\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available for providers to close the joint position and return the funds to each \r\n     * provider strategy\r\n     */\r\n    function closePositionReturnFunds() external onlyProviders {\r\n        // Check if it needs to stop starting new epochs after finishing this one.\r\n        // _autoProtect is implemented in children\r\n        if (_autoProtect() && !autoProtectionDisabled) {\r\n            dontInvestWant = true;\r\n        }\r\n\r\n        // Check that we have a position to close\r\n        if (investedA == 0 || investedB == 0) {\r\n            return;\r\n        }\r\n\r\n        // 1. CLOSE LIQUIDITY POSITION\r\n        // Closing the position will:\r\n        // - Remove liquidity from DEX\r\n        // - Claim pending rewards\r\n        // - Close Hedge and receive payoff\r\n        // and returns current balance of tokenA and tokenB\r\n        (uint256 currentBalanceA, uint256 currentBalanceB) = _closePosition();\r\n\r\n        // 2. SELL REWARDS FOR WANT\r\n        (uint256 rewardsSwappedToA, uint256 rewardsSwappedToB) = swapRewardTokens();\r\n        currentBalanceA += rewardsSwappedToA;\r\n        currentBalanceB += rewardsSwappedToB;\r\n\r\n        // 3. REBALANCE PORTFOLIO\r\n        // Calculate rebalance operation\r\n        // It will return which of the tokens (A or B) we need to sell and how much of it\r\n        // to leave the position with the initial proportions\r\n        (address sellToken, uint256 sellAmount) = calculateSellToBalance(\r\n            currentBalanceA,\r\n            currentBalanceB,\r\n            investedA,\r\n            investedB\r\n        );\r\n        // Perform the swap to balance the tokens\r\n        if (sellToken != address(0) && sellAmount > minAmountToSell) {\r\n            uint256 buyAmount = swap(\r\n                sellToken,\r\n                sellToken == tokenA ? tokenB : tokenA,\r\n                sellAmount\r\n            );\r\n        }\r\n\r\n        // reset invested balances\r\n        investedA = investedB = 0;\r\n\r\n        _returnLooseToProviders();\r\n        // Check that we have returned with no losses\r\n\r\n        require(\r\n            IERC20(tokenA).balanceOf(address(providerA)) >=\r\n                (providerA.totalDebt() *\r\n                    (RATIO_PRECISION - maxPercentageLoss)) /\r\n                    RATIO_PRECISION,\r\n            \"!wrong-balanceA\"\r\n        );\r\n        require(\r\n            IERC20(tokenB).balanceOf(address(providerB)) >=\r\n                (providerB.totalDebt() *\r\n                    (RATIO_PRECISION - maxPercentageLoss)) /\r\n                    RATIO_PRECISION,\r\n            \"!wrong-balanceB\"\r\n        );\r\n    }\r\n    \r\n    /*\r\n     * @notice\r\n     *  Function available for providers to open the joint position:\r\n     * - open the LP position\r\n     * - open the hedginf position if necessary\r\n     * - deposit the LPs if necessary\r\n     */\r\n    function openPosition() external onlyProviders {\r\n        // No capital, nothing to do\r\n        if (balanceOfA() == 0 || balanceOfB() == 0) {\r\n            return;\r\n        }\r\n\r\n        require(\r\n            balanceOfStake() == 0 &&\r\n                balanceOfPool() == 0 &&\r\n                investedA == 0 &&\r\n                investedB == 0\r\n        ); // don't create LP if we are already invested\r\n\r\n        // Open the LP position\r\n        (uint256 amountA, uint256 amountB) = createLP();\r\n        // Open hedge\r\n        (uint256 costHedgeA, uint256 costHedgeB) = hedgeLP();\r\n\r\n        // Set invested amounts\r\n        investedA = amountA + costHedgeA;\r\n        investedB = amountB + costHedgeB;\r\n\r\n        // Deposit LPs (if any)\r\n        depositLP();\r\n\r\n        // If there is loose balance, return it\r\n        if (balanceOfStake() != 0 || balanceOfPool() != 0) {\r\n            _returnLooseToProviders();\r\n        }\r\n    }\r\n\r\n    // Keepers will claim and sell rewards mid-epoch (otherwise we sell only in the end)\r\n    function harvest() external virtual onlyKeepers {\r\n        getReward();\r\n    }\r\n\r\n    function harvestTrigger() external view virtual returns (bool) {\r\n        return balanceOfRewardToken()[0] > minRewardToHarvest;\r\n    }\r\n\r\n    function getHedgeProfit() public view virtual returns (uint256, uint256);\r\n\r\n    /*\r\n     * @notice\r\n     *  Function estimating the current assets in the joint, taking into account:\r\n     * - current balance of tokens in the LP\r\n     * - pending rewards from the LP (if any)\r\n     * - hedge profit (if any)\r\n     * - rebalancing of tokens to maintain token ratios\r\n     * @return _aBalance, _bBalance, estimated tokenA and tokenB balances\r\n     */\r\n    function estimatedTotalAssetsAfterBalance()\r\n        public\r\n        view\r\n        returns (uint256 _aBalance, uint256 _bBalance)\r\n    {\r\n        // Current status of tokens in LP (includes potential IL)\r\n        (_aBalance, _bBalance) = balanceOfTokensInLP();\r\n\r\n        // Add remaining balance in joint (if any)\r\n        _aBalance = _aBalance + balanceOfA();\r\n        _bBalance = _bBalance + balanceOfB();\r\n\r\n        // Include hedge payoffs\r\n        (uint256 callProfit, uint256 putProfit) = getHedgeProfit();\r\n        _aBalance = _aBalance + callProfit;\r\n        _bBalance = _bBalance + putProfit;\r\n\r\n        // Include rewards (swapping them if not tokenA or tokenB)\r\n        uint256[] memory _rewardsPending = pendingRewards();\r\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\r\n            address reward = rewardTokens[i];\r\n            if (reward == tokenA) {\r\n                _aBalance = _aBalance + _rewardsPending[i];\r\n            } else if (reward == tokenB) {\r\n                _bBalance = _bBalance + _rewardsPending[i];\r\n            } else if (_rewardsPending[i] != 0) {\r\n                address swapTo = findSwapTo(reward);\r\n                uint256 outAmount = quote(\r\n                    reward,\r\n                    swapTo,\r\n                    _rewardsPending[i] + IERC20(reward).balanceOf(address(this))\r\n                );\r\n                if (swapTo == tokenA) {\r\n                    _aBalance = _aBalance + outAmount;\r\n                } else if (swapTo == tokenB) {\r\n                    _bBalance = _bBalance + outAmount;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Calculate rebalancing operation needed\r\n        (address sellToken, uint256 sellAmount) = calculateSellToBalance(\r\n            _aBalance,\r\n            _bBalance,\r\n            investedA,\r\n            investedB\r\n        );\r\n\r\n        // Update amounts with rebalancing operation\r\n        if (sellToken == tokenA) {\r\n            uint256 buyAmount = quote(sellToken, tokenB, sellAmount);\r\n            _aBalance = _aBalance - sellAmount;\r\n            _bBalance = _bBalance + buyAmount;\r\n        } else if (sellToken == tokenB) {\r\n            uint256 buyAmount = quote(sellToken, tokenA, sellAmount);\r\n            _bBalance = _bBalance - sellAmount;\r\n            _aBalance = _aBalance + buyAmount;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available internally calculating the necessary operation to rebalance\r\n     * the tokenA and tokenB balances to initial ratios\r\n     * @param currentA, current balance of tokenA\r\n     * @param currentB, current balance of tokenB\r\n     * @param startingA, initial balance of tokenA\r\n     * @param startingB, initial balance of tokenB\r\n     * @return _sellToken, address of the token needed to sell\r\n     * @return _sellAmount, amount needed to sell\r\n     */\r\n    function calculateSellToBalance(\r\n        uint256 currentA,\r\n        uint256 currentB,\r\n        uint256 startingA,\r\n        uint256 startingB\r\n    ) internal view returns (address _sellToken, uint256 _sellAmount) {\r\n        // If no position, no calculation needed\r\n        if (startingA == 0 || startingB == 0) return (address(0), 0);\r\n\r\n        // Get the current ratio between current and starting balance for each token\r\n        (uint256 ratioA, uint256 ratioB) = getRatios(\r\n            currentA,\r\n            currentB,\r\n            startingA,\r\n            startingB\r\n        );\r\n\r\n        //  if already balanced, no action needed\r\n        if (ratioA == ratioB) return (address(0), 0);\r\n\r\n        // If ratioA is higher, there is excess of tokenA\r\n        if (ratioA > ratioB) {\r\n            _sellToken = tokenA;\r\n            // Simulate the swap and assess the received amount\r\n            _sellAmount = _calculateSellToBalance(\r\n                _sellToken,\r\n                currentA,\r\n                currentB,\r\n                startingA,\r\n                startingB,\r\n                10**uint256(IERC20Extended(tokenA).decimals())\r\n            );\r\n        } else {\r\n            // ratioB is higher, excess of tokenB\r\n            _sellToken = tokenB;\r\n            // Simulate the swap and assess the received amount\r\n            _sellAmount = _calculateSellToBalance(\r\n                _sellToken,\r\n                currentB,\r\n                currentA,\r\n                startingB,\r\n                startingA,\r\n                10**uint256(IERC20Extended(tokenB).decimals())\r\n            );\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available internally calculating and simulating the necessary swap to \r\n     * rebalance the tokens\r\n     * @param sellToken, address of the token to sell\r\n     * @param current0, current balance of token\r\n     * @param current1, current balance of other token\r\n     * @param starting0, initial balance of token\r\n     * @param starting1, initial balance of other token     \r\n     * @param precision, constant value ensuring precision is preserved\r\n     * @return _sellAmount, amount needed to sell\r\n     */\r\n    function _calculateSellToBalance(\r\n        address sellToken,\r\n        uint256 current0,\r\n        uint256 current1,\r\n        uint256 starting0,\r\n        uint256 starting1,\r\n        uint256 precision\r\n    ) internal view returns (uint256 _sellAmount) {\r\n        uint256 numerator = (current0 - ((starting0 * current1) / starting1)) *\r\n            precision;\r\n        uint256 exchangeRate = quote(\r\n            sellToken,\r\n            sellToken == tokenA ? tokenB : tokenA,\r\n            precision\r\n        );\r\n\r\n        // First time to approximate\r\n        _sellAmount =\r\n            numerator /\r\n            (precision + ((starting0 * exchangeRate) / starting1));\r\n        // Shortcut to avoid Uniswap amountIn == 0 revert\r\n        if (_sellAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Second time to account for price impact\r\n        exchangeRate =\r\n            (quote(\r\n                sellToken,\r\n                sellToken == tokenA ? tokenB : tokenA,\r\n                _sellAmount\r\n            ) * precision) /\r\n            _sellAmount;\r\n        _sellAmount =\r\n            numerator /\r\n            (precision + ((starting0 * exchangeRate) / starting1));\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available publicly estimating the balance of one of the providers \r\n     * (one of the tokens). Re-uses the estimatedTotalAssetsAfterBalance function but oonly uses\r\n     * one the 2 returned values\r\n     * @param _provider, address of the provider of interest\r\n     * @return _balance, balance of the requested provider\r\n     */\r\n    function estimatedTotalProviderAssets(address _provider)\r\n        public\r\n        view\r\n        returns (uint256 _balance)\r\n    {\r\n        if (_provider == address(providerA)) {\r\n            (_balance, ) = estimatedTotalAssetsAfterBalance();\r\n        } else if (_provider == address(providerB)) {\r\n            (, _balance) = estimatedTotalAssetsAfterBalance();\r\n        }\r\n    }\r\n\r\n    function getHedgeBudget(address token)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256);\r\n\r\n    function hedgeLP() internal virtual returns (uint256, uint256);\r\n\r\n    function closeHedge() internal virtual;\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available publicly estimating the balancing ratios for the 2 tokens in the form:\r\n     * ratio = currentBalance / investedBalance\r\n     * @param currentA, current balance of tokenA\r\n     * @param currentB, current balance of tokenB\r\n     * @param startingA, initial balance of tokenA\r\n     * @param startingB, initial balance of tokenB\r\n     * @return _a, _b, ratios for tokenA and tokenB\r\n     */\r\n    function getRatios(\r\n        uint256 currentA,\r\n        uint256 currentB,\r\n        uint256 startingA,\r\n        uint256 startingB\r\n    ) public pure returns (uint256 _a, uint256 _b) {\r\n        _a = (currentA * RATIO_PRECISION) / startingA;\r\n        _b = (currentB * RATIO_PRECISION) / startingB;\r\n    }\r\n\r\n    function createLP() internal virtual returns (uint256, uint256);\r\n\r\n    function burnLP(uint256 amount) internal virtual;\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available internally deciding what to swap agaisnt the requested token:\r\n     * - if token is either tokenA or B, swap to the other\r\n     * - if token is not A or B but is a reward, swap to the reference token if it's \r\n     * either A or B, if not, swap to tokenA\r\n     * @param token, address of the token to swap from\r\n     * @return address of the token to swap to\r\n     */\r\n    function findSwapTo(address from_token) internal view returns (address) {\r\n        if (tokenA == from_token) {\r\n            return tokenB;\r\n        } else if (tokenB == from_token) {\r\n            return tokenA;\r\n        }\r\n        if (tokenA == referenceToken || tokenB == referenceToken) {\r\n            return referenceToken;\r\n        }\r\n        return tokenA;\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available internally deciding the swapping path to follow\r\n     * @param _token_in, address of the token to swap from\r\n     * @param _token_to, address of the token to swap to\r\n     * @return address array of the swap path to follow\r\n     */\r\n    function getTokenOutPath(address _token_in, address _token_out)\r\n        internal\r\n        view\r\n        returns (address[] memory _path)\r\n    {   \r\n        address _tokenA = tokenA;\r\n        address _tokenB = tokenB;\r\n        bool isReferenceToken = _token_in == address(referenceToken) ||\r\n            _token_out == address(referenceToken);\r\n        bool is_internal = (_token_in == _tokenA && _token_out == _tokenB) ||\r\n            (_token_in == _tokenB && _token_out == _tokenA);\r\n        _path = new address[](isReferenceToken || is_internal ? 2 : 3);\r\n        _path[0] = _token_in;\r\n        if (isReferenceToken || is_internal) {\r\n            _path[1] = _token_out;\r\n        } else {\r\n            _path[1] = address(referenceToken);\r\n            _path[2] = _token_out;\r\n        }\r\n    }\r\n\r\n    function getReward() internal virtual;\r\n\r\n    function depositLP() internal virtual {}\r\n\r\n    function withdrawLP() internal virtual {}\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available internally swapping amounts necessary to swap rewards\r\n     * @return amounts exchanged to tokenA and tokenB\r\n     */\r\n    function swapRewardTokens()\r\n        internal\r\n        virtual\r\n        returns (uint256 swappedToA, uint256 swappedToB)\r\n    {\r\n        address _tokenA = tokenA;\r\n        address _tokenB = tokenB;\r\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\r\n            address reward = rewardTokens[i];\r\n            uint256 _rewardBal = IERC20(reward).balanceOf(address(this));\r\n            // If the reward token is either A or B, don't swap\r\n            if (reward == _tokenA || reward == _tokenB || _rewardBal == 0) {\r\n                continue;\r\n            // If the referenceToken is either A or B, swap rewards against it \r\n            } else if (_tokenA == referenceToken) {\r\n                    swappedToA += swap(reward, referenceToken, _rewardBal);\r\n            } else if (_tokenB == referenceToken) {\r\n                    swappedToB += swap(reward, referenceToken, _rewardBal);\r\n            } else {\r\n                // Assume that position has already been liquidated\r\n                (uint256 ratioA, uint256 ratioB) = getRatios(\r\n                    balanceOfA(),\r\n                    balanceOfB(),\r\n                    investedA,\r\n                    investedB\r\n                );\r\n                \r\n                if (ratioA >= ratioB) {\r\n                    swappedToB += swap(reward, _tokenB, _rewardBal);\r\n                } else {\r\n                    swappedToA += swap(reward, _tokenA, _rewardBal);\r\n                }\r\n            }\r\n        }\r\n        return (swappedToA, swappedToB);\r\n    }\r\n\r\n    function swap(\r\n        address _tokenFrom,\r\n        address _tokenTo,\r\n        uint256 _amountIn\r\n    ) internal virtual returns (uint256 _amountOut);\r\n\r\n    function quote(\r\n        address _tokenFrom,\r\n        address _tokenTo,\r\n        uint256 _amountIn\r\n    ) internal view virtual returns (uint256 _amountOut);\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available internally closing the joint postion:\r\n     *  - withdraw LPs (if any)\r\n     *  - close hedging position (if any)\r\n     *  - close LP position \r\n     * @return balance of tokenA and tokenB\r\n     */\r\n    function _closePosition() internal returns (uint256, uint256) {\r\n        // Unstake LP from staking contract\r\n        withdrawLP();\r\n\r\n        // Close the hedge\r\n        closeHedge();\r\n\r\n        if (balanceOfPool() == 0) {\r\n            return (0, 0);\r\n        }\r\n\r\n        // **WARNING**: This call is sandwichable, care should be taken\r\n        //              to always execute with a private relay\r\n        burnLP(balanceOfPool());\r\n\r\n        return (balanceOfA(), balanceOfB());\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available internally sending back all funds to provuder strategies\r\n     * @return balance of tokenA and tokenB\r\n     */\r\n    function _returnLooseToProviders()\r\n        internal\r\n        returns (uint256 balanceA, uint256 balanceB)\r\n    {\r\n        balanceA = balanceOfA();\r\n        if (balanceA > 0) {\r\n            IERC20(tokenA).safeTransfer(address(providerA), balanceA);\r\n        }\r\n\r\n        balanceB = balanceOfB();\r\n        if (balanceB > 0) {\r\n            IERC20(tokenB).safeTransfer(address(providerB), balanceB);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available publicly returning the joint's balance of tokenA\r\n     * @return balance of tokenA \r\n     */\r\n    function balanceOfA() public view returns (uint256) {\r\n        return IERC20(tokenA).balanceOf(address(this));\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available publicly returning the joint's balance of tokenB\r\n     * @return balance of tokenB\r\n     */\r\n    function balanceOfB() public view returns (uint256) {\r\n        return IERC20(tokenB).balanceOf(address(this));\r\n    }\r\n\r\n    function balanceOfPool() public view virtual returns (uint256);\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available publicly returning the joint's balance of rewards\r\n     * @return array of balances\r\n     */\r\n    function balanceOfRewardToken() public view returns (uint256[] memory) {\r\n        uint256[] memory _balances = new uint256[](rewardTokens.length);\r\n        for (uint8 i = 0; i < rewardTokens.length; i++) {\r\n            _balances[i] = IERC20(rewardTokens[i]).balanceOf(address(this));\r\n        }\r\n        return _balances;\r\n    }\r\n\r\n    function balanceOfStake() public view virtual returns (uint256 _balance) {}\r\n\r\n    function balanceOfTokensInLP()\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 _balanceA, uint256 _balanceB);\r\n\r\n    function pendingRewards() public view virtual returns (uint256[] memory);\r\n\r\n    // --- MANAGEMENT FUNCTIONS ---\r\n    /*\r\n     * @notice\r\n     *  Function available to vault managers closing the joint position manually\r\n     * @param expectedBalanceA, expected balance of tokenA to receive\r\n     * @param expectedBalanceB, expected balance of tokenB to receive\r\n     */\r\n    function liquidatePositionManually(\r\n        uint256 expectedBalanceA,\r\n        uint256 expectedBalanceB\r\n    ) external onlyVaultManagers {\r\n        (uint256 balanceA, uint256 balanceB) = _closePosition();\r\n        require(expectedBalanceA <= balanceA, \"!sandwidched\");\r\n        require(expectedBalanceB <= balanceB, \"!sandwidched\");\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available to vault managers returning the funds to the providers manually\r\n     */\r\n    function returnLooseToProvidersManually() external onlyVaultManagers {\r\n        _returnLooseToProviders();\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available to vault managers closing the LP position manually\r\n     * @param expectedBalanceA, expected balance of tokenA to receive\r\n     * @param expectedBalanceB, expected balance of tokenB to receive\r\n     */\r\n    function removeLiquidityManually(\r\n        uint256 amount,\r\n        uint256 expectedBalanceA,\r\n        uint256 expectedBalanceB\r\n    ) external virtual onlyVaultManagers {\r\n        burnLP(amount);\r\n        require(expectedBalanceA <= balanceOfA(), \"!sandwidched\");\r\n        require(expectedBalanceB <= balanceOfB(), \"!sandwidched\");\r\n    }\r\n\r\n    function swapTokenForTokenManually(\r\n        address[] memory swapPath,\r\n        uint256 swapInAmount,\r\n        uint256 minOutAmount\r\n    ) external virtual returns (uint256);\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available to governance sweeping a specified token but tokenA and B\r\n     * @param _token, address of the token to sweep\r\n     */\r\n    function sweep(address _token) external onlyGovernance {\r\n        require(_token != address(tokenA));\r\n        require(_token != address(tokenB));\r\n\r\n        SafeERC20.safeTransfer(\r\n            IERC20(_token),\r\n            providerA.vault().governance(),\r\n            IERC20(_token).balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available to providers to change the provider addresses\r\n     * @param _newProvider, new address of provider\r\n     */\r\n    function migrateProvider(address _newProvider) external onlyProviders {\r\n        ProviderStrategy newProvider = ProviderStrategy(_newProvider);\r\n        if (address(newProvider.want()) == tokenA) {\r\n            providerA = newProvider;\r\n        } else if (address(newProvider.want()) == tokenB) {\r\n            providerB = newProvider;\r\n        } else {\r\n            revert(\"Unsupported token\");\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Internal function checking if allowance is already enough for the contract\r\n     * and if not, safely sets it to max\r\n     * @param _contract, spender contract\r\n     * @param _token, token to approve spend\r\n     * @param _amount, _amoun to approve\r\n     */\r\n    function _checkAllowance(\r\n        address _contract,\r\n        IERC20 _token,\r\n        uint256 _amount\r\n    ) internal {\r\n        if (_token.allowance(address(this), _contract) < _amount) {\r\n            _token.safeApprove(_contract, 0);\r\n            _token.safeApprove(_contract, _amount);\r\n        }\r\n    }\r\n}\r\n\r\n// File: NoHedgeJoint.sol\r\n\r\nabstract contract NoHedgeJoint is Joint {\r\n    constructor(\r\n        address _providerA,\r\n        address _providerB,\r\n        address _weth,\r\n        address _pool\r\n    ) Joint(_providerA, _providerB, _weth, _pool) {}\r\n\r\n    function getHedgeBudget(address token)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    function getTimeToMaturity() public view returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    function getHedgeProfit() public view override returns (uint256, uint256) {\r\n        return (0, 0);\r\n    }\r\n\r\n    function hedgeLP()\r\n        internal\r\n        override\r\n        returns (uint256 costA, uint256 costB)\r\n    {\r\n        // NO HEDGE\r\n        return (0, 0);\r\n    }\r\n\r\n    function closeHedge() internal override {\r\n        // NO HEDGE\r\n        return;\r\n    }\r\n\r\n    function shouldEndEpoch() public view override returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    // this function is called by Joint to see if it needs to stop initiating new epochs due to too high volatility\r\n    function _autoProtect() internal view override returns (bool) {\r\n        return false;\r\n    }\r\n}\r\n\r\n// File: UniV3StablesJoint.sol\r\n\r\n// Import necessary libraries and interfaces:\r\n// NoHedgeJoint to inherit from\r\n\r\n// Uni V3 pool functionality\r\n\r\n// CRV pool functionalities for swaps and quotes\r\n\r\n// Helper functions from Uni v3\r\n\r\n// Liquidity calculations\r\n\r\n// Pool tick calculations\r\n\r\n// Safe casting and math\r\n\r\ncontract UniV3StablesJoint is NoHedgeJoint {\r\n    using SafeERC20 for IERC20;\r\n    using SafeCast for uint256;\r\n    \r\n    // Used for cloning, will automatically be set to false for other clones\r\n    bool public isOriginal = true;\r\n    // lower tick of the current LP position\r\n    int24 public minTick;\r\n    // upper tick of the current LP position\r\n    int24 public maxTick;\r\n    // # of ticks to go up&down from current price to open LP position\r\n    uint24 public ticksFromCurrent;\r\n    // boolean variable deciding wether to swap in the uni v3 pool or using CRV\r\n    // this can make sense if the pool is unbalanced and price is far from CRV or if the \r\n    // liquidity remaining in the pool is not enough for the rebalancing swap the strategy needs\r\n    // to perform as the swap function from the uniV3 pool uses a while loop that would get stuck \r\n    // until we reach gas limit\r\n    bool public useCRVPool;\r\n    // CRV pool to use in case of useCRVPool = true\r\n    address public crvPool;\r\n\r\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\r\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\r\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\r\n    uint160 internal constant MAX_SQRT_RATIO =\r\n        1461446703485210103287273052203988822378723970342;\r\n\r\n    /*\r\n     * @notice\r\n     *  Constructor, only called during original deploy\r\n     * @param _providerA, provider strategy of tokenA\r\n     * @param _providerB, provider strategy of tokenB\r\n     * @param _referenceToken, token to use as reference, for pricing oracles and paying hedging costs (if any)\r\n     * @param _pool, Uni V3 pool to LP\r\n     * @param _ticksFromCurrent, # of ticks up & down to provide liquidity into\r\n     */\r\n    constructor(\r\n        address _providerA,\r\n        address _providerB,\r\n        address _referenceToken,\r\n        address _pool,\r\n        uint24 _ticksFromCurrent\r\n    ) NoHedgeJoint(_providerA, _providerB, _referenceToken, _pool) {\r\n        _initalizeUniV3StablesJoint(_ticksFromCurrent);\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Constructor equivalent for clones, initializing the joint and the specifics of UniV3StablesJoint\r\n     * @param _providerA, provider strategy of tokenA\r\n     * @param _providerB, provider strategy of tokenB\r\n     * @param _referenceToken, token to use as reference, for pricing oracles and paying hedging costs (if any)\r\n     * @param _pool, Uni V3 pool to LP\r\n     * @param _ticksFromCurrent, # of ticks up & down to provide liquidity into\r\n     */\r\n    function initialize(\r\n        address _providerA,\r\n        address _providerB,\r\n        address _referenceToken,\r\n        address _pool,\r\n        uint24 _ticksFromCurrent\r\n    ) external {\r\n        _initialize(_providerA, _providerB, _referenceToken, _pool);\r\n        _initalizeUniV3StablesJoint(_ticksFromCurrent);\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Initialize UniV3StablesJoint specifics\r\n     * @param _ticksFromCurrent, # of ticks up & down to provide liquidity into\r\n     */\r\n    function _initalizeUniV3StablesJoint(uint24 _ticksFromCurrent) internal {\r\n        ticksFromCurrent = _ticksFromCurrent;\r\n        // The reward tokens are the tokens provided to the pool\r\n        rewardTokens = new address[](2);\r\n        rewardTokens[0] = tokenA;\r\n        rewardTokens[1] = tokenB;\r\n        // by default use uni pool to swap as it has lower fees\r\n        useCRVPool = false;\r\n        // Initialize CRV pool to 3pool\r\n        crvPool = address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);\r\n    }\r\n\r\n    event Cloned(address indexed clone);\r\n\r\n    /*\r\n     * @notice\r\n     *  Cloning function to migrate/ deploy to other pools\r\n     * @param _providerA, provider strategy of tokenA\r\n     * @param _providerB, provider strategy of tokenB\r\n     * @param _referenceToken, token to use as reference, for pricing oracles and paying hedging costs (if any)\r\n     * @param _pool, Uni V3 pool to LP\r\n     * @param _ticksFromCurrent, # of ticks up & down to provide liquidity into\r\n     * @return newJoint, address of newly deployed joint\r\n     */\r\n    function cloneUniV3StablesJoint(\r\n        address _providerA,\r\n        address _providerB,\r\n        address _referenceToken,\r\n        address _pool,\r\n        uint24 _ticksFromCurrent\r\n    ) external returns (address newJoint) {\r\n        require(isOriginal, \"!original\");\r\n        bytes20 addressBytes = bytes20(address(this));\r\n\r\n        assembly {\r\n            // EIP-1167 bytecode\r\n            let clone_code := mload(0x40)\r\n            mstore(\r\n                clone_code,\r\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\r\n            )\r\n            mstore(add(clone_code, 0x14), addressBytes)\r\n            mstore(\r\n                add(clone_code, 0x28),\r\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\r\n            )\r\n            newJoint := create(0, clone_code, 0x37)\r\n        }\r\n\r\n        UniV3StablesJoint(newJoint).initialize(\r\n            _providerA,\r\n            _providerB,\r\n            _referenceToken,\r\n            _pool,\r\n            _ticksFromCurrent\r\n        );\r\n\r\n        emit Cloned(newJoint);\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function returning the name of the joint in the format \"NoHedgeUniV3StablesJoint(USDC-DAI)\"\r\n     * @return name of the strategy\r\n     */\r\n    function name() external view override returns (string memory) {\r\n        string memory ab = string(\r\n            abi.encodePacked(\r\n                IERC20Extended(address(tokenA)).symbol(),\r\n                \"-\",\r\n                IERC20Extended(address(tokenB)).symbol()\r\n            )\r\n        );\r\n\r\n        return string(abi.encodePacked(\"NoHedgeUniV3StablesJoint(\", ab, \")\"));\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function returning the liquidity amount of the LP position\r\n     * @return liquidity from positionInfo\r\n     */\r\n    function balanceOfPool() public view override returns (uint256) {\r\n        IUniswapV3Pool.PositionInfo memory positionInfo = _positionInfo();\r\n        return positionInfo.liquidity;\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available for vault managers to set the boolean value deciding wether\r\n     * to use the uni v3 pool for swaps or a CRV pool\r\n     * @param newUseCRVPool, new boolean value to use\r\n     */\r\n    function setUseCRVPool(bool newUseCRVPool) external onlyVaultManagers {\r\n        useCRVPool = newUseCRVPool;\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available for vault managers to set the number of ticks on each side of \r\n     * current tick to provide liquidity to\r\n     * @param newTicksFromCurrent, new value to use\r\n     */\r\n    function setTicksFromCurrent(uint24 newTicksFromCurrent) external onlyVaultManagers {\r\n        ticksFromCurrent = newTicksFromCurrent;\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available for vault managers to set min & max values of the position. If,\r\n     * for any reason the ticks are not the value they should be, we always have the option \r\n     * to re-set them back to the necessary value using the force parameter\r\n     * @param _minTick, lower limit of position\r\n     * @param _minTick, lower limit of position\r\n     * @param forceChange, force parameter to ensure this function is not called randomly\r\n     */\r\n    function setTicksManually(int24 _minTick, int24 _maxTick, bool forceChange) external onlyVaultManagers {\r\n        if ((investedA > 0 || investedB > 0) && !forceChange) {\r\n            revert();\r\n        }\r\n        minTick = _minTick;\r\n        maxTick = _maxTick;\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function returning the current balance of each token in the LP position taking\r\n     * the new level of reserves into account\r\n     * @return _balanceA, balance of tokenA in the LP position\r\n     * @return _balanceB, balance of tokenB in the LP position\r\n     */\r\n    function balanceOfTokensInLP()\r\n        public\r\n        view\r\n        override\r\n        returns (uint256 _balanceA, uint256 _balanceB)\r\n    {\r\n        // Get the current pool status\r\n        IUniswapV3Pool.Slot0 memory _slot0 = IUniswapV3Pool(pool).slot0();\r\n        // Get the current position status\r\n        IUniswapV3Pool.PositionInfo memory positionInfo = _positionInfo();\r\n\r\n        // Use Uniswap libraries to calculate the token0 and token1 balances for the \r\n        // provided ticks and liquidity amount\r\n        (uint256 amount0, uint256 amount1) = LiquidityAmounts\r\n            .getAmountsForLiquidity(\r\n                _slot0.sqrtPriceX96,\r\n                TickMath.getSqrtRatioAtTick(minTick),\r\n                TickMath.getSqrtRatioAtTick(maxTick),\r\n                positionInfo.liquidity\r\n            );\r\n        // uniswap orders token0 and token1 based on alphabetical order\r\n        return tokenA < tokenB ? (amount0, amount1) : (amount1, amount0);\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function returning the amount of rewards earned until now - unclaimed\r\n     * @return uint256 array of tokenA and tokenB earned as rewards\r\n     */\r\n    function pendingRewards() public view override returns (uint256[] memory) {\r\n        // Initialize the array to same length as reward tokens\r\n        uint256[] memory _amountPending = new uint256[](rewardTokens.length);\r\n\r\n        // Get LP position info\r\n        IUniswapV3Pool.PositionInfo memory positionInfo = _positionInfo();\r\n\r\n        // Initialize to the current status of owed tokens\r\n        (_amountPending[0], _amountPending[1]) = tokenA < tokenB\r\n            ? (positionInfo.tokensOwed0, positionInfo.tokensOwed1)\r\n            : (positionInfo.tokensOwed1, positionInfo.tokensOwed0);\r\n\r\n        // Gas savings\r\n        IUniswapV3Pool _pool = IUniswapV3Pool(pool);\r\n        int24 _minTick = minTick;\r\n        int24 _maxTick = maxTick;\r\n\r\n        // Use Uniswap views library to calculate the fees earned in tokenA and tokenB based\r\n        // on current status of the pool and provided position\r\n        (uint128 tokensOwed0, uint128 tokensOwed1) = UniswapHelperViews.getFeesEarned(\r\n            UniswapHelperViews.feesEarnedParams(\r\n                positionInfo.liquidity,\r\n                _pool.slot0().tick,\r\n                _minTick,\r\n                _maxTick,\r\n                _pool.feeGrowthGlobal0X128(),\r\n                _pool.feeGrowthGlobal1X128(),\r\n                positionInfo.feeGrowthInside0LastX128,\r\n                positionInfo.feeGrowthInside1LastX128\r\n            ),\r\n            _pool.ticks(_minTick),\r\n            _pool.ticks(_maxTick)\r\n        );\r\n\r\n        // Reorder to make sure amounts are added correctly\r\n        if (tokenA < tokenB) {\r\n            _amountPending[0] += tokensOwed0;\r\n            _amountPending[1] += tokensOwed1;\r\n        } else {\r\n            _amountPending[1] += tokensOwed0;\r\n            _amountPending[0] += tokensOwed1;\r\n        }\r\n\r\n        return _amountPending;\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function called by the uniswap pool when minting the LP position (providing liquidity),\r\n     * instead of approving and sending the tokens, uniV3 calls the callback imoplementation\r\n     * on the caller contract\r\n     * @param amount0Owed, amount of token0 to send\r\n     * @param amount1Owed, amount of token1 to send\r\n     * @param data, additional calldata\r\n     */\r\n    function uniswapV3MintCallback(\r\n        uint256 amount0Owed,\r\n        uint256 amount1Owed,\r\n        bytes calldata data\r\n    ) external {\r\n        IUniswapV3Pool _pool = IUniswapV3Pool(pool);\r\n        // Only the pool can use this function\r\n        require(msg.sender == address(_pool)); // dev: callback only called by pool\r\n        // Send the required funds to the pool\r\n        IERC20(_pool.token0()).safeTransfer(address(_pool), amount0Owed);\r\n        IERC20(_pool.token1()).safeTransfer(address(_pool), amount1Owed);\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function called by the uniswap pool when swapping,\r\n     * instead of approving and sending the tokens, uniV3 calls the callback imoplementation\r\n     * on the caller contract\r\n     * @param amount0Delta, amount of token0 to send (if any)\r\n     * @param amount1Delta, amount of token1 to send (if any)\r\n     * @param data, additional calldata\r\n     */\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata data\r\n    ) external {\r\n        IUniswapV3Pool _pool = IUniswapV3Pool(pool);\r\n        // Only the pool can use this function\r\n        require(msg.sender == address(_pool)); // dev: callback only called by pool\r\n\r\n        uint256 amountIn;\r\n        address tokenIn;\r\n\r\n        // Send the required funds to the pool\r\n        if (amount0Delta > 0) {\r\n            amountIn = uint256(amount0Delta);\r\n            tokenIn = _pool.token0();\r\n        } else {\r\n            amountIn = uint256(amount1Delta);\r\n            tokenIn = _pool.token1();\r\n        }\r\n\r\n        IERC20(tokenIn).safeTransfer(address(_pool), amountIn);\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function used internally to collect the accrued fees by burn 0 of the LP position\r\n     * and collecting the owed tokens (only fees as no LP has been burnt)\r\n     * @return balance of tokens in the LP (invested amounts)\r\n     */\r\n    function getReward() internal override {\r\n        _burnAndCollect(0, minTick, maxTick);\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function used internally to open the LP position in the uni v3 pool: \r\n     *      - calculates the ticks to provide liquidity into\r\n     *      - calculates the liquidity amount to provide based on the ticks \r\n     *      and amounts to invest\r\n     *      - calls the mint function in the uni v3 pool\r\n     * @return balance of tokens in the LP (invested amounts)\r\n     */\r\n    function createLP() internal override returns (uint256, uint256) {\r\n        IUniswapV3Pool _pool = IUniswapV3Pool(pool);\r\n        // Get the current state of the pool\r\n        IUniswapV3Pool.Slot0 memory _slot0 = _pool.slot0();\r\n        // Space between ticks for this pool\r\n        int24 _tickSpacing = _pool.tickSpacing();\r\n        // Current tick must be referenced as a multiple of tickSpacing\r\n        int24 _currentTick = (_slot0.tick / _tickSpacing) * _tickSpacing;\r\n        // Gas savings for # of ticks to LP\r\n        int24 _ticksFromCurrent = int24(ticksFromCurrent);\r\n        // Minimum tick to enter\r\n        int24 _minTick = _currentTick - (_tickSpacing * _ticksFromCurrent);\r\n        // Maximum tick to enter\r\n        int24 _maxTick = _currentTick + (_tickSpacing * (_ticksFromCurrent + 1));\r\n\r\n        // Set the state variables\r\n        minTick = _minTick;\r\n        maxTick = _maxTick;\r\n\r\n        uint256 amount0;\r\n        uint256 amount1;\r\n\r\n        // MAke sure tokens are in order\r\n        if (tokenA < tokenB) {\r\n            amount0 = balanceOfA();\r\n            amount1 = balanceOfB();\r\n        } else {\r\n            amount0 = balanceOfB();\r\n            amount1 = balanceOfA();\r\n        }\r\n\r\n        // Calculate the amount of liquidity the joint can provided based on current situation\r\n        // and amount of tokens available\r\n        uint128 liquidityAmount = LiquidityAmounts.getLiquidityForAmounts(\r\n            _slot0.sqrtPriceX96,\r\n            TickMath.getSqrtRatioAtTick(_minTick),\r\n            TickMath.getSqrtRatioAtTick(_maxTick),\r\n            amount0,\r\n            amount1\r\n        );\r\n\r\n        // Mint the LP position - we are not yet in the LP, needs to go through the mint\r\n        // callback first\r\n        _pool.mint(address(this), _minTick, _maxTick, liquidityAmount, \"\");\r\n\r\n        // After executing the mint callback, calculate the invested amounts\r\n        return balanceOfTokensInLP();\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function used internally to close the LP position in the uni v3 pool: \r\n     *      - burns the LP liquidity specified amount\r\n     *      - collects all pending rewards\r\n     *      - re-sets the active position min and max tick to 0\r\n     * @param amount, amount of liquidity to burn\r\n     */\r\n    function burnLP(uint256 amount) internal override {\r\n        _burnAndCollect(amount, minTick, maxTick);\r\n        // If entire position is closed, re-set the min and max ticks\r\n        IUniswapV3Pool.PositionInfo memory positionInfo = _positionInfo();\r\n        if (positionInfo.liquidity == 0){\r\n            minTick = 0;\r\n            maxTick = 0;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available to vault managers to burn the LP manually, if for any reason\r\n     * the ticks have been set to 0 (or any different value from the original LP), we make \r\n     * sure we can always get out of the position\r\n     * This function can be used to only collect fees by passing a 0 amount to burn\r\n     * @param _amount, amount of liquidity to burn\r\n     * @param _minTick, lower limit of position\r\n     * @param _maxTick, upper limit of position\r\n     */\r\n    function burnLPManually(\r\n            uint256 _amount,\r\n            int24 _minTick,\r\n            int24 _maxTick\r\n            ) external onlyVaultManagers {\r\n        _burnAndCollect(_amount, _minTick, _maxTick);\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available internally to burn the LP amount specified, for position\r\n     * defined by minTick and maxTick specified and collect the owed tokens\r\n     * @param _amount, amount of liquidity to burn\r\n     * @param _minTick, lower limit of position\r\n     * @param _maxTick, upper limit of position\r\n     */\r\n    function _burnAndCollect(\r\n        uint256 _amount,\r\n        int24 _minTick,\r\n        int24 _maxTick\r\n    ) internal {\r\n        IUniswapV3Pool _pool = IUniswapV3Pool(pool);\r\n        _pool.burn(_minTick, _maxTick, uint128(_amount));\r\n        _pool.collect(\r\n            address(this),\r\n            _minTick,\r\n            _maxTick,\r\n            type(uint128).max,\r\n            type(uint128).max\r\n        );\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function used internally to swap tokens during rebalancing. Depending on the useCRVPool\r\n     * state variable it will either use the uni v3 pool to swap or a CRV pool specified in \r\n     * crvPool state variable\r\n     * @param _tokenFrom, adress of token to swap from\r\n     * @param _tokenTo, address of token to swap to\r\n     * @param _amountIn, amount of _tokenIn to swap for _tokenTo\r\n     * @return swapped amount\r\n     */\r\n    function swap(\r\n        address _tokenFrom,\r\n        address _tokenTo,\r\n        uint256 _amountIn\r\n    ) internal override returns (uint256) {\r\n        require(_tokenTo == tokenA || _tokenTo == tokenB); // dev: must be a or b\r\n        require(_tokenFrom == tokenA || _tokenFrom == tokenB); // dev: must be a or b\r\n        if (!useCRVPool) {\r\n            // Use uni v3 pool to swap\r\n            // Order of swap\r\n            bool zeroForOne = _tokenFrom < _tokenTo;\r\n\r\n            // Use swap function of uni v3 pool, will use the implemented swap callback to \r\n            // receive the corresponding tokens\r\n            (int256 _amount0, int256 _amount1) = IUniswapV3Pool(pool).swap(\r\n                // recipient\r\n                address(this), // address(0) might cause issues with some tokens\r\n                // Order of swap\r\n                zeroForOne,\r\n                // amountSpecified\r\n                _amountIn.toInt256(),\r\n                // Price limit\r\n                zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\r\n                // additonal calldata\r\n                \"\"\r\n            );\r\n\r\n            // Ensure amounts are returned in right order and sign (uni returns negative numbers)\r\n            return zeroForOne ? uint256(-_amount1) : uint256(-_amount0);\r\n        } else {\r\n            // Do NOT use uni pool use CRV pool\r\n            ICRVPool _pool = ICRVPool(crvPool);\r\n        \r\n            // Allow necessary amount for CRV pool\r\n            _checkAllowance(address(_pool), IERC20(_tokenFrom), _amountIn);\r\n            uint256 prevBalance = IERC20(_tokenTo).balanceOf(address(this));\r\n            // Perform swap\r\n            _pool.exchange(\r\n                _getCRVPoolIndex(_tokenFrom, _pool), \r\n                _getCRVPoolIndex(_tokenTo, _pool),\r\n                _amountIn, \r\n                0\r\n            );\r\n            // Revoke allowance\r\n            IERC20(_tokenFrom).safeApprove(address(_pool), 0);\r\n            return (IERC20(_tokenTo).balanceOf(address(this)) - prevBalance);\r\n        }\r\n        \r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function used internally to quote a potential rebalancing swap without actually \r\n     * executing it. Same as the swap function, will simulate the trade either on the uni v3\r\n     * pool or CRV pool based on useCRVPool\r\n     * @param _tokenFrom, adress of token to swap from\r\n     * @param _tokenTo, address of token to swap to\r\n     * @param _amountIn, amount of _tokenIn to swap for _tokenTo\r\n     * @return simulated swapped amount\r\n     */\r\n    function quote(\r\n        address _tokenFrom,\r\n        address _tokenTo,\r\n        uint256 _amountIn\r\n    ) internal view override returns (uint256) {\r\n        require(_tokenTo == tokenA || _tokenTo == tokenB); // dev: must be a or b\r\n        require(_tokenFrom == tokenA || _tokenFrom == tokenB); // dev: must be a or b\r\n        if(!useCRVPool){\r\n            // Use uni v3 pool to swap\r\n            // Order of swap\r\n            bool zeroForOne = _tokenFrom < _tokenTo;\r\n\r\n            // Use the uniswap helper view to simulate the swap in the uni v3 pool\r\n            (int256 _amount0, int256 _amount1, , ) = UniswapHelperViews.simulateSwap(\r\n                // pool to use\r\n                IUniswapV3Pool(pool),\r\n                // order of swap\r\n                zeroForOne,\r\n                // amountSpecified\r\n                _amountIn.toInt256(),\r\n                // price limit\r\n                zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1\r\n            );\r\n\r\n            // Ensure amounts are returned in right order and sign (uni returns negative numbers)\r\n            return zeroForOne ? uint256(-_amount1) : uint256(-_amount0);\r\n        } else {\r\n            // Do NOT use uni pool use CRV pool\r\n            \r\n            ICRVPool _pool = ICRVPool(crvPool);\r\n\r\n            // Call the quote function in CRV pool\r\n            return _pool.get_dy(\r\n                _getCRVPoolIndex(_tokenFrom, _pool), \r\n                _getCRVPoolIndex(_tokenTo, _pool), \r\n                _amountIn\r\n            );\r\n        }\r\n        \r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function used internally to retrieve the CRV index for a token in a CRV pool, for example\r\n     * 3Pool uses:\r\n     * - 0 is DAI\r\n     * - 1 is USDC\r\n     * - 2 is USDT\r\n     * @return in128 containing the token's pool index\r\n     */\r\n    function _getCRVPoolIndex(address _token, ICRVPool _pool) internal view returns(int128) {\r\n        if(_pool.coins(0) == _token) {\r\n                return int128(0);\r\n            } else if (_pool.coins(1) == _token) {\r\n                return int128(1);\r\n            } else if (_pool.coins(2) == _token) {\r\n                return int128(2);\r\n            } else {\r\n                revert();\r\n            }\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function used internally to retrieve the details of the joint's LP position:\r\n     * - the amount of liquidity owned by this position\r\n     * - fee growth per unit of liquidity as of the last update to liquidity or fees owed\r\n     * - the fees owed to the position owner in token0/token1\r\n     * @return PositionInfo struct containing the position details\r\n     */\r\n    function _positionInfo()\r\n        private\r\n        view\r\n        returns (IUniswapV3Pool.PositionInfo memory)\r\n    {\r\n        bytes32 key = keccak256(\r\n            abi.encodePacked(address(this), minTick, maxTick)\r\n        );\r\n        return IUniswapV3Pool(pool).positions(key);\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function used by governance to swap tokens manually if needed, can be used when closing \r\n     * the LP position manually and need some re-balancing before sending funds back to the \r\n     * providers\r\n     * @param swapPath, path of addresses to swap, should be 2 and always tokenA <> tokenB\r\n     * @param swapInAmount, amount of swapPath[0] to swap for swapPath[1]\r\n     * @param minOutAmount, minimum amount of want out\r\n     * @return swapped amount\r\n     */\r\n    function swapTokenForTokenManually(\r\n        address[] memory swapPath,\r\n        uint256 swapInAmount,\r\n        uint256 minOutAmount\r\n    ) external onlyGovernance override returns (uint256) {\r\n        address _tokenA = tokenA;\r\n        address _tokenB = tokenB;\r\n        require(swapPath.length == 2);\r\n        require(swapPath[0] == _tokenA || swapPath[1] == _tokenA);\r\n        require(swapPath[0] == _tokenB || swapPath[1] == _tokenB);\r\n        return swap(\r\n            swapPath[0], \r\n            swapPath[1], \r\n            swapInAmount\r\n            );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_providerA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_providerB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referenceToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"_ticksFromCurrent\",\"type\":\"uint24\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"T\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"clone\",\"type\":\"address\"}],\"name\":\"Cloned\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"autoProtectionDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfRewardToken\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfTokensInLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_balanceA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_balanceB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"int24\",\"name\":\"_minTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"_maxTick\",\"type\":\"int24\"}],\"name\":\"burnLPManually\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_providerA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_providerB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referenceToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"_ticksFromCurrent\",\"type\":\"uint24\"}],\"name\":\"cloneUniV3StablesJoint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newJoint\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closePositionReturnFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crvPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dontInvestWant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estimatedTotalAssetsAfterBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_aBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"}],\"name\":\"estimatedTotalProviderAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getHedgeBudget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHedgeProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingB\",\"type\":\"uint256\"}],\"name\":\"getRatios\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_b\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimeToMaturity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvestTrigger\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_providerA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_providerB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referenceToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"_ticksFromCurrent\",\"type\":\"uint24\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investedA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investedB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOriginal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expectedBalanceA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedBalanceB\",\"type\":\"uint256\"}],\"name\":\"liquidatePositionManually\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPercentageLoss\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTick\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newProvider\",\"type\":\"address\"}],\"name\":\"migrateProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmountToSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minRewardToHarvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTick\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"providerA\",\"outputs\":[{\"internalType\":\"contract ProviderStrategy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"providerB\",\"outputs\":[{\"internalType\":\"contract ProviderStrategy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referenceToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedBalanceA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedBalanceB\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityManually\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnLooseToProvidersManually\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_autoProtectionDisabled\",\"type\":\"bool\"}],\"name\":\"setAutoProtectionDisabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_dontInvestWant\",\"type\":\"bool\"}],\"name\":\"setDontInvestWant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxPercentageLoss\",\"type\":\"uint256\"}],\"name\":\"setMaxPercentageLoss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minAmountToSell\",\"type\":\"uint256\"}],\"name\":\"setMinAmountToSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minRewardToHarvest\",\"type\":\"uint256\"}],\"name\":\"setMinRewardToHarvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"newTicksFromCurrent\",\"type\":\"uint24\"}],\"name\":\"setTicksFromCurrent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"_minTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"_maxTick\",\"type\":\"int24\"},{\"internalType\":\"bool\",\"name\":\"forceChange\",\"type\":\"bool\"}],\"name\":\"setTicksManually\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newUseCRVPool\",\"type\":\"bool\"}],\"name\":\"setUseCRVPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shouldEndEpoch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shouldStartEpoch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"swapPath\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"swapInAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOutAmount\",\"type\":\"uint256\"}],\"name\":\"swapTokenForTokenManually\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticksFromCurrent\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0Owed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Owed\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3MintCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"useCRVPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UniV3StablesJoint", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006059ef666807f69d535e2c19ba509e88c7e11f96000000000000000000000000d13a0052780009a47e02e96c456ae916010ecadf000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000003416cf6c708da44db2624d63ea0aaef7113527c60000000000000000000000000000000000000000000000000000000000000002", "EVMVersion": "Default", "Library": "UniswapHelperViews:7626bb31a75feef8889760201bd6a547af2f67b1", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d75d753f20d1b0df7fd5f36f91d78d1ec0c84caa5a1e2ffe41389ae2cae7352c"}]}