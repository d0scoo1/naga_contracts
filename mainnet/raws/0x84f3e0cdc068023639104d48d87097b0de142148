{"status": "1", "message": "OK", "result": [{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.12;\r\n\r\n\r\n\r\ninterface IOwnershipInstructorRegisterV1 {\r\n    struct Instructor{\r\n        address _impl;\r\n        string _name;\r\n    }\r\n  \r\n\r\n    event NewInstructor(address indexed _instructor,string _name);\r\n    event RemovedInstructor(address indexed _instructor,string _name);\r\n    event UnlinkedImplementation(string indexed _name,address indexed _implementation);\r\n    event LinkedImplementation(string indexed _name,address indexed _implementation);\r\n\r\n\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function getInstructorByName (string memory _name) external view returns(Instructor memory);\r\n\r\n    /**\r\n     * @dev Paginated to avoid risk of DoS.\r\n     * @notice Function that returns the implementations of a given Instructor (pages of 150 elements)\r\n     * @param _name name of instructor\r\n     * @param page page index, 0 is the first 150 elements of the list of implementation.\r\n     * @return _addresses list of implementations and _nextpage is the index of the next page, _nextpage is 0 if there is no more pages.\r\n     */\r\n    function getImplementationsOf(string memory _name,uint256 page)\r\n        external\r\n        view\r\n        returns (address[] memory _addresses,uint256 _nextpage);\r\n\r\n\r\n      /**\r\n     * @dev Paginated to avoid risk of DoS.\r\n     * @notice Function that returns the list of Instructor names (pages of 150 elements)\r\n     * @param page page index, 0 is the first 150 elements of the list of implementation.\r\n     * @return _names list of instructor names and _nextpage is the index of the next page, _nextpage is 0 if there are no more pages.\r\n     */\r\n    function getListOfInstructorNames(uint256 page)\r\n        external\r\n        view\r\n        returns (string[] memory _names,uint256 _nextpage);\r\n\r\n    function addInstructor(address _instructor,string memory _name) external;\r\n    function addInstructorAndImplementation(address _instructor,string memory _name, address _implementation) external;\r\n\r\n    function linkImplementationToInstructor(address _implementation,string memory _name) external;\r\n    function unlinkImplementationToInstructor(address _impl) external;\r\n\r\n    function removeInstructor(string memory _name) external;\r\n\r\n    function instructorGivenImplementation(address _impl)external view returns (Instructor memory _instructor);\r\n}\r\n\r\n// File: Interfaces/IOwnershipInstructor.sol\r\n\r\n\r\n/**\r\n * This is an interface of OwnershipInstructor\r\n * The goal of this contract is to allow people to integrate their contract into OwnershipChecker.sol\r\n * by generalising the obtention of the owner of NFTs.\r\n * The reason for this solution was because NFTs nowadays have standards, but not all NFTs support these standards.\r\n * The interface id for this is 0xb0f6fd7f;\r\n */\r\ninterface IOwnershipInstructor{\r\n\r\n/**\r\n * isValidInterface()\r\n * This function should be public and should be overriden.\r\n * It should obtain an address as input and should return a boolean value;\r\n * A positive result means the given address supports your contract's interface.\r\n * @dev This should be overriden and replaced with a set of instructions to check the given _impl if your contract's interface.\r\n * See ERC165 for help on interface support.\r\n * @param _impl address we want to check.\r\n * @return bool\r\n * \r\n */\r\n  function isValidInterface (address _impl) external view returns (bool);\r\n\r\n    /**\r\n    * This function should be public or External and should be overriden.\r\n    * It should obtain an address as implementation, a uint256 token Id and an optional _potentialOwner;\r\n    * It should return an address (or address zero is no owner);\r\n    * @dev This should be overriden and replaced with a set of instructions obtaining the owner of the given tokenId;\r\n    *\r\n    * @param _tokenId token id we want to grab the owner of.\r\n    * @param _impl Address of the NFT contract\r\n    * @param _potentialOwner (OPTIONAL) A potential owner, set address zero if no potentialOwner; Necessary for ERC1155\r\n    * @return a non zero address if the given tokenId has an owner; else if the token Id does not exist or has no owner, return zero address\r\n    * \r\n    */\r\n    function ownerOfTokenOnImplementation(address _impl,uint256 _tokenId,address _potentialOwner) external view  returns (address);\r\n}\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/ERC165Checker.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\r\n\r\n\r\n/**\r\n * @dev Library used to query support of an interface declared via {IERC165}.\r\n *\r\n * Note that these functions return the actual result of the query: they do not\r\n * `revert` if an interface is not supported. It is up to the caller to decide\r\n * what to do in these cases.\r\n */\r\nlibrary ERC165Checker {\r\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\r\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\r\n\r\n    /**\r\n     * @dev Returns true if `account` supports the {IERC165} interface,\r\n     */\r\n    function supportsERC165(address account) internal view returns (bool) {\r\n        // Any contract that implements ERC165 must explicitly indicate support of\r\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\r\n        return\r\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\r\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` supports the interface defined by\r\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\r\n        // query support of both ERC165 as per the spec and support of _interfaceId\r\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a boolean array where each value corresponds to the\r\n     * interfaces passed in and whether they're supported or not. This allows\r\n     * you to batch check interfaces for a contract where your expectation\r\n     * is that some interfaces may not be supported.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\r\n        internal\r\n        view\r\n        returns (bool[] memory)\r\n    {\r\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\r\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\r\n\r\n        // query support of ERC165 itself\r\n        if (supportsERC165(account)) {\r\n            // query support of each interface in interfaceIds\r\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\r\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\r\n            }\r\n        }\r\n\r\n        return interfaceIdsSupported;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` supports all the interfaces defined in\r\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\r\n     *\r\n     * Batch-querying can lead to gas savings by skipping repeated checks for\r\n     * {IERC165} support.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\r\n        // query support of ERC165 itself\r\n        if (!supportsERC165(account)) {\r\n            return false;\r\n        }\r\n\r\n        // query support of each interface in _interfaceIds\r\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\r\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // all interfaces supported\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Query if a contract implements an interface, does not check ERC165 support\r\n     * @param account The address of the contract to query for support of an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @return true if the contract at account indicates support of the interface with\r\n     * identifier interfaceId, false otherwise\r\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\r\n     * the behavior of this method is undefined. This precondition can be checked\r\n     * with {supportsERC165}.\r\n     * Interface identification is specified in ERC-165.\r\n     */\r\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\r\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\r\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\r\n        if (result.length < 32) return false;\r\n        return success && abi.decode(result, (bool));\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: InstructorRegister.sol\r\n\r\n\r\n\r\n/**\r\n * A register of OwnershipInstructor contracts that helps standardize \"ownerOf\" for NFTs.\r\n */\r\ncontract OwnershipInstructorRegisterV1 is Ownable,IOwnershipInstructorRegisterV1 {\r\n    bytes4 public immutable INSTRUCTOR_ID = type(IOwnershipInstructor).interfaceId;\r\n    using ERC165Checker for address;\r\n    ///@dev name of the contract\r\n    string internal __name;\r\n\r\n    ///@dev list of Ownership instructor contracts\r\n    Instructor[] public instructorRegister;\r\n    /**\r\n     * Hashed Name to instructorIndex lookup \r\n     */\r\n    mapping(bytes32 => uint256) internal nameToinstructorIndex;\r\n\r\n    ///@dev name (hashed) of instructor to list of implementations\r\n    mapping(address => string) public implementationToInstructorName;\r\n\r\n    ///@dev name (hashed) of instructor to list of implementations\r\n    mapping(bytes32=>address[]) internal instructorNameToImplementationList;\r\n\r\n    ///@dev implementation address to index inside instructorNameToImplementationList\r\n    mapping(address => uint256) internal implementationIndex;\r\n\r\n    /**\r\n     * Useful for knowing if a contract has already been registered\r\n     */\r\n    mapping(bytes32=>bool) internal registeredHash;    \r\n    /**\r\n     * Useful for knowing if a Contract Instructor name has already been registered\r\n     */\r\n    mapping(bytes32=>bool) internal registeredName;\r\n\r\n    // event NewInstructor(address indexed _instructor,string _name);\r\n    // event RemovedInstructor(address indexed _instructor,string _name);\r\n    // event UnlinkedImplementation(string indexed _name,address indexed _implementation);\r\n    // event LinkedImplementation(string indexed _name,address indexed _implementation);\r\n\r\n    constructor(){\r\n        __name=\"OwnershipInstructorRegisterV1\";\r\n    }\r\n\r\n    function hashInstructor(address _instructor) internal view returns (bytes32 _hash){\r\n        return keccak256(_instructor.code);\r\n    }\r\n\r\n    function hashName(string memory _name) internal pure returns (bytes32 _hash){\r\n        return keccak256(abi.encode(_name));\r\n    }\r\n\r\n    function name() public view returns (string memory){\r\n        return __name;\r\n    }\r\n\r\n    function getInstructorByName (string memory _name) public view returns(Instructor memory){\r\n        bytes32 _hash =hashName(_name);\r\n        require(registeredName[_hash],\"Name does not exist\");\r\n        return instructorRegister[nameToinstructorIndex[_hash]];\r\n    }\r\n    ///@dev the max number of items to show per page;\r\n    ///@dev only used in getImplementationsOf()\r\n    uint256 private constant _maxItemsPerPage = 150;\r\n    /**\r\n     * @dev Paginated to avoid risk of DoS.\r\n     * @notice Function that returns the implementations of a given Instructor (pages of 150 elements)\r\n     * @param _name name of instructor\r\n     * @param page page index, 0 is the first 150 elements of the list of implementation.\r\n     * @return _addresses list of implementations and _nextpage is the index of the next page, _nextpage is 0 if there is no more pages.\r\n     */\r\n    function getImplementationsOf(string memory _name,uint256 page)\r\n        public\r\n        view\r\n        returns (address[] memory _addresses,uint256 _nextpage)\r\n    {\r\n        bytes32 _nameHash =hashName(_name);\r\n        require(registeredName[_nameHash],\"Name does not exist\");\r\n        uint256 size = instructorNameToImplementationList[_nameHash].length;\r\n        uint256 offset = page*_maxItemsPerPage;\r\n        uint256 resultSize;\r\n        if(size>= _maxItemsPerPage+offset){\r\n            // size is above or equal to 150* page index + 150\r\n            resultSize = _maxItemsPerPage;\r\n        }else if (size< _maxItemsPerPage+offset){\r\n            // size is less than 150* page index + 150\r\n            resultSize = size - offset;\r\n        }\r\n        address[] memory addresses = new address[](resultSize);\r\n        uint256 index = 0;\r\n        for (uint256 i = offset; i < resultSize+offset; i++) {\r\n            addresses[index] = instructorNameToImplementationList[_nameHash][i];\r\n            index++;\r\n        }\r\n        if(size<=(addresses.length+offset)){\r\n            return (addresses,0);\r\n        }else{\r\n            return (addresses,page+1);\r\n        }\r\n        \r\n    }\r\n\r\n      /**\r\n     * @dev Paginated to avoid risk of DoS.\r\n     * @notice Function that returns the list of Instructor names (pages of 150 elements)\r\n     * @param page page index, 0 is the first 150 elements of the list of implementation.\r\n     * @return _names list of instructor names and _nextpage is the index of the next page, _nextpage is 0 if there are no more pages.\r\n     */\r\n    function getListOfInstructorNames(uint256 page)\r\n        public\r\n        view\r\n        returns (string[] memory _names,uint256 _nextpage)\r\n    {\r\n\r\n        uint256 size = instructorRegister.length;\r\n        uint256 offset = page*_maxItemsPerPage;\r\n        uint256 resultSize;\r\n        if(size>= _maxItemsPerPage+offset){\r\n            // size is above or equal to 150* page index + 150\r\n            resultSize = _maxItemsPerPage;\r\n        }else if (size< _maxItemsPerPage+offset){\r\n            // size is less than 150* page index + 150\r\n            resultSize = size - offset;\r\n        }\r\n        string[] memory names = new string[](resultSize);\r\n        uint256 index = 0;\r\n        for (uint256 i = offset; i < resultSize+offset; i++) {\r\n            names[index] = instructorRegister[i]._name;\r\n            index++;\r\n        }\r\n        if(size<=(names.length+offset)){\r\n            return (names,0);\r\n        }else{\r\n            return (names,page+1);\r\n        }\r\n        \r\n    }\r\n\r\n    function _safeAddInstructor(address _instructor,string memory _name) private {\r\n        bytes32 _hash = hashInstructor(_instructor);\r\n        bytes32 _nameHash = hashName(_name);\r\n        require(!registeredHash[_hash],\"Instructor has already been registered\");\r\n        require(!registeredName[_nameHash],\"Instructor Name already taken\");\r\n\r\n        Instructor memory _inst = Instructor(_instructor,_name);\r\n\r\n        instructorRegister.push(_inst);\r\n        //instructor inserted at last index.\r\n        nameToinstructorIndex[_nameHash]=instructorRegister.length-1;\r\n\r\n        registeredHash[_hash]=true;\r\n        registeredName[_nameHash]=true;\r\n    }\r\n\r\n    function addInstructor(address _instructor,string memory _name) public onlyOwner {\r\n        require(_instructor !=address(0),\"Instructor address cannot be address zero\");\r\n        require(bytes(_name).length>4,\"Name is too short\");\r\n        require(_instructor.supportsInterface(INSTRUCTOR_ID),\"Contract does not support instructor interface\");\r\n\r\n        _safeAddInstructor( _instructor, _name);\r\n\r\n        emit NewInstructor(_instructor, _name);\r\n    }\r\n\r\n    function addInstructorAndImplementation(address _instructor,string memory _name, address _implementation) public onlyOwner {\r\n        addInstructor(_instructor,_name);\r\n        \r\n        linkImplementationToInstructor( _implementation, _name);\r\n    }\r\n\r\n    function linkImplementationToInstructor(address _implementation,string memory _name) public onlyOwner {\r\n        require(bytes(implementationToInstructorName[_implementation]).length==0,\"Implementation already linked to an instructor\");\r\n        bytes32 _hash =hashName(_name);\r\n        require(registeredName[_hash],\"Name does not exist\");\r\n\r\n        implementationToInstructorName[_implementation]=_name;\r\n        instructorNameToImplementationList[_hash].push(_implementation);\r\n        implementationIndex[_implementation] = instructorNameToImplementationList[hashName(_name)].length-1;\r\n        // emit event;\r\n        emit LinkedImplementation(implementationToInstructorName[_implementation], _implementation);\r\n        \r\n    }\r\n\r\n    function unlinkImplementationToInstructor(address _impl) public onlyOwner {\r\n        require(bytes(implementationToInstructorName[_impl]).length!=0,\"Implementation already not linked to any instructor.\");\r\n        bytes32 _hashName = hashName(implementationToInstructorName[_impl]);\r\n\r\n        uint256 indexOfImplementation = implementationIndex[_impl];\r\n        address lastImplementation = instructorNameToImplementationList[_hashName][instructorNameToImplementationList[_hashName].length-1];\r\n        // emit event before unlinking;\r\n        emit UnlinkedImplementation(implementationToInstructorName[_impl], _impl);\r\n\r\n        implementationToInstructorName[_impl]=\"\";\r\n        instructorNameToImplementationList[_hashName][indexOfImplementation]=lastImplementation;\r\n        instructorNameToImplementationList[_hashName].pop();\r\n        \r\n        implementationIndex[lastImplementation] = indexOfImplementation;\r\n    }\r\n\r\n    function _safeRemoveInstructor(bytes32 _nameHash) private {\r\n\r\n        uint256 index = nameToinstructorIndex[_nameHash];\r\n        Instructor memory current = instructorRegister[index];\r\n        Instructor memory lastInstructor = instructorRegister[instructorRegister.length-1];\r\n\r\n        bytes32 _byteCodeHash = hashInstructor(current._impl);\r\n\r\n        registeredHash[_byteCodeHash]=false;\r\n        registeredName[_nameHash]=false;\r\n\r\n        instructorRegister[index] = lastInstructor;\r\n        instructorRegister.pop();\r\n        nameToinstructorIndex[_nameHash]=0;\r\n    }\r\n\r\n    function removeInstructor(string memory _name) public onlyOwner {\r\n        bytes32 _hash =hashName(_name);\r\n        Instructor memory _instructor = getInstructorByName(_name);\r\n        require(registeredName[_hash],\"Name does not exist\");\r\n        require(_instructor._impl!=address(0),\"Instructor does not exist\");\r\n\r\n        uint256 size = instructorNameToImplementationList[_hash].length;\r\n        for (uint256 i=0; i < size; i++) {  //for loop example\r\n            unlinkImplementationToInstructor(instructorNameToImplementationList[_hash][i]);\r\n        }\r\n\r\n        _safeRemoveInstructor(_hash);\r\n        emit RemovedInstructor(_instructor._impl, _name);\r\n    }\r\n\r\n    /**\r\n     * @dev Given an implementation, find the best Ownership instructor contract for it.\r\n     * @notice Find the best Ownership Instructor contract given the implementation address\r\n     * @param _impl address of an NFT contract.\r\n     */\r\n    function instructorGivenImplementation(address _impl)public view returns (Instructor memory _instructor) {\r\n\r\n        string memory _name = implementationToInstructorName[_impl];\r\n        if(bytes(_name).length > 0){\r\n            // Implementation was linked to an instructor contract, return the recorded Instructor;\r\n            return getInstructorByName(_name);\r\n        }\r\n        // If the implementation was never linked to an instructor\r\n        // Loop through the Instructors\r\n        uint256 size = instructorRegister.length;\r\n        // address _instrImpl;\r\n        // string memory _instrName;\r\n        for(uint256 i; i<size;i++ ){\r\n            if(IOwnershipInstructor(instructorRegister[i]._impl).isValidInterface(_impl)){\r\n                // _instrImpl = instructorRegister[i]._impl;\r\n                // _instrName = instructorRegister[i]._name;\r\n                _instructor =instructorRegister[i];\r\n                break;\r\n            }\r\n        }\r\n        return _instructor;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"LinkedImplementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_instructor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"NewInstructor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_instructor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"RemovedInstructor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"UnlinkedImplementation\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INSTRUCTOR_ID\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_instructor\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"addInstructor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_instructor\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"addInstructorAndImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"getImplementationsOf\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_nextpage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"getInstructorByName\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"internalType\":\"struct IOwnershipInstructorRegisterV1.Instructor\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"getListOfInstructorNames\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"_names\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"_nextpage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"implementationToInstructorName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"}],\"name\":\"instructorGivenImplementation\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"internalType\":\"struct IOwnershipInstructorRegisterV1.Instructor\",\"name\":\"_instructor\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"instructorRegister\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"linkImplementationToInstructor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"removeInstructor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"}],\"name\":\"unlinkImplementationToInstructor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OwnershipInstructorRegisterV1", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://200458c0d90ead94bff94fd9f989592f31562e3b8e9edb154eb46ba70080164c"}]}