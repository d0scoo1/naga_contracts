{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: ERC721/ERC721TokenReceiver.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\r\ninterface ERC721TokenReceiver {\r\n\tfunction onERC721Received(\r\n\t\taddress operator,\r\n\t\taddress from,\r\n\t\tuint256 id,\r\n\t\tbytes calldata data\r\n\t) external returns (bytes4);\r\n}\r\n// File: ERC721/ERC721.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nabstract contract ERC721 {\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                                   EVENTS                                   */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @dev Emitted when `id` token is transferred from `from` to `to`.\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed id);\r\n\r\n\t/// @dev Emitted when `owner` enables `approved` to manage the `id` token.\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 indexed id);\r\n\r\n\t/// @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                              METADATA STORAGE                              */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @dev The collection name.\r\n\tstring private _name;\r\n\r\n\t/// @dev The collection symbol.\r\n\tstring private _symbol;\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                               ERC721 STORAGE                               */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @dev ID => spender\r\n\tmapping(uint256 => address) internal _tokenApprovals;\r\n\r\n\t/// @dev owner => operator => approved\r\n\tmapping(address => mapping(address => bool)) internal _operatorApprovals;\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                                 CONSTRUCTOR                                */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @param name_ The collection name.\r\n\t/// @param symbol_ The collection symbol.\r\n\tconstructor(string memory name_, string memory symbol_) {\r\n\t\t_name = name_;\r\n\t\t_symbol = symbol_;\r\n\t}\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                                ERC165 LOGIC                                */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @notice Returns true if this contract implements an interface from its ID.\r\n\t/// @dev See the corresponding\r\n\t/// [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n\t/// to learn more about how these IDs are created.\r\n\t/// @return The implementation status.\r\n\tfunction supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\r\n\t\treturn\r\n\t\t\tinterfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\r\n\t\t\tinterfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\r\n\t\t\tinterfaceId == 0x5b5e139f || // ERC165 Interface ID for ERC721Metadata\r\n\t\t\tinterfaceId == 0x780e9d63; // ERC165 Interface ID for ERC721Enumerable\r\n\t}\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                               METADATA LOGIC                               */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @notice Returns the collection name.\r\n\t/// @return The collection name.\r\n\tfunction name() public view virtual returns (string memory) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\t/// @notice Returns the collection symbol.\r\n\t/// @return The collection symbol.\r\n\tfunction symbol() public view virtual returns (string memory) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\t/// @notice Returns the Uniform Resource Identifier (URI) for `id` token.\r\n\t/// @param id The token ID.\r\n\t/// @return The URI.\r\n\tfunction tokenURI(uint256 id) public view virtual returns (string memory);\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                              ENUMERABLE LOGIC                              */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @notice Returns the total amount of tokens stored by the contract.\r\n\t/// @return The token supply.\r\n\tfunction totalSupply() public view virtual returns (uint256);\r\n\r\n\t/// @notice Returns a token ID owned by `owner` at a given `index` of its token list.\r\n\t/// @dev Use along with {balanceOf} to enumerate all of `owner`'s tokens.\r\n\t/// @param owner The address to query.\r\n\t/// @param index The index to query.\r\n\t/// @return The token ID.\r\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256);\r\n\r\n\t/// @notice Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n\t/// @dev Use along with {totalSupply} to enumerate all tokens.\r\n\t/// @param index The index to query.\r\n\t/// @return The token ID.\r\n\tfunction tokenByIndex(uint256 index) public view virtual returns (uint256);\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                                ERC721 LOGIC                                */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @notice Returns the account approved for a token ID.\r\n\t/// @dev Requirements:\r\n\t/// - `id` must exist.\r\n\t/// @param id Token ID to query.\r\n\t/// @return The account approved for `id` token.\r\n\tfunction getApproved(uint256 id) public virtual returns (address) {\r\n\t\trequire(_exists(id), \"NONEXISTENT_TOKEN\");\r\n\t\treturn _tokenApprovals[id];\r\n\t}\r\n\r\n\t/// @notice Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n\t/// @param owner The address of the owner.\r\n\t/// @param operator The address of the operator.\r\n\t/// @return True if `operator` was approved by `owner`.\r\n\tfunction isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\r\n\t\treturn _operatorApprovals[owner][operator];\r\n\t}\r\n\r\n\t/// @notice Gives permission to `to` to transfer `id` token to another account.\r\n\t/// @dev The approval is cleared when the token is transferred.\r\n\t/// Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n\t/// Requirements:\r\n\t/// - The caller must own the token or be an approved operator.\r\n\t/// - `id` must exist.\r\n\t/// Emits an {Approval} event.\r\n\t/// @param spender The address of the spender to approve to.\r\n\t/// @param id The token ID to approve.\r\n\tfunction approve(address spender, uint256 id) public virtual {\r\n\t\taddress owner = ownerOf(id);\r\n\r\n\t\trequire(isApprovedForAll(owner, msg.sender) || msg.sender == owner, \"NOT_AUTHORIZED\");\r\n\r\n\t\t_tokenApprovals[id] = spender;\r\n\r\n\t\temit Approval(owner, spender, id);\r\n\t}\r\n\r\n\t/// @notice Approve or remove `operator` as an operator for the caller.\r\n\t/// @dev Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n\t/// Emits an {ApprovalForAll} event.\r\n\t/// @param operator The address of the operator to approve.\r\n\t/// @param approved The status to set.\r\n\tfunction setApprovalForAll(address operator, bool approved) public virtual {\r\n\t\t_operatorApprovals[msg.sender][operator] = approved;\r\n\r\n\t\temit ApprovalForAll(msg.sender, operator, approved);\r\n\t}\r\n\r\n\t/// @notice Transfers `id` token from `from` to `to`.\r\n\t/// WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n\t/// @dev Requirements:\r\n\t/// - `to` cannot be the zero address.\r\n\t/// - `id` token must be owned by `from`.\r\n\t/// - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n\t/// Emits a {Transfer} event.\r\n\t/// @param from The address to transfer from.\r\n\t/// @param to The address to transfer to.\r\n\t/// @param id The token ID to transfer.\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 id\r\n\t) public virtual {\r\n\t\t_transfer(from, to, id);\r\n\t}\r\n\r\n\t/// @notice Safely transfers `id` token from `from` to `to`.\r\n\t/// @dev Requirements:\r\n\t/// - `to` cannot be the zero address.\r\n\t/// - `id` token must exist and be owned by `from`.\r\n\t/// - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n\t/// - If `to` refers to a smart contract, it must implement {ERC721TokenReceiver-onERC721Received}, which is called upon a safe transfer.\r\n\t/// Emits a {Transfer} event.\r\n\t/// @param from The address to transfer from.\r\n\t/// @param to The address to transfer to.\r\n\t/// @param id The token ID to transfer.\r\n\tfunction safeTransferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 id\r\n\t) public virtual {\r\n\t\t_transfer(from, to, id);\r\n\r\n\t\trequire(to.code.length == 0 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") == ERC721TokenReceiver.onERC721Received.selector, \"UNSAFE_RECIPIENT\");\r\n\t}\r\n\r\n\t/// @notice Safely transfers `id` token from `from` to `to`.\r\n\t/// @dev Requirements:\r\n\t/// - `to` cannot be the zero address.\r\n\t/// - `id` token must exist and be owned by `from`.\r\n\t/// - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n\t/// - If `to` refers to a smart contract, it must implement {ERC721TokenReceiver-onERC721Received}, which is called upon a safe transfer.\r\n\t/// Emits a {Transfer} event.\r\n\t/// Additionally passes `data` in the callback.\r\n\t/// @param from The address to transfer from.\r\n\t/// @param to The address to transfer to.\r\n\t/// @param id The token ID to transfer.\r\n\t/// @param data The calldata to pass in the {ERC721TokenReceiver-onERC721Received} callback.\r\n\tfunction safeTransferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 id,\r\n\t\tbytes memory data\r\n\t) public virtual {\r\n\t\t_transfer(from, to, id);\r\n\r\n\t\trequire(to.code.length == 0 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) == ERC721TokenReceiver.onERC721Received.selector, \"UNSAFE_RECIPIENT\");\r\n\t}\r\n\r\n\t/// @notice Returns the number of tokens in an account.\r\n\t/// @param owner The address to query.\r\n\t/// @return The balance.\r\n\tfunction balanceOf(address owner) public view virtual returns (uint256);\r\n\r\n\t/// @notice Returns the owner of a token ID.\r\n\t/// @dev Requirements:\r\n\t/// - `id` must exist.\r\n\t/// @param id The token ID.\r\n\tfunction ownerOf(uint256 id) public view virtual returns (address);\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                               INTERNAL LOGIC                               */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @dev Returns whether a token ID exists.\r\n\t/// Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n\t/// Tokens start existing when they are minted.\r\n\t/// @param id Token ID to query.\r\n\tfunction _exists(uint256 id) internal view virtual returns (bool);\r\n\r\n\t/// @dev Transfers `id` from `from` to `to`.\r\n\t/// Requirements:\r\n\t/// - `to` cannot be the zero address.\r\n\t/// - `id` token must be owned by `from`.\r\n\t/// Emits a {Transfer} event.\r\n\t/// @param from The address to transfer from.\r\n\t/// @param to The address to transfer to.\r\n\t/// @param id The token ID to transfer.\r\n\tfunction _transfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 id\r\n\t) internal virtual;\r\n\r\n\t/// @dev Mints `amount` tokens to `to`.\r\n\t/// Requirements:\r\n\t/// - there must be `amount` tokens remaining unminted in the total collection.\r\n\t/// - `to` cannot be the zero address.\r\n\t/// Emits `amount` {Transfer} events.\r\n\t/// @param to The address to mint to.\r\n\t/// @param amount The amount of tokens to mint.\r\n\tfunction _mint(address to, uint256 amount) internal virtual;\r\n\r\n\t/// @dev Safely mints `amount` of tokens and transfers them to `to`.\r\n\t/// If `to` is a contract it must implement {ERC721TokenReceiver.onERC721Received}\r\n\t/// that returns {ERC721TokenReceiver.onERC721Received.selector}.\r\n\t/// @param to The address to mint to.\r\n\t/// @param amount The amount of tokens to mint.\r\n\tfunction _safeMint(address to, uint256 amount) internal virtual {\r\n\t\t_mint(to, amount);\r\n\r\n\t\trequire(to.code.length == 0 || ERC721TokenReceiver(to).onERC721Received(address(0), to, totalSupply() - amount + 1, \"\") == ERC721TokenReceiver.onERC721Received.selector, \"UNSAFE_RECIPIENT\");\r\n\t}\r\n\r\n\t/// @dev Safely mints `amount` of tokens and transfers them to `to`.\r\n\t/// Requirements:\r\n\t/// - `id` must not exist.\r\n\t/// - If `to` refers to a smart contract, it must implement {ERC721TokenReceiver.onERC721Received}, which is called upon a safe transfer.\r\n\t/// Additionally passes `data` in the callback.\r\n\t/// @param to The address to mint to.\r\n\t/// @param amount The amount of tokens to mint.\r\n\t/// @param data The calldata to pass in the {ERC721TokenReceiver.onERC721Received} callback.\r\n\tfunction _safeMint(\r\n\t\taddress to,\r\n\t\tuint256 amount,\r\n\t\tbytes memory data\r\n\t) internal virtual {\r\n\t\t_mint(to, amount);\r\n\r\n\t\trequire(to.code.length == 0 || ERC721TokenReceiver(to).onERC721Received(address(0), to, totalSupply() - amount + 1, data) == ERC721TokenReceiver.onERC721Received.selector, \"UNSAFE_RECIPIENT\");\r\n\t}\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                                    UTILS                                   */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @notice Converts a `uint256` to its ASCII `string` decimal representation.\r\n\t/// @dev https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\r\n\tfunction toString(uint256 value) internal pure virtual returns (string memory) {\r\n\t\t// Inspired by OraclizeAPI's implementation - MIT licence\r\n\t\t// https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n\t\tif (value == 0) {\r\n\t\t\treturn \"0\";\r\n\t\t}\r\n\t\tuint256 temp = value;\r\n\t\tuint256 digits;\r\n\t\twhile (temp != 0) {\r\n\t\t\tdigits++;\r\n\t\t\ttemp /= 10;\r\n\t\t}\r\n\t\tbytes memory buffer = new bytes(digits);\r\n\t\twhile (value != 0) {\r\n\t\t\tdigits -= 1;\r\n\t\t\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n\t\t\tvalue /= 10;\r\n\t\t}\r\n\t\treturn string(buffer);\r\n\t}\r\n}\r\n// File: ERC721/extensions/ERC721Tradable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/// @notice An interface for the OpenSea Proxy Registry.\r\ninterface IProxyRegistry {\r\n\tfunction proxies(address) external view returns (address);\r\n}\r\n\r\nabstract contract ERC721Tradable is ERC721 {\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                              IMMUTABLE STORAGE                             */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @notice The OpenSea Proxy Registry address.\r\n\taddress public immutable openSeaProxyRegistry;\r\n\r\n\t/// @notice The LooksRare Transfer Manager (ERC721) address.\r\n\taddress public immutable looksRareTransferManager;\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                               MUTABLE STORAGE                              */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @notice Returns true if the stored marketplace addresses are whitelisted in {isApprovedForAll}.\r\n\t/// @dev Enabled by default. Can be turned off with {setMarketplaceApprovalForAll}.\r\n\tbool public marketPlaceApprovalForAll = true;\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                                 CONSTRUCTOR                                */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// OpenSea proxy registry addresses:\r\n\t/// - ETHEREUM MAINNET: 0xa5409ec958C83C3f309868babACA7c86DCB077c1\r\n\t/// - ETHEREUM RINKEBY: 0xF57B2c51dED3A29e6891aba85459d600256Cf317\r\n\t/// LooksRare Transfer Manager addresses (https://docs.looksrare.org/developers/deployed-contract-addresses):\r\n\t/// - ETHEREUM MAINNET: 0xf42aa99F011A1fA7CDA90E5E98b277E306BcA83e\r\n\t/// - ETHEREUM RINKEBY: 0x3f65A762F15D01809cDC6B43d8849fF24949c86a\r\n\t/// @param _openSeaProxyRegistry The OpenSea proxy registry address.\r\n\tconstructor(address _openSeaProxyRegistry, address _looksRareTransferManager) {\r\n\t\trequire(_openSeaProxyRegistry != address(0) && _looksRareTransferManager != address(0), \"INVALID_ADDRESS\");\r\n\t\topenSeaProxyRegistry = _openSeaProxyRegistry;\r\n\t\tlooksRareTransferManager = _looksRareTransferManager;\r\n\t}\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                            ERC721ATradable LOGIC                           */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @notice Enables or disables the marketplace whitelist in {isApprovedForAll}.\r\n\t/// @dev Must be implemented in inheriting contracts.\r\n\t/// Recommended to use in combination with an access control contract (e.g. OpenZeppelin's Ownable).\r\n\tfunction setMarketplaceApprovalForAll(bool approved) public virtual;\r\n\r\n\t/// @return True if `operator` is a whitelisted marketplace contract or if it was approved by `owner` with {ERC721A.setApprovalForAll}.\r\n\t/// @inheritdoc ERC721\r\n\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n\t\tif (marketPlaceApprovalForAll && (operator == IProxyRegistry(openSeaProxyRegistry).proxies(owner) || operator == looksRareTransferManager)) return true;\r\n\t\treturn super.isApprovedForAll(owner, operator);\r\n\t}\r\n}\r\n// File: ERC721/ERC721M.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nabstract contract ERC721M is ERC721 {\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                               ERC721M STORAGE                              */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @dev The index is the token ID counter and points to its owner.\r\n\taddress[] internal _owners;\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                                 CONSTRUCTOR                                */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\tconstructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {\r\n\t\t// Initializes the index to 1.\r\n\t\t_owners.push();\r\n\t}\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                              ENUMERABLE LOGIC                              */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @inheritdoc ERC721\r\n\tfunction totalSupply() public view override returns (uint256) {\r\n\t\t// Overflow is impossible as _owners.length is initialized to 1.\r\n\t\tunchecked {\r\n\t\t\treturn _owners.length - 1;\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev O(totalSupply), it is discouraged to call this function from other contracts\r\n\t/// as it can become very expensive, especially with higher total collection sizes.\r\n\t/// @inheritdoc ERC721\r\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\r\n\t\trequire(index < balanceOf(owner), \"INVALID_INDEX\");\r\n\r\n\t\t// Both of the counters cannot overflow because the loop breaks before that.\r\n\t\tunchecked {\r\n\t\t\tuint256 count;\r\n\t\t\tuint256 _currentIndex = _owners.length; // == totalSupply() + 1 == _owners.length - 1 + 1\r\n\t\t\tfor (uint256 i; i < _currentIndex; i++) {\r\n\t\t\t\tif (owner == ownerOf(i)) {\r\n\t\t\t\t\tif (count == index) return i;\r\n\t\t\t\t\telse count++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trevert(\"NOT_FOUND\");\r\n\t}\r\n\r\n\t/// @inheritdoc ERC721\r\n\tfunction tokenByIndex(uint256 index) public view virtual override returns (uint256) {\r\n\t\trequire(_exists(index), \"INVALID_INDEX\");\r\n\t\treturn index;\r\n\t}\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                                ERC721 LOGIC                                */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @dev O(totalSupply), it is discouraged to call this function from other contracts\r\n\t/// as it can become very expensive, especially with higher total collection sizes.\r\n\t/// @inheritdoc ERC721\r\n\tfunction balanceOf(address owner) public view virtual override returns (uint256 balance) {\r\n\t\trequire(owner != address(0), \"INVALID_OWNER\");\r\n\r\n\t\tunchecked {\r\n\t\t\t// Start at 1 since token 0 does not exist\r\n\t\t\tuint256 _currentIndex = _owners.length; // == totalSupply() + 1 == _owners.length - 1 + 1\r\n\t\t\tfor (uint256 i = 1; i < _currentIndex; i++) {\r\n\t\t\t\tif (owner == ownerOf(i)) {\r\n\t\t\t\t\tbalance++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/// @dev O(MAX_TX), gradually moves to O(1) as more tokens get transferred and\r\n\t/// the owners are explicitly set.\r\n\t/// @inheritdoc ERC721\r\n\tfunction ownerOf(uint256 id) public view virtual override returns (address owner) {\r\n\t\trequire(_exists(id), \"NONEXISTENT_TOKEN\");\r\n\r\n\t\tfor (uint256 i = id; ; i++) {\r\n\t\t\towner = _owners[i];\r\n\t\t\tif (owner != address(0)) {\r\n\t\t\t\treturn owner;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                               INTERNAL LOGIC                               */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @inheritdoc ERC721\r\n\tfunction _mint(address to, uint256 amount) internal virtual override {\r\n\t\trequire(to != address(0), \"INVALID_RECIPIENT\");\r\n\t\trequire(amount != 0, \"INVALID_AMOUNT\");\r\n\r\n\t\tunchecked {\r\n\t\t\tuint256 _currentIndex = _owners.length; // == totalSupply() + 1 == _owners.length - 1 + 1\r\n\r\n\t\t\tfor (uint256 i; i < amount - 1; i++) {\r\n\t\t\t\t// storing address(0) while also incrementing the index\r\n\t\t\t\t_owners.push();\r\n\t\t\t\temit Transfer(address(0), to, _currentIndex + i);\r\n\t\t\t}\r\n\r\n\t\t\t// storing the actual owner\r\n\t\t\t_owners.push(to);\r\n\t\t\temit Transfer(address(0), to, _currentIndex + (amount - 1));\r\n\t\t}\r\n\t}\r\n\r\n\t/// @inheritdoc ERC721\r\n\tfunction _exists(uint256 id) internal view virtual override returns (bool) {\r\n\t\treturn id != 0 && id < _owners.length;\r\n\t}\r\n\r\n\t/// @inheritdoc ERC721\r\n\tfunction _transfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 id\r\n\t) internal virtual override {\r\n\t\trequire(ownerOf(id) == from, \"WRONG_FROM\");\r\n\t\trequire(to != address(0), \"INVALID_RECIPIENT\");\r\n\t\trequire(msg.sender == from || getApproved(id) == msg.sender || isApprovedForAll(from, msg.sender), \"NOT_AUTHORIZED\");\r\n\r\n\t\tdelete _tokenApprovals[id];\r\n\r\n\t\t_owners[id] = to;\r\n\r\n\t\tunchecked {\r\n\t\t\tuint256 prevId = id - 1;\r\n\t\t\tif (_owners[prevId] == address(0)) {\r\n\t\t\t\t_owners[prevId] = from;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\temit Transfer(from, to, id);\r\n\t}\r\n}\r\n// File: Bendys.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract Bendys is ERC721M, ERC721Tradable, Ownable {\r\n\tuint256 public constant PRICE = 0.02 ether;\r\n\r\n\tuint256 public constant MAX_SUPPLY = 2222;\r\n\tuint256 public constant MAX_RESERVE = 22;\r\n\tuint256 public constant MAX_PUBLIC = 2200; // MAX_SUPPLY - MAX_RESERVE\r\n\tuint256 public constant MAX_FREE = 150;\r\n\r\n\tuint256 public constant MAX_TX = 20;\r\n\r\n\tuint256 public reservesMinted;\r\n\r\n\tstring public baseURI;\r\n\r\n\tbool public isSaleActive;\r\n\r\n\tmapping (address => bool) public hasClaimed;\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                                 CONSTRUCTOR                                */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\tconstructor(\r\n\t\taddress _openSeaProxyRegistry,\r\n\t\taddress _looksRareTransferManager,\r\n\t\tstring memory _baseURI\r\n\t) payable ERC721M(\"Bendys\", \"BENDYS\") ERC721Tradable(_openSeaProxyRegistry, _looksRareTransferManager) {\r\n\t\tbaseURI = _baseURI;\r\n\t}\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                                    USER                                    */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @notice Mints an amount of tokens and transfers them to the caller during the public sale.\r\n\t/// @param amount The amount of tokens to mint.\r\n\tfunction publicMint(uint256 amount) external payable {\r\n\t\trequire(isSaleActive, \"Sale is not active\");\r\n\t\trequire(msg.sender == tx.origin, \"No contracts allowed\");\r\n\r\n\t\tuint256 _totalSupply = totalSupply();\r\n\t\tif (_totalSupply < MAX_FREE) {\r\n\t\t\trequire(!hasClaimed[msg.sender], \"Already claimed\");\r\n\t\t\thasClaimed[msg.sender] = true;\r\n\t\t\t\r\n\t\t\t_mint(msg.sender, 1);\r\n\t\t\t\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\t\r\n\t\trequire(msg.value == PRICE * amount, \"Wrong ether amount\");\r\n\t\trequire(amount <= MAX_TX, \"Amount exceeds tx limit\");\r\n\t\trequire(_totalSupply + amount <= MAX_PUBLIC, \"Max public supply reached\");\r\n\r\n\t\t_mint(msg.sender, amount);\r\n\t}\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                                    OWNER                                   */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @notice Enables or disables minting through {publicMint}.\r\n\t/// @dev Requirements:\r\n\t/// - Caller must be the owner.\r\n\tfunction setIsSaleActive(bool _isSaleActive) external onlyOwner {\r\n\t\tisSaleActive = _isSaleActive;\r\n\t}\r\n\r\n\t/// @notice Mints tokens to multiple addresses.\r\n\t/// @dev Requirements:\r\n\t/// - Caller must be the owner.\r\n\t/// @param recipients The addresses to mint the tokens to.\r\n\t/// @param amounts The amounts of tokens to mint.\r\n\tfunction reserveMint(address[] calldata recipients, uint256[] calldata amounts) external onlyOwner {\r\n\t\tunchecked {\r\n\t\t\tuint256 sum;\r\n\t\t\tuint256 length = recipients.length;\r\n\t\t\tfor (uint256 i; i < length; i++) {\r\n\t\t\t\taddress to = recipients[i];\r\n\t\t\t\trequire(to != address(0), \"Invalid recipient\");\r\n\t\t\t\tuint256 amount = amounts[i];\r\n\r\n\t\t\t\t_mint(to, amount);\r\n\t\t\t\tsum += amount;\r\n\t\t\t}\r\n\r\n\t\t\tuint256 totalReserves = reservesMinted + sum;\r\n\r\n\t\t\trequire(totalSupply() <= MAX_SUPPLY, \"Max supply reached\");\r\n\t\t\trequire(totalReserves <= MAX_RESERVE, \"Amount exceeds reserve limit\");\r\n\r\n\t\t\treservesMinted = totalReserves;\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice Sets the base Uniform Resource Identifier (URI) for token metadata.\r\n\t/// @dev Requirements:\r\n\t/// - Caller must be the owner.\r\n\t/// @param _baseURI The base URI.\r\n\tfunction setBaseURI(string calldata _baseURI) external onlyOwner {\r\n\t\tbaseURI = _baseURI;\r\n\t}\r\n\r\n\t/// @notice Withdraws all contract balance to the caller.\r\n\t/// @dev Requirements:\r\n\t/// - Caller must be the owner.\r\n\tfunction withdrawETH() external onlyOwner {\r\n\t\t_transferETH(msg.sender, address(this).balance);\r\n\t}\r\n\r\n\t/// @dev Requirements:\r\n\t/// - Caller must be the owner.\r\n\t/// @inheritdoc ERC721Tradable\r\n\tfunction setMarketplaceApprovalForAll(bool approved) public override onlyOwner {\r\n\t\tmarketPlaceApprovalForAll = approved;\r\n\t}\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                             SOLIDITY OVERRIDES                             */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\t/// @inheritdoc ERC721\r\n\tfunction tokenURI(uint256 id) public view override returns (string memory) {\r\n\t\trequire(_exists(id), \"NONEXISTENT_TOKEN\");\r\n\t\tstring memory _baseURI = baseURI;\r\n\t\treturn bytes(_baseURI).length == 0 ? \"\" : string(abi.encodePacked(_baseURI, toString(id)));\r\n\t}\r\n\r\n\t/// @inheritdoc ERC721Tradable\r\n\tfunction isApprovedForAll(address owner, address operator) public view override(ERC721, ERC721Tradable) returns (bool) {\r\n\t\treturn ERC721Tradable.isApprovedForAll(owner, operator);\r\n\t}\r\n\r\n\t/* -------------------------------------------------------------------------- */\r\n\t/*                                    UTILS                                   */\r\n\t/* -------------------------------------------------------------------------- */\r\n\r\n\tfunction _transferETH(address to, uint256 value) internal {\r\n\t\t// solhint-disable-next-line avoid-low-level-calls\r\n\t\t(bool success, ) = to.call{ value: value }(\"\");\r\n\t\trequire(success, \"ETH transfer failed\");\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_openSeaProxyRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_looksRareTransferManager\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_FREE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PUBLIC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_RESERVE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSaleActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"looksRareTransferManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketPlaceApprovalForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openSeaProxyRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"publicMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"reserveMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reservesMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isSaleActive\",\"type\":\"bool\"}],\"name\":\"setIsSaleActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setMarketplaceApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Bendys", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000a5409ec958c83c3f309868babaca7c86dcb077c1000000000000000000000000f42aa99f011a1fa7cda90e5e98b277e306bca83e0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000005568747470733a2f2f62656e6479736e66742e6d7970696e6174612e636c6f75642f697066732f516d504b394d5243506e465941346269634d34643957437350637a4b6e79363751526e4774765a586d6e507073392f0000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bcc9d19db706e10e4c971dbc80d95d4b2226e0437a46b8b4dd7b99e1ed154cca"}]}