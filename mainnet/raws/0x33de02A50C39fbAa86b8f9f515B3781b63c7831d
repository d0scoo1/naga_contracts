{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Genesis_descriptor.sol\": {\r\n      \"content\": \"//\\tSPDX-License-Identifier: MIT\\n\\n/// @title  ETHTerrestrials by Kye descriptor (v1). An on-chain migration of assets from the OpenSea shared storefront token.\\n/// @notice Image and traits stored on-chain (non-generative)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./InflateLib.sol\\\";\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./Base64.sol\\\";\\nimport \\\"@0xsequence/sstore2/contracts/SSTORE2.sol\\\";\\n\\ncontract EthTerrestrialsGenesisDescriptor {\\n   using Strings for uint8;\\n   using Strings for uint256;\\n   using InflateLib for bytes;\\n\\n   /// @notice Storage entry for a token\\n   struct Token {\\n      address imageStore; //SSTORE2 storage location for a base64 encoded PNG, compressed using DEFLATE (python zlib). Header (first 2 bytes) and checksum (last 4 bytes) truncated.\\n      uint96 imagelen; //The length of the uncomressed image data (required for decompression).\\n      uint8[] buildCode; //Each token's traits.\\n   }\\n   mapping(uint256 => Token) public tokenData;\\n\\n   /// @notice Storage of the two types of traits\\n   mapping(uint256 => string) public skincolor;\\n   mapping(uint256 => string) public accesories;\\n\\n   /// @notice Storage entry for an animated frame\\n   struct Frame {\\n      address imageStore; //SSTORE2 storage location for a base64 encoded PNG, compressed using DEFLATE (python zlib). Header (first 2 bytes) and checksum (last 4 bytes) truncated.\\n      uint96 imagelen; //The length of the uncomressed image data (required for decompression).\\n   }\\n\\n   /// @notice A mapping of frame components for animated tokens in the format animationFrames[tokenId][frame number].\\n   /// @dev each frame is a base64 encoded PNG. In order to save storage space, each frame PNG only contains pixels that differ from frame 0\\n   mapping(uint256 => mapping(uint256 => Frame)) public animationFrames;\\n\\n   /// @notice Permanently seals the metadata in the contract from being modified by deployer.\\n   bool public contractsealed;\\n\\n   address private deployer;\\n\\n   constructor() public {\\n      deployer = msg.sender;\\n   }\\n\\n   modifier onlyDeployerWhileUnsealed() {\\n      require(!contractsealed && msg.sender == deployer, \\\"Not authorized or locked\\\");\\n      _;\\n   }\\n\\n   string imageTagOpen =\\n      '<image x=\\\"0\\\" y=\\\"0\\\" width=\\\"24\\\" height=\\\"24\\\" image-rendering=\\\"pixelated\\\" preserveAspectRatio=\\\"xMidYMid\\\" xlink:href=\\\"data:image/png;base64,';\\n\\n   /*\\n.___  ___.  _______ .___________.    ___       _______       ___   .___________.    ___      \\n|   \\\\/   | |   ____||           |   /   \\\\     |       \\\\     /   \\\\  |           |   /   \\\\     \\n|  \\\\  /  | |  |__   `---|  |----`  /  ^  \\\\    |  .--.  |   /  ^  \\\\ `---|  |----`  /  ^  \\\\    \\n|  |\\\\/|  | |   __|      |  |      /  /_\\\\  \\\\   |  |  |  |  /  /_\\\\  \\\\    |  |      /  /_\\\\  \\\\   \\n|  |  |  | |  |____     |  |     /  _____  \\\\  |  '--'  | /  _____  \\\\   |  |     /  _____  \\\\  \\n|__|  |__| |_______|    |__|    /__/     \\\\__\\\\ |_______/ /__/     \\\\__\\\\  |__|    /__/     \\\\__\\\\ \\n*/\\n\\n   /// @notice Generates a list of traits\\n   /// @param tokenId, the desired tokenId\\n   /// @return traits, a string array\\n   function viewTraits(uint256 tokenId) public view returns (string[] memory) {\\n      uint256 length = tokenData[tokenId].buildCode.length;\\n      string[] memory traits = new string[](length);\\n\\n      for (uint256 i; i < length; i++) {\\n         uint8 thisTrait = tokenData[tokenId].buildCode[i];\\n         if (i == 0) {\\n            traits[i] = skincolor[thisTrait];\\n         } else {\\n            traits[i] = accesories[thisTrait];\\n         }\\n      }\\n      return traits;\\n   }\\n\\n   /// @notice Generates an ERC721 standard metadata JSON string\\n   /// @param tokenId, the desired tokenId\\n   /// @return json, a JSON metadata string\\n   function viewTraitsJSON(uint256 tokenId) public view returns (string memory) {\\n      uint256 length = tokenData[tokenId].buildCode.length;\\n      string[] memory traits = new string[](length);\\n      traits = viewTraits(tokenId);\\n\\n      traits[0] = string(abi.encodePacked('[{\\\"trait_type\\\":\\\"Genesis Skin Color\\\",\\\"value\\\":\\\"', traits[0], '\\\"}'));\\n\\n      for (uint256 i = 1; i < length; i++) {\\n         traits[i] = string(abi.encodePacked(',{\\\"trait_type\\\":\\\"Genesis Accessory\\\",\\\"value\\\":\\\"', traits[i], '\\\"}'));\\n      }\\n\\n      string memory json = traits[0];\\n      for (uint256 i = 1; i < length; i++) {\\n         json = string(abi.encodePacked(json, traits[i]));\\n      }\\n\\n      json = string(abi.encodePacked(json, ',{\\\"trait_type\\\":\\\"Life Form\\\",\\\"value\\\":\\\"Genesis\\\"}]'));\\n      return json;\\n   }\\n\\n   /// @notice Returns an ERC721 standard tokenURI\\n   /// @param tokenId, the desired tokenId to display\\n   /// @return output, a base64 encoded JSON string containing the tokenURI (metadata and image)\\n   function generateTokenURI(uint256 tokenId) external view returns (string memory) {\\n      string memory name = string(abi.encodePacked(\\\"Genesis EtherTerrestrial #\\\", tokenId.toString()));\\n      string\\n         memory description = \\\"EtherTerrestrials are inter-dimensional Extra-Terrestrials who came to Earth's internet to infuse consciousness into all other pixelated Lifeforms. They can be encountered in the form of on-chain characters as interpreted by the existential explorer Kye.\\\";\\n      string memory traits = viewTraitsJSON(tokenId);\\n      string memory svg = getSvg(tokenId);\\n\\n      string memory json = Base64.encode(\\n         bytes(\\n            string(\\n               abi.encodePacked(\\n                  '{\\\"name\\\": \\\"',\\n                  name,\\n                  '\\\", \\\"description\\\": \\\"',\\n                  description,\\n                  '\\\", \\\"attributes\\\":',\\n                  traits,\\n                  ',\\\"image\\\": \\\"data:image/svg+xml;base64,',\\n                  Base64.encode(bytes(svg)),\\n                  '\\\"}'\\n               )\\n            )\\n         )\\n      );\\n\\n      string memory output = string(abi.encodePacked(\\\"data:application/json;base64,\\\", json));\\n      return output;\\n   }\\n\\n   /// @notice Generates an unencoded SVG image for a given token\\n   /// @param tokenId, the desired tokenId to display\\n   /// @dev PNG images are added into an SVG for easy scaling\\n   /// @return an SVG string\\n   function getSvg(uint256 tokenId) public view returns (string memory) {\\n      string\\n         memory SVG = '<svg id=\\\"ETHT\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 24 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">';\\n      string memory base64encodedPNG = decompress(SSTORE2.read(tokenData[tokenId].imageStore), tokenData[tokenId].imagelen);\\n      SVG = string(\\n         abi.encodePacked(\\n            SVG,\\n            imageTagOpen,\\n            base64encodedPNG,\\n            '\\\"/>',\\n            tokenId <= 3 ? addAnimations(tokenId) : \\\"\\\",\\n            \\\"<style>#ETHT{shape-rendering: crispedges; image-rendering: -webkit-crisp-edges; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; image-rendering: pixelated; -ms-interpolation-mode: nearest-neighbor;}</style></svg>\\\"\\n         )\\n      );\\n      return SVG;\\n   }\\n\\n   /// @notice Builds animation layers for certain tokens\\n   /// @param tokenId, the desired tokenId\\n   /// @return allAnimatedFrames, a string of SVG components\\n   function addAnimations(uint256 tokenId) internal view returns (string memory) {\\n      uint8 numAnimatedFrames;\\n      string memory duration;\\n      if (tokenId == 1) {\\n         numAnimatedFrames = 18;\\n         duration = \\\"1.33\\\";\\n      } else if (tokenId == 2) {\\n         numAnimatedFrames = 32;\\n         duration = \\\"2.31\\\";\\n      } else if (tokenId == 3) {\\n         numAnimatedFrames = 35;\\n         duration = \\\"2.52\\\";\\n      }\\n      string[36] memory frames;\\n      frames[0] = string(\\n         abi.encodePacked(\\n            '<rect><animate  id=\\\"b\\\" begin=\\\"0;f',\\n            (numAnimatedFrames - 1).toString(),\\n            '.end\\\" dur=\\\"',\\n            duration,\\n            's\\\" attributeName=\\\"visibility\\\" from=\\\"hide\\\" to=\\\"hide\\\"/></rect>'\\n         )\\n      );\\n\\n      for (uint8 i; i < numAnimatedFrames; i++) {\\n         string memory begin;\\n         if (i == 0) begin = \\\"b.begin+0.07s\\\";\\n         else begin = string(abi.encodePacked(\\\"f\\\", (i - 1).toString(), \\\".end\\\"));\\n\\n         string memory frame = string(\\n            abi.encodePacked(\\n               '<g opacity=\\\"0\\\">',\\n               imageTagOpen,\\n               decompress(SSTORE2.read(animationFrames[tokenId][i].imageStore), animationFrames[tokenId][i].imagelen),\\n               '\\\"/>',\\n               '<animate attributeName=\\\"opacity\\\" id =\\\"f',\\n               i.toString(),\\n               '\\\" begin=\\\"',\\n               begin,\\n               '\\\" values=\\\"1\\\" dur=\\\"0.07\\\"  calcMode=\\\"discrete\\\"/></g>'\\n            )\\n         );\\n         frames[i + 1] = frame;\\n      }\\n\\n      string memory allAnimatedFrames;\\n\\n      for (uint8 i; i < numAnimatedFrames + 1; i++) {\\n         allAnimatedFrames = string(abi.encodePacked(allAnimatedFrames, frames[i]));\\n      }\\n\\n      return allAnimatedFrames;\\n   }\\n\\n   function decompress(bytes memory input, uint256 len) public pure returns (string memory) {\\n      (, bytes memory decompressed) = InflateLib.puff(input, len);\\n      return string(decompressed);\\n   }\\n\\n   /*\\n _______   _______ .______    __        ______   ____    ____  _______ .______      \\n|       \\\\ |   ____||   _  \\\\  |  |      /  __  \\\\  \\\\   \\\\  /   / |   ____||   _  \\\\     \\n|  .--.  ||  |__   |  |_)  | |  |     |  |  |  |  \\\\   \\\\/   /  |  |__   |  |_)  |    \\n|  |  |  ||   __|  |   ___/  |  |     |  |  |  |   \\\\_    _/   |   __|  |      /     \\n|  '--'  ||  |____ |  |      |  `----.|  `--'  |     |  |     |  |____ |  |\\\\  \\\\----.\\n|_______/ |_______|| _|      |_______| \\\\______/      |__|     |_______|| _| `._____|\\n                                                                                                                                                \\n*/\\n\\n   /// @notice Establishes the list of accessory traits\\n   function setSkins(string[] memory _skins, uint256[] memory traitNumber) external onlyDeployerWhileUnsealed {\\n      require(_skins.length == traitNumber.length);\\n\\n      for (uint8 i; i < _skins.length; i++) skincolor[traitNumber[i]] = _skins[i];\\n   }\\n\\n   /// @notice Establishes the list of accessory traits\\n   function setAccessories(string[] memory _accesories, uint256[] memory traitNumber) external onlyDeployerWhileUnsealed {\\n      require(_accesories.length == traitNumber.length);\\n      for (uint8 i; i < _accesories.length; i++) accesories[traitNumber[i]] = _accesories[i];\\n   }\\n\\n   /// @notice Establishes the tokenData for a list of tokens (image and trait build code)\\n   function setTokenData(\\n      uint8[] memory _newTokenIds,\\n      Token[] memory _tokenData,\\n      bytes[] memory _imageData\\n   ) external onlyDeployerWhileUnsealed {\\n      require(_newTokenIds.length == _tokenData.length && _imageData.length == _tokenData.length);\\n      for (uint8 i; i < _newTokenIds.length; i++) {\\n         _tokenData[i].imageStore = SSTORE2.write(_imageData[i]);\\n         tokenData[_newTokenIds[i]] = _tokenData[i];\\n      }\\n   }\\n\\n   /// @notice Establishes the animated frames for a given tokenId\\n   function setAnimationFrames(\\n      uint256 _tokenId,\\n      Frame[] memory _animationFrames,\\n      uint256[] memory frameNumber,\\n      bytes[] memory _imageData\\n   ) external onlyDeployerWhileUnsealed {\\n      require(_tokenId <= 3);\\n      require(_animationFrames.length == frameNumber.length && _imageData.length == frameNumber.length);\\n      for (uint256 i; i < _animationFrames.length; i++) {\\n         _animationFrames[i].imageStore = SSTORE2.write(_imageData[i]);\\n         animationFrames[_tokenId][frameNumber[i]] = _animationFrames[i];\\n      }\\n   }\\n\\n   /// @notice IRREVERSIBLY SEALS THE CONTRACT FROM BEING MODIFIED\\n   function sealContract() external onlyDeployerWhileUnsealed {\\n      contractsealed = true;\\n   }\\n}\\n\"\r\n    },\r\n    \"contracts/InflateLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/// https://github.com/adlerjohn/inflate-sol\\n/// @notice Based on https://github.com/madler/zlib/blob/master/contrib/puff\\nlibrary InflateLib {\\n   // Maximum bits in a code\\n   uint256 constant MAXBITS = 15;\\n   // Maximum number of literal/length codes\\n   uint256 constant MAXLCODES = 286;\\n   // Maximum number of distance codes\\n   uint256 constant MAXDCODES = 30;\\n   // Maximum codes lengths to read\\n   uint256 constant MAXCODES = (MAXLCODES + MAXDCODES);\\n   // Number of fixed literal/length codes\\n   uint256 constant FIXLCODES = 288;\\n\\n   // Error codes\\n   enum ErrorCode {\\n      ERR_NONE, // 0 successful inflate\\n      ERR_NOT_TERMINATED, // 1 available inflate data did not terminate\\n      ERR_OUTPUT_EXHAUSTED, // 2 output space exhausted before completing inflate\\n      ERR_INVALID_BLOCK_TYPE, // 3 invalid block type (type == 3)\\n      ERR_STORED_LENGTH_NO_MATCH, // 4 stored block length did not match one's complement\\n      ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES, // 5 dynamic block code description: too many length or distance codes\\n      ERR_CODE_LENGTHS_CODES_INCOMPLETE, // 6 dynamic block code description: code lengths codes incomplete\\n      ERR_REPEAT_NO_FIRST_LENGTH, // 7 dynamic block code description: repeat lengths with no first length\\n      ERR_REPEAT_MORE, // 8 dynamic block code description: repeat more than specified lengths\\n      ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS, // 9 dynamic block code description: invalid literal/length code lengths\\n      ERR_INVALID_DISTANCE_CODE_LENGTHS, // 10 dynamic block code description: invalid distance code lengths\\n      ERR_MISSING_END_OF_BLOCK, // 11 dynamic block code description: missing end-of-block code\\n      ERR_INVALID_LENGTH_OR_DISTANCE_CODE, // 12 invalid literal/length or distance code in fixed or dynamic block\\n      ERR_DISTANCE_TOO_FAR, // 13 distance is too far back in fixed or dynamic block\\n      ERR_CONSTRUCT // 14 internal: error in construct()\\n   }\\n\\n   // Input and output state\\n   struct State {\\n      //////////////////\\n      // Output state //\\n      //////////////////\\n      // Output buffer\\n      bytes output;\\n      // Bytes written to out so far\\n      uint256 outcnt;\\n      /////////////////\\n      // Input state //\\n      /////////////////\\n      // Input buffer\\n      bytes input;\\n      // Bytes read so far\\n      uint256 incnt;\\n      ////////////////\\n      // Temp state //\\n      ////////////////\\n      // Bit buffer\\n      uint256 bitbuf;\\n      // Number of bits in bit buffer\\n      uint256 bitcnt;\\n      //////////////////////////\\n      // Static Huffman codes //\\n      //////////////////////////\\n      Huffman lencode;\\n      Huffman distcode;\\n   }\\n\\n   // Huffman code decoding tables\\n   struct Huffman {\\n      uint256[] counts;\\n      uint256[] symbols;\\n   }\\n\\n   function bits(State memory s, uint256 need) private pure returns (ErrorCode, uint256) {\\n      // Bit accumulator (can use up to 20 bits)\\n      uint256 val;\\n\\n      // Load at least need bits into val\\n      val = s.bitbuf;\\n      while (s.bitcnt < need) {\\n         if (s.incnt == s.input.length) {\\n            // Out of input\\n            return (ErrorCode.ERR_NOT_TERMINATED, 0);\\n         }\\n\\n         // Load eight bits\\n         val |= uint256(uint8(s.input[s.incnt++])) << s.bitcnt;\\n         s.bitcnt += 8;\\n      }\\n\\n      // Drop need bits and update buffer, always zero to seven bits left\\n      s.bitbuf = val >> need;\\n      s.bitcnt -= need;\\n\\n      // Return need bits, zeroing the bits above that\\n      uint256 ret = (val & ((1 << need) - 1));\\n      return (ErrorCode.ERR_NONE, ret);\\n   }\\n\\n   function _stored(State memory s) private pure returns (ErrorCode) {\\n      // Length of stored block\\n      uint256 len;\\n\\n      // Discard leftover bits from current byte (assumes s.bitcnt < 8)\\n      s.bitbuf = 0;\\n      s.bitcnt = 0;\\n\\n      // Get length and check against its one's complement\\n      if (s.incnt + 4 > s.input.length) {\\n         // Not enough input\\n         return ErrorCode.ERR_NOT_TERMINATED;\\n      }\\n      len = uint256(uint8(s.input[s.incnt++]));\\n      len |= uint256(uint8(s.input[s.incnt++])) << 8;\\n\\n      if (uint8(s.input[s.incnt++]) != (~len & 0xFF) || uint8(s.input[s.incnt++]) != ((~len >> 8) & 0xFF)) {\\n         // Didn't match complement!\\n         return ErrorCode.ERR_STORED_LENGTH_NO_MATCH;\\n      }\\n\\n      // Copy len bytes from in to out\\n      if (s.incnt + len > s.input.length) {\\n         // Not enough input\\n         return ErrorCode.ERR_NOT_TERMINATED;\\n      }\\n      if (s.outcnt + len > s.output.length) {\\n         // Not enough output space\\n         return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n      }\\n      while (len != 0) {\\n         // Note: Solidity reverts on underflow, so we decrement here\\n         len -= 1;\\n         s.output[s.outcnt++] = s.input[s.incnt++];\\n      }\\n\\n      // Done with a valid stored block\\n      return ErrorCode.ERR_NONE;\\n   }\\n\\n   function _decode(State memory s, Huffman memory h) private pure returns (ErrorCode, uint256) {\\n      // Current number of bits in code\\n      uint256 len;\\n      // Len bits being decoded\\n      uint256 code = 0;\\n      // First code of length len\\n      uint256 first = 0;\\n      // Number of codes of length len\\n      uint256 count;\\n      // Index of first code of length len in symbol table\\n      uint256 index = 0;\\n      // Error code\\n      ErrorCode err;\\n\\n      for (len = 1; len <= MAXBITS; len++) {\\n         // Get next bit\\n         uint256 tempCode;\\n         (err, tempCode) = bits(s, 1);\\n         if (err != ErrorCode.ERR_NONE) {\\n            return (err, 0);\\n         }\\n         code |= tempCode;\\n         count = h.counts[len];\\n\\n         // If length len, return symbol\\n         if (code < first + count) {\\n            return (ErrorCode.ERR_NONE, h.symbols[index + (code - first)]);\\n         }\\n         // Else update for next length\\n         index += count;\\n         first += count;\\n         first <<= 1;\\n         code <<= 1;\\n      }\\n\\n      // Ran out of codes\\n      return (ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE, 0);\\n   }\\n\\n   function _construct(\\n      Huffman memory h,\\n      uint256[] memory lengths,\\n      uint256 n,\\n      uint256 start\\n   ) private pure returns (ErrorCode) {\\n      // Current symbol when stepping through lengths[]\\n      uint256 symbol;\\n      // Current length when stepping through h.counts[]\\n      uint256 len;\\n      // Number of possible codes left of current length\\n      uint256 left;\\n      // Offsets in symbol table for each length\\n      uint256[MAXBITS + 1] memory offs;\\n\\n      // Count number of codes of each length\\n      for (len = 0; len <= MAXBITS; len++) {\\n         h.counts[len] = 0;\\n      }\\n      for (symbol = 0; symbol < n; symbol++) {\\n         // Assumes lengths are within bounds\\n         h.counts[lengths[start + symbol]]++;\\n      }\\n      // No codes!\\n      if (h.counts[0] == n) {\\n         // Complete, but decode() will fail\\n         return (ErrorCode.ERR_NONE);\\n      }\\n\\n      // Check for an over-subscribed or incomplete set of lengths\\n\\n      // One possible code of zero length\\n      left = 1;\\n\\n      for (len = 1; len <= MAXBITS; len++) {\\n         // One more bit, double codes left\\n         left <<= 1;\\n         if (left < h.counts[len]) {\\n            // Over-subscribed--return error\\n            return ErrorCode.ERR_CONSTRUCT;\\n         }\\n         // Deduct count from possible codes\\n\\n         left -= h.counts[len];\\n      }\\n\\n      // Generate offsets into symbol table for each length for sorting\\n      offs[1] = 0;\\n      for (len = 1; len < MAXBITS; len++) {\\n         offs[len + 1] = offs[len] + h.counts[len];\\n      }\\n\\n      // Put symbols in table sorted by length, by symbol order within each length\\n      for (symbol = 0; symbol < n; symbol++) {\\n         if (lengths[start + symbol] != 0) {\\n            h.symbols[offs[lengths[start + symbol]]++] = symbol;\\n         }\\n      }\\n\\n      // Left > 0 means incomplete\\n      return left > 0 ? ErrorCode.ERR_CONSTRUCT : ErrorCode.ERR_NONE;\\n   }\\n\\n   function _codes(\\n      State memory s,\\n      Huffman memory lencode,\\n      Huffman memory distcode\\n   ) private pure returns (ErrorCode) {\\n      // Decoded symbol\\n      uint256 symbol;\\n      // Length for copy\\n      uint256 len;\\n      // Distance for copy\\n      uint256 dist;\\n      // TODO Solidity doesn't support constant arrays, but these are fixed at compile-time\\n      // Size base for length codes 257..285\\n      uint16[29] memory lens = [\\n         3,\\n         4,\\n         5,\\n         6,\\n         7,\\n         8,\\n         9,\\n         10,\\n         11,\\n         13,\\n         15,\\n         17,\\n         19,\\n         23,\\n         27,\\n         31,\\n         35,\\n         43,\\n         51,\\n         59,\\n         67,\\n         83,\\n         99,\\n         115,\\n         131,\\n         163,\\n         195,\\n         227,\\n         258\\n      ];\\n      // Extra bits for length codes 257..285\\n      uint8[29] memory lext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\\n      // Offset base for distance codes 0..29\\n      uint16[30] memory dists = [\\n         1,\\n         2,\\n         3,\\n         4,\\n         5,\\n         7,\\n         9,\\n         13,\\n         17,\\n         25,\\n         33,\\n         49,\\n         65,\\n         97,\\n         129,\\n         193,\\n         257,\\n         385,\\n         513,\\n         769,\\n         1025,\\n         1537,\\n         2049,\\n         3073,\\n         4097,\\n         6145,\\n         8193,\\n         12289,\\n         16385,\\n         24577\\n      ];\\n      // Extra bits for distance codes 0..29\\n      uint8[30] memory dext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\\n      // Error code\\n      ErrorCode err;\\n\\n      // Decode literals and length/distance pairs\\n      while (symbol != 256) {\\n         (err, symbol) = _decode(s, lencode);\\n         if (err != ErrorCode.ERR_NONE) {\\n            // Invalid symbol\\n            return err;\\n         }\\n\\n         if (symbol < 256) {\\n            // Literal: symbol is the byte\\n            // Write out the literal\\n            if (s.outcnt == s.output.length) {\\n               return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n            }\\n            s.output[s.outcnt] = bytes1(uint8(symbol));\\n            s.outcnt++;\\n         } else if (symbol > 256) {\\n            uint256 tempBits;\\n            // Length\\n            // Get and compute length\\n            symbol -= 257;\\n            if (symbol >= 29) {\\n               // Invalid fixed code\\n               return ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE;\\n            }\\n\\n            (err, tempBits) = bits(s, lext[symbol]);\\n            if (err != ErrorCode.ERR_NONE) {\\n               return err;\\n            }\\n            len = lens[symbol] + tempBits;\\n\\n            // Get and check distance\\n            (err, symbol) = _decode(s, distcode);\\n            if (err != ErrorCode.ERR_NONE) {\\n               // Invalid symbol\\n               return err;\\n            }\\n            (err, tempBits) = bits(s, dext[symbol]);\\n            if (err != ErrorCode.ERR_NONE) {\\n               return err;\\n            }\\n            dist = dists[symbol] + tempBits;\\n            if (dist > s.outcnt) {\\n               // Distance too far back\\n               return ErrorCode.ERR_DISTANCE_TOO_FAR;\\n            }\\n\\n            // Copy length bytes from distance bytes back\\n            if (s.outcnt + len > s.output.length) {\\n               return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n            }\\n            while (len != 0) {\\n               // Note: Solidity reverts on underflow, so we decrement here\\n               len -= 1;\\n               s.output[s.outcnt] = s.output[s.outcnt - dist];\\n               s.outcnt++;\\n            }\\n         } else {\\n            s.outcnt += len;\\n         }\\n      }\\n\\n      // Done with a valid fixed or dynamic block\\n      return ErrorCode.ERR_NONE;\\n   }\\n\\n   function _build_fixed(State memory s) private pure returns (ErrorCode) {\\n      // Build fixed Huffman tables\\n      // TODO this is all a compile-time constant\\n      uint256 symbol;\\n      uint256[] memory lengths = new uint256[](FIXLCODES);\\n\\n      // Literal/length table\\n      for (symbol = 0; symbol < 144; symbol++) {\\n         lengths[symbol] = 8;\\n      }\\n      for (; symbol < 256; symbol++) {\\n         lengths[symbol] = 9;\\n      }\\n      for (; symbol < 280; symbol++) {\\n         lengths[symbol] = 7;\\n      }\\n      for (; symbol < FIXLCODES; symbol++) {\\n         lengths[symbol] = 8;\\n      }\\n\\n      _construct(s.lencode, lengths, FIXLCODES, 0);\\n\\n      // Distance table\\n      for (symbol = 0; symbol < MAXDCODES; symbol++) {\\n         lengths[symbol] = 5;\\n      }\\n\\n      _construct(s.distcode, lengths, MAXDCODES, 0);\\n\\n      return ErrorCode.ERR_NONE;\\n   }\\n\\n   function _fixed(State memory s) private pure returns (ErrorCode) {\\n      // Decode data until end-of-block code\\n      return _codes(s, s.lencode, s.distcode);\\n   }\\n\\n   function _build_dynamic_lengths(State memory s) private pure returns (ErrorCode, uint256[] memory) {\\n      uint256 ncode;\\n      // Index of lengths[]\\n      uint256 index;\\n      // Descriptor code lengths\\n      uint256[] memory lengths = new uint256[](MAXCODES);\\n      // Error code\\n      ErrorCode err;\\n      // Permutation of code length codes\\n      uint8[19] memory order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\\n\\n      (err, ncode) = bits(s, 4);\\n      if (err != ErrorCode.ERR_NONE) {\\n         return (err, lengths);\\n      }\\n      ncode += 4;\\n\\n      // Read code length code lengths (really), missing lengths are zero\\n      for (index = 0; index < ncode; index++) {\\n         (err, lengths[order[index]]) = bits(s, 3);\\n         if (err != ErrorCode.ERR_NONE) {\\n            return (err, lengths);\\n         }\\n      }\\n      for (; index < 19; index++) {\\n         lengths[order[index]] = 0;\\n      }\\n\\n      return (ErrorCode.ERR_NONE, lengths);\\n   }\\n\\n   function _build_dynamic(State memory s)\\n      private\\n      pure\\n      returns (\\n         ErrorCode,\\n         Huffman memory,\\n         Huffman memory\\n      )\\n   {\\n      // Number of lengths in descriptor\\n      uint256 nlen;\\n      uint256 ndist;\\n      // Index of lengths[]\\n      uint256 index;\\n      // Error code\\n      ErrorCode err;\\n      // Descriptor code lengths\\n      uint256[] memory lengths = new uint256[](MAXCODES);\\n      // Length and distance codes\\n      Huffman memory lencode = Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXLCODES));\\n      Huffman memory distcode = Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES));\\n      uint256 tempBits;\\n\\n      // Get number of lengths in each table, check lengths\\n      (err, nlen) = bits(s, 5);\\n      if (err != ErrorCode.ERR_NONE) {\\n         return (err, lencode, distcode);\\n      }\\n      nlen += 257;\\n      (err, ndist) = bits(s, 5);\\n      if (err != ErrorCode.ERR_NONE) {\\n         return (err, lencode, distcode);\\n      }\\n      ndist += 1;\\n\\n      if (nlen > MAXLCODES || ndist > MAXDCODES) {\\n         // Bad counts\\n         return (ErrorCode.ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES, lencode, distcode);\\n      }\\n\\n      (err, lengths) = _build_dynamic_lengths(s);\\n      if (err != ErrorCode.ERR_NONE) {\\n         return (err, lencode, distcode);\\n      }\\n\\n      // Build huffman table for code lengths codes (use lencode temporarily)\\n      err = _construct(lencode, lengths, 19, 0);\\n      if (err != ErrorCode.ERR_NONE) {\\n         // Require complete code set here\\n         return (ErrorCode.ERR_CODE_LENGTHS_CODES_INCOMPLETE, lencode, distcode);\\n      }\\n\\n      // Read length/literal and distance code length tables\\n      index = 0;\\n      while (index < nlen + ndist) {\\n         // Decoded value\\n         uint256 symbol;\\n         // Last length to repeat\\n         uint256 len;\\n\\n         (err, symbol) = _decode(s, lencode);\\n         if (err != ErrorCode.ERR_NONE) {\\n            // Invalid symbol\\n            return (err, lencode, distcode);\\n         }\\n\\n         if (symbol < 16) {\\n            // Length in 0..15\\n            lengths[index++] = symbol;\\n         } else {\\n            // Repeat instruction\\n            // Assume repeating zeros\\n            len = 0;\\n            if (symbol == 16) {\\n               // Repeat last length 3..6 times\\n               if (index == 0) {\\n                  // No last length!\\n                  return (ErrorCode.ERR_REPEAT_NO_FIRST_LENGTH, lencode, distcode);\\n               }\\n               // Last length\\n               len = lengths[index - 1];\\n               (err, tempBits) = bits(s, 2);\\n               if (err != ErrorCode.ERR_NONE) {\\n                  return (err, lencode, distcode);\\n               }\\n               symbol = 3 + tempBits;\\n            } else if (symbol == 17) {\\n               // Repeat zero 3..10 times\\n               (err, tempBits) = bits(s, 3);\\n               if (err != ErrorCode.ERR_NONE) {\\n                  return (err, lencode, distcode);\\n               }\\n               symbol = 3 + tempBits;\\n            } else {\\n               // == 18, repeat zero 11..138 times\\n               (err, tempBits) = bits(s, 7);\\n               if (err != ErrorCode.ERR_NONE) {\\n                  return (err, lencode, distcode);\\n               }\\n               symbol = 11 + tempBits;\\n            }\\n\\n            if (index + symbol > nlen + ndist) {\\n               // Too many lengths!\\n               return (ErrorCode.ERR_REPEAT_MORE, lencode, distcode);\\n            }\\n            while (symbol != 0) {\\n               // Note: Solidity reverts on underflow, so we decrement here\\n               symbol -= 1;\\n\\n               // Repeat last or zero symbol times\\n               lengths[index++] = len;\\n            }\\n         }\\n      }\\n\\n      // Check for end-of-block code -- there better be one!\\n      if (lengths[256] == 0) {\\n         return (ErrorCode.ERR_MISSING_END_OF_BLOCK, lencode, distcode);\\n      }\\n\\n      // Build huffman table for literal/length codes\\n      err = _construct(lencode, lengths, nlen, 0);\\n      if (\\n         err != ErrorCode.ERR_NONE &&\\n         (err == ErrorCode.ERR_NOT_TERMINATED || err == ErrorCode.ERR_OUTPUT_EXHAUSTED || nlen != lencode.counts[0] + lencode.counts[1])\\n      ) {\\n         // Incomplete code ok only for single length 1 code\\n         return (ErrorCode.ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS, lencode, distcode);\\n      }\\n\\n      // Build huffman table for distance codes\\n      err = _construct(distcode, lengths, ndist, nlen);\\n      if (\\n         err != ErrorCode.ERR_NONE &&\\n         (err == ErrorCode.ERR_NOT_TERMINATED || err == ErrorCode.ERR_OUTPUT_EXHAUSTED || ndist != distcode.counts[0] + distcode.counts[1])\\n      ) {\\n         // Incomplete code ok only for single length 1 code\\n         return (ErrorCode.ERR_INVALID_DISTANCE_CODE_LENGTHS, lencode, distcode);\\n      }\\n\\n      return (ErrorCode.ERR_NONE, lencode, distcode);\\n   }\\n\\n   function _dynamic(State memory s) private pure returns (ErrorCode) {\\n      // Length and distance codes\\n      Huffman memory lencode;\\n      Huffman memory distcode;\\n      // Error code\\n      ErrorCode err;\\n\\n      (err, lencode, distcode) = _build_dynamic(s);\\n      if (err != ErrorCode.ERR_NONE) {\\n         return err;\\n      }\\n\\n      // Decode data until end-of-block code\\n      return _codes(s, lencode, distcode);\\n   }\\n\\n   function puff(bytes memory source, uint256 destlen) internal pure returns (ErrorCode, bytes memory) {\\n      // Input/output state\\n      State memory s = State(\\n         new bytes(destlen),\\n         0,\\n         source,\\n         0,\\n         0,\\n         0,\\n         Huffman(new uint256[](MAXBITS + 1), new uint256[](FIXLCODES)),\\n         Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES))\\n      );\\n      // Temp: last bit\\n      uint256 last;\\n      // Temp: block type bit\\n      uint256 t;\\n      // Error code\\n      ErrorCode err;\\n\\n      // Build fixed Huffman tables\\n      err = _build_fixed(s);\\n      if (err != ErrorCode.ERR_NONE) {\\n         return (err, s.output);\\n      }\\n\\n      // Process blocks until last block or error\\n      while (last == 0) {\\n         // One if last block\\n         (err, last) = bits(s, 1);\\n         if (err != ErrorCode.ERR_NONE) {\\n            return (err, s.output);\\n         }\\n\\n         // Block type 0..3\\n         (err, t) = bits(s, 2);\\n         if (err != ErrorCode.ERR_NONE) {\\n            return (err, s.output);\\n         }\\n\\n         err = (t == 0 ? _stored(s) : (t == 1 ? _fixed(s) : (t == 2 ? _dynamic(s) : ErrorCode.ERR_INVALID_BLOCK_TYPE)));\\n         // type == 3, invalid\\n\\n         if (err != ErrorCode.ERR_NONE) {\\n            // Return with error\\n            break;\\n         }\\n      }\\n\\n      return (err, s.output);\\n   }\\n}\\n\"\r\n    },\r\n    \"contracts/Strings.sol\": {\r\n      \"content\": \"library Strings {\\n   function toString(uint256 value) internal pure returns (string memory) {\\n      // Inspired by OraclizeAPI's implementation - MIT licence\\n      // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n      if (value == 0) {\\n         return \\\"0\\\";\\n      }\\n      uint256 temp = value;\\n      uint256 digits;\\n      while (temp != 0) {\\n         digits++;\\n         temp /= 10;\\n      }\\n      bytes memory buffer = new bytes(digits);\\n      while (value != 0) {\\n         digits -= 1;\\n         buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n         value /= 10;\\n      }\\n      return string(buffer);\\n   }\\n}\\n\"\r\n    },\r\n    \"contracts/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\n\\nlibrary Base64 {\\n   string internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n   function encode(bytes memory data) internal pure returns (string memory) {\\n      if (data.length == 0) return \\\"\\\";\\n\\n      // load the table into memory\\n      string memory table = TABLE;\\n\\n      // multiply by 4/3 rounded up\\n      uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n      // add some extra buffer at the end required for the writing\\n      string memory result = new string(encodedLen + 32);\\n\\n      assembly {\\n         // set the actual output length\\n         mstore(result, encodedLen)\\n\\n         // prepare the lookup table\\n         let tablePtr := add(table, 1)\\n\\n         // input ptr\\n         let dataPtr := data\\n         let endPtr := add(dataPtr, mload(data))\\n\\n         // result ptr, jump over length\\n         let resultPtr := add(result, 32)\\n\\n         // run over the input, 3 bytes at a time\\n         for {\\n\\n         } lt(dataPtr, endPtr) {\\n\\n         } {\\n            dataPtr := add(dataPtr, 3)\\n\\n            // read 3 bytes\\n            let input := mload(dataPtr)\\n\\n            // write 4 characters\\n            mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\\n            resultPtr := add(resultPtr, 1)\\n            mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\\n            resultPtr := add(resultPtr, 1)\\n            mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F)))))\\n            resultPtr := add(resultPtr, 1)\\n            mstore(resultPtr, shl(248, mload(add(tablePtr, and(input, 0x3F)))))\\n            resultPtr := add(resultPtr, 1)\\n         }\\n\\n         // padding with '='\\n         switch mod(mload(data), 3)\\n         case 1 {\\n            mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n         }\\n         case 2 {\\n            mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n         }\\n      }\\n\\n      return result;\\n   }\\n}\\n\"\r\n    },\r\n    \"@0xsequence/sstore2/contracts/SSTORE2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./utils/Bytecode.sol\\\";\\n\\n/**\\n  @title A key-value storage with auto-generated keys for storing chunks of data with a lower write & read cost.\\n  @author Agustin Aguilar <aa@horizon.io>\\n\\n  Readme: https://github.com/0xsequence/sstore2#readme\\n*/\\nlibrary SSTORE2 {\\n  error WriteError();\\n\\n  /**\\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\\n    @dev The pointer is a contract address with `_data` as code\\n    @param _data to be written\\n    @return pointer Pointer to the written `_data`\\n  */\\n  function write(bytes memory _data) internal returns (address pointer) {\\n    // Append 00 to _data so contract can't be called\\n    // Build init code\\n    bytes memory code = Bytecode.creationCodeFor(\\n      abi.encodePacked(\\n        hex'00',\\n        _data\\n      )\\n    );\\n\\n    // Deploy contract using create\\n    assembly { pointer := create(0, add(code, 32), mload(code)) }\\n\\n    // Address MUST be non-zero\\n    if (pointer == address(0)) revert WriteError();\\n  }\\n\\n  /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @return data read from `_pointer` contract\\n  */\\n  function read(address _pointer) internal view returns (bytes memory) {\\n    return Bytecode.codeAt(_pointer, 1, type(uint256).max);\\n  }\\n\\n  /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @return data read from `_pointer` contract\\n  */\\n  function read(address _pointer, uint256 _start) internal view returns (bytes memory) {\\n    return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\\n  }\\n\\n  /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @param _end index before which to end extraction\\n    @return data read from `_pointer` contract\\n  */\\n  function read(address _pointer, uint256 _start, uint256 _end) internal view returns (bytes memory) {\\n    return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\\n  }\\n}\\n\"\r\n    },\r\n    \"@0xsequence/sstore2/contracts/utils/Bytecode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\nlibrary Bytecode {\\n  error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\\n\\n  /**\\n    @notice Generate a creation code that results on a contract with `_code` as bytecode\\n    @param _code The returning value of the resulting `creationCode`\\n    @return creationCode (constructor) for new contract\\n  */\\n  function creationCodeFor(bytes memory _code) internal pure returns (bytes memory) {\\n    /*\\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\\n      0x01    0x80         0x80        DUP1                size size\\n      0x02    0x60         0x600e      PUSH1 14            14 size size\\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\\n      0x04    0x39         0x39        CODECOPY            size\\n      0x05    0x60         0x6000      PUSH1 00            0 size\\n      0x06    0xf3         0xf3        RETURN\\n      <CODE>\\n    */\\n\\n    return abi.encodePacked(\\n      hex\\\"63\\\",\\n      uint32(_code.length),\\n      hex\\\"80_60_0E_60_00_39_60_00_F3\\\",\\n      _code\\n    );\\n  }\\n\\n  /**\\n    @notice Returns the size of the code on a given address\\n    @param _addr Address that may or may not contain code\\n    @return size of the code on the given `_addr`\\n  */\\n  function codeSize(address _addr) internal view returns (uint256 size) {\\n    assembly { size := extcodesize(_addr) }\\n  }\\n\\n  /**\\n    @notice Returns the code of a given address\\n    @dev It will fail if `_end < _start`\\n    @param _addr Address that may or may not contain code\\n    @param _start number of bytes of code to skip on read\\n    @param _end index before which to end extraction\\n    @return oCode read from `_addr` deployed bytecode\\n\\n    Forked from: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\\n  */\\n  function codeAt(address _addr, uint256 _start, uint256 _end) internal view returns (bytes memory oCode) {\\n    uint256 csize = codeSize(_addr);\\n    if (csize == 0) return bytes(\\\"\\\");\\n\\n    if (_start > csize) return bytes(\\\"\\\");\\n    if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end); \\n\\n    unchecked {\\n      uint256 reqSize = _end - _start;\\n      uint256 maxSize = csize - _start;\\n\\n      uint256 size = maxSize < reqSize ? maxSize : reqSize;\\n\\n      assembly {\\n        // allocate output byte array - this could also be done without assembly\\n        // by using o_code = new bytes(size)\\n        oCode := mload(0x40)\\n        // new \\\"memory end\\\" including padding\\n        mstore(0x40, add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f))))\\n        // store length in memory\\n        mstore(oCode, size)\\n        // actually retrieve the code, this needs assembly\\n        extcodecopy(_addr, add(oCode, 0x20), _start, size)\\n      }\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"InvalidCodeAtRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WriteError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accesories\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"animationFrames\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"imageStore\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"imagelen\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractsealed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"len\",\"type\":\"uint256\"}],\"name\":\"decompress\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"generateTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getSvg\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sealContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_accesories\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"traitNumber\",\"type\":\"uint256[]\"}],\"name\":\"setAccessories\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"imageStore\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"imagelen\",\"type\":\"uint96\"}],\"internalType\":\"struct EthTerrestrialsGenesisDescriptor.Frame[]\",\"name\":\"_animationFrames\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"frameNumber\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_imageData\",\"type\":\"bytes[]\"}],\"name\":\"setAnimationFrames\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_skins\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"traitNumber\",\"type\":\"uint256[]\"}],\"name\":\"setSkins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"_newTokenIds\",\"type\":\"uint8[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"imageStore\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"imagelen\",\"type\":\"uint96\"},{\"internalType\":\"uint8[]\",\"name\":\"buildCode\",\"type\":\"uint8[]\"}],\"internalType\":\"struct EthTerrestrialsGenesisDescriptor.Token[]\",\"name\":\"_tokenData\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_imageData\",\"type\":\"bytes[]\"}],\"name\":\"setTokenData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"skincolor\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"imageStore\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"imagelen\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"viewTraits\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"viewTraitsJSON\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "EthTerrestrialsGenesisDescriptor", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}