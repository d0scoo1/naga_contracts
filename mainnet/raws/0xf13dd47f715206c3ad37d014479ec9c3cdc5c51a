{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"ExchangeAuction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n//pragma experimental ABIEncoderV2;\\r\\n\\r\\n\\r\\nimport \\\"./VcgBase.sol\\\";\\r\\n\\r\\n\\r\\ncontract ExchangeVcgAuction is Ownable,Commission,ReentrancyGuardUpgradeable {\\r\\n    using Strings for string;\\r\\n    using Address for address;    \\r\\n    using SafeMath for uint256;\\r\\n    enum State {Pending, Started, Ended, Cancelled}\\r\\n\\r\\n    struct auctionInfo {\\r\\n        address  _nftContractAddress;\\r\\n        uint256  _nftId;\\r\\n        address  _beneficiaryAddress;\\r\\n        uint256  _initialPrice;\\r\\n        uint256  _bidIncrement;\\r\\n        uint256  _startTime;\\r\\n        uint256  _stopTime;\\r\\n        address  highestBidder;\\r\\n        mapping(address =\\u003e uint256) fundsByBidder;   \\r\\n        State  _state;\\r\\n        uint256 _totalBalance;\\r\\n        //bool isUsed;\\r\\n    }\\r\\n\\r\\n    mapping(uint256 =\\u003e auctionInfo) private _auctionInfos;\\r\\n\\r\\n    // Interface to halt all auctions.\\r\\n    bool public IsHalted;\\r\\n\\r\\n    // Admin withdrawal\\r\\n    event WithDrawal(uint256 auctionid,address bidder,uint256 amount);\\r\\n    // Pause and resume\\r\\n    event Pause();\\r\\n    event Resume();\\r\\n    // New Bidding Event\\r\\n    event NewBid(uint256 auctionid, uint256 price, address bidder);\\r\\n    // Auction Finish Event\\r\\n    event AuctionMade(uint256 auctionid, address oper ,State s);\\r\\n    event AuctionAmountDetail(uint256 indexed auctionId,\\r\\n            uint256 indexed beneficiaryReceived,\\r\\n            uint256 indexed creatorReceived,\\r\\n            uint256  platformReceived);\\r\\n\\r\\n    // Halt transactions\\r\\n    function halt() public onlyOwner {\\r\\n        //require(_privilleged_operators[msg.sender] == true, \\\"Operator only\\\");\\r\\n        IsHalted = true;\\r\\n        emit Pause();\\r\\n    }\\r\\n    \\r\\n    // Resume transactions\\r\\n    function resume() public onlyOwner {\\r\\n        IsHalted = false;\\r\\n        emit Resume();\\r\\n    }\\r\\n\\r\\n    modifier onlyAuctionExist(uint256 auctionID) {\\r\\n        require(_auctionInfos[auctionID]._nftId != 0,\\\"auctionID not existed...\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwnerOrBeneficiary(uint256 auctionID) {\\r\\n        require(msg.sender == owner() ||\\r\\n           msg.sender == _auctionInfos[auctionID]._beneficiaryAddress,\\r\\n           \\\"only Owner Or Beneficiary allow to do this.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier notBeneficiary(uint256 auctionID, address bider) {\\r\\n        //if (bider == _auctionInfos[auctionid].beneficiaryAddress) throw;\\r\\n        require(bider != _auctionInfos[auctionID]._beneficiaryAddress, \\\"Bider Must not the beneficiary\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyAfterStart(uint256 auctionID) {\\r\\n        require(block.timestamp \\u003e _auctionInfos[auctionID]._startTime, \\\"only After Start\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyBeforeEnd(uint256 auctionID) {\\r\\n        require(block.timestamp \\u003c _auctionInfos[auctionID]._stopTime, \\\"only Before End\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyEndedOrCanceled(uint256 auctionID) {\\r\\n        require(_auctionInfos[auctionID]._state == State.Ended || \\r\\n            _auctionInfos[auctionID]._state == State.Cancelled, \\r\\n            \\\"The nft is still on auction, pls claim it or wait for finish\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function hasRightToAuction(address nftContractaddr,uint256 tokenId) public view returns(bool) {\\r\\n        return (IERC721(nftContractaddr).getApproved(tokenId) == address(this));\\r\\n    }\\r\\n\\r\\n    function isTokenOwner(address nftContractaddr,address targetAddr, uint256 tokenId) internal view returns(bool) {  \\r\\n        return (targetAddr == IERC721(nftContractaddr).ownerOf(tokenId) );   \\r\\n    }\\r\\n\\r\\n    function isOnAuction(uint256 auctionID) public view returns(bool) {\\r\\n        require(_auctionInfos[auctionID]._nftId != 0,\\\"auctionID not existed...\\\");\\r\\n        return (block.timestamp \\u003e _auctionInfos[auctionID]._startTime\\r\\n            \\u0026\\u0026 block.timestamp \\u003c _auctionInfos[auctionID]._stopTime);\\r\\n    }   \\r\\n\\r\\n    function createAuction(uint256 auctionID, \\r\\n        address  nftContractAddress,\\r\\n        uint256  nftId,\\r\\n        uint256  initialPrice,\\r\\n        uint256  bidIncrement,\\r\\n        uint256  startTime,\\r\\n        uint256  stopTime) public {\\r\\n        require(_auctionInfos[auctionID]._nftId == 0,\\\"auctionID existed...\\\");\\r\\n\\r\\n        require(!Address.isContract(msg.sender),\\\"the sender should be a person, not a contract!\\\");\\r\\n\\r\\n        require(startTime \\u003c  stopTime, \\\"stopTime must greater than startTime\\\");\\r\\n        require(stopTime \\u003e block.timestamp + 600 , \\\"stopTime must greater than current Time after 10 min\\\");\\r\\n\\r\\n        require(isTokenOwner(nftContractAddress, msg.sender, nftId),\\r\\n        \\\"the sender isn\\u0027t the owner of the token id nft!\\\");\\r\\n\\r\\n        require(hasRightToAuction(nftContractAddress,nftId),\\r\\n            \\\"the exchange contracct is not the approved of the token.\\\");\\r\\n        \\r\\n        require(initialPrice \\u003e 0 \\u0026\\u0026 initialPrice \\u003e= bidIncrement ,\\\"need a vaild initial price\\\");\\r\\n\\r\\n        auctionInfo storage ainfo = _auctionInfos[auctionID];\\r\\n        ainfo._nftContractAddress=nftContractAddress;\\r\\n        ainfo._nftId=nftId;\\r\\n        ainfo._beneficiaryAddress=msg.sender;\\r\\n        ainfo._initialPrice=initialPrice;\\r\\n        ainfo._bidIncrement=bidIncrement;\\r\\n        ainfo._totalBalance = 0;\\r\\n        ainfo._startTime=startTime;\\r\\n        ainfo._stopTime=stopTime;  \\r\\n        ainfo._state=State.Pending;\\r\\n        //ainfo.isUsed=true;\\r\\n\\r\\n        emit AuctionMade(auctionID, address(this) ,State.Pending);\\r\\n    }\\r\\n\\r\\n    function getAuctionInfo(uint256 auctionID) external \\r\\n        view\\r\\n        returns (address,uint256,address,uint256,uint256,\\r\\n        uint256,uint256,address,uint256,State,uint256){\\r\\n        auctionInfo storage info = _auctionInfos[auctionID];\\r\\n        return (\\r\\n            info._nftContractAddress,\\r\\n            info._nftId,\\r\\n            info._beneficiaryAddress,\\r\\n            info._initialPrice,\\r\\n            info._bidIncrement,\\r\\n            info._startTime,\\r\\n            info._stopTime,\\r\\n            info.highestBidder,\\r\\n            info.fundsByBidder[info.highestBidder],\\r\\n            info._state,\\r\\n            info._totalBalance\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function clearAuctionInfo(uint256 auctionID) internal\\r\\n        onlyAuctionExist(auctionID) {\\r\\n        require(_auctionInfos[auctionID]._totalBalance == 0 ,\\r\\n            \\\"only zero balance to be claered.\\\");\\r\\n        /*\\r\\n        auctionInfo storage ainfo = _auctionInfos[auctionID];\\r\\n        \\r\\n        ainfo._nftContractAddress=address(0);\\r\\n        ainfo._nftId=0;\\r\\n        ainfo._beneficiaryAddress=address(0);\\r\\n        ainfo._initialPrice=0;\\r\\n        ainfo._bidIncrement=0;\\r\\n        ainfo._totalBalance = 0;\\r\\n        ainfo._startTime=0;\\r\\n        ainfo._stopTime=0;  \\r\\n        ainfo._state=State.Pending;\\r\\n        ainfo.highestBidder=address(0);\\r\\n        ainfo.isUsed=false;\\r\\n        */\\r\\n        delete _auctionInfos[auctionID];\\r\\n    }\\r\\n\\r\\n    function cancelAuction(uint256 auctionID) public \\r\\n        onlyAuctionExist(auctionID) onlyOwnerOrBeneficiary(auctionID){\\r\\n        _auctionInfos[auctionID]._state = State.Cancelled;\\r\\n    }\\r\\n    \\r\\n    function getHighestBid(uint256 auctionID) public\\r\\n        view\\r\\n        returns (address,uint256)\\r\\n    {\\r\\n        require(_auctionInfos[auctionID]._nftId != 0,\\\"auctionID not existed...\\\");\\r\\n        if(_auctionInfos[auctionID].highestBidder == address(0))\\r\\n        {\\r\\n            return (address(0),0);\\r\\n        }\\r\\n        return (_auctionInfos[auctionID].highestBidder,\\r\\n            _auctionInfos[auctionID].fundsByBidder[\\r\\n                _auctionInfos[auctionID].highestBidder]);\\r\\n    }\\r\\n    \\r\\n\\r\\n    function placeBid(uint256 auctionID) public payable \\r\\n            onlyAuctionExist(auctionID)\\r\\n            notBeneficiary(auctionID,msg.sender) onlyAfterStart(auctionID) onlyBeforeEnd(auctionID) {\\r\\n        // to place a bid auction should be running\\r\\n        require(_auctionInfos[auctionID]._state == State.Pending ||\\r\\n            _auctionInfos[auctionID]._state == State.Started,\\\"Invaild Auction State\\\");\\r\\n        // minimum value allowed to be sent\\r\\n        require(msg.value \\u003e= _auctionInfos[auctionID]._bidIncrement || _auctionInfos[auctionID]._bidIncrement == 0,\\r\\n        \\\"bid should be greater bid Increment\\\");\\r\\n        \\r\\n        uint256 currentBid = _auctionInfos[auctionID].fundsByBidder[msg.sender] + msg.value;\\r\\n        \\r\\n        // the currentBid should be greater than the highestBid. \\r\\n        // Otherwise there\\u0027s nothing to do.\\r\\n        require((address(0) == _auctionInfos[auctionID].highestBidder \\u0026\\u0026\\r\\n               currentBid \\u003e= _auctionInfos[auctionID]._initialPrice)//first bid\\r\\n            || \\r\\n            (currentBid \\u003e _auctionInfos[auctionID].fundsByBidder[\\r\\n            _auctionInfos[auctionID].highestBidder]),\\r\\n            \\\"the currentBid should be greater than the highestBid.\\\");\\r\\n        \\r\\n        //set state to started,when first vaild bid\\r\\n        if (_auctionInfos[auctionID]._state == State.Pending)\\r\\n        {\\r\\n            _auctionInfos[auctionID]._state = State.Started;\\r\\n            emit AuctionMade(auctionID, msg.sender ,State.Started);\\r\\n        }\\r\\n\\r\\n        // updating the mapping variable\\r\\n        _auctionInfos[auctionID].fundsByBidder[msg.sender] = currentBid;\\r\\n        _auctionInfos[auctionID]._totalBalance = \\r\\n        _auctionInfos[auctionID]._totalBalance.add(msg.value);\\r\\n\\r\\n        if (_auctionInfos[auctionID].highestBidder != msg.sender){ // highestBidder is another bidder\\r\\n             _auctionInfos[auctionID].highestBidder = payable(msg.sender);\\r\\n        }\\r\\n        emit NewBid(auctionID, currentBid, msg.sender);\\r\\n    }  \\r\\n    \\r\\n    function finalizeAuction(uint256 auctionID) public\\r\\n        // onlyAuctionExist(auctionID) \\r\\n        onlyOwner nonReentrant {\\r\\n        // support multi finalizeAuction call--2021.12.29\\r\\n        if (_auctionInfos[auctionID]._nftId == 0 || \\r\\n        _auctionInfos[auctionID]._state == State.Ended)\\r\\n        {\\r\\n            return;\\r\\n        }\\r\\n       // the auction has been Cancelled or Ended\\r\\n       require((_auctionInfos[auctionID]._state == State.Cancelled \\r\\n        || _auctionInfos[auctionID]._state == State.Started\\r\\n        || _auctionInfos[auctionID]._state == State.Pending)\\r\\n        \\u0026\\u0026\\r\\n        block.timestamp \\u003e _auctionInfos[auctionID]._stopTime,\\r\\n        \\\"the auction may be Cancelled or Ended\\\"); \\r\\n       \\r\\n       if(_auctionInfos[auctionID]._state == State.Started)\\r\\n       {\\r\\n            address payable recipient;\\r\\n            uint256 value;\\r\\n            recipient = payable(_auctionInfos[auctionID]._beneficiaryAddress);\\r\\n            value = _auctionInfos[auctionID].fundsByBidder[\\r\\n            _auctionInfos[auctionID].highestBidder];\\r\\n            \\r\\n            // resetting the bids of the recipient to avoid multiple transfers to the same recipient\\r\\n            _auctionInfos[auctionID].fundsByBidder[\\r\\n            _auctionInfos[auctionID].highestBidder] = 0;\\r\\n            _auctionInfos[auctionID]._totalBalance = \\r\\n                _auctionInfos[auctionID]._totalBalance.sub(value);\\r\\n            //\\r\\n            IERC721(_auctionInfos[auctionID]._nftContractAddress).safeTransferFrom(\\r\\n                _auctionInfos[auctionID]._beneficiaryAddress,\\r\\n                _auctionInfos[auctionID].highestBidder,\\r\\n                _auctionInfos[auctionID]._nftId\\r\\n            );\\r\\n            (address creator,uint256 royalty) = IVcgERC721TokenWithRoyalty(_auctionInfos[auctionID]._nftContractAddress).royaltyInfo(_auctionInfos[auctionID]._nftId,value);\\r\\n            (address platform,uint256 fee) = calculateFee(value);\\r\\n            require(value \\u003e royalty + fee,\\\"No enough Amount to pay except royalty and platform service fee\\\");\\r\\n            if(creator != address(0) \\u0026\\u0026 royalty \\u003e0 \\u0026\\u0026 royalty \\u003c value)\\r\\n            {\\r\\n                payable(creator).transfer(royalty);\\r\\n                value = value.sub(royalty);\\r\\n            } \\r\\n            if(fee \\u003e 0 \\u0026\\u0026 fee \\u003c value)\\r\\n            {\\r\\n                //payable(platform).transfer(fee);\\r\\n                //(bool sent, bytes memory data) = platform.call{value: fee}(\\\"\\\");\\r\\n                //require(sent, \\\"Failed to send Ether to platform\\\");\\r\\n                Address.sendValue(payable(platform),fee);\\r\\n                value = value.sub(fee);\\r\\n            }\\r\\n            //sends value to the recipient\\r\\n            recipient.transfer(value);\\r\\n            emit AuctionAmountDetail(auctionID,value,royalty,fee);\\r\\n        }\\r\\n        _auctionInfos[auctionID]._state = State.Ended;\\r\\n        emit AuctionMade(auctionID, msg.sender ,State.Ended);\\r\\n        if(_auctionInfos[auctionID]._totalBalance == 0){\\r\\n            clearAuctionInfo(auctionID);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 auctionID) public\\r\\n        onlyAuctionExist(auctionID) onlyEndedOrCanceled(auctionID)\\r\\n        returns (bool success)\\r\\n    {\\r\\n        address payable withdrawalAccount;\\r\\n        uint withdrawalAmount;\\r\\n\\r\\n        if (_auctionInfos[auctionID]._state == State.Cancelled) {\\r\\n            // if the auction was canceled, everyone should simply be allowed to withdraw their funds\\r\\n            withdrawalAccount = payable(msg.sender);\\r\\n            withdrawalAmount = _auctionInfos[auctionID].fundsByBidder[withdrawalAccount];\\r\\n\\r\\n        } else {\\r\\n            require(msg.sender != _auctionInfos[auctionID].highestBidder ,\\r\\n                \\\"highestBidder does not allow to withdraw.\\\");\\r\\n            // anyone who participated but did not win the auction should be allowed to withdraw\\r\\n            // the full amount of their funds\\r\\n            withdrawalAccount = payable(msg.sender);\\r\\n            withdrawalAmount = _auctionInfos[auctionID].fundsByBidder[withdrawalAccount];\\r\\n        }\\r\\n\\r\\n        if (withdrawalAmount == 0) {\\r\\n            revert();\\r\\n        }\\r\\n        delete _auctionInfos[auctionID].fundsByBidder[withdrawalAccount];\\r\\n        /*\\r\\n        _auctionInfos[auctionID].fundsByBidder[withdrawalAccount] = \\r\\n        _auctionInfos[auctionID].fundsByBidder[withdrawalAccount].sub(withdrawalAmount);\\r\\n        */\\r\\n        // send the funds\\r\\n        if (!withdrawalAccount.send(withdrawalAmount)){\\r\\n            revert();\\r\\n        }\\r\\n        \\r\\n        _auctionInfos[auctionID]._totalBalance = \\r\\n                _auctionInfos[auctionID]._totalBalance.sub(withdrawalAmount);\\r\\n        if(_auctionInfos[auctionID]._totalBalance == 0){\\r\\n            clearAuctionInfo(auctionID);\\r\\n        }\\r\\n\\r\\n        emit WithDrawal(auctionID,withdrawalAccount,withdrawalAmount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function getBalance(uint256 auctionID,address target) public\\r\\n        view\\r\\n        onlyAuctionExist(auctionID)\\r\\n        returns (uint256)\\r\\n    {\\r\\n        if(address(0) == target){\\r\\n            return _auctionInfos[auctionID].fundsByBidder[msg.sender];\\r\\n        }\\r\\n        return _auctionInfos[auctionID].fundsByBidder[target];\\r\\n    }\\r\\n\\r\\n    function destroyContract() external onlyOwner {\\r\\n        selfdestruct(payable(owner()));\\r\\n    } \\r\\n}\"},\"VcgBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n//pragma experimental ABIEncoderV2;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title Ownable\\r\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\r\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\r\\n */\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\r\\n     * account.\\r\\n     */\\r\\n    constructor () {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the address of the owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner());\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return true if `msg.sender` is the owner of the contract.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return msg.sender == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current owner to relinquish control of the contract.\\r\\n     * It will not be possible to call the functions with the `onlyOwner`\\r\\n     * modifier anymore.\\r\\n     * @notice Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n     /*\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }*/\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers control of the contract to a newOwner.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0));\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title Authentication \\r\\n * Authentication \\r\\n * @author duncanwang\\r\\n */\\r\\ncontract Authentication is Ownable {\\r\\n    address private _owner;\\r\\n    mapping(address=\\u003ebool) _managers;\\r\\n\\r\\n    /**\\r\\n    * @dev constructor\\r\\n    */\\r\\n    constructor() {    \\r\\n        _owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    \\r\\n    modifier onlyAuthorized(address target) {\\r\\n        require(isOwner()||isManager(target),\\\"Only for manager or owner!\\\");\\r\\n        _;\\r\\n    }    \\r\\n\\r\\n    \\r\\n    function addManager(address manager) public onlyOwner{    \\r\\n        _managers[manager] = true;\\r\\n    }    \\r\\n\\r\\n    \\r\\n    function removeManager(address manager) public onlyOwner{    \\r\\n        _managers[manager] = false;\\r\\n    }  \\r\\n\\r\\n   \\r\\n    function isManager(address manager) public view returns (bool) {    \\r\\n        return(_managers[manager]);\\r\\n    }             \\r\\n\\r\\n}    \\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\r\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        while (value != 0) {\\r\\n            digits -= 1;\\r\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\r\\n            value /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\r\\n     */\\r\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\r\\n        if (value == 0) {\\r\\n            return \\\"0x00\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 length = 0;\\r\\n        while (temp != 0) {\\r\\n            length++;\\r\\n            temp \\u003e\\u003e= 8;\\r\\n        }\\r\\n        return toHexString(value, length);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\r\\n     */\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\r\\n            buffer[i] = _HEX_SYMBOLS[value \\u0026 0xf];\\r\\n            value \\u003e\\u003e= 4;\\r\\n        }\\r\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\r\\n        return string(buffer);\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        assembly {\\r\\n            size := extcodesize(account)\\r\\n        }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) private pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\r\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it\\u0027s common to move constructor logic to an\\r\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\r\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\r\\n *\\r\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\r\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\r\\n *\\r\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\r\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\r\\n *\\r\\n * [CAUTION]\\r\\n * ====\\r\\n * Avoid leaving a contract uninitialized.\\r\\n *\\r\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\r\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\r\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\r\\n *\\r\\n * [.hljs-theme-light.nopadding]\\r\\n * ```\\r\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\r\\n * constructor() initializer {}\\r\\n * ```\\r\\n * ====\\r\\n */\\r\\nabstract contract Initializable {\\r\\n    /**\\r\\n     * @dev Indicates that the contract has been initialized.\\r\\n     */\\r\\n    bool private _initialized;\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates that the contract is in the process of being initialized.\\r\\n     */\\r\\n    bool private _initializing;\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\r\\n     */\\r\\n    modifier initializer() {\\r\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\r\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\r\\n        // contract may have been reentered.\\r\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\r\\n\\r\\n        bool isTopLevelCall = !_initializing;\\r\\n        if (isTopLevelCall) {\\r\\n            _initializing = true;\\r\\n            _initialized = true;\\r\\n        }\\r\\n\\r\\n        _;\\r\\n\\r\\n        if (isTopLevelCall) {\\r\\n            _initializing = false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\r\\n     * {initializer} modifier, directly or indirectly.\\r\\n     */\\r\\n    modifier onlyInitializing() {\\r\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _isConstructor() private view returns (bool) {\\r\\n        return !Address.isContract(address(this));\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\r\\n        __ReentrancyGuard_init_unchained();\\r\\n    }\\r\\n\\r\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n\\r\\n        _;\\r\\n\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\r\\n     * variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    //uint256[49] private __gap;\\r\\n}\\r\\n\\r\\n// CAUTION\\r\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\r\\n// because it relies on the compiler\\u0027s built in overflow checks.\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations.\\r\\n *\\r\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\r\\n * now has built in overflow checking.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c \\u003c a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b \\u003e a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003c= a, errorMessage);\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003e 0, errorMessage);\\r\\n            return a / b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting with custom message when dividing by zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003e 0, errorMessage);\\r\\n            return a % b;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC721 compliant contract.\\r\\n */\\r\\ninterface IERC721 is IERC165 {\\r\\n    /**\\r\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of tokens in ``owner``\\u0027s account.\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the owner of the `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\r\\n     *\\r\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n     * The approval is cleared when the token is transferred.\\r\\n     *\\r\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The caller must own the token or be an approved operator.\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the account approved for `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n\\r\\n    /**\\r\\n     * @dev Approve or remove `operator` as an operator for the caller.\\r\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The `operator` cannot be the caller.\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool _approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n     *\\r\\n     * See {setApprovalForAll}\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n */\\r\\ninterface IERC721Metadata is IERC721 {\\r\\n    /**\\r\\n     * @dev Returns the token collection name.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token collection symbol.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC721 token receiver interface\\r\\n * @dev Interface for any contract that wants to support safeTransfers\\r\\n * from ERC721 asset contracts.\\r\\n */\\r\\ninterface IERC721Receiver {\\r\\n    /**\\r\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\r\\n     * by `operator` from `from`, this function is called.\\r\\n     *\\r\\n     * It must return its Solidity selector to confirm the token transfer.\\r\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\r\\n     *\\r\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\r\\n     */\\r\\n    function onERC721Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\r\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n */\\r\\ninterface IERC721Enumerable is IERC721 {\\r\\n    /**\\r\\n     * @dev Returns the total amount of tokens stored by the contract.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\r\\n     * Use along with {balanceOf} to enumerate all of ``owner``\\u0027s tokens.\\r\\n     */\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\r\\n     * Use along with {totalSupply} to enumerate all tokens.\\r\\n     */\\r\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC165} interface.\\r\\n *\\r\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\r\\n * for the additional interface id that will be supported. For example:\\r\\n *\\r\\n * ```solidity\\r\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\r\\n */\\r\\nabstract contract ERC165 is IERC165 {\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return interfaceId == type(IERC165).interfaceId;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IVcgERC721Token is IERC721Enumerable {\\r\\n   \\r\\n\\r\\n    function getBaseTokenURI() external view returns (string memory); \\r\\n\\r\\n    function setBaseTokenURI(string memory url) external;\\r\\n\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n\\r\\n    function isVcgNftToken(address tokenAddress) external view returns(bool);\\r\\n\\r\\n    function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\\r\\n\\r\\n    function exists(uint256 tokenId) external view returns (bool);\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Implementation of royalties for 721s\\r\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2981.md\\r\\n */\\r\\ninterface IERC2981 {\\r\\n    // ERC165 bytes to add to interface array - set in parent contract\\r\\n    // implementing this standard\\r\\n    //\\r\\n    // bytes4(keccak256(\\\"royaltyInfo(uint256)\\\")) == 0xcef6d368\\r\\n    // bytes4(keccak256(\\\"onRoyaltiesReceived(address,address,uint256,address,uint256,bytes32)\\\")) == 0xe8cb9d99\\r\\n    // bytes4(0xcef6d368) ^ bytes4(0xe8cb9d99) == 0x263d4ef1\\r\\n    // bytes4 private constant _INTERFACE_ID_ERC721ROYALTIES = 0x263d4ef1;\\r\\n    // _registerInterface(_INTERFACE_ID_ERC721ROYALTIES);\\r\\n\\r\\n    // @notice Called to return both the creator\\u0027s address and the royalty percentage\\r\\n    // @param _tokenId - the NFT asset queried for royalty information\\r\\n    // @return receiver - address of who should be sent the royalty payment\\r\\n    // @return amount - a percentage calculated as a fixed point\\r\\n    //         with a scaling factor of 100000 (5 decimals), such that\\r\\n    //         100% would be the value 10000000, as 10000000/100000 = 100.\\r\\n    //         1% would be the value 100000, as 100000/100000 = 1\\r\\n    function royaltyInfo(uint256 _tokenId) external view \\r\\n    returns (address receiver, uint256 amount);\\r\\n\\r\\n    /// @notice Called with the sale price to determine how much royalty\\r\\n    //          is owed and to whom.\\r\\n    /// @param _tokenId - the NFT asset queried for royalty information\\r\\n    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId\\r\\n    /// @return receiver - address of who should be sent the royalty payment\\r\\n    /// @return royaltyAmount - the royalty payment amount for _salePrice\\r\\n    function royaltyInfo(\\r\\n        uint256 _tokenId,\\r\\n        uint256 _salePrice\\r\\n    ) external view returns (\\r\\n        address receiver,\\r\\n        uint256 royaltyAmount\\r\\n    );\\r\\n\\r\\n\\r\\n    // @notice Called when royalty is transferred to the receiver. This\\r\\n    //         emits the RoyaltiesReceived event as we want the NFT contract\\r\\n    //         itself to contain the event for easy tracking by royalty receivers.\\r\\n    // @param _royaltyRecipient - The address of who is entitled to the\\r\\n    //                            royalties as specified by royaltyInfo().\\r\\n    // @param _buyer - If known, the address buying the NFT on a secondary\\r\\n    //                 sale. 0x0 if not known.\\r\\n    // @param _tokenId - the ID of the ERC-721 token that was sold\\r\\n    // @param _tokenPaid - The address of the ERC-20 token used to pay the\\r\\n    //                     royalty fee amount. Set to 0x0 if paid in the\\r\\n    //                     native asset (ETH).\\r\\n    // @param _amount - The amount being paid to the creator using the\\r\\n    //                  correct decimals from _tokenPaid\\u0027s ERC-20 contract\\r\\n    //                  (i.e. if 7 decimals, 10000000 for 1 token paid)\\r\\n    // @param _metadata - Arbitrary data attached to this payment\\r\\n    // @return `bytes4(keccak256(\\\"onRoyaltiesReceived(address,address,uint256,address,uint256,bytes32)\\\"))`\\r\\n    function onRoyaltiesReceived(address _royaltyRecipient, address _buyer, uint256 _tokenId, address _tokenPaid, uint256 _amount, bytes32 _metadata) external returns (bytes4);\\r\\n\\r\\n    // @dev This event MUST be emitted by `onRoyaltiesReceived()`.\\r\\n    event RoyaltiesReceived(\\r\\n        address indexed _royaltyRecipient,\\r\\n        address indexed _buyer,\\r\\n        uint256 indexed _tokenId,\\r\\n        address _tokenPaid,\\r\\n        uint256 _amount,\\r\\n        bytes32 _metadata\\r\\n    );\\r\\n\\r\\n}\\r\\n\\r\\ninterface IVcgERC721TokenWithRoyalty is IVcgERC721Token,IERC2981 {\\r\\n    \\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title Commission \\r\\n * Commission with Auction \\r\\n * @author Alan\\r\\n */\\r\\ncontract Commission is Ownable {\\r\\n    address private _wallet;\\r\\n    uint32 private _commissionRate;\\r\\n    uint256 private _scaling_factor = 100000;//5 decimals\\r\\n\\r\\n    event WalletChanged(address indexed previousWallet,address indexed currentWallet);\\r\\n    event CommissionRateChanged(uint32 indexed previousCommissionRate,\\r\\n        uint32 indexed currentCommissionRate);\\r\\n    /**\\r\\n    * @dev constructor \\r\\n    */\\r\\n    constructor() {    \\r\\n        //_wallet = msg.sender;//\\r\\n        //_commissionRate = 0;\\r\\n        _wallet = 0xEA5320a1a80705c81d72d3DD30c483f2a09CeB6c;\\r\\n        _commissionRate = 5000;\\r\\n    }\\r\\n    modifier _validateCommission(\\r\\n        uint32 comm\\r\\n    ) {\\r\\n        require(comm \\u003e= 0 \\u0026\\u0026 comm \\u003c= 30000, \\\"wrong Commission\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setWallet(address payable wallet) public onlyOwner{    \\r\\n        require(address(0) != wallet, \\\"It\\u0027s not an invalid wallet address.\\\");\\r\\n        emit WalletChanged(_wallet,wallet);\\r\\n        _wallet = wallet; \\r\\n    }    \\r\\n\\r\\n    function setCommissionRate(uint32 commissionRate) public \\r\\n        onlyOwner _validateCommission(commissionRate){    \\r\\n        emit CommissionRateChanged(_commissionRate,commissionRate);\\r\\n        _commissionRate = commissionRate;      \\r\\n    }  \\r\\n\\r\\n    function commissionInfo() public view returns (\\r\\n        address walletAddr,\\r\\n        uint32 commissionRate\\r\\n    ){\\r\\n      return (_wallet,_commissionRate);\\r\\n    }             \\r\\n    function calculateFee(uint256 _num) public view \\r\\n        returns (address receiver,uint256 fee){\\r\\n        if (_num == 0 || _commissionRate == 0){\\r\\n          return (_wallet,0);\\r\\n        }\\r\\n        fee = SafeMath.div(SafeMath.mul(_num, _commissionRate),_scaling_factor);\\r\\n        return (_wallet,fee);\\r\\n    }\\r\\n}    \\r\\n\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"beneficiaryReceived\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"creatorReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"platformReceived\",\"type\":\"uint256\"}],\"name\":\"AuctionAmountDetail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum ExchangeVcgAuction.State\",\"name\":\"s\",\"type\":\"uint8\"}],\"name\":\"AuctionMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"previousCommissionRate\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"currentCommissionRate\",\"type\":\"uint32\"}],\"name\":\"CommissionRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"}],\"name\":\"NewBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Resume\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currentWallet\",\"type\":\"address\"}],\"name\":\"WalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithDrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IsHalted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"calculateFee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionID\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commissionInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"walletAddr\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"commissionRate\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidIncrement\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stopTime\",\"type\":\"uint256\"}],\"name\":\"createAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroyContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionID\",\"type\":\"uint256\"}],\"name\":\"finalizeAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionID\",\"type\":\"uint256\"}],\"name\":\"getAuctionInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeVcgAuction.State\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionID\",\"type\":\"uint256\"}],\"name\":\"getHighestBid\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContractaddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"hasRightToAuction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionID\",\"type\":\"uint256\"}],\"name\":\"isOnAuction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionID\",\"type\":\"uint256\"}],\"name\":\"placeBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"commissionRate\",\"type\":\"uint32\"}],\"name\":\"setCommissionRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionID\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ExchangeVcgAuction", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://34c2da515e6af17202cd83333d48f9b26284760e7624b20eee6a4ad2a485e8c4"}]}