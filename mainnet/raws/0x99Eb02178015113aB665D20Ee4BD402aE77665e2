{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Master.sol\": {\r\n      \"content\": \"//  ,888     8888    ,88'   8 8888                 \\r\\n// 888^8     8888   ,88'    8 8888         \\r\\n//   8|8     8888  ,88'     8 8888         \\r\\n//   8N8     8888 ,88'      8 8888         \\r\\n//   8G8     888888<        8 8888         \\r\\n//   8U8     8888 `MP.      8 8888         \\r\\n//   8|8     8888   `JK.    8 8888         \\r\\n// /88888\\\\   8888     `JO.  8888888888888 \\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\ninterface IERC165 {\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\ncontract ERC165 is IERC165 {\\r\\n    \\r\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\r\\n\\r\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\r\\n\\r\\n    constructor () internal {\\r\\n        _registerInterface(_INTERFACE_ID_ERC165);\\r\\n    }\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\\r\\n        return _supportedInterfaces[interfaceId];\\r\\n    }\\r\\n\\r\\n    function _registerInterface(bytes4 interfaceId) internal {\\r\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\r\\n        _supportedInterfaces[interfaceId] = true;\\r\\n    }\\r\\n}\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\ncontract IERC721 is IERC165 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    function balanceOf(address owner) public view returns (uint256 balance);\\r\\n\\r\\n    function ownerOf(uint256 tokenId) public view returns (address owner);\\r\\n\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\\r\\n    \\r\\n    function transferFrom(address from, address to, uint256 tokenId) public;\\r\\n    function approve(address to, uint256 tokenId) public;\\r\\n    function getApproved(uint256 tokenId) public view returns (address operator);\\r\\n\\r\\n    function setApprovalForAll(address operator, bool _approved) public;\\r\\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\\r\\n\\r\\n\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\\r\\n}\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\nlibrary SafeMath {\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n}\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\nlibrary Address {\\r\\n    \\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        \\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size > 0;\\r\\n    }\\r\\n}\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\nlibrary Counters {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    struct Counter {\\r\\n        uint256 _value; // default: 0\\r\\n    }\\r\\n\\r\\n    function current(Counter storage counter) internal view returns (uint256) {\\r\\n        return counter._value;\\r\\n    }\\r\\n\\r\\n    function increment(Counter storage counter) internal {\\r\\n        counter._value += 1;\\r\\n    }\\r\\n\\r\\n    function decrement(Counter storage counter) internal {\\r\\n        counter._value = counter._value.sub(1);\\r\\n    }\\r\\n}\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\ncontract IERC721Receiver {\\r\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\\r\\n    public returns (bytes4);\\r\\n}\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\ncontract ERC721 is ERC165, IERC721 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n    using Counters for Counters.Counter;\\r\\n\\r\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\r\\n\\r\\n    mapping (uint256 => address) private _tokenOwner;\\r\\n\\r\\n    mapping (uint256 => address) private _tokenApprovals;\\r\\n\\r\\n    mapping (address => Counters.Counter) private _ownedTokensCount;\\r\\n\\r\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\r\\n    \\r\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\r\\n\\r\\n    constructor () public {\\r\\n        _registerInterface(_INTERFACE_ID_ERC721);\\r\\n    }\\r\\n\\r\\n\\r\\n    function balanceOf(address owner) public view returns (uint256) {\\r\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\r\\n\\r\\n        return _ownedTokensCount[owner].current();\\r\\n    }\\r\\n\\r\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\r\\n        address owner = _tokenOwner[tokenId];\\r\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\r\\n\\r\\n        return owner;\\r\\n    }\\r\\n\\r\\n    function approve(address to, uint256 tokenId) public {\\r\\n        address owner = ownerOf(tokenId);\\r\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\r\\n\\r\\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),\\r\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\r\\n        );\\r\\n\\r\\n        _tokenApprovals[tokenId] = to;\\r\\n        emit Approval(owner, to, tokenId);\\r\\n    }\\r\\n\\r\\n    function getApproved(uint256 tokenId) public view returns (address) {\\r\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\r\\n\\r\\n        return _tokenApprovals[tokenId];\\r\\n    }\\r\\n\\r\\n    function setApprovalForAll(address to, bool approved) public {\\r\\n        require(to != msg.sender, \\\"ERC721: approve to caller\\\");\\r\\n\\r\\n        _operatorApprovals[msg.sender][to] = approved;\\r\\n        emit ApprovalForAll(msg.sender, to, approved);\\r\\n    }\\r\\n\\r\\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\\r\\n        return _operatorApprovals[owner][operator];\\r\\n    }\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 tokenId) public {\\r\\n        //solhint-disable-next-line max-line-length\\r\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\r\\n\\r\\n        _transferFrom(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\\r\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\\r\\n        transferFrom(from, to, tokenId);\\r\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\r\\n    }\\r\\n\\r\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\r\\n        address owner = _tokenOwner[tokenId];\\r\\n        return owner != address(0);\\r\\n    }\\r\\n\\r\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\r\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\r\\n        address owner = ownerOf(tokenId);\\r\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\r\\n    }\\r\\n\\r\\n    function _mint(address to, uint256 tokenId) internal {\\r\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\r\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\r\\n\\r\\n        _tokenOwner[tokenId] = to;\\r\\n        _ownedTokensCount[to].increment();\\r\\n\\r\\n        // emit Transfer(address(0), to, tokenId);\\r\\n    }\\r\\n\\r\\n    function _burn(address owner, uint256 tokenId) internal {\\r\\n        require(ownerOf(tokenId) == owner, \\\"ERC721: burn of token that is not own\\\");\\r\\n\\r\\n        _clearApproval(tokenId);\\r\\n\\r\\n        _ownedTokensCount[owner].decrement();\\r\\n        _tokenOwner[tokenId] = address(0);\\r\\n\\r\\n        // emit Transfer(owner, address(0), tokenId);\\r\\n    }\\r\\n\\r\\n    function _burn(uint256 tokenId) internal {\\r\\n        _burn(ownerOf(tokenId), tokenId);\\r\\n    }\\r\\n\\r\\n\\r\\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\\r\\n        require(ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\r\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\r\\n\\r\\n        _clearApproval(tokenId);\\r\\n\\r\\n        _ownedTokensCount[from].decrement();\\r\\n        _ownedTokensCount[to].increment();\\r\\n\\r\\n        _tokenOwner[tokenId] = to;\\r\\n\\r\\n        emit Transfer(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\r\\n    internal returns (bool)\\r\\n    {\\r\\n        if (!to.isContract()) {\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\\r\\n        return (retval == _ERC721_RECEIVED);\\r\\n    }\\r\\n\\r\\n    function _clearApproval(uint256 tokenId) private {\\r\\n        if (_tokenApprovals[tokenId] != address(0)) {\\r\\n            _tokenApprovals[tokenId] = address(0);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\ncontract IERC721Enumerable is IERC721 {\\r\\n    function totalSupply() public view returns (uint256);\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\\r\\n\\r\\n    function tokenByIndex(uint256 index) public view returns (uint256);\\r\\n}\\r\\n\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\\r\\n    mapping(address => uint256[]) private _ownedTokens;\\r\\n\\r\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\r\\n\\r\\n    uint256[] private _allTokens;\\r\\n\\r\\n    mapping(uint256 => uint256) private _allTokensIndex;\\r\\n\\r\\n    /*\\r\\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\\r\\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\\r\\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\\r\\n     *\\r\\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\r\\n     */\\r\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\r\\n\\r\\n    constructor () public {\\r\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\\r\\n     * @param owner address owning the tokens list to be accessed\\r\\n     * @param index uint256 representing the index to be accessed of the requested tokens list\\r\\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\\r\\n     */\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\\r\\n        require(index < balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\r\\n        return _ownedTokens[owner][index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the total amount of tokens stored by the contract.\\r\\n     * @return uint256 representing the total amount of tokens\\r\\n     */\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _allTokens.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the token ID at a given index of all the tokens in this contract\\r\\n     * Reverts if the index is greater or equal to the total number of tokens.\\r\\n     * @param index uint256 representing the index to be accessed of the tokens list\\r\\n     * @return uint256 token ID at the given index of the tokens list\\r\\n     */\\r\\n    function tokenByIndex(uint256 index) public view returns (uint256) {\\r\\n        require(index < totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\r\\n        return _allTokens[index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer ownership of a given token ID to another address.\\r\\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\\r\\n     * @param from current owner of the token\\r\\n     * @param to address to receive the ownership of the given token ID\\r\\n     * @param tokenId uint256 ID of the token to be transferred\\r\\n     */\\r\\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\\r\\n        super._transferFrom(from, to, tokenId);\\r\\n\\r\\n        _removeTokenFromOwnerEnumeration(from, tokenId);\\r\\n\\r\\n        _addTokenToOwnerEnumeration(to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to mint a new token.\\r\\n     * Reverts if the given token ID already exists.\\r\\n     * @param to address the beneficiary that will own the minted token\\r\\n     * @param tokenId uint256 ID of the token to be minted\\r\\n     */\\r\\n    function _mintToken(address to, uint256 tokenId) internal {\\r\\n        super._mint(to, tokenId);\\r\\n\\r\\n        _addTokenToOwnerEnumeration(to, tokenId);\\r\\n\\r\\n        _addTokenToAllTokensEnumeration(tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to burn a specific token.\\r\\n     * Reverts if the token does not exist.\\r\\n     * Deprecated, use _burn(uint256) instead.\\r\\n     * @param owner owner of the token to burn\\r\\n     * @param tokenId uint256 ID of the token being burned\\r\\n     */\\r\\n    function _burn(address owner, uint256 tokenId) internal {\\r\\n        super._burn(owner, tokenId);\\r\\n\\r\\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\\r\\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\\r\\n        _ownedTokensIndex[tokenId] = 0;\\r\\n\\r\\n        _removeTokenFromAllTokensEnumeration(tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the list of token IDs of the requested owner.\\r\\n     * @param owner address owning the tokens\\r\\n     * @return uint256[] List of token IDs owned by the requested address\\r\\n     */\\r\\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\\r\\n        return _ownedTokens[owner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\r\\n     * @param to address representing the new owner of the given token ID\\r\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\r\\n     */\\r\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\r\\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\\r\\n        _ownedTokens[to].push(tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\r\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\r\\n     */\\r\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\r\\n        _allTokensIndex[tokenId] = _allTokens.length;\\r\\n        _allTokens.push(tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\r\\n     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\\r\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\r\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\r\\n     * @param from address representing the previous owner of the given token ID\\r\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\r\\n     */\\r\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\r\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\r\\n        // then delete the last slot (swap and pop).\\r\\n\\r\\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\\r\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\r\\n\\r\\n        // When the token to delete is the last token, the swap operation is unnecessary\\r\\n        if (tokenIndex != lastTokenIndex) {\\r\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\r\\n\\r\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\r\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\r\\n        }\\r\\n\\r\\n        // This also deletes the contents at the last position of the array\\r\\n        _ownedTokens[from].length--;\\r\\n\\r\\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\\r\\n        // lastTokenId, or just over the end of the array if the token was the last one).\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\r\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\r\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\r\\n     */\\r\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\r\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\r\\n        // then delete the last slot (swap and pop).\\r\\n\\r\\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\\r\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\r\\n\\r\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\r\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\r\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\r\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\r\\n\\r\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\r\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\r\\n\\r\\n        // This also deletes the contents at the last position of the array\\r\\n        _allTokens.length--;\\r\\n        _allTokensIndex[tokenId] = 0;\\r\\n    }\\r\\n}\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor() public {\\r\\n        _setOwner(msg.sender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        _setOwner(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _setOwner(newOwner);\\r\\n    }\\r\\n\\r\\n    function _setOwner(address newOwner) private {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\ncontract CustomERC721Metadata is ERC165, ERC721Enumerable {\\r\\n\\r\\n    // Token name\\r\\n    string private _name;\\r\\n\\r\\n    // Token symbol\\r\\n    string private _symbol;\\r\\n\\r\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\r\\n\\r\\n    /**\\r\\n     * @dev Constructor function\\r\\n     */\\r\\n    constructor (string memory name, string memory symbol) public {\\r\\n        _name = name;\\r\\n        _symbol = symbol;\\r\\n\\r\\n        // register the supported interfaces to conform to ERC721 via ERC165\\r\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the token name\\r\\n     * @return string representing the token name\\r\\n     */\\r\\n    function name() external view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the token symbol\\r\\n     * @return string representing the token symbol\\r\\n     */\\r\\n    function symbol() external view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n//https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\\r\\nlibrary Strings {\\r\\n\\r\\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory _concatenatedString) {\\r\\n        return strConcat(_a, _b, \\\"\\\", \\\"\\\", \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory _concatenatedString) {\\r\\n        return strConcat(_a, _b, _c, \\\"\\\", \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory _concatenatedString) {\\r\\n        return strConcat(_a, _b, _c, _d, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory _concatenatedString) {\\r\\n        bytes memory _ba = bytes(_a);\\r\\n        bytes memory _bb = bytes(_b);\\r\\n        bytes memory _bc = bytes(_c);\\r\\n        bytes memory _bd = bytes(_d);\\r\\n        bytes memory _be = bytes(_e);\\r\\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\\r\\n        bytes memory babcde = bytes(abcde);\\r\\n        uint k = 0;\\r\\n        uint i = 0;\\r\\n        for (i = 0; i < _ba.length; i++) {\\r\\n            babcde[k++] = _ba[i];\\r\\n        }\\r\\n        for (i = 0; i < _bb.length; i++) {\\r\\n            babcde[k++] = _bb[i];\\r\\n        }\\r\\n        for (i = 0; i < _bc.length; i++) {\\r\\n            babcde[k++] = _bc[i];\\r\\n        }\\r\\n        for (i = 0; i < _bd.length; i++) {\\r\\n            babcde[k++] = _bd[i];\\r\\n        }\\r\\n        for (i = 0; i < _be.length; i++) {\\r\\n            babcde[k++] = _be[i];\\r\\n        }\\r\\n        return string(babcde);\\r\\n    }\\r\\n\\r\\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\\r\\n        if (_i == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint j = _i;\\r\\n        uint len;\\r\\n        while (j != 0) {\\r\\n            len++;\\r\\n            j /= 10;\\r\\n        }\\r\\n        bytes memory bstr = new bytes(len);\\r\\n        uint k = len - 1;\\r\\n        while (_i != 0) {\\r\\n            bstr[k--] = byte(uint8(48 + _i % 10));\\r\\n            _i /= 10;\\r\\n        }\\r\\n        return string(bstr);\\r\\n    }\\r\\n}\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\ninterface SubContract {\\r\\n    function getAdmin() external view returns (address);\\r\\n    function getArtist() external view returns (address);\\r\\n    function setMaster(address _masterAddress) external;\\r\\n    function setBlockStart(uint256 startDate) external;\\r\\n    function getBlockStart() external view returns (uint256);\\r\\n    function getMaxSupply() external view returns (uint256);\\r\\n    function getTotalSupply() external view returns (uint256);\\r\\n    function setMaxSupply(uint256 supply) external;\\r\\n    function setMaxMintAmount(uint256 _newmaxMintAmount) external;\\r\\n    function getMaxMintAmount() external view returns (uint256);\\r\\n    function canMint(bool mintFlag) external;\\r\\n    function getBaseURI() external view returns (string memory);\\r\\n    function setBaseURI(string calldata _newBaseURI) external;\\r\\n    function setMetaDataExt(string calldata _newExt) external;\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n    function mint(address _to) external returns (uint256);\\r\\n    function mintId(address _to, uint256 _tokenId) external;\\r\\n    function addBatchWhitelisted(address[] calldata mintWhitelist) external;\\r\\n    function checkWhitelisted(address _to) external view returns (bool);\\r\\n    function removeWhitelisted(address _address) external;\\r\\n    function upgradeWhitelistVersion() external;\\r\\n    function setCost(bool isPublic, uint256 _newCost) external;\\r\\n    function getCost() external view returns(uint256);\\r\\n    function getSaleType() external view returns(bool);\\r\\n    function setRandom(bool _flag) external;\\r\\n}\\r\\n\\r\\ncontract Exposed is CustomERC721Metadata, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    event Mint(\\r\\n        address indexed _to,\\r\\n        uint256 indexed _tokenId\\r\\n    );\\r\\n\\r\\n    uint256 public royalty = 10000;\\r\\n    uint256 public pubSaleCost = 3000000000000000000;\\r\\n    uint256 public prvSaleCost = 3000000000000000000;\\r\\n    uint256 public nextProjectId = 0;\\r\\n    uint256 public currentMintWhiteListVersion = 0;\\r\\n\\r\\n    bool public publicSale = true;\\r\\n    bool public useMasterPrice = true;\\r\\n\\r\\n    // SubContract public subContract;\\r\\n\\r\\n    mapping(uint256 => SubContract) subContract;\\r\\n    mapping(uint256 => address) project;\\r\\n    mapping(address => uint256) subContractAddress;\\r\\n    mapping(uint256 => uint256) public tokenIdToProjectId;\\r\\n    \\r\\n    address public admin;\\r\\n\\r\\n    uint256 ONE_MILLION = 1_000_000;\\r\\n\\r\\n    mapping(address => bool) public isWhitelisted;\\r\\n    mapping(uint256 => mapping(address => bool)) public isMintWhitelisted;\\r\\n    mapping(address => uint256) public balanceOfAddress;\\r\\n    \\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin, \\\"Only admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyWhitelisted() {\\r\\n        require(isWhitelisted[msg.sender], \\\"Only whitelisted\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(string memory _tokenName, string memory _tokenSymbol) CustomERC721Metadata(_tokenName, _tokenSymbol) public {\\r\\n        admin = msg.sender;\\r\\n        isWhitelisted[msg.sender] = true;\\r\\n        isMintWhitelisted[currentMintWhiteListVersion][msg.sender] = true;\\r\\n    }\\r\\n\\r\\n    // admin function\\r\\n    function setMasterCost(bool isPublic, uint256 _newCost) external onlyAdmin {\\r\\n        if(isPublic) {\\r\\n            pubSaleCost = _newCost;\\r\\n        }\\r\\n        else {\\r\\n            prvSaleCost = _newCost;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getMasterCost(bool isPublic) public view returns(uint256) {\\r\\n        if(isPublic) {\\r\\n            return pubSaleCost;\\r\\n        }\\r\\n        return prvSaleCost;\\r\\n    }\\r\\n\\r\\n    function setSaleType(bool flag) external onlyAdmin {\\r\\n        publicSale = flag;\\r\\n    }\\r\\n\\r\\n    function setMasterPriceUsage(bool flag) external onlyAdmin {\\r\\n        useMasterPrice = flag;\\r\\n    }\\r\\n\\r\\n    function getSaleType() external view returns(bool) {\\r\\n        return publicSale;\\r\\n    }\\r\\n\\r\\n    function getMintCost(uint256 _projectId) public view returns(uint256) {\\r\\n        if(useMasterPrice) {\\r\\n            return getMasterCost(publicSale);\\r\\n        }\\r\\n        return getSubCost(_projectId);\\r\\n    }\\r\\n    \\r\\n    function addProject(address _subContractAddress) public onlyWhitelisted {\\r\\n        project[nextProjectId] = _subContractAddress;\\r\\n        subContractAddress[_subContractAddress] = nextProjectId;\\r\\n        subContract[nextProjectId] = SubContract(_subContractAddress);\\r\\n        nextProjectId = nextProjectId.add(1);\\r\\n    }\\r\\n\\r\\n    function setRoyalty(uint256 _newFee) external onlyAdmin {\\r\\n        royalty = _newFee;\\r\\n    }\\r\\n\\r\\n    function updateAdmin(address _newAdmin) public onlyAdmin {\\r\\n        admin = _newAdmin;\\r\\n    }\\r\\n    \\r\\n    function addWhitelisted(address _address) public onlyAdmin {\\r\\n        isWhitelisted[_address] = true;\\r\\n    }\\r\\n\\r\\n    function removeWhitelisted(address _address) public onlyAdmin {\\r\\n        isWhitelisted[_address] = false;\\r\\n    }\\r\\n\\r\\n    function addMintWhitelisted(address _address) public onlyAdmin {\\r\\n        isMintWhitelisted[currentMintWhiteListVersion][_address] = true;\\r\\n    }\\r\\n\\r\\n    function upgradeMintWhitelistVersion() public onlyAdmin {\\r\\n        currentMintWhiteListVersion++;\\r\\n    }\\r\\n\\r\\n    function addBatchMintWhitelisted(address[] memory mintWhitelist) public onlyAdmin {\\r\\n        for(uint256 i=0; i<mintWhitelist.length; i++) {\\r\\n            addMintWhitelisted(mintWhitelist[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setBatchCost(uint256[] memory _newCosts, bool _saleType) public onlyAdmin {\\r\\n        for(uint256 i=0; i<nextProjectId; i++) {\\r\\n            setSubCost(i, _saleType, _newCosts[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeMintWhitelisted(address _address, uint256 version) public onlyAdmin {\\r\\n        isMintWhitelisted[version][_address] = false;\\r\\n    }\\r\\n\\r\\n    function withdraw() public {\\r\\n        address payable wallet = address(msg.sender);\\r\\n        wallet.transfer(balanceOfAddress[msg.sender]);\\r\\n    }\\r\\n\\r\\n    function mint(uint256 _projectId) external payable returns (uint256 _tokenId) {\\r\\n        require(msg.value >= getMintCost(_projectId), \\\"Value should be more than mint cost.\\\");\\r\\n        require(publicSale || isMintWhitelisted[currentMintWhiteListVersion][msg.sender] || subContract[_projectId].checkWhitelisted(msg.sender) || subContract[_projectId].getSaleType(), \\\"Mint is not permitted.\\\");\\r\\n        \\r\\n        uint256 tokenId = subContract[_projectId].mint(msg.sender);\\r\\n        tokenIdToProjectId[tokenId + _projectId * ONE_MILLION] = _projectId;\\r\\n        address artist = subContract[_projectId].getArtist();\\r\\n        balanceOfAddress[artist] = balanceOfAddress[artist].add(msg.value * royalty / 10000);\\r\\n        balanceOfAddress[admin] = balanceOfAddress[admin].add(msg.value).sub(msg.value * royalty / 10000);\\r\\n\\r\\n        _mintToken(msg.sender, tokenId + _projectId * ONE_MILLION);\\r\\n\\r\\n        emit Mint(msg.sender, tokenId + _projectId * ONE_MILLION);\\r\\n\\r\\n        return tokenId;\\r\\n    }\\r\\n\\r\\n    function mintId(uint256 _projectId, uint256 tokenId) external payable {\\r\\n        require(msg.value >= getMintCost(_projectId), \\\"Value should be more than mint cost.\\\");\\r\\n        require(publicSale || isMintWhitelisted[currentMintWhiteListVersion][msg.sender] || subContract[_projectId].checkWhitelisted(msg.sender) || subContract[_projectId].getSaleType(), \\\"Mint is not permitted.\\\");\\r\\n        require(!_exists(tokenId + _projectId * ONE_MILLION), \\\"TokenId already exists.\\\");\\r\\n\\r\\n        subContract[_projectId].mintId(msg.sender, tokenId);\\r\\n        tokenIdToProjectId[tokenId + _projectId * ONE_MILLION] = _projectId;\\r\\n        address artist = subContract[_projectId].getArtist();\\r\\n        balanceOfAddress[artist] = balanceOfAddress[artist].add(msg.value * royalty / 10000);\\r\\n        balanceOfAddress[admin] = balanceOfAddress[admin].add(msg.value).sub(msg.value * royalty / 10000);\\r\\n\\r\\n        _mintToken(msg.sender, tokenId + _projectId * ONE_MILLION);\\r\\n\\r\\n        emit Mint(msg.sender, tokenId + _projectId * ONE_MILLION);\\r\\n    }\\r\\n\\r\\n    // inside of subContract\\r\\n    function getAdmin(uint256 _projectId) public view returns (address) {\\r\\n        // subContract = SubContract(project[_projectId]);\\r\\n        return subContract[_projectId].getAdmin();\\r\\n    }\\r\\n\\r\\n    function getArtist(uint256 _projectId) public view returns (address) {\\r\\n        return subContract[_projectId].getArtist();\\r\\n    }\\r\\n\\r\\n    function setMaster(uint256 _projectId, address _masterAddress) public onlyAdmin {\\r\\n        subContract[_projectId].setMaster(_masterAddress);\\r\\n    }\\r\\n\\r\\n    function setBlockStart(uint256 _projectId, uint256 _newBlockStart) public onlyAdmin {\\r\\n        subContract[_projectId].setBlockStart(_newBlockStart);\\r\\n    }\\r\\n\\r\\n    function getBlockStart(uint256 _projectId) public view returns (uint256) {\\r\\n        return subContract[_projectId].getBlockStart();\\r\\n    }\\r\\n\\r\\n    function getMaxSupply(uint256 _projectId) public view returns (uint256) {\\r\\n        return subContract[_projectId].getMaxSupply();\\r\\n    }\\r\\n\\r\\n    function getTotalSupply(uint256 _projectId) public view returns (uint256) {\\r\\n        return subContract[_projectId].getTotalSupply();\\r\\n    }\\r\\n\\r\\n    function setMaxSupply(uint256 _projectId, uint256 _newMaxSupply) public onlyAdmin {\\r\\n        subContract[_projectId].setMaxSupply(_newMaxSupply);\\r\\n    }\\r\\n\\r\\n    function setMaxMintAmount(uint256 _projectId, uint256 _newmaxMintAmount) public onlyAdmin {\\r\\n        subContract[_projectId].setMaxMintAmount(_newmaxMintAmount);\\r\\n    }\\r\\n\\r\\n    function getMaxMintAmount(uint256 _projectId) public view returns (uint256) {\\r\\n        return subContract[_projectId].getMaxMintAmount();\\r\\n    }\\r\\n\\r\\n    function setMintable(uint256 _projectId, bool mintFlag) public onlyAdmin {\\r\\n        subContract[_projectId].canMint(mintFlag);\\r\\n    }\\r\\n\\r\\n    function getBaseURI(uint256 _projectId) public view returns (string memory) {\\r\\n        return subContract[_projectId].getBaseURI();\\r\\n    }\\r\\n\\r\\n    function setBaseURI(uint256 _projectId, string memory _newBaseURI) public onlyAdmin {\\r\\n        subContract[_projectId].setBaseURI(_newBaseURI);\\r\\n    }\\r\\n\\r\\n    function setMetaDataExt(uint256 _projectId, string memory _newExt) public onlyAdmin {\\r\\n        subContract[_projectId].setMetaDataExt(_newExt);\\r\\n    }\\r\\n\\r\\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\\r\\n        return subContract[tokenIdToProjectId[tokenId]].tokenURI(tokenId - tokenIdToProjectId[tokenId] * ONE_MILLION);\\r\\n    }\\r\\n\\r\\n    function addSubBatchMintWhitelisted(uint256 _projectId, address[] memory mintWhitelist) public onlyAdmin {\\r\\n        subContract[_projectId].addBatchWhitelisted(mintWhitelist);\\r\\n    }\\r\\n\\r\\n    function removeSubWhitelisted(uint256 _projectId, address _address) public onlyAdmin {\\r\\n        subContract[_projectId].removeWhitelisted(_address);\\r\\n    }\\r\\n\\r\\n    function upgradeSubWhitelistVersion(uint256 _projectId) public onlyAdmin {\\r\\n        subContract[_projectId].upgradeWhitelistVersion();\\r\\n    }\\r\\n\\r\\n    function setSubCost(uint256 _projectId, bool _saleType, uint256 _newCost) public onlyAdmin {\\r\\n        subContract[_projectId].setCost(_saleType, _newCost);\\r\\n    }\\r\\n\\r\\n    function getSubCost(uint256 _projectId) public view returns (uint256) {\\r\\n        return subContract[_projectId].getCost();\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"mintWhitelist\",\"type\":\"address[]\"}],\"name\":\"addBatchMintWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addMintWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_subContractAddress\",\"type\":\"address\"}],\"name\":\"addProject\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"mintWhitelist\",\"type\":\"address[]\"}],\"name\":\"addSubBatchMintWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOfAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentMintWhiteListVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"getArtist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"getBaseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"getBlockStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isPublic\",\"type\":\"bool\"}],\"name\":\"getMasterCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"getMaxMintAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"getMaxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"getMintCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSaleType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"getSubCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"getTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMintWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mintId\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextProjectId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prvSaleCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pubSaleCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publicSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"removeMintWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeSubWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"royalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_newCosts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"_saleType\",\"type\":\"bool\"}],\"name\":\"setBatchCost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newBlockStart\",\"type\":\"uint256\"}],\"name\":\"setBlockStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_masterAddress\",\"type\":\"address\"}],\"name\":\"setMaster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isPublic\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_newCost\",\"type\":\"uint256\"}],\"name\":\"setMasterCost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setMasterPriceUsage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newmaxMintAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxMintAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newMaxSupply\",\"type\":\"uint256\"}],\"name\":\"setMaxSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_newExt\",\"type\":\"string\"}],\"name\":\"setMetaDataExt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"mintFlag\",\"type\":\"bool\"}],\"name\":\"setMintable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"setRoyalty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setSaleType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_saleType\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_newCost\",\"type\":\"uint256\"}],\"name\":\"setSubCost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToProjectId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"updateAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgradeMintWhitelistVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"upgradeSubWhitelistVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"useMasterPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Exposed", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000074578706f7365640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000035850440000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}