{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/common/LogoFactory.sol\": {\r\n      \"content\": \"//\\tSPDX-License-Identifier: MIT\\n/// @notice Initializes data transfer objects so svg can be built\\npragma solidity ^0.8.0;\\n\\nimport './LogoType.sol';\\nimport '../emoticon/SvgEmoticonBuilder.sol';\\nimport '../background/SvgBackground.sol';\\nimport '../text/SvgText.sol';\\nimport './LogoHelper.sol';\\n\\nlibrary LogoFactory {\\n  function initBackground(uint256 tokenId, uint256 seed) public view returns (SvgBackground.Background memory) {\\n    Color.Palette memory palette = LogoType.getPalette(seed);\\n    return getBackground(tokenId, seed, palette);\\n  }\\n\\n  function initEmoticon(uint256 tokenId, uint256 seed, string memory val, SvgText.Font memory font) public view returns (SvgEmoticonBuilder.Emoticon memory) {\\n    Color.Palette memory palette = LogoType.getPalette(seed);\\n    return getEmoticon(tokenId, seed, val, font, palette);\\n  }\\n\\n  function initText(uint256 tokenId, uint256 seed, string memory val, SvgText.Font memory font) public view returns (SvgText.Text memory) {\\n    Color.Palette memory palette = LogoType.getPalette(seed);\\n    string memory textType = LogoType.getTextType(seed);\\n    return getText(tokenId, seed >> 1, val, textType, font, palette);\\n  }\\n\\n  function getBackground(uint256 tokenId, uint256 seed, Color.Palette memory palette) public view returns (SvgBackground.Background memory) {\\n    string memory backgroundType = LogoType.getBackgroundType(seed);\\n    SvgFill.Fill[] memory fills;\\n    string memory class = '';\\n    if (LogoHelper.equal(backgroundType, 'None')) {\\n      //\\n    } else if (LogoHelper.equal(backgroundType,'Box')) {\\n      class = getIdOrClass(tokenId, 'box-background');\\n      string[] memory fillClasses = new string[](1);\\n      fillClasses[0] = getIdOrClass(tokenId, 'box-background');\\n      fills = getFills(seed, fillClasses, 1, palette.backgroundColors, LogoType.getFillTypeAlt(seed));\\n    } else if (LogoHelper.equal(backgroundType, 'Pattern A') \\n                || LogoHelper.equal(backgroundType, 'Pattern B')) {\\n      class = getIdOrClass(tokenId, 'pattern-background');\\n      string[] memory fillClasses = new string[](1);\\n      fillClasses[0] = getIdOrClass(tokenId, 'pattern-background');\\n      fills = getFills(seed, fillClasses, 1, palette.backgroundColors, '');\\n    } else if (LogoHelper.equal(backgroundType, 'Pattern AX2') \\n                || LogoHelper.equal(backgroundType, 'Pattern BX2') \\n                  || LogoHelper.equal(backgroundType, 'Pattern AB')) {\\n      class = getIdOrClass(tokenId, 'pattern-background');\\n      string[] memory fillClasses = new string[](2);\\n      fillClasses[0] = getIdOrClass(tokenId, 'pattern-background-1');\\n      fillClasses[1] = getIdOrClass(tokenId, 'pattern-background-2');\\n      fills = getFills(seed, fillClasses, 2, palette.backgroundColors, '');\\n    } else if (LogoHelper.equal(backgroundType, 'GM')) {\\n      class = getIdOrClass(tokenId, 'pattern-background');\\n      string[] memory fillClasses = new string[](5);\\n      fillClasses[0] = getIdOrClass(tokenId, 'pattern-background-1-1');\\n      fillClasses[1] = getIdOrClass(tokenId, 'pattern-background-1-2');\\n\\n      fillClasses[2] = getIdOrClass(tokenId, 'pattern-background-2-1');\\n      fillClasses[3] = getIdOrClass(tokenId, 'pattern-background-2-2');\\n\\n      fillClasses[4] = getIdOrClass(tokenId, 'pattern-background-3');\\n      fills = getFills(seed, fillClasses, 5, palette.backgroundColors, '');\\n    }\\n    SvgFilter.Filter memory filter = getFilter(tokenId, seed >> 10);\\n    return SvgBackground.Background(getIdOrClass(tokenId, 'background'), class, backgroundType, palette.name, 0, 0, fills, filter);\\n  }\\n\\n  function getEmoticon(uint256 tokenId, uint256 seed, string memory txtVal, SvgText.Font memory font, Color.Palette memory palette) public view returns (SvgEmoticonBuilder.Emoticon memory) {\\n    SvgFill.Fill[] memory fills;\\n    string memory class = getIdOrClass(tokenId, 'emoticon');\\n    string memory emoticonType = LogoType.getEmoticonType(seed);\\n    SvgText.Text memory text = getText(tokenId, seed, txtVal, emoticonType, font, palette);\\n    if (LogoHelper.equal(emoticonType, 'Text')) {\\n      fills = new SvgFill.Fill[](0);\\n    } else {\\n      string[] memory fillClasses = new string[](1);\\n      fillClasses[0] = getIdOrClass(tokenId, 'emoticon');\\n      fills = getFills(seed >> 1, fillClasses, 1, palette.emoticonColors, 'Solid');\\n    }\\n    return SvgEmoticonBuilder.Emoticon(getIdOrClass(tokenId, 'emoticon'), class, emoticonType, text, palette.name, fills, true);\\n  }\\n\\n  function getText(uint256 tokenId, uint256 seed, string memory val, string memory textType, SvgText.Font memory font, Color.Palette memory palette) public pure returns (SvgText.Text memory) {\\n    SvgFill.Fill[] memory fills;\\n    string memory class;\\n    uint256 size;\\n\\n    if (LogoHelper.equal(textType, 'Mailbox') \\n          || LogoHelper.equal(textType, 'Warped Mailbox')) {\\n      uint256 iSize = 300 / (bytes(val).length - 1);\\n      iSize = iSize <= 80 ? iSize : 80;\\n      size = iSize;\\n      string[] memory fillClasses = new string[](4);\\n      fillClasses[0] = getIdOrClass(tokenId, 'text-1');\\n      fillClasses[1] = getIdOrClass(tokenId, 'text-2');\\n      fillClasses[2] = getIdOrClass(tokenId, 'text-3');\\n      fillClasses[3] = getIdOrClass(tokenId, 'text-4');\\n      fills = getFills(seed, fillClasses, 4, palette.textColors, 'Solid');\\n      class = getIdOrClass(tokenId, 'text');\\n    } else if (LogoHelper.equal(textType, 'The Flippening')\\n                  || LogoHelper.equal(textType, 'Probably Nothing')) {\\n      uint256 iSize = 150 / (bytes(val).length - 1);\\n      iSize = iSize <= 12 ? iSize : 12;\\n      size = iSize;\\n      string[] memory fillClasses = new string[](1);\\n      fillClasses[0] = getIdOrClass(tokenId, 'emoticon-text');\\n      fills = getFills(seed, fillClasses, 1, palette.textColors, 'Solid');\\n      class = getIdOrClass(tokenId, 'emoticon-text');\\n    } else if (LogoHelper.equal(textType, 'Rug Pull')) {\\n      uint256 iSize = 300 / (bytes(val).length - 1);\\n      iSize = iSize <= 80 ? iSize : 80;\\n      size = iSize;\\n      string[] memory fillClasses = new string[](1);\\n      fillClasses[0] = getIdOrClass(tokenId, 'text');\\n      fills = getFills(seed, fillClasses, 1, palette.textColors, 'Solid');\\n      class = getIdOrClass(tokenId, 'text');\\n    } else if (LogoHelper.equal(textType, 'Fren')) {\\n      uint256 iSize = 150 / (bytes(val).length - 1);\\n      iSize = iSize <= 12 ? iSize : 12;\\n      size = iSize;\\n      string[] memory fillClasses = new string[](1);\\n      fillClasses[0] = getIdOrClass(tokenId, 'emoticon-text');\\n      fills = getFills(seed, fillClasses, 1, palette.textColors, 'Solid');\\n      class = getIdOrClass(tokenId, 'emoticon-text');\\n    } else if (LogoHelper.equal(textType, 'NGMI')) {\\n      uint256 iSize = 300 / (bytes(val).length - 1);\\n      iSize = iSize <= 80 ? iSize : 80;\\n      size = iSize;\\n      string[] memory fillClasses = new string[](1);\\n      fillClasses[0] = getIdOrClass(tokenId, 'text');\\n      fills = getFills(seed, fillClasses, 1, palette.textColors, 'Solid');\\n      class = getIdOrClass(tokenId, 'text');\\n    } else if (LogoHelper.equal(textType, 'Plain')) {\\n      uint256 iSize = 300 / (bytes(val).length - 1);\\n      iSize = iSize <= 80 ? iSize : 80;\\n      size = iSize;\\n      string[] memory fillClasses = new string[](1);\\n      fillClasses[0] = getIdOrClass(tokenId, 'text');\\n      fills = getFills(seed, fillClasses, 1, palette.textColors, 'Solid');\\n      class = getIdOrClass(tokenId, 'text');\\n    }\\n    return SvgText.Text(class, class, val, textType, font, size, palette.name, fills, LogoType.getAnimationType(seed));\\n  }\\n\\n  function getFills(uint256 seed, string[] memory classes, uint num, string[] memory palette, string memory fillTypeOverride) public pure returns (SvgFill.Fill[] memory) {\\n    SvgFill.Fill[] memory fills = new SvgFill.Fill[](num);\\n    for (uint i=0; i < num; i++) {\\n      string memory fillType = LogoHelper.equal(fillTypeOverride, '') ? LogoType.getFillType(seed >> i) : fillTypeOverride;\\n      string[] memory colors;\\n      if (LogoHelper.equal(fillType, 'Solid')) {\\n        colors = new string[](1);\\n        colors[0] = LogoType.getFillColor(seed >> i * 8, palette);\\n      } else if (LogoHelper.equal(fillType, 'Linear Gradient')\\n                  || LogoHelper.equal(fillType, 'Radial Gradient')\\n                      || LogoHelper.equal(fillType, 'Blocked Linear Gradient')\\n                        || LogoHelper.equal(fillType, 'Blocked Radial Gradient')) {\\n        colors = new string[](5);\\n        colors[0] = LogoType.getFillColor(seed >> (i * 5) + 1, palette);\\n        colors[1] = LogoType.getFillColor(seed >> (i * 5) + 2, palette);\\n        colors[2] = LogoType.getFillColor(seed >> (i * 5) + 3, palette);\\n        colors[3] = LogoType.getFillColor(seed >> (i * 5) + 4, palette);\\n        colors[4] = LogoType.getFillColor(seed >> (i * 5) + 5, palette);\\n      }\\n      string memory fillId = string(abi.encodePacked(classes[i], '-fill'));\\n      fills[i] = SvgFill.Fill(fillId, classes[i], fillType, colors, LogoType.getAnimationType(seed >> (i * 5) + 6));\\n    }\\n    return fills;\\n  }\\n\\n  function getFilter(uint256 tokenId, uint256 seed) public pure returns (SvgFilter.Filter memory) {\\n    string memory filterType = LogoType.getFilterType(seed);\\n    bool animate = LogoType.getAnimationType(seed >> 1);\\n    return SvgFilter.Filter(getIdOrClass(tokenId, 'filter'), filterType, '50', animate);\\n  }\\n\\n  function getIdOrClass(uint256 tokenId, string memory name) public pure returns (string memory) {\\n    return string(abi.encodePacked('tid', LogoHelper.toString(tokenId), '-', name));\\n  }\\n}\"\r\n    },\r\n    \"contracts/common/LogoType.sol\": {\r\n      \"content\": \"//\\tSPDX-License-Identifier: MIT\\n/// @notice Helper to pick the logo types based on seed\\npragma solidity ^0.8.0;\\n\\nimport './Color.sol';\\n\\nlibrary LogoType {\\n  function getPalette(uint256 seed) public pure returns (Color.Palette memory) {\\n    Color.Palette[] memory palettes = Color.getPalettes();\\n    return palettes[seed % palettes.length];\\n  }\\n\\n  function getBackgroundType(uint256 seed) public pure returns (string memory) {\\n    string[7] memory backgroundTypes = ['Box', 'Pattern A', 'Pattern B', 'Pattern AX2', 'Pattern BX2', 'Pattern AB', 'GM'];\\n    uint256 index = random(seed) % 100;\\n    uint8[7] memory distribution = [8, 26, 39, 52, 65, 78, 100];\\n    for (uint8 i = 0; i < backgroundTypes.length; i++) {\\n      if (index < distribution[i]) {\\n        return backgroundTypes[i];\\n      }\\n    }\\n    return backgroundTypes[6];\\n  }\\n\\n  function getEmoticonType(uint256 seed) public pure returns (string memory) {\\n    string[3] memory emoticonTypes = ['The Flippening', 'Probably Nothing', 'Fren'];\\n    return emoticonTypes[seed % emoticonTypes.length];\\n  }\\n\\n  function getTextType(uint256 seed) public pure returns (string memory) {\\n    string[5] memory textTypes = ['Plain', 'Rug Pull', 'Mailbox', 'Warped Mailbox', 'NGMI'];\\n    uint256 index = random(seed) % 1000;\\n    uint16[5] memory distribution = [250, 350, 550, 750, 1000];\\n    for (uint8 i = 0; i < textTypes.length; i++) {\\n      if (index < distribution[i]) {\\n        return textTypes[i];\\n      }\\n    }\\n    return textTypes[0];\\n  }\\n  function getFillType(uint256 seed) public pure returns (string memory) {\\n    string[5] memory fillTypes = ['Solid', 'Linear Gradient', 'Radial Gradient', 'Blocked Linear Gradient', 'Blocked Radial Gradient'];\\n    return fillTypes[seed % fillTypes.length];\\n  }\\n\\n  function getFillTypeAlt(uint256 seed) public pure returns (string memory) {\\n    string[4] memory fillTypes = ['Linear Gradient', 'Radial Gradient', 'Blocked Linear Gradient', 'Blocked Radial Gradient'];\\n    return fillTypes[seed % fillTypes.length];\\n  }\\n\\n  function getFillColor(uint256 seed, string[] memory palette) public pure returns (string memory) {\\n    return palette[seed % palette.length];\\n  }\\n\\n  function getFilterType(uint256 seed) public pure returns (string memory) {\\n    string[2] memory filterTypes = ['None', 'A'];\\n    return filterTypes[seed % filterTypes.length];\\n  }\\n\\n  function getAnimationType(uint256 seed) public pure returns (bool) {\\n    bool[2] memory animationTypes = [true, false];\\n    return animationTypes[seed % animationTypes.length];\\n  }\\n\\n  function random(uint256 input) internal pure returns (uint256) {\\n    return uint256(keccak256(abi.encodePacked(input)));\\n  }\\n  \\n  function random(string memory input) internal pure returns (uint256) {\\n    return uint256(keccak256(abi.encodePacked(input)));\\n  }\\n}\"\r\n    },\r\n    \"contracts/emoticon/SvgEmoticonBuilder.sol\": {\r\n      \"content\": \"//\\tSPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport './SvgEmoticon.sol';\\nimport '../text/SvgText.sol';\\nimport '../common/SvgFill.sol';\\nimport '../common/SvgElement.sol';\\nimport '../common/LogoHelper.sol';\\n\\nlibrary SvgEmoticonBuilder {\\n\\n  struct Emoticon {\\n    string id;\\n    string class;\\n    string emoticonType;\\n    SvgText.Text text;\\n    string paletteName;\\n    SvgFill.Fill[] fills;\\n    bool animate;\\n  }\\n\\n  function getSvgDefs(string memory seed, Emoticon memory emoticon) public pure returns (string memory) {\\n    string memory defs = '';\\n\\n    for (uint i=0; i < emoticon.fills.length; i++) {\\n      defs = string(abi.encodePacked(defs, SvgFill.getFillDefs(seed, emoticon.fills[i])));\\n    }\\n\\n    defs = string(abi.encodePacked(defs, SvgText.getSvgDefs(seed, emoticon.text)));\\n    return defs;\\n  }\\n\\n  function getSvgStyles(Emoticon memory emoticon) public pure returns (string memory) {\\n    string memory styles = '';\\n\\n    styles = string(abi.encodePacked(styles, SvgText.getSvgStyles(emoticon.text)));\\n\\n    for (uint i=0; i < emoticon.fills.length; i++) {\\n      styles = string(abi.encodePacked(styles, SvgFill.getFillStyles(emoticon.fills[i])));\\n    }\\n\\n    if (LogoHelper.equal(emoticon.emoticonType, 'The Flippening')) {\\n      styles = string(abi.encodePacked(styles, string(abi.encodePacked('.', emoticon.class, ' { font-size: 28px; font-family: Helvetica } '))));\\n    } else if (LogoHelper.equal(emoticon.emoticonType, 'Probably Nothing')) {\\n      styles = string(abi.encodePacked(styles, string(abi.encodePacked('.', emoticon.class, ' { font-size: 48px; font-family: Helvetica } '))));\\n    } else if (LogoHelper.equal(emoticon.emoticonType, 'Fren')) {\\n      styles = string(abi.encodePacked(styles, string(abi.encodePacked('.', emoticon.class, ' { font-size: 112px; font-family: Helvetica } '))));\\n    } \\n    return styles;\\n  }\\n\\n  function getSvgContent(Emoticon memory emoticon) public pure returns (string memory) {\\n    string memory content;\\n    if (LogoHelper.equal(emoticon.emoticonType, 'The Flippening')) {\\n      content = SvgEmoticon.getTheFlippeningContent(emoticon.text.animate, emoticon.class, emoticon.text.class, emoticon.text.val);\\n    } else if (LogoHelper.equal(emoticon.emoticonType, 'Probably Nothing')) {\\n      content = SvgEmoticon.getProbablyNothingContent(emoticon.animate, emoticon.class, emoticon.text.class, emoticon.text.val);\\n    } else if (LogoHelper.equal(emoticon.emoticonType, 'Fren')) {\\n      content = SvgEmoticon.getFrenContent(emoticon.animate, emoticon.class, emoticon.text.class, emoticon.text.val);\\n    }\\n    return content;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/background/SvgBackground.sol\": {\r\n      \"content\": \"//\\tSPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '../common/SvgFill.sol';\\nimport '../common/SvgFilter.sol';\\nimport '../common/SvgElement.sol';\\nimport '../common/LogoHelper.sol';\\nimport './SvgPattern.sol';\\n\\nlibrary SvgBackground {\\n\\n  struct Background {\\n    string id;\\n    string class;\\n    string backgroundType;\\n    string paletteName;\\n    uint16 width;\\n    uint16 height;\\n    SvgFill.Fill[] fills;\\n    SvgFilter.Filter filter;\\n  }\\n\\n  function getSvgDefs(string memory seed, Background memory background) public pure returns (string memory) {\\n    string memory defs = '';\\n    // Fill defs\\n    for (uint i=0; i < background.fills.length; i++) {\\n      defs = string(abi.encodePacked(defs, SvgFill.getFillDefs(seed, background.fills[i])));\\n    }\\n\\n    // Filter defs\\n    if (LogoHelper.equal(background.filter.filterType, 'A')) {\\n      defs = string(abi.encodePacked(defs, SvgFilter.getFilterDef(string(abi.encodePacked(seed, 'a')), background.filter)));\\n      if (LogoHelper.equal(background.backgroundType, 'GM')) {\\n        string memory originalId = background.filter.id;\\n        background.filter.id = string(abi.encodePacked(background.filter.id, '-2'));\\n        defs = string(abi.encodePacked(defs, SvgFilter.getFilterDef(string(abi.encodePacked(seed, 'b')), background.filter)));\\n        background.filter.id = originalId;\\n      }\\n    }\\n\\n    // Pattern defs\\n    if (LogoHelper.equal(background.backgroundType, 'Pattern A')) { \\n      defs = string(abi.encodePacked(defs, SvgPattern.getADef(seed, background.id, background.fills[0].fillType, background.fills[0].class)));\\n    } else if (LogoHelper.equal(background.backgroundType, 'Pattern B')) { \\n      defs = string(abi.encodePacked(defs, SvgPattern.getBDef(seed, background.id, background.fills[0].class)));\\n    } else if (LogoHelper.equal(background.backgroundType, 'Pattern AX2')) { \\n      defs = string(abi.encodePacked(defs, SvgPattern.getAX2Def(seed, background.id, background.fills[0].class, background.fills[0].fillType, background.fills[1].class)));\\n    } else if (LogoHelper.equal(background.backgroundType, 'Pattern BX2')) { \\n      defs = string(abi.encodePacked(defs, SvgPattern.getBX2Def(seed, background.id, background.fills[0].class, background.fills[1].class)));\\n    } else if (LogoHelper.equal(background.backgroundType, 'Pattern AB')) { \\n      defs = string(abi.encodePacked(defs, SvgPattern.getABDef(seed, background.id, background.fills[0].fillType, background.fills[0].class, background.fills[1].class)));\\n    } else if (LogoHelper.equal(background.backgroundType, 'GM')) { \\n      defs = string(abi.encodePacked(defs, SvgPattern.getGMDef(seed, background.id, background.fills[0].class, background.fills[1].class, background.fills[2].class, background.fills[3].class)));\\n    }\\n    return defs;\\n  }\\n\\n  function getSvgStyles(Background memory background) public pure returns (string memory) {\\n    string memory styles = '';\\n    for (uint i=0; i < background.fills.length; i++) {\\n      styles = string(abi.encodePacked(styles, SvgFill.getFillStyles(background.fills[i])));\\n    }\\n    return styles;\\n  }\\n\\n  function getSvgContent(Background memory background) public pure returns (string memory) {\\n    if (LogoHelper.equal(background.backgroundType, 'Box')) {\\n      return SvgElement.getRect(SvgElement.Rect(background.class, '0', '0', '100%', '100%', '', '', ''));\\n    } else if (LogoHelper.equal(background.backgroundType, 'Pattern A')\\n                || LogoHelper.equal(background.backgroundType, 'Pattern AX2')\\n                  || LogoHelper.equal(background.backgroundType, 'Pattern B')\\n                    || LogoHelper.equal(background.backgroundType, 'Pattern BX2')\\n                      || LogoHelper.equal(background.backgroundType, 'Pattern AB')) {\\n      if (LogoHelper.equal(background.filter.filterType, 'None')) {\\n        return SvgElement.getRect(SvgElement.Rect('', '0', '0', '100%', '100%', '', background.id, ''));\\n      } else {\\n        return SvgElement.getRect(SvgElement.Rect('', '0', '0', '100%', '100%', '', background.id, background.filter.id));\\n      }\\n    } else if (LogoHelper.equal(background.backgroundType, 'GM')) {\\n      string memory backgroundId1 = string(abi.encodePacked(background.id, '-1'));\\n      string memory backgroundId2 = string(abi.encodePacked(background.id, '-2'));\\n      string memory content = '';\\n      if (LogoHelper.equal(background.filter.filterType, 'None')) {\\n        content = SvgElement.getRect(SvgElement.Rect('', '0', '0', '100%', '70%', '0.8', backgroundId1, ''));\\n        content = string(abi.encodePacked(content, SvgElement.getCircle(SvgElement.Circle(background.fills[4].class, '80%', '50%', '15%', ''))));\\n        content = string(abi.encodePacked(content, SvgElement.getRect(SvgElement.Rect('', '0', '60%', '100%', '70%', '', backgroundId2, ''))));\\n        return content;\\n      } else {\\n        content = SvgElement.getRect(SvgElement.Rect('', '0', '0', '100%', '100%', '0.8', backgroundId1, background.filter.id));\\n        content = string(abi.encodePacked(content, SvgElement.getCircle(SvgElement.Circle(background.fills[4].class, '80%', '50%', '15%', ''))));\\n        content = string(abi.encodePacked(content, SvgElement.getRect(SvgElement.Rect('', '0', '60%', '100%', '70%', '', backgroundId2, string(abi.encodePacked(background.filter.id, '-2'))))));\\n        return content;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/text/SvgText.sol\": {\r\n      \"content\": \"//\\tSPDX-License-Identifier: MIT\\n/// @title  Text Logo Elements\\n/// @notice On-chain SVG\\npragma solidity ^0.8.0;\\n\\nimport '../common/SvgFill.sol';\\nimport '../common/SvgElement.sol';\\nimport '../common/LogoHelper.sol';\\n\\nlibrary SvgText {\\n\\n  struct Font {\\n    string link;\\n    string name;\\n  }\\n  \\n  struct Text {\\n    string id;\\n    string class;\\n    string val;\\n    string textType;\\n    Font font;\\n    uint256 size;\\n    string paletteName;\\n    SvgFill.Fill[] fills;\\n    bool animate;\\n  }\\n\\n  function getSvgDefs(string memory seed, Text memory text) public pure returns (string memory) {\\n    string memory defs = '';\\n\\n    for (uint i = 0; i < text.fills.length; i++) {\\n      defs = string(abi.encodePacked(defs, SvgFill.getFillDefs(seed, text.fills[i])));\\n    }\\n\\n    if (LogoHelper.equal(text.textType, 'Rug Pull')) {\\n      uint256[] memory ys = getRugPullY(text);\\n      for (uint8 i = 0; i < 4; i++) {\\n        string memory path = SvgElement.getRect(SvgElement.Rect('', '', LogoHelper.toString(ys[i] + 3), '100%', '100%', '', '', ''));\\n        string memory id = string(abi.encodePacked('clip-', LogoHelper.toString(i)));\\n        defs = string(abi.encodePacked(defs, SvgElement.getClipPath(SvgElement.ClipPath(id, path))));\\n      }\\n    }\\n    return defs;\\n  }\\n  \\n  // TEXT //\\n  function getSvgStyles(Text memory text) public pure returns (string memory) {\\n    string memory styles = !LogoHelper.equal(text.font.link, '') ? string(abi.encodePacked('@import url(', text.font.link, '); ')) : '';\\n    styles = string(abi.encodePacked(styles, '.', text.class, ' { font-family:', text.font.name, '; font-size: ', LogoHelper.toString(text.size), 'px; font-weight: 800; } '));\\n\\n    for (uint i=0; i < text.fills.length; i++) {\\n      styles = string(abi.encodePacked(styles, SvgFill.getFillStyles(text.fills[i])));\\n    }\\n    return styles;\\n  }\\n\\n  function getSvgContent(Text memory text) public pure returns (string memory) {\\n    string memory content = '';\\n    if (LogoHelper.equal(text.textType, 'Plain')) {\\n      content = SvgElement.getText(SvgElement.Text(text.class, '50%', '50%', '', '', '', 'central', 'middle', '', '', '', text.val));\\n    } else if (LogoHelper.equal(text.textType, 'Rug Pull')) {\\n      content = getRugPullContent(text);\\n    } else if (LogoHelper.equal(text.textType, 'Mailbox') || LogoHelper.equal(text.textType, 'Warped Mailbox')) {\\n      uint8 iterations = LogoHelper.equal(text.textType, 'Mailbox') ? 2 : 30;\\n      for (uint8 i = 0; i < iterations; i++) {\\n        content = string(abi.encodePacked(content, SvgElement.getText(SvgElement.Text(string(abi.encodePacked(text.class, ' ', text.fills[i % text.fills.length].class)), '50%', '50%', LogoHelper.toString(iterations - i), LogoHelper.toString(iterations - i), '', 'central', 'middle', '', '', '', text.val))));\\n      }\\n      content = string(abi.encodePacked(content, SvgElement.getText(SvgElement.Text(string(abi.encodePacked(text.class, ' ', text.fills[text.fills.length - 1].class)), '50%', '50%', '', '', '', 'central', 'middle', '', '', '', text.val))));\\n    } else if (LogoHelper.equal(text.textType, 'NGMI')) {\\n      string memory rotate = LogoHelper.getRotate(text.val);\\n      content = SvgElement.getText(SvgElement.Text(text.class, '50%', '50%', '', '', '', 'central', 'middle', rotate, '', '', text.val));\\n    }\\n    return content;\\n  }\\n\\n  function getRugPullContent(Text memory text) public pure returns (string memory) {\\n    // get first animation y via y_prev = (y of txt 1) - font size / 2)\\n    // next animation goes to y_prev + (font size / 3)\\n    // clip path is txt elemnt y + 3\\n\\n    string memory content = '';\\n    uint256[] memory ys = getRugPullY(text);\\n\\n    string memory element = SvgElement.getAnimate(SvgElement.Animate('y', LogoHelper.toString(ys[4]), '', '2600', '0', '1', 'freeze'));\\n    element = string(abi.encodePacked(text.val, element));\\n    element = SvgElement.getText(SvgElement.Text(text.class, '50%', LogoHelper.toString(ys[0]), '', '', '', 'alphabetic', 'middle', '', '', 'clip-3', element));      \\n\\n    content = element;\\n    element = SvgElement.getAnimate(SvgElement.Animate('y', LogoHelper.toString(ys[3]), '', '2400', '0', '1', 'freeze'));\\n    element = string(abi.encodePacked(text.val, element));\\n    element = SvgElement.getText(SvgElement.Text(text.class, '50%', LogoHelper.toString(ys[0]), '', '', '', 'alphabetic', 'middle', '', '', 'clip-2', element));    \\n    content = string(abi.encodePacked(content, element));\\n\\n    element = SvgElement.getAnimate(SvgElement.Animate('y', LogoHelper.toString(ys[2]), '', '2200', '0', '1', 'freeze'));\\n    element = string(abi.encodePacked(text.val, element));\\n    element = SvgElement.getText(SvgElement.Text(text.class, '50%', LogoHelper.toString(ys[0]), '', '', '', 'alphabetic', 'middle', '', '', 'clip-1', element));      \\n    content = string(abi.encodePacked(content, element));\\n\\n    element = SvgElement.getAnimate(SvgElement.Animate('y', LogoHelper.toString(ys[1]), '', '2000', '0', '1', 'freeze'));\\n    element = string(abi.encodePacked(text.val, element));\\n    element = SvgElement.getText(SvgElement.Text(text.class, '50%', LogoHelper.toString(ys[0]), '', '', '', 'alphabetic', 'middle', '', '', 'clip-0', element));\\n    content = string(abi.encodePacked(content, element));\\n\\n    return string(abi.encodePacked(content, SvgElement.getText(SvgElement.Text(text.class, '50%', LogoHelper.toString(ys[0]), '', '', '', 'alphabetic', 'middle', '', '', '', text.val))));\\n  }\\n\\n  function getRugPullY(Text memory text) public pure returns (uint256[] memory) {\\n    uint256[] memory ys = new uint256[](5);\\n    uint256 y =  (text.size - (text.size / 4)) + (text.size / 2) + (text.size / 3) + (text.size / 4) + (text.size / 5);\\n    y = ((300 - y) / 2) + (text.size - (text.size / 4));\\n    ys[0] = y;\\n    y = y + text.size / 2;\\n    ys[1] = y;\\n    y = y + text.size / 3;\\n    ys[2] = y;\\n    y = y + text.size / 4;\\n    ys[3] = y;\\n    y = y + text.size / 5;\\n    ys[4] = y;\\n    return ys;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/common/LogoHelper.sol\": {\r\n      \"content\": \"//\\tSPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\nlibrary LogoHelper {\\n  function getRotate(string memory text) public pure returns (string memory) {\\n    bytes memory byteString = bytes(text);\\n    string memory rotate = string(abi.encodePacked('-', toString(random(text) % 10 + 1)));\\n    for (uint i=1; i < byteString.length; i++) {\\n      uint nextRotate = random(rotate) % 10 + 1;\\n      if (i % 2 == 0) {\\n        rotate = string(abi.encodePacked(rotate, ',-', toString(nextRotate)));\\n      } else {\\n        rotate = string(abi.encodePacked(rotate, ',', toString(nextRotate)));\\n      }\\n    }\\n    return rotate;\\n  }\\n\\n  function getTurbulance(string memory seed, uint max, uint magnitudeOffset) public pure returns (string memory) {\\n    string memory turbulance = decimalInRange(seed, max, magnitudeOffset);\\n    uint rand = randomInRange(turbulance, max, 0);\\n    return string(abi.encodePacked(turbulance, ', ', getDecimal(rand, magnitudeOffset)));\\n  }\\n\\n  function decimalInRange(string memory seed, uint max, uint magnitudeOffset) public pure returns (string memory) {\\n    uint rand = randomInRange(seed, max, 0);\\n    return getDecimal(rand, magnitudeOffset);\\n  }\\n\\n  // CORE HELPERS //\\n  function random(string memory input) public pure returns (uint256) {\\n    return uint256(keccak256(abi.encodePacked(input)));\\n  }\\n\\n  function randomFromInt(uint256 seed) internal pure returns (uint256) {\\n    return uint256(keccak256(abi.encodePacked(seed)));\\n  }\\n\\n  function randomInRange(string memory input, uint max, uint offset) public pure returns (uint256) {\\n    max = max - offset;\\n    return (random(input) % max) + offset;\\n  }\\n\\n  function equal(string memory a, string memory b) public pure returns (bool) {\\n    return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\\n  }\\n\\n  function toString(uint256 value) public pure returns (string memory) {\\n    // Inspired by OraclizeAPI's implementation - MIT license\\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n    if (value == 0) {\\n        return \\\"0\\\";\\n    }\\n    uint256 temp = value;\\n    uint256 digits;\\n    while (temp != 0) {\\n        digits++;\\n        temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n        digits -= 1;\\n        buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n        value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n\\n  function toString(address x) internal pure returns (string memory) {\\n    bytes memory s = new bytes(40);\\n    for (uint i = 0; i < 20; i++) {\\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));\\n      bytes1 hi = bytes1(uint8(b) / 16);\\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n      s[2*i] = char(hi);\\n      s[2*i+1] = char(lo);            \\n    }\\n    return string(s);\\n  }\\n\\nfunction char(bytes1 b) internal pure returns (bytes1 c) {\\n  if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n  else return bytes1(uint8(b) + 0x57);\\n}\\n  \\n  function getDecimal(uint val, uint magnitudeOffset) public pure returns (string memory) {\\n    string memory decimal;\\n    if (val != 0) {\\n      for (uint i = 10; i < magnitudeOffset / val; i=10*i) {\\n        decimal = string(abi.encodePacked(decimal, '0'));\\n      }\\n    }\\n    decimal = string(abi.encodePacked('0.', decimal, toString(val)));\\n    return decimal;\\n  }\\n\\n  bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n  /// @notice Encodes some bytes to the base64 representation\\n  function encode(bytes memory data) internal pure returns (string memory) {\\n    uint256 len = data.length;\\n    if (len == 0) return \\\"\\\";\\n\\n    // multiply by 4/3 rounded up\\n    uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n    // Add some extra buffer at the end\\n    bytes memory result = new bytes(encodedLen + 32);\\n\\n    bytes memory table = TABLE;\\n\\n    assembly {\\n      let tablePtr := add(table, 1)\\n      let resultPtr := add(result, 32)\\n\\n      for {\\n        let i := 0\\n      } lt(i, len) {\\n\\n      } {\\n        i := add(i, 3)\\n        let input := and(mload(add(data, i)), 0xffffff)\\n\\n        let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n        out := shl(8, out)\\n        out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n        out := shl(8, out)\\n        out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n        out := shl(8, out)\\n        out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n        out := shl(224, out)\\n\\n        mstore(resultPtr, out)\\n\\n        resultPtr := add(resultPtr, 4)\\n      }\\n\\n      switch mod(len, 3)\\n      case 1 {\\n        mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n      }\\n      case 2 {\\n        mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n      }\\n\\n      mstore(result, encodedLen)\\n    }\\n    return string(result);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/common/Color.sol\": {\r\n      \"content\": \"//\\tSPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\nlibrary Color {\\n  \\n  struct Palette {\\n    string name;\\n    string[] backgroundColors;\\n    string[] emoticonColors;\\n    string[] textColors;\\n  }\\n\\n  function getPalettes() public pure returns (Palette[] memory) {\\n    Palette[] memory palettes = new Palette[](9);\\n    palettes[0] = getPalette1();\\n    palettes[1] = getPalette2();\\n    palettes[2] = getPalette3();\\n    palettes[3] = getPalette4();\\n    palettes[4] = getPalette5();\\n    palettes[5] = getPalette6();\\n    palettes[6] = getPalette7();\\n    palettes[7] = getPalette8();\\n    palettes[8] = getPalette9();\\n    return palettes;\\n  }\\n\\n  function getPalette1() public pure returns (Palette memory) {\\n    string[] memory backgroundColors = new string[](5);\\n    backgroundColors[0] = '#D9D161';\\n    backgroundColors[1] = '#FFC9ED';\\n    backgroundColors[2] = '#C9CAF7';\\n    backgroundColors[3] = '#F2FA7F';\\n    backgroundColors[4] = '#53B7F0';\\n\\n    string[] memory textColors = new string[](5);\\n    textColors[0] = '#AFA1C7';\\n    textColors[1] = '#644A91';\\n    textColors[2] = '#6C637A';\\n    textColors[3] = '#CCB9ED';\\n    textColors[4] = '#3F3A47';\\n\\n    return Palette('1', backgroundColors, textColors, textColors);\\n  }\\n\\n  function getPalette2() public pure returns (Palette memory) {\\n    string[] memory backgroundColors = new string[](5);\\n    backgroundColors[0] = '#C25F4A';\\n    backgroundColors[1] = '#F5DDD7';\\n    backgroundColors[2] = '#8F4561';\\n    backgroundColors[3] = '#7D9C72';\\n    backgroundColors[4] = '#94C24A';\\n\\n    string[] memory textColors = new string[](5);\\n    textColors[0] = '#3E7F8C';\\n    textColors[1] = '#425559';\\n    textColors[2] = '#1C3A40';\\n    textColors[3] = '#68868C';\\n    textColors[4] = '#998971';\\n\\n    return Palette('2', backgroundColors, textColors, textColors);\\n  }\\n\\n  function getPalette3() public pure returns (Palette memory) {\\n    string[] memory backgroundColors = new string[](5);\\n    backgroundColors[0] = '#885FBD';\\n    backgroundColors[1] = '#80788D';\\n    backgroundColors[2] = '#495AF0';\\n    backgroundColors[3] = '#F5F1DF';\\n    backgroundColors[4] = '#BD955C';\\n\\n    string[] memory textColors = new string[](5);\\n    textColors[0] = '#3E3D54';\\n    textColors[1] = '#716BDB';\\n    textColors[2] = '#9D9BD4';\\n    textColors[3] = '#312E5E';\\n    textColors[4] = '#7775A1';\\n\\n    return Palette('3', backgroundColors, textColors, textColors);\\n  }\\n\\n  function getPalette4() public pure returns (Palette memory) {\\n    string[] memory backgroundColors = new string[](5);\\n    backgroundColors[0] = '#568F82';\\n    backgroundColors[1] = '#79DBC5';\\n    backgroundColors[2] = '#DBB36E';\\n    backgroundColors[3] = '#59478F';\\n    backgroundColors[4] = '#8163DB';\\n\\n    string[] memory textColors = new string[](5);\\n    textColors[0] = '#5C441E';\\n    textColors[1] = '#E1C18E';\\n    textColors[2] = '#FFBE54';\\n    textColors[3] = '#574C3A';\\n    textColors[4] = '#A87D03';\\n\\n    return Palette('4', backgroundColors, textColors, textColors);\\n  }\\n\\n  function getPalette5() public pure returns (Palette memory) {\\n    string[] memory backgroundColors = new string[](5);\\n    backgroundColors[0] = '#D9A561';\\n    backgroundColors[1] = '#FFEFED';\\n    backgroundColors[2] = '#FACAF7';\\n    backgroundColors[3] = '#CBED2E';\\n    backgroundColors[4] = '#78C7AC';\\n\\n    string[] memory textColors = new string[](5);\\n    textColors[0] = '#B8A561';\\n    textColors[1] = '#856F1E';\\n    textColors[2] = '#C21D3E';\\n    textColors[3] = '#D1EAED';\\n    textColors[4] = '#769C96';\\n\\n    return Palette('5', backgroundColors, textColors, textColors);\\n  }\\n\\n  function getPalette6() public pure returns (Palette memory) {\\n    string[] memory backgroundColors = new string[](5);\\n    backgroundColors[0] = '#D9D161';\\n    backgroundColors[1] = '#FFC9ED';\\n    backgroundColors[2] = '#C9CAF7';\\n    backgroundColors[3] = '#F2FA7F';\\n    backgroundColors[4] = '#53B7F0';\\n\\n    string[] memory textColors = new string[](5);\\n    textColors[0] = '#AFA1C7';\\n    textColors[1] = '#644A91';\\n    textColors[2] = '#6C637A';\\n    textColors[3] = '#CCB9ED';\\n    textColors[4] = '#3F3A47';\\n\\n    return Palette('6', backgroundColors, textColors, textColors);\\n  }\\n\\n  function getPalette7() public pure returns (Palette memory) {\\n    string[] memory backgroundColors = new string[](5);\\n    backgroundColors[0] = '#F5E564';\\n    backgroundColors[1] = '#F5C971';\\n    backgroundColors[2] = '#F5595B';\\n    backgroundColors[3] = '#D0C6F5';\\n    backgroundColors[4] = '#95BAF5';\\n\\n    string[] memory textColors = new string[](5);\\n    textColors[0] = '#FFEE00';\\n    textColors[1] = '#F5A318';\\n    textColors[2] = '#F50008';\\n    textColors[3] = '#4B00F5';\\n    textColors[4] = '#1685F5';\\n\\n    return Palette('7', backgroundColors, textColors, textColors);\\n  }\\n\\n  function getPalette8() public pure returns (Palette memory) {\\n    string[] memory backgroundColors = new string[](5);\\n    backgroundColors[0] = '#FDAD0E';\\n    backgroundColors[1] = '#F4671F';\\n    backgroundColors[2] = '#D60441';\\n    backgroundColors[3] = '#84265E';\\n    backgroundColors[4] = '#247D75';\\n\\n    string[] memory textColors = new string[](5);\\n    textColors[0] = '#FFF6E1';\\n    textColors[1] = '#A01356';\\n    textColors[2] = '#4F516A';\\n    textColors[3] = '#F25322';\\n    textColors[4] = '#5B3486';\\n\\n    return Palette('8', backgroundColors, textColors, textColors);\\n  }\\n\\n  function getPalette9() public pure returns (Palette memory) {\\n    string[] memory backgroundColors = new string[](5);\\n    backgroundColors[0] = '#5E4D3D';\\n    backgroundColors[1] = '#FFFFE9';\\n    backgroundColors[2] = '#C1C9C3';\\n    backgroundColors[3] = '#F4F3F0';\\n    backgroundColors[4] = '#CFC9A5';\\n\\n    string[] memory textColors = new string[](5);\\n    textColors[0] = '#85A383';\\n    textColors[1] = '#CCCCBA';\\n    textColors[2] = '#A6ADA8';\\n    textColors[3] = '#4A4A48';\\n    textColors[4] = '#D1D0CD';\\n\\n    return Palette('9', backgroundColors, textColors, textColors);\\n  }\\n}\"\r\n    },\r\n    \"contracts/emoticon/SvgEmoticon.sol\": {\r\n      \"content\": \"//\\tSPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '../common/SvgElement.sol';\\n\\nlibrary SvgEmoticon {\\n  function getTheFlippeningContent(bool animate, string memory emoticonClass, string memory textClass, string memory text) public pure returns (string memory) {\\n    string memory animate = SvgElement.getAnimate(SvgElement.Animate('rotate', '', '0;20;0', '500', '0', '1', 'freeze'));\\n    string memory element = string(abi.encodePacked('\\\\xE2\\\\x95\\\\xAF', animate, ''));\\n\\n    string memory content = SvgElement.getTspan(SvgElement.Tspan(emoticonClass, '', '', '', element));\\n\\n    content = string(abi.encodePacked(content, '\\\\xC2\\\\xB0\\\\xE2\\\\x96\\\\xA1\\\\xC2\\\\xB0\\\\xEF\\\\xBC\\\\x89', ''));\\n    element = string(abi.encodePacked('\\\\xE2\\\\x95\\\\xAF', animate));\\n\\n    content = string(abi.encodePacked(content, SvgElement.getTspan(SvgElement.Tspan(emoticonClass, '', '', '', element)), ''));\\n\\n    element = string(abi.encodePacked('(', content, ''));\\n\\n    content = SvgElement.getText(SvgElement.Text(emoticonClass, '20', '50%', '', '', '', 'central', 'start', '', '', '', element));\\n    \\n    animate = '<animateTransform attributeName=\\\"transform\\\" attributeType=\\\"XML\\\" type=\\\"rotate\\\" from=\\\"0 160 110\\\" to=\\\"180 220 150\\\" begin=\\\"250ms\\\" dur=\\\"500ms\\\" repeatCount=\\\"1\\\" fill=\\\"freeze\\\"/>';\\n    element = SvgElement.getTspan(SvgElement.Tspan(textClass, '', '', '', text));\\n    element = string(abi.encodePacked(element, 'T', animate));\\n    element = string(abi.encodePacked('T', element));\\n\\n    element = SvgElement.getText(SvgElement.Text(emoticonClass, '160', '140', '', '', '', 'hanging', 'start', '', '', '', element));\\n    return string(abi.encodePacked(content, element)); \\n  }\\n\\n  function getProbablyNothingContent(bool animate, string memory emoticonClass, string memory textClass, string memory text) public pure returns (string memory) {\\n    string memory element = SvgElement.getTspan(SvgElement.Tspan(textClass, '', '2', '-18', text));\\n    element = string(abi.encodePacked('\\\\xC2\\\\xAF\\\\x5C\\\\x5F\\\\x28\\\\xE3\\\\x83\\\\x84\\\\x29\\\\x5F\\\\x2F', element));\\n    element = string(abi.encodePacked(element, '<animate attributeName=\\\"dy\\\" values=\\\"0;-2,0,0,2,0,0,-2;0;-2,0,0,2,0,0,-2;0\\\" dur=\\\"2s\\\" repeatCount=\\\"1\\\"/>'));\\n    return SvgElement.getText(SvgElement.Text(emoticonClass, '10%', '50%', '', '', '', 'central', 'start', '', '', '', element));\\n  }\\n\\n  function getFrenContent(bool animate, string memory emoticonClass, string memory textClass, string memory text) public pure returns (string memory) {\\n    string memory element = SvgElement.getTspan(SvgElement.Tspan(textClass, '', '1', '', text));\\n    element = string(abi.encodePacked('(^', element, '^)'));\\n\\n    bytes memory byteString = bytes(text);\\n    string memory dy = '0,-2,2,';\\n    for (uint i = 1; i < byteString.length; i++) {\\n      dy = string(abi.encodePacked(dy, '0,'));\\n    }\\n    dy = string(abi.encodePacked('0;', dy, '-2,2;', '0;'));\\n    element = string(abi.encodePacked(element, SvgElement.getAnimate(SvgElement.Animate('dy', '', dy, '1500', '500', '1', ''))));\\n    return SvgElement.getText(SvgElement.Text(emoticonClass, '50%', '50%', '', '', '', 'central', 'middle', '', '', '', element));\\n  }\\n}\"\r\n    },\r\n    \"contracts/common/SvgFill.sol\": {\r\n      \"content\": \"//\\tSPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport './SvgElement.sol';\\nimport './LogoHelper.sol';\\n\\nlibrary SvgFill {\\n  struct Fill {\\n    string id;\\n    string class;\\n    string fillType;\\n    string[] colors;\\n    bool animate;\\n  }\\n\\n  // FILL //\\n  function getFillDefs(string memory seed, Fill memory fill) public pure returns (string memory) {\\n    string memory defs = '';\\n    if (LogoHelper.equal(fill.fillType, 'Linear Gradient') || LogoHelper.equal(fill.fillType, 'Blocked Linear Gradient')) {\\n      if (!fill.animate) {\\n        defs = SvgElement.getLinearGradient(SvgElement.LinearGradient(fill.id, fill.colors, LogoHelper.equal(fill.fillType, 'Blocked Linear Gradient'), ''));\\n      } else {\\n       string memory val = LogoHelper.toString(LogoHelper.randomInRange(seed, 100 , 0));\\n       string memory values = string(abi.encodePacked(val,\\n                                                      '%;',\\n                                                      LogoHelper.toString(LogoHelper.randomInRange(string(abi.encodePacked(seed, 'a')), 100 , 0)),\\n                                                      '%;',\\n                                                      val,\\n                                                      '%;'));\\n        val = LogoHelper.toString(LogoHelper.randomInRange(seed, 50000 , 5000));\\n        defs = SvgElement.getLinearGradient(SvgElement.LinearGradient(fill.id, fill.colors, LogoHelper.equal(fill.fillType, 'Blocked Linear Gradient'), SvgElement.getAnimate(SvgElement.Animate(getLinearAnimationType(seed), '', values, val, '0', getAnimationRepeat(seed), 'freeze'))));\\n      }\\n    } else if (LogoHelper.equal(fill.fillType, 'Radial Gradient') || LogoHelper.equal(fill.fillType, 'Blocked Radial Gradient')) {\\n      if (!fill.animate) {\\n        defs = SvgElement.getRadialGradient(SvgElement.RadialGradient(fill.id, fill.colors, LogoHelper.equal(fill.fillType, 'Blocked Radial Gradient'), ''));\\n      } else {\\n        string memory val = LogoHelper.toString(LogoHelper.randomInRange(seed, 100, 0));\\n        string memory values = string(abi.encodePacked(val,\\n                                                      '%;',\\n                                                      LogoHelper.toString(LogoHelper.randomInRange(string(abi.encodePacked(seed, 'a')), 100 , 0)),\\n                                                      '%;',\\n                                                      val,\\n                                                      '%;'));\\n        val = LogoHelper.toString(LogoHelper.randomInRange(seed, 10000 , 5000));\\n        defs = SvgElement.getRadialGradient(SvgElement.RadialGradient(fill.id, fill.colors, LogoHelper.equal(fill.fillType, 'Blocked Radial Gradient'), SvgElement.getAnimate(SvgElement.Animate(getRadialAnimationType(seed), '', values, val, '0', getAnimationRepeat(seed), 'freeze'))));\\n        \\n      }\\n    }\\n    return defs;\\n  }\\n\\n  function getFillStyles(Fill memory fill) public pure returns (string memory) {\\n    if (LogoHelper.equal(fill.fillType, 'Solid')) {\\n      return string(abi.encodePacked('.', fill.class, ' { fill: ', fill.colors[0], ' } '));\\n    } else if (LogoHelper.equal(fill.fillType, 'Linear Gradient')\\n                || LogoHelper.equal(fill.fillType, 'Radial Gradient')\\n                  || LogoHelper.equal(fill.fillType, 'Blocked Linear Gradient')\\n                    || LogoHelper.equal(fill.fillType, 'Blocked Radial Gradient')) {\\n      return string(abi.encodePacked('.', fill.class, ' { fill: url(#', fill.id, ') } '));\\n    }\\n    string memory styles = '';\\n    return styles;\\n  }\\n\\n  function getLinearAnimationType(string memory seed) private pure returns (string memory) {\\n    string[4] memory types = ['x1', 'x2', 'y1', 'y2'];\\n    return types[LogoHelper.random(seed) % types.length];\\n  }\\n\\n  function getRadialAnimationType(string memory seed) private pure returns (string memory) {\\n    string[3] memory types = ['fx', 'fy', 'r'];\\n    return types[LogoHelper.random(seed) % types.length];\\n  }\\n\\n  function getAnimationRepeat(string memory seed) private pure returns (string memory) {\\n    string[3] memory types = ['indefinite', '1', '2'];\\n    return types[LogoHelper.random(seed) % types.length];\\n  }\\n\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/common/SvgElement.sol\": {\r\n      \"content\": \"//\\tSPDX-License-Identifier: MIT\\n/// @notice Helper to build svg elements\\npragma solidity ^0.8.0;\\n\\nlibrary SvgElement {\\n  struct Rect {\\n    string class;\\n    string x;\\n    string y;\\n    string width;\\n    string height;\\n    string opacity;\\n    string fill;\\n    string filter;\\n  }\\n\\n  function getRect(Rect memory rect) public pure returns (string memory) {\\n    string memory element = '<rect ';\\n    element = !equal(rect.class, '') ? string(abi.encodePacked(element, 'class=\\\"', rect.class, '\\\" ')) : element;\\n    element = !equal(rect.x, '') ? string(abi.encodePacked(element, 'x=\\\"', rect.x, '\\\" ')) : element;\\n    element = !equal(rect.y, '') ? string(abi.encodePacked(element, 'y=\\\"', rect.y, '\\\" ')) : element;\\n    element = !equal(rect.width, '') ? string(abi.encodePacked(element, 'width=\\\"', rect.width, '\\\" ')) : element;\\n    element = !equal(rect.height, '') ? string(abi.encodePacked(element, 'height=\\\"', rect.height, '\\\" ')) : element;\\n    element = !equal(rect.opacity, '') ? string(abi.encodePacked(element, 'opacity=\\\"', rect.opacity, '\\\" ')) : element;\\n    element = !equal(rect.fill, '') ? string(abi.encodePacked(element, 'fill=\\\"url(#', rect.fill, ')\\\" ')) : element;\\n    element = !equal(rect.filter, '') ? string(abi.encodePacked(element, 'filter=\\\"url(#', rect.filter, ')\\\" ')) : element;\\n    element = string(abi.encodePacked(element, '/>'));\\n    return element;\\n  }\\n\\n  struct Circle {\\n    string class;\\n    string cx;\\n    string cy;\\n    string r;\\n    string opacity;\\n  }\\n\\n  function getCircle(Circle memory circle) public pure returns (string memory) {\\n    string memory element = '<circle ';\\n    element = !equal(circle.class, '') ? string(abi.encodePacked(element, 'class=\\\"', circle.class, '\\\" ')) : element;\\n    element = !equal(circle.cx, '') ? string(abi.encodePacked(element, 'cx=\\\"', circle.cx, '\\\" ')) : element;\\n    element = !equal(circle.cy, '') ? string(abi.encodePacked(element, 'cy=\\\"', circle.cy, '\\\" ')) : element;\\n    element = !equal(circle.r, '') ? string(abi.encodePacked(element, 'r=\\\"', circle.r, '\\\" ')) : element;\\n    element = !equal(circle.opacity, '') ? string(abi.encodePacked(element, 'opacity=\\\"', circle.opacity, '\\\" ')) : element;\\n    element = string(abi.encodePacked(element, '/>'));\\n    return element;\\n  }\\n\\n  struct Text {\\n    string class;\\n    string x;\\n    string y;\\n    string dx;\\n    string dy;\\n    string display;\\n    string baseline;\\n    string anchor;\\n    string rotate;\\n    string transform;\\n    string clipPath;\\n    string val;\\n  }\\n\\n  function getText(Text memory txt) public pure returns (string memory) {\\n    string memory element = '<text ';\\n    element = !equal(txt.class, '') ? string(abi.encodePacked(element, 'class=\\\"', txt.class, '\\\" ')) : element;\\n    element = !equal(txt.x, '') ? string(abi.encodePacked(element, 'x=\\\"', txt.x, '\\\" ')) : element;\\n    element = !equal(txt.y, '') ? string(abi.encodePacked(element, 'y=\\\"', txt.y, '\\\" ')) : element;\\n    element = !equal(txt.dx, '') ? string(abi.encodePacked(element, 'dx=\\\"', txt.dx, '\\\" ')) : element;\\n    element = !equal(txt.dy, '') ? string(abi.encodePacked(element, 'dy=\\\"', txt.dy, '\\\" ')) : element;\\n    element = !equal(txt.display, '') ? string(abi.encodePacked(element, 'display=\\\"', txt.display, '\\\" ')) : element;\\n    element = !equal(txt.baseline, '') ? string(abi.encodePacked(element, 'dominant-baseline=\\\"', txt.baseline, '\\\" ')) : element;\\n    element = !equal(txt.anchor, '') ? string(abi.encodePacked(element, 'text-anchor=\\\"', txt.anchor, '\\\" ')) : element;\\n    element = !equal(txt.rotate, '') ? string(abi.encodePacked(element, 'rotate=\\\"', txt.rotate, '\\\" ')) : element;\\n    element = !equal(txt.transform, '') ? string(abi.encodePacked(element, 'transform=\\\"', txt.transform, '\\\" ')) : element;\\n    element = !equal(txt.clipPath, '') ? string(abi.encodePacked(element, 'clip-path=\\\"url(#', txt.clipPath, ')\\\" ')) : element;\\n    element = string(abi.encodePacked(element, '>', txt.val, '</text>'));\\n    return element;\\n  }\\n\\n  struct TextPath {\\n    string class;\\n    string href;\\n    string val;\\n  }\\n\\n  function getTextPath(TextPath memory txtPath) public pure returns (string memory) {\\n    string memory element = '<textPath ';\\n    element = !equal(txtPath.class, '') ? string(abi.encodePacked(element, 'class=\\\"', txtPath.class, '\\\" ')) : element;\\n    element = !equal(txtPath.class, '') ? string(abi.encodePacked(element, 'href=\\\"#', txtPath.href, '\\\" ')) : element;\\n    element = string(abi.encodePacked(element, '>', txtPath.val, '</textPath>'));\\n    return element;\\n  }\\n\\n  struct Tspan {\\n    string class;\\n    string display;\\n    string dx;\\n    string dy;\\n    string val;\\n  }\\n\\n  function getTspan(Tspan memory tspan) public pure returns (string memory) {\\n    string memory element = '<tspan ';\\n    element = !equal(tspan.class, '') ? string(abi.encodePacked(element, 'class=\\\"', tspan.class, '\\\" ')) : element;\\n    element = !equal(tspan.display, '') ? string(abi.encodePacked(element, 'display=\\\"', tspan.display, '\\\" ')) : element;\\n    element = !equal(tspan.dx, '') ? string(abi.encodePacked(element, 'dx=\\\"', tspan.dx, '\\\" ')) : element;\\n    element = !equal(tspan.dy, '') ? string(abi.encodePacked(element, 'dy=\\\"', tspan.dy, '\\\" ')) : element;\\n    element = string(abi.encodePacked(element, '>', tspan.val, '</tspan>'));\\n    return element;\\n  }\\n\\n  struct Animate {\\n    string attributeName;\\n    string to;\\n    string values;\\n    string duration;\\n    string begin;\\n    string repeatCount;\\n    string fill;\\n  }\\n\\n  function getAnimate(Animate memory animate) public pure returns (string memory) {\\n    string memory element = '<animate ';\\n    element = !equal(animate.attributeName, '') ? string(abi.encodePacked(element, 'attributeName=\\\"', animate.attributeName, '\\\" ')) : element;\\n    element = !equal(animate.to, '') ? string(abi.encodePacked(element, 'to=\\\"', animate.to, '\\\" ')) : element;\\n    element = !equal(animate.values, '') ? string(abi.encodePacked(element, 'values=\\\"', animate.values, '\\\" ')) : element;\\n    element = !equal(animate.duration, '') ? string(abi.encodePacked(element, 'dur=\\\"', animate.duration, 'ms\\\" ')) : element;\\n    element = !equal(animate.begin, '') ? string(abi.encodePacked(element, 'begin=\\\"', animate.begin, 'ms\\\" ')) : element;\\n    element = !equal(animate.repeatCount, '') ? string(abi.encodePacked(element, 'repeatCount=\\\"', animate.repeatCount, '\\\" ')) : element;\\n    element = !equal(animate.fill, '') ? string(abi.encodePacked(element, 'fill=\\\"', animate.fill, '\\\" ')) : element;\\n    element = string(abi.encodePacked(element, '/>'));\\n    return element;\\n  }\\n\\n  struct Path {\\n    string id;\\n    string pathAttr;\\n    string val;\\n  }\\n\\n  function getPath(Path memory path) public pure returns (string memory) {\\n    string memory element = '<path ';\\n    element = !equal(path.id, '') ? string(abi.encodePacked(element, 'id=\\\"', path.id, '\\\" ')) : element;\\n    element = !equal(path.pathAttr, '') ? string(abi.encodePacked(element, 'd=\\\"', path.pathAttr, '\\\" ')) : element;\\n    element = string(abi.encodePacked(element, '>', path.val, '</path>'));\\n    return element;\\n  }\\n\\n  struct Group {\\n    string transform;\\n    string val;\\n  }\\n\\n  function getGroup(Group memory group) public pure returns (string memory) {\\n    string memory element = '<g ';\\n    element = !equal(group.transform, '') ? string(abi.encodePacked(element, 'transform=\\\"', group.transform, '\\\" ')) : element;\\n    element = string(abi.encodePacked(element, '>', group.val, '</g>'));\\n    return element;\\n  }\\n\\n  struct Pattern {\\n    string id;\\n    string x;\\n    string y;\\n    string width;\\n    string height;\\n    string patternUnits;\\n    string val;\\n  }\\n\\n  function getPattern(Pattern memory pattern) public pure returns (string memory) {\\n    string memory element = '<pattern ';\\n    element = !equal(pattern.id, '') ? string(abi.encodePacked(element, 'id=\\\"', pattern.id, '\\\" ')) : element;\\n    element = !equal(pattern.x, '') ? string(abi.encodePacked(element, 'x=\\\"', pattern.x, '\\\" ')) : element;\\n    element = !equal(pattern.y, '') ? string(abi.encodePacked(element, 'y=\\\"', pattern.y, '\\\" ')) : element;\\n    element = !equal(pattern.width, '') ? string(abi.encodePacked(element, 'width=\\\"', pattern.width, '\\\" ')) : element;\\n    element = !equal(pattern.height, '') ? string(abi.encodePacked(element, 'height=\\\"', pattern.height, '\\\" ')) : element;\\n    element = !equal(pattern.patternUnits, '') ? string(abi.encodePacked(element, 'patternUnits=\\\"', pattern.patternUnits, '\\\" ')) : element;\\n    element = string(abi.encodePacked(element, '>', pattern.val, '</pattern>'));\\n    return element;\\n  }\\n\\n  struct Filter {\\n    string id;\\n    string val;\\n  }\\n\\n  function getFilter(Filter memory filter) public pure returns (string memory) {\\n    string memory element = '<filter ';\\n    element = !equal(filter.id, '') ? string(abi.encodePacked(element, 'id=\\\"', filter.id, '\\\" ')) : element;\\n    element = string(abi.encodePacked(element, '>', filter.val, '</filter>'));\\n    return element;\\n  }\\n\\n  struct Turbulance {\\n    string fType;\\n    string baseFrequency;\\n    string octaves;\\n    string result;\\n    string val;\\n  }\\n\\n  function getTurbulance(Turbulance memory turbulance) public pure returns (string memory) {\\n    string memory element = '<feTurbulence ';\\n    element = !equal(turbulance.fType, '') ? string(abi.encodePacked(element, 'type=\\\"', turbulance.fType, '\\\" ')) : element;\\n    element = !equal(turbulance.baseFrequency, '') ? string(abi.encodePacked(element, 'baseFrequency=\\\"', turbulance.baseFrequency, '\\\" ')) : element;\\n    element = !equal(turbulance.octaves, '') ? string(abi.encodePacked(element, 'numOctaves=\\\"', turbulance.octaves, '\\\" ')) : element;\\n    element = !equal(turbulance.result, '') ? string(abi.encodePacked(element, 'result=\\\"', turbulance.result, '\\\" ')) : element;\\n    element = string(abi.encodePacked(element, '>', turbulance.val, '</feTurbulence>'));\\n    return element;\\n  }\\n\\n  struct DisplacementMap {\\n    string mIn;\\n    string in2;\\n    string result;\\n    string scale;\\n    string xChannelSelector;\\n    string yChannelSelector;\\n    string val;\\n  }\\n\\n  function getDisplacementMap(DisplacementMap memory displacementMap) public pure returns (string memory) {\\n    string memory element = '<feDisplacementMap ';\\n    element = !equal(displacementMap.mIn, '') ? string(abi.encodePacked(element, 'in=\\\"', displacementMap.mIn, '\\\" ')) : element;\\n    element = !equal(displacementMap.in2, '') ? string(abi.encodePacked(element, 'in2=\\\"', displacementMap.in2, '\\\" ')) : element;\\n    element = !equal(displacementMap.result, '') ? string(abi.encodePacked(element, 'result=\\\"', displacementMap.result, '\\\" ')) : element;\\n    element = !equal(displacementMap.scale, '') ? string(abi.encodePacked(element, 'scale=\\\"', displacementMap.scale, '\\\" ')) : element;\\n    element = !equal(displacementMap.xChannelSelector, '') ? string(abi.encodePacked(element, 'xChannelSelector=\\\"', displacementMap.xChannelSelector, '\\\" ')) : element;\\n    element = !equal(displacementMap.yChannelSelector, '') ? string(abi.encodePacked(element, 'yChannelSelector=\\\"', displacementMap.yChannelSelector, '\\\" ')) : element;\\n    element = string(abi.encodePacked(element, '>', displacementMap.val, '</feDisplacementMap>'));\\n    return element;\\n  }\\n\\n  struct ClipPath {\\n    string id;\\n    string val;\\n  }\\n\\n  function getClipPath(ClipPath memory clipPath) public pure returns (string memory) {\\n    string memory element = '<clipPath ';\\n    element = !equal(clipPath.id, '') ? string(abi.encodePacked(element, 'id=\\\"', clipPath.id, '\\\" ')) : element;\\n    element = string(abi.encodePacked(element, ' >', clipPath.val, '</clipPath>'));\\n    return element;\\n  }\\n\\n  struct LinearGradient {\\n    string id;\\n    string[] colors;\\n    bool blockScheme;\\n    string animate;\\n  }\\n\\n  function getLinearGradient(LinearGradient memory linearGradient) public pure returns (string memory) {\\n    string memory element = '<linearGradient ';\\n    element = !equal(linearGradient.id, '') ? string(abi.encodePacked(element, 'id=\\\"', linearGradient.id, '\\\">')) : element;\\n    uint baseOffset = 100 / (linearGradient.colors.length - 1);\\n    for (uint i=0; i<linearGradient.colors.length; i++) {\\n      uint offset;\\n      if (i != linearGradient.colors.length - 1) {\\n        offset = baseOffset * i;\\n      } else {\\n        offset = 100;\\n      }\\n      if (linearGradient.blockScheme && i != 0) {\\n        element = string(abi.encodePacked(element, '<stop offset=\\\"', toString(offset), '%\\\"  stop-color=\\\"', linearGradient.colors[i-1], '\\\" />'));\\n      }\\n\\n      if (!linearGradient.blockScheme || (linearGradient.blockScheme && i != linearGradient.colors.length - 1)) {\\n        element = string(abi.encodePacked(element, '<stop offset=\\\"', toString(offset), '%\\\"  stop-color=\\\"', linearGradient.colors[i], '\\\" />'));\\n      }\\n    }\\n    element = !equal(linearGradient.animate, '') ? string(abi.encodePacked(element, linearGradient.animate)) : element;\\n    element =  string(abi.encodePacked(element, '</linearGradient>'));\\n    return element;\\n  }\\n\\n  struct RadialGradient {\\n    string id;\\n    string[] colors;\\n    bool blockScheme;\\n    string animate;\\n  }\\n\\n  function getRadialGradient(RadialGradient memory radialGradient) public pure returns (string memory) {\\n    string memory element = '<radialGradient ';\\n    element = !equal(radialGradient.id, '') ? string(abi.encodePacked(element, 'id=\\\"', radialGradient.id, '\\\">')) : element;\\n    uint baseOffset = 100 / (radialGradient.colors.length - 1);\\n    for (uint i=0; i<radialGradient.colors.length; i++) {\\n      uint offset;\\n      if (i != radialGradient.colors.length - 1) {\\n        offset = baseOffset * i;\\n      } else {\\n        offset = 100;\\n      }\\n      if (radialGradient.blockScheme && i != 0) {\\n        element = string(abi.encodePacked(element, '<stop offset=\\\"', toString(offset), '%\\\"  stop-color=\\\"', radialGradient.colors[i-1], '\\\" />'));\\n      }\\n\\n      if (!radialGradient.blockScheme || (radialGradient.blockScheme && i != radialGradient.colors.length - 1)) {\\n        element = string(abi.encodePacked(element, '<stop offset=\\\"', toString(offset), '%\\\"  stop-color=\\\"', radialGradient.colors[i], '\\\" />'));\\n      }\\n    }\\n    element = !equal(radialGradient.animate, '') ? string(abi.encodePacked(element, radialGradient.animate)) : element;\\n    element =  string(abi.encodePacked(element, '</radialGradient>'));\\n    return element;\\n  }\\n\\n  function equal(string memory a, string memory b) private pure returns (bool) {\\n    return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\\n  }\\n\\n  function toString(uint256 value) private pure returns (string memory) {\\n    // Inspired by OraclizeAPI's implementation - MIT license\\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n    if (value == 0) {\\n        return \\\"0\\\";\\n    }\\n    uint256 temp = value;\\n    uint256 digits;\\n    while (temp != 0) {\\n        digits++;\\n        temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n        digits -= 1;\\n        buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n        value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n}\"\r\n    },\r\n    \"contracts/common/SvgFilter.sol\": {\r\n      \"content\": \"//\\tSPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport './SvgElement.sol';\\nimport './LogoHelper.sol';\\n\\nlibrary SvgFilter {\\n\\n  struct Filter {\\n    string id;\\n    string filterType;\\n    string scale;\\n    bool animate;\\n  }\\n\\n  function getFilterDef(string memory seed, Filter memory filter) public pure returns (string memory) {\\n    string memory defs = '';\\n    string memory turbulance;\\n    string memory animateTurbulance;\\n    if (LogoHelper.equal(filter.scale, '50')) {\\n      turbulance = LogoHelper.getTurbulance(seed, 10000, 100000);\\n      if (filter.animate) {\\n        animateTurbulance = string(abi.encodePacked(turbulance, '; ', LogoHelper.getTurbulance(filter.id, 10000, 100000), '; ', turbulance, '; '));\\n      }\\n    }\\n\\n    if (filter.animate) {\\n      string memory element = SvgElement.getAnimate(SvgElement.Animate('baseFrequency', '', animateTurbulance, LogoHelper.toString(LogoHelper.randomInRange(seed, 100000, 100)), '0', 'indefinite', ''));\\n      element = SvgElement.getTurbulance(SvgElement.Turbulance('fractalNoise', turbulance, '5', 'r1', element));\\n      element = string(abi.encodePacked(element, SvgElement.getDisplacementMap(SvgElement.DisplacementMap('SourceGraphic', 'r1', 'r2', filter.scale, 'R', 'G', ''))));\\n      defs = string(abi.encodePacked(defs, SvgElement.getFilter(SvgElement.Filter(filter.id, element))));\\n    } else {\\n      string memory element = SvgElement.getTurbulance(SvgElement.Turbulance('fractalNoise', turbulance, '5', 'r1', ''));\\n      element = string(abi.encodePacked(element, SvgElement.getDisplacementMap(SvgElement.DisplacementMap('SourceGraphic', 'r1', 'r2', filter.scale, 'R', 'G', ''))));\\n      defs = string(abi.encodePacked(defs, SvgElement.getFilter(SvgElement.Filter(filter.id, element))));\\n    }\\n    return defs;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/background/SvgPattern.sol\": {\r\n      \"content\": \"//\\tSPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '../common/SvgElement.sol';\\nimport '../common/LogoHelper.sol';\\nimport '../common/InlineSvgElement.sol';\\n\\nlibrary SvgPattern {\\n  function getADef(string memory seed, string memory backgroundId, string memory fillType, string memory fillZeroClass) public pure returns (string memory) {\\n    uint patternSize = randomInRange(string(abi.encodePacked(seed, 'a')), 140, 10);\\n    // pattern should end in frame\\n    for (uint i = 0; i < 150; i++) {\\n      if (300 % (patternSize + i) == 0) {\\n        patternSize = patternSize + i;\\n        break;\\n      } \\n    }\\n    uint squareSize = randomInRange(string(abi.encodePacked(seed, 'b')), LogoHelper.equal(fillType, 'Solid') ? patternSize - (patternSize / 6) : patternSize + (patternSize / 2), patternSize / 6);\\n    string memory element = SvgElement.getRect(SvgElement.Rect(fillZeroClass, '0', '0', LogoHelper.toString(squareSize), LogoHelper.toString(squareSize), '', '', ''));\\n    return SvgElement.getPattern(SvgElement.Pattern(backgroundId, '0', '0', LogoHelper.toString(patternSize), LogoHelper.toString(patternSize), 'userSpaceOnUse', element));\\n  }\\n\\n  function getBDef(string memory seed, string memory backgroundId, string memory fillZeroClass) public pure returns (string memory) {\\n    uint patternSize = randomInRange(string(abi.encodePacked(seed, 'a')), 200, 10);\\n    for (uint i = 0; i < 150; i++) {\\n      if (300 % (patternSize + i) == 0) {\\n        patternSize = patternSize + i;\\n        break;\\n      }  \\n    }\\n    uint circleRadius = randomInRange(string(abi.encodePacked(seed, 'b')), patternSize - (patternSize / 4), patternSize / 12);\\n    string memory center = LogoHelper.toString(randomInRange(string(abi.encodePacked(seed, 'c')), patternSize, patternSize / 4));\\n    string memory element = SvgElement.getCircle(SvgElement.Circle(fillZeroClass, center, center, LogoHelper.toString(circleRadius), ''));\\n    return SvgElement.getPattern(SvgElement.Pattern(backgroundId, '0', '0', LogoHelper.toString(patternSize), LogoHelper.toString(patternSize), 'userSpaceOnUse', element));\\n  }\\n  \\n  function getAX2Def(string memory seed, string memory backgroundId, string memory fillZeroClass, string memory fillType, string memory fillOneClass) public pure returns (string memory) {\\n    uint patternSize = randomInRange(string(abi.encodePacked(seed, 'a')), 200, 2);\\n    for (uint i = 0; i < 150; i++) {\\n      if (300 % (patternSize + i) == 0) {\\n        patternSize = patternSize + i;\\n        break;\\n      } \\n    }\\n    uint squareSize1 = randomInRange(string(abi.encodePacked(seed, 'b')), LogoHelper.equal(fillType, 'Solid') ? patternSize : patternSize + (patternSize / 2), patternSize / 6);\\n    uint squareSize2 = randomInRange(string(abi.encodePacked(seed, 'c')), LogoHelper.equal(fillType, 'Solid') ? patternSize : patternSize + (patternSize / 2), patternSize / 6);\\n\\n    uint offset = randomInRange(string(abi.encodePacked(seed, 'd')), patternSize - (squareSize2 / 2) , 0);\\n    string memory opactiy = LogoHelper.decimalInRange(seed, 8, 10);\\n    string memory element = SvgElement.getRect(SvgElement.Rect(fillZeroClass, '0', '0', LogoHelper.toString(squareSize1), LogoHelper.toString(squareSize1), '', '', ''));\\n    element = string(abi.encodePacked(element, SvgElement.getRect(SvgElement.Rect(fillOneClass, LogoHelper.toString(offset), LogoHelper.toString(offset), LogoHelper.toString(squareSize2), LogoHelper.toString(squareSize2), opactiy, '', ''))));\\n    return SvgElement.getPattern(SvgElement.Pattern(backgroundId, '0', '0', LogoHelper.toString(patternSize), LogoHelper.toString(patternSize), 'userSpaceOnUse', element));\\n  }\\n\\n  function getBX2Def(string memory seed, string memory backgroundId, string memory fillZeroClass, string memory fillOneClass) public pure returns (string memory) {\\n    uint patternSize = randomInRange(string(abi.encodePacked(seed, 'a')), 200, 20);\\n    for (uint i = 0; i < 150; i++) {\\n      if (300 % (patternSize + i) == 0) {\\n        patternSize = patternSize + i;\\n        break;\\n      } \\n    }\\n    uint circleRadius = randomInRange(string(abi.encodePacked(seed, 'b')), patternSize - (patternSize / 4), patternSize / 6);\\n\\n    string memory center = LogoHelper.toString(randomInRange(string(abi.encodePacked(seed, 'c')), patternSize, patternSize / 4));\\n    string memory element = SvgElement.getCircle(SvgElement.Circle(fillZeroClass, center, center, LogoHelper.toString(circleRadius), ''));\\n\\n    circleRadius = randomInRange(string(abi.encodePacked(seed, 'e')), patternSize, patternSize / 6);\\n    center = LogoHelper.toString(randomInRange(string(abi.encodePacked(seed, 'f')), patternSize, patternSize / 4));\\n    string memory opactiy = LogoHelper.decimalInRange(seed, 8, 10);\\n    element = string(abi.encodePacked(element, SvgElement.getCircle(SvgElement.Circle(fillOneClass, center, center, LogoHelper.toString(circleRadius), opactiy))));\\n    return SvgElement.getPattern(SvgElement.Pattern(backgroundId, '0', '0', LogoHelper.toString(patternSize), LogoHelper.toString(patternSize), 'userSpaceOnUse', element));\\n  }\\n\\n  function getABDef(string memory seed, string memory backgroundId, string memory fillType, string memory fillZeroClass, string memory fillOneClass) public pure returns (string memory) {\\n    uint patternSize = randomInRange(string(abi.encodePacked(seed, 'a')), 200, 20);\\n    for (uint i = 0; i < 150; i++) {\\n      if ((patternSize + i) % 300 == 0) {\\n        patternSize = patternSize + i;\\n        break;\\n      } \\n    }\\n    uint squareSize1 = randomInRange(string(abi.encodePacked(seed, 'b')), LogoHelper.equal(fillType, 'Solid') ? patternSize : patternSize + (patternSize / 2), patternSize / 6);\\n    string memory element = SvgElement.getRect(SvgElement.Rect(fillZeroClass, '0', '0', LogoHelper.toString(squareSize1), LogoHelper.toString(squareSize1), '', '', ''));\\n\\n    uint circleRadius = randomInRange(string(abi.encodePacked(seed, 'b')), patternSize - (patternSize / 4), patternSize / 6);\\n    string memory center = LogoHelper.toString(randomInRange(string(abi.encodePacked(seed, 'c')), patternSize, patternSize / 4));\\n    element = string(abi.encodePacked(element, SvgElement.getCircle(SvgElement.Circle(fillOneClass, center, center, LogoHelper.toString(circleRadius), ''))));\\n    return SvgElement.getPattern(SvgElement.Pattern(backgroundId, '0', '0', LogoHelper.toString(patternSize), LogoHelper.toString(patternSize), 'userSpaceOnUse', element));\\n  }\\n\\n  function getGMDef(string memory seed, string memory backgroundId, string memory fillZeroClass, string memory fillOneClass, string memory fillTwoClass, string memory fillThreeClass) public pure returns (string memory) {\\n    // sky\\n    uint patternSizeX = randomInRange(string(abi.encodePacked(seed, 'a')), 300, 6);\\n    uint patternSizeY = randomInRange(string(abi.encodePacked(seed, 'b')), 300, 6);\\n    uint squareSize2 = randomInRange(seed, patternSizeX / 2, patternSizeX / 6);\\n\\n    uint offset = randomInRange(seed, patternSizeX - (squareSize2 / 2) , 0);\\n\\n    string memory element = SvgElement.getRect(SvgElement.Rect(fillZeroClass, '0', '0', LogoHelper.toString(patternSizeX), LogoHelper.toString(patternSizeX), '', '', ''));\\n    element = string(abi.encodePacked(element, SvgElement.getRect(SvgElement.Rect(fillOneClass, LogoHelper.toString(offset), LogoHelper.toString(offset), LogoHelper.toString(squareSize2), LogoHelper.toString(squareSize2), '0.8', '', ''))));\\n    SvgElement.Pattern memory pattern = SvgElement.Pattern(string(abi.encodePacked(backgroundId, '-1')), '0', '0', LogoHelper.toString(patternSizeX), LogoHelper.toString(patternSizeY), 'userSpaceOnUse', element);\\n    string memory defs = SvgElement.getPattern(pattern);\\n\\n    // ocean\\n    patternSizeX = 300;\\n    patternSizeY = randomInRange(string(abi.encodePacked(seed, 'c')), 30, 0);\\n    squareSize2 = randomInRange(seed, patternSizeX, patternSizeX / 4);\\n    offset = 230 - (squareSize2 / 2);\\n    backgroundId = string(abi.encodePacked(backgroundId, '-2'));\\n\\n    element = SvgElement.getRect(SvgElement.Rect(fillTwoClass, '0', '0', LogoHelper.toString(patternSizeX), LogoHelper.toString(squareSize2), '', '', ''));\\n    // element = string(abi.encodePacked(element, SvgElement.getRect(SvgElement.Rect(fillThreeClass, LogoHelper.toString(offset), '5', LogoHelper.toString(squareSize2), '10', '0.8', '', ''))));\\n    element = string(abi.encodePacked(element, SvgElement.getRect(SvgElement.Rect(fillThreeClass, LogoHelper.toString(offset), LogoHelper.toString(patternSizeY), LogoHelper.toString(squareSize2), LogoHelper.toString(patternSizeY), '0.8', '', ''))));\\n    patternSizeY = randomInRange(string(abi.encodePacked(seed, 'd')), 100, 0);\\n    pattern = SvgElement.Pattern(backgroundId, '0', '0', LogoHelper.toString(patternSizeX), LogoHelper.toString(patternSizeY), 'userSpaceOnUse', element);\\n    return string(abi.encodePacked(defs, SvgElement.getPattern(pattern)));\\n  }\\n\\n  function randomInRange(string memory input, uint max, uint offset) public pure returns (uint256) {\\n    max = max - offset;\\n    return (random(input) % max) + offset;\\n  }\\n\\n  function random(string memory input) public pure returns (uint256) {\\n    return uint256(keccak256(abi.encodePacked(input)));\\n  }\\n}\"\r\n    },\r\n    \"contracts/common/InlineSvgElement.sol\": {\r\n      \"content\": \"//\\tSPDX-License-Identifier: MIT\\n/// @notice A helper to create svg elements\\npragma solidity ^0.8.0;\\n\\n\\nlibrary InlineSvgElement {\\n  function getTspanBytes1(\\n      string memory class,\\n      string memory display, \\n      string memory dx, \\n      string memory dy, \\n      bytes1 val)\\n      public pure \\n      returns (string memory) {\\n    return string(abi.encodePacked('<tspan class=\\\"', class, '\\\" display=\\\"', display, '\\\" dx=\\\"', dx, '\\\" dy=\\\"', dy, '\\\" >', val));\\n  }\\n\\n  function getAnimate(\\n      string memory attributeName,\\n      string memory values,\\n      string memory duration,\\n      string memory begin,\\n      string memory repeatCount,\\n      string memory fill) \\n      public pure \\n      returns (string memory) {\\n    return string(abi.encodePacked('<animate attributeName=\\\"', attributeName, '\\\" values=\\\"', values, '\\\" dur=\\\"', duration, 'ms\\\" begin=\\\"', begin, 'ms\\\" repeatCount=\\\"', repeatCount, '\\\"  fill=\\\"', fill, '\\\" />'));\\n  }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/common/LogoHelper.sol\": {\r\n        \"LogoHelper\": \"0xe4e64b52d86ba86c5553b0e9972cd30b509a40d9\"\r\n      },\r\n      \"contracts/common/LogoType.sol\": {\r\n        \"LogoType\": \"0xbcb68257a78950237a3930850f52b314cf0942ca\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"backgroundColors\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"emoticonColors\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"textColors\",\"type\":\"string[]\"}],\"internalType\":\"struct Color.Palette\",\"name\":\"palette\",\"type\":\"tuple\"}],\"name\":\"getBackground\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"backgroundType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"paletteName\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"width\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"height\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillType\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"colors\",\"type\":\"string[]\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgFill.Fill[]\",\"name\":\"fills\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"filterType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"scale\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgFilter.Filter\",\"name\":\"filter\",\"type\":\"tuple\"}],\"internalType\":\"struct SvgBackground.Background\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"txtVal\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct SvgText.Font\",\"name\":\"font\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"backgroundColors\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"emoticonColors\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"textColors\",\"type\":\"string[]\"}],\"internalType\":\"struct Color.Palette\",\"name\":\"palette\",\"type\":\"tuple\"}],\"name\":\"getEmoticon\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"emoticonType\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"textType\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct SvgText.Font\",\"name\":\"font\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"paletteName\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillType\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"colors\",\"type\":\"string[]\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgFill.Fill[]\",\"name\":\"fills\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgText.Text\",\"name\":\"text\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"paletteName\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillType\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"colors\",\"type\":\"string[]\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgFill.Fill[]\",\"name\":\"fills\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgEmoticonBuilder.Emoticon\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"classes\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"palette\",\"type\":\"string[]\"},{\"internalType\":\"string\",\"name\":\"fillTypeOverride\",\"type\":\"string\"}],\"name\":\"getFills\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillType\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"colors\",\"type\":\"string[]\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgFill.Fill[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"getFilter\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"filterType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"scale\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgFilter.Filter\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"getIdOrClass\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"textType\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct SvgText.Font\",\"name\":\"font\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"backgroundColors\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"emoticonColors\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"textColors\",\"type\":\"string[]\"}],\"internalType\":\"struct Color.Palette\",\"name\":\"palette\",\"type\":\"tuple\"}],\"name\":\"getText\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"textType\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct SvgText.Font\",\"name\":\"font\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"paletteName\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillType\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"colors\",\"type\":\"string[]\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgFill.Fill[]\",\"name\":\"fills\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgText.Text\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"initBackground\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"backgroundType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"paletteName\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"width\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"height\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillType\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"colors\",\"type\":\"string[]\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgFill.Fill[]\",\"name\":\"fills\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"filterType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"scale\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgFilter.Filter\",\"name\":\"filter\",\"type\":\"tuple\"}],\"internalType\":\"struct SvgBackground.Background\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct SvgText.Font\",\"name\":\"font\",\"type\":\"tuple\"}],\"name\":\"initEmoticon\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"emoticonType\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"textType\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct SvgText.Font\",\"name\":\"font\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"paletteName\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillType\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"colors\",\"type\":\"string[]\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgFill.Fill[]\",\"name\":\"fills\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgText.Text\",\"name\":\"text\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"paletteName\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillType\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"colors\",\"type\":\"string[]\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgFill.Fill[]\",\"name\":\"fills\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgEmoticonBuilder.Emoticon\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct SvgText.Font\",\"name\":\"font\",\"type\":\"tuple\"}],\"name\":\"initText\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"textType\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct SvgText.Font\",\"name\":\"font\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"paletteName\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillType\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"colors\",\"type\":\"string[]\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgFill.Fill[]\",\"name\":\"fills\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"animate\",\"type\":\"bool\"}],\"internalType\":\"struct SvgText.Text\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LogoFactory", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}