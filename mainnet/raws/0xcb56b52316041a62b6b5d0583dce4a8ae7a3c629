{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// SYS 64738\r\n// Version 2.0\r\n// Author: 0xTycoon\r\n// Contributor: Alphasoup <twitter: alphasoups>\r\n// Special Thanks: straybits1, cryptopunkart, cyounessi1, ethereumdegen, Punk7572, sherone.eth,\r\n//                 songadaymann, Redlioneye.eth, tw1tte7, PabloPunkasso, Kaprekar_Punk, aradtski,\r\n//                 phantom_scribbs, Cryptopapa.eth, johnhenderson, thekriskay, PerfectoidPeter,\r\n//                 uxt_exe, 0xUnicorn, dansickles.eth, Blon Dee#9649, VRPunk1, Don Seven Slices, hogo.eth,\r\n//                 GeoCities#5700, \"HP OfficeJet Pro 9015e #2676\", gigiuz#0061, danpolko.eth, mariano.eth,\r\n//                 0xfoobar, jakerockland, Mudit__Gupta, BokkyPooBah, 0xaaby.eth, and\r\n//                 everyone at the discord, and all the awesome people who gave feedback for this project!\r\n// Greetings to:   Punk3395, foxthepunk, bushleaf.eth, 570Kyl\u039e.eth, bushleaf.eth, Tokyolife, Joshuad.eth (1641),\r\n//                 markchesler_coinwitch, decideus.eth, zachologylol, punk8886, jony_bee, nfttank, DolAtoR, punk8886\r\n//                 DonJon.eth, kilifibaobab, joked507, cryptoed#3040, DroScott#7162, 0xAllen.eth, Tschuuuly#5158,\r\n//                 MetasNomadic#0349, punk8653, NittyB, heygareth.eth, Aaru.eth, robertclarke.eth, Acmonides#6299,\r\n//                 Gustavus99 (1871), Foobazzler\r\n// Repo: github.com/0xTycoon/punksceo\r\n\r\npragma solidity ^0.8.11;\r\n\r\n//import \"./safemath.sol\"; // don't need since v0.8\r\n//import \"./ceo.sol\";\r\n//import \"hardhat/console.sol\";\r\n/*\r\n\r\nPUNKS CEO (and \"Cigarette\" token)\r\nWEB: https://punksceo.eth.limo / https://punksceo.eth.link\r\nIPFS: See content hash record for punksceo.eth\r\nToken Address: cigtoken.eth\r\n\r\n         , - ~ ~ ~ - ,\r\n     , '               ' ,\r\n   ,                    \ud83d\udeac  ,\r\n  ,                     \ud83d\udeac   ,\r\n ,                      \ud83d\udeac    ,\r\n ,                      \ud83d\udeac    ,\r\n ,         =============     ,\r\n  ,                   ||\u2588   ,\r\n   ,       =============   ,\r\n     ,                  , '\r\n       ' - , _ _ _ ,  '\r\n\r\n\r\n### THE RULES OF THE GAME\r\n\r\n1. Anybody can buy the CEO title at any time using Cigarettes. (The CEO of all cryptopunks)\r\n2. When buying the CEO title, you must nominate a punk, set the price and pre-pay the tax.\r\n3. The CEO title can be bought from the existing CEO at any time.\r\n4. To remain a CEO, a daily tax needs to be paid.\r\n5. The tax is 0.1% of the price to buy the CEO title, to be charged per epoch.\r\n6. The CEO can be removed if they fail to pay the tax. A reward of CIGs is paid to the whistleblower.\r\n7. After Removing a CEO: A dutch auction is held, where the price will decrease 10% every half-an-epoch.\r\n8. The price can be changed by the CEO at any time. (Once per block)\r\n9. An epoch is 7200 blocks.\r\n10. All the Cigarettes from the sale are burned.\r\n11. All tax is burned\r\n12. After buying the CEO title, the old CEO will get their unspent tax deposit refunded\r\n\r\n### CEO perk\r\n\r\n13. The CEO can increase or decrease the CIG farming block reward by 20% every 2nd epoch!\r\nHowever, note that the issuance can never be more than 1000 CIG per block, also never under 0.0001 CIG.\r\n14. THE CEO gets to hold a NFT in their wallet. There will only be ever 1 this NFT.\r\nThe purpose of this NFT is so that everyone can see that they are the CEO.\r\nIMPORTANT: This NFT will be revoked once the CEO title changes.\r\nAlso, the NFT cannot be transferred by the owner, the only way to transfer is for someone else to buy the CEO title! (Think of this NFT as similar to a \"title belt\" in boxing.)\r\n\r\nEND\r\n\r\n* states\r\n* 0 = initial\r\n* 1 = CEO reigning\r\n* 2 = Dutch auction\r\n* 3 = Migration\r\n\r\nNotes:\r\nIt was decided that whoever buys the CEO title does not have to hold a punk and can nominate any punk they wish.\r\nThis is because some may hold their punks in cold storage, plus checking ownership costs additional gas.\r\nBesides, CEOs are usually appointed by the board.\r\n\r\nCredits:\r\n- LP Staking based on code from SushiSwap's MasterChef.sol\r\n- ERC20 & SafeMath based on lib from OpenZeppelin\r\n\r\n*/\r\n\r\ncontract Cig {\r\n    //using SafeMath for uint256; // no need since Solidity 0.8\r\n    string public constant name = \"Cigarette Token\";\r\n    string public constant symbol = \"CIG\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public totalSupply = 0;\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    // UserInfo keeps track of user LP deposits and withdrawals\r\n    struct UserInfo {\r\n        uint256 deposit;    // How many LP tokens the user has deposited.\r\n        uint256 rewardDebt; // keeps track of how much reward was paid out\r\n    }\r\n    mapping(address => UserInfo) public farmers;  // keeps track of UserInfo for each staking address with own pool\r\n    mapping(address => UserInfo) public farmersMasterchef;  // keeps track of UserInfo for each staking address with masterchef pool\r\n    mapping(address => uint256) public wBal;      // keeps tracked of wrapped old cig\r\n    address public admin;                         // admin is used for deployment, burned after\r\n    ILiquidityPoolERC20 public lpToken;           // lpToken is the address of LP token contract that's being staked.\r\n    uint256 public lastRewardBlock;               // Last block number that cigarettes distribution occurs.\r\n    uint256 public accCigPerShare;                // Accumulated cigarettes per share, times 1e12. See below.\r\n    uint256 public masterchefDeposits;            // How much has been deposited onto the masterchef contract\r\n    uint256 public cigPerBlock;                   // CIGs per-block rewarded and split with LPs\r\n    bytes32 public graffiti;                      // a 32 character graffiti set when buying a CEO\r\n    ICryptoPunk public punks;                     // a reference to the CryptoPunks contract\r\n    event Deposit(address indexed user, uint256 amount);           // when depositing LP tokens to stake\r\n    event Harvest(address indexed user, address to, uint256 amount);// when withdrawing LP tokens form staking\r\n    event Withdraw(address indexed user, uint256 amount); // when withdrawing LP tokens, no rewards claimed\r\n    event EmergencyWithdraw(address indexed user, uint256 amount); // when withdrawing LP tokens, no rewards claimed\r\n    event ChefDeposit(address indexed user, uint256 amount);       // when depositing LP tokens to stake\r\n    event ChefWithdraw(address indexed user, uint256 amount);      // when withdrawing LP tokens, no rewards claimed\r\n    event RewardUp(uint256 reward, uint256 upAmount);              // when cigPerBlock is increased\r\n    event RewardDown(uint256 reward, uint256 downAmount);          // when cigPerBlock is decreased\r\n    event Claim(address indexed owner, uint indexed punkIndex, uint256 value); // when a punk is claimed\r\n    mapping(uint => bool) public claims;                           // keep track of claimed punks\r\n    modifier onlyAdmin {\r\n        require(\r\n            msg.sender == admin,\r\n            \"Only admin can call this\"\r\n        );\r\n        _;\r\n    }\r\n    uint256 constant MIN_PRICE = 1e12;            // 0.000001 CIG\r\n    uint256 constant CLAIM_AMOUNT = 100000 ether; // claim amount for each punk\r\n    uint256 constant MIN_REWARD = 1e14;           // minimum block reward of 0.0001 CIG (1e14 wei)\r\n    uint256 constant MAX_REWARD = 1000 ether;     // maximum block reward of 1000 CIG\r\n    uint256 constant STARTING_REWARDS = 512 ether;// starting rewards at end of migration\r\n    address public The_CEO;                       // address of CEO\r\n    uint public CEO_punk_index;                   // which punk id the CEO is using\r\n    uint256 public CEO_price = 50000 ether;       // price to buy the CEO title\r\n    uint256 public CEO_state;                     // state has 3 states, described above.\r\n    uint256 public CEO_tax_balance;               // deposit to be used to pay the CEO tax\r\n    uint256 public taxBurnBlock;                  // The last block when the tax was burned\r\n    uint256 public rewardsChangedBlock;           // which block was the last reward increase / decrease\r\n    uint256 private immutable CEO_epoch_blocks;   // secs per day divided by 12 (86400 / 12), assuming 12 sec blocks\r\n    uint256 private immutable CEO_auction_blocks; // 3600 blocks\r\n    // NewCEO 0x09b306c6ea47db16bdf4cc36f3ea2479af494cd04b4361b6485d70f088658b7e\r\n    event NewCEO(address indexed user, uint indexed punk_id, uint256 new_price, bytes32 graffiti); // when a CEO is bought\r\n    // TaxDeposit 0x2ab3b3b53aa29a0599c58f343221e29a032103d015c988fae9a5cdfa5c005d9d\r\n    event TaxDeposit(address indexed user,  uint256 amount);                               // when tax is deposited\r\n    // RevenueBurned 0x1b1be00a9ca19f9c14f1ca5d16e4aba7d4dd173c2263d4d8a03484e1c652c898\r\n    event RevenueBurned(address indexed user,  uint256 amount);                            // when tax is burned\r\n    // TaxBurned 0x9ad3c710e1cc4e96240264e5d3cd5aeaa93fd8bd6ee4b11bc9be7a5036a80585\r\n    event TaxBurned(address indexed user,  uint256 amount);                                // when tax is burned\r\n    // CEODefaulted b69f2aeff650d440d3e7385aedf764195cfca9509e33b69e69f8c77cab1e1af1\r\n    event CEODefaulted(address indexed called_by,  uint256 reward);                        // when CEO defaulted on tax\r\n    // CEOPriceChange 0x10c342a321267613a25f77d4273d7f2688bef174a7214bc3dde44b31c5064ff6\r\n    event CEOPriceChange(uint256 price);                                                   // when CEO changed price\r\n    modifier onlyCEO {\r\n        require(\r\n            msg.sender == The_CEO,\r\n            \"only CEO can call this\"\r\n        );\r\n        _;\r\n    }\r\n    IRouterV2 private immutable V2ROUTER;    // address of router used to get the price quote\r\n    ICEOERC721 private immutable The_NFT;    // reference to the CEO NFT token\r\n    address private immutable MASTERCHEF_V2; // address pointing to SushiSwap's MasterChefv2 contract\r\n    IOldCigtoken private immutable OC;       // Old Contract\r\n    /**\r\n    * @dev constructor\r\n    * @param _cigPerBlock Number of CIG tokens rewarded per block\r\n    * @param _punks address of the cryptopunks contract\r\n    * @param _CEO_epoch_blocks how many blocks between each epochs\r\n    * @param _CEO_auction_blocks how many blocks between each auction discount\r\n    * @param _CEO_price starting price to become CEO (in CIG)\r\n    * @param _graffiti bytes32 initial graffiti message\r\n    * @param _NFT address pointing to the NFT contract\r\n    * @param _V2ROUTER address pointing to the SushiSwap router\r\n    * @param _OC address pointing to the original Cig Token contract\r\n    * @param _MASTERCHEF_V2 address for the sushi masterchef v2 contract\r\n    */\r\n    constructor(\r\n        uint256 _cigPerBlock,\r\n        address _punks,\r\n        uint _CEO_epoch_blocks,\r\n        uint _CEO_auction_blocks,\r\n        uint256 _CEO_price,\r\n        bytes32 _graffiti,\r\n        address _NFT,\r\n        address _V2ROUTER,\r\n        address _OC,\r\n        uint256 _migration_epochs,\r\n        address _MASTERCHEF_V2\r\n    ) {\r\n        cigPerBlock        = _cigPerBlock;\r\n        admin              = msg.sender;             // the admin key will be burned after deployment\r\n        punks              = ICryptoPunk(_punks);\r\n        CEO_epoch_blocks   = _CEO_epoch_blocks;\r\n        CEO_auction_blocks = _CEO_auction_blocks;\r\n        CEO_price          = _CEO_price;\r\n        graffiti           = _graffiti;\r\n        The_NFT            = ICEOERC721(_NFT);\r\n        V2ROUTER           = IRouterV2(_V2ROUTER);\r\n        OC                 = IOldCigtoken(_OC);\r\n        lastRewardBlock =\r\n            block.number + (CEO_epoch_blocks * _migration_epochs); // set the migration window end\r\n        MASTERCHEF_V2 = _MASTERCHEF_V2;\r\n        CEO_state = 3;                               // begin in migration state\r\n    }\r\n\r\n    /**\r\n    * @dev buyCEO allows anybody to be the CEO\r\n    * @param _max_spend the total CIG that can be spent\r\n    * @param _new_price the new price for the punk (in CIG)\r\n    * @param _tax_amount how much to pay in advance (in CIG)\r\n    * @param _punk_index the id of the punk 0-9999\r\n    * @param _graffiti a little message / ad from the buyer\r\n    */\r\n    function buyCEO(\r\n        uint256 _max_spend,\r\n        uint256 _new_price,\r\n        uint256 _tax_amount,\r\n        uint256 _punk_index,\r\n        bytes32 _graffiti\r\n    ) external  {\r\n        require (CEO_state != 3); // disabled in in migration state\r\n        if (CEO_state == 1 && (taxBurnBlock != block.number)) {\r\n            _burnTax();                                                    // _burnTax can change CEO_state to 2\r\n        }\r\n        if (CEO_state == 2) {\r\n            // Auction state. The price goes down 10% every `CEO_auction_blocks` blocks\r\n            CEO_price = _calcDiscount();\r\n        }\r\n        require (CEO_price + _tax_amount <= _max_spend, \"overpaid\");       // prevent CEO over-payment\r\n        require (_new_price >= MIN_PRICE, \"price 2 smol\");                 // price cannot be under 0.000001 CIG\r\n        require (_punk_index <= 9999, \"invalid punk\");                     // validate the punk index\r\n        require (_tax_amount >= _new_price / 1000, \"insufficient tax\" );   // at least %0.1 fee paid for 1 epoch\r\n        transfer(address(this), CEO_price);                                // pay for the CEO title\r\n        _burn(address(this), CEO_price);                                   // burn the revenue\r\n        emit RevenueBurned(msg.sender, CEO_price);\r\n        _returnDeposit(The_CEO, CEO_tax_balance);                          // return deposited tax back to old CEO\r\n        transfer(address(this), _tax_amount);                              // deposit tax (reverts if not enough)\r\n        CEO_tax_balance = _tax_amount;                                     // store the tax deposit amount\r\n        _transferNFT(The_CEO, msg.sender);                                 // yank the NFT to the new CEO\r\n        CEO_price = _new_price;                                            // set the new price\r\n        CEO_punk_index = _punk_index;                                      // store the punk id\r\n        The_CEO = msg.sender;                                              // store the CEO's address\r\n        taxBurnBlock = block.number;                                       // store the block number\r\n        // (tax may not have been burned if the\r\n        // previous state was 0)\r\n        CEO_state = 1;\r\n        graffiti = _graffiti;\r\n        emit TaxDeposit(msg.sender, _tax_amount);\r\n        emit NewCEO(msg.sender, _punk_index, _new_price, _graffiti);\r\n    }\r\n\r\n    /**\r\n    * @dev _returnDeposit returns the tax deposit back to the CEO\r\n    * @param _to address The address which you want to transfer to\r\n    * remember to update CEO_tax_balance after calling this\r\n    */\r\n    function _returnDeposit(\r\n        address _to,\r\n        uint256 _amount\r\n    )\r\n    internal\r\n    {\r\n        if (_amount == 0) {\r\n            return;\r\n        }\r\n        balanceOf[address(this)] = balanceOf[address(this)] - _amount;\r\n        balanceOf[_to] = balanceOf[_to] + _amount;\r\n        emit Transfer(address(this), _to, _amount);\r\n        //CEO_tax_balance = 0; // can be omitted since value gets overwritten by caller\r\n    }\r\n\r\n    /**\r\n    * @dev transfer the NFT to a new wallet\r\n    */\r\n    function _transferNFT(address _oldCEO, address _newCEO) internal {\r\n        The_NFT.transferFrom(_oldCEO, _newCEO, 0);\r\n    }\r\n\r\n    /**\r\n    * @dev depositTax pre-pays tax for the existing CEO.\r\n    * It may also burn any tax debt the CEO may have.\r\n    * @param _amount amount of tax to pre-pay\r\n    */\r\n    function depositTax(uint256 _amount) external onlyCEO {\r\n        require (CEO_state == 1, \"no CEO\");\r\n        if (_amount > 0) {\r\n            transfer(address(this), _amount);                   // place the tax on deposit\r\n            CEO_tax_balance = CEO_tax_balance + _amount;        // record the balance\r\n            emit TaxDeposit(msg.sender, _amount);\r\n        }\r\n        if (taxBurnBlock != block.number) {\r\n            _burnTax();                                         // settle any tax debt\r\n            taxBurnBlock = block.number;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev burnTax is called to burn tax.\r\n    * It removes the CEO if tax is unpaid.\r\n    * 1. deduct tax, update last update\r\n    * 2. if not enough tax, remove & begin auction\r\n    * 3. reward the caller by minting a reward from the amount indebted\r\n    * A Dutch auction begins where the price decreases 10% every hour.\r\n    */\r\n\r\n    function burnTax() external  {\r\n        if (taxBurnBlock == block.number) return;\r\n        if (CEO_state == 1) {\r\n            _burnTax();\r\n            taxBurnBlock = block.number;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev _burnTax burns any tax debt. Boots the CEO if defaulted, paying a reward to the caller\r\n    */\r\n    function _burnTax() internal {\r\n        // calculate tax per block (tpb)\r\n        uint256 tpb = CEO_price / 1000 / CEO_epoch_blocks;       // 0.1% per epoch\r\n        uint256 debt = (block.number - taxBurnBlock) * tpb;\r\n        if (CEO_tax_balance !=0 && CEO_tax_balance >= debt) {    // Does CEO have enough deposit to pay debt?\r\n            CEO_tax_balance = CEO_tax_balance - debt;            // deduct tax\r\n            _burn(address(this), debt);                          // burn the tax\r\n            emit TaxBurned(msg.sender, debt);\r\n        } else {\r\n            // CEO defaulted\r\n            uint256 default_amount = debt - CEO_tax_balance;     // calculate how much defaulted\r\n            _burn(address(this), CEO_tax_balance);               // burn the tax\r\n            emit TaxBurned(msg.sender, CEO_tax_balance);\r\n            CEO_state = 2;                                       // initiate a Dutch auction.\r\n            CEO_tax_balance = 0;\r\n            _transferNFT(The_CEO, address(this));                // This contract holds the NFT temporarily\r\n            The_CEO = address(this);                             // This contract is the \"interim CEO\"\r\n            _mint(msg.sender, default_amount);                   // reward the caller for reporting tax default\r\n            emit CEODefaulted(msg.sender, default_amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev setPrice changes the price for the CEO title.\r\n     * @param _price the price to be paid. The new price most be larger tan MIN_PRICE and not default on debt\r\n     */\r\n    function setPrice(uint256 _price) external onlyCEO  {\r\n        require(CEO_state == 1, \"No CEO in charge\");\r\n        require (_price >= MIN_PRICE, \"price 2 smol\");\r\n        require (CEO_tax_balance >= _price / 1000, \"price would default\"); // need at least 0.1% for tax\r\n        if (block.number != taxBurnBlock) {\r\n            _burnTax();\r\n            taxBurnBlock = block.number;\r\n        }\r\n        // The state is 1 if the CEO hasn't defaulted on tax\r\n        if (CEO_state == 1) {\r\n            CEO_price = _price;                                   // set the new price\r\n            emit CEOPriceChange(_price);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev rewardUp allows the CEO to increase the block rewards by %20\r\n    * Can only be called by the CEO every 2 epochs\r\n    * @return _amount increased by\r\n    */\r\n    function rewardUp() external onlyCEO returns (uint256)  {\r\n        require(CEO_state == 1, \"No CEO in charge\");\r\n        require(block.number > rewardsChangedBlock + (CEO_epoch_blocks*2), \"wait more blocks\");\r\n        require (cigPerBlock < MAX_REWARD, \"reward already max\");\r\n        rewardsChangedBlock = block.number;\r\n        uint256 _amount = cigPerBlock / 5;            // %20\r\n        uint256 _new_reward = cigPerBlock + _amount;\r\n        if (_new_reward > MAX_REWARD) {\r\n            _amount = MAX_REWARD - cigPerBlock;\r\n            _new_reward = MAX_REWARD;                 // cap\r\n        }\r\n        cigPerBlock = _new_reward;\r\n        emit RewardUp(_new_reward, _amount);\r\n        return _amount;\r\n    }\r\n\r\n    /**\r\n    * @dev rewardDown decreases the block rewards by 20%\r\n    * Can only be called by the CEO every 2 epochs\r\n    */\r\n    function rewardDown() external onlyCEO returns (uint256) {\r\n        require(CEO_state == 1, \"No CEO in charge\");\r\n        require(block.number > rewardsChangedBlock + (CEO_epoch_blocks*2), \"wait more blocks\");\r\n        require(cigPerBlock > MIN_REWARD, \"reward already low\");\r\n        rewardsChangedBlock = block.number;\r\n        uint256 _amount = cigPerBlock / 5;            // %20\r\n        uint256 _new_reward = cigPerBlock - _amount;\r\n        if (_new_reward < MIN_REWARD) {\r\n            _amount = cigPerBlock - MIN_REWARD;\r\n            _new_reward = MIN_REWARD;                 // limit\r\n        }\r\n        cigPerBlock = _new_reward;\r\n        emit RewardDown(_new_reward, _amount);\r\n        return _amount;\r\n    }\r\n\r\n    /**\r\n    * @dev _calcDiscount calculates the discount for the CEO title based on how many blocks passed\r\n    */\r\n    function _calcDiscount() internal view returns (uint256) {\r\n        unchecked {\r\n            uint256 d = (CEO_price / 10)           // 10% discount\r\n            // multiply by the number of discounts accrued\r\n            * ((block.number - taxBurnBlock) / CEO_auction_blocks);\r\n            if (d > CEO_price) {\r\n                // overflow assumed, reset to MIN_PRICE\r\n                return MIN_PRICE;\r\n            }\r\n            uint256 price = CEO_price - d;\r\n            if (price < MIN_PRICE) {\r\n                price = MIN_PRICE;\r\n            }\r\n            return price;\r\n        }\r\n    }\r\n\r\n    /*\r\n    * \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac Information used by the UI \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\r\n    */\r\n\r\n    /**\r\n    * @dev getStats helps to fetch some stats for the GUI in a single web3 call\r\n    * @param _user the address to return the report for\r\n    * @return uint256[27] the stats\r\n    * @return address of the current CEO\r\n    * @return bytes32 Current graffiti\r\n    */\r\n    function getStats(address _user) external view returns(uint256[] memory, address, bytes32, uint112[] memory) {\r\n        uint[] memory ret = new uint[](27);\r\n        uint112[] memory reserves = new uint112[](2);\r\n        uint256 tpb = (CEO_price / 1000) / (CEO_epoch_blocks); // 0.1% per epoch\r\n        uint256 debt = (block.number - taxBurnBlock) * tpb;\r\n        uint256 price = CEO_price;\r\n        UserInfo memory info = farmers[_user];\r\n        if (CEO_state == 2) {\r\n            price = _calcDiscount();\r\n        }\r\n        ret[0] = CEO_state;\r\n        ret[1] = CEO_tax_balance;\r\n        ret[2] = taxBurnBlock;                     // the block number last tax burn\r\n        ret[3] = rewardsChangedBlock;              // the block of the last staking rewards change\r\n        ret[4] = price;                            // price of the CEO title\r\n        ret[5] = CEO_punk_index;                   // punk ID of CEO\r\n        ret[6] = cigPerBlock;                      // staking reward per block\r\n        ret[7] = totalSupply;                      // total supply of CIG\r\n        if (address(lpToken) != address(0)) {\r\n            ret[8] = lpToken.balanceOf(address(this)); // Total LP staking\r\n            ret[16] = lpToken.balanceOf(_user);        // not staked by user\r\n            ret[17] = pendingCig(_user);               // pending harvest\r\n            (reserves[0], reserves[1], ) = lpToken.getReserves();        // uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast\r\n            ret[18] = V2ROUTER.getAmountOut(1 ether, uint(reserves[0]), uint(reserves[1])); // CIG price in ETH\r\n            if (isContract(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2))) { // are we on mainnet?\r\n                ILiquidityPoolERC20 ethusd = ILiquidityPoolERC20(address(0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f));  // sushi DAI-WETH pool\r\n                uint112 r0;\r\n                uint112 r1;\r\n                (r0, r1, ) = ethusd.getReserves();\r\n                // get the price of ETH in USD\r\n                ret[19] =  V2ROUTER.getAmountOut(1 ether, uint(r0), uint(r1));      // ETH price in USD\r\n            }\r\n            ret[22] = lpToken.totalSupply();       // total supply\r\n        }\r\n        ret[9] = block.number;                       // current block number\r\n        ret[10] = tpb;                               // \"tax per block\" (tpb)\r\n        ret[11] = debt;                              // tax debt accrued\r\n        ret[12] = lastRewardBlock;                   // the block of the last staking rewards payout update\r\n        ret[13] = info.deposit;                      // amount of LP tokens staked by user\r\n        ret[14] = info.rewardDebt;                   // amount of rewards paid out\r\n        ret[15] = balanceOf[_user];                  // amount of CIG held by user\r\n        ret[20] = accCigPerShare;                    // Accumulated cigarettes per share\r\n        ret[21] = balanceOf[address(punks)];         // amount of CIG to be claimed\r\n        ret[23] = wBal[_user];                       // wrapped cig balance\r\n        ret[24] = OC.balanceOf(_user);               // balance of old cig in old isContract\r\n        ret[25] = OC.allowance(_user, address(this));// is old contract approved\r\n        (ret[26], ) = OC.userInfo(_user);            // old contract stake bal\r\n        return (ret, The_CEO, graffiti, reserves);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * credits https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /*\r\n    * \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac Token distribution and farming stuff \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\r\n    */\r\n\r\n    /**\r\n    * @dev isClaimed checks to see if a punk was claimed\r\n    * @param _punkIndex the punk number\r\n    */\r\n    function isClaimed(uint256 _punkIndex) external view returns (bool) {\r\n        if (claims[_punkIndex]) {\r\n            return true;\r\n        }\r\n        if (OC.claims(_punkIndex)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Claim claims the initial CIG airdrop using a punk\r\n    * @param _punkIndex the index of the punk, number between 0-9999\r\n    */\r\n    function claim(uint256 _punkIndex) external returns(bool) {\r\n        require (CEO_state != 3, \"invalid state\");                            // disabled in migration state\r\n        require (_punkIndex <= 9999, \"invalid punk\");\r\n        require(claims[_punkIndex] == false, \"punk already claimed\");\r\n        require(OC.claims(_punkIndex) == false, \"punk already claimed\");      // claimed in old contract\r\n        require(msg.sender == punks.punkIndexToAddress(_punkIndex), \"punk 404\");\r\n        claims[_punkIndex] = true;\r\n        balanceOf[address(punks)] = balanceOf[address(punks)] - CLAIM_AMOUNT; // deduct from the punks contract\r\n        balanceOf[msg.sender] = balanceOf[msg.sender] + CLAIM_AMOUNT;         // deposit to the caller\r\n        emit Transfer(address(punks), msg.sender, CLAIM_AMOUNT);\r\n        emit Claim(msg.sender, _punkIndex, CLAIM_AMOUNT);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the LP supply, with masterchef deposits taken into account.\r\n    */\r\n    function stakedlpSupply() public view returns(uint256)\r\n    {\r\n        return lpToken.balanceOf(address(this)) + masterchefDeposits;\r\n    }\r\n    /**\r\n    * @dev update updates the accCigPerShare value and mints new CIG rewards to be distributed to LP stakers\r\n    * Credits go to MasterChef.sol\r\n    * Modified the original by removing poolInfo as there is only a single pool\r\n    * Removed totalAllocPoint and pool.allocPoint\r\n    * pool.lastRewardBlock moved to lastRewardBlock\r\n    * There is no need for getMultiplier (rewards are adjusted by the CEO)\r\n    *\r\n    */\r\n    function update() public {\r\n        if (block.number <= lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint256 supply = stakedlpSupply();\r\n        if (supply == 0) {\r\n            lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n        // mint some new cigarette rewards to be distributed\r\n        uint256 cigReward = (block.number - lastRewardBlock) * cigPerBlock;\r\n        _mint(address(this), cigReward);\r\n        accCigPerShare = accCigPerShare + (\r\n        cigReward * 1e12 / supply\r\n        );\r\n        lastRewardBlock = block.number;\r\n    }\r\n\r\n    /**\r\n    * @dev pendingCig displays the amount of cig to be claimed\r\n    * @param _user the address to report\r\n    */\r\n    function pendingCig(address _user) view public returns (uint256) {\r\n        uint256 _acps = accCigPerShare;\r\n        // accumulated cig per share\r\n        UserInfo storage user = farmers[_user];\r\n        uint256 supply = stakedlpSupply();\r\n        if (block.number > lastRewardBlock && supply != 0) {\r\n            uint256 cigReward = (block.number - lastRewardBlock) * cigPerBlock;\r\n            _acps = _acps + (\r\n            cigReward * 1e12 / supply\r\n            );\r\n        }\r\n        return (user.deposit * _acps / 1e12) - user.rewardDebt;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev userInfo is added for compatibility with the Snapshot.org interface.\r\n    */\r\n    function userInfo(uint256, address _user) view external returns (uint256, uint256 depositAmount) {\r\n        return (0,farmers[_user].deposit + farmersMasterchef[_user].deposit);\r\n    }\r\n    /**\r\n    * @dev deposit deposits LP tokens to be staked.\r\n    * @param _amount the amount of LP tokens to deposit. Assumes this contract has been approved for the _amount.\r\n    */\r\n    function deposit(uint256 _amount) external {\r\n        require(_amount != 0, \"You cannot deposit only 0 tokens\"); // Check how many bytes\r\n        UserInfo storage user = farmers[msg.sender];\r\n\r\n        update();\r\n        _deposit(user, _amount);\r\n        require(lpToken.transferFrom(\r\n                address(msg.sender),\r\n                address(this),\r\n                _amount\r\n            ));\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n    \r\n    function _deposit(UserInfo storage _user, uint256 _amount) internal {\r\n        _user.deposit += _amount;\r\n        _user.rewardDebt += _amount * accCigPerShare / 1e12;\r\n    }\r\n    /**\r\n    * @dev withdraw takes out the LP tokens\r\n    * @param _amount the amount to withdraw\r\n    */\r\n    function withdraw(uint256 _amount) external {\r\n        UserInfo storage user = farmers[msg.sender];\r\n        update();\r\n        /* harvest beforehand, so _withdraw can safely decrement their reward count */\r\n        _harvest(user, msg.sender);\r\n        _withdraw(user, _amount);\r\n        /* Interact */\r\n        require(lpToken.transferFrom(\r\n            address(this),\r\n            address(msg.sender),\r\n            _amount\r\n        ));\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n    \r\n    /**\r\n    * @dev Internal withdraw, updates internal accounting after withdrawing LP\r\n    * @param _amount to subtract\r\n    */\r\n    function _withdraw(UserInfo storage _user, uint256 _amount) internal {\r\n        require(_user.deposit >= _amount, \"Balance is too low\");\r\n        _user.deposit -= _amount;\r\n        uint256 _rewardAmount = _amount * accCigPerShare / 1e12;\r\n        _user.rewardDebt -= _rewardAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev harvest redeems pending rewards & updates state\r\n    */\r\n    function harvest() external {\r\n        UserInfo storage user = farmers[msg.sender];\r\n        update();\r\n        _harvest(user, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal harvest\r\n    * @param _to the amount to harvest\r\n    */\r\n    function _harvest(UserInfo storage _user, address _to) internal {\r\n        uint256 potentialValue = (_user.deposit * accCigPerShare / 1e12);\r\n        uint256 delta = potentialValue - _user.rewardDebt;\r\n        safeSendPayout(_to, delta);\r\n        // Recalculate their reward debt now that we've given them their reward\r\n        _user.rewardDebt = _user.deposit * accCigPerShare / 1e12;\r\n        emit Harvest(msg.sender, _to, delta);\r\n    }\r\n\r\n    /**\r\n    * @dev safeSendPayout, just in case if rounding error causes pool to not have enough CIGs.\r\n    * @param _to recipient address\r\n    * @param _amount the value to send\r\n    */\r\n    function safeSendPayout(address _to, uint256 _amount) internal {\r\n        uint256 cigBal = balanceOf[address(this)];\r\n        require(cigBal >= _amount, \"insert more tobacco leaves...\");\r\n        unchecked {\r\n            balanceOf[address(this)] = balanceOf[address(this)] - _amount;\r\n            balanceOf[_to] = balanceOf[_to] + _amount;\r\n        }\r\n        emit Transfer(address(this), _to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev emergencyWithdraw does a withdraw without caring about rewards. EMERGENCY ONLY.\r\n    */\r\n    function emergencyWithdraw() external {\r\n        UserInfo storage user = farmers[msg.sender];\r\n        uint256 amount = user.deposit;\r\n        user.deposit = 0;\r\n        user.rewardDebt = 0;\r\n        // Interact\r\n        require(lpToken.transfer(\r\n                address(msg.sender),\r\n                amount\r\n            ));\r\n        emit EmergencyWithdraw(msg.sender, amount);\r\n    }\r\n\r\n    /*\r\n    * \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac Migration \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\r\n    */\r\n\r\n    /**\r\n    * @dev renounceOwnership burns the admin key, so this contract is unruggable\r\n    */\r\n    function renounceOwnership() external onlyAdmin {\r\n        admin = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev setStartingBlock sets the starting block for LP staking rewards\r\n    * Admin only, used only for initial configuration.\r\n    * @param _startBlock the block to start rewards for\r\n    */\r\n    function setStartingBlock(uint256 _startBlock) external onlyAdmin {\r\n        lastRewardBlock = _startBlock;\r\n    }\r\n\r\n    /**\r\n    * @dev setPool address to an LP pool. Only Admin. (used only in testing/deployment)\r\n    */\r\n    function setPool(ILiquidityPoolERC20 _addr) external onlyAdmin {\r\n        require(address(lpToken) == address(0), \"pool already set\");\r\n        lpToken = _addr;\r\n    }\r\n\r\n    /**\r\n    * @dev setReward sets the reward. Admin only (used only in testing/deployment)\r\n    */\r\n    function setReward(uint256 _value) public onlyAdmin {\r\n        cigPerBlock = _value;\r\n    }\r\n\r\n    /**\r\n    * @dev migrationComplete completes the migration\r\n    */\r\n    function migrationComplete() external  {\r\n        require (CEO_state == 3);\r\n        require (OC.CEO_state() == 1);\r\n        require (block.number > lastRewardBlock, \"cannot end migration yet\");\r\n        CEO_state = 1;                         // CEO is in charge state\r\n        OC.burnTax();                          // before copy, burn the old CEO's tax\r\n        /* copy the state over to this contract */\r\n        _mint(address(punks), OC.balanceOf(address(punks))); // CIG to be set aside for the remaining airdrop\r\n        uint256 taxDeposit = OC.CEO_tax_balance();\r\n        The_CEO = OC.The_CEO();                // copy the CEO\r\n        if (taxDeposit > 0) {                  // copy the CEO's outstanding tax\r\n            _mint(address(this), taxDeposit);  // mint tax that CEO had locked in previous contract (cannot be migrated)\r\n            CEO_tax_balance =  taxDeposit;\r\n        }\r\n        taxBurnBlock = OC.taxBurnBlock();\r\n        CEO_price = OC.CEO_price();\r\n        graffiti = OC.graffiti();\r\n        CEO_punk_index = OC.CEO_punk_index();\r\n        cigPerBlock = STARTING_REWARDS;        // set special rewards\r\n        lastRewardBlock = OC.lastRewardBlock();// start rewards\r\n        rewardsChangedBlock = OC.rewardsChangedBlock();\r\n        /* Historical records */\r\n        _transferNFT(\r\n            address(0),\r\n            address(0x1e32a859d69dde58d03820F8f138C99B688D132F)\r\n        );\r\n        emit NewCEO(\r\n            address(0x1e32a859d69dde58d03820F8f138C99B688D132F),\r\n            0x00000000000000000000000000000000000000000000000000000000000015c9,\r\n            0x000000000000000000000000000000000000000000007618fa42aac317900000,\r\n            0x41732043454f2049206465636c617265204465632032322050756e6b20446179\r\n        );\r\n        _transferNFT(\r\n            address(0x1e32a859d69dde58d03820F8f138C99B688D132F),\r\n            address(0x72014B4EEdee216E47786C4Ab27Cc6344589950d)\r\n        );\r\n        emit NewCEO(\r\n            address(0x72014B4EEdee216E47786C4Ab27Cc6344589950d),\r\n            0x0000000000000000000000000000000000000000000000000000000000000343,\r\n            0x00000000000000000000000000000000000000000001a784379d99db42000000,\r\n            0x40617a756d615f626974636f696e000000000000000000000000000000000000\r\n        );\r\n        _transferNFT(\r\n            address(0x72014B4EEdee216E47786C4Ab27Cc6344589950d),\r\n            address(0x4947DA4bEF9D79bc84bD584E6c12BfFa32D1bEc8)\r\n        );\r\n        emit NewCEO(\r\n            address(0x4947DA4bEF9D79bc84bD584E6c12BfFa32D1bEc8),\r\n            0x00000000000000000000000000000000000000000000000000000000000007fa,\r\n            0x00000000000000000000000000000000000000000014adf4b7320334b9000000,\r\n            0x46697273742070756e6b7320746f6b656e000000000000000000000000000000\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev wrap wraps old CIG and issues new CIG 1:1\r\n    * @param _value how much old cig to wrap\r\n    */\r\n    function wrap(uint256 _value) external {\r\n        require (CEO_state == 3);\r\n        OC.transferFrom(msg.sender, address(this), _value); // transfer old cig to here\r\n        _mint(msg.sender, _value);                          // give user new cig\r\n        wBal[msg.sender] = wBal[msg.sender] + _value;       // record increase of wrapped old cig for caller\r\n    }\r\n\r\n    /**\r\n    * @dev unwrap unwraps old CIG and burns new CIG 1:1\r\n    */\r\n    function unwrap(uint256 _value) external {\r\n        require (CEO_state == 3);\r\n        _burn(msg.sender, _value);                          // burn new cig\r\n        OC.transfer(msg.sender, _value);                    // give back old cig\r\n        wBal[msg.sender] = wBal[msg.sender] - _value;       // record decrease of wrapped old cig for caller\r\n    }\r\n    /*\r\n    * \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac ERC20 Token stuff \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\r\n    */\r\n\r\n    /**\r\n    * @dev burn some tokens\r\n    * @param _from The address to burn from\r\n    * @param _amount The amount to burn\r\n    */\r\n    function _burn(address _from, uint256 _amount) internal {\r\n        balanceOf[_from] = balanceOf[_from] - _amount;\r\n        totalSupply = totalSupply - _amount;\r\n        emit Transfer(_from, address(0), _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev mint new tokens\r\n   * @param _to The address to mint to.\r\n   * @param _amount The amount to be minted.\r\n   */\r\n    function _mint(address _to, uint256 _amount) internal {\r\n        require(_to != address(0), \"ERC20: mint to the zero address\");\r\n        unchecked {\r\n            totalSupply = totalSupply + _amount;\r\n            balanceOf[_to] = balanceOf[_to] + _amount;\r\n        }\r\n        emit Transfer(address(0), _to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        //require(_value <= balanceOf[msg.sender], \"value exceeds balance\"); // SafeMath already checks this\r\n        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\r\n        balanceOf[_to] = balanceOf[_to] + _value;\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n    public\r\n    returns (bool)\r\n    {\r\n        uint256 a = allowance[_from][msg.sender]; // read allowance\r\n        //require(_value <= balanceOf[_from], \"value exceeds balance\"); // SafeMath already checks this\r\n        if (a != type(uint256).max) {             // not infinite approval\r\n            require(_value <= a, \"not approved\");\r\n            unchecked {\r\n                allowance[_from][msg.sender] = a - _value;\r\n            }\r\n        }\r\n        balanceOf[_from] = balanceOf[_from] - _value;\r\n        balanceOf[_to] = balanceOf[_to] + _value;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve tokens of mount _value to be spent by _spender\r\n    * @param _spender address The spender\r\n    * @param _value the stipend to spend\r\n    */\r\n    function approve(address _spender, uint256 _value) external returns (bool) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    * \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac Masterchef v2 integration \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\r\n    */\r\n\r\n    /**\r\n    * @dev onSushiReward implements the SushiSwap masterchefV2 callback, guarded by the onlyMCV2 modifier\r\n    * @param _user address called on behalf of\r\n    * @param _to address who send rewards to\r\n    * @param _sushiAmount uint256, if not 0 then the rewards will be harvested\r\n    * @param _newLpAmount uint256, amount of LP tokens staked at Sushi\r\n    */\r\n    function onSushiReward (\r\n        uint256 /* pid */,\r\n        address _user,\r\n        address _to,\r\n        uint256 _sushiAmount,\r\n        uint256 _newLpAmount)  external onlyMCV2 {\r\n        UserInfo storage user = farmersMasterchef[_user];\r\n        update();\r\n        // Harvest sushi when there is sushiAmount passed through as this only comes in the event of the masterchef contract harvesting\r\n        if(_sushiAmount != 0) _harvest(user, _to); // send outstanding CIG to _to\r\n        uint256 delta;\r\n        // Withdraw stake\r\n        if(user.deposit >= _newLpAmount) { // Delta is withdraw\r\n            delta = user.deposit - _newLpAmount;\r\n            masterchefDeposits -= delta;   // subtract from staked total\r\n            _withdraw(user, delta);\r\n            emit ChefWithdraw(_user, delta);\r\n        }\r\n        // Deposit stake\r\n        else if(user.deposit != _newLpAmount) { // Delta is deposit\r\n            delta = _newLpAmount - user.deposit;\r\n            masterchefDeposits += delta;        // add to staked total\r\n            _deposit(user, delta);\r\n            emit ChefDeposit(_user, delta);\r\n        }\r\n    }\r\n\r\n    // onlyMCV2 ensures only the MasterChefV2 contract can call this\r\n    modifier onlyMCV2 {\r\n        require(\r\n            msg.sender == MASTERCHEF_V2,\r\n            \"Only MCV2\"\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n/*\r\n* \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac interfaces \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\r\n*/\r\n\r\n/**\r\n* @dev IRouterV2 is the sushi router 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F\r\n*/\r\ninterface IRouterV2 {\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external pure returns(uint256 amountOut);\r\n}\r\n\r\n/**\r\n* @dev ICryptoPunk used to query the cryptopunks contract to verify the owner\r\n*/\r\ninterface ICryptoPunk {\r\n    //function balanceOf(address account) external view returns (uint256);\r\n    function punkIndexToAddress(uint256 punkIndex) external returns (address);\r\n    //function punksOfferedForSale(uint256 punkIndex) external returns (bool, uint256, address, uint256, address);\r\n    //function buyPunk(uint punkIndex) external payable;\r\n    //function transferPunk(address to, uint punkIndex) external;\r\n}\r\n\r\ninterface ICEOERC721 {\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n}\r\n\r\n/*\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * 0xTycoon was here\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n* @dev from UniswapV2Pair.sol\r\n*/\r\ninterface ILiquidityPoolERC20 is IERC20 {\r\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\r\n    function totalSupply() external view returns(uint);\r\n}\r\n\r\ninterface IOldCigtoken is IERC20 {\r\n    function claims(uint256) external view returns (bool);\r\n    function graffiti() external view returns (bytes32);\r\n    function cigPerBlock() external view returns (uint256);\r\n    function The_CEO() external view returns (address);\r\n    function CEO_punk_index() external view returns (uint);\r\n    function CEO_price() external view returns (uint256);\r\n    function CEO_state() external view returns (uint256);\r\n    function CEO_tax_balance() external view returns (uint256);\r\n    function taxBurnBlock() external view returns (uint256);\r\n    function lastRewardBlock() external view returns (uint256);\r\n    function rewardsChangedBlock() external view returns (uint256);\r\n    function userInfo(address) external view returns (uint256, uint256);\r\n    function burnTax() external;\r\n}\r\n\r\n// \ud83d\udeac", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cigPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_punks\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_CEO_epoch_blocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_CEO_auction_blocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_CEO_price\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_graffiti\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_NFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_V2ROUTER\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_OC\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_migration_epochs\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_MASTERCHEF_V2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"called_by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"CEODefaulted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"CEOPriceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ChefDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ChefWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"punkIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"punk_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"new_price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"graffiti\",\"type\":\"bytes32\"}],\"name\":\"NewCEO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RevenueBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"downAmount\",\"type\":\"uint256\"}],\"name\":\"RewardDown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"upAmount\",\"type\":\"uint256\"}],\"name\":\"RewardUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TaxBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TaxDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CEO_price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CEO_punk_index\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CEO_state\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CEO_tax_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"The_CEO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accCigPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_max_spend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_new_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tax_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_punk_index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_graffiti\",\"type\":\"bytes32\"}],\"name\":\"buyCEO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cigPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_punkIndex\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claims\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"farmers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"farmersMasterchef\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getStats\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint112[]\",\"name\":\"\",\"type\":\"uint112[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"graffiti\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_punkIndex\",\"type\":\"uint256\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpToken\",\"outputs\":[{\"internalType\":\"contract ILiquidityPoolERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterchefDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrationComplete\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sushiAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newLpAmount\",\"type\":\"uint256\"}],\"name\":\"onSushiReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingCig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"punks\",\"outputs\":[{\"internalType\":\"contract ICryptoPunk\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardDown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardUp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsChangedBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILiquidityPoolERC20\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"name\":\"setStartingBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedlpSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxBurnBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"unwrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wBal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"wrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Cig", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "2000000", "ConstructorArguments": "00000000000000000000000000000000000000000000001bc16d674ec8000000000000000000000000000000b47e3cd837ddf8e4c57f05d70ab865de6e193bbb0000000000000000000000000000000000000000000000000000000000001c200000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000a968163f0a57b40000068656c6c6f20776f726c64000000000000000000000000000000000000000000000000000000000000000000e0de149facf51aeb4b48a8b94a3c388f6720ed70000000000000000000000000d9e1ce17f2641f24ae83637ab66a2cca9c378b9f0000000000000000000000005a35a6686db167b05e2eb74e1ede9fb5d9cdb3e0000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000ef0881ec094552b2e128cf945ef17a6752b4ec5d", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://51741ae0275bf63b35d9cd243f70961ea7a7f7e545e5cfb3ed1a6b33bdb394c3"}]}