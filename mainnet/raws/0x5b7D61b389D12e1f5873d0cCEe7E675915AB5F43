{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/protocols/arbitrum/balances/main.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.6;\\npragma experimental ABIEncoderV2;\\n\\ninterface TokenInterface {\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function decimals() external view returns (uint256);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n}\\n\\ncontract Resolver {\\n    struct TokenData {\\n        bool isToken;\\n        string name;\\n        string symbol;\\n        uint256 decimals;\\n    }\\n\\n    function getTokenDetails(address[] memory tknAddress) public view returns (TokenData[] memory) {\\n        TokenData[] memory tokenDatas = new TokenData[](tknAddress.length);\\n        for (uint256 i = 0; i < tknAddress.length; i++) {\\n            if (tknAddress[i] == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\\n                tokenDatas[i] = TokenData(true, \\\"ETHER\\\", \\\"ETH\\\", 18);\\n            } else {\\n                TokenInterface token = TokenInterface(tknAddress[i]);\\n                bool isToken = true;\\n\\n                try token.symbol() {} catch {\\n                    isToken = false;\\n                    continue;\\n                }\\n\\n                try token.name() {} catch {\\n                    isToken = false;\\n                    continue;\\n                }\\n\\n                try token.decimals() {} catch {\\n                    isToken = false;\\n                    continue;\\n                }\\n\\n                tokenDatas[i] = TokenData(true, token.name(), token.symbol(), token.decimals());\\n            }\\n        }\\n        return tokenDatas;\\n    }\\n\\n    struct BalanceData {\\n        address owner;\\n        address[] tokens;\\n    }\\n\\n    struct BalanceReturnData {\\n        address owner;\\n        uint256[] balances;\\n    }\\n\\n    function getBalancesOfOwnersWithTokens(BalanceData[] memory datas)\\n        public\\n        view\\n        returns (BalanceReturnData[] memory)\\n    {\\n        BalanceReturnData[] memory balanceReturnData = new BalanceReturnData[](datas.length);\\n        for (uint256 i = 0; i < datas.length; i++) {\\n            balanceReturnData[i].owner = datas[i].owner;\\n            balanceReturnData[i].balances = getBalances(datas[i].owner, datas[i].tokens);\\n        }\\n        return balanceReturnData;\\n    }\\n\\n    function getBalancesOfOwners(address[] memory owners, address[] memory tokens)\\n        public\\n        view\\n        returns (BalanceReturnData[] memory)\\n    {\\n        BalanceReturnData[] memory balanceReturnData = new BalanceReturnData[](owners.length);\\n        for (uint256 i = 0; i < owners.length; i++) {\\n            balanceReturnData[i].owner = owners[i];\\n            balanceReturnData[i].balances = getBalances(owners[i], tokens);\\n        }\\n        return balanceReturnData;\\n    }\\n\\n    function getBalances(address owner, address[] memory tknAddress) public view returns (uint256[] memory) {\\n        uint256[] memory tokensBal = new uint256[](tknAddress.length);\\n        for (uint256 i = 0; i < tknAddress.length; i++) {\\n            if (tknAddress[i] == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\\n                tokensBal[i] = owner.balance;\\n            } else {\\n                TokenInterface token = TokenInterface(tknAddress[i]);\\n                tokensBal[i] = token.balanceOf(owner);\\n            }\\n        }\\n        return tokensBal;\\n    }\\n\\n    function getAllowances(\\n        address owner,\\n        address spender,\\n        address[] memory tknAddress\\n    ) public view returns (uint256[] memory) {\\n        uint256[] memory tokenAllowances = new uint256[](tknAddress.length);\\n        for (uint256 i = 0; i < tknAddress.length; i++) {\\n            if (tknAddress[i] == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\\n                tokenAllowances[i] = 0;\\n            } else {\\n                TokenInterface token = TokenInterface(tknAddress[i]);\\n                tokenAllowances[i] = token.allowance(owner, spender);\\n            }\\n        }\\n        return tokenAllowances;\\n    }\\n}\\n\\ncontract InstaERC20Resolver is Resolver {\\n    string public constant name = \\\"ERC20-Resolver-v1.2\\\";\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tknAddress\",\"type\":\"address[]\"}],\"name\":\"getAllowances\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tknAddress\",\"type\":\"address[]\"}],\"name\":\"getBalances\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getBalancesOfOwners\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"internalType\":\"struct Resolver.BalanceReturnData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"internalType\":\"struct Resolver.BalanceData[]\",\"name\":\"datas\",\"type\":\"tuple[]\"}],\"name\":\"getBalancesOfOwnersWithTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"internalType\":\"struct Resolver.BalanceReturnData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tknAddress\",\"type\":\"address[]\"}],\"name\":\"getTokenDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isToken\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"internalType\":\"struct Resolver.TokenData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "InstaERC20Resolver", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}