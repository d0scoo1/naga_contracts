{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.11;\r\n\r\ninterface IVault {\r\n\tfunction token() external view returns (address);\r\n}\r\n\r\ninterface IRegistry {\r\n\tfunction numVaults(address) external view returns (uint256);\r\n\tfunction vaults(address, uint256) external view returns (address);\r\n    function isRegistered(address) external view returns (bool);\r\n}\r\n\r\ninterface IAddressesProvider {\r\n\tfunction addressById(string memory) external view returns (address);\r\n}\r\n\r\ninterface IRegistryAdapter {\r\n\tfunction registryAddress() external view returns (address);\r\n}\r\n\r\ncontract AllowlistImplementationPartnerTracker {\r\n\taddress constant public partnerTracker = 0x8ee392a4787397126C163Cb9844d7c447da419D8;\r\n\taddress public addressesProviderAddress;\r\n\r\n\tconstructor(address _addressesProviderAddress) {\r\n\t\taddressesProviderAddress = _addressesProviderAddress;\r\n\t}\r\n\r\n\t/**\r\n\t* @notice Determine whether the address is yearn's deployed partner tracker contract\r\n\t* @param _address the address to validate\r\n\t* @return returns true if the input is the partner tracker\r\n\t*/\r\n\tfunction isPartnerTracker(address _address) external view returns (bool) {\r\n\t\treturn _address == partnerTracker;\r\n\t}\r\n\r\n\t/**\r\n\t* @notice Determine whether or not a vault address is a valid vault\r\n\t* @param vaultAddress The vault address to test\r\n\t* @return Returns true if the valid address is valid and false if not\r\n\t*/\r\n\tfunction isVault(address vaultAddress) public view returns (bool) {\r\n\t\tIVault vault = IVault(vaultAddress);\r\n\t\taddress tokenAddress;\r\n\t\ttry vault.token() returns (address _tokenAddress) {\r\n\t\t\ttokenAddress = _tokenAddress;\r\n\t\t} catch {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tuint256 numVaults = registry().numVaults(tokenAddress);\r\n\t\tfor (uint256 vaultIdx; vaultIdx < numVaults; vaultIdx++) {\r\n\t\t\taddress currentVaultAddress = registry().vaults(tokenAddress, vaultIdx);\r\n\t\t\tif (currentVaultAddress == vaultAddress) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @notice Determine whether or not a vault address is a valid vault\r\n\t * @param tokenAddress The vault token address to test\r\n\t * @return Returns true if the valid address is valid and false if not\r\n\t */\r\n\tfunction isVaultUnderlyingToken(address tokenAddress)\r\n\t  public\r\n\t  view\r\n\t  returns (bool)\r\n\t{\r\n\t  return registry().isRegistered(tokenAddress);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Fetch registry adapter address\r\n\t*/\r\n\tfunction registryAdapterAddress() public view returns (address) {\r\n\t\treturn\r\n\t\t\tIAddressesProvider(addressesProviderAddress).addressById(\r\n\t\t\t\t\"REGISTRY_ADAPTER_V2_VAULTS\"\r\n\t  \t\t);\r\n  \t}\r\n\r\n\t/**\r\n\t* @dev Fetch registry adapter interface\r\n\t*/\r\n\tfunction registryAdapter() internal view returns (IRegistryAdapter) {\r\n\t\treturn IRegistryAdapter(registryAdapterAddress());\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Fetch registry address\r\n\t*/\r\n\tfunction registryAddress() public view returns (address) {\r\n\t\treturn registryAdapter().registryAddress();\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Fetch registry interface\r\n\t*/\r\n\tfunction registry() internal view returns (IRegistry) {\r\n\t\treturn IRegistry(registryAddress());\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressesProviderAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"addressesProviderAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isPartnerTracker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"}],\"name\":\"isVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"isVaultUnderlyingToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partnerTracker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registryAdapterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AllowlistImplementationPartnerTracker", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e11dc9f2ab122dc5978eaca41483da0d7d7e6128", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://853cc2cb4733f5ed39b573a142a321745285e7f986eb3e83c2597f7a5f93c70b"}]}