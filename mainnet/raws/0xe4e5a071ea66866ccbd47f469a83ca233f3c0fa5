{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: Witness Protected\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns (uint256);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ninterface IUniswapFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapRouter01 {\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getamountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getamountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getamountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getamountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapRouter02 is IUniswapRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\ncontract Protected {\r\n\r\n    mapping (address => bool) is_auth;\r\n\r\n    function authorized(address addy) public view returns(bool) {\r\n        return is_auth[addy];\r\n    }\r\n\r\n    function set_authorized(address addy, bool booly) public onlyAuth {\r\n        is_auth[addy] = booly;\r\n    }\r\n\r\n    modifier onlyAuth() {\r\n        require( is_auth[msg.sender] || msg.sender==owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    address owner;\r\n    modifier onlyOwner() {\r\n        require(msg.sender==owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    bool locked;\r\n    modifier safe() {\r\n        require(!locked, \"reentrant\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    receive() external payable {}\r\n    fallback() external payable {}\r\n}\r\n\r\n\r\ninterface UniswapV2Pair {\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n}\r\n\r\n\r\ninterface AggregatorInterface {\r\n  function latestAnswer() external view returns (int256);\r\n  function latestTimestamp() external view returns (uint256);\r\n  function latestRound() external view returns (uint256);\r\n  function getAnswer(uint256 roundId) external view returns (int256);\r\n  function getTimestamp(uint256 roundId) external view returns (uint256);\r\n\r\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\r\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\r\n{\r\n}\r\n\r\ncontract smart_dex is Protected {\r\n\r\n    ////////////////// Basic definitions //////////////////\r\n\r\n    address middleware;    \r\n\r\n    event open_position(address token, uint limit_price, uint qty, bytes32 direction, bool executed);\r\n    address public constant Dead = 0x000000000000000000000000000000000000dEaD;\r\n    IUniswapFactory factory;\r\n    IUniswapRouter02 router;\r\n\r\n    mapping(address => uint) order_cooldown;\r\n    uint cooldown_value;\r\n\r\n    address aggregator = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\r\n    AggregatorV2V3Interface usd_price;\r\n\r\n    ////////////////// Structures and data //////////////////\r\n\r\n    struct positions {\r\n        address token;\r\n        address actor;\r\n        uint qty;\r\n        uint price_limit;\r\n        bytes32 action;\r\n        bool active;\r\n    }\r\n\r\n    mapping(address => mapping(uint => positions)) actor_positions;\r\n    mapping(uint => address) position_owner;\r\n    mapping(address => uint[]) owned_positions;\r\n    uint last_position;\r\n\r\n\r\n    ////////////////// Constructor //////////////////\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        router = IUniswapRouter02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        factory = IUniswapFactory(router.factory());\r\n        usd_price = AggregatorV2V3Interface(aggregator);\r\n    }\r\n\r\n    ////////////////// Settings //////////////////\r\n\r\n    function set_middleware(address addy) public onlyAuth {\r\n        middleware = addy;\r\n    }\r\n\r\n    ////////////////// Public write functions //////////////////\r\n\r\n    function set_limit_buy(address token, uint limit_price, uint qty) payable public safe { \r\n        require(order_cooldown[msg.sender] < block.timestamp, \"Sheesh, calm down\");       \r\n        uint required_price = get_price(token, qty);\r\n        uint fee = required_price/100;\r\n        required_price = (required_price) + (fee);\r\n        require(msg.value >= required_price);\r\n        set_position(token, limit_price, msg.value, \"limit_buy\", msg.sender);\r\n        order_cooldown[msg.sender] = block.timestamp + cooldown_value;\r\n    }\r\n\r\n    function set_limit_sell(address token, uint limit_price, uint qty) public safe {\r\n        require(order_cooldown[msg.sender] < block.timestamp, \"Sheesh, calm down\");       \r\n        ERC20 coin = ERC20(token);\r\n        require(coin.balanceOf(msg.sender) >= qty, \"Not enough tokens\");\r\n        require(coin.allowance(msg.sender, address(this)) >= qty, \"Not enough allowance\");\r\n        coin.transferFrom(msg.sender, address(this), qty);\r\n        set_position(token, limit_price, qty, \"limit_sell\", msg.sender);\r\n        order_cooldown[msg.sender] = block.timestamp + cooldown_value;\r\n    }\r\n\r\n    function rescue() public onlyAuth{\r\n        (bool sent,) =msg.sender.call{value: (address(this).balance)}(\"\");\r\n        require(sent);\r\n    }\r\n\r\n    ////////////////// Private write functions //////////////////\r\n\r\n\r\n    function set_position(address token, uint limit_price, uint qty, bytes32 direction, address sender) private {\r\n        last_position += 1;\r\n        actor_positions[sender][last_position].token = token;\r\n        actor_positions[sender][last_position].actor = sender;\r\n        actor_positions[sender][last_position].action = \"buy_limit\";\r\n        actor_positions[sender][last_position].qty = qty;\r\n        actor_positions[sender][last_position].price_limit = limit_price;\r\n        actor_positions[sender][last_position].active = true;\r\n        owned_positions[sender].push(last_position);\r\n        position_owner[last_position] = sender;\r\n        emit open_position(token, limit_price, qty, direction, false);\r\n    }\r\n\r\n    function execute_buy(uint position) private {\r\n        address actor = position_owner[position];\r\n        address token = actor_positions[actor][position].token;\r\n        uint qty = actor_positions[actor][position].qty;\r\n        address[] memory path = new address[](2);\r\n        path[0] = router.WETH();\r\n        path[1] = token;\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: qty}(0, path, actor, block.timestamp);\r\n        actor_positions[actor][position].active = false;\r\n    }\r\n\r\n    function execute_sell(uint position) private {\r\n        address actor = position_owner[position];\r\n        address token = actor_positions[actor][position].token;\r\n        uint qty = actor_positions[actor][position].qty;\r\n        address[] memory path = new address[](2);\r\n        path[0] = token;\r\n        path[1] = router.WETH();\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(qty, 0, path, actor, block.timestamp);  \r\n        actor_positions[actor][position].active = false;      \r\n    }\r\n\r\n    ////////////////// Public view functions //////////////////\r\n    \r\n    // calculate price based on pair reserves (in ETH per 1 token)\r\n   function get_price(address tkn, uint amount) public view returns(uint)\r\n   {\r\n    address pair = factory.getPair(router.WETH(), tkn);\r\n    UniswapV2Pair pair_interface = UniswapV2Pair(pair);\r\n    (uint Res0, uint Res1,) = pair_interface.getReserves();\r\n    // decimals\r\n    uint res0 = Res0*(10**ERC20(tkn).decimals());\r\n    uint eth_answer = (amount*res0)/Res1;\r\n    return(eth_answer); // return amount of token0 needed to buy token1\r\n   }\r\n\r\n   function price_in_dollars(uint eth_answer) public view returns(uint) {\r\n    int current_usd = (usd_price.latestAnswer())/(10**8);\r\n    uint usd_answer = (uint(current_usd) * eth_answer);\r\n    return(usd_answer);\r\n   }\r\n\r\n    function get_positions(address actor) public view returns(uint[] memory) {\r\n        return owned_positions[actor];\r\n    }\r\n\r\n    function get_single_position(uint pos) public view returns(positions memory) {\r\n        address owner_of = position_owner[pos];\r\n        return actor_positions[owner_of][pos];\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit_price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"direction\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"open_position\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"Dead\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"actor\",\"type\":\"address\"}],\"name\":\"get_positions\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"get_price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"get_single_position\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"actor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price_limit\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"action\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct smart_dex.positions\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eth_answer\",\"type\":\"uint256\"}],\"name\":\"price_in_dollars\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"set_authorized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"limit_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"}],\"name\":\"set_limit_buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"limit_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"}],\"name\":\"set_limit_sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"set_middleware\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "smart_dex", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3472c4d10f701ed9b40d8fffcd2cd03586527eee7a5fe106a33edfe0eaf7a038"}]}