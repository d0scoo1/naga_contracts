{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/NFTDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"base64-sol/base64.sol\\\";\\n\\nlibrary NFTDescriptor {\\n    using Strings for uint256;\\n\\n    struct ConstructTokenParams {\\n        uint256 tokenId;\\n        string imageURL;\\n        string animationURL;\\n        string externalURL;\\n    }\\n\\n    struct ConstructContractURIParams {\\n        string imageURL;\\n        string description;\\n        string externalURL;\\n        address payable royaltiesRecipient;\\n        uint256 royaltiesFeeBasisPoints; // Royalties fee in basis point\\n    }\\n\\n    function TokenURIParamsCtor(\\n        string calldata imageURL,\\n        string calldata animationURL,\\n        string calldata externalURL\\n    ) public pure returns (ConstructTokenParams memory params) {\\n        params.imageURL = imageURL;\\n        params.animationURL = animationURL;\\n        params.externalURL = externalURL;\\n        return params;\\n    }\\n\\n    function ConstructContractURIParamsCtor(\\n        string calldata imageURL,\\n        string calldata description,\\n        string calldata externalURL,\\n        address payable _royaltiesRecipient,\\n        uint256 _royaltiesFeeBasisPoints\\n    ) public pure returns (ConstructContractURIParams memory params) {\\n        params.imageURL = imageURL;\\n        params.description = description;\\n        params.externalURL = externalURL;\\n        params.royaltiesRecipient = _royaltiesRecipient;\\n        params.royaltiesFeeBasisPoints = _royaltiesFeeBasisPoints; // Royalties fee in basis point\\n        return params;\\n    }\\n\\n    function constructTokenURI(ConstructTokenParams memory params, string memory name)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory _name = generateName(params.tokenId, name);\\n        string memory description = generateDescription(params.tokenId, name);\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:application/json;base64,\\\",\\n                    Base64.encode(\\n                        bytes(\\n                            abi.encodePacked(\\n                                '{\\\"name\\\":\\\"',\\n                                _name,\\n                                '\\\", \\\"description\\\":\\\"',\\n                                description,\\n                                generateExternalUrl(params.externalURL),\\n                                '\\\", \\\"image\\\":\\\"',\\n                                generateImagesLink(params.imageURL, params.animationURL),\\n                                '\\\"}'\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    function constructContractURI(ConstructContractURIParams memory params, string memory contractName)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        uint256 sfbp = params.royaltiesFeeBasisPoints;\\n        address feeRecipient = params.royaltiesRecipient;\\n\\n        return\\n            string(abi.encodePacked(\\n                                '{\\\"name\\\":\\\"',\\n                                contractName,\\n                                '\\\", \\\"description\\\":\\\"',\\n                                params.description,\\n                                generateExternalUrl(params.externalURL),\\n                                '\\\", \\\"image\\\":\\\"',\\n                                generateImagesLink(params.imageURL, \\\"\\\"),\\n                                '\\\", \\\"seller_fee_basis_points\\\":\\\"',\\n                                sfbp.toString(),\\n                                '\\\", \\\"fee_recipient\\\":\\\"',\\n                                addressToString(feeRecipient),\\n                                '\\\"}'\\n                            )\\n            );\\n    }\\n\\n    function generateExternalUrl(string memory externalURL) internal pure returns (string memory) {\\n        if (bytes(externalURL).length > 0) return string(abi.encodePacked('\\\", \\\"external_url\\\": \\\"', externalURL));\\n        return \\\"\\\";\\n    }\\n\\n    function generateImagesLink(string memory imageURL, string memory animationURL)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        // if animation URL is not set\\n        if (bytes(animationURL).length > 0)\\n            return string(abi.encodePacked(imageURL, '\\\", \\\"animation_url\\\": \\\"', animationURL));\\n        // return only the imageURL\\n        return imageURL;\\n    }\\n\\n    function escapeQuotes(string memory symbol) internal pure returns (string memory) {\\n        bytes memory symbolBytes = bytes(symbol);\\n        uint8 quotesCount = 0;\\n        for (uint8 i = 0; i < symbolBytes.length; i++) {\\n            if (symbolBytes[i] == '\\\"') {\\n                quotesCount++;\\n            }\\n        }\\n        if (quotesCount > 0) {\\n            bytes memory escapedBytes = new bytes(symbolBytes.length + (quotesCount));\\n            uint256 index;\\n            for (uint8 i = 0; i < symbolBytes.length; i++) {\\n                if (symbolBytes[i] == '\\\"') {\\n                    escapedBytes[index++] = \\\"\\\\\\\\\\\";\\n                }\\n                escapedBytes[index++] = symbolBytes[i];\\n            }\\n            return string(escapedBytes);\\n        }\\n        return symbol;\\n    }\\n\\n    function generateDescription(uint256 tokenId, string memory contractName) private pure returns (string memory) {\\n        return string(abi.encodePacked(contractName, \\\" - \\\", tokenId.toString(), unicode\\\"\u00ba\\\")); // TODO make it binary with \u00aa\\n    }\\n\\n    function generateName(uint256 tokenId, string memory contractName) private pure returns (string memory) {\\n        return string(abi.encodePacked(contractName, \\\" - \\\", tokenId.toString()));\\n    }\\n\\n    function addressToString(address addr) internal pure returns (string memory) {\\n        return (uint256(uint160(addr))).toHexString(20);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"imageURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"externalURL\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"_royaltiesRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_royaltiesFeeBasisPoints\",\"type\":\"uint256\"}],\"name\":\"ConstructContractURIParamsCtor\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"imageURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"externalURL\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"royaltiesRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesFeeBasisPoints\",\"type\":\"uint256\"}],\"internalType\":\"struct NFTDescriptor.ConstructContractURIParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"imageURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"animationURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"externalURL\",\"type\":\"string\"}],\"name\":\"TokenURIParamsCtor\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"imageURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"animationURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"externalURL\",\"type\":\"string\"}],\"internalType\":\"struct NFTDescriptor.ConstructTokenParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"imageURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"externalURL\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"royaltiesRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesFeeBasisPoints\",\"type\":\"uint256\"}],\"internalType\":\"struct NFTDescriptor.ConstructContractURIParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"constructContractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"imageURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"animationURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"externalURL\",\"type\":\"string\"}],\"internalType\":\"struct NFTDescriptor.ConstructTokenParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"constructTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "NFTDescriptor", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}