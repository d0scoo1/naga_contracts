{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/mainnet/OrcsFix.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.7;\\n\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"./ERC721-Orcs.sol\\\"; \\n\\nimport \\\"../interfaces/Interfaces.sol\\\";\\n\\n//    ___ _   _               ___            \\n//  | __| |_| |_  ___ _ _   / _ \\\\ _ _ __ ___\\n//  | _||  _| ' \\\\/ -_) '_| | (_) | '_/ _(_-<\\n//  |___|\\\\__|_||_\\\\___|_|    \\\\___/|_| \\\\__/__/\\n//\\n\\ncontract OrcsFix is ERC721O {\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    Global STATE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant  cooldown = 10 minutes;\\n    uint256 internal constant  startingTime = 1633951800 + 4.5 hours;\\n\\n    address internal migrator;\\n\\n    bytes32 internal entropySauce;\\n\\n    ERC20 internal zug;\\n\\n    mapping (address => bool)     internal auth;\\n    mapping (uint256 => Orc)      internal orcs;\\n    mapping (uint256 => Action)   internal activities;\\n    mapping (Places  => LootPool) internal lootPools;\\n    \\n    uint256 mintedFromThis = 0;\\n    bool mintOpen = false;\\n\\n    MetadataHandlerLike internal metadaHandler;\\n    address internal raids = 0x47DC8e20C15f6deAA5cBFeAe6cf9946aCC89af59;\\n    mapping(bytes4 => address) implementer;\\n\\n    address constant impl = 0x3CE5Aa4Bb4c8058A8458bc5F55208Df318Cf1177;\\n\\n    address internal castle;\\n\\n    event ActionMade(address owner, uint256 id, uint256 timestamp, uint8 activity);\\n\\n\\n    /*///////////////////////////////////////////////////////////////\\n                DATA STRUCTURES \\n    //////////////////////////////////////////////////////////////*/\\n\\n    struct LootPool { \\n        uint8  minLevel; uint8  minLootTier; uint16  cost;   uint16 total;\\n        uint16 tier_1;   uint16 tier_2;      uint16 tier_3; uint16 tier_4;\\n    }\\n\\n    struct Orc { uint8 body; uint8 helm; uint8 mainhand; uint8 offhand; uint16 level; uint16 zugModifier; uint32 lvlProgress; }\\n\\n    enum   Actions { UNSTAKED, FARMING, TRAINING }\\n    struct Action  { address owner; uint88 timestamp; Actions action; }\\n\\n    // These are all the places you can go search for loot\\n    enum Places { \\n        TOWN, DUNGEON, CRYPT, CASTLE, DRAGONS_LAIR, THE_ETHER, \\n        TAINTED_KINGDOM, OOZING_DEN, ANCIENT_CHAMBER, ORC_GODS \\n    }   \\n\\n    function fix() external {\\n        require(msg.sender == admin);\\n        \\n        // Do whatever needs fixing\\n        ownerOf[778] = 0x3aBEDBA3052845CE3f57818032BFA747CDED3fca;\\n        implementation_ = impl;\\n\\n    }\\n\\n\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    FALLBACK HANDLER \\n    //////////////////////////////////////////////////////////////*/\\n\\n\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n    \\n\\n    fallback() external {\\n        if(implementer[msg.sig] == address(0)) {\\n            _delegate(impl);\\n        } else {\\n            _delegate(implementer[msg.sig]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.7;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// Taken from Solmate: https://github.com/Rari-Capital/solmate\\n\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function name() external view virtual returns (string memory);\\n    function symbol() external view virtual returns (string memory);\\n    function decimals() external view virtual returns (uint8);\\n\\n    // string public constant name     = \\\"ZUG\\\";\\n    // string public constant symbol   = \\\"ZUG\\\";\\n    // uint8  public constant decimals = 18;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    mapping(address => bool) public isMinter;\\n\\n    address public ruler;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor() { ruler = msg.sender;}\\n\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        allowance[msg.sender][spender] = value;\\n\\n        emit Approval(msg.sender, spender, value);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external returns (bool) {\\n        balanceOf[msg.sender] -= value;\\n\\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(msg.sender, to, value);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool) {\\n        if (allowance[from][msg.sender] != type(uint256).max) {\\n            allowance[from][msg.sender] -= value;\\n        }\\n\\n        balanceOf[from] -= value;\\n\\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(from, to, value);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             ORC PRIVILEGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mint(address to, uint256 value) external {\\n        require(isMinter[msg.sender], \\\"FORBIDDEN TO MINT\\\");\\n        _mint(to, value);\\n    }\\n\\n    function burn(address from, uint256 value) external {\\n        require(isMinter[msg.sender], \\\"FORBIDDEN TO BURN\\\");\\n        _burn(from, value);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         Ruler Function\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setMinter(address minter, bool status) external {\\n        require(msg.sender == ruler, \\\"NOT ALLOWED TO RULE\\\");\\n\\n        isMinter[minter] = status;\\n    }\\n\\n    function setRuler(address ruler_) external {\\n        require(msg.sender == ruler ||ruler == address(0), \\\"NOT ALLOWED TO RULE\\\");\\n\\n        ruler = ruler_;\\n    }\\n\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          INTERNAL UTILS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply += value;\\n\\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] -= value;\\n\\n        // This is safe because a user won't ever\\n        // have a balance larger than totalSupply!\\n        unchecked {\\n            totalSupply -= value;\\n        }\\n\\n        emit Transfer(from, address(0), value);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/mainnet/ERC721-Orcs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.7;\\n\\n/// @notice Modern and gas efficient ERC-721 + ERC-20/EIP-2612-like implementation,\\n/// including the MetaData, and partially, Enumerable extensions.\\ncontract ERC721O {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    \\n    event Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\\n    \\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    \\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    address        implementation_;\\n    address public admin; //Lame requirement from opensea\\n    \\n    /*///////////////////////////////////////////////////////////////\\n                             ERC-721 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n    uint256 public oldSupply;\\n    uint256 public minted;\\n    \\n    mapping(address => uint256) public balanceOf;\\n    \\n    mapping(uint256 => address) public ownerOf;\\n        \\n    mapping(uint256 => address) public getApproved;\\n \\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             VIEW FUNCTION\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function owner() external view returns (address) {\\n        return admin;\\n    }\\n    \\n    /*///////////////////////////////////////////////////////////////\\n                              ERC-20-LIKE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    function transfer(address to, uint256 tokenId) external {\\n        require(msg.sender == ownerOf[tokenId], \\\"NOT_OWNER\\\");\\n        \\n        _transfer(msg.sender, to, tokenId);\\n        \\n    }\\n    \\n    /*///////////////////////////////////////////////////////////////\\n                              ERC-721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool supported) {\\n        supported = interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;\\n    }\\n    \\n    function approve(address spender, uint256 tokenId) external {\\n        address owner_ = ownerOf[tokenId];\\n        \\n        require(msg.sender == owner_ || isApprovedForAll[owner_][msg.sender], \\\"NOT_APPROVED\\\");\\n        \\n        getApproved[tokenId] = spender;\\n        \\n        emit Approval(owner_, spender, tokenId); \\n    }\\n    \\n    function setApprovalForAll(address operator, bool approved) external {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n        \\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public {        \\n        require(\\n            msg.sender == from \\n            || msg.sender == getApproved[tokenId]\\n            || isApprovedForAll[from][msg.sender], \\n            \\\"NOT_APPROVED\\\"\\n        );\\n        \\n        _transfer(from, to, tokenId);\\n        \\n    }\\n    \\n    function safeTransferFrom(address from, address to, uint256 tokenId) external {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n    \\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {\\n        transferFrom(from, to, tokenId); \\n        \\n        if (to.code.length != 0) {\\n            // selector = `onERC721Received(address,address,uint,bytes)`\\n            (, bytes memory returned) = to.staticcall(abi.encodeWithSelector(0x150b7a02,\\n                msg.sender, address(0), tokenId, data));\\n                \\n            bytes4 selector = abi.decode(returned, (bytes4));\\n            \\n            require(selector == 0x150b7a02, \\\"NOT_ERC721_RECEIVER\\\");\\n        }\\n    }\\n    \\n    /*///////////////////////////////////////////////////////////////\\n                          INTERNAL UTILS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _transfer(address from, address to, uint256 tokenId) internal {\\n        require(ownerOf[tokenId] == from, \\\"not owner\\\");\\n\\n        balanceOf[from]--; \\n        balanceOf[to]++;\\n        \\n        delete getApproved[tokenId];\\n        \\n        ownerOf[tokenId] = to;\\n        emit Transfer(from, to, tokenId); \\n\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal { \\n        require(ownerOf[tokenId] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        totalSupply++;\\n        \\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to]++;\\n        }\\n        \\n        ownerOf[tokenId] = to;\\n                \\n        emit Transfer(address(0), to, tokenId); \\n    }\\n    \\n    function _burn(uint256 tokenId) internal { \\n        address owner_ = ownerOf[tokenId];\\n        \\n        require(ownerOf[tokenId] != address(0), \\\"NOT_MINTED\\\");\\n        \\n        totalSupply--;\\n        balanceOf[owner_]--;\\n        \\n        delete ownerOf[tokenId];\\n                \\n        emit Transfer(owner_, address(0), tokenId); \\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.7;\\n\\ninterface OrcishLike {\\n    function pull(address owner, uint256[] calldata ids) external;\\n    function manuallyAdjustOrc(uint256 id, uint8 body, uint8 helm, uint8 mainhand, uint8 offhand, uint16 level, uint16 zugModifier, uint32 lvlProgress) external;\\n    function transfer(address to, uint256 tokenId) external;\\n    function orcs(uint256 id) external view returns(uint8 body, uint8 helm, uint8 mainhand, uint8 offhand, uint16 level, uint16 zugModifier, uint32 lvlProgress);\\n    function allies(uint256 id) external view returns (uint8 class, uint16 level, uint32 lvlProgress, uint16 modF, uint8 skillCredits, bytes22 details);\\n    function adjustAlly(uint256 id, uint8 class_, uint16 level_, uint32 lvlProgress_, uint16 modF_, uint8 skillCredits_, bytes22 details_) external;\\n}\\n\\ninterface PortalLike {\\n    function sendMessage(bytes calldata message_) external;\\n}\\n\\ninterface OracleLike {\\n    function request() external returns (uint64 key);\\n    function getRandom(uint64 id) external view returns(uint256 rand);\\n}\\n\\ninterface MetadataHandlerLike {\\n    function getTokenURI(uint16 id, uint8 body, uint8 helm, uint8 mainhand, uint8 offhand, uint16 level, uint16 zugModifier) external view returns (string memory);\\n}\\n\\ninterface MetadataHandlerAllies {\\n    function getTokenURI(uint256 id_, uint256 class_, uint256 level_, uint256 modF_, uint256 skillCredits_, bytes22 details_) external view returns (string memory);\\n}\\n\\ninterface RaidsLike {\\n    function stakeManyAndStartCampaign(uint256[] calldata ids_, address owner_, uint256 location_, bool double_) external;\\n    function startCampaignWithMany(uint256[] calldata ids, uint256 location_, bool double_) external;\\n    function commanders(uint256 id) external returns(address);\\n    function unstake(uint256 id) external;\\n}\\n\\ninterface RaidsLikePoly {\\n    function stakeManyAndStartCampaign(uint256[] calldata ids_, address owner_, uint256 location_, bool double_, uint256[] calldata potions_) external;\\n    function startCampaignWithMany(uint256[] calldata ids, uint256 location_, bool double_,  uint256[] calldata potions_) external;\\n    function commanders(uint256 id) external returns(address);\\n    function unstake(uint256 id) external;\\n}\\n\\ninterface CastleLike {\\n    function pullCallback(address owner, uint256[] calldata ids) external;\\n}\\n\\ninterface EtherOrcsLike {\\n    function ownerOf(uint256 id) external view returns (address owner_);\\n    function activities(uint256 id) external view returns (address owner, uint88 timestamp, uint8 action);\\n    function orcs(uint256 orcId) external view returns (uint8 body, uint8 helm, uint8 mainhand, uint8 offhand, uint16 level, uint16 zugModifier, uint32 lvlProgress);\\n}\\n\\ninterface ERC20Like {\\n    function balanceOf(address from) external view returns(uint256 balance);\\n    function burn(address from, uint256 amount) external;\\n    function mint(address from, uint256 amount) external;\\n    function transfer(address to, uint256 amount) external;\\n}\\n\\ninterface ERC1155Like {\\n    function mint(address to, uint256 id, uint256 amount) external;\\n    function burn(address from, uint256 id, uint256 amount) external;\\n}\\n\\ninterface ERC721Like {\\n    function transferFrom(address from, address to, uint256 id) external;   \\n    function transfer(address to, uint256 id) external;\\n    function ownerOf(uint256 id) external returns (address owner);\\n    function mint(address to, uint256 tokenid) external;\\n}\\n\\ninterface HallOfChampionsLike {\\n    function joined(uint256 orcId) external view returns (uint256 joinDate);\\n} \\n\\ninterface AlliesLike {\\n    function allies(uint256 id) external view returns (uint8 class, uint16 level, uint32 lvlProgress, uint16 modF, uint8 skillCredits, bytes22 details);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"activity\",\"type\":\"uint8\"}],\"name\":\"ActionMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"supported\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OrcsFix", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}